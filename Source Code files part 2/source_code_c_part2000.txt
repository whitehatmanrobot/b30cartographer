0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000000000000000100000031F0003C1C8F109A19CB2E000080000032A0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C80003C1C8F109A19CB2E03F80000000000000000000000000000000004000026B0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFA87D3FFF553921FFBC7535FF917A51FF553921FFAAA6C9FF553921FF5F4294FF5F42940000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401CE0003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000A90001C1C8F109A19CB2E0001000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000001000A90001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401CE0003C1C8F109A19CB2E00004000000000000000000000000000000000000003A40C8300C03090000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000000000000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002FF0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF6E4124FF1F120BFFB56157FF243F53FF1F120BFF5395CAFF1F120BFF5F4294FF5F42940000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401BD0003C1C8F109A19CB2E0000400000000000000000000000000000000000803CD0002C1C8F109A19CB2E00008000000000000000000000000000000000010015F0002C1C8F109A19CB2E0001000000000000000000000000000000000002003C60002C1C8F109A19CB2E0002000000000000000000000000000000000088001890002C1C8F109A19CB2E0088000000000000000000000000000000000020001950002C1C8F109A19CB2E0020000000000000000000000000000000000004000024103C1110123FFFFBAAA004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002003C60002C1C8F109A19CB2E00020000000000000000000000000000000000010015F0002C1C8F109A19CB2E0001000000000000000000000000000000000000803CD0002C1C8F109A19CB2E0000800000000000000000000000000000000000401BD0003C1C8F109A19CB2E000040000000000000000000000000000E00029DC48A7CBF8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000000000000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002EC0003C1C8F109A19CB2E00000000000000000000000000000000000002000028A0003C1C8F109A19CB2E00000000000000000000000000000000000004000026F0003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000003050003C1C8F109A19CB2E000000000000000000000000000000000FFE6BC8EFF553921FFCB6758FF727F35FF553921FF904F33FF1F120BFFAD5F47FFAD5F470000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402490003C1C8F109A19CB2E0000400000000000000000000000000000000004001A30002C1C8F109A19CB2E00040000000000000000000000000000000800218017F0002C1C8F109A19CB2E0021800000000000000000000000000000000002001020002C1C8F109A19CB2E0002000000000000000000000000000000000080001AD0002C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001020002C1C8F109A19CB2E00020000000000000000000000000000000000010016C0002C1C8F109A19CB2E0001000000000000000000000000000000000000801140002C1C8F109A19CB2E0000800000000000000000000000000000000000402490003C1C8F109A19CB2E000040000000000000000000000000000E00133335A84AA3A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000000000000000100000031F0003C1C8F109A19CB2E000080000032D0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F80000000000000000000000000000000002000027A0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F8000000000000000000000000000000001000002DE0001C1C8F109A19CB2E03F80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF4F463DFFE58995FF88B049FF4F463DFFFFE2A3FF4F463DFF66BCDCFF66BCDC0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004021D0003C1C8F109A19CB2E0000400000000000000000000000000000000000800610001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800610001C1C8F109A19CB2E00008000000000000000000000000000000000004021D0003C1C8F109A19CB2E000040000000000000000000000000000E0009B14FA65D63A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000000000000000100000031F0003C1C8F109A19CB2E000080000032F0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AE0003C1C8F109A19CB2E03F80000000000000000000000000000000004000026E0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF64411BFF92340EFF83463FFF312114FF92340EFFF3BC7BFF92340EFF5F4294FF5F42940000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F40003C1C8F109A19CB2E00004000000000000000000000000000000000008011E0002C1C8F109A19CB2E0000800000000000000000000000000000000001001700002C1C8F109A19CB2E00010000000000000000000000000000000000020010C0002C1C8F109A19CB2E0002000000000000000000000000000000000040005000002C1C8F109A19CB2E0040000000000000000000000000000000000080001A80002C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010C0002C1C8F109A19CB2E0002000000000000000000000000000000000001001700002C1C8F109A19CB2E00010000000000000000000000000000000000008011E0002C1C8F109A19CB2E0000800000000000000000000000000000000000401F40003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000000000000000100000031F0003C1C8F109A19CB2E00008000003300003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F80000000000000000000000000000000002000029E0003C1C8F109A19CB2E03F80000000000000000000000000000000004000026D0003C1C8F109A19CB2E0000000000000000000000000000000000001000002D80001C1C8F109A19CB2E00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE3A976FF6E5326FFCF8562FF6381A7FF6E5326FF000000FF6E5326FFD75F47FFD75F470000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402570003C1C8F109A19CB2E00004000000000000000000000000000000000020002C0001C1C8F109A19CB2E00020000000000000000000000000000000000208005B0001C1C8F109A19CB2E0020800000000000000000000000000000000001003CF0001C1C8F109A19CB2E00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002C0001C1C8F109A19CB2E0002000000000000000000000000000000000001003CF0001C1C8F109A19CB2E0001000000000000000000000000000000000000800890001C1C8F109A19CB2E000080000FFFF0000FF00FF00FF0000FF0000000402570003C1C8F109A19CB2E000040000000000000000000000000000E000D287FAB1F406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000000000000000100000031F0003C1C8F109A19CB2E00008000003320003C1C8F109A19CB2E00020000003350003C1C8F109A19CB2E00000800002F80003C1C8F109A19CB2E0000000000000000000000000000000000000200002880003C1C8F109A19CB2E0000000000000000000000000000000000000400002720003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF8E8274FF000000FFAB0207FFE2DEDDFFFEC854FF8E8274FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000020003C0001C1C8F109A19CB2E0002000000000000000000000000000000000000401AE0003C1C8F109A19CB2E0000400000000000000000000000000000080021800B10001C1C8F109A19CB2E002180000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003C0001C1C8F109A19CB2E00020000000000000000000000000000000000010009C0001C1C8F109A19CB2E0001000000000000000000000000000000000000800650001C1C8F109A19CB2E0000800000000000000000000000000000000000401AE0003C1C8F109A19CB2E000040000000000000000000000000000E0000D5C48A4F55C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000000000000000100000031F0003C1C8F109A19CB2E00008000003330003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E0000000000000000000000000000000000000200002C60003C1C8F109A19CB2E00000000000000000000000000000000000004000026D0003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF98652FFF553921FFF5686BFF5B351EFF553921FFC1A590FF553921FF66BCDCFF66BCDC0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000020002C0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A90001C1C8F109A19CB2E0001000000000000000000000000000000000000800480001C1C8F109A19CB2E000080000FFD72909FFD72909FFD729090000000401DC0003C1C8F109A19CB2E00004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002C0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A90001C1C8F109A19CB2E0001000000000000000000000000000000000000800480001C1C8F109A19CB2E000080000FFD72909FFD72909FFD729090000000401DC0003C1C8F109A19CB2E000040000000000000000000000000000E0001315FABF2452000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000000000000000100000031F0003C1C8F109A19CB2E00008000003340003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F80000000000000000000000000000000002000028C0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002640003C1C8F109A19CB2E03F8000000000000000000000000000000001000002E40001C1C8F109A19CB2E03F80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF906636FF9F5D69FF82501DFF906636FFA2A89BFF906636FF66BCDCFF66BCDC0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004025D0003C1C8F109A19CB2E0000400000000000000000000000000000000000800500001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000370001C1C8F109A19CB2E0002000000000000000000000000000000000004000E40001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000370001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800500001C1C8F109A19CB2E00008000000000000000000000000000000000004025D0003C1C8F109A19CB2E000040000000000000000000000000000E0028485AE6C976E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E00008000003260003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002F60003C1C8F109A19CB2E03F8000000000000000000000000000000000200002BA0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002610003C1C8F109A19CB2E03F8000000000000000000000000000000001000002DB0001C1C8F109A19CB2E03F80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF682618FFD00E0EFF312114FF682618FFF3BC7BFF682618FFAD5F47FFAD5F470000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401CE0003C1C8F109A19CB2E00004000000000000000000000000000000000008004B0001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000008004B0001C1C8F109A19CB2E0000800000000000000000000000000000000000401CE0003C1C8F109A19CB2E000040000000000000000000000000000E001676FFABB9F80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            //"0x0000000000000000000000000010000003200003C1C8F109A19CB2E00008000003280003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002F60003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A00003C1C8F109A19CB2E03F8000000000000000000000000000000000400002690003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF6E4124FF0D0D0DFFB56157FF2A72A4FF0D0D0DFF6A3919FF0D0D0DFF4D5523FF4D55230000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401D70003C1C8F109A19CB2E00004000000000000000000000000000000000008004F0001C1C8F109A19CB2E0000800000000000000000000000000000000001000960001C1C8F109A19CB2E0001000000000000000000000000000000000002000300001C1C8F109A19CB2E0002000000000000000000000000000000000010000CA0001C1C8F109A19CB2E001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000300001C1C8F109A19CB2E0002000000000000000000000000000000000001000960001C1C8F109A19CB2E00010000000000000000000000000000000000008004F0001C1C8F109A19CB2E0000800000000000000000000000000000000000401D70003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", --suspected invalid manifest
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E00008000003280003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002F60003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A00003C1C8F109A19CB2E03F8000000000000000000000000000000000400002690003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF6E4124FF0D0D0DFFB56157FF2A72A4FF0D0D0DFF6A3919FF0D0D0DFF4D5523FF4D55230000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401D70003C1C8F109A19CB2E00004000000000000000000000000000000000008004F0001C1C8F109A19CB2E0000800000000000000000000000000000000001000960001C1C8F109A19CB2E0001000000000000000000000000000000000002000300001C1C8F109A19CB2E0002000000000000000000000000000000000010000CA0001C1C8F109A19CB2E0010000000000000000000000000000000000100040EB72C3C9599B9E5553083B1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000300001C1C8F109A19CB2E0002000000000000000000000000000000000001000960001C1C8F109A19CB2E00010000000000000000000000000000000000008004F0001C1C8F109A19CB2E0000800000000000000000000000000000000000401D70003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E000080000032A0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C60003C1C8F109A19CB2E03F80000000000000000000000000000000004000026B0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FF753E1FFFE58995FF37512AFF753E1FFFC08950FF753E1FFF8B8B8BFF8B8B8B0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401EA0003C1C8F109A19CB2E0000400000000000000000000000000000000000800650001C1C8F109A19CB2E00008000000000000000000000000000000000010009E0001C1C8F109A19CB2E0001000000000000000000000000000000000002000380001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000380001C1C8F109A19CB2E00020000000000000000000000000000000000010009E0001C1C8F109A19CB2E0001000000000000000000000000000000000000800650001C1C8F109A19CB2E0000800000000000000000000000000000000000401EA0003C1C8F109A19CB2E000040000000000000000000000000000E0005654D854819C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002BA0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002690003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF64411BFF1F120BFFB14A37FF312114FF1F120BFFA9CEF0FF1F120BFF8ABF55FF8ABF550000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004021D0003C1C8F109A19CB2E0000400000000000000000000000000000000000800600001C1C8F109A19CB2E00008000000000000000000000000000000000010008F0001C1C8F109A19CB2E0001000000000000000000000000000000000002000320001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000320001C1C8F109A19CB2E00020000000000000000000000000000000000010008F0001C1C8F109A19CB2E0001000000000000000000000000000000000000800600001C1C8F109A19CB2E00008000000000000000000000000000000000004021D0003C1C8F109A19CB2E000040000000000000000000000000000E0012B54AE6C976E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E000080000032D0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002D00003C1C8F109A19CB2E03F80000000000000000000000000000000004000026B0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF98652FFF523436FF83463FFF212121FF523436FF776DD3FF523436FF8B8B8BFF8B8B8B0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401DE0003C1C8F109A19CB2E0000400000000000000000000000000000000000800610001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000020003A0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003A0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800610001C1C8F109A19CB2E0000800000000000000000000000000000000000401DE0003C1C8F109A19CB2E000040000000000000000000000000000E000124648262340000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E000080000032D0003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C60003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7B971FF906636FFB14A37FF92B2CAFF906636FF61701FFFBD934BFF2AB0ABFF2AB0AB0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000000401CC0003C1C8F109A19CB2E00004000000000000000000000000000000000208005A0001C1C8F109A19CB2E0020800000000000000000000000000000000002000330001C1C8F109A19CB2E0002000000000000000000000000000000000080000F50001C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000330001C1C8F109A19CB2E0002000000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000000800480001C1C8F109A19CB2E000080000FF804000FF804000FF8040000000000401CC0003C1C8F109A19CB2E000040000000000000000000000000000E0000CE6AE7915A8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E000080000032E0003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002F00003C1C8F109A19CB2E03F8000000000000000000000000000000000200002B40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026C0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE3A976FF0D0D0DFF83463FFF5B351EFF0D0D0DFFC1C335FF0D0D0DFFD13927FFD139270000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401D70003C1C8F109A19CB2E0000400000000000000000000000000000000000800440001C1C8F109A19CB2E0000800000000000000000000000000000000001000A70001C1C8F109A19CB2E00010000000000000000000000000000000000020003B0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003B0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000000800440001C1C8F109A19CB2E0000800000000000000000000000000000000000401D70003C1C8F109A19CB2E000040000000000000000000000000000E00008BBAEE443FC000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E000080000032F0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EF0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C60003C1C8F109A19CB2E03F8000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE3A976FF988054FFEFC28BFF243F53FF988054FF9A2F7DFF988054FF8C603AFF8C603A0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B00003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000A90001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000A90001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000000401B00003C1C8F109A19CB2E000040000000000000000000000000000E000E1E548A4FAB0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E00008000003330003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A00003C1C8F109A19CB2E03F8000000000000000000000000000000000400002690003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE3A976FF553921FFCF8562FF5B351EFF553921FF000000FF553921FF81271FFF81271F0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401D70003C1C8F109A19CB2E00004000000000000000000000000000000000008008B0001C1C8F109A19CB2E0000800000000000000000000000000000000001000970001C1C8F109A19CB2E0001000000000000000000000000000000000002000320001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000320001C1C8F109A19CB2E0002000000000000000000000000000000000001000970001C1C8F109A19CB2E00010000000000000000000000000000000000008008B0001C1C8F109A19CB2E0000800000000000000000000000000000000000401D70003C1C8F109A19CB2E000040000000000000000000000000000E0000743AE6B6522000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E00008000003330003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CC0003C1C8F109A19CB2E03F80000000000000000000000000000000004000026C0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FF0D0D0DFFAD2D2DFF2A72A4FF0D0D0DFFA2A89BFF0D0D0DFF2AB0ABFF2AB0AB0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004023B0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000002000300001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000300001C1C8F109A19CB2E0002000000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004023B0003C1C8F109A19CB2E000040000000000000000000000000000E0006F07FABB5A30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003200003C1C8F109A19CB2E00008000003340003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F8000000000000000000000000000000000200002860003C1C8F109A19CB2E03F8000000000000000000000000000000000400002630003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE3A976FFE4D381FFC65265FF6381A7FFE4D381FFF3BC7BFFE4D381FFAA7C65FFAA7C650000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401C40003C1C8F109A19CB2E0000400000000000000000000000000000000000800610001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800610001C1C8F109A19CB2E0000800000000000000000000000000000000000401C40003C1C8F109A19CB2E000040000000000000000000000000000E00050C7D856461E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003210003C1C8F109A19CB2E00008000003260003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002F90003C1C8F109A19CB2E03F8000000000000000000000000000000000200002860003C1C8F109A19CB2E03F80000000000000000000000000000000004000026D0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7B971FF906636FFF5686BFF92B2CAFF906636FF631A46FF906636FFFFFFFFFFFFFFFF0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401FA0003C1C8F109A19CB2E0000400000000000000000000000000000000000801230002C1C8F109A19CB2E0000800000000000000000000000000000000001001700002C1C8F109A19CB2E0001000000000000000000000000000000000002003C60002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002003C60002C1C8F109A19CB2E0002000000000000000000000000000000000001001700002C1C8F109A19CB2E0001000000000000000000000000000000000000801230002C1C8F109A19CB2E0000800000000000000000000000000000000000401FA0003C1C8F109A19CB2E000040000000000000000000000000000E00004FB4874744E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003210003C1C8F109A19CB2E00008000003260003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002FC0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C80003C1C8F109A19CB2E03F8000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FFDCB74FFFD59282FF82501DFFDCB74FFFB2B05DFFDCB74FFF8C603AFF8C603A0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402040003C1C8F109A19CB2E0000400000000000000000000000000000000002000FC0002C1C8F109A19CB2E0002000000000000000000000000000000000020001950002C1C8F109A19CB2E0020000000000000000000000000000000000040004FF0002C1C8F109A19CB2E0040000000000000000000000000000000080001801710002C1C8F109A19CB2E000180000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000FC0002C1C8F109A19CB2E00020000000000000000000000000000000000010016A0002C1C8F109A19CB2E00010000000000000000000000000000000000008011B0002C1C8F109A19CB2E0000800000000000000000000000000000000000402040003C1C8F109A19CB2E0000400000000000000000000000000000000000000705EC6300C03090000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003210003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EE0003C1C8F109A19CB2E0000000000000000000000000000000000000200002B40003C1C8F109A19CB2E0000000000000000000000000000000000000400002600003C1C8F109A19CB2E00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000002B50003C1C8F109A19CB2E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF1F120BFFECA853FF37512AFF553921FFA9CEF0FF553921FFE18417FFE184170000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402490003C1C8F109A19CB2E00004000000000000000000000000000000800218017F0002C1C8F109A19CB2E0021800000000000000000000000000000000002001070002C1C8F109A19CB2E0002000000000000000000000000000000000010003C30002C1C8F109A19CB2E0010000000000000000000000000000000000080001AA0002C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001070002C1C8F109A19CB2E00020000000000000000000000000000000000010015F0002C1C8F109A19CB2E0001000000000000000000000000000000000000801300002C1C8F109A19CB2E0000800000000000000000000000000000000000402490003C1C8F109A19CB2E000040000000000000000000000000000E0002C3BAE24021E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003210003C1C8F109A19CB2E000080000032F0003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E0000000000000000000000000000000000000200002B20003C1C8F109A19CB2E0000000000000000000000000000000000000400002600003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF372116FF5C3B2CFF312114FF372116FF195381FF553921FFD75F47FFD75F470000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402210003C1C8F109A19CB2E0000400000000000000000000000000000000000801340002C1C8F109A19CB2E0000800000000000000000000000000000000001001670002C1C8F109A19CB2E0001000000000000000000000000000000000002001040002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001040002C1C8F109A19CB2E0002000000000000000000000000000000000001001670002C1C8F109A19CB2E0001000000000000000000000000000000000000801340002C1C8F109A19CB2E0000800000000000000000000000000000000000402210003C1C8F109A19CB2E000040000000000000000000000000000E001881C5A70DD5A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003210003C1C8F109A19CB2E000080000032F0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F8000000000000000000000000000000000200002BE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF493421FFB56157FFAE9843FF493421FF631A46FF493421FFB24F7DFFB24F7D0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402040003C1C8F109A19CB2E0000400000000000000000000000000000000000803D90002C1C8F109A19CB2E00008000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002000FD0002C1C8F109A19CB2E0002000000000000000000000000000000000040003D60002C1C8F109A19CB2E004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000FD0002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000803D90002C1C8F109A19CB2E0000800000000000000000000000000000000000402040003C1C8F109A19CB2E000040000000000000000000000000000E0001553AE905AEC000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003210003C1C8F109A19CB2E000080000032F0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002EC0003C1C8F109A19CB2E0000000000000000000000000000000000000200002C20003C1C8F109A19CB2E00000000000000000000000000000000000004000026A0003C1C8F109A19CB2E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000003090003C1C8F109A19CB2E000000000000000000000000000000000FFD7AA71FFBD934BFF83463FFF8F7497FFBD934BFF6A3919FF745131FFD75F47FFD75F470000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000020801240002C1C8F109A19CB2E0020800000000000000000000000000000000001003D30002C1C8F109A19CB2E0001000000000000000000000000000000000002001020002C1C8F109A19CB2E0002000000000000000000000000000000000010003C30002C1C8F109A19CB2E0010000000000000000000000000000000000040004EC0002C1C8F109A19CB2E0040000000000000000000000000000000000000401FC0003C1C8F109A19CB2E00004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001020002C1C8F109A19CB2E0002000000000000000000000000000000000001003D30002C1C8F109A19CB2E00010000000000000000000000000000000000008011C0002C1C8F109A19CB2E0000800000000000000000000000000000000000401FC0003C1C8F109A19CB2E000040000000000000000000000000000E003D0A7D85C28B0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003210003C1C8F109A19CB2E00008000003300003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000027A0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E0000000000000000000000000000000000001000002E10001C1C8F109A19CB2E00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FFBFA783FFF5686BFF37512AFF85541AFFB2B05DFF906636FF399251FF3992510000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000010000BE0001C1C8F109A19CB2E00100000000000000000000000000000000000004023B0003C1C8F109A19CB2E0000400000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000008004F0001C1C8F109A19CB2E0000800000000000000000000000000000000002000310001C1C8F109A19CB2E000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E00010000000000000000000000000000000000008004F0001C1C8F109A19CB2E00008000000000000000000000000000000000004023B0003C1C8F109A19CB2E000040000000000000000000000000000E0000F39AE78C5AE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000000010000003210003C1C8F109A19CB2E00008000003340003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002F90003C1C8F109A19CB2E0000000000000000000000000000000000000200002980003C1C8F109A19CB2E00000000000000000000000000000000000004000026A0003C1C8F109A19CB2E03F80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000002990003C1C8F109A19CB2E00000000000000000000000000000000000020000030E0003C1C8F109A19CB2E000000000000000000000000000000000FFD7AA71FF0D0D0DFF5C3B2CFF5B351EFF493421FF631A46FF493421FF81271FFF81271F0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402270003C1C8F109A19CB2E00004000000000000000000000000000000000010016B0002C1C8F109A19CB2E0001000000000000000000000000000000000002000FC0002C1C8F109A19CB2E0002000000000000000000000000000000000000801220002C1C8F109A19CB2E0000800000000000000000000000000000000004001970002C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000FC0002C1C8F109A19CB2E00020000000000000000000000000000000000010016B0002C1C8F109A19CB2E0001000000000000000000000000000000000000801220002C1C8F109A19CB2E0000800000000000000000000000000000000000402270003C1C8F109A19CB2E000040000000000000000000000000000E00018B9FA637CD0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031A0003C1C8F109A19CB2E00008000003240003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002F60003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026C0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF906636FFCB6758FF82501DFF906636FF9A2F7DFF906636FFFFFFFFFFFFFFFF0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401D70003C1C8F109A19CB2E00004000000000000000000000000000000000008004B0001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000390001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000390001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E00010000000000000000000000000000000000008004B0001C1C8F109A19CB2E0000800000000000000000000000000000000000401D70003C1C8F109A19CB2E000040000000000000000000000000000E0002DA2AE7CCE0E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031A0003C1C8F109A19CB2E00008000003280003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002F00003C1C8F109A19CB2E03F80000000000000000000000000000000002000027A0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002690003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFA87D3FFF523436FFFD6A68FF212121FF523436FF6E50A4FF523436FFB24F7DFFB24F7D0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000800610001C1C8F109A19CB2E0000800000000000000000000000000000000001000A90001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E00020000000000000000000000000000000000004020A0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000A90001C1C8F109A19CB2E0001000000000000000000000000000000000000800610001C1C8F109A19CB2E00008000000000000000000000000000000000004020A0003C1C8F109A19CB2E000040000000000000000000000000000E00009FEFA663BF2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032A0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002D20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026C0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FF493421FF83463FFF917A51FF493421FFB37D59FF493421FFECB6BEFFECB6BE0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F20003C1C8F109A19CB2E0000400000000000000000000000000000000000800500001C1C8F109A19CB2E0000800000000000000000000000000000000001000960001C1C8F109A19CB2E00010000000000000000000000000000000000020003C0001C1C8F109A19CB2E0002000000000000000000000000000000000010000C60001C1C8F109A19CB2E0010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003C0001C1C8F109A19CB2E0002000000000000000000000000000000000001000960001C1C8F109A19CB2E0001000000000000000000000000000000000000800500001C1C8F109A19CB2E0000800000000000000000000000000000000000401F20003C1C8F109A19CB2E000040000000000000000000000000000E003BDD4AE6C976E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032A0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F8000000000000000000000000000000000200002860003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FF6E5326FFD59282FF82501DFF6E5326FF9A2F7DFF6E5326FF4D5523FF4D55230000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401D10003C1C8F109A19CB2E0000400000000000000000000000000000000000800610001C1C8F109A19CB2E00008000000000000000000000000000000000010009A0001C1C8F109A19CB2E0001000000000000000000000000000000000002000340001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000340001C1C8F109A19CB2E00020000000000000000000000000000000000010009A0001C1C8F109A19CB2E0001000000000000000000000000000000000000800610001C1C8F109A19CB2E0000800000000000000000000000000000000000401D10003C1C8F109A19CB2E00004000000000000000000000000000000000000009806C9300C03090000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031A0003C1C8F109A19CB2E000080000032D0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A20003C1C8F109A19CB2E03F8000000000000000000000000000000000400002670003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF64411BFF1F120BFFE58995FF6381A7FF1F120BFFA2A89BFF1F120BFF81271FFF81271F0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E00004000000000000000000000000000000000008006F0001C1C8F109A19CB2E0000800000000000000000000000000000000001000A70001C1C8F109A19CB2E0001000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000001000A70001C1C8F109A19CB2E00010000000000000000000000000000000000008006F0001C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E00004915A354B3E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031A0003C1C8F109A19CB2E00008000003310003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002F00003C1C8F109A19CB2E03F8000000000000000000000000000000000200002920003C1C8F109A19CB2E03F80000000000000000000000000000000004000026B0003C1C8F109A19CB2E03F8000000000000000000000000000000001000002D80001C1C8F109A19CB2E03F80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF0D0D0DFFCF8562FF212121FF0D0D0DFF9A2F7DFF0D0D0DFFD75F47FFD75F470000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004025B0003C1C8F109A19CB2E0000400000000000000000000000000000000000800620001C1C8F109A19CB2E0000800000000000000000000000000000000001000940001C1C8F109A19CB2E00010000000000000000000000000000000000020002C0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002C0001C1C8F109A19CB2E0002000000000000000000000000000000000001000940001C1C8F109A19CB2E0001000000000000000000000000000000000000800620001C1C8F109A19CB2E00008000000000000000000000000000000000004025B0003C1C8F109A19CB2E000040000000000000000000000000000E002AA90486D7120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031A0003C1C8F109A19CB2E00008000003340003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002BA0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002600003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE3A976FF8E8274FF8A1A0EFF595D5CFF8E8274FFA2A89BFF8E8274FFAA1D26FFAA1D260000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401D60003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000001000940001C1C8F109A19CB2E0001000000000000000000000000000000000002000380001C1C8F109A19CB2E0002000000000000000000000000000000000080000F50001C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000380001C1C8F109A19CB2E0002000000000000000000000000000000000001000940001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401D60003C1C8F109A19CB2E000040000000000000000000000000000E000D2B848A4FAB0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031B0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F80000000000000000000000000000000004000026E0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF6E4124FF6E5326FFECA853FFAE9843FF6E5326FF000000FF6E5326FFCF5969FFCF59690000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402210003C1C8F109A19CB2E0000400000000000000000000000000000000000801150002C1C8F109A19CB2E0000800000000000000000000000000000000001003D30002C1C8F109A19CB2E00010000000000000000000000000000000000020010A0002C1C8F109A19CB2E0002000000000000000000000000000000000040004FD0002C1C8F109A19CB2E0040000000000000000000000000000000000080001A70002C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010A0002C1C8F109A19CB2E0002000000000000000000000000000000000001003D30002C1C8F109A19CB2E0001000000000000000000000000000000000000801150002C1C8F109A19CB2E0000800000000000000000000000000000000000402210003C1C8F109A19CB2E000040000000000000000000000000000E000246DAE905518000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031B0003C1C8F109A19CB2E00008000003270003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002FF0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C60003C1C8F109A19CB2E03F8000000000000000000000000000000000400002620003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7B971FFBD934BFFD59282FF37512AFFBD934BFF631A46FFBD934BFF7F3979FF7F39790000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401BD0003C1C8F109A19CB2E0000400000000000000000000000000000000000801110002C1C8F109A19CB2E00008000000000000000000000000000000000010016D0002C1C8F109A19CB2E0001000000000000000000000000000000000002000FF0002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000FF0002C1C8F109A19CB2E00020000000000000000000000000000000000010016D0002C1C8F109A19CB2E0001000000000000000000000000000000000000801110002C1C8F109A19CB2E0000800000000000000000000000000000000000401BD0003C1C8F109A19CB2E000040000000000000000000000000000E0001555AE733CFE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003230003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002F60003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A60003C1C8F109A19CB2E03F8000000000000000000000000000000000400002630003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFFBD934BFFEFC28BFF2A72A4FFBD934BFFC5496DFFBD934BFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401C30003C1C8F109A19CB2E0000400000000000000000000000000000000000800610001C1C8F109A19CB2E00008000000000000000000000000000000000010009E0001C1C8F109A19CB2E00010000000000000000000000000000000000020002F0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E00020000000000000000000000000000000000010009E0001C1C8F109A19CB2E0001000000000000000000000000000000000000800610001C1C8F109A19CB2E0000800000000000000000000000000000000000401C30003C1C8F109A19CB2E000040000000000000000000000000000E00156AED85C4D34000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003240003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002F00003C1C8F109A19CB2E03F8000000000000000000000000000000000200002920003C1C8F109A19CB2E03F8000000000000000000000000000000000400002620003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7B971FF988054FFD00E0EFF917A51FF988054FFFFE2A3FF988054FF616161FF6161610000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401CC0003C1C8F109A19CB2E0000400000000000000000000000000000000000800540001C1C8F109A19CB2E0000800000000000000000000000000000000001000990001C1C8F109A19CB2E0001000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000001000990001C1C8F109A19CB2E0001000000000000000000000000000000000000800540001C1C8F109A19CB2E0000800000000000000000000000000000000000401CC0003C1C8F109A19CB2E000040000000000000000000000000000E000346EAE6BB7D0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003240003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F80000000000000000000000000000000002000027A0003C1C8F109A19CB2E03F80000000000000000000000000000000004000025F0003C1C8F109A19CB2E03F8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003F8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF0D0D0DFFEB7D80FF312114FF0D0D0DFF9A2F7DFFF7D748FFD75F47FFD75F470000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000000401DA0003C1C8F109A19CB2E0000400000000000000000000000000000000088000B30001C1C8F109A19CB2E0088000000000000000000000000000000000000800650001C1C8F109A19CB2E0000800000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002F0001C1C8F109A19CB2E0002000000000000000000000000000000000001000940001C1C8F109A19CB2E0001000000000000000000000000000000000000800540001C1C8F109A19CB2E00008000000000000000000000000000000000004025D0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003240003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002F00003C1C8F109A19CB2E03F8000000000000000000000000000000000200002BA0003C1C8F109A19CB2E03F80000000000000000000000000000000004000026E0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF64411BFF4F463DFF875741FF5B351EFF4F463DFFA9CEF0FF4F463DFF616161FF6161610000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402370003C1C8F109A19CB2E00004000000000000000000000000000000000008008E0001C1C8F109A19CB2E000080000FFFF0000FF00FF00FF0000FF0000001000A70001C1C8F109A19CB2E00010000000000000000000000000000000000020003C0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003C0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A70001C1C8F109A19CB2E00010000000000000000000000000000000000008008E0001C1C8F109A19CB2E000080000FFFF0000FF00FF00FF0000FF0000000402370003C1C8F109A19CB2E000040000000000000000000000000000E0007044FABB5CD2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CA0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7B971FF523436FFB56157FF212121FF523436FFC5496DFF523436FF7F3979FF7F39790000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402390003C1C8F109A19CB2E0000400000000000000000000000000000000000801380002C1C8F109A19CB2E00008000000000000000000000000000000000010016B0002C1C8F109A19CB2E00010000000000000000000000000000000000020010A0002C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010A0002C1C8F109A19CB2E00020000000000000000000000000000000000010016B0002C1C8F109A19CB2E0001000000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000000402390003C1C8F109A19CB2E000040000000000000000000000000000E00013785AB537B2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002820003C1C8F109A19CB2E03F8000000000000000000000000000000000400002610003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF1F120BFF9F5D69FF88B049FF1F120BFFC5496DFF1F120BFF654428FF6544280000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401C80003C1C8F109A19CB2E0000400000000000000000000000000000000000800560001C1C8F109A19CB2E00008000000000000000000000000000000000010009D0001C1C8F109A19CB2E00010000000000000000000000000000000000020002C0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002C0001C1C8F109A19CB2E00020000000000000000000000000000000000010009D0001C1C8F109A19CB2E0001000000000000000000000000000000000000800560001C1C8F109A19CB2E0000800000000000000000000000000000000000401C80003C1C8F109A19CB2E000040000000000000000000000000000E0009C6DD824EB5C000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003260003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002F60003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A20003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF64411BFF523436FFD00E0EFF727F35FF523436FFFFE2A3FF523436FF59332FFF59332F0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401E60003C1C8F109A19CB2E0000400000000000000000000000000000000000800580001C1C8F109A19CB2E00008000000000000000000000000000000000010008F0001C1C8F109A19CB2E00010000000000000000000000000000000000020003A0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003A0001C1C8F109A19CB2E00020000000000000000000000000000000000010008F0001C1C8F109A19CB2E0001000000000000000000000000000000000000800580001C1C8F109A19CB2E0000800000000000000000000000000000000000401E60003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003280003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A00003C1C8F109A19CB2E03F8000000000000000000000000000000000400002630003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF372116FF875741FF917A51FF372116FF000000FF372116FFECB6BEFFECB6BE0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401AE0003C1C8F109A19CB2E00004000000000000000000000000000000000008004B0001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000300001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000300001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E00010000000000000000000000000000000000008004B0001C1C8F109A19CB2E0000800000000000000000000000000000000000401AE0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002F90003C1C8F109A19CB2E03F8000000000000000000000000000000000200002920003C1C8F109A19CB2E03F80000000000000000000000000000000004000026E0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE3A976FF745131FFD00E0EFF243F53FF745131FF9A2F7DFF745131FF59332FFF59332F0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004023F0003C1C8F109A19CB2E00004000000000000000000000000000000000008011E0002C1C8F109A19CB2E0000800000000000000000000000000000000001001630002C1C8F109A19CB2E00010000000000000000000000000000000000020010B0002C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010B0002C1C8F109A19CB2E0002000000000000000000000000000000000001001630002C1C8F109A19CB2E00010000000000000000000000000000000000008011E0002C1C8F109A19CB2E00008000000000000000000000000000000000004023F0003C1C8F109A19CB2E000040000000000000000000000000000E0039BBCFA18B514000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002F90003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CA0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002610003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF6E4124FF92340EFFECA853FF312114FF92340EFFFFE2A3FF92340EFFAA1D26FFAA1D260000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402310003C1C8F109A19CB2E00004000000000000000000000000000000000008011F0002C1C8F109A19CB2E0000800000000000000000000000000000000001001680002C1C8F109A19CB2E0001000000000000000000000000000000000002003C60002C1C8F109A19CB2E0002000000000000000000000000000000000040005000002C1C8F109A19CB2E0040000000000000000000000000000000000080001AD0002C1C8F109A19CB2E00800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002003C60002C1C8F109A19CB2E0002000000000000000000000000000000000001001680002C1C8F109A19CB2E00010000000000000000000000000000000000008011F0002C1C8F109A19CB2E0000800000000000000000000000000000000000402310003C1C8F109A19CB2E000040000000000000000000000000000E000E71BAE6C976E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002BC0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002690003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFA87D3FFF92340EFFCB6758FF243F53FF92340EFF000000FF92340EFFCF5969FFCF59690000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004023B0003C1C8F109A19CB2E0000400000000000000000000000000000000000801110002C1C8F109A19CB2E0000800000000000000000000000000000000001003D30002C1C8F109A19CB2E0001000000000000000000000000000000000002000FD0002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000FD0002C1C8F109A19CB2E0002000000000000000000000000000000000001003D30002C1C8F109A19CB2E0001000000000000000000000000000000000000801110002C1C8F109A19CB2E00008000000000000000000000000000000000004023B0003C1C8F109A19CB2E000040000000000000000000000000000E002A0B3FA638E72000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E0000000000000000000000000000000000000200002860003C1C8F109A19CB2E00000000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF682618FF875741FF2A72A4FF682618FF6A3919FF682618FF59332FFF59332F0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000002000380001C1C8F109A19CB2E0002000000000000000000000000000000000000401D70003C1C8F109A19CB2E00004000000000000000000000000000000000208004A0001C1C8F109A19CB2E0020800000000000000000000000000000000004000EE0001C1C8F109A19CB2E0004000000000000000000000000000000000001000A30001C1C8F109A19CB2E000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000380001C1C8F109A19CB2E0002000000000000000000000000000000000001000A30001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000000401D70003C1C8F109A19CB2E000040000000000000000000000000000E00009C648A15528000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A00003C1C8F109A19CB2E03F8000000000000000000000000000000000400002610003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF1F120BFFB56157FF37512AFF1F120BFFFEC854FF1F120BFFE8C84FFFE8C84F0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000001001580002C1C8F109A19CB2E00010000000000000000000000000000000000020010A0002C1C8F109A19CB2E00020000000000000000000000000000000000400018B0002C1C8F109A19CB2E0040000000000000000000000000000000000080001A60002C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010A0002C1C8F109A19CB2E0002000000000000000000000000000000000001001580002C1C8F109A19CB2E0001000000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A00003C1C8F109A19CB2E03F8000000000000000000000000000000000400002610003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF6E5326FFB56157FF37512AFF6E5326FFFEC854FF6E5326FFE8C84FFFE8C84F0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000001001580002C1C8F109A19CB2E00010000000000000000000000000000000000020010A0002C1C8F109A19CB2E00020000000000000000000000000000000000400018B0002C1C8F109A19CB2E0040000000000000000000000000000000000080001A60002C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010A0002C1C8F109A19CB2E0002000000000000000000000000000000000001001580002C1C8F109A19CB2E0001000000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A00003C1C8F109A19CB2E03F8000000000000000000000000000000000400002610003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FFBD934BFFB56157FF37512AFFBD934BFFFEC854FFBD934BFFE8C84FFFE8C84F0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000001001580002C1C8F109A19CB2E00010000000000000000000000000000000000020010A0002C1C8F109A19CB2E00020000000000000000000000000000000000400018B0002C1C8F109A19CB2E0040000000000000000000000000000000000080001A60002C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010A0002C1C8F109A19CB2E0002000000000000000000000000000000000001001580002C1C8F109A19CB2E0001000000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A00003C1C8F109A19CB2E03F8000000000000000000000000000000000400002610003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FFDCB74FFFB56157FF37512AFFDCB74FFFFEC854FFDCB74FFFE8C84FFFE8C84F0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000001001580002C1C8F109A19CB2E00010000000000000000000000000000000000020010A0002C1C8F109A19CB2E00020000000000000000000000000000000000400018B0002C1C8F109A19CB2E0040000000000000000000000000000000000080001A60002C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010A0002C1C8F109A19CB2E0002000000000000000000000000000000000001001580002C1C8F109A19CB2E0001000000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A00003C1C8F109A19CB2E03F8000000000000000000000000000000000400002610003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FFFEEF7CFFB56157FF37512AFFFEEF7CFFFEC854FFFEEF7CFFE8C84FFFE8C84F0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000001001580002C1C8F109A19CB2E00010000000000000000000000000000000000020010A0002C1C8F109A19CB2E00020000000000000000000000000000000000400018B0002C1C8F109A19CB2E0040000000000000000000000000000000000080001A60002C1C8F109A19CB2E008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010A0002C1C8F109A19CB2E0002000000000000000000000000000000000001001580002C1C8F109A19CB2E0001000000000000000000000000000000000000801380002C1C8F109A19CB2E0000800000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E000080000032F0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EF0003C1C8F109A19CB2E03F80000000000000000000000000000000002000028C0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002630003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFA87D3FFF1F120BFFD59282FF917A51FF1F120BFFC1C335FF1F120BFF66BCDCFF66BCDC0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401D70003C1C8F109A19CB2E0000400000000000000000000000000000000000800630001C1C8F109A19CB2E00008000000000000000000000000000000000010009D0001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E00020000000000000000000000000000000000010009D0001C1C8F109A19CB2E0001000000000000000000000000000000000000800630001C1C8F109A19CB2E0000800000000000000000000000000000000000401D70003C1C8F109A19CB2E000040000000000000000000000000000E000295CAE69B29E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003330003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002AE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002600003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE6BC8EFFB85E22FFCB6758FF917A51FFB85E22FF904F33FFB85E22FF66BCDCFF66BCDC0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401D10003C1C8F109A19CB2E0000400000000000000000000000000000000000800620001C1C8F109A19CB2E00008000000000000000000000000000000000010009E0001C1C8F109A19CB2E00010000000000000000000000000000000000020002E0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002E0001C1C8F109A19CB2E00020000000000000000000000000000000000010009E0001C1C8F109A19CB2E0001000000000000000000000000000000000000800620001C1C8F109A19CB2E0000800000000000000000000000000000000000401D10003C1C8F109A19CB2E000040000000000000000000000000000E0002130FA50F19A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031C0003C1C8F109A19CB2E00008000003340003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F8000000000000000000000000000000000200002840003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7B971FFDCB74FFFCF8562FF6381A7FFDCB74FFF9A2F7DFFDCB74FFFE8C84FFFE8C84F0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401E80003C1C8F109A19CB2E0000400000000000000000000000000000000000800500001C1C8F109A19CB2E0000800000000000000000000000000000000001000900001C1C8F109A19CB2E00010000000000000000000000000000000000020002E0001C1C8F109A19CB2E0002000000000000000000000000000000000100040EB72C3C9599B9E5553083B100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002E0001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800500001C1C8F109A19CB2E0000800000000000000000000000000000000000401E80003C1C8F109A19CB2E00004000000000000000000000000000000000000009A81C6300C03090000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031D0003C1C8F109A19CB2E00008000003230003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002F00003C1C8F109A19CB2E03F80000000000000000000000000000000002000027A0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFE6BC8EFF906636FF8A1A0EFF5B351EFF906636FFE06E32FF906636FF4D5523FF4D55230000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401DE0003C1C8F109A19CB2E0000400000000000000000000000000000000000800630001C1C8F109A19CB2E00008000000000000000000000000000000000010009F0001C1C8F109A19CB2E00010000000000000000000000000000000000020003A0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003A0001C1C8F109A19CB2E00020000000000000000000000000000000000010009F0001C1C8F109A19CB2E0001000000000000000000000000000000000000800630001C1C8F109A19CB2E0000800000000000000000000000000000000000401DE0003C1C8F109A19CB2E000040000000000000000000000000000E001B78EAE6C976E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031D0003C1C8F109A19CB2E00008000003240003C1C8F109A19CB2E00020000003390003C1C8F109A19CB2E00000800002FA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002D20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026B0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF64411BFF906636FFBC7535FF88B049FF906636FF5395CAFF906636FFECB6BEFFECB6BE0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401C60003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000980001C1C8F109A19CB2E0001000000000000000000000000000000000002000370001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000370001C1C8F109A19CB2E0002000000000000000000000000000000000001000980001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000401C60003C1C8F109A19CB2E000040000000000000000000000000000E00018105A8456DE000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031E0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F80000000000000000000000000000000002000028C0003C1C8F109A19CB2E03F80000000000000000000000000000000004000026C0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF98652FFF553921FFFD6A68FF243F53FF553921FF6A3919FF553921FFE8C84FFFE8C84F0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401CA0003C1C8F109A19CB2E00004000000000000000000000000000000000008006F0001C1C8F109A19CB2E00008000000000000000000000000000000000010009D0001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E00020000000000000000000000000000000000010009D0001C1C8F109A19CB2E00010000000000000000000000000000000000008006F0001C1C8F109A19CB2E0000800000000000000000000000000000000000401CA0003C1C8F109A19CB2E000040000000000000000000000000000E00055ADAE6C976E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031E0003C1C8F109A19CB2E00008000003260003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002FC0003C1C8F109A19CB2E03F80000000000000000000000000000000002000029E0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002690003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF1F120BFFBC7535FF727F35FF1F120BFFA9CEF0FF1F120BFFECB6BEFFECB6BE0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402450003C1C8F109A19CB2E0000400000000000000000000000000000000002000FF0002C1C8F109A19CB2E0002000000000000000000000000000000000040005000002C1C8F109A19CB2E0040000000000000000000000000000000080001801710002C1C8F109A19CB2E0001800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000FF0002C1C8F109A19CB2E00020000000000000000000000000000000000010016F0002C1C8F109A19CB2E0001000000000000000000000000000000000000801340002C1C8F109A19CB2E0000800000000000000000000000000000000000402450003C1C8F109A19CB2E0000400000000000000000000000000000000000000EDF2C6300C03090000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
          //"0x00000000000000003F00000000100000031E0003C1C8F109A19CB2E00008000003280003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002820003C1C8F109A19CB2E03F8000000000000000000000000000000000400002630003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FFE3802FFFC65265FF6381A7FFE3802FFF904F33FFE3802FFFAA1D26FFAA1D260000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004021D0003C1C8F109A19CB2E00004000000000000000000000000000000000020003B0001C1C8F109A19CB2E0002000000000000000000000000000000000001000990001C1C8F109A19CB2E0001000000000000000000000000000000000000800890001C1C8F109A19CB2E000080000FFFF0000FF00FF00FF0000FF00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003B0001C1C8F109A19CB2E0002000000000000000000000000000000000001000990001C1C8F109A19CB2E0001000000000000000000000000000000000000800890001C1C8F109A19CB2E000080000FFFF0000FF00FF00FF0000FF00000004021D0003C1C8F109A19CB2E000040000000000000000000000000000E000497D5A84A20A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", --suspected invalid manifest
            "0x00000000000000003F00000000100000031E0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033C0003C1C8F109A19CB2E00000800002E60003C1C8F109A19CB2E03F8000000000000000000000000000000000200002980003C1C8F109A19CB2E03F8000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF682618FF83463FFF82501DFF682618FFF3BC7BFF682618FF2AB0ABFF2AB0AB0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402250003C1C8F109A19CB2E00004000000000000000000000000000000000008010F0002C1C8F109A19CB2E00008000000000000000000000000000000000010016C0002C1C8F109A19CB2E0001000000000000000000000000000000000002003C60002C1C8F109A19CB2E00020000000000000000000000000000000000400018B0002C1C8F109A19CB2E0040000000000000000000000000000000000080001AD0002C1C8F109A19CB2E00800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002003C60002C1C8F109A19CB2E00020000000000000000000000000000000000010016C0002C1C8F109A19CB2E00010000000000000000000000000000000000008010F0002C1C8F109A19CB2E0000800000000000000000000000000000000000402250003C1C8F109A19CB2E000040000000000000000000000000000E0000095FAB26C50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031E0003C1C8F109A19CB2E000080000032E0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F80000000000000000000000000000000002000029E0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002620003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF85541AFFEFC28BFF5B351EFF85541AFF631A46FF85541AFFE673B8FFE673B80000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401FE0003C1C8F109A19CB2E00004000000000000000000000000000000000008006F0001C1C8F109A19CB2E0000800000000000000000000000000000000001000A90001C1C8F109A19CB2E0001000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000350001C1C8F109A19CB2E0002000000000000000000000000000000000001000A90001C1C8F109A19CB2E00010000000000000000000000000000000000008006F0001C1C8F109A19CB2E0000800000000000000000000000000000000000401FE0003C1C8F109A19CB2E000040000000000000000000000000000E0004F815A36DFCC000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0x00000000000000003F00000000100000031E0003C1C8F109A19CB2E000080000032F0003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002E70003C1C8F109A19CB2E03F80000000000000000000000000000000002000027E0003C1C8F109A19CB2E03F80000000000000000000000000000000004000026A0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFF0B393FF493421FFB56157FF37512AFF493421FFFEC854FF493421FFE8C84FFFE8C84F0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402000003C1C8F109A19CB2E00004000000000000000000000000000000000008004F0001C1C8F109A19CB2E0000800000000000000000000000000000000001000A40001C1C8F109A19CB2E00010000000000000000000000000000000000020002C0001C1C8F109A19CB2E0002000000000000000000000000000000000080000F40001C1C8F109A19CB2E0080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020002C0001C1C8F109A19CB2E0002000000000000000000000000000000000001000A40001C1C8F109A19CB2E00010000000000000000000000000000000000008004F0001C1C8F109A19CB2E0000800000000000000000000000000000000000402000003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        };

        private static string[] pictureKeys = new string[] {
            "0x6600660066006500300037006400310030003000300032003000300030003100300030003000310030003000300031000000",
            "0x6600660066006500300037006400310030003000300032003000300030003200300030003000310030003000300032000000",
            "0x6600660066006500300037006400310030003000300032003000300030003300300030003000310030003000300033000000",
            "0x6600660066006500300037006400310030003000300032003000300030003400300030003000310030003000300034000000",
            "0x6600660066006500300037006400310030003000300032003000300030003500300030003000310030003000300035000000",
            "0x6600660066006500300037006400310030003000300032003000300030003600300030003000310030003000300036000000",
            "0x6600660066006500300037006400310030003000300032003000300030003700300030003000310030003000300037000000",
            "0x6600660066006500300037006400310030003000300032003000300030003900300030003000310030003000300039000000",
            "0x6600660066006500300037006400310030003000300032003000300030006100300030003000310030003000300061000000",
            "0x6600660066006500300037006400310030003000300032003000300030006200300030003000310030003000300062000000",
            "0x6600660066006500300037006400310030003000300032003000300030006300300030003000310030003000300063000000",
        };

        private static string[] profileNames = new string[] {
            "Charlotte",
            "A",
            "Steve",
            "Matt",
            "Sarah",
            "Duoc",
            "Rankin",
            "Sean",
            "Brendan",
            "Eric",
            "My name goes here",
            "HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH",
            "Larry Hryb, Xbox LIVE's Major Nelson",
            "Laura lollip0p",
            "Malia Lupychica",
            "Pete BoomtownParade"
        };

        private static byte[] hexStringToByteArray(string str)
        {
            //remove the "0x"
            if (str.StartsWith("0x") || str.StartsWith("0X"))
            {
                str = str.Substring(2);
            }

            int stringIndex = 0;
            int byteArrayIndex = 0;
            byte[] retVal = new byte[(str.Length) / 2];

            while (str.Length > stringIndex + 1)
            {
                long temp = Convert.ToInt32(str.Substring(stringIndex, 2), 16);
                retVal[byteArrayIndex] = Convert.ToByte(temp);
                stringIndex += 2;
                byteArrayIndex++;
            }

            return retVal;
        }

        private static byte[] unicodeStringToByteArray(string str)
        {
            //add null terminator
            str = str + "\0";
            Encoding unicode = Encoding.Unicode;
            return unicode.GetBytes(str);
        }


        #region Profile Utils

        //This just sets the profile setting. This does NOT delete all achievements, etc.
        // TODO BUGBUG this breaks when profile/progress moves out of uodb!
        public static HResult MarkCheater(ulong userid)
        {
            HResult hr = HResult.E_FAIL;
            try
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.StoredProc = "p_stats_mark_user_as_cheater";
                    ws.Partition = ws.CalcPartition(userid);
                    ws.AddParameter("@bi_user_puid", userid);

                    ws.ExecuteNonQuery();
                }

                RemoveCachedData(userid, ProfileDefs.XPROFILE_GAMER_TYPE, XOn.XENON_DASH_TITLE_ID);
            }
            catch (Exception e)
            {
                Xom.Trace("testfd", LogLevel.L_HIGH, "MarkCheater calling UODB's p_stats_mark_user_as_cheater threw an exception: " + e.ToString());
                throw e;
                
            }
            hr = HResult.S_OK;
            return hr;
        }

        public static HResult SetWatermark(ulong userid, uint watermarkValue)
        {
            HResult hr = HResult.S_OK;
            UserSetting setting = new UserSetting(userid, XOn.XENON_DASH_TITLE_ID, ProfileDefs.XPROFILE_GAMER_TYPE, null);

            //convert watermark setting into binary data
            byte[] value1 = BitConverter.GetBytes(watermarkValue);

            setting.Value = value1;
            setting.ValueLen = (ushort)value1.Length;
            hr = SyncSettingsBackdoor(userid, new UserSetting[] { setting });

            return hr;
        }

        public static HResult SetTenure(ulong userid, ushort years, ushort months)
        {
            HResult hr = HResult.S_OK;

            uint milestone = 0;
            if (months >= 2 && months < 6)
            {
                milestone = 1;
            }
            if (months >= 6 && months < 9)
            {
                milestone = 2;
            }
            if (months >= 9)
            {
                milestone = 3;
            }
            uint level = (uint)years;

            //convert settings into binary data
            byte[] value1 = BitConverter.GetBytes(level);
            byte[] value2 = BitConverter.GetBytes(milestone);

            UserSetting setting1 = new UserSetting(userid, XOn.XENON_DASH_TITLE_ID, ProfileDefs.XPROFILE_TENURE_LEVEL, value1);
            UserSetting setting2 = new UserSetting(userid, XOn.XENON_DASH_TITLE_ID, ProfileDefs.XPROFILE_TENURE_MILESTONE, value2);

            setting1.ValueLen = (ushort) value1.Length;
            setting2.ValueLen = (ushort)value2.Length;

            hr = SyncSettingsBackdoor(userid, new UserSetting[] { setting1, setting2 });

            return hr;
        }

        public static HResult SetInitialRandomProfileSettings(ulong userid)
        {
            byte[] value1 = GetRandomAvatarValue();
            byte[] value2 = GetRandomGamerPictureValue();
            byte[] value3 = GetRandomNameValue();

            UserSetting[] settings = new UserSetting[3];

            settings[0] = new UserSetting(userid, XOn.XENON_DASH_TITLE_ID, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, value1);
            settings[1] = new UserSetting(userid, XOn.XENON_DASH_TITLE_ID, ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY, value2);
            settings[2] = new UserSetting(userid, XOn.XENON_DASH_TITLE_ID, ProfileDefs.XPROFILE_GAMERCARD_USER_NAME, value3);

            settings[0].ValueLen = (ushort)value1.Length;
            settings[1].ValueLen = (ushort)value2.Length;
            settings[2].ValueLen = (ushort)value3.Length;

            HResult hr = SyncSettings(userid, XOn.XENON_DASH_TITLE_ID, settings);

            return hr;

        }

        public static byte[] GetRandomGamerPictureValue()
        {
            int randomIndex = GetRandomInt(pictureKeys.Length);

            string key = pictureKeys[randomIndex];
            return hexStringToByteArray(key);
        }

        public static byte[] GetRandomAvatarValue()
        {
            int randomIndex = GetRandomInt(avatarManifests.Length);

            string manifest = avatarManifests[randomIndex];
            return hexStringToByteArray(manifest);
        }

        public static byte[] GetRandomNameValue()
        {
            int randomIndex = GetRandomInt(profileNames.Length);
            
            string name = profileNames[randomIndex];
            return unicodeStringToByteArray(name);
        }

        private static HResult SyncSettings(ulong xuid, uint titleId, UserSetting[] settings)
        {
            HResult hr = HResult.S_OK;
            if (settings.Length > 32)
            {
                return HResult.E_INVALIDARG;
            }

            SyncSettingsRequest req = new SyncSettingsRequest();
            SyncSettingsResponse resp = new SyncSettingsResponse();
            XRLObject2 xrlObject = resp;

            req.TitleId = titleId;
            req.UserId = xuid;
            req.Version = DateTime.Now;
            req.StartinIndex = 0;
            req.SettingsLen = (ushort)settings.Length;
            req.Settings = settings;

            HTTPAuthData authData = new HTTPAuthData();
            WebHeaderCollection headers = new WebHeaderCollection();

            GetAuthDataAndHeaders(xuid, titleId, (uint)XOService.Profile, out authData, out headers);

            hr = XRLUtil.PostXrlRequest(VirtualInterface.profilefd_int, req.Xrl, authData.GetBase64EncodedString(), req, headers, ref xrlObject);

            return hr;
        }

        //ONLY ADD WATERMARK and ADD TENURE IS ALLOWED TO CALL THIS
        // TODO BUGBUG this breaks when profile/progress moves out of uodb!
        private static HResult SyncSettingsBackdoor(ulong userid, UserSetting[] settings)
        {
            HResult hr = HResult.E_FAIL;
            if (settings.Length > 32)
            {
                return HResult.E_INVALIDARG;
            }

            foreach(UserSetting setting in settings)
            {
                if (setting.SettingId != ProfileDefs.XPROFILE_TENURE_LEVEL
                    && setting.SettingId != ProfileDefs.XPROFILE_TENURE_MILESTONE
                    && setting.SettingId != ProfileDefs.XPROFILE_GAMER_TYPE)
                {
                    return HResult.E_INVALIDARG;
                }
            }

            try
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.StoredProc = "dbo.p_stats_sync_user_settings";
                    ws.Partition = ws.CalcPartition(userid);

                    ws.AddParameter("@bi_user_puid", userid);
                    ws.AddParameter("@i_title_id", XOn.XENON_DASH_TITLE_ID);
                    ws.AddParameter("@dt_client_version", DateTime.Now);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);
                    for (int j = 0; j < settings.Length; j++)
                    {
                        ws.AddParameter("@i_setting_id" + j, settings[j].SettingId);
                        ws.AddParameter("@i_title_id" + j, XOn.XENON_DASH_TITLE_ID);
                        ws.AddParameter(ParamType.INPUT, "@vb_value" + j, (settings[j].ValueLen == 0 ? null : settings[j].Value), (int)settings[j].ValueLen);
                    }

                    WstDataReader reader = ws.Execute();
                    if (!reader.Read())
                    {
                        Xom.Trace("testfd", LogLevel.L_HIGH, "SyncSettingsBackdoor did not receive a result from p_stats_sync_user_settings.");
                        //TODO: Throw an event
                    }
                }

                for (int j = 0; j < settings.Length; j++)
                {
                    RemoveCachedData(userid, settings[j].SettingId, XOn.XENON_DASH_TITLE_ID);
                }

                hr = HResult.S_OK;
            }
            catch (Exception e)
            {
                Xom.Trace("testfd", LogLevel.L_HIGH, "SyncSettingsBackdoor calling UODB's p_stats_sync_user_settings threw an exception: " + e.ToString());
                throw e;
            }

            return hr;
        }

        // TODO BUGBUG this breaks when profile/progress moves out of uodb!
        private static void RemoveCachedData(ulong userid, uint settingid, uint titleId)
        {
            Acceleration xb = new Acceleration(Interface.ProfileCache);
            xb.Remove(ProfileDefs.BuildCacheKey(settingid, titleId, userid));
        }
        #endregion


        #region Passport Utils

        public static ulong CreatePassportID(string email, string password, string secretQuestion, string secretAnswer, DateTime birthdate, byte countryId)
        {
            ulong puid = 0;
            XePassportCreateRequest request = new XePassportCreateRequest();
            XePassportCreateResponse response = new XePassportCreateResponse();
            XRLObject2 xrlObject = response;

            request.passportMemberName = email;
            request.passportMemberNameLength = (ushort) email.Length;
            request.secretQuestion = secretQuestion;
            request.secretQuestionLength = (ushort) secretQuestion.Length;
            request.countryId = countryId;
            request.birthdate = birthdate;

            PassportTestClient passport = new PassportTestClient();
            passport.Init();
            passport.GenerateEncryptedCredentials("", password, secretAnswer, out request.encryptedPassword);

            HTTPAuthData authData = new HTTPAuthData(0, 0, 0, 0, 0, XOn.WEB_TITLE_ID, (uint)XOService.User_Account, 0);

            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";

            HResult hr = XRLUtil.PostXrlRequest(VirtualInterface.xuacs_int, request.Xrl, authData.GetBase64EncodedString(), request, headers, ref xrlObject);

            //in the case of an error, zero will be returned as the puid.
            if (hr == HResult.S_OK)
            {
                // The puid is contained within the first 8 bytes of the session token.
                // Extract the first 8 bytes and return it.
                puid = (ulong)BitConverter.ToInt64(response.sessionToken, 0);
            }
            else
            {
                Xom.Trace("testfd", LogLevel.L_HIGH, "CreatePassportID's call to XePassportCreate returned an error: " + hr);
                //TODO: throw an event
            }

            return puid;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\testrefl\TestRefl.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Net;
using System.Text;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: ConfigAttribute(xonline.common.config.Component.testrefl)]

[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.server.testfd.TestRefl
{
    public class TestRefl : System.ServiceProcess.ServiceBase
    {
        private bool m_fRunAsConsole = false;
        private bool m_fRunStandalone = false;

        private UdpListener _udpListener = null;
        private UdpListener _udpListener_XConn = null;

        private static TestRefl _instance = null;
        public static TestRefl Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new TestRefl();
                }
                return _instance;
            }
        }

        public bool IsStandalone { get { return m_fRunStandalone; } }

        public TestRefl ()
        {          
        }

        public void Log(string sDelim, params Object[] args)
        {
            StringBuilder sb = new StringBuilder();
            for (int iArg = 0; iArg < args.Length; iArg++)
            {
                sb.Append((args[iArg] == null) ? "{null}" : args[iArg]);

                if (iArg < args.Length - 1)
                    sb.Append(sDelim);
            }

            Log(sb.ToString());
        }

        public void Log(string output)
        {
            if (m_fRunAsConsole)
            {
                Console.WriteLine(output);
            }

            Xom.Log(XomAreaName.log, output);
        }

        public void LogEvent (XEvent.Id id, string message)
        {
            if (m_fRunAsConsole)
            {
                Console.WriteLine("Event(" + id.ToString() + "): " + message);
            }

            Xom.NtEvent(id, message);
        }
        
        /// <summary>
        /// Set things in motion so your service can do its work.
        /// </summary>
        protected override void OnStart(string[] args)
        {           
            InitService();
            LogEvent(XEvent.Id.TESTREFL_STARTED, "Test reflector has been started.");
        }
 
        /// <summary>
        /// Stop this service.
        /// </summary>
        protected override void OnStop()
        {
            CloseService();
            _instance = null;
            LogEvent(XEvent.Id.TESTREFL_SHUTDOWN, "Test reflector has been shutdown.");
        }

        public void Start()
        {
            OnStart(null);
        }

        private void InitService()
        {                   
            try
            {
                Config.Assembly = System.Reflection.Assembly.GetExecutingAssembly();
                XomLoggingControl.Init();

                IVirtualInterfaceInfo tr_ivii = Config.GetVirtualInterface(VirtualInterface.testrefl);
                IVirtualInterfaceInfo tr2_ivii = Config.GetVirtualInterface(VirtualInterface.testrefl2);

                // sample setting retrieval
                //int cbReadBuffer = Config.GetIntSetting(Setting.XConnSrv_SocketBufferSize);

                // create listeners
                _udpListener = new UdpListener(4, tr_ivii.Port);
                _udpListener_XConn = new UdpListener(1, tr2_ivii.Port);

                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

                // Register for setting changes
                Config.SettingChange += OnSettingChange;

                xonline.common.health.HealthListener.InitializeHealthListener(Config.ComponentName);
                
                Log("|", "INIT", "Test reflector initialized.");
            }
            catch (Exception e)
            {
                LogEvent(XEvent.Id.TESTREFL_STARTUP_FAILURE, "Failed to initialize test reflector. Exception:\n" + e.ToString());
                throw;
            }
        }

        private void CloseService()
        {
            Log("|", "SHTDWN", "Test reflector shutting down.");

            if (_udpListener != null)
            {
                _udpListener.Close();
                _udpListener = null;
            }

            if (_udpListener_XConn != null)
            {
                _udpListener_XConn.Close();
                _udpListener_XConn = null;
            }

            XomLoggingControl.Close();
        }

        string HelpString
        {
            get
            {
                return 
                "\r\nTestRefl Commands:\r\n\r\n" +
                "  help:\tshow this help message.\r\n" +
                "  udpthreads <count>:\tset the number of UDP listener threads.\r\n" +
                "  udpport <port>:\tset the port of the UDP listener.\r\n" +
                (m_fRunAsConsole ? "  quit:\tshutdown server.\r\n\r\n" : "\r\n");
            }
        }

        string HandleManangementCommand(ControlRequestEventArgs args)
        {
            switch (args.Command.ToLower())
            {
                case "help":
                    // leave handled as false to allow for all handlers to process help.
                    return HelpString;

                case "udpthreads":
                    {
                        args.Handled = true;

                        if (_udpListener == null)
                        {
                            return "UDP not running.";
                        }

                        if (args.CommandArgs.Length < 1)
                        {
                            return "No argument <count> passed in, it should be an integer from 1 to 10.";
                        }

                        string param = args.CommandArgs[0];
                        int count = 0;
                        if (int.TryParse(param, out count))
                        {
                            if (count >= 1 || count <= 10)
                            {
                                try
                                {
                                    _udpListener.SetThreadCount(count);
                                    return "UDP thread count set to " + count.ToString() + ".";
                                }
                                catch (Exception e)
                                {
                                    return "An exception was thrown trying to set the UDP thread count:\r\n" + e.ToString();
                                }
                            }
                        }

                        // leaving TryParse means
                        return "Invalid argument '" + param + "', should be an integer from 1 to 10.";
                    }

                case "udpport":
                    {
                        args.Handled = true;

                        if (args.CommandArgs.Length < 1)
                        {
                            return "No argument <port> passed in, it should be an integer from 1 to 65535.";
                        }

                        string param = args.CommandArgs[0];
                        int port = 0;
                        UdpListener old_listener = null;
                        if (int.TryParse(param, out port))
                        {
                            if (port >= 1 || port <= 0xFFFF)
                            {
                                try
                                {
                                    old_listener = _udpListener;
                                    int count = 4;

                                    if (old_listener != null)
                                    {
                                        count = old_listener.GetThreadCount();
                                        old_listener.Close();
                                    }

                                    _udpListener = new UdpListener(count, port);

                                    return "UDP port set to " + port.ToString() + ".";
                                }
                                catch (Exception e)
                                {
                                    return "An exception was thrown trying to set the UDP thread count:\r\n" + e.ToString();
                                }
                            }
                        }

                        // leaving TryParse means
                        return "Invalid argument '" + param + "', should be an integer from 1 to 65535.";
                    }


                case "quit":
                    args.Handled = true;
                    if (m_fRunAsConsole != true)
                    {
                        return "Server running in service mode.  Cannot quit.\r\n";
                    }
                    else
                    {
                        m_fRunAsConsole = false;
                        return "Exiting.\r\n";
                    }
                        
                default:
                    return "";
            }
        }

        // Running in standalone should not reference external dependencies
        void RunAsConsole(string[] args)
        {
            if (m_fRunStandalone)
            {
                _udpListener = new UdpListener(4, 10280);
            }
            else
            {
                OnStart(args);
            }

            try
            {
                Console.WriteLine("Running as console.  Type \"help\" for commands.");

                while (m_fRunAsConsole)
                {
                    string sCommand = Console.ReadLine();
                    string sResponse = "Invalid Command\r\n";
                    try
                    {
                        ControlRequestEventArgs cmdArgs = new ControlRequestEventArgs(sCommand, 0);
                        sResponse = HandleManangementCommand(cmdArgs);
                    }
                    catch (Exception e)
                    {
                        Console.Write("Error: " + e.ToString() + "\r\n\r\n");
                    }

                    Console.WriteLine(sResponse);
                }
            }
            finally
            {
                if (m_fRunStandalone)
                {
                    UdpListener udpl = _udpListener;

                    if (udpl != null)
                    {
                        _udpListener = null;
                        udpl.Close();
                    }
                }
                else
                {
                    OnStop();
                }
            }
        }

        // The main entry point for the process
        static void Main(string[] args)
        {
            TestRefl srv = TestRefl.Instance;
            
            foreach (string sArg in args)
            {
                if (sArg.ToLower().Contains("console"))
                {
                    srv.m_fRunAsConsole = true;
                }
                else if (sArg.ToLower().Contains("alone"))
                {
                    srv.m_fRunAsConsole = true;
                    srv.m_fRunStandalone = true;
                }

                if (sArg.ToLower().Contains("halt"))
                {
                    System.Diagnostics.Debugger.Break();
                }
            }

            if (srv.m_fRunAsConsole)
            {
                srv.RunAsConsole(args);
            }
            else
            {
                System.ServiceProcess.ServiceBase.Run(srv);
            }
        }
        
        // -------------------------------------------------------------------------
        // OnSettingChange - handles changes to npdb settings
        // -------------------------------------------------------------------------
        public static void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            return;
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string sResponse = TestRefl.Instance.HandleManangementCommand(args);
                XomControlConnection.SendMessage(sResponse, args.RequestId);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

    }

    [XomPerformanceCounterCategoryAttr("Test FD Reflector", "Test FD Reflector")]
    public class TestReflCounters : XomPerformanceCounterCategory
    {
        public TestReflCounters() : base(true)
        {
        }

        static public TestReflCounters Current = new TestReflCounters();
        
        [XomPerformanceCounterAttr(
            "Total Packets/second", 
            "Total number of packets received per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PacketRate;

        [XomPerformanceCounterAttr(
            "UDP Packets/second",
            "Total number of UDP packets received per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PacketUDPRate;

        [XomPerformanceCounterAttr(
            "TCP Packets/second",
            "Total number of TCP packets received per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PacketTCPRate;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\xsts\soap\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\xsts\common\Common.cs ===
using System.Text;
using System.Threading;
using System.Web.Services;

using Microsoft.XboxLive.Auth.Policy;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.IdentityModel.Claims;

namespace TestXsts
{
    public class CommonSimple
    {
        public static string GetTokenClaimsString()
        {
            ClaimsIdentityCollection claimIdentities = GetClaimIdentities();
            StringBuilder sb = new StringBuilder("\n");
            foreach (IClaimsIdentity cId in claimIdentities)
            {
                sb.AppendLine(System.String.Empty);
                ClaimCollection claims = cId.Claims;
                if (claims != null)
                {
                    foreach (Claim c in claims)
                    {
                        sb.AppendLine("   " + c.ClaimType + " " + c.ValueType + " "  + c.Value + " " + c.OriginalIssuer);
                    }
                }
            }
            return sb.ToString();
        }

        private static ClaimsIdentityCollection GetClaimIdentities()
        {
            if (Thread.CurrentPrincipal is IClaimsPrincipal)
            {
                return ((IClaimsPrincipal)Thread.CurrentPrincipal).Identities;
            }
            else
            {
                return null;
            }
        }
    };

    public class CommonCode
    {
        public static string CallVerifyOperator(Microsoft.XboxLive.Auth.AuthHelper auth, string method, string claimType, string value)
        {
            try
            {
                if (method=="exists")
                {
                    return auth.VerifyExists(claimType).ToString();
                }
                else if (method=="equals")
                {
                    return auth.VerifyEquals(claimType, value).ToString();
                }
                else if (method=="lessthan")
                {
                    return auth.VerifyLessThan(claimType, value).ToString();
                }
                else if (method=="greaterthan")
                {
                    return auth.VerifyGreaterThan(claimType, value).ToString();
                }
                else if (method == "contains")
                {
                    return auth.VerifyContains(claimType, value).ToString();
                }
            }
            catch (System.Exception e)
            {
                string s="";

                for (System.Exception i=e; i!=null; i=i.InnerException)
                {
                    if (s.Length!=0)
                    {
                        s+="|";
                    }

                    s+=i.GetType().ToString()+"|"+i.Message.Replace("\r", "").Replace("\n", "");
                }

                return s;
            }

            throw new System.Exception("Unhandled method name.");
        }

        public static string CallFindClaim(Microsoft.XboxLive.Auth.AuthHelper auth, string claimType)
        {
            //get the claim
            Claim claim;
            try
            {
                claim=auth.FindClaim(claimType);
            }
            catch (System.Exception e)
            {
                return e.GetType()+"|"+e.Message;
            }

            if (claim==null)
            {
                return "false";
            }

            //serialize it to a string for return
            string ret="true|"; //means valid data in the response
            ret+="ClaimType="+claim.ClaimType+"|";
            ret+="Issuer="+claim.Issuer+"|";
            ret+="OriginalIssuer="+claim.OriginalIssuer+"|";
            ret+="Properties={";
            bool isFirstProp=true;
            foreach (System.Collections.Generic.KeyValuePair<string, string> prop in claim.Properties)
            {
                if (!isFirstProp)
                {
                    ret+="|";
                }

                ret+=prop.Key+"="+prop.Value;
                isFirstProp=false;
            }
            ret+="}|";
            //ret+="Subject="+claim.Subject+"|"; //Subject ToString is throwing... just skip over it, probably a bug in WIF.
            ret+="Value="+claim.Value+"|";
            ret+="ValueType="+claim.ValueType;

            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\xsts\mvc\Installer.cs ===
using xonline.common.config;
using xonline.common.installer;

[assembly: XomIisInstaller( Interface.testfdxstsmvc )]
[assembly: XomIisInstaller( Interface.testfdxstsmvc_int )]

[System.ComponentModel.RunInstaller(true)]
public class Installer: XomConfiguratorInstall
{
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\xsts\soap\Installer.cs ===
using xonline.common.config;
using xonline.common.installer;

[assembly: XomIisInstaller( Interface.testfdxstssoap )]
[assembly: XomIisInstaller( Interface.testfdxstssoap_int )]

[System.ComponentModel.RunInstaller(true)]
public class Installer: XomConfiguratorInstall
{
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\xsts\wcf\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\xsts\wcf\Installer.cs ===
using xonline.common.config;
using xonline.common.installer;

[assembly: XomIisInstaller( Interface.testfdxstswcf )]
[assembly: XomIisInstaller( Interface.testfdxstswcf_int )]

[System.ComponentModel.RunInstaller(true)]
public class Installer: XomConfiguratorInstall
{
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\testrefl\UdpListener.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.testfd.TestRefl
{
    public class XlspUtil
    {
        public static byte[] CreateStringErrorResponse(byte code, string msg)
        {
            byte []resp=new byte[msg.Length+2];
            resp[0]=code;
            for (int i=0; i<msg.Length; ++i)
            {
                resp[1+i]=(byte)msg[i];
            }
            resp[resp.Length-1]=0;

            return resp;
        }

        public static string[] ParseNullStringSequence(byte []blob, int offset, int length)
        {
            System.Collections.Generic.List<string> list=new System.Collections.Generic.List<string>();

            System.Text.StringBuilder cur=new System.Text.StringBuilder();
            for (int l=0; l<length; ++l)
            {
                byte b=blob[offset+l];
                if (b==0)
                {
                    list.Add(cur.ToString());
                    cur=new System.Text.StringBuilder();
                }
                else
                {
                    cur.Append((char)b);
                }
            }

            if (cur.ToString().Length!=0)
            {
                throw new System.Exception("Partially complete string found at end of buffer: "+cur.ToString());
            }

            return list.ToArray();
        }

        public static object GetObjectProperty(object obj, string name)
        {
            foreach (System.Reflection.MemberInfo mi in obj.GetType().GetMembers())
            {
                if (mi.MemberType==System.Reflection.MemberTypes.Property)
                {
                    System.Reflection.PropertyInfo pi=(System.Reflection.PropertyInfo)mi;
                    if (pi.Name==name)
                    {
                        return pi.GetValue(obj, null);
                    }
                }
            }

            return null;
        }
    };

    public class TestReflSGInfo : SGInfo
    {
        public TestReflSGInfo (IPAddress ipa, ushort port) : base(ipa, port)
        {
        }

        /// <summary>
        /// Exposes the parametered ConstructAuthData function from SGInfo.
        /// </summary>
        public byte[] GetAuthDataVersion (ushort version)
        {
            if (version == 0)
            {
                return ConstructAuthData();
            }
            else
            {
                return ConstructAuthData(version);
            }
        }

        /// <summary>
        /// Expose the UseOldProtocol bool.
        /// </summary>
        public static bool? UseOldProtocol
        {
            set
            {
                if (value.HasValue)
                {
                    _useOldProtocol = value.Value;
                }
                else
                {
                    _useOldProtocol = Config.GetBoolSetting(Setting.sginfo_useOldProtocol);
                }
            }
        }
    }

    /// <summary>
    /// Container for a UDP reflector, including the socket, threads, and code.
    /// </summary>
    public class UdpListener
    {
        /// <summary>The maximum size of the Listen buffer.</summary>
        private const int MaxListenBufferSize = 1500;

        /// <summary>The shared Authdata lookup ID value.</summary>
        private int _authdataRequestID = 0;

        /// <summary>Our listening socket.</summary>
        private Socket _socket = null;

        /// <summary>Container for thread information.</summary>
        private class ListenThread
        {
            public Thread Thread = null;
            public bool ShouldRun = true;
            public AutoResetEvent AREvent = null;
            public Socket AuthdataSocket = null;
        }

        /// <summary>Our list of threads.</summary>
        private List<ListenThread> _threads = null;

        /// <summary>Constructor.</summary>
        public UdpListener (int threadCount, int port)
        {
            if (threadCount < 1)
            {
                throw new ArgumentOutOfRangeException("threadCount", threadCount, "threadCount must be >= 1.");
            }
            
            // create socket
            _socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, 65536);
            _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, 65536);
            IPEndPoint ipep = new IPEndPoint(IPAddress.Any, port);
            _socket.Bind((EndPoint)ipep);

            // create all of our threads
            _threads = new List<ListenThread>();

            for (int i = 0; i < threadCount; ++i)
            {
                AddThread();
            }
        }

        /// <summary>
        /// Shuts down the UdpListener.  It will be unusable afterwards.
        /// </summary>
        public void Close ()
        {
            SetThreadCount(0);
            _socket.Close();
        }

        /// <summary>
        /// Sets the number of threads that should be used for listening.
        /// </summary>
        /// <param name="threadCount">The number of threads that should be used.</param>
        public void SetThreadCount (int threadCount)
        {
            if (threadCount < 0)
            {
                throw new ArgumentOutOfRangeException("threadCount", threadCount, "threadCount cannot be negative.");
            }

            lock (_threads)
            {
                int currentCount = _threads.Count;

                if (threadCount < currentCount)
                {
                    for (int i = threadCount; i < currentCount; ++i)
                    {
                        ListenThread lt = _threads[i];
                        lt.ShouldRun = false;
                        // release the thread if it happens to be waiting
                        // the async receive may get 1 more packet in afterwards, no biggie
                        lt.AREvent.Set();
                    }

                    _threads.RemoveRange(threadCount, currentCount - threadCount);
                }
                else if (threadCount > currentCount)
                {
                    for (int i = currentCount; i < threadCount; ++i)
                    {
                        AddThread();
                    }
                }
            }
        }

        /// <summary>
        /// Gets the number of threads that should be used for listening.
        /// </summary>
        /// <returns>The number of threads.</returns>
        public int GetThreadCount ()
        {
            lock (_threads)
            {
                return _threads.Count;
            }
        }

        /// <summary>
        /// Creates a thread and adds it to the list.  Exclusive access to _threads must be held before calling.
        /// </summary>
        private void AddThread ()
        {
            ListenThread lt = new ListenThread();
            lt.AREvent = new AutoResetEvent(true);
            lt.Thread = new Thread(Listen);
            lt.Thread.IsBackground = true;
            lt.Thread.Start(lt);

            _threads.Add(lt);
        }

        /// <summary>
        /// The worker thread function.
        /// </summary>
        /// <param name="data">The data to be used by this worker thread.</param>
        public void Listen (object data)
        {
            ListenThread lt = null;
            SocketAsyncEventArgs saea = null;

            try
            {
                // get the listener data
                lt = (ListenThread)data;

                // create a new socket async context
                saea = new SocketAsyncEventArgs();
                saea.SetBuffer(new byte[MaxListenBufferSize], 0, MaxListenBufferSize);
                saea.Completed += ListenCallback;
                saea.RemoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                saea.UserToken = lt;
            }
            catch (Exception e)
            {
                TestRefl.Instance.LogEvent(XEvent.Id.TESTREFL_THREAD_FAILURE, "Failed to create UDP listener thread. Exception:\n" + e.ToString());
                return;
            }

            while (lt.ShouldRun)
            {
                try
                {
                    // wait for async receive to finish
                    lt.AREvent.WaitOne();

                    while (lt.ShouldRun)
                    {
                        // this try block will keep us from getting into a deadlock
                        // we will keep trying to receive until an async occurs
                        try
                        {
                            saea.SocketFlags = SocketFlags.None;

                            if (_socket.ReceiveFromAsync(saea))
                            {
                                break;
                            }
                            else
                            {
                                ProcessReceive(saea);
                            }
                        }
                        catch (Exception e)
                        {
                            TestRefl.Instance.LogEvent(XEvent.Id.TESTREFL_THREAD_FAILURE, "Failure on UDP listener thread. Exception:\n" + e.ToString());
                        }
                    }
                }
                catch (Exception e)
                {
                    TestRefl.Instance.LogEvent(XEvent.Id.TESTREFL_THREAD_FAILURE, "Failure on UDP listener thread. Exception:\n" + e.ToString());
                }
            }
        }

        /// <summary>
        /// The callback for Listen async stuff.
        /// </summary>
        public void ListenCallback (object sender, SocketAsyncEventArgs saea)
        {
            ListenThread lt = null;

            try
            {
                lt = (ListenThread)(saea.UserToken);

                ProcessReceive(saea);
            }
            catch (Exception e)
            {
                TestRefl.Instance.LogEvent(XEvent.Id.TESTREFL_THREAD_FAILURE, "Failure on UDP listener thread. Exception:\n" + e.ToString());
            }
            finally
            {
                if (lt != null)
                {
                    try
                    {
                        lt.AREvent.Set();
                    }
                    catch (Exception e)
                    {
                        TestRefl.Instance.LogEvent(XEvent.Id.TESTREFL_THREAD_FAILURE, "Failure on UDP listener thread. Exception:\n" + e.ToString());
                    }
                }
            }
        }

        /// <summary>
        /// Processes received packets.
        /// </summary>
        /// <remarks>
        /// This is currently a copy of SGFakeService.Process used by the SG's ThroughputReflector.
        /// If significant changes are needed by another consumer, we are not tied to this protocol.
        /// 
        /// Ignoring the SendTo output because we don't care about a failure in that case.
        /// </remarks>
        private void ProcessReceive (SocketAsyncEventArgs saea)
        {
            if (saea.SocketError != SocketError.Success)
            {
                TestRefl.Instance.Log("SERR|" + saea.SocketError.ToString());
                return;
            }

            // need at least 1 byte for the action
            byte[] buffer = saea.Buffer;
            int offset = saea.Offset;
            int size = saea.BytesTransferred;
            EndPoint ep = saea.RemoteEndPoint;
            IPEndPoint ipep = (IPEndPoint)ep;

            if (size < 1)
            {
                TestRefl.Instance.Log("EMPTYPACKET");
                return;
            }

            // perf counter poke
            if (!TestRefl.Instance.IsStandalone)
            {
                TestReflCounters.Current.PacketRate.Increment();
                TestReflCounters.Current.PacketUDPRate.Increment();
            }

            byte action = buffer[offset];

            switch ((TestReflAction)action)
            {
                case TestReflAction.Drop:
                    // do nothing
                    break;

                case TestReflAction.Reflect:
                case TestReflAction.ReflectTimestamp: // No timestamp!!!  I don't like that log file thing
                    {
                        byte param = buffer[offset + 2];

                        if (size < 3 || param == 0)
                        {
                            _socket.SendTo(buffer, offset, size, SocketFlags.None, ep);
                        }
                        else
                        {
                            // this should always work for valid UDP sizes
                            int toSend = param << 3;
                            if (toSend <= buffer.Length)
                            {
                                _socket.SendTo(buffer, 0, toSend, SocketFlags.None, ep);
                            }
                        }

                        if (TestReflAction.ReflectTimestamp == (TestReflAction)action)
                        {
                            byte seq = 0;
                            if (size >= 2)
                            {
                                seq = buffer[offset + 1];
                            }

                            TestRefl.Instance.Log("|", (TestReflAction)action, size, param, seq);
                        }
                    }
                    break;

                case TestReflAction.ReflectAuthdata:
                    // this action wants us to reflect the packet as well as look up auth data
                    // we need to get better with these actions
                    _socket.SendTo(buffer, offset, size, SocketFlags.None, ep);
                    goto case TestReflAction.DropAuthdata;
                case TestReflAction.DropAuthdata:
                case TestReflAction.AuthdataLookup:
                    {
                        // first we need to make sure the socket is ready
                        ListenThread lt = (ListenThread)saea.UserToken;

                        if (lt.AuthdataSocket == null)
                        {
                            lt.AuthdataSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                            lt.AuthdataSocket.Bind(new IPEndPoint(IPAddress.Any, 0));
                        }

                        // create request
                        MemoryStream ms = new MemoryStream();
                        BinaryWriter wr = new BinaryWriter(ms);
                        byte[] request;

                        int currentRequestID = Interlocked.Increment(ref _authdataRequestID);
                        byte[] addr = ipep.Address.GetAddressBytes();

                        wr.Write((ushort)(SG_MSG_TYPES.SGMSG_TYPE_SPIDATA_REQ));
                        wr.Write((ushort)14);
                        wr.Write(currentRequestID);
                        wr.Write((uint)(((uint)addr[0]) | ((uint)addr[1] << 8) | ((uint)addr[2] << 16) | ((uint)addr[3] << 24)));
                        wr.Write(IPAddress.HostToNetworkOrder((short)(ipep.Port)));

                        request = ms.ToArray();

                        // flush the socket of any back data
                        IPEndPoint adipep = new IPEndPoint(IPAddress.Any, 0);
                        EndPoint adep = adipep;
                        while (lt.AuthdataSocket.Available > 0)
                        {
                            lt.AuthdataSocket.ReceiveFrom(buffer, offset, saea.Count, SocketFlags.None, ref adep);
                        }

                        // send the request
                        adipep.Address = ipep.Address;
                        adipep.Port = 0xFFFF;
                        lt.AuthdataSocket.SendTo(request, adipep);

                        // if we need to reflect it, do so
                        if (((TestReflAction)action) == TestReflAction.AuthdataLookup)
                        {
                            DateTime begin = DateTime.UtcNow;
                            while ((DateTime.UtcNow - begin).TotalMilliseconds < 2000)
                            {
                                if (lt.AuthdataSocket.Available > 0)
                                {
                                    size = lt.AuthdataSocket.ReceiveFrom(buffer, offset, saea.Count, SocketFlags.None, ref adep);
                                    // could validate that the request id was correct...
                                    _socket.SendTo(buffer, offset, size, SocketFlags.None, ep);
                                    return;
                                }
                                else
                                {
                                    Thread.Sleep(0);
                                }
                            }

                            // if we get here, we didn't receive a response, we are going 
                            // to send an empty message back to the client
                            _socket.SendTo(buffer, offset, 0, SocketFlags.None, ep);
                        }
                    }
                    break;

                case TestReflAction.SendBackX:
                    {
                        byte param = buffer[offset + 2];

                        if (size < 3 || param == 0)
                        {
                            // the request wasn't correct/asking for any packets
                        }
                        else
                        {
                            buffer[offset + 1] = 0;

                            for (int i = 0, j = param * 10; i < j; ++i)
                            {
                                _socket.SendTo(buffer, offset, size, SocketFlags.None, ep);
                                buffer[offset + 1] = (byte)((buffer[offset + 1] + 1) % 256);
                            }
                        }
                    }
                    break;

                case TestReflAction.ReflectOffset:
                    {
                        byte param = buffer[offset + 2];

                        if (size < 3 || param == 0)
                        {
                            _socket.SendTo(buffer, offset, size, SocketFlags.None, ep);
                        }
                        else
                        {
                            // this should always work for valid UDP sizes
                            int shift = param << 2;
                            if (shift < size)
                            {
                                _socket.SendTo(buffer, offset + shift, size - shift, SocketFlags.None, ep);
                            }
                        }
                    }
                    break;

                case TestReflAction.ReflectNATData:
                    {
                        Buffer.BlockCopy(ipep.Address.GetAddressBytes(), 0, buffer, offset + 5, 4);
                        Buffer.BlockCopy(BitConverter.GetBytes(ipep.Port), 0, buffer, offset + 9, 4);
                        _socket.SendTo(buffer, offset + 1, 12, SocketFlags.None, ep);
                    }
                    break;

                case TestReflAction.TCPConnectTest:
                    {
                        byte[] ip_bytes = new byte[4];
                        Buffer.BlockCopy(buffer, offset + 4, ip_bytes, 0, 4);
                        IPAddress ip = new IPAddress(ip_bytes);

                        int port = (int)(BitConverter.ToUInt16(buffer, offset + 8));
                        byte ans = 1;

                        using (Socket sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))
                        {
                            try
                            {
                                sock.Connect(ip, port);
                            }
                            catch (SocketException se)
                            {
                                if (se.SocketErrorCode == SocketError.ConnectionRefused)
                                {
                                    ans = 0;
                                }
                                else
                                {
                                    ans = 2;
                                }
                            }
                            catch (Exception)
                            {
                                ans = 2;
                            }
                        }

                        buffer[offset + 2] = ans;

                        _socket.SendTo(buffer, offset, 3, SocketFlags.None, ep);
                    }
                    break;

                case TestReflAction.SGInfoLookup:
                    {
                        byte param = buffer[offset + 2];
                        byte useOldProt = buffer[offset + 4];
                        byte[] replyBytes;

                        try
                        {
                            if (useOldProt > 1)
                            {
                                TestReflSGInfo.UseOldProtocol = null;
                            }
                            else
                            {
                                TestReflSGInfo.UseOldProtocol = (useOldProt == 1);
                            }

                            TestReflSGInfo sgInfo = new TestReflSGInfo(ipep.Address, (ushort)ipep.Port);
                            replyBytes = sgInfo.GetAuthDataVersion(param);
                        }
                        catch (Exception e)
                        {
                            replyBytes = System.Text.Encoding.ASCII.GetBytes(e.ToString());
                        }
                        
                        // Reply back to caller
                        _socket.SendTo(replyBytes, 0, replyBytes.Length, SocketFlags.None, ep);
                    }
                    break;

                case TestReflAction.SgMsg:
                    {
                        // Skip the first 4 bytes (action, seqnum, param, flag). Remainder 
                        // of the payload is the actual SGMSG to send to the SG, provided 
                        // by the caller.
                        ProcessSgMsg(saea, buffer, offset + 4, size - 4 );
                    }
                    break;

                case TestReflAction.XlspAuthDataSimpleRequest:
                case TestReflAction.XlspAuthDataGetAssemblyReferences:
                case TestReflAction.XlspAuthDataGetProperty:
                case TestReflAction.XlspAuthDataGetSubProperty:
                case TestReflAction.XlspAuthDataGetSubSubProperty:
                case TestReflAction.XlspAuthDataGetUserProperty:
                case TestReflAction.XlspAuthDataGetUserSubProperty:
                case TestReflAction.XlspAuthDataGetUserSubSubProperty:
                case TestReflAction.XlspAuthDataGetUserList:
                case TestReflAction.XlspAuthDataCheckPrivilege:
                case TestReflAction.XlspAuthDataCheckPrivacySetting:
                    ProcessLSPAuthdata(saea, action);
                    break;

                default:
                    TestRefl.Instance.Log("|", "BADACTION", ep, action);
                    break;
            }
        }

        private void ProcessSgMsg(SocketAsyncEventArgs saea, byte[] request, int requestStart, int requestLen)
        {
            byte[] buffer = new byte[1500];
            EndPoint ep = saea.RemoteEndPoint;
            IPEndPoint ipep = (IPEndPoint)ep;

            // first we need to make sure the socket is ready
            ListenThread lt = (ListenThread)saea.UserToken;

            if (lt.AuthdataSocket == null)
            {
                lt.AuthdataSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                lt.AuthdataSocket.Bind(new IPEndPoint(IPAddress.Any, 0));
            }

            // flush the socket of any back data
            IPEndPoint adipep = new IPEndPoint(IPAddress.Any, 0);
            EndPoint adep = adipep;
            while (lt.AuthdataSocket.Available > 0)
            {
                lt.AuthdataSocket.ReceiveFrom(buffer, 0, saea.Count, SocketFlags.None, ref adep);
            }

            // send the request
            adipep.Address = ipep.Address;
            adipep.Port = 0xFFFF;
            lt.AuthdataSocket.SendTo(request, requestStart, requestLen, SocketFlags.None, adipep);

            // reflect and recv it
            if (lt.AuthdataSocket.Poll(1000000, SelectMode.SelectRead))
            {
                int size = lt.AuthdataSocket.ReceiveFrom(buffer, 0, saea.Count, SocketFlags.None, ref adep);
                _socket.SendTo(buffer, 0, size, SocketFlags.None, ep);
                return;
            }

            // if we get here, we didn't receive a response. oh well!
        }

        private void ProcessLSPAuthdata (SocketAsyncEventArgs saea, byte action)
        {
            // Pull out same values as in main function
            byte[] buffer = saea.Buffer;
            int offset = saea.Offset;
            int size = saea.BytesTransferred;
            EndPoint ep = saea.RemoteEndPoint;
            IPEndPoint ipep = (IPEndPoint)ep;

            switch ((TestReflAction)action)
            {
                //Request authdata and verify it succeeds
                //returns byte 0 as 0 on success, nonzero on failure
            case TestReflAction.XlspAuthDataSimpleRequest:
                {
                    byte []result=new byte[1]{0};
                    try
                    {
                        Microsoft.XboxLive.XLSP.AuthData ad=Microsoft.XboxLive.XLSP.AuthData.RequestAuthData(ipep.Address, (ushort)ipep.Port);
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(1, e.ToString());
                    }

                    _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                    break;
                }

                //return a list of assembly names that the XLSP authdata library references as a series of null-terminated strings
                //returns byte 0 as 0 on success, nonzero on failure
            case TestReflAction.XlspAuthDataGetAssemblyReferences:
                {
                    byte []result=new byte[1]{0};

                    //find the xlsp assembly
                    System.Reflection.Assembly xlspAsm=null;
                    System.Reflection.Assembly myAsm=System.Reflection.Assembly.GetExecutingAssembly();
                    try
                    {
                        System.Reflection.AssemblyName []refAsmNames=myAsm.GetReferencedAssemblies();
                        foreach (System.Reflection.AssemblyName name in refAsmNames)
                        {
                            if (name.Name.ToLower().Contains("xlsp"))
                            {
                                xlspAsm=System.Reflection.Assembly.ReflectionOnlyLoad(name.Name);
                                break;
                            }
                        }
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(1, "Exception walking reflector assembly references: "+e);
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    if (xlspAsm==null)
                    {
                        result=XlspUtil.CreateStringErrorResponse(2, "xlsp assembly not found in reflector references.");
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    //go through all references
                    System.Collections.Generic.List<byte> resultBuild=new System.Collections.Generic.List<byte>();
                    resultBuild.Add(0);

                    try
                    {
                        System.Reflection.AssemblyName []refAsmNames=xlspAsm.GetReferencedAssemblies();
                        foreach (System.Reflection.AssemblyName name in refAsmNames)
                        {
                            string an=name.Name;
                            for (int i=0; i<an.Length; ++i)
                            {
                                resultBuild.Add((byte)an[i]);
                            }

                            resultBuild.Add((byte)'\0');
                        }
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(3, "Exception walking xlsp assembly references: "+e);
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    //return result
                    result=resultBuild.ToArray();
                    _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);

                    break;
                }

                //Request to return authdata properties
                //returns byte 0 as 0 on success, nonzero on failure
            case TestReflAction.XlspAuthDataGetProperty:
            case TestReflAction.XlspAuthDataGetSubProperty:
            case TestReflAction.XlspAuthDataGetSubSubProperty:
            case TestReflAction.XlspAuthDataGetUserProperty:
            case TestReflAction.XlspAuthDataGetUserSubProperty:
            case TestReflAction.XlspAuthDataGetUserSubSubProperty:
                {
                    //get the authdata
                    byte []result=new byte[1]{0};
                    Microsoft.XboxLive.XLSP.AuthData ad;
                    try
                    {
                        ad=Microsoft.XboxLive.XLSP.AuthData.RequestAuthData(ipep.Address, (ushort)ipep.Port);
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(1, "RequestAuthData failed: "+e);
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    //get a list of properties that they want
                    string []requestedProperties=null;
                    try
                    {
                        requestedProperties=XlspUtil.ParseNullStringSequence(buffer, 1, size-1);
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(2, e.ToString());
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    //if this is a request for a user, find that user, and adjust the property list if needed
                    object userOrAdObject=ad;
                    if ((TestReflAction)action==TestReflAction.XlspAuthDataGetUserProperty || (TestReflAction)action==TestReflAction.XlspAuthDataGetUserSubProperty || (TestReflAction)action==TestReflAction.XlspAuthDataGetUserSubSubProperty)
                    {
                        userOrAdObject=null;

                        ulong xuid=0;
                        int desiredUserOccurance=0;
                        try
                        {
                            string userXuidString=requestedProperties[0];
                            xuid=ulong.Parse(userXuidString);
                            string userOccuranceString=requestedProperties[1];
                            desiredUserOccurance=int.Parse(userOccuranceString);
                            string []requestedPropertiesClipped=new string[requestedProperties.Length-2];
                            System.Array.Copy(requestedProperties, 2, requestedPropertiesClipped, 0, requestedPropertiesClipped.Length);
                            requestedProperties=requestedPropertiesClipped;

                            int curOccurance=0;
                            foreach (Microsoft.XboxLive.XLSP.User user in ad.Users)
                            {
                                if (user.XUID==xuid)
                                {
                                    if (curOccurance==desiredUserOccurance)
                                    {
                                        userOrAdObject=user;
                                        break;
                                    }

                                    ++curOccurance;
                                }
                            }
                        }
                        catch (System.Exception e)
                        {
                            result=XlspUtil.CreateStringErrorResponse(3, e.ToString());
                            _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                            break;
                        }

                        if (userOrAdObject==null)
                        {
                            result=XlspUtil.CreateStringErrorResponse(4, "xuid "+xuid+" not found in authdata");
                            _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                            break;
                        }
                    }

                    //find the sub-object they want the properties of, and adjust the property list if needed
                    object outterProperty=userOrAdObject;
                    if ((TestReflAction)action==TestReflAction.XlspAuthDataGetSubProperty || (TestReflAction)action==TestReflAction.XlspAuthDataGetUserSubProperty ||(TestReflAction)action==TestReflAction.XlspAuthDataGetSubSubProperty || (TestReflAction)action==TestReflAction.XlspAuthDataGetUserSubSubProperty)
                    {
                        outterProperty=null;
                        string outterPropertyName=null;
                        try
                        {
                            outterPropertyName=requestedProperties[0];
                            string []requestedPropertiesClipped=new string[requestedProperties.Length-1];
                            System.Array.Copy(requestedProperties, 1, requestedPropertiesClipped, 0, requestedPropertiesClipped.Length);
                            requestedProperties=requestedPropertiesClipped;

                            outterProperty=XlspUtil.GetObjectProperty(userOrAdObject, outterPropertyName);
                        }
                        catch (System.Exception e)
                        {
                            result=XlspUtil.CreateStringErrorResponse(5, e.ToString());
                            _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                            break;
                        }

                        if (outterProperty==null)
                        {
                            result=XlspUtil.CreateStringErrorResponse(6, "Could not find outter authdata property named "+outterPropertyName);
                            _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                            break;
                        }
                    }

                    //find the sub-sub-object they want the properties of, and adjust the property list if needed
                    object middleProperty=outterProperty;
                    if ((TestReflAction)action==TestReflAction.XlspAuthDataGetSubSubProperty || (TestReflAction)action==TestReflAction.XlspAuthDataGetUserSubSubProperty)
                    {
                        middleProperty=null;
                        string middlePropertyName=null;
                        try
                        {
                            middlePropertyName=requestedProperties[0];
                            string []requestedPropertiesClipped=new string[requestedProperties.Length-1];
                            System.Array.Copy(requestedProperties, 1, requestedPropertiesClipped, 0, requestedPropertiesClipped.Length);
                            requestedProperties=requestedPropertiesClipped;

                            middleProperty=XlspUtil.GetObjectProperty(outterProperty, middlePropertyName);
                        }
                        catch (System.Exception e)
                        {
                            result=XlspUtil.CreateStringErrorResponse(7, e.ToString());
                            _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                            break;
                        }

                        if (middleProperty==null)
                        {
                            result=XlspUtil.CreateStringErrorResponse(8, "Could not find middle authdata property named "+middleProperty);
                            _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                            break;
                        }
                    }

                    //return each of those properties
                    string reply="";
                    try
                    {
                        foreach (string req in requestedProperties)
                        {
                            object finalProperty=XlspUtil.GetObjectProperty(middleProperty, req);

                            if (finalProperty==null)
                            {
                                result=XlspUtil.CreateStringErrorResponse(9, "Could not find a property named "+req);
                                _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                                break;
                            }
                            else
                            {
                                reply+=finalProperty.ToString()+"\0";
                            }
                        }
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(10, e.ToString());
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    result=XlspUtil.CreateStringErrorResponse(0, reply);
                    _socket.SendTo(result, 0, result.Length-1, SocketFlags.None, ep); //send all but the last byte which will be an extra 0 we don't need

                    break;
                }

                //Request to return authdata user xuid list
                //returns byte 0 as 0 on success, nonzero on failure
                case TestReflAction.XlspAuthDataGetUserList:
                {
                    //get the authdata
                    byte []result=new byte[1]{0};
                    Microsoft.XboxLive.XLSP.AuthData ad;
                    try
                    {
                        ad=Microsoft.XboxLive.XLSP.AuthData.RequestAuthData(ipep.Address, (ushort)ipep.Port);
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(1, "RequestAuthData failed: "+e);
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    string xuidList="";
                    foreach (Microsoft.XboxLive.XLSP.User user in ad.Users)
                    {
                        if (xuidList.Length!=0)
                        {
                            xuidList+="\0";
                        }
                        xuidList+=user.XUID.ToString();
                    }

                    result=XlspUtil.CreateStringErrorResponse(0, xuidList);
                    _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);

                    break;
                }

                //Request to return authdata privilege bit
                //returns byte 0 as 0 on success, nonzero on failure
                case TestReflAction.XlspAuthDataCheckPrivilege:
                {
                    //get the authdata
                    byte []result=new byte[1]{0};
                    Microsoft.XboxLive.XLSP.AuthData ad;
                    try
                    {
                        ad=Microsoft.XboxLive.XLSP.AuthData.RequestAuthData(ipep.Address, (ushort)ipep.Port);
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(1, "RequestAuthData failed: "+e);
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    //get the bit they want
                    int requestedBit=0;
                    try
                    {
                        string []parameters=XlspUtil.ParseNullStringSequence(buffer, 1, size-1);
                        requestedBit=int.Parse(parameters[0]);
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(2, e.ToString());
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    //check it
                    bool isBitSet;
                    try
                    {
                        isBitSet=ad.CheckPrivilege((Microsoft.XboxLive.XLSP.Privilege)requestedBit);
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(3, e.ToString());
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    result=XlspUtil.CreateStringErrorResponse(0, isBitSet.ToString());
                    _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);

                    break;
                }

                //Request to return authdata privacy setting
                //returns byte 0 as 0 on success, nonzero on failure
                case TestReflAction.XlspAuthDataCheckPrivacySetting:
                {
                    //get the authdata
                    byte []result=new byte[1]{0};
                    Microsoft.XboxLive.XLSP.AuthData ad;
                    try
                    {
                        ad=Microsoft.XboxLive.XLSP.AuthData.RequestAuthData(ipep.Address, (ushort)ipep.Port);
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(1, "RequestAuthData failed: "+e);
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    //parse the setting they want
                    int requestedSetting=0;
                    try
                    {
                        string []parameters=XlspUtil.ParseNullStringSequence(buffer, 1, size-1);
                        requestedSetting=int.Parse(parameters[0]);
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(2, e.ToString());
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    //get the setting
                    string setting;
                    try
                    {
                        setting=ad.CheckPrivacySetting((Microsoft.XboxLive.XLSP.PrivacySettings)requestedSetting).ToString();
                    }
                    catch (System.Exception e)
                    {
                        result=XlspUtil.CreateStringErrorResponse(3, e.ToString());
                        _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);
                        break;
                    }

                    result=XlspUtil.CreateStringErrorResponse(0, setting);
                    _socket.SendTo(result, 0, result.Length, SocketFlags.None, ep);

                    break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\xsts\wcf\IApis.cs ===
using System.ServiceModel;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.XboxLive.Auth.Policy;

namespace TestXsts.Wcf
{
    [ServiceContract]
    public interface ISimple
    {
        [OperationContract]
        string Echo(string s);

        [OperationContract]
        string GetTokenClaimsString();
    }

    [ServiceContract]
    public interface IAttribute
    {
        [OperationContract]
        [AllowedPlatforms()]
        void Platforms_None();

        [OperationContract]
        [AllowedPlatforms(AuthDeviceTypes.Xbox360)]
        void Platforms_Xbox360();

        [OperationContract]
        [AllowedPlatforms(AuthDeviceTypes.Xbox360, AuthDeviceTypes.PC)]
        void Platforms_Xbox360_Pc();

        [OperationContract]
        [AllowedTitles(0xfffe07d1)]
        void Titles_FFFE07D1();

        [OperationContract]
        [AllowedTitles(0xfffe07d1, 0x00112233, 0xffaa7700)]
        void Titles_FFFE07D1_00112233_FFAA7700();

        [OperationContract]
        [RequiredPrivileges()]
        void Privileges_None();

        [OperationContract]
        [RequiredPrivileges(254)]
        void Privileges_254();

        [OperationContract]
        [RequiredPrivileges(128, 160, 255)]
        void Privileges_128_160_255();

        [OperationContract]
        [RequiredPrivileges(192)]
        [RequiredPrivileges(193)]
        void Privileges_192_193();

        [OperationContract]
        [AuthExists("http://example.com/tiger")]
        void RequiresClaim_Tiger();

        [OperationContract]
        [AuthExists("http://example.com/lion")]
        [AuthExists("http://example.com/tiger")]
        [AuthExists("http://example.com/ocelot")]
        void RequiresClaim_Lion_Tiger_Ocelot();

        [OperationContract]
        [AllowedValues(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder", "Ancient")]
        void AllowedValues_Strings();

        [OperationContract]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder")]
        void AuthEquals_StringAgeGroupElder();

        [OperationContract]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder")]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Language, "1337")]
        void AuthEquals_StringAgeGroupElder_IntegerLanguage1337();

        [OperationContract]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Xuid, 0x0011223344221100)]
        void AuthEquals_Xuid();

        [OperationContract]
        [AuthGreaterThan("http://example.com/int", "28")]
        void AuthGreaterThan_PositiveInteger();

        [OperationContract]
        [AuthGreaterThan("http://example.com/int", "0")]
        void AuthGreaterThan_ZeroInteger();

        [OperationContract]
        [AuthGreaterThan("http://example.com/int", "-28")]
        void AuthGreaterThan_NegativeInteger();

        [OperationContract]
        [AuthGreaterThan("http://example.com/string", "lllll")]
        void AuthGreaterThan_String();

        [OperationContract]
        [AuthLessThan("http://example.com/int", "28")]
        void AuthLessThan_PositiveInteger();

        [OperationContract]
        [AuthLessThan("http://example.com/int", "0")]
        void AuthLessThan_ZeroInteger();

        [OperationContract]
        [AuthLessThan("http://example.com/int", "-28")]
        void AuthLessThan_NegativeInteger();

        [OperationContract]
        [AuthLessThan("http://example.com/string", "lllll")]
        void AuthLessThan_String();

        [OperationContract]
        void UserParameter_UnsignedLong([VerifyUser] ulong userId);

        [OperationContract]
        void UserParameter_NullableUnsignedLong([VerifyUser] ulong ?userId);

        [OperationContract]
        void UserParameter_SignedLong([VerifyUser] long userId);

        [OperationContract]
        void UserParameter_String([VerifyUser] string userId);

        [OperationContract]
        void UserParameter_Binary([VerifyUser] byte []userId);

        [OperationContract]
        void MachineParameter_UnsignedLong([VerifyMachine] ulong machineId);

        [OperationContract]
        void MachineParameter_String([VerifyMachine] string machineId);

        [OperationContract]
        void TitleParameter_UnsignedInt([VerifyTitle] uint titleId);

        [OperationContract]
        void TitleParameter_SignedInt([VerifyTitle] int titleId);

        [OperationContract]
        void TitleParameter_UnsignedLong([VerifyTitle] ulong titleId);

        [OperationContract]
        void TitleParameter_String([VerifyTitle] string titleId);

        [OperationContract]
        void TitleParameter_Binary([VerifyTitle] byte []titleId);

        [OperationContract]
        void TitleParameter_DateTime([VerifyTitle] System.DateTime titleId);

        [OperationContract]
        void CountryParameter_UnsignedInt([VerifyCountry] uint countryId);

        [OperationContract]
        void CountryParameter_NullableSignedInt([VerifyCountry] int ?countryId);

        [OperationContract]
        void CountryParameter_SignedShort([VerifyCountry] short countryId);

        [OperationContract]
        void CountryParameter_UnsignedByte([VerifyCountry] byte countryId);

        [OperationContract]
        void CountryParameter_String([VerifyCountry] string countryId);

        [OperationContract]
        void CountryParameter_Binary([VerifyCountry] byte []countryId);

        [OperationContract]
        void CountryParameter_DateTime([VerifyCountry] System.DateTime countryId);

        [OperationContract]
        [AllowedPlatforms(AuthDeviceTypes.Xbox360)]
        [AllowedTitles(0xfffe07d1)]
        [RequiredPrivileges(254)]
        [AuthExists("http://example.com/tiger")]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder")]
        void MassiveCombo([VerifyUser] ulong userId, [VerifyMachine] ulong machineId, [VerifyTitle] uint titleId, [VerifyCountry] uint countryId);
    };

    [ServiceContract]
    public interface IWebConfig
    {
        [OperationContract]
        void Platforms_Xbox360();

        [OperationContract]
        void Titles_FFFE07D1();

        [OperationContract]
        void Privileges_254();

        [OperationContract]
        void RequiresClaim_Tiger();

        [OperationContract]
        void EqualsAgeGroup_OldEnough();

        [OperationContract]
        void GreaterThanInteger_13();

        [OperationContract]
        void LessThanInteger_13();

        [OperationContract]
        void SimpleAnd();

        [OperationContract]
        void SimpleOr();

        [OperationContract]
        void SimpleNot();

        [OperationContract]
        void ComplexAndOrNot();
    };

    [ServiceContract]
    //        [RequiredPrivileges(253)] TODO: Bug 59943: this attribute is not being allowed on an interface.
    public interface IMixed
    {
        [OperationContract]
        [AllowedPlatforms(AuthDeviceTypes.PC)]
        void PlatformsPC();

        [OperationContract]
        [AllowedPlatforms(AuthDeviceTypes.PC)]
        void PlatformsPC_WebConfigXbox360();

        [OperationContract]
        [AllowedTitles(0xFFFE07D2)]
        void TitlesFFFE07D2();

        [OperationContract]
        [AllowedTitles(0xFFFE07D2)]
        void TitlesFFFE07D2_WebConfigFFFE07D1();
        [OperationContract]
        void Privileges253();

        [OperationContract]
        [RequiredPrivileges(254)]
        void Privileges254();

        [OperationContract]
        [RequiredPrivileges(254)]
        void Privileges254_WebConfig255();

        [OperationContract]
        [AuthExists("http://example.com/lion")]
        void RequiresClaimLion();

        [OperationContract]
        [AuthExists("http://example.com/lion")]
        void RequiresClaimLion_WebConfigTiger();
    };

    [ServiceContract]
    //        [RequiredPrivileges(253)] TODO: Bug 59943: this attribute is not being allowed on an interface.
    public interface IMixedOverride
    {
        [OperationContract]
        [AllowedPlatforms(AuthDeviceTypes.PC)]
        void PlatformsPC();

        [OperationContract]
        [AllowedPlatforms(AuthDeviceTypes.PC)]
        void PlatformsPC_WebConfigXbox360();

        [OperationContract]
        [AllowedTitles(0xFFFE07D2)]
        void TitlesFFFE07D2();

        [OperationContract]
        [AllowedTitles(0xFFFE07D2)]
        void TitlesFFFE07D2_WebConfigFFFE07D1();

        [OperationContract]
        void Privileges252();

        [OperationContract]
        [RequiredPrivileges(254)]
        void Privileges254();

        [OperationContract]
        [RequiredPrivileges(254)]
        void Privileges254_WebConfig255();

        [OperationContract]
        [AuthExists("http://example.com/lion")]
        void RequiresClaimLion();

        [OperationContract]
        [AuthExists("http://example.com/lion")]
        void RequiresClaimLion_WebConfigTiger();
    };
    
    [ServiceContract]
    public interface ICode
    {
        [OperationContract]
        string CallVerifyOperator(string method, string claimType, string value, string overrideIssuer);

        [OperationContract]
        string CallFindClaim(string claimType, string overrideIssuer);
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\xsts\wcf\Apis.cs ===
using System.ServiceModel;
using Microsoft.XboxLive.Auth;
using Microsoft.IdentityModel.Claims;
using System.Text;
using System.Threading;

namespace TestXsts.Wcf
{
    [ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Multiple)]
    public class Simple: ISimple
    {
        public string Echo(string s)
        {
            return s;
        }

        public string GetTokenClaimsString()
        {
            return TestXsts.CommonSimple.GetTokenClaimsString();
        }
    }

    [ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Multiple)]
    public class Attribute: IAttribute
    {
        public void Platforms_None()
        {
        }

        public void Platforms_Xbox360()
        {
        }

        public void Platforms_Xbox360_Pc()
        {
        }

        public void Platforms_WP7_Xbox360()
        {
        }

        public void Titles_FFFE07D1()
        {
        }

        public void Titles_FFFE07D1_00112233_FFAA7700()
        {
        }

        public void Privileges_None()
        {
        }

        public void Privileges_254()
        {
        }

        public void Privileges_128_160_255()
        {
        }

        public void Privileges_192_193()
        {
        }

        public void RequiresClaim_Tiger()
        {
        }

        public void RequiresClaim_Lion_Tiger_Ocelot()
        {
        }

        public void AllowedValues_Strings()
        {
        }

        public void AuthEquals_StringAgeGroupElder()
        {
        }

        public void AuthEquals_StringAgeGroupElder_IntegerLanguage1337()
        {
        }

        public void AuthEquals_Xuid()
        {
        }

        public void AuthGreaterThan_PositiveInteger()
        {
        }

        public void AuthGreaterThan_ZeroInteger()
        {
        }

        public void AuthGreaterThan_NegativeInteger()
        {
        }

        public void AuthGreaterThan_String()
        {
        }

        public void AuthLessThan_PositiveInteger()
        {
        }

        public void AuthLessThan_ZeroInteger()
        {
        }

        public void AuthLessThan_NegativeInteger()
        {
        }

        public void AuthLessThan_String()
        {
        }

        public void UserParameter_UnsignedLong(ulong userId)
        {
        }

        public void UserParameter_NullableUnsignedLong(ulong ?userId)
        {
        }

        public void UserParameter_SignedLong(long userId)
        {
        }

        public void UserParameter_String(string userId)
        {
        }

        public void UserParameter_Binary(byte []userId)
        {
        }

        public void MachineParameter_UnsignedLong(ulong machineId)
        {
        }

        public void MachineParameter_String(string machineId)
        {
        }

        public void TitleParameter_UnsignedInt(uint titleId)
        {
        }

        public void TitleParameter_SignedInt(int titleId)
        {
        }

        public void TitleParameter_UnsignedLong(ulong titleId)
        {
        }

        public void TitleParameter_String(string titleId)
        {
        }

        public void TitleParameter_Binary(byte []titleId)
        {
        }

        public void TitleParameter_DateTime(System.DateTime titleId)
        {
        }

        public void CountryParameter_UnsignedInt(uint countryId)
        {
        }

        public void CountryParameter_NullableSignedInt(int ?countryId)
        {
        }

        public void CountryParameter_SignedShort(short countryId)
        {
        }

        public void CountryParameter_UnsignedByte(byte countryId)
        {
        }

        public void CountryParameter_String(string countryId)
        {
        }

        public void CountryParameter_Binary(byte []countryId)
        {
        }

        public void CountryParameter_DateTime(System.DateTime countryId)
        {
        }

        public void MassiveCombo(ulong userId, ulong machineId, uint titleId, uint countryId)
        {
        }
    };

    [ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Multiple)]
    public class WebConfig: IWebConfig
    {
        public void Platforms_Xbox360()
        {
        }

        public void Titles_FFFE07D1()
        {
        }

        public void Privileges_254()
        {
        }

        public void RequiresClaim_Tiger()
        {
        }

        public void EqualsAgeGroup_OldEnough()
        {
        }

        public void GreaterThanInteger_13()
        {
        }

        public void LessThanInteger_13()
        {
        }

        public void SimpleAnd()
        {
        }

        public void SimpleOr()
        {
        }

        public void SimpleNot()
        {
        }

        public void ComplexAndOrNot()
        {
        }
    };

    [ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Multiple)]
    public class Mixed : IMixed
    {
        public void PlatformsPC()
        {
        }

        public void PlatformsPC_WebConfigXbox360()
        {
        }

        public void TitlesFFFE07D2()
        {
        }

        public void TitlesFFFE07D2_WebConfigFFFE07D1()
        {
        }

        public void Privileges253()
        {
        }

        public void Privileges254()
        {
        }

        public void Privileges254_WebConfig255()
        {
        }

        public void RequiresClaimLion()
        {
        }

        public void RequiresClaimLion_WebConfigTiger()
        {
        }
    };

    [ServiceBehavior(ConcurrencyMode = ConcurrencyMode.Multiple)]
    public class MixedOverride : IMixedOverride
    {
        public void PlatformsPC()
        {
        }

        public void PlatformsPC_WebConfigXbox360()
        {
        }

        public void TitlesFFFE07D2()
        {
        }

        public void TitlesFFFE07D2_WebConfigFFFE07D1()
        {
        }

        public void Privileges252()
        {
        }

        public void Privileges254()
        {
        }

        public void Privileges254_WebConfig255()
        {
        }

        public void RequiresClaimLion()
        {
        }

        public void RequiresClaimLion_WebConfigTiger()
        {
        }
    };

    [ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Multiple)]
    public class Code: ICode
    {
        public string CallVerifyOperator(string method, string claimType, string value, string overrideIssuer)
        {
            Microsoft.XboxLive.Auth.AuthHelper authHelper;
            if (overrideIssuer!=null)
            {
                authHelper=new Microsoft.XboxLive.Auth.AuthHelper(overrideIssuer);
            }
            else
            {
                authHelper=new Microsoft.XboxLive.Auth.AuthHelper();
            }

            return TestXsts.CommonCode.CallVerifyOperator(authHelper, method, claimType, value);
        }

        public string CallFindClaim(string claimType, string overrideIssuer)
        {
            Microsoft.XboxLive.Auth.AuthHelper authHelper;
            if (overrideIssuer!=null)
            {
                authHelper=new Microsoft.XboxLive.Auth.AuthHelper(overrideIssuer);
            }
            else
            {
                authHelper=new Microsoft.XboxLive.Auth.AuthHelper();
            }

            return TestXsts.CommonCode.CallFindClaim(authHelper, claimType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\toolsmgmt\ActionTable.cs ===
using System;
using System.Text;
using System.Collections;
using System.Threading;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Web;
using System.Management;
using System.Runtime.InteropServices;
using System.Web.Services;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Reflection;
using System.Collections.Generic;
using System.Data.SqlClient;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.server.webcache.common;

namespace xonline.server.webcache.toolsmgmt.dll
{
    public class ActionTable
    {
        private static XmlDocument actionXmlDoc;

        static ActionTable()
        {
            Config.SettingChange += new SettingChangeEventHandler(Config_SettingChange);
        }

        public static void Load()
        {
            Load(Config.GetSetting(Setting.wctoolsmgmt_actionTableXML));
            
        }

        public static void Load(string xmlText)
        {
            XmlDocument newXmlDoc;

            StringReader strReader = new StringReader(xmlText);

            newXmlDoc = new XmlDocument();
            newXmlDoc.Load(strReader);

            //  Validate action table

            string xpQuery = "/ToolsmgmtActions/workType/File/Action";
            XmlNodeList list = newXmlDoc.SelectNodes(xpQuery);

            foreach (XmlNode n in list)
            {
                if (n.Attributes["Tool"] == null)
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_113, "Action table is malformed: Could not find a Tool attribute for the actionNode: [" + n.Name + "]");

                if (n.FirstChild == null)
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_114, "Action table is malformed: Could not find command line argument information for node: [" + n.Name + "]");

                if (n.FirstChild.NodeType != XmlNodeType.CDATA)
                    throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_115, "Action table is malformed: First child node of action element was not a CDATA: [" + n.Name + "]");
            }

            actionXmlDoc = newXmlDoc;
        }

        public static bool IsValidWorkType(uint workType)
        {
            string xpQuery = "/ToolsmgmtActions/workType[@ID=\"" + workType + "\"]";

            XmlNodeList list = actionXmlDoc.SelectNodes(xpQuery);

            return (list.Count != 0);
        }

        public static XmlNodeList GetActions(uint workType, string file)
        {
            string xpQuery = "/ToolsmgmtActions/workType[@ID=\"" + workType + "\"]/File[@Extension=\"" + Path.GetExtension(file).ToUpper().Substring(1) + "\"]/Action";

            return actionXmlDoc.SelectNodes(xpQuery);
        }

        public static XmlNode GetAction(uint workType)
        {
            string xpQuery = "/ToolsmgmtActions/workType[@ID=\"" + workType + "\"]";

            return actionXmlDoc.SelectSingleNode(xpQuery);
        }

        public static XmlDocument XmlDoc
        {
            get
            {
                return actionXmlDoc;
            }
        }

        private static void Config_SettingChange(object sender, SettingChangeEventArgs e)
        {
            if (e.Setting == Setting.wctoolsmgmt_actionTableXML)
            {
                Load(e.ValueNew);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\testfd\xsts\soap\Apis.cs ===
using System.Text;
using System.Threading;
using System.Web.Services;

using Microsoft.XboxLive.Auth.Policy;
using Microsoft.XboxLive.Auth.Claims;
using Microsoft.IdentityModel.Claims;

namespace TestXsts.Soap
{
    [WebService]
    public class Simple
    {
        [WebMethod]
        public string Echo(string s)
        {
            return s;
        }

        [WebMethod]
        public string GetTokenClaimsString()
        {
            return TestXsts.CommonSimple.GetTokenClaimsString();
        }
    }

    [WebService]
    public class Attribute
    {
        [WebMethod]
        [AllowedPlatforms()]
        public void Platforms_None()
        {
        }

        [WebMethod]
        [AllowedPlatforms(AuthDeviceTypes.Xbox360)]
        public void Platforms_Xbox360()
        {
        }

        [WebMethod]
        [AllowedPlatforms(AuthDeviceTypes.Xbox360, AuthDeviceTypes.PC)]
        public void Platforms_Xbox360_Pc()
        {
        }

        [WebMethod]
        [AllowedTitles(0xfffe07d1)]
        public void Titles_FFFE07D1()
        {
        }

        [WebMethod]
        [AllowedTitles(0xfffe07d1, 0x00112233, 0xffaa7700)]
        public void Titles_FFFE07D1_00112233_FFAA7700()
        {
        }

        [WebMethod]
        [RequiredPrivileges()]
        public void Privileges_None()
        {
        }

        [WebMethod]
        [RequiredPrivileges(254)]
        public void Privileges_254()
        {
        }

        [WebMethod]
        [RequiredPrivileges(128, 160, 255)]
        public void Privileges_128_160_255()
        {
        }

        [WebMethod]
        [RequiredPrivileges(192)]
        [RequiredPrivileges(193)]
        public void Privileges_192_193()
        {
        }

        [WebMethod]
        [AuthExists("http://example.com/tiger")]
        public void RequiresClaim_Tiger()
        {
        }

        [WebMethod]
        [AuthExists("http://example.com/lion")]
        [AuthExists("http://example.com/tiger")]
        [AuthExists("http://example.com/ocelot")]
        public void RequiresClaim_Lion_Tiger_Ocelot()
        {
        }

        [WebMethod]
        [AllowedValues(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder", "Ancient")]
        public void AllowedValues_Strings()
        {
        }

        [WebMethod]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder")]
        public void AuthEquals_StringAgeGroupElder()
        {
        }

        [WebMethod]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder")]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Language, "1337")]
        public void AuthEquals_StringAgeGroupElder_IntegerLanguage1337()
        {
        }

        [WebMethod]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.Xuid, 0x0011223344221100)]
        public void AuthEquals_Xuid()
        {
        }

        [WebMethod]
        [AuthGreaterThan("http://example.com/int", "28")]
        public void AuthGreaterThan_PositiveInteger()
        {
        }

        [WebMethod]
        [AuthGreaterThan("http://example.com/int", "0")]
        public void AuthGreaterThan_ZeroInteger()
        {
        }

        [WebMethod]
        [AuthGreaterThan("http://example.com/int", "-28")]
        public void AuthGreaterThan_NegativeInteger()
        {
        }

        [WebMethod]
        [AuthGreaterThan("http://example.com/string", "lllll")]
        public void AuthGreaterThan_String()
        {
        }

        [WebMethod]
        [AuthLessThan("http://example.com/int", "28")]
        public void AuthLessThan_PositiveInteger()
        {
        }

        [WebMethod]
        [AuthLessThan("http://example.com/int", "0")]
        public void AuthLessThan_ZeroInteger()
        {
        }

        [WebMethod]
        [AuthLessThan("http://example.com/int", "-28")]
        public void AuthLessThan_NegativeInteger()
        {
        }

        [WebMethod]
        [AuthLessThan("http://example.com/string", "lllll")]
        public void AuthLessThan_String()
        {
        }

        [WebMethod]
        public void UserParameter_UnsignedLong([VerifyUser] ulong userId)
        {
        }

        [WebMethod]
        public void UserParameter_NullableUnsignedLong([VerifyUser] ulong ?userId)
        {
        }

        [WebMethod]
        public void UserParameter_SignedLong([VerifyUser] long userId)
        {
        }

        [WebMethod]
        public void UserParameter_String([VerifyUser] string userId)
        {
        }

        [WebMethod]
        public void UserParameter_Binary([VerifyUser] byte []userId)
        {
        }

        [WebMethod]
        public void MachineParameter_UnsignedLong([VerifyMachine] ulong machineId)
        {
        }

        [WebMethod]
        public void MachineParameter_String([VerifyMachine] string machineId)
        {
        }

        [WebMethod]
        public void TitleParameter_UnsignedInt([VerifyTitle] uint titleId)
        {
        }

        [WebMethod]
        public void TitleParameter_SignedInt([VerifyTitle] int titleId)
        {
        }

        [WebMethod]
        public void TitleParameter_UnsignedLong([VerifyTitle] ulong titleId)
        {
        }

        [WebMethod]
        public void TitleParameter_String([VerifyTitle] string titleId)
        {
        }

        [WebMethod]
        public void TitleParameter_Binary([VerifyTitle] byte []titleId)
        {
        }

        [WebMethod]
        public void TitleParameter_DateTime([VerifyTitle] System.DateTime titleId)
        {
        }

        [WebMethod]
        public void CountryParameter_UnsignedInt([VerifyCountry] uint countryId)
        {
        }

        [WebMethod]
        public void CountryParameter_NullableSignedInt([VerifyCountry] int ?countryId)
        {
        }

        [WebMethod]
        public void CountryParameter_SignedShort([VerifyCountry] short countryId)
        {
        }

        [WebMethod]
        public void CountryParameter_UnsignedByte([VerifyCountry] byte countryId)
        {
        }

        [WebMethod]
        public void CountryParameter_String([VerifyCountry] string countryId)
        {
        }

        [WebMethod]
        public void CountryParameter_Binary([VerifyCountry] byte []countryId)
        {
        }

        [WebMethod]
        public void CountryParameter_DateTime([VerifyCountry] System.DateTime countryId)
        {
        }

        [WebMethod]
        [AllowedPlatforms(AuthDeviceTypes.Xbox360)]
        [AllowedTitles(0xfffe07d1)]
        [RequiredPrivileges(254)]
        [AuthExists("http://example.com/tiger")]
        [AuthEquals(Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.AgeGroup, "Elder")]
        public void MassiveCombo([VerifyUser] ulong userId, [VerifyMachine] ulong machineId, [VerifyTitle] uint titleId, [VerifyCountry] uint countryId)
        {
        }
    };

    [WebService]
    public class WebConfig
    {
        [WebMethod]
        public void Platforms_Xbox360()
        {
        }

        [WebMethod]
        public void Titles_FFFE07D1()
        {
        }

        [WebMethod]
        public void Privileges_254()
        {
        }

        [WebMethod]
        public void RequiresClaim_Tiger()
        {
        }

        [WebMethod]
        public void EqualsAgeGroup_OldEnough()
        {
        }

        [WebMethod]
        public void GreaterThanInteger_13()
        {
        }

        [WebMethod]
        public void LessThanInteger_13()
        {
        }

        [WebMethod]
        public void SimpleAnd()
        {
        }

        [WebMethod]
        public void SimpleOr()
        {
        }

        [WebMethod]
        public void SimpleNot()
        {
        }

        [WebMethod]
        public void ComplexAndOrNot()
        {
        }
    };

    [WebService]
    [RequiredPrivileges(253)]
    public class Mixed
    {
        [WebMethod]
        [AllowedPlatforms(AuthDeviceTypes.PC)]
        public void PlatformsPC()
        {
        }

        [WebMethod]
        [AllowedPlatforms(AuthDeviceTypes.PC)]
        public void PlatformsPC_WebConfigXbox360()
        {
        }

        [WebMethod]
        [AllowedTitles(0xFFFE07D2)]
        public void TitlesFFFE07D2()
        {
        }

        [WebMethod]
        [AllowedTitles(0xFFFE07D2)]
        public void TitlesFFFE07D2_WebConfigFFFE07D1()
        {
        }

        [WebMethod]
        public void Privileges253()
        {
        }

        [WebMethod]
        [RequiredPrivileges(254)]
        public void Privileges254()
        {
        }

        [WebMethod]
        [RequiredPrivileges(254)]
        public void Privileges254_WebConfig255()
        {
        }

        [WebMethod]
        [AuthExists("http://example.com/lion")]
        public void RequiresClaimLion()
        {
        }

        [WebMethod]
        [AuthExists("http://example.com/lion")]
        public void RequiresClaimLion_WebConfigTiger()
        {
        }
    };

    [WebService]
    [RequiredPrivileges(253)]
    public class MixedOverride
    {
        [WebMethod]
        [AllowedPlatforms(AuthDeviceTypes.PC)]
        public void PlatformsPC()
        {
        }

        [WebMethod]
        [AllowedPlatforms(AuthDeviceTypes.PC)]
        public void PlatformsPC_WebConfigXbox360()
        {
        }

        [WebMethod]
        [AllowedTitles(0xFFFE07D2)]
        public void TitlesFFFE07D2()
        {
        }

        [WebMethod]
        [AllowedTitles(0xFFFE07D2)]
        public void TitlesFFFE07D2_WebConfigFFFE07D1()
        {
        }

        [WebMethod]
        public void Privileges252()
        {
        }

        [WebMethod]
        [RequiredPrivileges(254)]
        public void Privileges254()
        {
        }

        [WebMethod]
        [RequiredPrivileges(254)]
        public void Privileges254_WebConfig255()
        {
        }

        [WebMethod]
        [AuthExists("http://example.com/lion")]
        public void RequiresClaimLion()
        {
        }

        [WebMethod]
        [AuthExists("http://example.com/lion")]
        public void RequiresClaimLion_WebConfigTiger()
        {
        }
    };
    
    [WebService]
    public class Code
    {
        [WebMethod]
        public string CallVerifyOperator(string method, string claimType, string value, string overrideIssuer)
        {
            Microsoft.XboxLive.Auth.AuthHelper authHelper;
            if (overrideIssuer!=null)
            {
                authHelper=new Microsoft.XboxLive.Auth.AuthHelper(overrideIssuer);
            }
            else
            {
                authHelper=new Microsoft.XboxLive.Auth.AuthHelper();
            }

            return TestXsts.CommonCode.CallVerifyOperator(authHelper, method, claimType, value);
        }

        [WebMethod]
        public string CallFindClaim(string claimType, string overrideIssuer)
        {
            Microsoft.XboxLive.Auth.AuthHelper authHelper;
            if (overrideIssuer!=null)
            {
                authHelper=new Microsoft.XboxLive.Auth.AuthHelper(overrideIssuer);
            }
            else
            {
                authHelper=new Microsoft.XboxLive.Auth.AuthHelper();
            }

            return TestXsts.CommonCode.CallFindClaim(authHelper, claimType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\toolsmgmt\Service.cs ===
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using xonline.server.webcache.toolsmgmt.common;
using System;
using System.IO;

using xonline.common.config;
using xonline.common.service;

namespace xonline.server.webcache.toolsmgmt.service
{
    public class ToolsMgmtService : System.ServiceProcess.ServiceBase
    {
        ToolsDB _toolsdb;
        int _maxthreadcount;
        int _pingInterval;
        bool _running;
        Semaphore _semaphore;
        XboxLiveThread _mainthread;
        List<RunningJob> _runningJobs;

        /// <summary>
        /// Called when the running job completes.
        /// </summary>
        /// <param name="jobobject"></param>
        /// <param name="args"></param>
        private void OnJobComplete(object jobobject, EventArgs args)
        {
            _semaphore.Release();
            _runningJobs.Remove((RunningJob)jobobject);
        }

        private void OnConfig_SettingChange(object o, SettingChangeEventArgs args)
        {
            int newvalue;

            if (args.Setting == Setting.wctoolsmgmt_pingInterval)
            {
                try
                {

                    newvalue = Config.GetIntSetting(Setting.wctoolsmgmt_pingInterval);
                    _pingInterval = newvalue;
                }
                catch (Exception e)
                {
                    _toolsdb.p_toolsmgmt_job_writelog(0, ErrorLevel.Error, "Either {0} is not set, or is not a valid ping interval in seconds.  Using the default value of 10s.\n\n{0}",
                        Setting.wctoolsmgmt_pingInterval, e.ToString());
                    _pingInterval = 10;
                }
            }
            else if (args.Setting == Setting.wctoolsmgmt_concurrentJobs)
            {
                try
                {
                    newvalue = Config.GetIntSetting(Setting.wctoolsmgmt_concurrentJobs);

                    if (newvalue > _maxthreadcount)
                        _semaphore.Release(newvalue - _maxthreadcount);

                    _maxthreadcount = newvalue;
                }
                catch (Exception e)
                {
                    _toolsdb.p_toolsmgmt_job_writelog(0, ErrorLevel.Error, "Either {0} is not set, or is not a valid number of jobs.  Using the default value of 1 concurrent job.\n\n{0}",
                        Setting.wctoolsmgmt_concurrentJobs, e.ToString());
                    _maxthreadcount = 1;
                }
            }
        }

        /// <summary>
        /// The core of the tools service
        /// </summary>
        /// <param name="args">Command line arguments</param>
        private void ServiceMain(string[] args)
        {
            // Event to insure that jobId is transfered to the working thread
            AutoResetEvent threadStarted = new AutoResetEvent(false);
            IInterfaceInfo ifInfo;
            long jobId;
            int workType;

            // Get toolsdb location from ConfigDB
            ifInfo = Config.GetSingleInterface(Interface.toolsdb);
            _toolsdb = new ToolsDB(ifInfo.IPAddressString, ifInfo.DBName);

            // Set handler for configdb changes
            Config.SettingChange += new SettingChangeEventHandler(OnConfig_SettingChange);

            // Initialize cached configdb values
            _maxthreadcount = Config.GetIntSetting(Setting.wctoolsmgmt_concurrentJobs);
            _pingInterval = Config.GetIntSetting(Setting.wctoolsmgmt_pingInterval);

            // Initialize state variables
            _semaphore = new Semaphore(_maxthreadcount, 500);
            _runningJobs = new List<RunningJob>();
            _running = true;

            // Main service loop 
            while (_running)
            {
                // Consume any threads above _maxthreadcount
                do
                {
                    _semaphore.WaitOne();
                } while (_runningJobs.Count > _maxthreadcount);

                // Wait for a Job (If there is an error,this loop will double the sleep time)
                int unemployed = 1;

                // Assign values to prevent warnings.
                jobId = -1; workType = -1;
                while (_running && unemployed == 1)
                {
                    try
                    {
                        // Get a job from the job queue
                        unemployed = _toolsdb.p_toolsmgmt_job_getnext(out jobId, out workType, Environment.MachineName);
                    }
                    // Catch any SQL error (should only be connection failure)
                    catch(SqlException)
                    {
                        Thread.Sleep(_pingInterval * 1000);
                    }
                    
                    // Pause so we don't hammer the DB
                    Thread.Sleep(_pingInterval * 1000);
                }

                // Make sure that there is work.
                if (unemployed == 1)
                    break;                      

                if (workType == 0)
                {
                    RunningJob job = new RunningJob(_toolsdb, jobId);
                    job.OnJobComplete += OnJobComplete;
                    if (job.DownloadFiles())
                    {
                        if (job.ExecuteNextAction())
                        {
                            _runningJobs.Add(job);
                        }
                    }
                }
                else
                {
                    try
                    {
                        toolsmgmt.dll.ToolsMgmt.DoWork(jobId);
                    }
                    catch (Exception e)
                    {
                        _toolsdb.p_toolsmgmt_job_writelog(jobId, (int)ErrorLevel.Error, "Exception: " + e.ToString());
                        _toolsdb.p_toolsmgmt_job_complete(jobId, (int)JobState.Failed);
                    }
                    finally
                    {
                        _semaphore.Release();
                    }
                }
            }

            while (_runningJobs.Count > 0)
            {
                _semaphore.WaitOne();
            }
        }

        #region Service Callbacks
        /// <summary>
        /// Start the service.  This method should exit in under 10s to allow time
        /// for the framework to start, etc. within the SCM's 30s service start window.
        /// </summary>
        /// <param name="args">Command line arguments</param>
        protected override void OnStart(string[] args)
        {
            // Event to insure that the main thread starts before this
            // method exits.
            AutoResetEvent insurance = new AutoResetEvent(false);

            // Anonymous delegate to wrap argument passing. 
            ThreadStart EntryPoint = delegate
            {
                insurance.Set();
                ServiceMain(args);
            };

            // Create the main thread.
            _mainthread = new XboxLiveThread(EntryPoint);
            _mainthread.Start();

            // Make sure it started.
            insurance.WaitOne();
        }

        /// <summary>
        /// Tell threads to wrap up what they are doing, and wait for
        /// the main thread to complete.
        /// </summary>
        protected override void OnStop()
        {
            _running = false;
            _mainthread.Join();
        }
        #endregion
        #region "Main Entry Point"
        /// <summary>
        /// The main console entry point of this process.
        /// </summary>
        /// <param name="args">Arguments to the ToolsMgmtService</param>
        /// <remarks>
        /// If args contains "/console", the service runs in console mode
        /// </remarks>
        static void Main(string[] args)
        {
            ToolsMgmtService service;
            bool consolemode = false;

            foreach (string arg in args)
            {
                if (arg.ToUpper().Trim() == "/CONSOLE")
                    consolemode = true;
            }
            service = new ToolsMgmtService();
            if (consolemode)
            {
                service.ServiceMain(args);
            }
            else
            {
                System.ServiceProcess.ServiceBase.Run(service);
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\toolsmgmt\ToolsMgmtService.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Data;
using System.Data.Sql;
using xonline.server.webcache.toolsmgmt.common;
using xonline.common.config;
using System.Data.SqlClient;
using System.Threading;

namespace xonline.server.webcache.toolsmgmt.service
{
    delegate void RunningJobCompleteEventHandler(object sender, EventArgs args);
    class RunningJob
    {
        private long _jobId;
        private Guid _actionId;
        private ToolsDB _toolsdb;
        private string _workingDirectory;
        private string _uploadDirectory;
        private bool _isRunning;
        private Semaphore _streams;
        public event RunningJobCompleteEventHandler OnJobComplete;

        /// <summary>
        /// Create a new RunningJob object, which holds the state for a running job.
        /// </summary>
        /// <param name="toolsdb">ToolsDB object</param>
        /// <param name="jobId">Job Id</param>
        public RunningJob(ToolsDB toolsdb, long jobId)
        {
            _toolsdb = toolsdb;
            _jobId = jobId;
            _actionId = Guid.Empty;
            _isRunning = true;
            _streams = new Semaphore(0, 2);
        }

        /// <summary>
        /// Signal that the job should halt after the currently running action completes
        /// </summary>
        public void Stop()
        {
            _isRunning = false;
        }

        /// <summary>
        /// HACK: Delete a directory and log exceptions.
        /// </summary>
        /// <param name="directoryName">Name of the directory to delete</param>
        /// <param name="recursive">true to remove directories, subdirectories, and files in path; otherwise, false.</param>
        private void DeleteDirectory(String directoryName, Boolean recursive)
        {
            try
            {
                Directory.Delete(directoryName, recursive);
            }
            catch (Exception ex)
            {
                _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Warning, "Failed to delete directory: {0}\nException:\n{1}", directoryName, ex.ToString());
            }
        }

        /// <summary>
        /// HACK: Delete a file and log exceptions
        /// </summary>
        /// <param name="fileName">file to delete</param>
        private void DeleteFile(String fileName)
        {
            try
            {
                File.Delete(fileName);
            }
            catch (Exception ex)
            {
                _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Warning, "Failed to delete file: {0}\nException:\n{1}", fileName, ex.ToString());
            }
        }

        /// <summary>
        /// Downloads the files for the job.  Most of the checking is done by the
        /// webservice, so this routing can simply quit if it finds anything wrong.
        /// </summary>
        /// <returns>true if the download was successful.</returns>
        public bool DownloadFiles()
        {
            try
            {
                SqlDataReader reader;
                Dictionary<string, bool> copiedfiles;

                // Get and create the working directory for the job
                _workingDirectory = Config.GetSetting(Setting.wctoolsmgmt_workPathRoot);
                _workingDirectory = Path.Combine(_workingDirectory, _jobId.ToString());
                if (!Directory.Exists(_workingDirectory))
                {
                    Directory.CreateDirectory(_workingDirectory);
                }

                // Get the upload directory from the server
                _toolsdb.p_toolsmgmt_job_getuploadpath(out _uploadDirectory, _jobId);
                if (!Directory.Exists(_uploadDirectory))
                {
                    _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "The upload directory does not exist: {0}", _uploadDirectory);
                    _toolsdb.p_toolsmgmt_job_complete(_jobId, (int)JobState.Failed);
                    DeleteDirectory(_workingDirectory, true);
                    DeleteDirectory(_uploadDirectory, true);
                    OnJobComplete(this, null);
                    return false;
                }

                // Download the files, which are expected to be relative to the upload directory
                copiedfiles = new Dictionary<string, bool>();
                _toolsdb.p_toolsmgmt_job_getfiles(out reader, _jobId);
                while (reader.Read())
                {

                    string filepath, filename, filebase;
                    string workpath, uploadpath;

                    // Get the file from the database
                    filepath = reader.GetString(0);
                    if (Path.IsPathRooted(filepath))
                    {
                        _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Somehow got a rooted path: {0}", filepath);
                        _toolsdb.p_toolsmgmt_job_complete(_jobId, (int)JobState.Failed);
                        DeleteDirectory(_workingDirectory, true);
                        DeleteDirectory(_uploadDirectory, true);
                        OnJobComplete(this, null);
                        reader.Close();
                        return false;
                    }

                    // Break the path into pieces
                    filename = Path.GetFileName(filepath);
                    filebase = Path.GetDirectoryName(filepath);

                    // Construct path to upload and working directory versions
                    uploadpath = Path.Combine(_uploadDirectory, filebase);
                    workpath = Path.Combine(_workingDirectory, filebase);

                    // If the upload path doesn't exist... ummm
                    if (!Directory.Exists(uploadpath))
                    {
                        _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Upload path not found: {0}", filebase);
                        _toolsdb.p_toolsmgmt_job_complete(_jobId, (int)JobState.Failed);
                        DeleteDirectory(_workingDirectory, true);
                        DeleteDirectory(_uploadDirectory, true);
                        OnJobComplete(this, null);
                        reader.Close();
                        return false;
                    }

                    // If the working path doesn't exist ... create it
                    if (!Directory.Exists(workpath))
                    {
                        Directory.CreateDirectory(workpath);
                    }

                    // Construct full file paths
                    //uploadpath = Path.Combine(uploadpath, filename);
                    //workpath = Path.Combine(workpath, filename);

                    // Handle wildcarding differently, since there may be no files
                    // which match the wildcards, which is allowable
                    if (filename.Contains("*") || filename.Contains("?"))
                    {
                        string[] matchingfiles = Directory.GetFiles(uploadpath, filename);

                        if (matchingfiles.Length == 0)
                        {
                            _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Warning, "The pattern matches no uploaded files: {0}",
                                Path.Combine(uploadpath, filename));
                        }
                        else
                        {
                            // Process each matching file.
                            foreach (string matchingfile in matchingfiles)
                            {
                                filename = Path.GetFileName(matchingfile);
                                string uploadfile = Path.Combine(uploadpath, filename);
                                string workfile = Path.Combine(workpath, filename);

                                // If the uploaded file doesn't exist, this may be a BUG!
                                if (!File.Exists(uploadfile))
                                {
                                    _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Info, "OOPS: {0} != {1}",
                                        uploadfile, matchingfile);
                                    uploadfile = matchingfile;
                                }

                                // Catch the odd case where the work file already exists, and isn't 
                                // an overlap from a wildcard match.
                                if (File.Exists(workfile) && !copiedfiles.ContainsKey(uploadfile))
                                {
                                    _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Warning, "Overwriting file previously in the working directory: {0}",
                                        workfile);
                                }
                                _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Info, "Downloading {0}", filepath);
                                File.Copy(uploadfile, workfile);
                                DeleteFile(uploadfile);
                                _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Info, "Downloaded {0}", filepath);
                            }
                        }
                    }
                    else
                    {
                        string uploadfile = Path.Combine(uploadpath, filename);
                        string workfile = Path.Combine(workpath, filename);

                        // If the uploaded file doesn't exist, this may be a BUG!
                        if (!File.Exists(uploadfile))
                        {
                            _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Uploaded file not found: {0}", filepath);
                            _toolsdb.p_toolsmgmt_job_complete(_jobId, (int)JobState.Failed);
                            DeleteDirectory(_workingDirectory, true);
                            DeleteDirectory(_uploadDirectory, true);
                            OnJobComplete(this, null);
                            reader.Close();
                            return false;
                        }

                        // Catch the odd case where the work file already exists, and isn't 
                        // an overlap from a wildcard match.
                        if (File.Exists(workfile) && !copiedfiles.ContainsKey(uploadfile))
                        {
                            _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Warning, "Overwriting file previously in the working directory: {0}",
                                workfile);
                        }
                        _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Info, "Downloading {0}", filepath);
                        File.Copy(uploadfile, workfile);
                        DeleteFile(uploadfile);
                        _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Info, "Downloaded {0}", filepath);
                    }
                }

                // Done reading/copying files.  Close the reader.
                reader.Close();

                // Return Success.
                return true;
            }
            // There is no room for unhandled exceptions, so catch 'em, log 'em, and fail the job
            catch (Exception e)
            {
                _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Unhandled Exception\n{0}", e.ToString());
                _toolsdb.p_toolsmgmt_job_complete(_jobId, (int)JobState.Failed);
                if (Directory.Exists(_workingDirectory))
                {
                    try
                    {
                        DeleteDirectory(_workingDirectory, true);
                    }
                    catch (Exception dnf)
                    {
                        // Should NEVER get here... but in case we do log it.
                        _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Unhandled Exception\n{0}", dnf.ToString());
                    }
                }

                if (Directory.Exists(_uploadDirectory))
                {
                    try
                    {
                        DeleteDirectory(_uploadDirectory, true);
                    }
                    catch (Exception dnf)
                    {
                        // Should NEVER get here... but in case we do log it.
                        _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Unhandled Exception\n{0}", dnf.ToString());
                    }
                }
                OnJobComplete(this, null);
                return false;
            }
        }

        /// <summary>
        /// Apparently the Process.Exited event can be fired before all output
        /// has been written to the output event handlers, so this class wraps
        /// a process object, and adds an _actionId field.
        /// </summary>
        private class ActionProcess : Process
        {
            public Guid _actionId;

            public ActionProcess(Guid actionId)
            {
                _actionId = actionId;
            }
        }

        /// <summary>
        /// Starts the job execution.
        /// </summary>
        /// <returns>Returns true if the action chain was started.</returns>
        public bool ExecuteNextAction()
        {
            try
            {
                JobState state;
                ActionProcess process;
                StringBuilder arguments;
                string name, value, toolname;
                SqlDataReader reader;

                // Try to get the next action.  If not, then exit the chain.
                state = (JobState)_toolsdb.p_toolsmgmt_job_getnextaction(out _actionId, out toolname, _jobId);
                if (state != JobState.Running)
                {
                    _toolsdb.p_toolsmgmt_job_complete(_jobId, (int)state);
                    if (Directory.Exists(_workingDirectory))
                    {
                        try
                        {
                            DeleteDirectory(_workingDirectory, true);
                        }
                        catch (Exception dnf)
                        {
                            // Should NEVER get here... but in case we do log it.
                            _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Unhandled Exception\n{0}", dnf.ToString());
                        }
                    }

                    if (Directory.Exists(_uploadDirectory))
                    {
                        try
                        {
                            DeleteDirectory(_uploadDirectory, true);
                        }
                        catch (Exception dnf)
                        {
                            // Should NEVER get here... but in case we do log it.
                            _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Unhandled Exception\n{0}", dnf.ToString());
                        }
                    }
                    OnJobComplete(this, null);
                    return false;
                }

                // Construct the process arguments
                arguments = new StringBuilder();
                _toolsdb.p_toolsmgmt_action_getparams(out reader, _actionId);
                while (reader.Read())
                {
                    // If either name or value are null, then convert them to empty strings
                    name = (reader.IsDBNull(1)) ? name = "" : reader.GetString(1);
                    value = (reader.IsDBNull(2)) ? "" : reader.GetString(2);

                    // Empty
                    if (name == "" && value == "")
                    {
                        continue;
                    }

                    // Argument
                    if (name == "" && value != "")
                    {
                        if (value.Contains(" "))
                            arguments.AppendFormat("\"{0}\" ", value);
                        else
                            arguments.AppendFormat("{0} ", value);

                        continue;
                    }

                    // Flag
                    if (name != "" && value == "")
                    {
                        arguments.AppendFormat("{0} ", name);

                        continue;
                    }

                    // Named parameter
                    if (name != "" && value != "")
                    {
                        if (value.Contains(" "))
                            arguments.AppendFormat("\"{0}{1}\" ", name, value);
                        else
                            arguments.AppendFormat("{0}{1} ", name, value);

                        continue;
                    }
                }
                reader.Close();

                // Log the command line
                _toolsdb.p_toolsmgmt_action_writeoutput(_actionId, 1, "FileName : " + toolname );
                _toolsdb.p_toolsmgmt_action_writeoutput(_actionId, 1, "Arguments: " + arguments.ToString() );
                _toolsdb.p_toolsmgmt_action_writeoutput(_actionId, 1, "" );

                // Setup the process
                process = new ActionProcess(_actionId);
                process.StartInfo.FileName = toolname;
                process.StartInfo.Arguments = arguments.ToString();
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.CreateNoWindow = false;
                process.StartInfo.LoadUserProfile = true;
                process.StartInfo.WorkingDirectory = _workingDirectory;
                process.EnableRaisingEvents = true;
                process.OutputDataReceived += OnOutputDataRecieved;
                process.ErrorDataReceived += OnErrorDataRecieved;
                process.Exited += OnActionCompleted;

                // Start the process, and enable the asynchronous stdout/stderr 
                // capture.
                process.Start();
                process.BeginErrorReadLine();
                process.BeginOutputReadLine();

                return true;
            }
            // There is no room for unhandled exceptions, so catch 'em, log 'em, and fail the job
            catch (Exception e)
            {
                _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Unhandled Exception\n{0}", e.ToString());
                _toolsdb.p_toolsmgmt_job_complete(_jobId, (int)JobState.Failed);
                DeleteDirectory(_workingDirectory, true);
                DeleteDirectory(_uploadDirectory, true);
                OnJobComplete(this, null);
                return false;
            }
        }

        /// <summary>
        /// Called by the process object when the action is complete.  If the
        /// service is still running, this handler kicks off the next action,
        /// otherwise the job dies here, and the OnJobComplete handler is
        /// called.
        /// </summary>
        /// <param name="sendingProcess"></param>
        /// <param name="args"></param>
        private void OnActionCompleted(object sendingProcess, EventArgs args)
        {
            try
            {
                Process process = (Process)sendingProcess;

                // Wait for streams to complete
                _streams.WaitOne();
                _streams.WaitOne();

                _toolsdb.p_toolsmgmt_action_complete(_actionId, process.ExitCode);
                if (process.ExitCode == -1)
                {
                    _toolsdb.p_toolsmgmt_job_complete(_jobId, (int)JobState.Failed);
                    if (Directory.Exists(_workingDirectory))
                    {
                        try
                        {
                            DeleteDirectory(_workingDirectory, true);
                        }
                        catch (Exception dnf)
                        {
                            // Should NEVER get here... but in case we do log it.
                            _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Unhandled Exception\n{0}", dnf.ToString());
                        }
                    }

                    if (Directory.Exists(_uploadDirectory))
                    {
                        try
                        {
                            DeleteDirectory(_uploadDirectory, true);
                        }
                        catch (Exception dnf)
                        {
                            // Should NEVER get here... but in case we do log it.
                            _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Unhandled Exception\n{0}", dnf.ToString());
                        }
                    }
                    OnJobComplete(this, null);
                    return;
                }
                if (_isRunning)
                {
                    ExecuteNextAction();
                }
                else
                {
                    DeleteDirectory(_workingDirectory, true);
                    DeleteDirectory(_uploadDirectory, true);
                    OnJobComplete(this, null);
                }
                return;
            }
            // There is no room for unhandled exceptions, so catch 'em, log 'em, and fail the job
            catch (Exception e)
            {
                _toolsdb.p_toolsmgmt_job_writelog(_jobId, ErrorLevel.Error, "Unhandled Exception\n{0}", e.ToString());
                _toolsdb.p_toolsmgmt_job_complete(_jobId, (int)JobState.Failed);
                DeleteDirectory(_workingDirectory, true);
                DeleteDirectory(_uploadDirectory, true);
                OnJobComplete(this, null);
                return;
            }            
        }

        private void OnOutputDataRecieved(object sendingProcess, DataReceivedEventArgs outLine)
        {
            if (outLine.Data == null)
            {
                _streams.Release();
                return;
            }
            ActionProcess process = (ActionProcess)sendingProcess;
            _toolsdb.p_toolsmgmt_action_writeoutput(process._actionId, 1, outLine.Data);
        }

        private void OnErrorDataRecieved(object sendingProcess, DataReceivedEventArgs outLine)
        {
            if (outLine.Data == null)
            {
                _streams.Release();
                return;
            }
            ActionProcess process = (ActionProcess)sendingProcess;
            _toolsdb.p_toolsmgmt_action_writeoutput(process._actionId, 2, outLine.Data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\common\BaseConfig.cs ===
// BaseConfig.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Nice configuration wrapper. Provides methods for reading/writing to XML files, and for 
// cleaner handling of config reloads.
// 
// Author: kgoodier 10/2009
// Updated 4/2010
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.IO;
using System.Threading;
using System.Reflection;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.utilities2;

namespace xonline.server.vortex.common
{

[Flags]
public enum ConfigChangeSource
{
    NpdbSetting         = 0x01,
    LocalXml            = 0x02,
    NpdbMultiSetting    = 0x04,
};

public class ConfigChangedEventArgs : EventArgs
{

    public BaseConfig                   BaseConfigInstance;
    public ConfigChangeSource           Source;
    public SettingChangeEventArgs       SettingChangeArgs;
    public MultiSettingChangeEventArgs  MultiSettingChangeArgs;
};


public abstract class BaseConfig
{
    // Called whenever the settings have changed
    public event EventHandler<ConfigChangedEventArgs> ConfigChanged;

    private string              _ConfigInputFile;
    private string              _ConfigOutputFile;
    private FileSystemWatcher   _FileWatcher;
    private int                 _ConfigReloadScheduled;

    public BaseConfig(string componentName)
    {
        _ConfigInputFile = componentName + "Config.xml";
        _ConfigOutputFile = componentName + "ConfigLog.xml";
        _ConfigReloadScheduled = 0;

        // Try to set current path to where our exe lives, to make diagnostic logging easier
        try
        {
            string location = Assembly.GetExecutingAssembly().Location;
            string directory = Path.GetDirectoryName(location);
            System.Environment.CurrentDirectory = directory;
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_INIT_WARNING, e, 
                        "Failed setting the current directory, ignoring");
        }

        // Register for setting changes
        Config.SettingChange += OnSettingChange;
        Config.MultiSettingChange += OnMultiSettingChange;

        // Watch for changes to the local config file
        _FileWatcher = new FileSystemWatcher();
        _FileWatcher.Path = System.Environment.CurrentDirectory;
        _FileWatcher.Filter = _ConfigInputFile;
        _FileWatcher.NotifyFilter = NotifyFilters.LastWrite;
        _FileWatcher.Changed += new FileSystemEventHandler(OnConfigFileChanged);
        _FileWatcher.EnableRaisingEvents = true;

    }

    public void ReloadAll()
    {
        // Load the config
        ConfigChangedEventArgs args = new ConfigChangedEventArgs()
        {
            BaseConfigInstance = this,
            Source = ConfigChangeSource.LocalXml 
                | ConfigChangeSource.NpdbSetting
                | ConfigChangeSource.NpdbMultiSetting,
            SettingChangeArgs = null
        };
        ReloadConfig(args);
    }

    // Abstract methods
    abstract protected void LoadFromNpdb(ConfigInstance config);

    abstract protected void LoadFromXml(XmlReader reader);

    abstract protected void SaveToXml(XmlWriter writer);

    // -------------------------------------------------------------------------
    // LoadFromXml - local helper to create an XmlReader around local config file
    // -------------------------------------------------------------------------
    private void LoadFromXml(string inputFilename)
    {
        Trace.Normal("BaseConfig: Loading config from {0}", inputFilename);
        try
        {
            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.CheckCharacters = false;
            using (XmlReader reader = XmlReader.Create(inputFilename, xmlSettings))
            {
                LoadFromXml(reader);
            }
        }
        catch (FileNotFoundException)
        {
            Trace.Normal("BaseConfig: Unable to find local config file {0}", inputFilename);
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_LOCAL, e,
                        "Error while loading configuration from local xml file {0}. This config info will not be merged in.",
                        inputFilename);
        }
    }

    // -------------------------------------------------------------------------
    // SaveToXml - local helper to create an XmlReader around local config file
    // -------------------------------------------------------------------------
    private void SaveToXml(string outputFilename)
    {
        Trace.Normal("BaseConfig: Saving configuration to {0}", outputFilename);
        try
        {
            XmlWriterSettings xmlSettings = new XmlWriterSettings();
            xmlSettings.CheckCharacters = false;
            xmlSettings.Encoding = System.Text.Encoding.ASCII;
            xmlSettings.NewLineHandling = NewLineHandling.Entitize;
            xmlSettings.NewLineOnAttributes = false;
            xmlSettings.Indent = true;
            using (XmlWriter writer = XmlWriter.Create(outputFilename, xmlSettings))
            {
                SaveToXml(writer);
            }
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_SAVE, e,
                        "Error while saving configuration to xml file {0}. This is for reference only.",
                        outputFilename);
        }
    }

    // -------------------------------------------------------------------------
    // ScheduleConfigReload - schedules a full reload of all settings 2 seconds
    // in the future on a background thread.
    // -------------------------------------------------------------------------
    private void ScheduleConfigReload(
        bool fXmlChanged, 
        SettingChangeEventArgs settingChangeArgs, 
        MultiSettingChangeEventArgs multiSettingChangeArgs)
    {
        int fReloadAlreadyScheduled = Interlocked.CompareExchange(ref _ConfigReloadScheduled, 1, 0);
        if (fReloadAlreadyScheduled == 1)
        {
            // Already have a pending reload
            Trace.Normal("BaseConfig: Config reload already scheduled");
            return;
        }

        // Spawn this off on another thread so we can get our back-to-back callbacks. 
        // This event seems to be called synchronously when the config file changes,
        // and npdb setting changes are likely to happen in groups. So let's just do
        // one actual reload, k?

        ThreadPool.QueueUserWorkItem((WaitCallback)(s =>
        {
            // Note: s is unused
            try
            {
                try
                {
                    // Pause a bit, wait for other quick writes to happen
                    Thread.Sleep(2000);
                }
                finally
                {
                    // Let other things get scheduled now. This is the last chance we can
                    // do this and not miss any potential changes, as the remaining reload
                    // code is not atomic.
                    _ConfigReloadScheduled = 0;
                }

                Trace.Normal("BaseConfig: Reloading config...");

                ConfigChangeSource source = 0;
                if (fXmlChanged)
                    source |= ConfigChangeSource.LocalXml;
                if (settingChangeArgs != null)
                    source |= ConfigChangeSource.NpdbSetting;
                if (multiSettingChangeArgs != null)
                    source |= ConfigChangeSource.NpdbMultiSetting;

                ConfigChangedEventArgs args = new ConfigChangedEventArgs()
                {
                    BaseConfigInstance = this,
                    Source = source,
                    SettingChangeArgs = settingChangeArgs,
                    MultiSettingChangeArgs = multiSettingChangeArgs
                };
                ReloadConfig(args);

                Trace.Normal("Done reloading config.");
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_RELOAD, e,
                            "Error while reloading settings. Ignoring change.");
            }
        }));
    }

    // -------------------------------------------------------------------------
    // ReloadConfig - helper for reloading the configuration and telling registered 
    // parties.
    // -------------------------------------------------------------------------
    private void ReloadConfig(ConfigChangedEventArgs eventArgs)
    {
        // Do delayed action of retrieving new settings
        if ((eventArgs.Source & ConfigChangeSource.NpdbSetting) > 0 ||
            (eventArgs.Source & ConfigChangeSource.NpdbMultiSetting) > 0)
        {
            // @@@ We know exactly which setting changed. We could be smarter here about
            // what we reload.
            LoadFromNpdb(Config.DefaultInstance);
        }

        if ((eventArgs.Source & ConfigChangeSource.LocalXml) > 0)
        {
            LoadFromXml(_ConfigInputFile);
        }

        // Save log
        SaveToXml(_ConfigOutputFile);

        // Tell everybody
        var callback = ConfigChanged;
        if (callback != null)
        {
            callback(this, eventArgs);
        }
    }


    // -------------------------------------------------------------------------
    // OnConfigFileChanged - handles changes to local xml file settings
    // -------------------------------------------------------------------------
    private void OnConfigFileChanged(object sender, FileSystemEventArgs eventArgs)
    {
        Trace.Normal("Config XML file \"{0}\" changed, scheduling a reload", _ConfigInputFile);
        ScheduleConfigReload(true, null, null);
    }

    // -------------------------------------------------------------------------
    // OnSettingChange - handles changes to npdb settings
    // -------------------------------------------------------------------------
    private void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
    {
        Trace.Normal("NPDB setting \"{0}\" changed to value \"{1}\", scheduling a reload", eventArgs.Setting, eventArgs.ValueNew); 
        ScheduleConfigReload(false, eventArgs, null);
    }

    // -------------------------------------------------------------------------
    // OnMultiSettingChange - handles changes to npdb multisettings
    // -------------------------------------------------------------------------
    private void OnMultiSettingChange(object sender, MultiSettingChangeEventArgs eventArgs)
    {
        Trace.Normal("NPDB setting \"{0}\" changed, scheduling a reload", eventArgs.MultiSetting);
        ScheduleConfigReload(false, null, eventArgs);
    }

}

}  // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\toolsmgmt\installer.cs ===
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.Configuration.Install;
using System.ServiceProcess;
using System.ComponentModel;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.service;

[RunInstallerAttribute(true)]
public class ProjectInstaller : System.Configuration.Install.Installer
{

	private ServiceInstaller serviceInstaller;
	private ServiceProcessInstaller processInstaller;
	/// <summary>
	/// Required designer variable.
	/// </summary>
	private System.ComponentModel.Container components = null;

	public ProjectInstaller()
	{
		processInstaller = new ServiceProcessInstaller();
		serviceInstaller = new ServiceInstaller();

		IComponentInfo compInfo = Config.GetComponent(xonline.common.config.Component.toolsmgmtsrv);

		LSAUtil.GrantLogonRights(compInfo.Username);

		processInstaller.Account = System.ServiceProcess.ServiceAccount.User;
		processInstaller.Username = compInfo.Username;

		CSetupSecureResolver decoder = new CSetupSecureResolver();
		processInstaller.Password = decoder.UserSecret(compInfo.Password);

		serviceInstaller.ServiceName = "ToolsMgmtSrv";
		serviceInstaller.DisplayName = "XBL Tools Management Service";
		serviceInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
		serviceInstaller.Committed += new System.Configuration.Install.InstallEventHandler(this.Service_Committed);

		Installers.Add(serviceInstaller);
		Installers.Add(processInstaller);
	}

	/// <summary> 
	/// Clean up any resources being used.
	/// </summary>
	protected override void Dispose(bool disposing)
	{
		if (disposing)
		{
			if (components != null)
			{
				components.Dispose();
			}
		}
		base.Dispose(disposing);
	}


	private void Service_Committed(object sender, System.Configuration.Install.InstallEventArgs e)
	{
		System.ServiceProcess.ServiceController svc = new System.ServiceProcess.ServiceController("ToolsMgmtSrv");
		svc.Start();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\common\BaseService.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Net;
using System.Text;
using System.Threading;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;

// Not implemented yet, but I tried. Maybe again.
// [assembly: xonline.common.installer.XomWindowsServiceInstallerAttribute(
//     Interface.vortex,
//     "Xbox Live Vortex Service",
//     "Sucks in logs and other data, chews it up, and spits it out")]

namespace xonline.server.vortex.common
{
    public partial class BaseService : System.ServiceProcess.ServiceBase
    {
        private bool _fRunAsConsole = false;

        // Singleton
        private static BaseService _instance = null;
        public static BaseService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = BaseService.Create();
                }
                return _instance;
            }
        }

        public bool RunningAsConsole
        {
            get { return _fRunAsConsole; }
        }

        public BaseService()
        {  
        }

        // Need to implement this in child classes:
        // static void Create()
        // {
        //     return new ...
        // }
        
        protected virtual void InitService()
        {                   
            // XomLoggingControl.Init determines the current assembly, and will detect 
            // XblCore
            // if we don't override it here.
            try
            {
                // This ensures we (vortex) get registered, not xblcore.
                Config.Assembly = System.Reflection.Assembly.GetExecutingAssembly();

                // This ensures our xmgmt name is our actual component name:
                // e :vortex
                // and not the name of the .exe:
                // e :vortexsvc
                // XomControlConnection.cs is responsible for this, but i'm hesitant 
                // to change that code. Fortunately jelien provided this override 
                // already.
                XomLoggingControl.OverrideAssemblyName = Config.ComponentName;

                XomLoggingControl.Init();
                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_INIT_ERROR, e, 
                            "Failed initializing XomLogging (no logging will be available)");
                throw;
            }

            // Set up the non-IIS healthcheck listener
            try
            {
                // @@@ TODO should be: Config.GetVirtualInterface(VirtualInterface.vortexfd).VDir;
                xonline.common.health.HealthListener.InitializeHealthListener(Config.ComponentName);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_INIT_ERROR, e, 
                            "Failed initializing the Healthcheck system, continuing for now (no healthchecks will be available)");
                // Go ahead and throw
                throw;
            }
          
        }

        protected virtual void CloseService()
        {
            //xonline.common.health.HealthListener.ShutdownHealthListener();

            XomLoggingControl.Close();
        }

        // Set things in motion so your service can do its work.
        protected override void OnStart(string[] args)
        {
            Trace.Normal("Starting up Vortex");

            // Every 5 seconds, request an additional 10 seconds from the SCM. Use a 
            // threadpool thread. Disposing the timer will stop it. Vortex tends to
            // take a while to start sometimes, but it will never get permanently
            // stuck.

            try
            {
                if (!_fRunAsConsole)
                {
                    int watchdogPeriodInMs = 5000;
                    using (Timer watchdogTimer = new Timer(
                        p => { 
                            try
                            {
                                base.RequestAdditionalTime(watchdogPeriodInMs * 2);
                            }
                            catch (Exception)
                            { }
                        },
                        null,
                        0,
                        watchdogPeriodInMs))
                    {
                        InitService();
                    }
                }
                else
                {
                    // Hmm, awkward to refactor with the using() block.
                    InitService();
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_INIT_ERROR, e, 
                            "Unexpected runtime error while initializing the Vortex service");
                throw;
            }
        }
 
        /// Stop this service.
        protected override void OnStop()
        {
            Trace.Normal("Shutting down Vortex");
            try
            {
                if (!_fRunAsConsole)
                {
                    int watchdogPeriodInMs = 5000;
                    // Wrap the RequestAdditionalTime call in a try/catch to prevent
                    // this error:
                    //   InvalidOperationException (unhandled) "UpdatePendingStatus 
                    //   can only be called during the handling of Start, Stop, Pause 
                    //   and Continue commands."
                    using (Timer watchdogTimer = new Timer(
                        p =>
                        {
                            try
                            {
                                base.RequestAdditionalTime(watchdogPeriodInMs * 2);
                            }
                            catch (Exception)
                            { }
                        },
                        null,
                        0,
                        watchdogPeriodInMs))
                    {
                        CloseService();
                    }
                }
                else
                {
                    // Hmm, awkward to refactor with the using() block.
                    CloseService();
                }
            }
            catch (Exception e)
            {
                // Not so great to have unhandled exceptions past here
                Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_STOP_ERROR, e,
                    "Unhandled error while shutting down the service. Please investigate and fix the code.");
            }
            _instance = null;
            Trace.Normal("Vortex is now dead");
        }

        protected virtual string HandleManangementCommand(ControlRequestEventArgs args)
        {
            string helpText = @"
Vortex Help:
<none>
";
            switch (args.Command.ToLower())
            {
                case "help":
                    // leave handled as false to allow for all handlers to process help.
                    return helpText;

                default:
                    return "";
            }
        }

        private void RunAsConsole(string[] args)
        {
            _fRunAsConsole = true;
            OnStart(args);

            try
            {
                Console.WriteLine("Running as console.  Type \"help\" for commands.");

                Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);

                while (_fRunAsConsole)
                {
                    string sCommand = Console.ReadLine();
                    if (String.IsNullOrEmpty(sCommand))
                        continue;

                    string sResponse = "Invalid Command\r\n";
                    try
                    {
                        ControlRequestEventArgs cmdArgs = new ControlRequestEventArgs(sCommand, 0);
                        sResponse = HandleManangementCommand(cmdArgs);
                    }
                    catch (Exception e)
                    {
                        Console.Write("Error: " + e.ToString() + "\r\n\r\n");
                    }

                    Console.Write(sResponse);
                }
            }
            finally
            {
                OnStop();
            }
        }

        private void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            OnStop();
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string sResponse = BaseService.Instance.HandleManangementCommand(args);
                XomControlConnection.SendMessage(sResponse, args.RequestId);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        // The main entry point for the process
        static void Main(string[] args)
        {           
            BaseService srv = BaseService.Instance;

            bool fRunAsConsole = false;
            
            foreach (string sArg in args)
            {
                if (sArg.ToLower().Contains("console"))
                {
                    fRunAsConsole = true;
                }
            }

            if (fRunAsConsole)
            {
                srv.RunAsConsole(args);
            }
            else
            {
                System.ServiceProcess.ServiceBase.Run(srv);
            }
        }

    }        

    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\common\InputBase.cs ===
// InputBase.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Base class for transport layer.
// 
// Author: kgoodier 4/2010
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Threading;
using System.Net;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.core.etx;

namespace xonline.server.vortex.common
{

public class MessageReceivedEventArgs : EventArgs
{
    // The actual payload. Only one of these is expected to be set.
    public List<VxEvent> Events;
    public List<string> Lines;

    // HTTP Get related context used by LogWeb_v1 entry point
    public HttpGetMessageData HttpGetData;
    
    // Transport-provided request info. Guaranteed to be here.
    public IPEndPoint RemoteEP;
    public IPEndPoint LocalEP;

    // Transport-provided request info.  Not all of these will be filled out.
    public string AuthZHdr;
    public string HttpAuthDataHdr;

    // Others
    public long LifetimeTicks
    {
        get { return MessageReceivedTime.TimeElapsed; }
    }

    private XomRequestTimeElapsed MessageReceivedTime;

    public MessageReceivedEventArgs()
    {
        MessageReceivedTime = new XomRequestTimeElapsed();
    }
}

public class HttpGetMessageData
{
    public const string CookiePrefix = "c.";
    public const string HeaderPrefix = "hdr.";

    public StringDictionary ImplicitData;
    public NameValueCollection QuerystringParameters;
    public string ProducerSymbol;
    public ushort ProducerSequence;
    public string EventName;
    public Event EventManifest;

    public static HttpGetMessageData CreateFromRequest(HttpListenerRequest request)
    {
        HttpGetMessageData md = new HttpGetMessageData()
        {
            QuerystringParameters = request.QueryString
        };

        md.ImplicitData = new StringDictionary();

        foreach (Cookie cookie in request.Cookies)
        {
            md.ImplicitData.Add(CookiePrefix + cookie.Name, cookie.Value);
        }

        foreach (string key in request.Headers.Keys)
        {
            md.ImplicitData.Add(HeaderPrefix + key, request.Headers[key]);
        }

        // Adding headers that are stripped from the header collection
        md.ImplicitData.Add(HeaderPrefix + "User-Agent", request.UserAgent);

        return md;
    }

    public HttpGetMessageData()
    {
        ImplicitData = new StringDictionary();
        QuerystringParameters = new NameValueCollection();
    }
}

public abstract class BaseInput 
{
    public BaseInput(string inputName)
    {
        _NumRequestsPending = 0;
        _MessageCounters = new VortexMessageCountersHelper("In: " + inputName);
    }

    public event EventHandler<MessageReceivedEventArgs> EventsReceived;

    public abstract void Start();
    
    public abstract void Stop();

    protected void DoEventsReceived(object sender, MessageReceivedEventArgs callbackEventArgs)
    {
        EventsReceived(sender, callbackEventArgs);
    }

    public int NumRequestsPending
    {
        get
        {
            return _NumRequestsPending;
        }
    }

    protected VortexMessageCountersHelper MessageCounters
    {
        get
        {
            return _MessageCounters;
        }
    }

    protected int _NumRequestsPending;
    protected VortexMessageCountersHelper _MessageCounters;
}

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\common\PerfCounters.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.server.vortex.common
{
    // The perf counters here are only for files in this \common\ directory.

    [XomComponentPerformanceCounterCategoryAttr( "Messages", "Data collection for the masses, broken down by incoming and outgoing messages per transport type" )]
    public class VortexMessageCounters : XomPerformanceCounterCategory
    {
        // Note:
        //
        // These perf counters are instanced by the transport type.
        //

        public VortexMessageCounters() : base(true)
        {
        }
        
        public virtual VortexMessageCounters this[string transport]
        {
            get
            {
                return (VortexMessageCounters) GetInstance(transport);
            }
        }

        static public VortexMessageCounters Current = new VortexMessageCounters();

        [XomPerformanceCounterAttr(
            "Incoming Bytes Rate", 
            "Number of incoming bytes per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter IncomingBytesRate;

        [XomPerformanceCounterAttr(
            "Incoming Bytes Total", 
            "Number of incoming bytes total", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IncomingBytesTotal;

        [XomPerformanceCounterAttr(
            "Incoming Events Rate",
            "Number of incoming events per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter IncomingEventsRate;

        [XomPerformanceCounterAttr(
            "Incoming Events Total",
            "Number of incoming events total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IncomingEventsTotal;

        [XomPerformanceCounterAttr(
            "Incoming Messages Rate", 
            "Number of incoming request messages per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter IncomingMessagesRate;

        [XomPerformanceCounterAttr(
            "Incoming Messages Total", 
            "Number of incoming request messages", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IncomingMessagesTotal;

        [XomPerformanceCounterAttr(
            "Incoming Messages In Progress", 
            "Number of incoming request messages currently being serviced", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IncomingMessagesInProgress;

        [XomPerformanceCounterAttr(
             "Average Events Per Message",
             "Average number of events per each batched message",
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageEventsPerMessage;

        [XomPerformanceCounterAttr(
             "Average Events Per Message Base",
             "Base for average number of events per each batched message",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageEventsPerMessageBase;

        [XomPerformanceCounterAttr(
             "Average Message Size (in bytes)",
             "Average batched message size expressed in bytes",
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageMessageSize;

        [XomPerformanceCounterAttr(
             "Average Message Size (in bytes) Base",
             "Base for average batched message size expressed in bytes",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageMessageSizeBase;

        [XomPerformanceCounterAttr(
            "IO Operations Pending",
            "Number of pending receive IO operations. When this hits 0, nothing else can be received.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IoOperationsPending;

        [XomPerformanceCounterAttr(
            "IO Receive Buffer Available",
            "Number of bytes available in the receive buffer",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IoReceiveBufferAvailableBytes;

    }

    public class VortexMessageCountersHelper
    {
        private VortexMessageCounters[] _TransportMessageCounters;

        public VortexMessageCountersHelper(string transportType)
        {
            if (!String.IsNullOrEmpty(transportType))
            {
                _TransportMessageCounters = new VortexMessageCounters[2];
                _TransportMessageCounters[0] = VortexMessageCounters.Current;
                _TransportMessageCounters[1] = VortexMessageCounters.Current[transportType];
            }
        }

        public void ForEach(Action<VortexMessageCounters> action)
        {
            try
            {
                if (_TransportMessageCounters == null)
                {
                    return;
                }

                foreach (VortexMessageCounters instance in _TransportMessageCounters)
                {
                    action(instance);
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_PERFCOUNTER_FAILURE, e,
                            "Error incrementing perf counters.");
            }
        }

        public void OnMessageParsed(int messageSizeInBytes, int numEvents)
        {
            // Convenient helper
            ForEach(inst =>
            {
                inst.IncomingBytesRate.IncrementBy(messageSizeInBytes);
                inst.IncomingBytesTotal.IncrementBy(messageSizeInBytes);
                inst.IncomingMessagesRate.Increment();
                inst.IncomingMessagesTotal.Increment();
                inst.IncomingEventsRate.IncrementBy(numEvents);
                inst.IncomingEventsTotal.IncrementBy(numEvents);

                // Averages
                inst.AverageEventsPerMessage.IncrementBy(numEvents);
                inst.AverageEventsPerMessageBase.Increment();
                inst.AverageMessageSize.IncrementBy(messageSizeInBytes);
                inst.AverageMessageSizeBase.Increment();
            });
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\common\InputUdp.cs ===
// InputUdp.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Provides UDP input for the Vortex data processor. For XomLog 'remote' targets.
// 
// Author: kgoodier 10/2009
// Modified 4/2010
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.vortex.common
{

/// <summary>
/// UDP transport for incoming messages. These would typically come from the 'remote' target of
/// XomLog.
/// </summary>
public class UdpInput : BaseInput
{

    // ----------------------------------------------------------------------------------
    // Constructor
    // ----------------------------------------------------------------------------------
    public UdpInput(int port, int receiveBufferSize, int numOverlappedIoOperations)
        : base("Udp")
    {
        _UdpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
        _UdpSocket.ExclusiveAddressUse = true;
        _UdpSocket.Bind(new IPEndPoint(IPAddress.Any, port));
        _UdpSocket.ReceiveBufferSize = receiveBufferSize;
        _NumOverlappedIoOperations = numOverlappedIoOperations;

        // @@@ Verify this! Maybe lock down to a single IP?
        _LocalEndpoint = (IPEndPoint)_UdpSocket.LocalEndPoint;  // cache for speed

        _ListAsyncArgs = new LinkedList<SocketAsyncEventArgs>();
        _ListAsyncArgsLock = new object();

        _fRunning = false;
        Trace.Normal("InputUdp: Listening at port {0}", port);


        _housekeepingTimer = new Timer(
            new TimerCallback(HousekeepingCallback),
            null,
            1000,
            1000);
    }

    private void HousekeepingCallback(object state)
    {
        if (!_fRunning)
        {
            return;
        }

        try
        {
            long receiveBufferRemaining = ReceiveBufferSize - _UdpSocket.Available;
            MessageCounters.ForEach(inst => inst.IoReceiveBufferAvailableBytes.RawValue = receiveBufferRemaining);
        }
        catch (System.ObjectDisposedException)
        {
        }
        catch (Exception e)
        {
            Trace.Error("InputUdp: HousekeepingCallback unexpected error: {0}", e.ToString());
        }
    }

    public int ReceiveBufferSize
    {
        get 
        { 
            return _UdpSocket.ReceiveBufferSize; 
        }
        set 
        { 
            _UdpSocket.ReceiveBufferSize = value;
            Trace.Normal("InputUdp: ReceiveBufferSize set to {0}", _UdpSocket.ReceiveBufferSize);
        }
    }

    public int NumOverlappedIoOperations
    {
        get
        {
            return _NumOverlappedIoOperations;
        }
        set
        {
            int diff = value - _NumOverlappedIoOperations;
            _NumOverlappedIoOperations = value;
            Trace.Normal("InputUdp: NumOverlappedIoOperations set to {0}, difference is {1}", _NumOverlappedIoOperations, diff);

            if (_fRunning)
            {
                if (diff > 0)
                {
                    for (int i = 0; i < diff; i++)
                    {
                        StartNewRequest();
                    }
                }
                else if (diff < 0)
                {
                    lock (_ListAsyncArgsLock)
                    {
                        for (int i = 0; i < Math.Abs(diff); i++)
                        {
                            SocketAsyncEventArgs args = _ListAsyncArgs.Last.Value;
                            CallbackData cd = (CallbackData)args.UserToken;
                            cd.Active = false;
                            _ListAsyncArgs.RemoveLast();
                        }
                    }
                }
            }
        }
    }

    public override void Start()
    {
        Trace.Normal("InputUdp: Start");
        _fRunning = true;

        for (int i = 0; i < _NumOverlappedIoOperations; i++)
        {
            StartNewRequest();
        }
    }

    public override void Stop()
    {
        Trace.Normal("InputUdp: Stop");
        _fRunning = false;
        _housekeepingTimer.Dispose();
        _UdpSocket.Close();
        _UdpSocket = null;

        lock (_ListAsyncArgsLock)
        {
            _ListAsyncArgs.Clear();
        }
    }

    private void StartNewRequest()
    {
        SocketAsyncEventArgs args = new SocketAsyncEventArgs();
        args.SetBuffer(new byte[1500], 0, 1500);
        args.RemoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
        args.Completed += new EventHandler<SocketAsyncEventArgs>(CompletedCallback);
        lock (_ListAsyncArgsLock)
        {
            args.UserToken = new CallbackData()
            {
                Id = _ListAsyncArgs.Count,
                Active = true,
            };
            _ListAsyncArgs.AddLast(args);
        }

        StartRequest(args);
    }

    private void StartRequest(SocketAsyncEventArgs args)
    {
        try
        {
            CallbackData cd = (CallbackData)args.UserToken;
            if (!cd.Active)
            {
                // Need to drain some callbacks, so POOF this one is off to the ether.
                Trace.Low("InputUdp: StartRequest abandoning inactive callback id {0}, NumOverlappedIoOperations={1}",
                    cd.Id, NumOverlappedIoOperations);
                return;
            }

            Interlocked.Increment(ref _NumRequestsPending);
            MessageCounters.ForEach(inst => inst.IoOperationsPending.Increment());
            bool isPending = _UdpSocket.ReceiveFromAsync(args);
            if (!isPending)
            {
                // Completely synchronously. Not really expected, but hey.
                Trace.Normal("InputUdp: ReceiveFromAsync completed synchronously");
                CompletedCallback(this, args);
            }
        }
        catch (Exception e)
        {
            if (_fRunning)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_UDPLISTENER_NEXTREQUEST, e,
                            "Error firing off next request listener, this is fatal. Pending listeners: {0}",
                            _NumRequestsPending);
                throw;
            }
        }
    }

    private void CompletedCallback(object sender, SocketAsyncEventArgs callbackArgs)
    {
        try
        {
            System.Threading.Interlocked.Decrement(ref _NumRequestsPending);
            MessageCounters.ForEach(inst => { 
                inst.IoOperationsPending.Decrement();
                inst.IncomingMessagesInProgress.Increment();
            });

            CallbackData cd = (CallbackData)callbackArgs.UserToken;

            if (callbackArgs.SocketError == SocketError.Success &&
                callbackArgs.BytesTransferred > 0)
            {
                // Split message into events and make callback
                using (MemoryStream stream = new MemoryStream(
                    callbackArgs.Buffer, 
                    0, 
                    callbackArgs.BytesTransferred))
                {
                    var events = VxProtocol.ReadStream(stream);

                    MessageCounters.OnMessageParsed(callbackArgs.BytesTransferred, events.Count);

                    MessageReceivedEventArgs eventArgs = new MessageReceivedEventArgs()
                    {
                        Events = events,
                        RemoteEP = callbackArgs.RemoteEndPoint as IPEndPoint,
                        LocalEP = _LocalEndpoint
                    };

                    // Note that _LocalEndpoint has an IP of "0.0.0.0" since we aren't 
                    // binding to any explicit interface. This is currently OK since
                    // the only consumer of LocalEP is XrlScanUtil, which doesn't
                    // run for UDP (VxEvent) inputs.

                    // At this point, we've copied everything out of the callbackArgs
                    // buffer and can reuse it before doing the remaining processing.
                    StartRequest(callbackArgs);

                    // Let next layer handle the message
                    DoEventsReceived(this, eventArgs);
                }
            }
            else if (callbackArgs.SocketError == SocketError.OperationAborted)
            {
                // Shutting down
            }
            else
            {
                // Oh noes, badness. Hmph.
                Trace.Error("InputUdp: ReceiveFromAsync SocketError={0}, BytesTransferred={1}",
                    callbackArgs.SocketError, callbackArgs.BytesTransferred);

                // Could be spammy, watch closely...
                Xom.NtEvent(XEvent.Id.VORTEX_UDPLISTENER_CALLBACK,
                            "Error returned in the UDP callback.\r\n" +
                            "SocketError: {0}, BytesTransferred: {1}, RemoteEndPoint: {2}, Id: {3}",
                            callbackArgs.SocketError, 
                            callbackArgs.BytesTransferred, 
                            callbackArgs.RemoteEndPoint, 
                            cd.Id);
            }

        }
        catch (Exception e)
        {
            if (_fRunning)
            {
                // Must handle all exceptions, even though we can't do much
                Xom.NtEvent(XEvent.Id.VORTEX_UDPLISTENER_PROCESSREQUEST, e,
                            "Generic error while handling the UDP callback.\r\n" +
                            "SocketError: {0}, BytesTransferred: {1}, RemoteEndPoint: {2}",
                            callbackArgs.SocketError, callbackArgs.BytesTransferred, callbackArgs.RemoteEndPoint);
            }
        }
        finally
        {
            MessageCounters.ForEach(inst => inst.IncomingMessagesInProgress.Decrement());
        }
    }

    // ----------------------------------------------------------------------------------
    // PRIVATE STUFF HERE
    // ----------------------------------------------------------------------------------

    private Socket                          _UdpSocket;
    private IPEndPoint                      _LocalEndpoint;
    private bool                            _fRunning;
    private int                             _NumOverlappedIoOperations;
    private LinkedList<SocketAsyncEventArgs> _ListAsyncArgs;
    private object                          _ListAsyncArgsLock;
    private Timer                           _housekeepingTimer;

    // Used for asynchronous I/O in UdpClient stuff 
    private class CallbackData
    {
        public int Id;
        public bool Active;
    }

}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\toolsmgmt\autoprop.cs ===
using System;
using System.Text;
using System.Collections;
using System.Threading;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Web;
using System.Management;
using System.Runtime.InteropServices;
using System.Web.Services;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Reflection;
using System.Collections.Generic;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.offerutil;
using System.Data.SqlClient;

using xonline.tools.framework;
using xonline.server.webcache.common;
using xonline.server.webcache.toolsmgmt.common;

[assembly: XomAreaDefinition(XomAreaName.wctoolsmgmtlog)]
[assembly: XomAreaDefinition(XomAreaName.wctoolsmgmttrace)]

namespace xonline.server.webcache.toolsmgmt.dll
{
    public class WorkFilesReadyInfo
    {
        public long workId;
        public string relativePath;
    };

    public class ToolsMgmt
    {
        #region Data members

        static private ToolsDB _toolsdb;

        #endregion

        #region Properties

        static public string ConfigWorkPathRoot
        {
            get
            {
                return Config.GetSetting(Setting.wctoolsmgmt_workPathRoot);
            }
        }

        static public string ConfigUploadBasePath
        {
            get
            {
                return Config.GetSetting(Setting.wctoolsmgmt_uploadPathRoot);
            }
        }
        #endregion

        #region CTOR/DTOR

        static ToolsMgmt()
        {
            try
            {
                // Get the Database interface from configdb
                IInterfaceInfo info = Config.GetSingleInterface(Interface.toolsdb);
                _toolsdb = new ToolsDB(info.IPAddressString, info.DBName);

                ActionTable.Load();
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_118, e, e.Message);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_82, e);
            }
        }

        public ToolsMgmt()
        {
            try
            {
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_120, e, e.Message);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_83, e);
            }
        }

        #endregion

        #region DoWork thread and associated methods

        /// <summary>
        /// Copy all files from the upload staging directory to the work files
        /// directory.
        /// </summary>
        /// <param name="wfri">Information about the work item including work ID.</param>
        /// <returns></returns>
        static private void CopyWorkFiles(WorkFilesReadyInfo wfri)
        {
            _toolsdb.p_toolsmgmt_job_getuploadpath(out wfri.relativePath, wfri.workId);
            Xom.Log(XomAreaName.wctoolsmgmttrace, "CopyWorkFiles: workId=" + wfri.workId + " relativePath=\"" + wfri.relativePath + "\"");

            WorkInfo wi = new WorkInfo(ConfigWorkPathRoot, wfri.workId);

            string filePath = Path.Combine(ConfigUploadBasePath, wfri.relativePath);

            if (!Directory.Exists(filePath))
            {
                Xom.Log(XomAreaName.wctoolsmgmttrace, "CopyWorkFiles: Upload directory does not exist: \"" + filePath + "\"");
                throw new ApplicationException("CopyWorkFiles: Upload directory does not exist: \"" + filePath + "\"");
            }

            // Create the working directory
            Directory.CreateDirectory(wi.WorkDirectory);

            foreach (string file in Directory.GetFiles(filePath, "*"))
            {
                string dest = Path.Combine(wi.WorkDirectory, Path.GetFileName(file));

                Xom.Log(XomAreaName.wctoolsmgmttrace, "CopyWorkFiles: Copying \"" + file + "\" to \"" + dest + "\"");
                File.Move(file, dest);
                Xom.Log(XomAreaName.wctoolsmgmttrace, "CopyWorkFiles: Copied.");
            }
        }

        /// <summary>
        /// Runs specified tools from the action table on the files in the
        /// working directory.
        /// </summary>
        /// <param name="gwsr">Tools result code and console output copied here.</param>
        static private void ProcessWorkFiles(WorkFilesReadyInfo wfri)
        {
            //-------------------------------------------------------------
            //
            //

            WorkInfo wi = new WorkInfo(ConfigWorkPathRoot, wfri.workId);

            //-------------------------------------------------------------
            // 
            // 

            WorkManager wm = new WorkManager(wi);

            try
            {
                if (wm.Execute())
                {
                    _toolsdb.p_toolsmgmt_job_complete(wfri.workId, (int)JobState.Completed);
                }
                else
                {
                    _toolsdb.p_toolsmgmt_job_complete(wfri.workId, (int)JobState.Failed);
                }
            }
            catch (Exception e)
            {
                _toolsdb.p_toolsmgmt_job_writelog(wfri.workId, (int)ErrorLevel.Error, "Exception: " + e.ToString());
                _toolsdb.p_toolsmgmt_job_complete(wfri.workId, (int)JobState.Failed);
                throw e;
            }
        }

        /// <summary>
        /// Remove all files from the work files directory.
        /// </summary>
        /// <param name="wfri">Information about the work item including work ID.</param>
        /// <returns></returns>
        static private void RemoveWorkFiles(WorkFilesReadyInfo wfri)
        {
            Xom.Log(XomAreaName.wctoolsmgmttrace, "RemoveWorkFiles: workId=" + wfri.workId + " relativePath=\"" + wfri.relativePath + "\"");

            WorkInfo wi = new WorkInfo(ConfigWorkPathRoot, wfri.workId);

            if (Directory.Exists(wi.WorkDirectory))
            {
                Directory.Delete(wi.WorkDirectory, true);
                Xom.Log(XomAreaName.wctoolsmgmttrace, "RemoveWorkFiles: Working directory removed: \"" + wi.WorkDirectory + "\"");
            }
            else
            {
                Xom.Log(XomAreaName.wctoolsmgmttrace, "RemoveWorkFiles: Working directory does not exist: \"" + wi.WorkDirectory + "\"");
            }
        }

        /// <summary>
        /// Thread that performs the file move from HST to WBCA, and then executes tools
        /// 
        /// WARNING!!!  I believe there are some cases where if multiple threads are
        /// within BlockingQueue.Dequeue, one of them can get back null from the queue.  
        /// However, this class was designed specifically for toolsmgmt widget, which will
        /// only have a single thread dequeuing objects, so the current implementation 
        /// is safe.  If we ever change the design of toolsmgmt widget to have
        /// multiple dequeuing threads, we will need to revisit the design of BlockingQueue.
        /// </summary>
        static public void DoWork(long workId)
        {
            WorkFilesReadyInfo wfri = new WorkFilesReadyInfo();
            wfri.workId = workId;

            try
            {
                CopyWorkFiles(wfri);
                ProcessWorkFiles(wfri);
            }
            catch (Exception e)
            {
                _toolsdb.p_toolsmgmt_job_complete(wfri.workId, (int)JobState.Failed);
                _toolsdb.p_toolsmgmt_job_writelog(wfri.workId, (int)ErrorLevel.Error, "Exception thrown while processing job:\r\n" + e.ToString());
                Xom.NtEvent(XEvent.Id.WEBCACHE_CODE_122, e, "Exception thrown while processing job.");
            }
            finally
            {
                RemoveWorkFiles(wfri);
            }
        }

        #endregion
    }




    /* CLASS: WorkManager
     * ------------------------------------
     * A class used to take the contents (files) of a work directory and an
     * action XML table and contstruct a sequence of command lines that
     * need to be executed which it then can run using the Execute() method
     *
    */
    public class WorkManager
    {
        private const string _actionTableWorkDirToken = "%W";
        private const string _actionTableFilenameToken = "%F";
        private const string _actionTableTitleIDToken = "%T";
        private const string _actionTableDecimalTitleIDToken = "%D";
        private const string _actionTableLBServerToken = "%L";
        private const string _actionTableMMServerToken = "%M";
        private const string _actionTableOfferFileToken = "%O";
        private const string _actionTableOfferFile2Token = "%O2";
        private const string _actionTableOfferIdToken = "%D";
        private const string _actionTableOfferId2Token = "%D2";

        public int _exitCode;
        public string _consoleOutput;
        private WorkInfo _wi;

        ArrayList _work;


        public string ToolPath
        {
            get
            {
                return Config.GetSetting(Setting.setup_approot) + "\\xbltools";   // N.B. This subdirectory is tied to the directory created by \msi\xbltools\xbltoos.msi
            }
        }

        public string DefaultLBServer
        {
            get
            {
                return Config.GetSetting(Setting.wctoolsmgmt_autopropLBServer);
            }
        }


        public string DefaultMMServer
        {
            get
            {
                return Config.GetSetting(Setting.wctoolsmgmt_autopropMMServer);
            }
        }

        /// <summary>
        /// Returns the first file in the provided array who's extension is .cab
        /// </summary>
        /// <param name="workFiles"></param>
        /// <returns></returns>
        private string GetCABFromList(string[] workFiles)
        {
            foreach (string file in workFiles)
            {
                if (Path.GetExtension(file).ToLower().Substring(1) == "cab")
                    return file;
            }

            return null;
        }

        private static ulong GetOfferId(string offerFile)
        {
            string offerIdString;
            ulong offerId = 0;

            LiveOffer lo = OfferUtil.LoadOffer(offerFile);

            if (lo.contentOfferCollection == null)
                throw new Exception(string.Format("Invalid Offer File \"{0}\":  No content offers in file.", offerFile));

            ContentOffer co = lo.contentOfferCollection[0];

            offerIdString = co.offerBasicInfo.offerID.ToLower();
            if (offerIdString.Substring(0, 2) == "0x")
            {
                offerIdString = offerIdString.Substring(2);
                offerId = UInt64.Parse(offerIdString, NumberStyles.HexNumber);
            }
            else
                offerId = UInt64.Parse(offerIdString);

            return offerId;
        }

        private static string GetTitleId(string offerFile)
        {
            LiveOffer lo = OfferUtil.LoadOffer(offerFile);

            if (lo.contentOfferCollection == null)
                throw new Exception(string.Format("Invalid Offer File \"{0}\":  No content offers in file.", offerFile));

            ContentOffer co = lo.contentOfferCollection[0];

            return co.offerBasicInfo.primaryTitleID.ToLower().Replace("0x","");
        }

        private static ContentOfferType GetContentType(string offerFile)
        {
            LiveOffer lo = OfferUtil.LoadOffer(offerFile);

            if (lo.contentOfferCollection == null)
                throw new Exception(string.Format("Invalid Offer File \"{0}\":  No content offers in file.", offerFile));

            ContentOffer co = lo.contentOfferCollection[0];

            return co.contentOfferType;
        }

        private static string[] GetOfferFilesFromList(string[] files)
        {
            ArrayList offerFilesList = new ArrayList();

            foreach (string file in files)
            {
                if (Path.GetExtension(file).ToLower().Substring(1) == "offer")
                    offerFilesList.Add(file);
            }

            return (string[])offerFilesList.ToArray(typeof(string));
        }

        private bool CabWork()
        {
            string[] workFiles = Directory.GetFiles(_wi.WorkDirectory);
            string cabFile;
            string[] offerFiles;

            cabFile = GetCABFromList(workFiles);
            if (cabFile == null)
                throw new Exception(string.Format("This work type ({0}) expects a single CAB file, but none were provided.", _wi.WorkType));

            XmlNodeList liveContentActionNodes = ActionTable.GetActions(_wi.WorkType, cabFile);
            XmlNodeList liveOfferActionNodes = ActionTable.GetActions(_wi.WorkType, "*.offer");

            if (liveContentActionNodes.Count != 1)
                throw new Exception(string.Format("Expected a single LiveContent action node in the action table, but found {0}.", liveContentActionNodes.Count));

            if (liveOfferActionNodes.Count != 1)
                throw new Exception(string.Format("Expected a single LiveOffer action node in the action table, but found {0}.", liveOfferActionNodes.Count));

            XmlNode liveContentActionNode = liveContentActionNodes[0];
            XmlNode liveOfferActionNode = liveOfferActionNodes[0];

            string liveContentCmd = ToolPath + "\\" + liveContentActionNode.Attributes["Tool"].Value;
            string liveContentArgs = liveContentActionNode.FirstChild.Value;
            int seq = Convert.ToInt32(liveContentActionNode.Attributes["Sequence"].Value);

            // Perform token replacement in the LiveContent argument string:
            liveContentArgs = liveContentArgs.Replace(_actionTableWorkDirToken, _wi.WorkDirectory);     // replace %F with the full filespec for the file
            liveContentArgs = liveContentArgs.Replace(_actionTableFilenameToken, cabFile);              // replace %F with the full filespec for the file
            liveContentArgs = liveContentArgs.Replace(_actionTableTitleIDToken, _wi.TitleId);           // replace %T with the 8 character hex formatted title ID

            ToolShell x = new ToolShell(_wi.WorkId, liveContentCmd, liveContentArgs, _wi.WorkDirectory, seq);

            // In this case we don't execute from the queue since we need to interject some logic
            // in between LiveContent and LiveOffer.  The only reason we queue up the work item is
            // for later retrieval of console output and exit code.
            QueueWork(x);

            string szLog = "EXECUTE|" + x.sequence + '|' +
                x.commandLine + "|" +
                x.commandArgs;

            Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
            Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

            x.Execute();

            if (x.Failed)
                return false;

            //  Now we need to check to see how many offers were produced.  In the case of a trailer
            //  submission, there will be two offers which require two runs of liveoffer
            offerFiles = Directory.GetFiles(Path.GetDirectoryName(cabFile), "0x" + Path.GetFileNameWithoutExtension(cabFile) + "*.offer");

            if (offerFiles.Length == 0)
            {
                throw new Exception(
                    string.Format("Default offer file not found.  No offer files matching \"{0}\" were found in \"{1}\".",
                    "0x" + Path.GetFileNameWithoutExtension(cabFile) + "*.offer",
                    Path.GetDirectoryName(cabFile)));
            }

            foreach (string offerFile in offerFiles)
            {
                string liveOfferCmd = ToolPath + "\\" + liveOfferActionNode.Attributes["Tool"].Value;
                string liveOfferArgs = liveOfferActionNode.FirstChild.Value;
                seq = Convert.ToInt32(liveOfferActionNode.Attributes["Sequence"].Value);

                // Perform token replacement in the LiveOffer argument string:
                liveOfferArgs = liveOfferArgs.Replace(_actionTableOfferFileToken, offerFile); // replace %O with the full filespec for the file
                liveOfferArgs = liveOfferArgs.Replace(_actionTableTitleIDToken, _wi.TitleId); // replace %T with the 8 character hex formatted title ID

                x = new ToolShell(_wi.WorkId, liveOfferCmd, liveOfferArgs, _wi.WorkDirectory, seq);

                // In this case we don't execute from the queue since we need to interject some logic
                // in between LiveContent and LiveOffer.  The only reason we queue up the work item is
                // for later retrieval of console output and exit code.
                QueueWork(x);

                szLog = "EXECUTE|" + x.sequence + '|' +
                    x.commandLine + "|" +
                    x.commandArgs;

                Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

                x.Execute();

                if (x.Failed)
                    return false;
            }

            return true;
        }

        private bool CabAndOfferWork()
        {
            string[] workFiles = Directory.GetFiles(_wi.WorkDirectory);
            string cabFile;
            string[] offerFiles;
            ulong offerId;
            string titleId2 = _wi.TitleId;

            cabFile = GetCABFromList(workFiles);
            if (cabFile == null)
                throw new Exception(string.Format("This work type ({0}) expects a single CAB file, but none were provided.", _wi.WorkType));

            offerFiles = GetOfferFilesFromList(workFiles);
            if (offerFiles.Length != 1)
            {
                throw new Exception(string.Format("This work type ({0}) only accepts a single offer file, but {1} offer files were provided.", _wi.WorkType, offerFiles.Length));
            }

            offerId = GetOfferId(offerFiles[0]);

            //
            //  55066 - Use title id contained in offer file when running
            //          liveoffer for demos.
            //

            if (GetContentType(offerFiles[0]) == ContentOfferType.GameDemo)
            {
                titleId2 = GetTitleId(offerFiles[0]);
            }

            XmlNodeList liveContentActionNodes = ActionTable.GetActions(_wi.WorkType, cabFile);
            XmlNodeList liveOfferActionNodes = ActionTable.GetActions(_wi.WorkType, offerFiles[0]);

            foreach (XmlNode liveContentActionNode in liveContentActionNodes)
            {
                string liveContentCmd = ToolPath + "\\" + liveContentActionNode.Attributes["Tool"].Value;
                string liveContentArgs = liveContentActionNode.FirstChild.Value;
                int seq = Convert.ToInt32(liveContentActionNode.Attributes["Sequence"].Value);

                // Perform token replacement in the LiveContent argument string:
                liveContentArgs = liveContentArgs.Replace(_actionTableWorkDirToken, _wi.WorkDirectory);     // replace %F with the full filespec for the file
                liveContentArgs = liveContentArgs.Replace(_actionTableFilenameToken, cabFile);              // replace %F with the full filespec for the file
                liveContentArgs = liveContentArgs.Replace(_actionTableTitleIDToken, _wi.TitleId);           // replace %T with the 8 character hex formatted title ID
                liveContentArgs = liveContentArgs.Replace(_actionTableOfferFileToken, offerFiles[0]);       // replace %O with the full filespec for the first offer file
                liveContentArgs = liveContentArgs.Replace(_actionTableOfferIdToken, offerId.ToString("X")); // replace %D with the first offer id

                ToolShell x = new ToolShell(_wi.WorkId, liveContentCmd, liveContentArgs, _wi.WorkDirectory, seq);

                QueueWork(x);
            }

            foreach (XmlNode liveOfferActionNode in liveOfferActionNodes)
            {
                string liveOfferCmd = ToolPath + "\\" + liveOfferActionNode.Attributes["Tool"].Value;
                string liveOfferArgs = liveOfferActionNode.FirstChild.Value;
                int seq = Convert.ToInt32(liveOfferActionNode.Attributes["Sequence"].Value);

                // Perform token replacement in the LiveOffer argument string:
                liveOfferArgs = liveOfferArgs.Replace(_actionTableWorkDirToken, _wi.WorkDirectory);   // replace %F with the full filespec for the file
                liveOfferArgs = liveOfferArgs.Replace(_actionTableOfferFileToken, offerFiles[0]);     // replace %F with the full filespec for the file
                liveOfferArgs = liveOfferArgs.Replace(_actionTableTitleIDToken, titleId2);            // replace %T with the 8 character hex formatted title ID

                ToolShell x = new ToolShell(_wi.WorkId, liveOfferCmd, liveOfferArgs, _wi.WorkDirectory, seq);

                QueueWork(x);
            }

            foreach (ToolShell x in _work)
            {
                string szLog = "EXECUTE|" + x.sequence + '|' +
                    x.commandLine + "|" +
                    x.commandArgs;

                Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

                x.Execute();


                // If the toolshell fails, consider the autoprop a failure and bail immediately
                if (x.Failed)
                    return false;
            }
            return true;
        }

        private bool CabAnd2OffersWork()
        {
            string[] workFiles = Directory.GetFiles(_wi.WorkDirectory);
            string cabFile;
            string[] offerFiles;
            ulong offerId;
            ulong offerId2;

            cabFile = GetCABFromList(workFiles);
            if (cabFile == null)
                throw new Exception(string.Format("This work type ({0}) expects a single CAB file, but none were provided.", _wi.WorkType));

            offerFiles = GetOfferFilesFromList(workFiles);
            if (offerFiles.Length != 2)
            {
                throw new Exception(string.Format("This work type ({0}) expects 2 offer files, but {1} offer files were provided.", _wi.WorkType, offerFiles.Length));
            }

            offerId = GetOfferId(offerFiles[0]);
            offerId2 = GetOfferId(offerFiles[1]);

            XmlNodeList liveContentActionNodes = ActionTable.GetActions(_wi.WorkType, cabFile);
            XmlNodeList liveOfferActionNodes = ActionTable.GetActions(_wi.WorkType, offerFiles[0]);

            foreach (XmlNode liveContentActionNode in liveContentActionNodes)
            {
                string liveContentCmd = ToolPath + "\\" + liveContentActionNode.Attributes["Tool"].Value;
                string liveContentArgs = liveContentActionNode.FirstChild.Value;
                int seq = Convert.ToInt32(liveContentActionNode.Attributes["Sequence"].Value);

                // Perform token replacement in the LiveContent argument string:
                liveContentArgs = liveContentArgs.Replace(_actionTableWorkDirToken, _wi.WorkDirectory);      // replace %F with the full filespec for the file
                liveContentArgs = liveContentArgs.Replace(_actionTableFilenameToken, cabFile);              // replace %F with the full filespec for the file
                liveContentArgs = liveContentArgs.Replace(_actionTableTitleIDToken, _wi.TitleId);            // replace %T with the 8 character hex formatted title ID
                liveContentArgs = liveContentArgs.Replace(_actionTableOfferFile2Token, offerFiles[1]);       // replace %O2 with the full filespec for the first offer file
                liveContentArgs = liveContentArgs.Replace(_actionTableOfferId2Token, offerId2.ToString("X")); // replace %D2 with the first offer id
                liveContentArgs = liveContentArgs.Replace(_actionTableOfferFileToken, offerFiles[0]);       // replace %O with the full filespec for the first offer file
                liveContentArgs = liveContentArgs.Replace(_actionTableOfferIdToken, offerId.ToString("X")); // replace %D with the first offer id

                ToolShell x = new ToolShell(_wi.WorkId, liveContentCmd, liveContentArgs, _wi.WorkDirectory, seq);

                QueueWork(x);
            }

            foreach (XmlNode liveOfferActionNode in liveOfferActionNodes)
            {
                string liveOfferCmd = ToolPath + "\\" + liveOfferActionNode.Attributes["Tool"].Value;
                string liveOfferArgs = liveOfferActionNode.FirstChild.Value;
                int seq = Convert.ToInt32(liveOfferActionNode.Attributes["Sequence"].Value);

                // Perform token replacement in the LiveOffer argument string:
                liveOfferArgs = liveOfferArgs.Replace(_actionTableOfferFile2Token, offerFiles[1]);     // replace %O2 with the full filespec for the file
                liveOfferArgs = liveOfferArgs.Replace(_actionTableOfferFileToken, offerFiles[0]);     // replace %O with the full filespec for the file
                liveOfferArgs = liveOfferArgs.Replace(_actionTableTitleIDToken, _wi.TitleId);          // replace %T with the 8 character hex formatted title ID

                ToolShell x = new ToolShell(_wi.WorkId, liveOfferCmd, liveOfferArgs, _wi.WorkDirectory, seq);

                QueueWork(x);
            }

            foreach (ToolShell x in _work)
            {
                string szLog = "EXECUTE|" + x.sequence + '|' +
                    x.commandLine + "|" +
                    x.commandArgs;

                Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

                x.Execute();


                // If the toolshell fails, consider the autoprop a failure and bail immediately
                if (x.Failed)
                    return false;
            }
            return true;
        }

        private bool OfferWork()
        {
            string[] workFiles = Directory.GetFiles(_wi.WorkDirectory);
            string[] offerFiles;
            ulong offerId;
            string titleId2 = _wi.TitleId;

            offerFiles = GetOfferFilesFromList(workFiles);
            if (offerFiles.Length != 1)
            {
                throw new Exception(string.Format("This work type ({0}) only accepts a single offer file, but {1} offer files were provided.", _wi.WorkType, offerFiles.Length));
            }

            offerId = GetOfferId(offerFiles[0]);

            //
            //  55066 - Use title id contained in offer file when running
            //          liveoffer for demos.
            //

            if (GetContentType(offerFiles[0]) == ContentOfferType.GameDemo)
            {
                titleId2 = GetTitleId(offerFiles[0]);
            }

            XmlNodeList liveOfferActionNodes = ActionTable.GetActions(_wi.WorkType, offerFiles[0]);

            foreach (XmlNode liveOfferActionNode in liveOfferActionNodes)
            {
                string liveOfferCmd = ToolPath + "\\" + liveOfferActionNode.Attributes["Tool"].Value;
                string liveOfferArgs = liveOfferActionNode.FirstChild.Value;
                int seq = Convert.ToInt32(liveOfferActionNode.Attributes["Sequence"].Value);

                // Perform token replacement in the LiveOffer argument string:
                liveOfferArgs = liveOfferArgs.Replace(_actionTableWorkDirToken, _wi.WorkDirectory);   // replace %F with the full filespec for the file
                liveOfferArgs = liveOfferArgs.Replace(_actionTableOfferFileToken, offerFiles[0]);     // replace %F with the full filespec for the file
                liveOfferArgs = liveOfferArgs.Replace(_actionTableTitleIDToken, titleId2);            // replace %T with the 8 character hex formatted title ID

                ToolShell x = new ToolShell(_wi.WorkId, liveOfferCmd, liveOfferArgs, _wi.WorkDirectory, seq);

                QueueWork(x);
            }

            foreach (ToolShell x in _work)
            {
                string szLog = "EXECUTE|" + x.sequence + '|' +
                    x.commandLine + "|" +
                    x.commandArgs;

                Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

                x.Execute();


                // If the toolshell fails, consider the autoprop a failure and bail immediately
                if (x.Failed)
                    return false;
            }
            return true;
        }

        private bool XlastWork()
        {
            string[] workFiles = Directory.GetFiles(_wi.WorkDirectory);

            foreach (string fspec in workFiles)
            {
                XmlNodeList nodeList = ActionTable.GetActions(_wi.WorkType, fspec);

                foreach (XmlNode actionNode in nodeList)
                {
                    if (actionNode.Attributes["Tool"].Value != "")
                    {
                        string cmd = ToolPath + "\\" + actionNode.Attributes["Tool"].Value;
                        int seq = Convert.ToInt32(actionNode.Attributes["Sequence"].Value);
                        string args = actionNode.FirstChild.Value;


                        // Perform token replacement in the argument string:
                        args = args.Replace(_actionTableWorkDirToken, _wi.WorkDirectory);                       // replace %F with the full filespec for the file
                        args = args.Replace(_actionTableFilenameToken, fspec);                                   // replace %F with the full filespec for the file
                        args = args.Replace(_actionTableTitleIDToken, _wi.TitleId);                              // replace %T with the 8 character hex formatted title ID
                        args = args.Replace(_actionTableDecimalTitleIDToken, _wi.DecimalTitleId.ToString());     // replace %D with the unsigned 32bit int decimal 
                        args = args.Replace(_actionTableLBServerToken, DefaultLBServer);                         // replace %L with the full filespec for the file
                        args = args.Replace(_actionTableMMServerToken, DefaultMMServer);                         // replace %M with the full filespec for the file

                        ToolShell x = new ToolShell(_wi.WorkId, cmd, args, _wi.WorkDirectory, seq);

                        QueueWork(x);
                    }
                }
            }

            foreach (ToolShell x in _work)
            {
                string szLog = "EXECUTE|" + x.sequence + '|' +
                    x.commandLine + "|" +
                    x.commandArgs;

                Xom.Log(XomAreaName.wctoolsmgmtlog, szLog);
                Xom.Log(XomAreaName.Reporting_v2, szLog); // target is not currently enabled, so this is a no-op

                x.Execute();

                // If the toolshell fails, consider the autoprop a failure and bail immediately
                if (x.Failed)
                    return false;
            }
            return true;
        }

        public WorkManager(WorkInfo wi)
        {
            _wi = wi;
        }


        void QueueWork(ToolShell x)
        {
            int insert = -1;

            for (int idx = 0; idx < _work.Count; idx++)
            {
                ToolShell y = (ToolShell)_work[idx];

                if (x.sequence < y.sequence)
                    insert = idx;
            }

            if (insert >= 0)
                _work.Insert(insert, x);
            else
                _work.Add(x);
        }



        public bool Execute()
        {
            _work = new ArrayList();

            switch (_wi.WorkType)
            {
                case 1: // XLAST
                    {
                        return XlastWork();
                    }

                case 2: // CAB
                    {
                        return CabWork();
                    }

                case 3: // CAB + Offer
                    {
                        return CabAndOfferWork();
                    }

                case 4: // CAB + 2 Offers
                    {
                        return CabAnd2OffersWork();
                    }

                case 5: // Offer Only
                    {
                        return OfferWork();
                    }

                default:  // XLAST
                    {
                        return false;
                    }
            }
        }


        public int ExitCode
        {
            get
            {
                foreach (ToolShell x in _work)
                {
                    if (x.exitCode != 0)
                        return x.exitCode;
                }

                return 0;
            }
        }


        public string ConsoleOutput
        {
            get
            {
                string ret = "\n";

                foreach (ToolShell x in _work)
                {
                    ret += "\n-------------------------------------------------------------------------------\n";
                    ret += "Command:   " + x.commandLine + "\n";
                    ret += "Arguments: " + x.commandArgs + "\n";
                    ret += "Exit Code: " + x.exitCode.ToString() + "\n";
                    ret += "-------------------------------------------------------------------------------\n";
                    ret += x.consoleOutput;
                    ret += "\n";
                }

                ret += "\n";
                return ret;
            }
        }
    }





    /* CLASS: ToolShell
     * ------------------------------------
     * A simple class to manage the information related to the execution of a 
     * single command line tool (including the tool command line and arguments
     * as well as return codes and console output)
     *
    */
    public class ToolShell
    {
        public bool executed;
        public int exitCode;
        public string consoleOutput;
        public string commandLine;
        public string commandArgs;
        public int sequence;
        public string workingDirectory;
        private StringBuilder _output;
        private Semaphore _streams;
        private Guid _actionId;
        private static ToolsDB _toolsdb;

        private void OnOutputDataRecieved(object sendingProcess, DataReceivedEventArgs outLine)
        {
            if (outLine.Data == null)
            {
                _streams.Release();
            }
            else
            {
                _output.AppendLine(outLine.Data);
                _toolsdb.p_toolsmgmt_action_writeoutput(_actionId, 1, outLine.Data);
            }
        }

        private void OnErrorDataRecieved(object sendingProcess, DataReceivedEventArgs outLine)
        {
            if (outLine.Data == null)
            {
                _streams.Release();
            }
            else
            {
                _output.AppendLine(outLine.Data);
                _toolsdb.p_toolsmgmt_action_writeoutput(_actionId, 2, outLine.Data);
            }
        }

        public ToolShell(long jobId, string cmd, string args, string dir, int seq)
        {
            int rank;

            executed = false;
            exitCode = -1;
            consoleOutput = "<not executed>";
            sequence = seq;
            commandLine = cmd;
            commandArgs = args;
            workingDirectory = dir;
            _streams = new Semaphore(0, 2);

            if (_toolsdb == null)
            {
                // Get the Database interface from configdb
                IInterfaceInfo info = Config.GetSingleInterface(Interface.toolsdb);
                _toolsdb = new ToolsDB(info.IPAddressString, info.DBName);
            }

            _toolsdb.p_toolsmgmt_step_create(out _actionId, out rank, jobId, cmd);
            _toolsdb.p_toolsmgmt_action_setarguments(_actionId, commandArgs);
        }

        public int Execute()
        {
            try
            {
                _toolsdb.p_toolsmgmt_action_start(_actionId);
                _output = new StringBuilder();
                Process process = new Process();
                process.StartInfo.FileName = commandLine;
                process.StartInfo.Arguments = commandArgs;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.WorkingDirectory = workingDirectory;
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.CreateNoWindow = true;
                process.OutputDataReceived += OnOutputDataRecieved;
                process.ErrorDataReceived += OnErrorDataRecieved;
                
                _toolsdb.p_toolsmgmt_action_writeoutput(_actionId, 1, "COMMAND  : " + commandLine );
                _toolsdb.p_toolsmgmt_action_writeoutput(_actionId, 1, "ARGUMENTS: " + commandArgs );
                _toolsdb.p_toolsmgmt_action_writeoutput(_actionId, 1, "===============================================" );

                process.Start();
                process.BeginErrorReadLine();
                process.BeginOutputReadLine();
                process.WaitForExit();
                executed = true;
                _streams.WaitOne();
                consoleOutput = _output.ToString();
                exitCode = process.ExitCode;

                _toolsdb.p_toolsmgmt_action_complete(_actionId, exitCode);
            }
            catch (Exception e)
            {
                consoleOutput = "Tool exception: " + e.ToString();
                _toolsdb.p_toolsmgmt_action_writeoutput(_actionId, 2, "Tool exception: " + e.ToString());
                exitCode = -1;
            }

            return exitCode;
        }


        public bool Failed
        {
            get
            {
                return (!executed) || (exitCode != 0);
            }
        }
    }





    /* CLASS: WorkInfo
     * ------------------------------------
     * A simple class to manage the encoding of work related information
     * (workID, titleID, workType) in the work directory name
     *
    */
    public class WorkInfo
    {
        long workId;
        uint workType;
        string titleId;
        string workRoot;
        private static ToolsDB _toolsdb;

        public WorkInfo(string root, long id)
        {
            if (_toolsdb == null)
            {
                // Get the Database interface from configdb
                IInterfaceInfo info = Config.GetSingleInterface(Interface.toolsdb);
                _toolsdb = new ToolsDB(info.IPAddressString, info.DBName);
            }

            workId = id;
            workRoot = root;
            /*
                        string[] dirs = Directory.GetDirectories(workRoot, id.ToString() + ".*");
            
                        if (dirs.Length == 0)
                            throw new XboxWebException (XEvent.Id.WEBCACHE_CODE_129, "Unable to locate a work directory for workId = " + id.ToString());

                        if (dirs.Length > 1)
                            throw new XboxWebException (XEvent.Id.WEBCACHE_CODE_130, "More than one workType found for workId = " + id.ToString());

                        int idxFirst = dirs[0].IndexOf('.');
                        int idxLast  = dirs[0].LastIndexOf('.');
            
                        if (idxFirst == 0 || idxFirst == idxLast)
                            throw new XboxWebException (XEvent.Id.WEBCACHE_CODE_131, "Directory name is not formatted correctly: " + dirs[0]);
                        */
            int t, w;
            _toolsdb.p_toolsmgmt_job_getinfo(out w, out t, id);
            workType = (uint)w;
            titleId = t.ToString("X8");
        }


        public WorkInfo(string root, uint w, string t)
        {
            if (_toolsdb == null)
            {
                // Get the Database interface from configdb
                IInterfaceInfo info = Config.GetSingleInterface(Interface.toolsdb);
                _toolsdb = new ToolsDB(info.IPAddressString, info.DBName);
            }

            workType = w;
            titleId = t;
            workRoot = root;
            CTitleId convert = new CTitleId(t);
            _toolsdb.p_toolsmgmt_job_create(out workId, (int)JobPriority.Normal, (int)convert.uiTitleId, (int)w, t);

            if (Directory.Exists(WorkDirectory))
                throw new XboxWebException(XEvent.Id.WEBCACHE_CODE_132, "WorkDirectory for new workId already exists: " + WorkDirectory);

            Directory.CreateDirectory(WorkDirectory);
        }


        public string WorkDirectory
        {
            get
            {
                return workRoot + "\\" + workId.ToString();
            }
        }

        public long WorkId
        {
            get
            {
                return workId;
            }
        }

        public uint WorkType
        {
            get
            {
                return workType;
            }
        }

        public string TitleId
        {
            get
            {
                return titleId.ToUpper();
            }
        }

        public uint DecimalTitleId
        {
            get
            {
                return Convert.ToUInt32(TitleId, 16);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\common\Trace.cs ===
// Trace.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Tracing helpers for Vortex.
// 
// Author: kgoodier 4/2010
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;

using xonline.common.mgmt;

namespace xonline.server.vortex.common
{

/// <summary>
/// Trace class - handy wrappers for making tracing prettier and easier 
/// </summary>
internal static class Trace
{
    internal static void Low(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.VortexTrace, LogLevel.L_LOW, format, args);
    }

    internal static void Normal(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.VortexTrace, LogLevel.L_NORMAL, format, args);
    }

    internal static void High(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.VortexTrace, LogLevel.L_HIGH, format, args);
    }

    internal static void Error(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.VortexTrace, LogLevel.L_ERROR, format, args);
    }

    private static string Timestamp
    {
        get
        {
            DateTime dt = DateTime.Now;
            return dt.ToString(@"hh:mm:ss.fff ");
        }
    }

}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\common\ProjectInstaller.cs ===
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.Configuration.Install;
using System.ServiceProcess;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;

using xonline.common.config;
using xonline.common.service;

namespace xonline.server.vortex.common
{

//[RunInstallerAttribute(true)]
public abstract class VortexProjectInstaller: System.Configuration.Install.Installer
{
    abstract protected string ServiceDisplayName { get; }
    abstract protected string ServiceDescription { get; }

#if !RUNONDEVMACHINE
    private ServiceInstaller serviceInstaller;
    private ServiceProcessInstaller processInstaller;
#endif

    /// <summary>
    /// Required designer variable.
    /// </summary>
    private System.ComponentModel.Container components = null;

    public VortexProjectInstaller()
    {
        // This call is required by the Designer.
        InitializeComponent();
    }

    /// <summary> 
    /// Clean up any resources being used.
    /// </summary>
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if(components != null)
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }


    private void InitializeComponent()
    {
#if !RUNONDEVMACHINE
        processInstaller = new ServiceProcessInstaller();
        serviceInstaller = new MyServiceInstaller();

        IComponentInfo compInfo = Config.GetComponent(Config.ComponentName);

        LSAUtil.GrantLogonRights( compInfo.Username );

        processInstaller.Account = System.ServiceProcess.ServiceAccount.User;
        processInstaller.Username = compInfo.Username;

        CSetupSecureResolver decoder = new CSetupSecureResolver();
        processInstaller.Password = decoder.UserSecret(compInfo.Password);

        serviceInstaller.ServiceName = Config.ComponentName;
        serviceInstaller.DisplayName = ServiceDisplayName;
        serviceInstaller.Description = ServiceDescription;
        serviceInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
        serviceInstaller.Committed += new System.Configuration.Install.InstallEventHandler(this.OnCommitted);
        Installers.Add(serviceInstaller);
        Installers.Add(processInstaller);
#endif

    }

    private void OnCommitted(object sender, System.Configuration.Install.InstallEventArgs e)
    {
        System.ServiceProcess.ServiceController svc = new System.ServiceProcess.ServiceController(Config.ComponentName);
        if (svc.Status != ServiceControllerStatus.Running &&
            svc.Status != ServiceControllerStatus.StartPending)
        {
            svc.Start();
        }
    }
}

public class MyServiceInstaller : ServiceInstaller
{
    public override void Install(IDictionary stateSaver)
    {
        try
        {
            base.Install(stateSaver);
        }
        catch (Win32Exception e)
        {
            if (e.ErrorCode != -2147467259)  //  0x80004005
                throw;
            Context.LogMessage("Service install failed, but ignoring because it seems like the service was already installed. The exception was:");
            Context.LogMessage(e.ToString());
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\fd\PerfCounters.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.server.vortex.fd
{
    [XomComponentPerformanceCounterCategoryAttr( "Service", "Data collection for the masses" )]
    public class VortexCounters : XomPerformanceCounterCategory
    {
        public VortexCounters() : base(true)
        {
        }
        
        static public VortexCounters Current = new VortexCounters();
        
        [XomPerformanceCounterAttr(
            "Events Without Manifest Rate",
            "Number of incoming events per second without an ETX manifest",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EventsWithoutManifestRate;

        [XomPerformanceCounterAttr(
            "Events Without Manifest Total",
            "Number of incoming events total without an ETX manifest",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter EventsWithoutManifestTotal;

        [XomPerformanceCounterAttr(
            "Input I/O Threads - Available", 
            "Number of available threadpool threads. Represents the difference between the max number of threads and the number currently active.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputIOThreadsAvailable;

        [XomPerformanceCounterAttr(
            "Input I/O Threads - Max", 
            "Maximum number of threadpool threads ever available", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputIOThreadsMax;
        
        [XomPerformanceCounterAttr(
            "Input I/O Threads - Min", 
            "Minimum number of threadpool threads kept alive by the system", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputIOThreadsMin;

        [XomPerformanceCounterAttr(
            "Input Worker Threads - Available",
            "Number of available threadpool threads. Represents the difference between the max number of threads and the number currently active.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputWorkerThreadsAvailable;

        [XomPerformanceCounterAttr(
            "Input Worker Threads - Max",
            "Maximum number of threadpool threads ever available",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputWorkerThreadsMax;

        [XomPerformanceCounterAttr(
            "Input Worker Threads - Min",
            "Minimum number of threadpool threads kept alive by the system",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputWorkerThreadsMin;

        [XomPerformanceCounterAttr(
             "Message Batch Size Average",
             "Average number of messages processed for each IO to worker thread context switch",
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageMessageBatchSize;

        [XomPerformanceCounterAttr(
             "Message Batch Size Average (base)",
             "Average number of messages processed for each IO to worker thread context switch (base)",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageMessageBatchSizeBase;

        [XomPerformanceCounterAttr(
            "Message Context Switches/sec",
            "Number of switches from an IO thread to a worker thread per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MessageContextSwitchRate;

        [XomPerformanceCounterAttr(
             "Message Latency Average (ms)",
             "Average message latency, in milliseconds, introduced by Vortex",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageMessageLatency;

        [XomPerformanceCounterAttr(
             "Message Latency Average (ms) (base)",
             "Average message latency, in milliseconds, introduced by Vortex (base)",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageMessageLatencyBase;

        [XomPerformanceCounterAttr(
            "Messages In Progress",
            "Number of request contexts currently being processed. This does not include input transports.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MessagesInProgress;

        [XomPerformanceCounterAttr(
            "Message Queue Discarded",
            "Number of messages discarded due to a full queue",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MessageQueueDiscarded;

        [XomPerformanceCounterAttr(
            "Message Queue Remaining (Worker)",
            "Number of slots remaining for messages queued for a worker thread",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MessageQueueRemainingWorker;

        [XomPerformanceCounterAttr(
            "SGInfo Lookups In Progress",
            "Number of SGInfo lookups currently in progress. This will tie up a worker thread until finished.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SGInfoLookupsInProgress;

        [XomPerformanceCounterAttr(
            "XomLog Calls In Progress",
            "Number of calls to Xom.Log() currently in progress. This occurs at the end of processing a message. This will tie up a worker thread until finished.",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter XomLogInProgress;

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\common\InputHttp.cs ===
// InputHttp.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Provides HTTP input for the Vortex data processor. Does not require IIS.
// 
// Author: kgoodier 10/2009
// Modified 4/2010
//

using System;
using System.Net;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Web;
using System.Linq;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.vortex.common
{

public class ValidateRequestEventArgs : EventArgs
{
    public HttpContextAdapter RequestContext;
    public bool Validated;
}

/// <summary>
/// HTTP transport for incoming messages. Accepts both query-string based GET requests and
/// content-based POST requests, such as LogString2 and LogString, respectively. 
/// </summary>
public class HttpInput : BaseInput
{
    public event EventHandler<ValidateRequestEventArgs> ValidateRequest;

    // ----------------------------------------------------------------------------------
    // HttpInput constructor
    // ----------------------------------------------------------------------------------
    public HttpInput(int port, string path, string p3p, string producerSymbol)
        : base("Http")
    {
        _Listener = new HttpListener();
        AddUrl(port, path);
        _fRunning = false;
        _p3p = p3p;
        _producerSymbol = producerSymbol;
    }

    public override void Start()
    {
        Trace.Normal("InputHttp: Start");
        _Listener.Start();
        _fRunning = true;
        BeginNextRequest();
    }

    public override void Stop()
    {
        Trace.Normal("InputHttp: Stop");
        _fRunning = false;
        _Listener.Stop();
    }


    // ----------------------------------------------------------------------------------
    // AddUrl - add base url for the HttpListener. Something like "http://*:80/vortex" is 
    // what this adds. The path param should be "/vortex" in this case.
    // ----------------------------------------------------------------------------------
    public void AddUrl(int port, string path)
    {
        if (!path.StartsWith("/"))
        {
            path = "/" + path;
        }
        string url = String.Format("http://*:{0}{1}/", port, path);
        Trace.Normal("InputHttp: Listening at {0}", url);
        _Listener.Prefixes.Add(url);
    }


    // ----------------------------------------------------------------------------------
    // ListenerCallback - incoming http request callback
    // ----------------------------------------------------------------------------------
    private void ListenerCallback(IAsyncResult result)
    {
        try
        {
            System.Threading.Interlocked.Decrement(ref _NumRequestsPending);
            MessageCounters.ForEach(inst => { 
                inst.IoOperationsPending.Decrement();
                inst.IncomingMessagesInProgress.Increment();
            });

            CallbackData        cd = (CallbackData)result.AsyncState;
            HttpListenerContext context;

            // Fire off new BeginGetContext; this MUST happen, so do it before any 
            // possibility of an exception.
            // @@@ we should handle any thrown exceptions here. It is critical that we 
            // call BeginGetContext(), or else our httplistener will die.
            BeginNextRequest();

            // Get context, may throw.
            context = _Listener.EndGetContext(result);

            // Go do the hard work. Won't throw.
            ProcessRequest(context);
        }
        catch (Exception e)
        {
            if (_fRunning)
            {
                // Must handle all exceptions, even though we can't do much
                Xom.NtEvent(XEvent.Id.VORTEX_HTTPLISTENER_CALLBACK, e,
                            "Generic error while handling the HttpListener callback.");
                Trace.Error("InputHttp: Generic error: {0}", e.Message);
            }
        }
        finally
        {
            MessageCounters.ForEach(inst => inst.IncomingMessagesInProgress.Decrement());
        }

    }

    private void ProcessRequest(HttpListenerContext context)
    {
        try
        {
            //
            // In support of SLS Routing Service protocol return 204 when supplied
            // the X-RouteTest header
            //
            if (null != context.Request.Headers["X-RouteTest"])
            {
                WriteHttpResponse(context, (int)HttpStatusCode.NoContent);
                return;
            }

            //
            // Validate the request before doing anything else
            //

            ValidateRequestEventArgs validateEventArgs = new ValidateRequestEventArgs()
            {
                RequestContext = new HttpContextAdapter(context),
                Validated = true
            };

            try
            {
                ValidateRequest(this, validateEventArgs);
            }
            catch (Exception)
            {
                validateEventArgs.Validated = false;
            }
            if (!validateEventArgs.Validated)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_HTTPLISTENER_FAILED_VALIDATION,
                            "HTTP request failed validation.\r\n" +
                            "URL: {0}\r\n" +
                            "Caller: {1}\r\n" +
                            "Content-Length: {2}\r\n" +
                            "Error returned to client: {3}",
                            context.Request.Url,
                            context.Request.RemoteEndPoint,
                            context.Request.ContentLength64,
                            "HTTP 500 InternalServerError");
                WriteHttpResponse(context, (int)HttpStatusCode.InternalServerError);
                return;
            }

            //
            // Continue processing the request
            //

            Uri url = context.Request.Url;
            int messageLength = (int)context.Request.ContentLength64;
            string apiName;

            MessageReceivedEventArgs callbackEventArgs = new MessageReceivedEventArgs()
            {
                RemoteEP = context.Request.RemoteEndPoint,
                LocalEP = context.Request.LocalEndPoint,
                AuthZHdr = context.Request.Headers[XHttpHdr.AUTHZ],
                HttpAuthDataHdr = context.Request.Headers[XHttpHdr.HTTPAUTHDATA],
            };

            // Assign the default response completion operation; an empty 200 OK
            Action completeResponse = () => { WriteHttpResponse(context, (int)HttpStatusCode.OK); };

            // url.Segments is a string array like so:
            //   [0] = "/"
            //   [1] = "vortex/"
            //   [2] = "logstring2.aspx"
            // and so on
            if (url.Segments.Length == 3)
            {
                apiName = url.Segments[2].ToLower();
            }
            else
            {
                apiName = url.LocalPath.ToLower();
            }

            // --------------------------------------------------------------------------
            // LogString2
            // --------------------------------------------------------------------------
            if (apiName == "logstring2.ashx" && 
                context.Request.HttpMethod == "GET")
            {
                NameValueCollection nvQuery = context.Request.QueryString;

                var logFields = from n in nvQuery.Cast<string>()
                    orderby n != "v1"
                    let v = nvQuery[n]
                    select n == "v1" ? v : n + "=" + v;

                string logString = String.Join("|", logFields.ToArray());

                messageLength = logString.Length;
                if (messageLength > 0)
                {
                    callbackEventArgs.Lines = new List<string>(1) 
                    {
                        logString
                    };
                    MessageCounters.OnMessageParsed(messageLength, 1);
                }
                else
                {
                    Trace.High("InputHttp: Invalid logstring2.ashx request (no querystring)");
                }
            }
            // --------------------------------------------------------------------------
            // LogString
            // --------------------------------------------------------------------------
            else if (apiName == "logstring.ashx" && 
                     context.Request.HttpMethod == "POST")
            {
                StringLogRequest request = new StringLogRequest();
                request.ReadStream(context.Request.InputStream);
                if (request.logLinesLength > 0 && !String.IsNullOrEmpty(request.logLines))
                {
                    string[] lines = request.logLines.Split('\n');
                    callbackEventArgs.Lines = new List<string>(lines);
                    MessageCounters.OnMessageParsed(messageLength, lines.Length);
                }
                else
                {
                    Trace.High("InputHttp: Invalid logstring.ashx request (no loglines)");
                }
            }
            // --------------------------------------------------------------------------
            // LogBinary
            // --------------------------------------------------------------------------
            else if (apiName == "logbinary.ashx" &&
                     context.Request.HttpMethod == "POST")
            {
                callbackEventArgs.Events = VxProtocol.ReadStream(context.Request.InputStream);
                MessageCounters.OnMessageParsed(messageLength, callbackEventArgs.Events.Count);
            }
            // --------------------------------------------------------------------------
            // LogWeb_v1
            // --------------------------------------------------------------------------
            else if (apiName == "logweb_v1.ashx" &&
                     context.Request.HttpMethod == "GET")
            {
                var data = HttpGetMessageData.CreateFromRequest(context.Request);

                data.ProducerSymbol = _producerSymbol;
                data.EventName = context.Request.QueryString["evt"];

                if (!string.IsNullOrEmpty(data.EventName) && ushort.TryParse(context.Request.QueryString["evn"], out data.ProducerSequence))
                {
                    callbackEventArgs.HttpGetData = data;
                    MessageCounters.OnMessageParsed(messageLength, 1);
                }
                else
                {
                    Trace.High("InputHttp: Invalid logweb_v1.ashx request (missing or invalid evn query-string parameter)");
                }

                completeResponse = () => { WriteClearGifResponse(_p3p, context); };
            }
            // --------------------------------------------------------------------------
            // <Unknown>
            // --------------------------------------------------------------------------
            else
            {
                Trace.High("InputHttp: Unrecognized request. Method: {0}, URL: {1}",
                           context.Request.HttpMethod, url.ToString());
                WriteHttpResponse(context, (int)HttpStatusCode.NotFound);
                return;
            }

            // Make the callback. Invalid requests have bailed out of this function 
            // already.
            DoEventsReceived(this, callbackEventArgs);

            // Complete the response
            completeResponse();
        }
        catch (Exception e)
        {
            try
            {
                Xom.NtEvent(XEvent.Id.VORTEX_HTTPLISTENER_PROCESSREQUEST, e,
                            "Unexpected runtime error while processing HTTP request.\r\n" +
                            "URL: {0}\r\n" +
                            "Caller: {1}\r\n" +
                            "Error returned to client: {2}",
                            context.Request.Url,
                            context.Request.RemoteEndPoint,
                            "HTTP 400 BadRequest");

                // @@@ meh?  only in dev environments?  remember, this is going to a client. Needs to be XRLy.
                //WriteHttpResponse(context, (int)HttpStatusCode.BadRequest, "Vortex Error", e.ToString());
                WriteHttpResponse(context, (int)HttpStatusCode.BadRequest);
            }
            catch { };
        }
    }


    // ----------------------------------------------------------------------------------
    // PRIVATE STUFF HERE
    // ----------------------------------------------------------------------------------

    private HttpListener                    _Listener;
    private bool                            _fRunning;
    private string                          _p3p;
    private string                          _producerSymbol;

    // Used for asynchronous I/O in HttpListener stuff 
    private class CallbackData
    {
        //public HttpInput httpInput;
        public HttpListener Listener;
    }

    // ----------------------------------------------------------------------------------
    // BeginNextRequest
    // ----------------------------------------------------------------------------------
    private void BeginNextRequest()
    {
        try
        {
            // Note: for more info on async calls and alternate implementations, see;
            // http://msdn.microsoft.com/en-us/library/2e08f6yc.aspx

            // Async
            CallbackData cd = new CallbackData();
            cd.Listener = _Listener;
            IAsyncResult result = _Listener.BeginGetContext(new AsyncCallback(ListenerCallback), cd);

            MessageCounters.ForEach(inst => inst.IoOperationsPending.Increment());
            System.Threading.Interlocked.Increment(ref _NumRequestsPending);
            // don't need to save result, i suppose
        }
        catch (Exception e)
        {

            if (_fRunning)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_HTTPLISTENER_NEXTREQUEST, e,
                            "Error firing off next request listener, this is fatal. Pending listeners: {0}",
                            NumRequestsPending);
            }
            throw;
        }
        
        
    }

    // ----------------------------------------------------------------------------------
    // WriteHttpResponse - makes it easier to send responses using the HttpListener
    // ----------------------------------------------------------------------------------
    private static void WriteHttpResponse(
        HttpListenerContext context, 
        int statusCode, 
        string htmlTitle, 
        string htmlBody)
    {
        string responseString = String.Format("<html><head><title>{0}</title></head><body>{1}</body></html>",
                                              htmlTitle, htmlBody);
        byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString);
        context.Response.StatusCode = statusCode;
        context.Response.ContentLength64 = buffer.Length;
        context.Response.OutputStream.Write(buffer, 0, buffer.Length);
        context.Response.OutputStream.Close();
    }
    
    private static void WriteHttpResponse(
        HttpListenerContext context, 
        int statusCode)
    {
        context.Response.StatusCode = statusCode;
        context.Response.ContentLength64 = 0;
        context.Response.OutputStream.Close();
    }

    private static readonly byte[] trackingGif = 
    { 
        0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x1,  0x0, 
        0x1,  0x0,  0x80, 0x0,  0x0,  0xff, 0xff, 0xff, 
        0x0,  0x0,  0x0,  0x2c, 0x0,  0x0,  0x0,  0x0, 
        0x1,  0x0,  0x1,  0x0,  0x0,  0x2,  0x2,  0x44, 
        0x1,  0x0,  0x3b 
    };

    private static void WriteClearGifResponse(
        string p3p,
        HttpListenerContext context)
    {
        var response = context.Response;

        response.StatusCode = (int)HttpStatusCode.OK;
        response.KeepAlive = true;
        response.ContentType = "image/gif";

        response.Headers["Pragma"] = "no-cache";
        response.Headers["Cache-Control"] = "no-cache, no-store, must-revalidate, max-age=0, proxy-revalidate, no-transform, private";

        // NEEDS INVESTIGATION
        response.Headers["P3P"] = p3p;

        response.ContentLength64 = trackingGif.Length;
        response.OutputStream.Write(trackingGif, 0, trackingGif.Length);
        response.OutputStream.Close();
    }

}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\fd\EtxManifestHelper.cs ===
// AutoValueAssistance.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Helps with filling out autovalues and retrieving SGInfo in a smart way.
// 
// Author: kgoodier 5/2010
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Text;
using System.Net;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.utilities;
using xonline.common.utilities2;
using xonline.common.core.etx;
using xonline.common.core.etx.collections;
using xonline.common.core.etx.extensions;
using xonline.server.vortex.common;

namespace xonline.server.vortex.fd
{
    internal static class PrivacyTreatmentExtensions
    {
        internal static bool Contains(this PrivacyTreatments source, PrivacyTreatments flag)
        {
            return ((long)source & (long)flag) == (long)flag;
        }
    }

    [Flags]
    internal enum AutoValueSource
    {
        None        = 0x01,
        SGInfo      = 0x02,
        AAInfo      = 0x04,
        VxEvent     = 0x08,
        EtxManifest = 0x10,
        HttpImplicit= 0x20,
    };

    internal class VxEventWithManifest
    {
        public VxEvent EventData;
        public Event   EventManifest;
        public PrivacyTreatments Treatment;

        public byte HeaderVersion;
        public VxEvent.VortexFieldCollection HeaderData;
        public DataFieldCollection HeaderManifest;  // sort of...
    }

    internal static class EtxManifestHelper
    {
        // Used for ETX events without a manifest
        public static byte UnknownEventHeaderVersion { get; set; }

        public static readonly HashSet<string> DefaultXomLogTimestampNames = 
            new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "XomLogTimestamp",
            "hdrCleanserTimestamp"
        };

        // Used for whitelisting events through ActiveAuth / IFLC
        public static HashSet<string> CategoriesAllowedThroughIFLC =
            new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            EventCategory.OfflineClickstream.ToString(),
        };


        // This list only applies to AutoValues of type AutoValueCreators.LiveService.
        // So if it isn't listed, we don't handle it.
        private static readonly Dictionary<AutoValues, AutoValueSource> 
            _AutoValueSources = new Dictionary<AutoValues, AutoValueSource>()
        {
            { AutoValues.CountryId, AutoValueSource.SGInfo },
            { AutoValues.CultureId, AutoValueSource.SGInfo },
            { AutoValues.FlowToken, AutoValueSource.SGInfo | AutoValueSource.AAInfo },
            { AutoValues.Ipv4Address, AutoValueSource.SGInfo | AutoValueSource.AAInfo },
            { AutoValues.LanguageId, AutoValueSource.SGInfo },
            { AutoValues.LogStringId, AutoValueSource.EtxManifest },
            { AutoValues.MachineId, AutoValueSource.SGInfo },
            { AutoValues.MembershipType, AutoValueSource.SGInfo },
            { AutoValues.PrimarySgNonce, AutoValueSource.SGInfo },
            { AutoValues.Timestamp, AutoValueSource.VxEvent },
            { AutoValues.TitleId, AutoValueSource.SGInfo },
        };

        // Generates the sequenced fingerprint and attempts to locate the corresponding
        // producer manifest.
        private static bool TryGetProducerBySequence(
            EtxManifest etxManifest,
            string symbol,
            ushort sequence,
            out Producer producer)
        {
            Blob fingerprint;

            fingerprint = FingerprintAlgorithm.SequentialProducer.GenerateFingerprint(symbol, sequence);

            return etxManifest.Producers.Fingerprints.TryGetValue(fingerprint, out producer);
        }

        /// <summary>
        /// Determine AutoValueSources need to satisfy the specified web
        /// event in this message.  Web events come from LogWeb_v1.
        /// 
        /// LogWeb_v1 autovalues are only allowed to come from HttpImplicit.
        /// </summary>
        /// <param name="args">Contains contextual information about the web event.</param>
        /// <returns>Returns the AutoValueSources associated with the web event.</returns>
        public static AutoValueSource ClassifyWebEvent(
            HttpGetMessageData data,
            EtxManifest manifest)
        {
            Producer producer = null;
            AutoValueSource source = AutoValueSource.None;

            if (manifest != null && data != null)
            {
                Func<DataField, bool> validField;
                ushort sequence;
                ushort rollback;
                string symbol;

                symbol = data.ProducerSymbol;
                sequence = data.ProducerSequence;
                rollback = sequence;
                validField = f
                    => (f.AutoValueCreator.HasValue == false)
                    || (f.AutoValueCreator == AutoValueCreators.LiveService
                        && (   f.AutoValue == AutoValues.LookupRequestHeader 
                            || f.AutoValue == AutoValues.LookupCookie 
                            || f.AutoValue == AutoValues.LookupQueryString 
                            || f.AutoValue == AutoValues.LookupQuerystringLeftover
                            || f.AutoValue == AutoValues.LogStringId
                            || f.AutoValue == AutoValues.Timestamp));

                TryGetProducerBySequence(manifest, symbol, sequence, out producer);

                // consider the previous sequence if original doesn't exist
                if (null == producer && sequence > 0 && TryGetProducerBySequence(manifest, symbol, --rollback, out producer))
                {
                    Trace.Low("ClassifyWebEvent: Encountered web event producer version roll-back: [{0},{1}->{2}]", symbol, sequence, rollback);
                }

                // consider the intial sequence if we still dont have a producer
                if (null == producer && sequence > 1 && TryGetProducerBySequence(manifest, symbol, rollback = 0, out producer))
                {
                    Trace.Low("ClassifyWebEvent: Encountered web event producer version roll-back: [{0},{1}->{2}]", symbol, sequence, rollback);
                }

                // attempt to locate the event when the producer is identified
                if (producer != null)
                {
                    Event evt;

                    producer.Events.Symbols.TryGetValue(data.EventName, out evt);

                    // classify the autovalues for the data fields when we have an event manifest
                    if (evt != null)
                    {
                        // enumerate fields, header fields first
                        var fields =
                            (from f in evt.HeaderFields select f).Union
                            (from f in evt.DataFields select f);

                        foreach (var field in fields)
                        {
                            // good autovalue
                            if (validField(field))
                            {
                                source = AutoValueSource.HttpImplicit;
                            }
                            // bad autovalue, cant process this message using the manifest
                            else
                            {
                                Trace.Low("ClassifyWebEvent: Encountered invalid autovalue({0}) in field ({1}): [{2},{3},{4}]",
                                    field.AutoValueCreator,
                                    field.Name,
                                    symbol,
                                    rollback,
                                    data.EventName);

                                evt = null;
                                source = AutoValueSource.None;

                                break;
                            }
                        }
                    }

                    if (null == (data.EventManifest = evt))
                    {
                        Trace.Low("ClassifyWebEvent: No event manifest available for: {0}-{1},{2}", symbol, data.EventName, rollback);
                    }
                }
                else
                {
                    Trace.Low("ClassifyWebEvent: Could not find producer manifest: {0},{1}", symbol, rollback);
                }
            }

            return source;
        }

        /// <summary>
        /// Determine various AutoValueSources needed to satisfy all events in this 
        /// message. Uses the producer id and event id from the incoming event, then 
        /// runs through all datafields in the manifest, classifying their source,
        /// if autovalues. 
        /// 
        /// Note this could be done in the manifest at import time, for an optimization.
        /// </summary>
        public static AutoValueSource ClassifyEvents(
            List<VxEvent> events, 
            EtxManifest etxManifest,
            bool classifyUnknownEvents,
            bool isMessageFromActiveAuth,
            out List<VxEventWithManifest> eventsWithManifests)

        {
            AutoValueSource avSource = AutoValueSource.None;
            eventsWithManifests = new List<VxEventWithManifest>(events.Count);
            DataFieldCollection headerFields = null;
            byte headerVersion = UnknownEventHeaderVersion;

            foreach (VxEvent veIter in events)
            {
                VxEvent eventData = veIter;
                Event etxEvent = null;

                // Do some on-the-wire pre-processing, namely for special fields and such.
                eventData = PreProcessEvent(eventData);
                if (eventData == null)
                {
                    // We're supposed to throw this away. Ok then.
                    continue;
                }

                if (etxManifest != null &&
                    etxManifest.TryGetEventByOrdinal(eventData.ProducerId, eventData.EventId, out etxEvent))
                {
                    headerVersion = etxEvent.HeaderVersion;
                    headerFields = etxEvent.HeaderFields;

                    // Enforce the category. We only allow certain categories of events 
                    // to go through the ActiveAuth / IFLC pathway, since it is mostly
                    // unsecured.
                    if (isMessageFromActiveAuth &&
                        !CategoriesAllowedThroughIFLC.Contains(etxEvent.Category.ToString()))
                    {
                        // @@@ better eventing, maybe write this to the "bad log bucket" file? perf counter?
                        Trace.High("ClassifyEvents: Message {0} ({1}) with Category \"{2}\" not allowed through IFLC",
                            eventData.LogStringId, etxEvent.Symbol, etxEvent.Category);
                        
                        // Don't classify this event. 
                        // Don't include it in the output.
                        // Throw it out.
                        // Bad caller!
                        continue;
                    }

                    // Go through header fields
                    foreach (DataField etxHdrField in etxEvent.HeaderFields)
                    {
                        ClassifyField(etxHdrField, ref avSource);
                    }

                    // Go through data fields
                    foreach (DataField etxField in etxEvent.DataFields)
                    {
                        ClassifyField(etxField, ref avSource);
                    }
                }
                else
                {
                    Trace.Low("ClassifyEvents: No manifest for ProducerId {0}, EventId {1}", eventData.ProducerId, eventData.EventId);
                    if (classifyUnknownEvents)
                    {
                        // Note: this may throw an ArgumentException if the version is not 
                        // found. If it truly isn't found, this will be a round-trip to 
                        // SQL each time. Perhaps we should throttle this some way.
                        try
                        {
                            Event etxHdrEvent = EtxLoader.NPDB.GetHeaderDefinition(headerVersion);

                            headerFields = etxHdrEvent.DataFields;

                            // Go through header fields
                            foreach (DataField etxHdrField in etxHdrEvent.DataFields)
                            {
                                ClassifyField(etxHdrField, ref avSource);
                            }
                        }
                        catch (ArgumentException e)
                        {
                            // @@@ event and throttle calls?
                            Trace.Low("ClassifyEvents: No header ver {0} event manifest found in cache ({1})", headerVersion, e.Message);
                            headerVersion = 0;
                        }
                    }
                }

                // Don't blow up enumerators
                if (headerFields == null)
                {
                    headerFields = new DataFieldCollection();
                }

                // Augment the VxEvent with the manifest, privacy treatment, and store it for the return
                if (null == etxEvent || etxEvent.PrivacyTreatments == PrivacyTreatments.PassThrough)
                {
                    VxEventWithManifest ve2 = new VxEventWithManifest()
                    {
                        EventData = eventData,
                        EventManifest = etxEvent,
                        HeaderVersion = headerVersion,
                        HeaderData = new VxEvent.VortexFieldCollection(),
                        HeaderManifest = headerFields,
                        Treatment = PrivacyTreatments.PassThrough
                    };

                    eventsWithManifests.Add(ve2);
                }
                else
                {
                    bool requireClone = false;

                    // Check for LBI and MBI
                    if (null != etxEvent && etxEvent.PrivacyTreatments.Contains(PrivacyTreatments.LBI))
                    {
                        VxEventWithManifest ve2 = new VxEventWithManifest()
                        {
                            EventData = requireClone ? eventData.Clone() : eventData,
                            EventManifest = etxEvent,
                            HeaderVersion = headerVersion,
                            HeaderData = new VxEvent.VortexFieldCollection(),
                            HeaderManifest = headerFields,
                            Treatment = PrivacyTreatments.LBI
                        };

                        eventsWithManifests.Add(ve2);

                        requireClone = true;
                    }
                    
                    if (null != etxEvent && etxEvent.PrivacyTreatments.Contains(PrivacyTreatments.MBI))
                    {
                        VxEventWithManifest ve2 = new VxEventWithManifest()
                        {
                            EventData = requireClone ? eventData.Clone() : eventData,
                            EventManifest = etxEvent,
                            HeaderVersion = headerVersion,
                            HeaderData = new VxEvent.VortexFieldCollection(),
                            HeaderManifest = headerFields,
                            Treatment = PrivacyTreatments.MBI
                        };

                        eventsWithManifests.Add(ve2);

                        requireClone = true;
                    }
                }
            }

            if (avSource != AutoValueSource.None)
            {
                // Remove the original None entry
                avSource &= ~AutoValueSource.None;
            }

            return avSource;
        }

        private static void ClassifyField(DataField etxField, ref AutoValueSource avSource)
        {
            if (etxField.AutoValue == null ||
                etxField.Deprecated == true ||
                etxField.AutoValueCreator != AutoValueCreators.LiveService)
            {
                // We don't care about this field
                return;
            }
            AutoValueSource source;
            if (_AutoValueSources.TryGetValue((AutoValues)etxField.AutoValue, out source))
            {
                avSource |= source;
            }
        }

        // ------------------------------------------------------------------------------
        // PreProcessEvent - Used to "pre-process" the event before any additional work is 
        // done. If null is returned, then the event will be thrown away. Otherwise, the 
        // new event, modified or not, should be returned. 
        //
        // Notice this currently doesn't return null in any case, but maybe it could in 
        // the future.
        // ------------------------------------------------------------------------------
        private static VxEvent PreProcessEvent(VxEvent eventData)
        {
            uint[] specialFieldOrdinals = eventData.EventFields.SpecialFieldOrdinals;
            if (specialFieldOrdinals.Length > 0)
            {
                foreach (uint ordinal in specialFieldOrdinals)
                {
                    SpecialField sf = eventData.EventFields.GetSpecialField(ordinal);

                    if (sf.Id == (uint)VxProtocol.VxSpecialFieldTypeId.VortexDeletedField)
                    {
                        // This special field type indicates the field was once used for 
                        // other destinations, such as StringSvr, but is not needed for 
                        // the Vortex code path. Vortex should remove this field from the 
                        // wire and shift all other ordinals down to fill the gap.

                        // This is a somewhat expensive operation, and it would be ideal 
                        // to detect *all* fields that need to be removed and just do them 
                        // once. However, this is not an expected code path, and we know 
                        // of only one case (with 1 event) where we will go down it, so 
                        // let's take the lazy way out for now.
                        eventData.EventFields.RemoveField(ordinal, true);

                        // We've now shifted all ordinals. Can't continue iterating. Have 
                        // to look for more fields *just in case*. Restart!
                        return PreProcessEvent(eventData);
                    }
                }
            }

            // No changes
            return eventData;
        }

        /// <summary>
        /// Retrieves and applies autovalues to header and data fields.
        /// </summary>
        public static void ApplyManifest(
            VxEventWithManifest vxEventWithManifest,
            SGInfo sginfo, 
            AAInfo aainfo)
        {
            VxEvent eventData = vxEventWithManifest.EventData;
            Event eventManifest = vxEventWithManifest.EventManifest;
            DataFieldCollection headerManifest = vxEventWithManifest.HeaderManifest;

            if (eventManifest != null)
            {
                // Apply the "fixed" autovalues 
                // Use LogStringId if provided, else use the event Symbol
                eventData.LogStringId = !String.IsNullOrEmpty(eventManifest.LogStringId) ? eventManifest.LogStringId : eventManifest.Symbol;
            }

            //
            // Run through the autovalues now.
            //

            // First header fields
            uint maxHdrOrdinal = (uint)headerManifest.Count;
            foreach (DataField etxHdrField in headerManifest)
            {
                maxHdrOrdinal = Math.Max(maxHdrOrdinal, etxHdrField.Ordinal);
                object val;
                if (ApplyAutoValueToField(etxHdrField, sginfo, aainfo, eventData, out val))
                {
                    // Apply privacy treatment
                    val = EtxPrivacy.ApplyTreatment(vxEventWithManifest.Treatment, etxHdrField, val);

                    // These get stored in our own collection of header fields, since 
                    // these will never appear on the wire in binary format (at least,
                    // not yet).
                    vxEventWithManifest.HeaderData.AddField(etxHdrField.Ordinal, val);
                }
            }
            vxEventWithManifest.HeaderData.MaxFieldOrdinal = maxHdrOrdinal;

            if (eventManifest == null)
            {
                // No manifest, nothing more to do
                VortexCounters.Current.EventsWithoutManifestRate.Increment();
                VortexCounters.Current.EventsWithoutManifestTotal.Increment();
                return;
            }

            // Then data fields
            uint maxEventOrdinal = eventData.EventFields.MaxFieldOrdinal;
            foreach (DataField etxField in eventManifest.DataFields)
            {
                maxEventOrdinal = Math.Max(maxEventOrdinal, etxField.Ordinal);
                object val;
                if (ApplyAutoValueToField(etxField, sginfo, aainfo, eventData, out val))
                {
                    // Apply privacy treatment
                    val = EtxPrivacy.ApplyTreatment(vxEventWithManifest.Treatment, etxField, val);

                    // We have our autovalue in "val" now. Stick it back into the event.  
                    // Note "AddField" will either add a new one or replace an existing
                    // one. The type of "val" needs to be a supported type, so that 
                    // VxEvent can recognize it and convert it to a wiretype (or string).

                    eventData.EventFields.AddField(etxField.Ordinal, val);
                }
                else
                {
                    // For datafields coming in on the wire, we need to change their
                    // "wiretype" to be the manifest's "inType". This may seem
                    // unnecessary, but it simplifies the outType logic later on.
                    // We only do this for fields that are not LiveService autovalues,
                    // or ones that possibly caused an exception while applying the
                    // autovalue.

                    object wireVal;
                    if (eventData.EventFields.TryGetField(etxField.Ordinal, out wireVal))
                    {
                        if (!ConvertWireTypeToInType(wireVal, etxField.InType, out val))
                        {
                            // Assign val to wireVal in preparation for privacy treatment
                            val = wireVal;
                        }

                        // Apply privacy treatment
                        val = EtxPrivacy.ApplyTreatment(vxEventWithManifest.Treatment, etxField, val);

                        eventData.EventFields.AddField(etxField.Ordinal, val);
                    }
                }
            }

            // If the manifest specifies more fields than we got on the wire, "fake" 
            // this to the VxEvent for when we do a ToString(). This will ensure the
            // proper number of "|" fields, particularly in the case we have 
            // deprecated fields at the end of the event.
            eventData.EventFields.MaxFieldOrdinal = maxEventOrdinal;
        }

        public static bool ApplyAutoValueToField(
            DataField etxField,
            SGInfo sginfo,      // autovalue source, may be null
            AAInfo aainfo,      // autovalue source, may be null
            VxEvent eventData,  // autovalue source, may be null
            out object av)
        {
            av = null;

            if (etxField.AutoValue == null ||
                etxField.Deprecated == true ||
                etxField.AutoValueCreator != AutoValueCreators.LiveService)
            {
                // We don't care about this field
                return false;
            }

            DataFieldType inType = etxField.InType;
            // Only 1 string type we deal with
            if (inType == DataFieldType.UnicodeString)
            {
                inType = DataFieldType.AnsiString;
            }

            try
            {
                #region Big switch statement of autovalues
                // {{{
                switch (etxField.AutoValue)
                {
                    case AutoValues.CountryId:  // first logged on user
                        if (sginfo != null)
                        {
                            byte countryId = 0;
                            int userIndex = sginfo.PrimaryUserIndex;
                            if (userIndex > -1)
                            {
                                countryId = sginfo.LogonUsers[userIndex].UserCountry();
                            }

                            // We don't have the console country available to us. Too bad.

                            switch (inType)
                            {
                                case DataFieldType.AnsiString:
                                    if (countryId != 0)
                                        av = CountryDictionary.CountryCode(countryId);
                                    else
                                        av = countryId.ToString();
                                    break;
                                case DataFieldType.UInt8:
                                    av = (byte)countryId;
                                    break;
                                default:
                                    InvalidType(etxField, countryId);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.CultureId:
                        if (sginfo != null)
                        {
                            string locale = sginfo.GetPrimaryUserLocale();
                            switch (inType)
                            {
                                case DataFieldType.AnsiString:
                                    av = locale;
                                    break;
                                default:
                                    InvalidType(etxField, locale);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.FlowToken:
                        {
                            Floken flowToken;
                            if (sginfo != null)
                                flowToken = sginfo.FlowToken;
                            else if (aainfo != null)
                                flowToken = aainfo.FlowToken;
                            else
                                break;

                            switch (inType)
                            {
                                case DataFieldType.AnsiString:
                                    av = flowToken.ToString();
                                    break;
                                case DataFieldType.UInt64:
                                    av = flowToken.FlowToken;
                                    break;
                                default:
                                    InvalidType(etxField, flowToken);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.Ipv4Address:
                        {
                            IPAddress ip = null;
                            if (sginfo != null)
                                ip = (IPAddress)sginfo.ClientIP;
                            else if (aainfo != null)
                                ip = (IPAddress)IPAddress.Parse(aainfo.IpAddressInternet);
                            else
                                break;

                            switch (inType)
                            {
                                case DataFieldType.AnsiString:
                                    av = ip.ToString();
                                    break;
                                case DataFieldType.UInt32:
                                    // uint IP addresses are in little-endian order, but 
                                    // IPAddress gives them in big-endian. See XCS bug 
                                    // #173340.
                                    av = (uint)IPAddress.NetworkToHostOrder(
                                        (int)(uint)BitConverter.ToUInt32(ip.GetAddressBytes(), 0));
                                    break;
                                default:
                                    InvalidType(etxField, ip);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.LanguageId:
                        if (sginfo != null)
                        {
                            uint languageId;
                            int userIndex = sginfo.PrimaryUserIndex;
                            if (userIndex > -1)
                            {
                                languageId = sginfo.LogonUsers[userIndex].UserLanguage();
                            }
                            else
                            {
                                languageId = sginfo.LanguageID;
                            }

                            switch (inType)
                            {
                                case DataFieldType.AnsiString:
                                    if (languageId != 0)
                                        av = Locale.NeutralCultureFromLanguage(languageId);
                                    else
                                        av = languageId.ToString();
                                    break;
                                case DataFieldType.UInt8:
                                    av = (byte)languageId;
                                    break;
                                default:
                                    InvalidType(etxField, languageId);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.LogStringId:
                        if (eventData != null)
                        {
                            string lsid = eventData.LogStringId;
                            switch (inType)
                            {
                                case DataFieldType.AnsiString:
                                    av = lsid;
                                    break;
                                default:
                                    InvalidType(etxField, lsid);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.MachineId:
                        if (sginfo != null)
                        {
                            ulong mid = sginfo.MachineId;
                            switch (inType)
                            {
                                case DataFieldType.UInt64:
                                    av = mid;
                                    break;
                                default:
                                    InvalidType(etxField, mid);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.MembershipType:
                        if (sginfo != null)
                        {
                            byte userTier = 0;
                            int userIndex = sginfo.PrimaryUserIndex;
                            if (userIndex > -1)
                            {
                                userTier = sginfo.LogonUsers[userIndex].UserTier();
                            }
                            else
                            {
                                break;
                            }

                            switch (inType)
                            {
                                case DataFieldType.AnsiString:
                                    av = XOn.UserTierToString(userTier);
                                    break;
                                case DataFieldType.UInt8:
                                    av = (byte)userTier;
                                    break;
                                default:
                                    InvalidType(etxField, userTier);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.PrimarySgNonce:
                        if (sginfo != null)
                        {
                            ulong nonce = sginfo.Nonce;
                            switch (inType)
                            {
                                case DataFieldType.UInt64:
                                    av = nonce;
                                    break;
                                default:
                                    InvalidType(etxField, nonce);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.Timestamp:
                        if (eventData != null)
                        {
                            DateTime t = eventData.Timestamp;
                            switch (inType)
                            {
                                case DataFieldType.AnsiString:
                                    av = XDateTime.ToString(t);
                                    break;
                                case DataFieldType.UInt64:
                                    av = (ulong)t.ToFileTimeUtc();
                                    break;
                                case DataFieldType.Int64:
                                    av = (long)t.ToFileTimeUtc();
                                    break;
                                default:
                                    InvalidType(etxField, t);
                                    break;
                            }
                        }
                        break;

                    case AutoValues.TitleId:
                        if (sginfo != null)
                        {
                            uint tid = sginfo.TitleId;
                            switch (inType)
                            {
                                case DataFieldType.UInt32:
                                    av = tid;
                                    break;
                                default:
                                    InvalidType(etxField, tid);
                                    break;
                            }
                        }
                        break;

                    default:
                        Trace.Error("Unknown LiveService autovalue \"{0}\" for event \"{1}\"",
                            etxField.AutoValue,
                            eventData != null ? eventData.LogStringId : "<none>");
                        break;
                }
                // }}}
                #endregion

                // Yay, all done, everything looks good
                return true;
            }
            catch (ArgumentException e)
            {
                // @@@ event here? perf counter?
                Trace.Error("ApplyAutoValueToField: type error: {0}", e.ToString());
            }
            catch (Exception e)
            {
                Trace.Error("ApplyAutoValueToField: error: {0}", e.ToString());
            }
            return false;
        }

        public static bool ConvertWireTypeToInType(
            object wireVal,
            DataFieldType inType,
            out object newWireVal)
        {
            // Valid wire types are:
            // * ulong
            // * long
            // * byte[]
            // * float
            // * double
            // * string
            // * SpecialField
            //
            // Except for ulong and long and GUID, these all have a 1:1 mapping with 
            // their inType. So we only need to fix those up, basically downgrade 
            // them.

            newWireVal = null;
            Type wireType = wireVal.GetType();
            if (wireType == typeof(ulong))
            {
                switch (inType)
                {
                    case DataFieldType.UInt8:
                        newWireVal = (byte)(ulong)wireVal;
                        break;
                    case DataFieldType.UInt16:
                        newWireVal = (ushort)(ulong)wireVal;
                        break;
                    case DataFieldType.UInt32:
                        newWireVal = (uint)(ulong)wireVal;
                        break;
                    // @@@ need to include the signed DataFieldTypes? invalid?
                }
            }
            else if (wireType == typeof(long))
            {
                switch (inType)
                {
                    case DataFieldType.Int8:
                        newWireVal = (sbyte)(long)wireVal;
                        break;
                    case DataFieldType.Int16:
                        newWireVal = (short)(long)wireVal;
                        break;
                    case DataFieldType.Int32:
                        newWireVal = (int)(long)wireVal;
                        break;
                    // @@@ need to include the unsigned DataFieldTypes? invalid?
                }
            }
            else if (wireType == typeof(byte[]))
            {
                switch (inType)
                {
                    case DataFieldType.GUID:
                        // Have to follow a big-endian GUID format per XCS bug 171180.  
                        newWireVal = new Guid(ByteOrder.RevertGuidBytesInline((byte[])wireVal));
                        break;
                }
            }

            return (newWireVal != null);
        }

        /// <summary>
        /// Convert a generic field value into its appropriate output type, and write
        /// it to a StringBuilder. Returns true if field was written, or false if not.
        /// This function follows this pattern as an optimization to reduce the number
        /// of strings allocated.
        /// </summary>
        public static bool WriteFieldOutputValue(
            object fieldValue,
            OutputType etxOutType,
            StringBuilder sbOutput)
        {
            Type fieldType = fieldValue.GetType();

            // {{{
#region Big switch statement of OutTypes
            switch (etxOutType)
            {
            case OutputType.String:
                {
                    if (fieldType == typeof(string))
                        sbOutput.Append((string)fieldValue);
                    else if (fieldType == typeof(byte[]))
                        sbOutput.Append(((Blob)(byte[])fieldValue).ToString());
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;

            case OutputType.Number:
            case OutputType.HexNumber:
            case OutputType.SgNonce:
                {
                    string fmt;

                    if (etxOutType == OutputType.Number)
                    {
                        fmt = "D";
                    }
                    else
                    {
                        // Not padded, no "0x" prefix
                        fmt = "X";
                    }

                    if (fieldType == typeof(byte))
                        sbOutput.Append(((byte)fieldValue).ToString(fmt));
                    else if (fieldType == typeof(ushort))
                        sbOutput.Append(((ushort)fieldValue).ToString(fmt));
                    else if (fieldType == typeof(uint))
                        sbOutput.Append(((uint)fieldValue).ToString(fmt));
                    else if (fieldType == typeof(ulong))
                        sbOutput.Append(((ulong)fieldValue).ToString(fmt));
                    else if (fieldType == typeof(sbyte))
                        sbOutput.Append(((sbyte)fieldValue).ToString(fmt));
                    else if (fieldType == typeof(short))
                        sbOutput.Append(((short)fieldValue).ToString(fmt));
                    else if (fieldType == typeof(int))
                        sbOutput.Append(((int)fieldValue).ToString(fmt));
                    else if (fieldType == typeof(long))
                        sbOutput.Append(((long)fieldValue).ToString(fmt));
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;
            
            case OutputType.Float:
                {
                    const string fmt = "R";
                    if (fieldValue is float)
                        sbOutput.Append(((float)fieldValue).ToString(fmt));
                    else if (fieldValue is double)
                        sbOutput.Append(((double)fieldValue).ToString(fmt));
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;

            case OutputType.DateTime:
                {
                    if (fieldType == typeof(ulong))
                        sbOutput.Append(XDateTime.ToString(DateTime.FromFileTimeUtc((long)(ulong)fieldValue)));
                    else if (fieldType == typeof(long))
                        sbOutput.Append(XDateTime.ToString(DateTime.FromFileTimeUtc((long)fieldValue)));
                    else if (fieldType == typeof(DateTime))
                        sbOutput.Append(XDateTime.ToString((DateTime)fieldValue));
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;

            case OutputType.Ipv4Address:
                {
                    if (fieldType == typeof(uint))
                    {
                        // uint IP addresses are in little-endian order, but IPAddress 
                        // wants them in big-endian. See XCS bug #173340.
                        uint dwIp = (uint)IPAddress.HostToNetworkOrder((int)(uint)fieldValue);
                        sbOutput.Append((new IPAddress((long)dwIp)).ToString());
                    }
                    else if (fieldType == typeof(IPAddress))
                        sbOutput.Append(((IPAddress)fieldValue).ToString());
                    else if (fieldType == typeof(byte[]) && ((byte[])fieldValue).Length == 4)
                        sbOutput.Append((new IPAddress((byte[])fieldValue)).ToString());
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;
            
            case OutputType.LBIOnlyGUID:
            case OutputType.GUID:
                {
                    // If your inType is Binary and outType is GUID, you're committing to 
                    // a little-endian wire format for the GUID. This is different than 
                    // having an inType of GUID.
                    if (fieldType == typeof(byte[]))
                        sbOutput.Append((new Guid((byte[])fieldValue)).ToString("D"));
                    else if (fieldType == typeof(Guid))
                        sbOutput.Append(((Guid)fieldValue).ToString("D"));
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;

            case OutputType.FlowToken:
                {
                    if (fieldType == typeof(ulong))
                        sbOutput.Append((new Floken((ulong)fieldValue)).ToString());
                    else if (fieldType == typeof(Floken))
                        sbOutput.Append(((Floken)fieldValue).ToString());
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;

            case OutputType.HResult:
                {
                    // We actually want to convert this to a string, either the
                    // original constant or a message. So far, we're only doing
                    // xonline's HResult class. Would be nice to incorporate
                    // some Windows HRESULT messages. Marshal.GetExceptionForHR
                    // is promising, but slow and returns the message, not the
                    // constant. @@@ TODO later
                    if (fieldType == typeof(uint) ||
                        fieldType == typeof(int))
                    {
                        HResult hr = fieldType == typeof(uint) ? (HResult)(uint)fieldValue : (HResult)(uint)(int)fieldValue;
                        sbOutput.Append(hr.ToString());
                        sbOutput.Append(':');
                        if (hr.HasName)
                        {
                            sbOutput.Append(hr.Name);
                        }
                    }
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;

            case OutputType.XexVersion:
                {
                    // Convert to "Major.Minor.Build.QFE" format
                    // DWORD bits:  MMMMmmmm BBBBBBBB BBBBBBBB QQQQQQQQ
                    if (fieldType == typeof(uint))
                    {
                        uint ver = (uint)fieldValue;

                        // Unrolling like this is 30% faster than AppendFormat.
                        sbOutput.Append((ver >> 28) & 0xF);
                        sbOutput.Append('.');
                        sbOutput.Append((ver >> 24) & 0xF);
                        sbOutput.Append('.');
                        sbOutput.Append((ver >>  8) & 0xFFFF);
                        sbOutput.Append('.');
                        sbOutput.Append((ver      ) & 0xFF);
                    }
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;

            case OutputType.TitleName:
                {
                    // Convert to a friendly human-readable title name. StringSvr's
                    // GetString api seems to be a good reference. We could build up
                    // a dictionary from p_stringsvr_strings_get where i_string_id
                    // equals 0 and vc_locale equals "en-US" (I *think* this is the
                    // title name). @@@ TODO later
                    if (fieldType == typeof(uint))
                    {
                        TitleId titleId = (TitleId)(uint)fieldValue;
                        sbOutput.Append(titleId.ToString());
                        sbOutput.Append(':');
                        //sbOutput.Append(titleName);
                    }
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;
            
            case OutputType.ConsoleId:
                {
                    // Convert to 12-digit decimal format where the last digit is the 
                    // checksum. This is how it is presented in the dashboard to the end 
                    // user and how it is stored in our database in the "XE.nnnnnnnnnnnn" 
                    // format.
                    // Conversion borrowed from \private\tools\consoleid\consoleid.cs
                    if (fieldType == typeof(byte[]))
                    {
                        byte[] cidb = (byte[])fieldValue;
                        if (cidb.Length != 5)
                            return InvalidType(etxOutType, fieldValue);
                        // Comes in from the console (which just pulls the 5 bytes from 
                        // the console certificate) as big-endian, at least with respect 
                        // to how we do our conversions here.
                        ulong cid = 
                            ((ulong)cidb[4]) + 
                            ((ulong)cidb[3] << 8) + 
                            ((ulong)cidb[2] << 16) + 
                            ((ulong)cidb[1] << 24) + 
                            ((ulong)cidb[0] << 32);
                        ulong lastFour = cid & 0xF;
                        ulong rest = cid >> 4;
                        string dash = rest.ToString("d") + lastFour.ToString("d");
                        sbOutput.Append(dash.PadLeft(12, '0'));
                    }
                    else if (fieldType == typeof(ulong))
                    {
                        ulong cid = ((ulong)fieldValue) & 0xFFFFFFFFFF;
                        ulong lastFour = cid & 0xF;
                        ulong rest = cid >> 4;
                        string dash = rest.ToString("d") + lastFour.ToString("d");
                        sbOutput.Append(dash.PadLeft(12, '0'));
                    }
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;

            case OutputType.Xuid:
                {
                    const string fmt = "X";

                    if (fieldType == typeof(ulong))
                        sbOutput.Append(((ulong)fieldValue).ToString(fmt));
                    else if (fieldType == typeof(long))
                        sbOutput.Append(((long)fieldValue).ToString(fmt));
                    else if (fieldType == typeof(byte[]))
                        sbOutput.Append(((Blob)(byte[])fieldValue).ToString());
                    else
                        return InvalidType(etxOutType, fieldValue);
                }
                break;

            default:
                {
                    // Handle future OutputTypes, I suppose
                    sbOutput.Append(fieldValue.ToString());
                }
                break;
            }
#endregion  
            // }}}

            return true;
        }

        public static string ToLogString(
            VxEventWithManifest vxEventWithManifest,
            out int firstOrdinalIndex)
        {
            VxEvent eventData = vxEventWithManifest.EventData;
            Event eventManifest = vxEventWithManifest.EventManifest;
            VxEvent.VortexFieldCollection headerData = vxEventWithManifest.HeaderData;
            DataFieldCollection headerManifest = vxEventWithManifest.HeaderManifest;

            uint ordinal = 1;
            StringBuilder sb = new StringBuilder(500);
            string sep = "";

            // Add service headers first.
            for (ordinal = 1; ordinal <= headerData.MaxFieldOrdinal; ordinal++)
            {
                // Append the separator
                sb.Append(sep);
                sep = "|";

                DataField etxField = null;
                object existingValue = null;
                try
                {
                    if (!headerManifest.TryGetValue(DataFieldCollectionKeys.Ordinal, ordinal, out etxField) ||
                        etxField == null)
                    {
                        // Urm.. not really expected.
                        continue;
                    }

                    // Special case the XomLogging timestamp. The first field is 
                    // automatically
                    // the timestamp, as provided by XomFileTarget on the Cleansers. We need
                    // to ignore that autovalue completely.
                    if (etxField.Ordinal == 1 &&
                        DefaultXomLogTimestampNames.Contains(etxField.Name))
                    {
                        sep = "";
                        continue;
                    }

                    if (!headerData.TryGetField(etxField.Ordinal, out existingValue) ||
                        existingValue == null)
                    {
                        // No value
                        continue;
                    }

                    WriteFieldOutputValue(existingValue, etxField.OutType, sb);
                }
                catch (Exception e)
                {
                    Trace.Error("ApplyManifest: header ver {0} field {1} in event {2} value {3} exception: {4}",
                                vxEventWithManifest.HeaderVersion,
                                etxField != null ? etxField.Ordinal.ToString() : "<unknown>",
                                eventData.LogStringId,
                                existingValue != null ? existingValue.ToString() : "<unknown>",
                                e.ToString());
                }
            }

            // No manifest, do the best we can with the wire data and bail.
            if (eventManifest == null)
            {
                sb.Append(sep);
                firstOrdinalIndex = sb.Length;
                string ordinalFields = eventData.EventFields.ToString();
                sb.Append(ordinalFields);
                return sb.ToString();
            }

            // This is actually the max ordinal of the both the VxEvent (wire) and Event 
            // (manifest). Yay. Also, we have agreed to cap at 256 fields max.
            uint maxEventOrdinal = Math.Min(eventData.EventFields.MaxFieldOrdinal, VxEvent.c_MaxFieldOrdinal);
            firstOrdinalIndex = sb.Length + sep.Length;
            for (ordinal = 1; ordinal <= maxEventOrdinal; ordinal++)
            {
                // Append the separator
                sb.Append(sep);
                sep = "|";

                DataField etxField = null;
                object existingValue = null;
                try
                {
                    if (!eventManifest.DataFields.TryGetValue(DataFieldCollectionKeys.Ordinal, ordinal, out etxField) ||
                        etxField == null)
                    {
                        // Urm.. not really expected.
                        continue;
                    }

                    if (!eventData.EventFields.TryGetField(etxField.Ordinal, out existingValue) ||
                        existingValue == null)
                    {
                        // No value
                        continue;
                    }

                    // We're going to make some assumptions here:
                    // 1. existingValue is either a basic inType or the even more limited
                    //    on-the-wire type.
                    // 2. existingValue's inType can easily be converted to the desired 
                    //    outputType. If not true, the manifest compiler or ingestion would
                    //    have thrown an error.

                    WriteFieldOutputValue(existingValue, etxField.OutType, sb);
                }
                catch (Exception e)
                {
                    Trace.Error("ApplyManifest: field {0} in event {1} value {2} exception: {3}",
                                etxField != null ? etxField.Ordinal.ToString() : "<unknown>",
                                eventData.LogStringId, 
                                existingValue != null ? existingValue.ToString() : "<unknown>",
                                e.ToString());
                }
            }

            return sb.ToString();
        }
        
        public static XomLogTargetContext CreateReportingContext(
            VxEventWithManifest vxEventWithManifest)
        {
            if (vxEventWithManifest.EventManifest != null)
            {
                string logString;

                switch(vxEventWithManifest.Treatment)
                {
                    case PrivacyTreatments.LBI:
                        logString = "LBI-";
                        break;
                    case PrivacyTreatments.MBI:
                        logString = "MBI-";
                        break;
                    default:
                        logString = "";
                        break;
                }

                logString += vxEventWithManifest.EventData.LogStringId;

                return new XomLogTargetContext()
                {
                    FlowToken = Floken.None,
                    LogStringId = logString,
                    EventData = new XomLogTargetContext.EtxEvent()
                    {
                        Fingerprint = vxEventWithManifest.EventManifest.Fingerprint,
                        HeaderVersion = vxEventWithManifest.EventManifest.HeaderVersion,
                        WebRepGroupId = 0
                    }
                };
            }

            return new XomLogTargetContext(Floken.None)
            {
                LogStringId = vxEventWithManifest.EventData.LogStringId
            };
        }

        private static bool InvalidType(OutputType etxOutType, object val)
        {
            throw new ArgumentException(String.Format(
                "Invalid input value \"{0}\": type \"{1}\" not allowed for OutputType {2}",
                val, val.GetType(), etxOutType));
            //return false;
        }

        private static bool InvalidType(DataField etxField, object val)
        {
            throw new ArgumentException(String.Format(
                "Invalid input value \"{0}\": type \"{1}\" not allowed for field {2}",
                val, val.GetType(), etxField));
            //return false;
        }

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\fd\RequestContext.cs ===
// RequestContext.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// RequestContext allows for a flexible execution engine that can carry along metadata.  
// It's similar to CPacket and all the functions in sgrecv.cpp in the SG. You can push 
// callback functions onto the context, and pop them off with ease. The processing 
// functions all take in a RequestContext object. 
//
// The rule for the processing functions is simple. Do work. At the end, either call 
// another request processing function, or call Complete() on the RequestContext if there 
// is no additional work in the request processor's chain. In addition, if you release 
// control of the context, say by handing it off to a worker thread, do not call 
// Complete().
// 
// Author: kgoodier 5/2010
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.core.etx;
using xonline.common.core.etx.extensions;
using xonline.server.vortex.common;

namespace xonline.server.vortex.fd
{
    internal delegate void RequestProcessor(RequestContext reqCtx);

    internal struct SchemaLine
    {
        public SchemaLine(string line, Event @event, string key, string logStringId) : this()
        {
            Line = line;
            Event = @event;
            Key = key;
            LogStringId = logStringId;
        }

        public string Line;
        public Event Event;
        public string Key;
        public string LogStringId;
    }

    internal class RequestContext 
    {
        // ------------------------------------------------------------------------------
        // Public members for carrying state.
        // ------------------------------------------------------------------------------
        public MessageReceivedEventArgs MessageArgs;
        public AutoValueSource MessageAutoValueSource;
        public SGInfo SGInfoInstance;
        public AAInfo AAInfoInstance;
        public List<VxEventWithManifest> VortexEvents;
        public bool IsRunningOnWorkerThread;

        private Stack<RequestProcessor> Processors;
        private long CtxNum;

        private IThreadPool _ThreadPool;

        private static long s_SequenceNum = 0;
        private static XomLogArea s_FlowTraceArea = null;

        public static RequestContext Create(MessageReceivedEventArgs args)
        {
            return Create(args, DotNetThreadPool.Default);
        }

        public static RequestContext Create(MessageReceivedEventArgs args, IThreadPool threadPool)
        {
            // Note: could use a free list here if garbage collection is out of hand.
            RequestContext reqCtx = new RequestContext(args, FreeContext, threadPool);
            VortexCounters.Current.MessagesInProgress.Increment();
            return reqCtx;
        }

        private static void FreeContext(RequestContext reqCtx)
        {
            // This is the last function ever called by a RequestContext. We know this
            // because it is the first function pushed onto the completion stack.
            // Note: potential for free list here
            reqCtx.FlowTrace("FreeContext");

            // In "ticks", as provided by QueryPerformanceCounter
            long latency = (long)(reqCtx.MessageArgs.LifetimeTicks * 1000);

            VortexCounters.Current.MessagesInProgress.Decrement();
            VortexCounters.Current.AverageMessageLatency.IncrementBy(latency);
            VortexCounters.Current.AverageMessageLatencyBase.Increment();
        }

        private RequestContext(MessageReceivedEventArgs args, IThreadPool threadPool)
            : this(args, null, threadPool)
        {
        }

        private RequestContext(MessageReceivedEventArgs args, RequestProcessor nextProcessor, IThreadPool threadPool)
        {
            if (s_FlowTraceArea == null)
            {
                // Optimization
                s_FlowTraceArea = Xom.GetAreaByName(XomAreaName.VortexFlow);
            }

            MessageArgs = args;
            MessageAutoValueSource = AutoValueSource.None;
            SGInfoInstance = null;
            AAInfoInstance = null;
            VortexEvents = null;
            IsRunningOnWorkerThread = false;

            Processors = new Stack<RequestProcessor>();
            CtxNum = Interlocked.Increment(ref s_SequenceNum);
            _ThreadPool = threadPool;

            CompletePush(nextProcessor); 
        }

        // Some accessor helpers

        public bool EventsAvailable
        {
            get { return MessageArgs.Events != null && MessageArgs.Events.Count > 0; }
        }

        public bool WebEventAvailable
        {
            get { return MessageArgs.HttpGetData != null; }
        }

        public List<string> Lines
        {
            get { return MessageArgs.Lines; }
            set { MessageArgs.Lines = value; }
        }

        public List<SchemaLine> SchemaLines
        {
            get;
            set;
        }

        public bool LinesAvailable
        {
            get { return MessageArgs.Lines != null && MessageArgs.Lines.Count > 0; }
        }

        public bool SchemaLinesAvailable
        {
            get { return SchemaLines != null && SchemaLines.Count > 0; }
        }

        public bool IsMessageFromActiveAuth
        {
            get
            {
                if (String.IsNullOrEmpty(MessageArgs.AuthZHdr))
                {
                    return false;
                }

                // Check where request came from. This is very similar to the 
                // AAInfo.IsMiddleTier code in AAinfo.cs.

                SGAddressValidator.Answer ans;
                ans = SGAddressValidator.Check(MessageArgs.RemoteEP.Address, (ushort)MessageArgs.RemoteEP.Port);
                if (ans == SGAddressValidator.Answer.Yes)
                {
                    return false;
                }

                return true;
            }
        }

        public void CompletePush(RequestProcessor nextProcessor)
        {
            Processors.Push(nextProcessor);
        }

        public void Complete()
        {
            if (Processors.Count > 0)
            {
                RequestProcessor pfn = Processors.Pop();
                if (pfn != null)
                {
                    pfn(this);
                }
            }
        }

        public void QueueUserWorkItem(RequestProcessor nextProcessor)
        {
            FlowTrace("QueueUserWorkItem");
            
            CompletePush(nextProcessor);
            if (_ThreadPool.QueueUserWorkItem(UserWorkItemCallback, this))
            {
                VortexCounters.Current.MessageQueueRemainingWorker.Decrement();
            }
            else
            {
                FlowTrace("QueueUserWorkItem: unable to queue, discarding");
                VortexCounters.Current.MessageQueueDiscarded.Increment();
                RequestContext.FreeContext(this);
            }
        }

        private static void UserWorkItemCallback(object state)
        {
            VortexCounters.Current.MessageQueueRemainingWorker.Increment();
            RequestContext reqCtx = (RequestContext)state;
            reqCtx.IsRunningOnWorkerThread = true;

            try
            {
                reqCtx.Complete();
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_REQUEST_UNHANDLED_ERROR, e,
                    "Error while processing request on worker thread. Details:\r\n{0}",
                    reqCtx.ToEventString());
                Trace.Error("{0} RequestContext: unhandled exception in worker thread: {1}", 
                    reqCtx.ToString(), e.Message);
            }
        }

        public void FlowTrace(string message, params object[] args)
        {
            if (s_FlowTraceArea == null || !s_FlowTraceArea.Enabled)
            {
                return;
            }

            LogLevel lvl = LogLevel.L_NORMAL;

            // Bump up level for local requests
            if (MessageArgs.RemoteEP != null &&
                MessageArgs.LocalEP != null &&
                MessageArgs.RemoteEP.Address.Equals(MessageArgs.LocalEP.Address))
            {
                lvl = LogLevel.L_HIGH;
            }

            // Note: We could log directly to the area and avoid the dictionary lookup,
            // but since this is normally off I don't want to do that optimization.

            if (!String.IsNullOrEmpty(message))
            {
                Xom.Trace(XomAreaName.VortexFlow, lvl, "{0}: {1}",
                    this.ToString(),
                    String.Format(message, args));
            }
            else
            {
                Xom.Trace(XomAreaName.VortexFlow, lvl, "{0}", this.ToString());
            }
        }

        public string ToEventString()
        {
            StringBuilder sb = new StringBuilder();
            try
            {
                sb.AppendLine("----- RequestContext -----");
                sb.AppendLine(this.ToString());
                sb.AppendLine();
                if (this.AAInfoInstance != null)
                {
                    sb.AppendLine("----- AA Info -----");
                    sb.AppendLine(this.AAInfoInstance.ToString());
                    sb.AppendLine();
                }
                else if (!String.IsNullOrEmpty(this.MessageArgs.AuthZHdr))
                {
                    sb.AppendLine("----- AA Info AuthZ Header -----");
                    sb.AppendLine(this.MessageArgs.AuthZHdr);
                    sb.AppendLine();
                }
                if (this.SGInfoInstance != null)
                {
                    sb.AppendLine("----- SG Info -----");
                    sb.AppendLine(this.SGInfoInstance.ToString());
                    sb.AppendLine();
                }
                // Don't currently support httpauthdata, so don't want to mislead anyone
                //else if (!String.IsNullOrEmpty(this.MessageArgs.HttpAuthDataHdr))
                //{
                //    sb.AppendLine("----- SG Info HttpAuthData Header -----");
                //    sb.AppendLine(this.MessageArgs.AuthZHdr);
                //    sb.AppendLine();
                //}

                if (this.LinesAvailable)
                {
                    sb.AppendLine("----- LogString -----");
                    foreach (string line in this.Lines)
                    {
                        sb.AppendLine(line);
                    }
                    sb.AppendLine();
                }
                if (this.EventsAvailable)
                {
                    sb.AppendLine("----- VortexProtocol -----");
                    foreach (VxEvent ve in this.MessageArgs.Events)
                    {
                        sb.AppendLine(ve.ToString(true));
                    }
                    sb.AppendLine();
                }
            }
            catch (Exception e)
            {
                sb.AppendLine("Unhandled exception while building event text:");
                sb.AppendLine(e.ToString());
            }
            return sb.ToString();
        }

        public override string ToString()
        {
            MessageReceivedEventArgs ma = MessageArgs;
            if (ma == null)
            {
                return String.Format("[#{0}] n/a", CtxNum);
            }

            StringBuilder sb = new StringBuilder(100);
            sb.AppendFormat("[{0} {1} #{2}] ",
                Thread.CurrentThread.ManagedThreadId,
                ma.RemoteEP != null ? ma.RemoteEP.ToString() : "0.0.0.0:0",
                CtxNum);
            if (EventsAvailable)
            {
                sb.AppendFormat("{0}/V ", MessageArgs.Events.Count);
            }
            if (LinesAvailable)
            {
                sb.AppendFormat("{0}/L ", Lines.Count);
            }
            sb.AppendFormat("SG:{0}/{1}",
                ma.HttpAuthDataHdr != null ? ma.HttpAuthDataHdr.Length : 0,
                SGInfoInstance != null ? "Y" : "N");
            if (ma.AuthZHdr != null && ma.AuthZHdr.Length > 0)
            {
                sb.AppendFormat(" AA:{0}/{1}",
                    ma.AuthZHdr.Length,
                    AAInfoInstance != null ? "Y" : "N");
            }
            if (MessageAutoValueSource != AutoValueSource.None)
            {
                sb.AppendFormat(" [{0}]", MessageAutoValueSource.ToString());
            }

            return sb.ToString();
        }
    }



} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\fd\InputEventMediator.cs ===
// InputEventMediator.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Hooks up the event providers and event consumers
// 
// Author: kgoodier 10/2009
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.core.etx;
using xonline.common.utilities2;
using xonline.server.vortex.common;

namespace xonline.server.vortex.fd
{

    /// <summary>
    /// </summary>
    public class InputEventMediator
    {
        // Transport-level inputs
        private HttpInput           _HttpInputProvider;
        private UdpInput            _UdpInputProvider;

        // For rounding up stats
        private Timer               _ReportTimer;

        private VortexConfig        _VortexConfig;
        private FastThreadPool      _FastThreadPool;

        private static bool         _DisableAllSgInfoLookups;

        // ----------------------------------------------------------------------------------
        // Constructor
        // ----------------------------------------------------------------------------------
        public InputEventMediator(VortexConfig vc)
        {
            _HttpInputProvider = new HttpInput(
                (int)vc.Settings.HttpPort,
                vc.Settings.HttpPrefix,
                vc.Settings.P3PForLogWebv1,
                vc.Settings.ProducerSymbolForLogWebv1);

            _UdpInputProvider = new UdpInput(
                (int)vc.Settings.UdpPort,
                (int)vc.Settings.UdpReceiveBufferSize,
                (int)vc.Settings.NumOverlappedIoOperations);

            _FastThreadPool = new FastThreadPool(
                vc.Settings.ComponentName,
                (int)vc.Settings.MinWorkerThreads,
                (int)vc.Settings.MaxWorkerThreads,
                ThreadPriority.Normal,
                (int)vc.Settings.MaxWorkerThreadLatencyMs,
                (int)vc.Settings.MaxWorkItemQueueSize);

            VortexCounters.Current.MessageQueueRemainingWorker.RawValue = _FastThreadPool.MaxQueueCount;

            _VortexConfig = vc;

            // Event callbacks
            _HttpInputProvider.ValidateRequest += new EventHandler<ValidateRequestEventArgs>(OnValidateRequest);
            _HttpInputProvider.EventsReceived += new EventHandler<MessageReceivedEventArgs>(OnEventsReceived);
            _UdpInputProvider.EventsReceived += new EventHandler<MessageReceivedEventArgs>(OnEventsReceived); 

            vc.ConfigChanged += new EventHandler<ConfigChangedEventArgs>(OnConfigChanged);

            // Load settings
            DoConfiguration(vc);

            _ReportTimer = new Timer(new TimerCallback(ReportTimerCallback), null, 1000, 1000);

        }

        private void DoConfiguration(VortexConfig vc)
        {
            int workerThreads;
            int ioThreads;

            // Only adjust IO threads
            if (vc.Settings.MaxIOThreads > 0)
            {
                ThreadPool.GetMaxThreads(out workerThreads, out ioThreads);
                ThreadPool.SetMaxThreads(workerThreads, (int)vc.Settings.MaxIOThreads);
            }
            if (vc.Settings.MinIOThreads > 0)
            {
                ThreadPool.GetMinThreads(out workerThreads, out ioThreads);
                ThreadPool.SetMinThreads(workerThreads, (int)vc.Settings.MinIOThreads);
            }

            if (vc.Settings.MaxWorkerThreads > 0)
            {
                _FastThreadPool.MaxThreadCount = (int)vc.Settings.MaxWorkerThreads;
            }
            if (vc.Settings.MinWorkerThreads > 0)
            {
                _FastThreadPool.ThreadCount = (int)vc.Settings.MinWorkerThreads;
            }
            
            int orig = _FastThreadPool.MaxQueueCount;
            _FastThreadPool.MaxQueueCount = vc.Settings.MaxWorkItemQueueSize ?? 0;
            _FastThreadPool.MaxLatencyMs = vc.Settings.MaxWorkerThreadLatencyMs ?? 0;

            // Adjust perf counter
            int diff = _FastThreadPool.MaxQueueCount - orig;
            VortexCounters.Current.MessageQueueRemainingWorker.RawValue += diff;

            _UdpInputProvider.ReceiveBufferSize = vc.Settings.UdpReceiveBufferSize ?? 1000000;
            _UdpInputProvider.NumOverlappedIoOperations = vc.Settings.NumOverlappedIoOperations ?? 1;
            _DisableAllSgInfoLookups = vc.Settings.DisableAllSgInfoLookups ?? false;

            StringSvrHelper.DoConfiguration(vc);

            EtxManifestHelper.UnknownEventHeaderVersion = (byte)vc.Settings.UnknownEventHeaderVersion;

            EtxManifestHelper.CategoriesAllowedThroughIFLC = new HashSet<string>(
                _VortexConfig.Settings.CategoriesAllowedThroughIFLC);
        }

        private void ReportTimerCallback(object data)
        {
            try
            {
                VortexCounters ctrs = VortexCounters.Current;

                // Do it for real
                int workerThreads;
                int ioThreads;

                // Available
                ThreadPool.GetAvailableThreads(out workerThreads, out ioThreads);
                ctrs.InputIOThreadsAvailable.RawValue = (long)ioThreads;
                ctrs.InputWorkerThreadsAvailable.RawValue = (long)_FastThreadPool.ThreadsWaiting;

                // Max
                ThreadPool.GetMaxThreads(out workerThreads, out ioThreads);
                ctrs.InputIOThreadsMax.RawValue = (long)ioThreads;
                ctrs.InputWorkerThreadsMax.RawValue = (long)_FastThreadPool.MaxThreadCount;

                // Min
                ThreadPool.GetMinThreads(out workerThreads, out ioThreads);
                ctrs.InputIOThreadsMin.RawValue = (long)ioThreads;
                ctrs.InputWorkerThreadsMin.RawValue = (long)_FastThreadPool.ThreadCount;

                // Other stuff
                ctrs.MessageContextSwitchRate.RawValue = _FastThreadPool.NumberOfAwakenings;
                ctrs.AverageMessageBatchSize.RawValue = _FastThreadPool.NumberOfItemsProcessed;
                ctrs.AverageMessageBatchSizeBase.RawValue = _FastThreadPool.NumberOfAwakenings;
            }
            catch (Exception e)
            {
                Trace.Error("InputEventMediator: ReportTimerCallback unexpected error: {0}", e.ToString());
            }
        }

        public void Start()
        {
            _HttpInputProvider.Start();
            _UdpInputProvider.Start();
        }

        public void Stop()
        {
            _HttpInputProvider.Stop();
            _UdpInputProvider.Stop();
        }

        public void Shutdown()
        {
            Stop();
            _FastThreadPool.Shutdown();
        }

        // ----------------------------------------------------------------------------------
        // OnConfigChanged - called whenever the configuration has changed.
        // ----------------------------------------------------------------------------------
        private void OnConfigChanged(object sender, ConfigChangedEventArgs args)
        {
            if (args.MultiSettingChangeArgs != null &&
                args.MultiSettingChangeArgs.MultiSetting == MultiSetting.vortex_categoriesAllowedThroughIFLC)
            {
                HashSet<string> categories = new HashSet<string>(_VortexConfig.Settings.CategoriesAllowedThroughIFLC);
                // Swap it out, shouldn't be any race conditions given its usage pattern
                EtxManifestHelper.CategoriesAllowedThroughIFLC = categories;
            }
            else
            {
                // @@@ Maybe detect what exactly changed by looking at args and do 
                // something smarter.
                DoConfiguration(_VortexConfig);
            }
        }

        // ----------------------------------------------------------------------------------
        // OnValidateRequest - called by the lower level HTTP input provider whenever an event
        // or batch of events comes in and it needs low-level validation.
        // ----------------------------------------------------------------------------------
        private void OnValidateRequest(object sender, ValidateRequestEventArgs messageArgs)
        {
            // Only bother to check if request is still valid
            if (messageArgs.Validated)
            {
                messageArgs.Validated = _VortexConfig.XrlUtility.TryValidateRequest(messageArgs.RequestContext);
            }
        }

        // ----------------------------------------------------------------------------------
        // OnEventsReceived - called by the lower level input providers whenever an event
        // or batch of events comes in.
        //
        // This is called by the transport layer using one of its IO threads. We should 
        // NOT do any significant work here. Avoid blocking. Queue a work item for a 
        // worker thread if expensive work is needed.
        // ----------------------------------------------------------------------------------
        private void OnEventsReceived(object sender, MessageReceivedEventArgs messageArgs)
        {
            RequestContext reqCtx = RequestContext.Create(messageArgs, _FastThreadPool);

            // This is the last thing we'll do to the request
            reqCtx.CompletePush(FinalizeRequest);

            if (_VortexConfig.Settings.AlwaysUseWorkerThread ?? true)
            {
                // Move off the IO thread and onto a worker thread. Will increase context 
                // switches and latency, but will keep the input buffer from overflowing.
                reqCtx.QueueUserWorkItem(OnEventsReceived);
            }
            else
            {
                OnEventsReceived(reqCtx);
            }
        }

        private void OnEventsReceived(RequestContext reqCtx)
        {
            reqCtx.FlowTrace("OnEventsReceived");

            try
            {
                if (reqCtx.LinesAvailable)
                {
                    // Old school LogString and LogString2 requests get treated much
                    // the same as StringSvr. They don't get fancy Vortex treatment.
                    StringSvrHelper.ProcessLogLinesLikeStringSvr(reqCtx);
                }

                if (reqCtx.EventsAvailable)
                {
                    // Vortex binary events get different treatment - manifests, etc.
                    ApplyManifest(reqCtx);
                }

                if (reqCtx.WebEventAvailable)
                {
                    // Web GET events also get different treatment - manifests, etc.
                    ApplyWebManifest(reqCtx);

                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_REQUEST_UNHANDLED_ERROR, e,
                    "Error while processing request on completion thread. Details:\r\n{0}",
                    reqCtx.ToEventString());
                Trace.Error("{0} RequestContext: unhandled exception: {1}",
                    reqCtx.ToString(), e.Message);
            }

        }

        // ------------------------------------------------------------------------------
        // FlattenWebRequest
        //
        // Transforms the web request into a pipe delimited event log line.
        //
        // RequestContext Processor
        // ------------------------------------------------------------------------------
        private void FlattenWebRequest(RequestContext reqCtx)
        {
            HttpGetMessageData msg = reqCtx.MessageArgs.HttpGetData;
            Event evt = msg.EventManifest;
            StringBuilder line = new StringBuilder();
            HashSet<string> unusedKeys;
            Func<string, string> cleanup;
            Func<StringBuilder, char, string> getLeftovers;

            // list of unused keys
            unusedKeys = new HashSet<string>(msg.QuerystringParameters.AllKeys, StringComparer.OrdinalIgnoreCase);

            // cleans up text to make sure it doesn't contain delimiters or line breaks
            cleanup = s => s == null ? s : s.Replace('|', ',').Replace('\n', ' ').Replace('\r', ' ');

            // retrieves the unreferenced fields from the query string
            getLeftovers = (sb, delim)
                =>
                {
                    foreach (var key in unusedKeys)
                    {
                        if (sb.Length > 0)
                        {
                            sb.Append(delim);
                        }

                        sb.AppendFormat("{0}={1}", key, cleanup(msg.QuerystringParameters[key]));
                    }

                    return sb.ToString();
                };

            // manifest present, use it flatten event
            if (evt != null)
            {
                var cur = 0;

                // enumerate fields, header fields first
                var fields =
                    (from f in evt.HeaderFields orderby f.Ordinal select f).Union
                    (from f in evt.DataFields orderby f.Ordinal select f);
                    
                foreach (var field in fields)
                {
                    string key;

                    if (cur > 0)
                    {
                        line.Append('|');
                    }

                    key = string.IsNullOrEmpty(field.Text)
                        ? field.Name
                        : field.Text;

                    if (field.AutoValue.HasValue)
                    {
                        switch (field.AutoValue.Value)
                        {
                            case AutoValues.LookupCookie:
                                line.Append(cleanup(msg.ImplicitData[HttpGetMessageData.CookiePrefix + key]));
                                break;

                            case AutoValues.LookupRequestHeader:
                                line.Append(cleanup(msg.ImplicitData[HttpGetMessageData.HeaderPrefix + key]));
                                break;

                            case AutoValues.LookupQuerystringLeftover:
                                line.Append(getLeftovers(new StringBuilder(), '&'));
                                break;

                            case AutoValues.LookupQueryString:
                                line.Append(cleanup(msg.QuerystringParameters[key]));
                                unusedKeys.Remove(key);
                                break;

                            case AutoValues.Timestamp:
                                if (field.Ordinal == 1) // cleanser timestamp, this will be handled by the cleanser
                                {
                                    // continue on to the next field so cur isn't updated
                                    continue;
                                }
                                else
                                {
                                    line.Append(XDateTime.ToString(DateTime.UtcNow));
                                }

                                break;

                            case AutoValues.LogStringId:
                                line.Append(cleanup(string.Format("{0}-{1}", msg.ProducerSymbol, msg.EventName)));
                                break;
                        }
                    }
                    else
                    {
                        line.Append(cleanup(msg.QuerystringParameters[key]));
                        unusedKeys.Remove(key);
                    }

                    cur++;
                }
            }
            else
            {
                // missing manifest dump the query string parameters to the log
                line.AppendFormat("{0}-{1}.{2}-NS|{3}",
                    msg.ProducerSymbol,
                    msg.EventName,
                    msg.ProducerSequence,
                    getLeftovers(new StringBuilder(), '|'));
            }

            // write out the line in the cleanser data protocol v1 format
            if (null == evt)
            {
                reqCtx.Lines = reqCtx.Lines ?? new List<string>();

                reqCtx.Lines.Add(line.ToString());
            }
            // write out the log line in the cleanser data protocol v3 format
            else
            {
                object sequence;

                reqCtx.SchemaLines = reqCtx.SchemaLines ?? new List<SchemaLine>();

                // we have a valid event sequence fingerprint, use the sequence number
                if (FingerprintAlgorithm.SequentialEvent.IsFingerprintValid(evt.Fingerprint))
                {
                    sequence = FingerprintAlgorithm.SequentialEvent.GetFingerprintSequence(evt.Fingerprint);
                }
                // we dont, so use the full fingerprint, it should have never come to this!?! :'(
                else
                {
                    sequence = evt.Fingerprint;
                }

                reqCtx.SchemaLines.Add(
                    new SchemaLine()
                    {
                        Key = string.Format("{0}-{1}", sequence, evt.HeaderVersion),
                        LogStringId = string.Format("{0}-{1}",
                            msg.ProducerSymbol,
                            msg.EventName),
                        Event = evt,
                        Line = line.ToString()
                    });
            }
        }

        // ------------------------------------------------------------------------------
        // ApplyWebManifest
        //
        // RequestContext Processor
        // ------------------------------------------------------------------------------
        private void ApplyWebManifest(RequestContext reqCtx)
        {
            reqCtx.FlowTrace("ApplyWebManifest");

            reqCtx.MessageAutoValueSource = EtxManifestHelper.ClassifyWebEvent(
                reqCtx.MessageArgs.HttpGetData,
                _VortexConfig.EtxEvents);

            FlattenWebRequest(reqCtx);

            reqCtx.Complete();
        }

        // ------------------------------------------------------------------------------
        // ApplyManifest 
        //
        // RequestContext Processor
        // ------------------------------------------------------------------------------
        private void ApplyManifest(RequestContext reqCtx)
        {
            reqCtx.FlowTrace("ApplyManifest");

            // If we're to retrieve the SGInfo for unknown events, then we want to 
            // classify them (with the default).
            reqCtx.MessageAutoValueSource = EtxManifestHelper.ClassifyEvents(
                reqCtx.MessageArgs.Events,
                _VortexConfig.EtxEvents,
                _VortexConfig.Settings.RetrieveSgInfoForUnknownEvents ?? false,
                reqCtx.IsMessageFromActiveAuth,
                out reqCtx.VortexEvents);

            // At this point, reqCtx.VortexEvents is what we want to start using instead
            // of reqCtx.MessageArgs.Events

            if ((reqCtx.MessageAutoValueSource & AutoValueSource.AAInfo) > 0 &&
                (reqCtx.MessageAutoValueSource & AutoValueSource.SGInfo) > 0)
            {
                // Some autovalues can come from either SGInfo or AAInfo. Or maybe different
                // events have a mix of different autovalue sources. Unfortunately, it has to 
                // be one or the other. So pick one.
                if (reqCtx.IsMessageFromActiveAuth)
                {
                    // Remove SGInfo
                    reqCtx.MessageAutoValueSource &= ~AutoValueSource.SGInfo;
                }
                else
                {
                    // Remove AAInfo
                    reqCtx.MessageAutoValueSource &= ~AutoValueSource.AAInfo;
                }
            }

            // For anything that's "expensive" to read -- blocking, mainly -- we
            // want to defer the work to a worker thread.
            if ((reqCtx.MessageAutoValueSource & AutoValueSource.SGInfo) > 0 ||
                (reqCtx.MessageAutoValueSource & AutoValueSource.AAInfo) > 0)
            {
                reqCtx.CompletePush(ApplyManifestContinued);
                if (reqCtx.IsRunningOnWorkerThread)
                {
                    // Just execute directly
                    RetrieveRequestInfo(reqCtx);
                }
                else
                {
                    // Defer it.
                    reqCtx.QueueUserWorkItem(RetrieveRequestInfo);
                }
            }
            else
            {
                // Otherwise continue on our way.
                ApplyManifestContinued(reqCtx);
            }
        }

        // ------------------------------------------------------------------------------
        // ApplyManifestContinued - actually fills out autovalues
        //
        // RequestContext Processor
        // ------------------------------------------------------------------------------
        private void ApplyManifestContinued(RequestContext reqCtx)
        {
            reqCtx.FlowTrace("ApplyManifestContinued");

            foreach (VxEventWithManifest ve in reqCtx.VortexEvents)
            {
                EtxManifestHelper.ApplyManifest(
                    ve,
                    reqCtx.SGInfoInstance,
                    reqCtx.AAInfoInstance);
            }

            reqCtx.Complete();
        }

        // ------------------------------------------------------------------------------
        // RetrieveRequestInfo
        //
        // RequestContext Processor
        // ------------------------------------------------------------------------------
        internal static void RetrieveRequestInfo(RequestContext reqCtx)
        {
            // the AutoValueSource is a flags enum, but a request cannot have both an AAInfo
            // and SGInfo. Some autovalue fieds can be filled from either source, though. 
            // We'll default to using AAInfo, since we know right now whether it is available
            // or not. SGInfo is the second choice.
            if ((reqCtx.MessageAutoValueSource & AutoValueSource.AAInfo) > 0)
            {
                try
                {
                    reqCtx.FlowTrace("RetrieveRequestInfo AAInfo");
                    AAInfo aainfo = AAInfo.CreateFromAuthZHeader(reqCtx.MessageArgs.AuthZHdr);
                    reqCtx.AAInfoInstance = aainfo;
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.VORTEX_REQUEST_AAINFO_ERROR, e,
                        "Error retrieving AAInfo, processing will continue without it.\r\nRequest: {0}",
                        reqCtx);
                    Trace.Error("RetrieveRequestInfo: Failed creating AAInfo: {0}", e.Message);
                }
            }
            else if ((reqCtx.MessageAutoValueSource & AutoValueSource.SGInfo) > 0)
            {
                // Big note:
                //
                // VortexFD currently only has an external interface. It has no internal
                // interface. That means we cannot trust the HttpAuthData header, since
                // we can't distinguish a malicious client from a datacenter call. This,
                // plus the fact no service in Live should be calling us anyway, means
                // we DO NOT SUPPORT HTTPAUTHDATA at this time. Thank you.

                // TODO: verify before we send the SGInfo request to the SG that this
                // request actually came from a real SG, or at least appears that way.
                // The current SGInfo.IsAvailable check requires lots of asp.net 
                // HttpContext stuff, so we can't use it. For now, we don't ever 
                // expect calls to hit us from anything but a real SG (or AuthSG),
                // so we're ok.

                if (reqCtx.MessageArgs.RemoteEP != null)
                {
                    try
                    {
                        if (!_DisableAllSgInfoLookups)
                        {
                            reqCtx.FlowTrace("RetrieveRequestInfo SGInfo");
                            VortexCounters.Current.SGInfoLookupsInProgress.Increment();
                            SGInfo sginfo = new SGInfo(
                                reqCtx.MessageArgs.RemoteEP.Address,
                                (ushort)reqCtx.MessageArgs.RemoteEP.Port);
                            reqCtx.SGInfoInstance = sginfo;
                        }
                        else
                        {
                            reqCtx.FlowTrace("RetrieveRequestInfo SGInfo: disabled, skipping");
                        }
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.VORTEX_REQUEST_SGINFO_ERROR, e,
                            "Error retrieving SGInfo from {0}, processing will continue without it.\r\nRequest: {1}",
                            reqCtx.MessageArgs.RemoteEP.ToString(),
                            reqCtx);
                        Trace.Error("RetrieveRequestInfo: Failed creating SGInfo: {0}", e.Message);
                    }
                    finally
                    {
                        VortexCounters.Current.SGInfoLookupsInProgress.Decrement();
                    }
                }
                else
                {
                    reqCtx.FlowTrace("RetrieveRequestInfo SGInfo unavailable, RemoteEP is null");
                }
            }
            else
            {
                reqCtx.FlowTrace("RetrieveRequestInfo No AAInfo or SGInfo required");
            }
            
            reqCtx.Complete();
        }

        // ------------------------------------------------------------------------------
        // FinalizeRequest - save events/loglines to cleanser, etc. Wrap things up.
        // ------------------------------------------------------------------------------
        private void FinalizeRequest(RequestContext reqCtx)
        {
            reqCtx.FlowTrace("FinalizeRequest");

            if (reqCtx.EventsAvailable)
            {
                foreach (VxEventWithManifest ve in reqCtx.VortexEvents)
                {
                    XomLogTargetContext xomCtx = EtxManifestHelper.CreateReportingContext(ve);

                    int firstOrdinalIndex;
                    string line = EtxManifestHelper.ToLogString(ve, out firstOrdinalIndex);

                    if (ve.EventManifest != null)
                    {
                        try
                        {
                            // Binary protocol events get StringSvr-style perf counters, too.
                            string firstOrdinalField = StringSvrHelper.ParseFirstField(line, firstOrdinalIndex);
                            StringSvrHelper.ApplyPerfCounter(ve.EventData.LogStringId, firstOrdinalField);
                        }
                        catch (Exception e)
                        {
                            Trace.Error("FinalizeRequest: error applying perf counter: {0}", e.ToString());
                        }

                        // Separate events with a manifest from events without one into 
                        // two xom areas. This allows us to disable one and not the other,
                        // for instance.
                        VortexCounters.Current.XomLogInProgress.Increment();
                        try
                        {
                            Xom.Log(XomAreaName.VortexOutput, xomCtx, "{0}", line);
                        }
                        finally
                        {
                            VortexCounters.Current.XomLogInProgress.Decrement();
                        }
                    }
                    else
                    {
                        VortexCounters.Current.XomLogInProgress.Increment();
                        try
                        {
                            Xom.Log(XomAreaName.VortexOutputUnknown, xomCtx, "{0}", line);
                        }
                        finally
                        {
                            VortexCounters.Current.XomLogInProgress.Decrement();
                        }
                    }
                }
            }

            if (reqCtx.LinesAvailable)
            {
                foreach (string line in reqCtx.Lines)
                {
                    VortexCounters.Current.XomLogInProgress.Increment();
                    try
                    {
                        Xom.Log(XomAreaName.VortexOutput, "{0}", line);
                    }
                    finally
                    {
                        VortexCounters.Current.XomLogInProgress.Decrement();
                    }
                }
            }

            if (reqCtx.SchemaLinesAvailable)
            {
                foreach (var line in reqCtx.SchemaLines)
                {
                    VortexCounters.Current.XomLogInProgress.Increment();

                    try
                    {
                        var ctx = new XomLogTargetContext(Floken.None)
                        {
                            LogStringId = line.LogStringId,
                            LineData = new XomLogTargetContext.SchematizedLine()
                            {
                                Fingerprint = line.Event.Fingerprint,
                                HeaderVersion = line.Event.HeaderVersion,
                                Key = line.Key
                            }
                        };

                        Xom.Log(XomAreaName.VortexOutput, ctx, "{0}", line.Line);
                    }
                    finally
                    {
                        VortexCounters.Current.XomLogInProgress.Decrement();
                    }
                }
            }

            reqCtx.Complete();
        }

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\fd\StringSvrHelper.cs ===
// 
// LogString.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// String Service Front Door
// Xbox Online Service
//
// This is a copy of \private\server\stringsvr\fd\logstring.cs. It provides nearly exact 
// back-compat with what StringSvr does. Vortex needs this for the "deprecated" LogString 
// and LogString2 apis. ETX (LogBinary and UDP) are the future -- the manifests provide 
// much richer processing directives.
//

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Web;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.server.vortex.fd
{
    internal class StringSvrHelper 
    {
        //-----------------------------------------------------
        //
        // Handle the raw request
        //
        public static void ProcessLogLinesLikeStringSvr(RequestContext reqCtx)
        {
            reqCtx.FlowTrace("ProcessLogLinesLikeStringSvr");

            if (!reqCtx.LinesAvailable)
            {
                reqCtx.Complete();
                return;
            }

            // See if any loglines require SGInfo or AAInfo
            foreach (string line in reqCtx.Lines)
            {
                if (String.IsNullOrEmpty(line))
                {
                    continue;
                }

                string key;
                string secondField;
                ParseFirstTwoFields(line, out key, out secondField);

                if (StringSvrHelper.Prefixes.ContainsKey(key))
                {
                    Dictionary<string, string> prefixInfo = StringSvrHelper.Prefixes[key];
                    bool fDone = false;
                    switch (prefixInfo["type"])
                    {
                        case "failure":
                        case "measurement":
                            // Use same logic as stringsvr for determing whether to use 
                            // AAInfo or SGInfo
                            if (reqCtx.IsMessageFromActiveAuth)
                            {
                                reqCtx.MessageAutoValueSource |= AutoValueSource.AAInfo;
                                fDone = true;
                            }
                            else if (reqCtx.MessageArgs.HttpAuthDataHdr == null)
                            {
                                // Only use SGInfo if it didn't come from internal. See 
                                // SGInfo._IsInternal. Basically boils down to "if there
                                // is an HttpAuthDataHdr, then it's from internal".
                                reqCtx.MessageAutoValueSource |= AutoValueSource.SGInfo;
                                fDone = true;
                            }
                            if (fDone)
                            {
                                // Go retrieve AAInfo or SGInfo on worker thread, and
                                // continue on when done.
                                reqCtx.CompletePush(ProcessLogLinesLikeStringSvrContinued);
                                reqCtx.QueueUserWorkItem(InputEventMediator.RetrieveRequestInfo);
                                return;
                            }
                            break;
                    }
                }
            }

            ProcessLogLinesLikeStringSvrContinued(reqCtx);
        }

        public static void ProcessLogLinesLikeStringSvrContinued(RequestContext reqCtx)
        {
            reqCtx.FlowTrace("ProcessLogLinesLikeStringSvrContinued");

            // Make a new list of loglines
            List<string> logList = new List<string>(reqCtx.Lines.Count);

            // Now process each logline
            foreach (string line in reqCtx.Lines)
            {
                if (String.IsNullOrEmpty(line))
                {
                    continue;
                }

                string key;
                string secondField;
                ParseFirstTwoFields(line, out key, out secondField);

                if(StringSvrHelper.Prefixes.ContainsKey(key))
                {
                    Dictionary<string, string> prefixInfo = StringSvrHelper.Prefixes[key];
                    string newline;
                    switch(prefixInfo["type"])
                    {
                        case "failure":
                        case "measurement":
                            newline = AppendRequestInfo(line, reqCtx);
                            ApplyPerfCounter(key, secondField);
                            logList.Add(newline);
                            break;

                        default:
                            break;
                    }
                }
                // If this is an aggregate linetype, aggregate it in our cache
                // Otherwise fire a logline to reporting.
//                 else if(StringSvrHelper.Keys.Contains(key))
//                 {
//                     ProcessReportingAggregate(line);
//                 }                
                else if (key.Length > 0)
                {
                    string logline = line.Replace('~', '|');
                    
                    // Reporting Log line: LS-LogString
                    logList.Add("LS-" + logline);
                }       
            }

            // Replace input logline list with our new (and improved) one.
            reqCtx.MessageArgs.Lines = logList;
            reqCtx.Complete();
        }

        public static void ApplyPerfCounter(string prefix, string secondField)
        {
            Dictionary<string, string> prefixInfo;
            if (StringSvrHelper.Prefixes.TryGetValue(prefix, out prefixInfo))
            {
                switch (prefixInfo["type"])
                {
                    case "failure":
                    {
                        FailureMonitoringCounter currentCounter = (FailureMonitoringCounter)FailureMonitoringCounter.Counters.GetInstance(prefix);
                        currentCounter.FailedAPIsByServiceIdRate.Increment();
                        break;
                    }

                    case "measurement":
                    {
                        // The second field of the log line is a number that we need to
                        // compare against the configured threshold. If there is no 
                        // second field, bail out.

                        if (String.IsNullOrEmpty(secondField))
                            break;

                        int measuredValue;
                        if (!Int32.TryParse(secondField, NumberStyles.AllowHexSpecifier, null, out measuredValue))
                        {
                            // No event. Can always find in forensics, and any error here
                            // will likely be very spammy.
                            break;
                        }

                        int threshold;
                        if (StringSvrHelper.Thresholds.TryGetValue(prefix, out threshold))
                        {
                            if (measuredValue <= threshold)
                            {
                                break;
                            }

                            MeasurementThresholdMonitoringCounter currentCounter =(MeasurementThresholdMonitoringCounter)MeasurementThresholdMonitoringCounter.Counters.GetInstance(prefix);
                            currentCounter.MeasurementThresholdsExceededRate.Increment();
                        }
                        break;
                    }
                    default:
                        break;
                }
            }
        }

        public static string ParseFirstField(string line, int startIndex)
        {
            if (String.IsNullOrEmpty(line))
            {
                return String.Empty;
            }

            int firstPipe = line.IndexOf("|", startIndex);
            if (firstPipe == -1)
            {
                return line;
            }

            return line.Substring(startIndex, firstPipe - startIndex);
        }

        public static void ParseFirstTwoFields(string line, out string firstField, out string secondField)
        {
            int firstPipe = line.IndexOf("|");
            if (firstPipe == -1)
            {
                firstField = line;
                secondField = null;
                return;
            }

            firstField = line.Substring(0, firstPipe);
            int secondPipe = line.IndexOf("|", firstPipe + 1);
            secondField = (-1 == secondPipe)
                ? line.Substring(firstPipe + 1)
                : line.Substring(firstPipe + 1, secondPipe - firstPipe - 1);
        }

        private static short GetLoggedOnUserIndex(SGInfo sginfo)
        {
            for(short currentUser = 0; currentUser < sginfo.LogonUsers.Length; ++currentUser)
            {
                if (sginfo.LogonUsers[currentUser].qwUserID != 0 &&
                    !sginfo.LogonUsers[currentUser].IsGuest())
                {
                    return currentUser;
                }
            }

            return -1;
        }

        private static string AppendSgInfo(string line, SGInfo sginfo)
        {
            if (sginfo != null)
            {
                return string.Format(
                    "LS-{0}|{1}|{2}|{3}|{4}",
                    line.Replace('~', '|'),
                    sginfo.ClientIP,
                    sginfo.MachineId.ToString("X"),
                    GetLoggedOnUserIndex(sginfo) != -1
                        ? sginfo.GetUserCountry(sginfo.LogonUsers[GetLoggedOnUserIndex(sginfo)].qwUserID).ToString("X")
                        : "0",
                    sginfo.TitleId.ToString("X"));
            }
            else
            {
                return string.Format(
                    "LS-{0}|0.0.0.0|0|0|0",
                    line.Replace('~', '|'));
            }
        }

        private static string AppendAAInfo(string line, AAInfo aainfo)
        {
            if (aainfo != null)
            {
                return string.Format(
                    "LS-{0}|{1}",
                    line.Replace('~', '|'),
                    aainfo.IpAddressInternet);
            }
            else
            {
                return string.Format(
                    "LS-{0}|0.0.0.0",
                    line.Replace('~', '|'));
            }
        }

        private static string AppendRequestInfo(string line, RequestContext reqCtx)
        {
            // Was:
            // return AAInfo.IsActiveAuthAvailable ? AppendAAInfo(line) : (SGInfo.IsInternal() ? line : AppendSgInfo(line) );

            if ((reqCtx.MessageAutoValueSource & AutoValueSource.AAInfo) > 0)
            {
                return AppendAAInfo(line, reqCtx.AAInfoInstance);
            }
            else if ((reqCtx.MessageAutoValueSource & AutoValueSource.SGInfo) > 0)
            {
                return AppendSgInfo(line, reqCtx.SGInfoInstance);
            }
            else
            {
                return line.Replace('~', '|');
            }
        }

        #region StringSvrApp yanked code

        public static void DoConfiguration(VortexConfig vc)
        {
            string[] prefixes = Config.GetMultiSetting(MultiSetting.stringsvr_LogStringPrefix);
            UpdatePrefixes(prefixes);
        }

        private static Dictionary<string,string> ParsePrefixLine(string line)
        {
            Dictionary<string,string> prefixLineValues = new Dictionary<string,string>();

            string[] prefixPairs = line.Split(';');

            foreach (string prefixPair in prefixPairs)
            {
                string[] pairNameValue = prefixPair.Split('=');
                if (pairNameValue.Length != 2)
                {
                    string errString = string.Format(
                        "Stringsvr:  Encountered a stringsvr_LogStringPrefix multisetting that " +
                        "did not conform to the correct format.  The required format is " +
                        "\"name1=value1;name2=value2;...\".  This multisetting will be skipped " +
                        "and initialization will continue, but this multisetting should be corrected.  " +
                        "Until corrected, it is possible that some log lines passed to the LogString " +
                        "API will not be handled correctly.  The multisetting value seen was \"{0}\".", line);
                    Xom.NtEvent(XEvent.Id.STRINGSVR_CONFIG_PREFIX_LINE_INVALID, errString);
                    Xom.Trace(XomAreaName.stringTrace, LogLevel.L_ERROR, errString);
                    return null;
                }

                prefixLineValues.Add(pairNameValue[0], pairNameValue[1]);
            }

            if(!prefixLineValues.ContainsKey("prefix"))
            {
                string errString = string.Format(
                    "Stringsvr:  Encountered a stringsvr_LogStringPrefix multisetting that " +
                    "did not specify the prefix name.  This multisetting will be skipped and " +
                    "not loaded, but the problem in this multisetting should be identified and " +
                    "corrected.  Until corrected, it is possible that some log lines passed to " +
                    "the LogString API will not be handled correctly.  The multisetting value seen " +
                    "was \"{0}\".", 
                    line);
                Xom.NtEvent(XEvent.Id.STRINGSVR_CONFIG_PREFIX_LINE_MISSING_PREFIX, errString);
                Xom.Trace(XomAreaName.stringTrace, LogLevel.L_ERROR, errString);
                return null;
            }

            if(!prefixLineValues.ContainsKey("type"))
            {
                string errString = string.Format(
                    "Stringsvr:  Encountered a stringsvr_LogStringPrefix multisetting that " +
                    "did not specify the prefix type.  This multisetting will be skipped and " +
                    "not loaded, but the problem in this multisetting should be identified and " +
                    "corrected.  Until corrected, it is possible that some log lines passed to " +
                    "the LogString API will not be handled correctly.  The multisetting value seen " +
                    "was \"{0}\".", 
                    line);
                Xom.NtEvent(XEvent.Id.STRINGSVR_CONFIG_PREFIX_LINE_MISSING_TYPE, errString);
                Xom.Trace(XomAreaName.stringTrace, LogLevel.L_ERROR, errString);
                return null;
            }

            return prefixLineValues;
        }

        public static void UpdatePrefixes(string [] prefixes)
        {
            Dictionary<string, Dictionary<string,string>> loadedPrefixes = new Dictionary<string, Dictionary<string,string>>();
            Dictionary<string, int> loadedThresholds = new Dictionary<string, int>();

            foreach(string prefixConfig in prefixes)
            {
                Dictionary<string,string> prefixLineValues = ParsePrefixLine(prefixConfig);
                if(prefixLineValues == null)
                {
                    // ParsePrefixLine already threw an event, we can just
                    // ignore this line and continue.
                    continue;
                }

                if(loadedPrefixes.ContainsKey(prefixLineValues["prefix"]))
                {
                    string errString = string.Format(
                        "Stringsvr:  Encountered a stringsvr_LogStringPrefix multisetting that contained " +
                        "a prefix that was a duplicate of a previously seen multisetting.  " +
                        "This multisetting will be skipped and " +
                        "not loaded, but the problem in this multisetting should be identified and " +
                        "corrected.  Until corrected, it is possible that some log lines passed to " +
                        "the LogString API will not be handled correctly.  The multisetting value seen " +
                        "was \"{0}\".",
                        prefixConfig);
                    Xom.NtEvent(XEvent.Id.STRINGSVR_CONFIG_PREFIX_LINE_BAD_THRESHOLD, errString);
                    Xom.Trace(XomAreaName.stringTrace, LogLevel.L_ERROR, errString);
                    continue;
                }

                if(prefixLineValues["type"] == "measurement")
                {
                    int threshold;
                    if(!Int32.TryParse(prefixLineValues["threshold"], out threshold))
                    {
                        string errString = string.Format(
                            "Stringsvr:  Encountered a stringsvr_LogStringPrefix multisetting of type "+
                            "\"measurement\" whose \"threshold\" value could not be parsed into an Int32.  " +
                            "This multisetting will be skipped and " +
                            "not loaded, but the problem in this multisetting should be identified and " +
                            "corrected.  Until corrected, it is possible that some log lines passed to " +
                            "the LogString API will not be handled correctly.  The multisetting value seen " +
                            "was \"{0}\".",
                            prefixConfig);
                        Xom.NtEvent(XEvent.Id.STRINGSVR_CONFIG_PREFIX_LINE_BAD_THRESHOLD, errString);
                        Xom.Trace(XomAreaName.stringTrace, LogLevel.L_ERROR, errString);
                        continue;
                    }

                    loadedThresholds.Add(prefixLineValues["prefix"], threshold);

                    // Ensure instance is created
                    MeasurementThresholdMonitoringCounter.Counters.GetInstance(prefixLineValues["prefix"]);
                }
                else if (prefixLineValues["type"] == "failure")
                {
                    // Ensure instance is created
                    FailureMonitoringCounter.Counters.GetInstance(prefixLineValues["prefix"]);
                }

                loadedPrefixes.Add(prefixLineValues["prefix"], prefixLineValues);
            }

            m_prefixes = loadedPrefixes;
            m_thresholds = loadedThresholds;
        }

        public static Dictionary<string, Dictionary<string, string>> Prefixes
        {
            get { return m_prefixes; }
        }

        public static Dictionary<string, int> Thresholds
        {
            get { return m_thresholds; }
        }

        private static Dictionary<string, Dictionary<string,string>> m_prefixes;
        private static Dictionary<string, int> m_thresholds;


        #endregion

    }

    #region StringSvrApp yanked perf counters

    [XomComponentPerformanceCounterCategoryAttr("Failure Monitoring", "LogString Failure Monitoring performance counters")]
    public class FailureMonitoringCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
            "Failures Seen Rate",
            "Total number of failures reported by the client per second.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedAPIsByServiceIdRate;

        static public FailureMonitoringCounter Counters = new FailureMonitoringCounter();
    }

    [XomComponentPerformanceCounterCategoryAttr("Measurement Threshold Monitoring", "LogString Measurement Threshold Monitoring performance counters")]
    public class MeasurementThresholdMonitoringCounter : XomPerformanceCounterCategory
    {
        static public MeasurementThresholdMonitoringCounter Counters = new MeasurementThresholdMonitoringCounter();

        [XomPerformanceCounterAttr(
            "Measurement Thresholds Exceeded Rate",
            "Total number of measurements received from Xbox 360 consoles that exceeded the configured threshold.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MeasurementThresholdsExceededRate;

    }

    #endregion
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\fd\EtxPrivacy.cs ===
// InputEventMediator.cs
//
// Copyright (c) 2011 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Manages PII privacy scrubbing functionality
// 
// Author: jojohn 08/2011
//

using System;
using System.Security.Cryptography;

using xonline.common.core.etx;

namespace xonline.server.vortex.fd 
{
	internal static class EtxPrivacy
	{
        internal static readonly byte[] PXUIDKey = new byte[] { 0x58, 0x62, 0x6F, 0x78, 0x33, 0x36, 0x30, 0x20, 0x52, 0x75, 0x6C, 0x65, 0x7A, 0x21 };

        internal static object ApplyTreatment(PrivacyTreatments treatment, DataField field, object value)
        {
            switch (treatment)
            {
                case PrivacyTreatments.PassThrough:
                    return value;
                case PrivacyTreatments.LBI:
                    switch (field.OutType)
                    {
                        case OutputType.SgNonce:
                            return null;
                        case OutputType.FlowToken:
                            return null;
                        case OutputType.Ipv4Address:
                            return null;
                        case OutputType.Xuid:
                            using (HMACSHA256 hash = new HMACSHA256(PXUIDKey))
                            {
                                byte[] hashXuid;
                                byte[] result = new byte[16];
                                ulong xuid;

                                // convert the xuid to a ulong (should be a ulong already)
                                xuid = value is ulong ? (ulong)value : (ulong)Convert.ToUInt64(value);

                                // compute the stable sha256 hash of the xuid
                                hashXuid = hash.ComputeHash(BitConverter.GetBytes(xuid));
                                
                                // take the top 128 bits of the hash as result
                                Buffer.BlockCopy(hashXuid, 16, result, 0, result.Length);

                                return result;
                            }
                        default:
                            return value;
                    }
                case PrivacyTreatments.MBI:
                    return (field.OutType == OutputType.LBIOnlyGUID) ? null : value;
                default:
                    throw new InvalidOperationException("Unexpected privacy treatment specified: " + treatment);
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\fd\VortexSvc.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading;
using System.ComponentModel;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.server.vortex.common;

// Not implemented yet, but I tried. Maybe again.
// [assembly: xonline.common.installer.XomWindowsServiceInstallerAttribute(
//     Interface.vortex,
//     "Xbox Live Vortex Service",
//     "Sucks in logs and other data, chews it up, and spits it out")]

[assembly: ConfigAttribute(xonline.common.config.Component.vortexfd)]
[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.VortexTrace)]
[assembly: XomAreaDefinition(XomAreaName.VortexFlow)]
[assembly: XomAreaDefinition(XomAreaName.VortexOutput)]
[assembly: XomAreaDefinition(XomAreaName.VortexOutputUnknown)]

// ----------------------------------------------------------------------------------
// Installer
// ----------------------------------------------------------------------------------
[RunInstallerAttribute(true)]
public class VortexFDProjectInstaller: VortexProjectInstaller
{
    override protected string ServiceDisplayName 
    {
        get { return "Xbox Live Vortex Front Door"; }
    }

    override protected string ServiceDescription 
    {
        get { return "Partitions and saves incoming logs and events via the ETX/StringSvr protocols."; }
    }
}

namespace xonline.server.vortex.common
{
    // ----------------------------------------------------------------------------------
    // Base service class extension
    // ----------------------------------------------------------------------------------
    public partial class BaseService : System.ServiceProcess.ServiceBase
    {
        static BaseService Create()
        {
            return new xonline.server.vortex.fd.VortexFDService();
        }
    }
}

namespace xonline.server.vortex.fd
{

    // ----------------------------------------------------------------------------------
    // Main service class
    // ----------------------------------------------------------------------------------
    public class VortexFDService : BaseService
    {
        public VortexFDService()
        {  
        }

        protected override void InitService()
        {
            base.InitService();

            // Load config
            Config = new VortexConfig();
            Config.ReloadAll();

            // Get input flowing
            EventMediator = new InputEventMediator(Config);
            EventMediator.Start();

        }
        
        protected override void CloseService()
        {
            EventMediator.Shutdown();
            base.CloseService();
        }
        
        protected override string HandleManangementCommand(ControlRequestEventArgs args)
        {
            // Don't call base, it's useless

            string helpText = @"
VortexFD Help:
   etxlist -- Display a list of etx producers currently cached in vortex.
";
            switch (args.Command.ToLower())
            {
                case "help":
                    // leave handled as false to allow for all handlers to process help.
                    return helpText;

                case "etxlist":
                {
                    StringBuilder message;
                    
                    var producers = Config.EtxEvents.CurrentManifest.Producers
                        .OrderBy(p => p.Symbol)
                        .ToList();

                    message = new StringBuilder();

                    message.AppendFormat("List of etx manifest producers ({0}):\n", producers.Count);

                    producers.ForEach(p => message.AppendFormat("  {0} :: FP={1}\n", p.Symbol, p.Fingerprint));

                    args.Handled = true;

                    return message.ToString();
                }

                default:
                    return "";
            }
        }

        public VortexConfig       Config;

        public InputEventMediator EventMediator;


    }        


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\BaseEventProvider.cs ===
// BaseEventProvider.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Common code for the event providers to use.
// 
// Author: kgoodier 10/2009
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;

using xonline.common.service;
using xonline.common.mgmt;
using xonline.server.vortex.cake;

namespace xonline.server.vortex
{

public class EventReceivedArgs : EventArgs
{
    public PayloadReader Reader;
    public object Payload;
}

public delegate void EventReceivedHandler(object sender, EventReceivedArgs e);


/// <summary>
/// Interface for event sources, either the originating transport-level provider or a mid-level
/// wrapper. The provider is the source of events, and should provide its own threads. It will
/// call the callback upon receipt of an event.
/// </summary>
public interface IEventProvider
{
    void Start();
    void Suspend();
    void Stop();

    event EventReceivedHandler EventReceived;
}


/// <summary>
/// Helper base class for event providers. Supports one or more callbacks, and allows consumers to
/// filter the types of events they receive. Also provides some helper methods for the 
/// implementors.
/// </summary>
public class BaseEventProvider : IEventProvider
{
    protected VortexMessageCountersHelper MessageCounters
    {
        get { return _TransportCounters; }
    }

    /// <summary>
    /// Parameterless constructor to make the serializer happy. DO NOT USE.
    /// </summary>
    public BaseEventProvider()
    {
    }

    /// <summary>
    /// Constructor, use this.
    /// </summary>
    /// <param name="transportType">String to be used as the performance counter instance name. May be null.</param>
    protected BaseEventProvider(string transportType)
    {
        _TransportType = transportType;
        _fProduceEvents = false;
        _TransportCounters = new VortexMessageCountersHelper("In: " + transportType);
    }

    /// <summary>
    /// Makes callbacks to all registered listeners. Will not throw any exceptions. 
    /// This is a helper function for the children.
    /// </summary>
    /// <param name="evt">Input event</param>
    /// <param name="parameters">Optional collection of relevant parameters, but not stored with the event</param>
    protected virtual void OnEventReceived(PayloadReader reader, object payload)
    {
        if (!_fProduceEvents || payload == null)
            return;

        EventReceivedArgs eventArgs = new EventReceivedArgs()
        {
            Reader = reader,
            Payload = payload
        };
        try
        {
            EventReceived(this, eventArgs);
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.VORTEX_EVENTPROVIDER_MAKECALLBACK, e,
                        "Unexpected runtime error while calling EventReceived event.");
        }
    }

    public virtual void Start()
    {
        Trace.High("{0}: Start() called. Events will be produced.", _TransportType);
        _fProduceEvents = true;
    }

    public virtual void Suspend()
    {
        Trace.High("{0}: Suspend() called. Events are suspended.", _TransportType);
        _fProduceEvents = false;
    }

    public virtual void Stop()
    {
        Trace.High("{0}: Stop() called. Events are suspended.", _TransportType);
        _fProduceEvents = false;
    }

    // Events
    public event EventReceivedHandler           EventReceived;

    // Private members
    private string                              _TransportType;
    private bool                                _fProduceEvents;
    private VortexMessageCountersHelper         _TransportCounters;
}




} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\fd\VortexConfig.cs ===
// VortexConfig.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Nice configuration wrapper
// 
// Author: kgoodier 10/2009
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.IO;
using System.Threading;
using System.Reflection;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.utilities2;
using xonline.common.core.etx;

using xonline.server.vortex.common;

namespace xonline.server.vortex.fd
{

public class VortexSettingsConfig
{
    public string ComponentName { get; set; }
    public int? HttpPort { get; set; }
    public string HttpPrefix { get; set; }
    public int? UdpPort { get; set; }

    public int? MaxIOThreads { get; set; }
    public int? MinIOThreads { get; set; }
    public int? MaxWorkerThreads { get; set; }
    public int? MinWorkerThreads { get; set; }
    public bool? RetrieveSgInfoForUnknownEvents { get; set; }
    public bool? DisableAllSgInfoLookups { get; set; } // not in npdb
    public int? UdpReceiveBufferSize { get; set; }
    public int? NumOverlappedIoOperations { get; set; }
    public int? MaxWorkerThreadLatencyMs { get; set; }
    public int? MaxWorkItemQueueSize { get; set; }
    public bool? AlwaysUseWorkerThread { get; set; }
    public int? UnknownEventHeaderVersion { get; set; }
    public string[] CategoriesAllowedThroughIFLC { get; set; }
    public string P3PForLogWebv1 { get; set; }
    public string ProducerSymbolForLogWebv1 { get; set; }
}

public class VortexConfig : BaseConfig
{
    // Configuration objects
    public VortexSettingsConfig Settings { get; set; }
    public XrlScanUtil XrlUtility { get; set; }
    
    [XmlIgnore]
    public ManagedEtxManifest EtxEvents { get; set; }

    private const bool _requireNpdb = true;

    public VortexConfig()
        : base(Config.ComponentName)
    {
    }

    /// <summary>
    /// Loads config from the NPDB. Will not throw an exception.
    /// </summary>
    /// <returns>Config object if successful, null if not.</returns>
    protected override void LoadFromNpdb(ConfigInstance config)
    {
        Trace.Normal("VortexConfig: Loading config from NPDB");

        IInterfaceInfo iiHttp;
        IInterfaceInfo iiUdp;
        try
        {
            iiHttp = config.GetInterface(Interface.vortexfd);
            iiUdp = config.GetInterface(Interface.vortexfd_udp);
        }
        catch (Exception e)
        {
            Trace.Error("Unable to load interface settings config from NPDB: {0}", e.Message);
            Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_NPDB, e,
                        "Error while loading interface settings configuration from NPDB. Service will attempt local config.");
            if (_requireNpdb)
                throw;
        }

        try
        {
            if (Settings == null)
            {
                Settings = new VortexSettingsConfig();
            }

            Settings.ComponentName = config.ComponentName;
            Settings.HttpPort = iiHttp.Port;
            Settings.HttpPrefix = iiHttp.VDir;
            Settings.UdpPort = iiUdp.Port;
            Settings.MaxIOThreads = config.GetIntSetting(Setting.vortex_maxIoThreads);
            Settings.MinIOThreads = config.GetIntSetting(Setting.vortex_minIoThreads);
            Settings.MaxWorkerThreads = config.GetIntSetting(Setting.vortex_maxWorkerThreads);
            Settings.MinWorkerThreads = config.GetIntSetting(Setting.vortex_minWorkerThreads);
            Settings.RetrieveSgInfoForUnknownEvents = config.GetBoolSetting(Setting.vortex_retrieveSgInfoForUnknownEvents);
            Settings.DisableAllSgInfoLookups = false;
            Settings.UdpReceiveBufferSize = config.GetIntSetting(Setting.vortex_udpReceiveBufferSize);
            Settings.NumOverlappedIoOperations = config.GetIntSetting(Setting.vortex_numOverlappedIoOperations);
            Settings.MaxWorkerThreadLatencyMs = config.GetIntSetting(Setting.vortex_maxWorkerThreadLatencyMs);
            Settings.MaxWorkItemQueueSize = config.GetIntSetting(Setting.vortex_maxWorkItemQueueSize);
            Settings.AlwaysUseWorkerThread = config.GetBoolSetting(Setting.vortex_alwaysUseWorkerThread);
            Settings.UnknownEventHeaderVersion = config.GetIntSetting(Setting.vortex_unknownEventHeaderVersion);
            Settings.CategoriesAllowedThroughIFLC = config.GetMultiSetting(MultiSetting.vortex_categoriesAllowedThroughIFLC);
            Settings.P3PForLogWebv1 = config.GetSetting(Setting.vortex_logweb_v1_p3p);
            Settings.ProducerSymbolForLogWebv1 = config.GetSetting(Setting.vortex_logweb_v1_producer);
        }
        catch (Exception e)
        {
            Trace.Error("Unable to load settings config from NPDB: {0}", e.Message);
            Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_NPDB, e,
                        "Error while loading settings configuration from NPDB. Service will attempt local config.");
            if (_requireNpdb)
                throw;
        }

        try
        {
            if (null == EtxEvents)
            {
                EtxEvents = new ManagedEtxManifest(ProducerFetchMode.Normalized);
                EtxEvents.ManifestReset += OnEtxManifestReset;
                EtxEvents.ManifestUpdate += OnEtxManifestUpdate;
                EtxEvents.ManifestError += OnEtxManifestError;
            }
        }
        catch (Exception e)
        {
            Trace.Error("Unable to load ETX config from NPDB: {0}", e.Message);
            Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_NPDB, e,
                        "Error while loading ETX configuration from NPDB. Service will attempt local config. " +
                        "This may indicate a corrupt ETX manifest and should be corrected.");
            // @@@ Hmm, was this a manifest formatting error or an NPDB connectivity 
            // error? Let's assume the former -- the other NPDB accesses in this function 
            // will determine the latter.
            throw;  // we need our manifests. a blank one is ok, but errors are not.
        }

        try
        {
            if (XrlUtility == null)
            {
                try
                {
                    XrlUtility = new XrlScanUtil(
                        Config.Server,
                        iiHttp.VSite,
                        iiHttp.VDir);
                }
                catch (Exception e)
                {
                    Trace.Error("XrlScanUtil: {0}", e.ToString());
                    XrlUtility = new XrlScanUtil();
                    throw;
                }
            }
            // XrlScanUtil manages reloading itself
        }
        catch (Exception e)
        {
            Trace.Error("Unable to load XRL config from NPDB: {0}", e.Message);
            Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_NPDB, e,
                        "Error while loading XRL configuration from NPDB. Service will attempt local config.");
            if (_requireNpdb)
                throw;
        }

    }

    private bool OnEtxManifestError(ManagedEtxManifest manifest, Exception e)
    {
        Trace.High("VortexConfig: Error Etx manifest, an error was encountered while updating the manifest: {0}", e);

        return false;
    }

    private void OnEtxManifestUpdate(ManagedEtxManifest manifest, DateTime originalProducerTimestamp, DateTime originalEventTimestamp)
    {
        Trace.Normal("VortexConfig: Updated Etx manifest, {0} producers, newest producer timestamp={1} --> {2}, newest event timestamp={3} --> {4}",
            manifest.CurrentManifest.Producers.Count,
            originalProducerTimestamp,
            manifest.NewestProducerTimestamp,
            originalEventTimestamp,
            manifest.NewestEventTimestamp);
    }

    private void OnEtxManifestReset(ManagedEtxManifest manifest)
    {
        Trace.Normal("VortexConfig: Initialized Etx manifest, {0} producers, newest producer timestamp={1}, newest event timestamp={2}",
            manifest.CurrentManifest.Producers.Count,
            manifest.NewestProducerTimestamp,
            manifest.NewestEventTimestamp);
    }

    /// <summary>
    /// Loads config from an XML file. Will not throw an exception.
    /// </summary>
    /// <param name="inputFilename"></param>
    /// <returns>Config object if successful, null if not</returns>
    protected override void LoadFromXml(XmlReader reader)
    {
        Trace.Normal("VortexConfig: Loading config from XML");
        XmlSerializerNamespaces xsn = new XmlSerializerNamespaces();
        xsn.Add(String.Empty, String.Empty);
        XmlSerializer serializer = new XmlSerializer(typeof(VortexConfig));

        object o = serializer.Deserialize(reader);
        VortexConfig vc = (VortexConfig)o;

        if (Settings == null)
        {
            Settings = new VortexSettingsConfig();
        }
        if (XrlUtility == null)
        {
            XrlUtility = new XrlScanUtil();
        }

        if (vc.Settings != null)
        {
            this.Settings.ComponentName = vc.Settings.ComponentName ?? this.Settings.ComponentName;
            this.Settings.HttpPort = vc.Settings.HttpPort ?? this.Settings.HttpPort;
            this.Settings.HttpPrefix = vc.Settings.HttpPrefix ?? this.Settings.HttpPrefix;
            this.Settings.UdpPort = vc.Settings.UdpPort ?? this.Settings.UdpPort;
            this.Settings.MaxIOThreads = vc.Settings.MaxIOThreads ?? this.Settings.MaxIOThreads;
            this.Settings.MinIOThreads = vc.Settings.MinIOThreads ?? this.Settings.MinIOThreads;
            this.Settings.MaxWorkerThreads = vc.Settings.MaxWorkerThreads ?? this.Settings.MaxWorkerThreads;
            this.Settings.MinWorkerThreads = vc.Settings.MinWorkerThreads ?? this.Settings.MinWorkerThreads;
            this.Settings.RetrieveSgInfoForUnknownEvents = vc.Settings.RetrieveSgInfoForUnknownEvents ?? this.Settings.RetrieveSgInfoForUnknownEvents;
            this.Settings.DisableAllSgInfoLookups = vc.Settings.DisableAllSgInfoLookups ?? this.Settings.DisableAllSgInfoLookups;
            this.Settings.UdpReceiveBufferSize = vc.Settings.UdpReceiveBufferSize ?? this.Settings.UdpReceiveBufferSize;
            this.Settings.NumOverlappedIoOperations = vc.Settings.NumOverlappedIoOperations ?? this.Settings.NumOverlappedIoOperations;
            this.Settings.MaxWorkerThreadLatencyMs = vc.Settings.MaxWorkerThreadLatencyMs ?? this.Settings.MaxWorkerThreadLatencyMs;
            this.Settings.MaxWorkItemQueueSize = vc.Settings.MaxWorkItemQueueSize ?? this.Settings.MaxWorkItemQueueSize;
            this.Settings.AlwaysUseWorkerThread = vc.Settings.AlwaysUseWorkerThread ?? this.Settings.AlwaysUseWorkerThread;
            this.Settings.UnknownEventHeaderVersion = vc.Settings.UnknownEventHeaderVersion ?? this.Settings.UnknownEventHeaderVersion;
            this.Settings.CategoriesAllowedThroughIFLC = vc.Settings.CategoriesAllowedThroughIFLC ?? this.Settings.CategoriesAllowedThroughIFLC;
        }

        if (vc.XrlUtility != null)
        {
            this.XrlUtility.Merge(vc.XrlUtility);
        }
    }

    /// <summary>
    /// Serializes a VortexConfig to an XML file. Will not throw an exception.
    /// </summary>
    /// <param name="outputFilename"></param>
    /// <param name="vc"></param>
    protected override void SaveToXml(XmlWriter writer)
    {
        Trace.Normal("VortexConfig: Saving config to XML");
        XmlSerializerNamespaces xsn = new XmlSerializerNamespaces();
        xsn.Add(String.Empty, String.Empty);
        XmlSerializer serializer = new XmlSerializer(typeof(VortexConfig));

        serializer.Serialize(writer, this, xsn);
    }

}

}  // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\InputEventMediator.cs ===
// InputEventMediator.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Hooks up the event providers and event consumers
// 
// Author: kgoodier 10/2009
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.server.vortex.cake;

namespace xonline.server.vortex
{

    /// <summary>
    /// This is a mid-level consumer AND provider of events. It provides a wrapper in front 
    /// of the transport-level event providers and refines the events received from them.
    /// It then provides a single interface for providing these multiplexed events to 
    /// the next consumer.
    /// </summary>
    public class InputEventMediator
    {
        // Transport-level inputs
        private HttpInput           _HttpInputProvider;
        private UdpInput            _UdpInputProvider;

        // For rounding up stats
        private Timer               _ReportTimer;
        private DateTime            _LastReportTime;

        // ----------------------------------------------------------------------------------
        // Constructor
        // ----------------------------------------------------------------------------------
        public InputEventMediator()
        {
            VortexSettingsConfig vc = VortexConfig.Instance.Settings;

            _HttpInputProvider = new HttpInput(vc.HttpPort ?? 0, vc.HttpPrefix);
            _UdpInputProvider = new UdpInput(vc.UdpPort ?? 0);

            _LastReportTime = DateTime.Now;
            _ReportTimer = new Timer(new TimerCallback(ReportTimerCallback), null, 1000, 1000);

            // Event callbacks
            _HttpInputProvider.EventReceived += new EventReceivedHandler(OnEventReceived);
            _UdpInputProvider.EventReceived += new EventReceivedHandler(OnEventReceived); 

            VortexConfig.OnVortexSettingsChanged += new VortexSettingsChanged(OnVortexSettingsChanged);
            VortexConfig.OnVortexSettingsChanged += config => DynamicallyConfiguredAdapters.NotifyConfigurationChange(config.EventIngestion);

            // Load settings
            DoConfiguration();
        }

        private void OnVortexSettingsChanged(VortexConfig vc)
        {
            Trace.Normal("InputEventMediator::OnVortexSettingsChanged() Reloading...");
            DoConfiguration();
            Trace.Normal("InputEventMediator::OnVortexSettingsChanged() Done.");
        }

        private void DoConfiguration()
        {
            VortexSettingsConfig vc = VortexConfig.Instance.Settings;

            if (vc.MaxIOThreads != null && vc.MaxWorkerThreads != null)
            {
                ThreadPool.SetMaxThreads(vc.MaxWorkerThreads ?? 0, vc.MaxIOThreads ?? 0);
            }
            if (vc.MinIOThreads != null && vc.MinWorkerThreads != null)
            {
                ThreadPool.SetMinThreads(vc.MinWorkerThreads ?? 0, vc.MinIOThreads ?? 0);
            }
        }

        private void ReportTimerCallback(object data)
        {
            // Do it for real
            int workerThreads;
            int ioThreads;

            // Available
            ThreadPool.GetAvailableThreads(out workerThreads, out ioThreads);
            VortexCounters.Current.InputIOThreadsAvailable.RawValue = (long)ioThreads;
            VortexCounters.Current.InputWorkerThreadsAvailable.RawValue = (long)workerThreads;

            // Max
            ThreadPool.GetMaxThreads(out workerThreads, out ioThreads);
            VortexCounters.Current.InputIOThreadsMax.RawValue = (long)ioThreads;
            VortexCounters.Current.InputWorkerThreadsMax.RawValue = (long)workerThreads;

            // Min
            ThreadPool.GetMinThreads(out workerThreads, out ioThreads);
            VortexCounters.Current.InputIOThreadsMin.RawValue = (long)ioThreads;
            VortexCounters.Current.InputWorkerThreadsMin.RawValue = (long)workerThreads;

        }

        public void Start()
        {
            _HttpInputProvider.Start();
            _UdpInputProvider.Start();
        }

        public void Suspend()
        {
            _HttpInputProvider.Suspend();
            _UdpInputProvider.Suspend();
        }

        public void Stop()
        {
            _HttpInputProvider.Stop();
            _UdpInputProvider.Stop();
        }

        // ----------------------------------------------------------------------------------
        // OnEventReceived - called by the lower level input providers whenever an event
        // comes in.
        // ----------------------------------------------------------------------------------
        private void OnEventReceived(object sender, EventReceivedArgs args)
        {
            VeiEventDispatcher.InputDispatcher.DispatchEvent(args.Reader, args.Payload);
        }

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\fd\XrlScanUtil.cs ===
// XrlScanUtil.cs
//
// Copyright (c) 2010 Microsoft Corporation. All Rights Reserved.
//
// Managed utilities for replacing xrlscan functionality.
// 
// Author: kgoodier 5/2010
//

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.service;
using xonline.common.utilities2;

using XrlDictionary = xonline.common.utilities2.SerializableDictionary<string, xonline.server.vortex.fd.XrlInfo>;

namespace xonline.server.vortex.fd
{

    public class XrlScanUtil
    {
        private string _serverName;
        private string _vsite;
        private string _vdir;
        
        private XrlDictionary _xrlMappings;

        public XrlScanUtil()
        {
            // Used when deserialzing from xml
            _xrlMappings = new XrlDictionary(StringComparer.OrdinalIgnoreCase); 
        }

        public XrlScanUtil(string serverName, string vsite, string vdir)
        {
            _serverName = serverName;
            _vsite = vsite;
            _vdir = vdir;

            Config.XrlMappingsChange += new XrlMappingsChangeEventHandler(Config_XrlMappingsChange);
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

            _xrlMappings = new XrlDictionary(StringComparer.OrdinalIgnoreCase); 
            LoadXrls();
        }

        // Exposed only for XML serialization, please don't use.
        public SerializableDictionary<string, XrlInfo> XrlMappings
        {
            get
            {
                return _xrlMappings;
            }
            set
            {
                _xrlMappings = value;
            }
        }

        public bool TryValidateRequest(HttpContextAdapter ctx)
        {
            // since vortex no longer relies on xrl virtual interface mappings
            // path specific validation will not be available - validation will
            // be done against hard coded upper bounds

            if (ctx.Request.ContentLength > 10000000)
            {
                return false;
            }

            if (ctx.Request.Url.Query != null &&
                ctx.Request.Url.Query.Length > 2000)
            {
                return false;
            }

            return true;
        }

        private void Config_XrlMappingsChange(object sender, EventArgs e)
        {
            try
            {
                LoadXrls();
            }
            catch (Exception ex)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_XRL_MAPPINGS, ex,
                    "Unexpected error while calling or reading p_xrlscan_get_valid_xrls. Aborting reload.");
            }

        }

        private void LoadXrls()
        {
            // Note: case-insensitive
            XrlDictionary newXrlMappings = new XrlDictionary(StringComparer.OrdinalIgnoreCase);

            using (SqlConnection connection = new SqlConnection(Config.NpdbConnectionString))
            {
                using (SqlCommand command = connection.CreateCommand())
                {
                    command.CommandText = "p_xrlscan_get_valid_xrls";
                    command.CommandType = CommandType.StoredProcedure;

                    command.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = _serverName;
                    command.Parameters.Add("@vc_vsite", SqlDbType.NVarChar).Value = _vsite;
                    command.Parameters.Add("@vc_vdir", SqlDbType.NVarChar).Value = _vdir;

                    connection.Open();

                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        int ordXrl = reader.GetOrdinal("vc_xrl");
                        int ordMaxUrl = reader.GetOrdinal("i_max_url_length");
                        int ordMaxContent = reader.GetOrdinal("i_max_content_length");
                        int ordMaxQuery = reader.GetOrdinal("i_max_query_string_length");
                        int ordAllowText = reader.GetOrdinal("ti_allow_text_xml_type");
                        int ordSgInfo = reader.GetOrdinal("ti_dont_get_sg_info");
                        int ordNoExactMatch = reader.GetOrdinal("ti_allow_no_exact_match");
                        int ordPort = reader.GetOrdinal("i_port");
                        int ordBlockLimited = reader.GetOrdinal("ti_block_limited_pc_account");

                        while (reader.Read()) 
                        {

                            XrlInfo xi = new XrlInfo()
                            {
                                Xrl = reader.GetString(ordXrl),
                                MaxUrlLength = reader.GetInt32(ordMaxUrl),
                                MaxContentLength = reader.GetInt32(ordMaxContent),
                                MaxQueryStringLength = reader.GetInt32(ordMaxQuery),
                                AllowTextXmlType = reader.GetByte(ordAllowText) > 0,
                                DontGetSgInfo = reader.GetByte(ordSgInfo) > 0,
                                AllowNoExactMatch = reader.GetByte(ordNoExactMatch) > 0,
                                Port = reader.GetInt32(ordPort),
                                BlockLimitedPcAccount = reader.GetByte(ordBlockLimited) > 0,
                            };

                            string key = xi.Xrl + ":" + xi.Port;
                            newXrlMappings[key] = xi;
                        }
                    } // using
                } // using
            } // using
            
            _xrlMappings = newXrlMappings;
        }

        public void Merge(XrlScanUtil xrlScanUtil)
        {
            XrlDictionary localXrlMappings = _xrlMappings;
            foreach (XrlInfo xi in xrlScanUtil._xrlMappings.Values)
            {
                string key = xi.Xrl + ":" + xi.Port;
                localXrlMappings[key] = xi;
            }
        }

        private void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string sResponse = "";
                switch (args.Command.ToLower())
                {
                    case "list_mappings":
                        sResponse = ListMappings();
                        args.Handled = true;
                        break;
                    case "reload_mappings":
                        LoadXrls();
                    sResponse = "Done. Loaded " + _xrlMappings.Count + " mappings.";
                        args.Handled = true;
                        break;
                    case "help":
                        sResponse = @"
XrlScanUtil:
  list_mappings   : Lists XRL mappings
  reload_mappings : Force reload of XRL mappings from database
";
                        sResponse += args.Command;
                        args.Handled = true;
                        break;
                }
                XomControlConnection.SendMessage(sResponse, args.RequestId);
            }
            catch (Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public string ListMappings()
        {
            XrlDictionary localXrlMappings = _xrlMappings;
            StringBuilder sb = new StringBuilder(500);
            foreach (XrlInfo xrlinfo in localXrlMappings.Values)
            {
                sb.AppendFormat("{0}\n Port:{1}\tExact:{2}\tSGInfo:{3}\tBlockLimited:{4}\ttext/xml:{5}\n\n",
                    xrlinfo.Xrl,
                    xrlinfo.Port,
                    !xrlinfo.AllowNoExactMatch,
                    !xrlinfo.DontGetSgInfo,
                    xrlinfo.BlockLimitedPcAccount,
                    xrlinfo.AllowTextXmlType);  
            }
            return sb.ToString();
        }

    }

    public class XrlInfo
    {
        public string Xrl;
        public int MaxUrlLength;
        public int MaxContentLength;
        public int MaxQueryStringLength;
        public bool AllowTextXmlType;
        public bool DontGetSgInfo;
        public bool AllowNoExactMatch;
        public int Port;
        public bool BlockLimitedPcAccount;

    }
 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\Block_StreamInsight.cs ===
// 
// Block_StreamInsight.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Healthblock for reporting diagnostic information on StreamInsight.
// 
// Author: kgoodier 11/2009
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;

using xonline.common.config;
using xonline.common.health;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Diagnostics;

namespace xonline.server.vortex
{

// --------------------------------------------------------------------------------------
// StreamInsight - 
//
// PARAMETERS:
// 
// --------------------------------------------------------------------------------------
internal class StreamInsightHealthBlock : IHealthBlock
{
    public ResourceTypeEnum ResourceType 
    { 
        get { return ResourceTypeEnum.Local; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        StreamInsightReport myReport = new StreamInsightReport();
        report.ExtendedReport = myReport;


        StreamInsightMediator si = VortexSvc.Instance.StreamInsightInstance;
        if (si == null)
        {
            report.ErrorDetails = "StreamInsight is not running in this instance.";
            report.HealthStatus = HealthStatusEnum.Green;
            return;
        }

        BuildDiagnosticView(si.GetDiagnosticView("cep:/Server/EventManager"), myReport.EventManager);
        BuildDiagnosticView(si.GetDiagnosticView("cep:/Server/PlanManager"), myReport.PlanManager);

        foreach (Uri queryName in si.QueryNames)
        {
            List<NameValuePair> queryProps = new List<NameValuePair>();
            queryProps.Add(new NameValuePair("QueryName", queryName.ToString()));
            BuildDiagnosticView(si.GetDiagnosticView(queryName.ToString()), queryProps);
            myReport.Queries.Add(queryProps);
        }

        report.HealthStatus = HealthStatusEnum.Green;
    }

    private void BuildDiagnosticView(DiagnosticView diagview, List<NameValuePair> outList)
    {
        if (diagview == null)
        {
            outList.Add(new NameValuePair("Error", "Diagnostic view unavailable"));
            return;
        }
        
        foreach (KeyValuePair<string, object> diagprop in diagview)
        {
            outList.Add(new NameValuePair(diagprop.Key.ToString(), diagprop.Value.ToString()));
        }
    }


}

public class StreamInsightReport : IExtendedHealthReport
{
    public List<NameValuePair> EventManager;
    public List<NameValuePair> PlanManager;
    public List<List<NameValuePair>> Queries;

    public StreamInsightReport()
    {
        EventManager = new List<NameValuePair>();
        PlanManager = new List<NameValuePair>();
        Queries = new List<List<NameValuePair>>();
    }
}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\PerfCounterHelpers.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.server.vortex
{
    
    public class VortexMessageCountersHelper
    {
        private VortexMessageCounters[] _TransportMessageCounters;

        public VortexMessageCountersHelper(string transportType)
        {
            if (!String.IsNullOrEmpty(transportType))
            {
                _TransportMessageCounters = new VortexMessageCounters[2];
                _TransportMessageCounters[0] = VortexMessageCounters.Current;
                _TransportMessageCounters[1] = VortexMessageCounters.Current[transportType];
            }
        }

        /// <summary>
        /// Call this at the very beginning of receiving a message. Assists with perf counters.
        /// </summary>
        public void OnMessageReceived()
        {
            try
            {
                if (_TransportMessageCounters == null)
                {
                    return;
                }

                foreach (VortexMessageCounters instance in _TransportMessageCounters)
                {
                    instance.IncomingMessagesInProgress.Increment();
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_PERFCOUNTER_FAILURE, e,
                            "Error incrementing perf counters.");
            }
        }

        /// <summary>
        /// Call this once the incoming message has been parsed and the size is understood. Assists with perf counters.
        /// </summary>
        /// <param name="messageSizeInBytes">Approximate size of the received message or messages.</param>
        /// <param name="numEvents">For messages with multiple events, specify the count here (batched messages).</param>
        public void OnMessageParsed(int messageSizeInBytes, int numEvents)
        {
            try
            {
                if (_TransportMessageCounters == null)
                {
                    return;
                }

                foreach (VortexMessageCounters instance in _TransportMessageCounters)
                {
                    instance.IncomingBytesRate.IncrementBy(messageSizeInBytes);
                    instance.IncomingBytesTotal.IncrementBy(messageSizeInBytes);
                    instance.IncomingMessagesRate.Increment();
                    instance.IncomingMessagesTotal.Increment();
                    instance.IncomingEventsRate.IncrementBy(numEvents);
                    instance.IncomingEventsTotal.IncrementBy(numEvents);
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_PERFCOUNTER_FAILURE, e,
                            "Error incrementing perf counters.");
            }
        }

        /// <summary>
        /// Call this at the very end of receiving a message, after making the callback. Assists with perf counters.
        /// </summary>
        /// <remarks>
        /// It is very important that this is called if OnMessageReceived() was also called, or else the perf counter
        /// value will drift into meaninglessness. A try/finally block would be a good idea.
        /// </remarks>
        public void OnMessageFinished()
        {
            try
            {
                if (_TransportMessageCounters == null)
                {
                    return;
                }

                foreach (VortexMessageCounters instance in _TransportMessageCounters)
                {
                    instance.IncomingMessagesInProgress.Decrement();
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_PERFCOUNTER_FAILURE, e,
                            "Error decrementing perf counters."); 
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\PerfCounters.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.server.vortex
{
    [XomPerformanceCounterCategoryAttr( "Vortex Svc", "Xbox Live Vortex Service - Data collection for the masses" )]
    public class VortexCounters : XomPerformanceCounterCategory
    {
        public VortexCounters() : base(true)
        {
        }
        
        static public VortexCounters Current = new VortexCounters();
        
        [XomPerformanceCounterAttr(
            "Input I/O Threads - Available", 
            "Number of available threadpool threads. Represents the difference between the max number of threads and the number currently active.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputIOThreadsAvailable;

        [XomPerformanceCounterAttr(
            "Input I/O Threads - Max", 
            "Maximum number of threadpool threads ever available", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputIOThreadsMax;
        
        [XomPerformanceCounterAttr(
            "Input I/O Threads - Min", 
            "Minimum number of threadpool threads kept alive by the system", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputIOThreadsMin;

        [XomPerformanceCounterAttr(
            "Input Worker Threads - Available",
            "Number of available threadpool threads. Represents the difference between the max number of threads and the number currently active.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputWorkerThreadsAvailable;

        [XomPerformanceCounterAttr(
            "Input Worker Threads - Max",
            "Maximum number of threadpool threads ever available",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputWorkerThreadsMax;

        [XomPerformanceCounterAttr(
            "Input Worker Threads - Min",
            "Minimum number of threadpool threads kept alive by the system",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputWorkerThreadsMin;

        [XomPerformanceCounterAttr(
            "Incoming Message Queue",
            "Number of messages waiting in the input adapter's queue",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IncomingMessageQueue;

        [XomPerformanceCounterAttr(
            "Messages Dropped Rate - Too Old",
            "Rate of incoming messages dropped because they were older than the last enqueued CTI",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MessagesDroppedRateTooOld;


        [XomPerformanceCounterAttr(
            "Messages Dropped Total - Too Old",
            "Number of incoming messages dropped because they were older than the last enqueued CTI",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MessagesDroppedTotalTooOld;

        [XomPerformanceCounterAttr(
            "Intermediate Queue Messages Dropped Total",
            "Number of queue messages dropped because they could not be processed fast enough",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InputQueueEvictions;

        [XomPerformanceCounterAttr(
            "Query Output Messages Dropped Total",
            "Number of StreamInsight Query output events that are dropped due to no EventSinks being associated with the Query",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter UndispatchedOutputEvents;

        [XomPerformanceCounterAttr(
            "Query Output Message Dispatch Failures Total",
            "Number of StreamInishgt Query output events that failed to be dispatched through its associated EventSink",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter OuputEventDispatchFailures;

        [XomPerformanceCounterAttr(
            "Invalid Field References Total",
            "Number of references to invalid EventBuilder or SinkBuilder fields",
            PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter InvalidFieldAccess;
    }

    [XomPerformanceCounterCategoryAttr( "Vortex Svc - Messages", "Xbox Live Vortex Service - Data collection for the masses, broken down by incoming and outgoing messages per transport type" )]
    public class VortexMessageCounters : XomPerformanceCounterCategory
    {
        // Note:
        //
        // These perf counters are instanced by the transport type.
        //

        public VortexMessageCounters() : base(true)
        {
        }
        
        public virtual VortexMessageCounters this[string transport]
        {
            get
            {
                return (VortexMessageCounters) GetInstance(transport);
            }
        }

        static public VortexMessageCounters Current = new VortexMessageCounters();

        [XomPerformanceCounterAttr(
            "Incoming Bytes Rate", 
            "Number of incoming bytes per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter IncomingBytesRate;

        [XomPerformanceCounterAttr(
            "Incoming Bytes Total", 
            "Number of incoming bytes total", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IncomingBytesTotal;

        [XomPerformanceCounterAttr(
            "Incoming Events Rate",
            "Number of incoming events per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter IncomingEventsRate;

        [XomPerformanceCounterAttr(
            "Incoming Events Total",
            "Number of incoming events total",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IncomingEventsTotal;

        [XomPerformanceCounterAttr(
            "Incoming Messages Rate", 
            "Number of incoming request messages per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter IncomingMessagesRate;

        [XomPerformanceCounterAttr(
            "Incoming Messages Total", 
            "Number of incoming request messages", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IncomingMessagesTotal;

        [XomPerformanceCounterAttr(
            "Incoming Messages In Progress", 
            "Number of incoming request messages currently being serviced", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter IncomingMessagesInProgress;


    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\InputHttp.cs ===
// InputHttp.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Provides HTTP input for the Vortex data processor. Does not require IIS.
// 
// Author: kgoodier 10/2009
//

using System;
using System.Net;
using System.Collections.Generic;
using System.IO;
using System.Web;
using System.Linq;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

using xonline.server.vortex.cake;

namespace xonline.server.vortex
{

/// <summary>
/// HTTP transport for incoming messages. Accepts both query-string based GET requests and
/// content-based POST requests, such as LogString2 and LogString, respectively. 
/// </summary>
public class HttpInput : BaseEventProvider
{
    // ----------------------------------------------------------------------------------
    // HttpInput constructor
    // ----------------------------------------------------------------------------------
    public HttpInput(int port, string path) 
        : base("Http")
    {
        _NumRequestsPending = 0;
        _fSuspended = false;
        _Listener = new HttpListener();
        AddUrl(port, path);
    }

    public override void Start()
    {
        base.Start();
        if (_fSuspended)
        {
            _fSuspended = false;
        }
        else
        {
            _Listener.Start();
            BeginNextRequest();
        }
    }

    public override void Suspend()
    {
        base.Suspend();
        _fSuspended = true;
    }

    public override void Stop()
    {
        base.Stop();
        _Listener.Stop();
        _fSuspended = false;
    }


    // ----------------------------------------------------------------------------------
    // AddUrl - add base url for the HttpListener. Something like "http://*:80/vortex" is 
    // what this adds. The path param should be "/vortex" in this case.
    // ----------------------------------------------------------------------------------
    public void AddUrl(int port, string path)
    {
        if (!path.StartsWith("/"))
        {
            path = "/" + path;
        }
        string url = String.Format("http://*:{0}{1}/", port, path);
        Trace.Normal("Vortex is listening at {0}", url);
        _Listener.Prefixes.Add(url);
    }


    // ----------------------------------------------------------------------------------
    // ListenerCallback - incoming http request callback
    // ----------------------------------------------------------------------------------
    private void ListenerCallback(IAsyncResult result)
    {
        try
        {
            System.Threading.Interlocked.Decrement(ref _NumRequestsPending);

            // Perf counters, won't throw
            MessageCounters.OnMessageReceived();

            CallbackData        cd = (CallbackData)result.AsyncState;
            HttpListenerContext context;

            // Fire off new BeginGetContext; this MUST happen, so do it before any 
            // possibility of an exception.
            // @@@ we should handle any thrown exceptions here. It is critical that we 
            // call BeginGetContext(), or else our httplistener will die.
            BeginNextRequest();

            // Get context, may throw.
            context = _Listener.EndGetContext(result);

            // Go do the hard work. Won't throw.
            ProcessRequest(context);
        }
        catch (Exception e)
        {
            // Must handle all exceptions, even though we can't do much
            Xom.NtEvent(XEvent.Id.VORTEX_HTTPLISTENER_CALLBACK, e,
                        "Generic error while handling the HttpListener callback.");
        }
        finally
        {
            MessageCounters.OnMessageFinished();
        }

    }

    private void ProcessRequest(HttpListenerContext context)
    {
        try
        {
            Uri url = context.Request.Url;
            int contentLength = (int)context.Request.ContentLength64;
            string eventId;

            // url.Segments is a string array like so:
            //   [0] = "/"
            //   [1] = "vortex/"
            //   [2] = "logstring2.aspx"
            // and so on
            if (url.Segments.Length == 3)
            {
                eventId = url.Segments[2].ToLower();
            }
            else
            {
                eventId = url.LocalPath.ToLower();
            }

            // We'll create a new GenericEvent and fill it out the best we can. Later 
            // layers should replace these values with more accurate ones, if they 
            // can.
            if (context.Request.HttpMethod == "GET")
            {
                // Presumably a "GET". No binary data here. Just use the URL as the input.

                // Kind of hard and misleading to calculate the # of bytes for an http request.
                // Do we include the entire packet?  Just the "payload"?  What about POST bodies?
                // I say we include the length of the query string plus the content-length. 
                // We have no content-length here.
                
                //int messageSizeInBytes = System.Runtime.InteropServices.Marshal.SizeOf(evt);
                //int messageSizeInBytes = 8 + evt.Id.Length + evt.RawPayload.Length;
                int messageSizeInBytes = url.Query.Length;

                if (messageSizeInBytes > 0)
                {
                    MessageCounters.OnMessageParsed(messageSizeInBytes, 1);

                    // Dispatch the event to the cake. LogString2 requests are required to 
                    // have a v1 parameter.
                    var nvc = context.Request.QueryString;
                    if (!String.IsNullOrEmpty(nvc["v1"]))
                    {
                        OnEventReceived(_logString2PayloadReader, context.Request.QueryString);
                    }
                    else
                    {
                        Trace.Error("InputHttp: LogString2 request must have a \"v1\" parameter, aborting this request: " + url.ToString());
                    }
                }
            }
            else
            {
                // Body contains our data. We should read it. And make the callback.


                if (eventId.Contains("logstring.ashx"))
                {
                    StringLogRequest request = new StringLogRequest();
                    request.ReadStream(context.Request.InputStream);
                    if (request.logLinesLength > 0 && !String.IsNullOrEmpty(request.logLines))
                    {
                        string[] lines = request.logLines.Split('\n');
                        MessageCounters.OnMessageParsed(contentLength, lines.Length);

                        lines.ToList().ForEach(e =>
                        {
                            if (!String.IsNullOrEmpty(e))
                            {
                                OnEventReceived(_logStringPayloadReader, e);
                            }
                        });
                    }
                    else
                    {
                        // @@@ xomtrace here
                        Trace.High("InputHttp.ProcessRequest(): Invalid logstring.ashx request");
                    }
                }
                else if (eventId.Contains("logbinary.ashx"))
                {
                    var events = VxProtocol.ReadStream(context.Request.InputStream);
                    MessageCounters.OnMessageParsed(contentLength, events.Count); 
                    events.ForEach(e => OnEventReceived(_vxProtocolPayloadReader, e));
                }
                else
                {
                    // @@@ xomtrace here
                    Trace.High("InputHttp.ProcessRequest(): Unrecognized request. Method: {0}, URL: {1}",
                               context.Request.HttpMethod, url.ToString());
                }
            }

            WriteHttpResponse(context, (int)HttpStatusCode.OK);
        }
        catch (Exception e)
        {
            try
            {
                Xom.NtEvent(XEvent.Id.VORTEX_HTTPLISTENER_PROCESSREQUEST, e,
                            "Unexpected runtime error while processing HTTP request. Error returned to client.");

                // @@@ meh?  only in dev environments?  remember, this is going to a client. Needs to be XRLy.
                //WriteHttpResponse(context, (int)HttpStatusCode.BadRequest, "Vortex Error", e.ToString());
                WriteHttpResponse(context, (int)HttpStatusCode.BadRequest);
            }
            catch { };
        }
    }


    // ----------------------------------------------------------------------------------
    // PRIVATE STUFF HERE
    // ----------------------------------------------------------------------------------

    private static LogString2PayloadReader  _logString2PayloadReader = new LogString2PayloadReader();
    private static LogStringPayloadReader   _logStringPayloadReader = new LogStringPayloadReader();
    private static VortexProtocolPayloadReader _vxProtocolPayloadReader = new VortexProtocolPayloadReader();

    private HttpListener                    _Listener;
    private bool                            _fSuspended;
    private int                             _NumRequestsPending;

    public int NumRequestsPending
    {
        get { return _NumRequestsPending; }
    }

    // Used for asynchronous I/O in HttpListener stuff 
    private class CallbackData
    {
        //public HttpInput httpInput;
        public HttpListener Listener;
    }

    // ----------------------------------------------------------------------------------
    // BeginNextRequest
    // ----------------------------------------------------------------------------------
    private void BeginNextRequest()
    {
        try
        {
#if true
            // Note: for more info on async calls and alternate implementations, see;
            // http://msdn.microsoft.com/en-us/library/2e08f6yc.aspx

            // Async
            CallbackData cd = new CallbackData();
            cd.Listener = _Listener;
            IAsyncResult result = _Listener.BeginGetContext(new AsyncCallback(ListenerCallback), cd);

            System.Threading.Interlocked.Increment(ref _NumRequestsPending);
            // don't need to save result, i suppose
#else
            // Synchronous
            while (true)
            {
                HttpListenerContext context = _Listener.GetContext();
                ProcessRequest(context);
            }

#endif
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.VORTEX_HTTPLISTENER_NEXTREQUEST, e,
                        "Error firing off next request listener, this is fatal. Pending listeners: {0}",
                        NumRequestsPending);
            throw;
        }
        
        
    }

    // ----------------------------------------------------------------------------------
    // WriteHttpResponse - makes it easier to send responses using the HttpListener
    // ----------------------------------------------------------------------------------
    private static void WriteHttpResponse(
        HttpListenerContext context, 
        int statusCode, 
        string htmlTitle, 
        string htmlBody)
    {
        string responseString = String.Format("<html><head><title>{0}</title></head><body>{1}</body></html>",
                                              htmlTitle, htmlBody);
        byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString);
        context.Response.StatusCode = statusCode;
        context.Response.ContentLength64 = buffer.Length;
        context.Response.OutputStream.Write(buffer, 0, buffer.Length);
        context.Response.OutputStream.Close();
    }
    
    private static void WriteHttpResponse(
        HttpListenerContext context, 
        int statusCode)
    {
        context.Response.StatusCode = statusCode;
        context.Response.ContentLength64 = 0;
        context.Response.OutputStream.Close();
    }



}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\InputUdp.cs ===
// InputUdp.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Provides UDP input for the Vortex data processor. For XomLog 'remote' targets.
// 
// Author: kgoodier 10/2009
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.vortex.cake;

namespace xonline.server.vortex
{

/// <summary>
/// UDP transport for incoming messages. These would typically come from the 'remote' target of
/// XomLog.
/// </summary>
public class UdpInput : BaseEventProvider
{
    // ----------------------------------------------------------------------------------
    // Constructor
    // ----------------------------------------------------------------------------------
    public UdpInput(int port)
        : base("Udp")
    {
        _PayloadReader = new VortexProtocolPayloadReader();
        _UdpClient = new UdpClient(port);
    }

    public override void Start()
    {
        base.Start();
        BeginNextRequest();
    }

    public override void Suspend()
    {
        base.Suspend();
    }

    public override void Stop()
    {
        base.Stop();
        _UdpClient.Close();
    }

    private void BeginNextRequest()
    {
        try
        {
            CallbackData cd = new CallbackData()
            {
                Udp = _UdpClient
            };

            IAsyncResult result = _UdpClient.BeginReceive(new AsyncCallback(ListenerCallback), cd);
            Interlocked.Increment(ref _NumRequestsPending);
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.VORTEX_UDPLISTENER_NEXTREQUEST, e,
                        "Error firing off next request listener, this is fatal. Pending listeners: {0}",
                        NumRequestsPending);
            throw;
        }
    }

    private void ListenerCallback(IAsyncResult result)
    {
        try
        {
            System.Threading.Interlocked.Decrement(ref _NumRequestsPending);

            // Perf counters, won't throw
            MessageCounters.OnMessageReceived();

            CallbackData cd = (CallbackData)result.AsyncState;
            IPEndPoint remoteEP = null;
            byte[] recvBuffer;

            recvBuffer = _UdpClient.EndReceive(result, ref remoteEP);
            BeginNextRequest();

            // Go do the hard work. Won't throw.
            ProcessRequest(recvBuffer);
        }
        catch (Exception e)
        {
            // Must handle all exceptions, even though we can't do much
            // @@@ kgoodier new event id
            Xom.NtEvent(XEvent.Id.VORTEX_UDPLISTENER_CALLBACK, e,
                        "Generic error while handling the HttpListener callback.");
        }
        finally
        {
            MessageCounters.OnMessageFinished();
        }
    }

    private void ProcessRequest(byte[] messageBuffer)
    {
        try
        {
            using (MemoryStream stream = new MemoryStream(messageBuffer))
            {
                var events = VxProtocol.ReadStream(stream);
                MessageCounters.OnMessageParsed(messageBuffer.Length, events.Count);
                events.ForEach(e => OnEventReceived(_PayloadReader, e));
            }
        }
        catch (Exception e)
        {
            try
            {
                Xom.NtEvent(XEvent.Id.VORTEX_UDPLISTENER_PROCESSREQUEST, e,
                            "Unexpected runtime error while processing request.");
            }
            catch { };
        }
    }

    // ----------------------------------------------------------------------------------
    // PRIVATE STUFF HERE
    // ----------------------------------------------------------------------------------

    private UdpClient                       _UdpClient;
    private int                             _NumRequestsPending;
    private VortexProtocolPayloadReader     _PayloadReader;

    public int NumRequestsPending
    {
        get { return _NumRequestsPending; }
    }

    // Used for asynchronous I/O in UdpClient stuff 
    private class CallbackData
    {
        public UdpClient Udp;
    }

}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\StreamInsightCommon.cs ===
// StreamInsightCommon.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Provides common code for integrating StreamInsight with Vortex
// 
// Author: kgoodier 10/2009
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Linq;

using xonline.common.mgmt;
using xonline.common.service;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Linq;

namespace xonline.server.vortex
{
    public class PassthroughEvent
    {
        public DateTime EventTimestamp { get; set; }
        public string Id { get; set; }
        public ulong FlowToken { get; set; }  // only basic types supported
        public string Payload { get; set; }
    }

    public class EventCountEvent
    {
        public string Id { get; set; }
    }

    public class BaseWebInstEvent
    {
        public DateTime Timestamp { get; set; }
        public string Id { get; set; }

        public string PageName { get; set; }    // pageName
        public string AppArea { get; set; }     // v1 - for this event, "Epix"
        public string Events { get; set; }      // events

        public string VisitorId { get; set; }   // vid
        public string GroupId { get; set; }     // v16
        public string FlowToken { get; set; }   // v17
        public string Tier { get; set; }        // v6
    }

    //
    // Output Events
    //

    #region Info
    // Output events, that get created in the LINQ queries, can't have properties - only
    // actual fields seem to be allowed. E.g.,
    //     System.ArgumentException: Argument must be either a FieldInfo or PropertyInfo
    //     at System.Linq.Expressions.Expression.ValidateSettableFieldOrPropertyMember(MemberInfo member, Type& memberType)
    //     at System.Linq.Expressions.Expression.Bind(MemberInfo member, Expression expression)
    //     at Microsoft.ComplexEventProcessing.Linq.SplitGroupUnionSelect.CreateSecondSelectFromMemberInitExpr()
    //     at Microsoft.ComplexEventProcessing.Linq.SplitGroupUnionSelect.Split()
    //     at Microsoft.ComplexEventProcessing.Linq.CEPSelectManyRewriter.Rewriter.VisitSelectMany(Expression sourceExpr, MethodCallExpression methodCallExpr)
    //     at Microsoft.ComplexEventProcessing.Linq.CEPSelectManyRewriter.Rewriter.VisitMethodCall(MethodCallExpression methodCallExpr)
    //     at Microsoft.ComplexEventProcessing.Linq.ExpressionVisitor.Visit(Expression exp)
    //     at Microsoft.ComplexEventProcessing.Linq.ExpressionRewriteBase.Visit(Expression exp)
    //     at Microsoft.ComplexEventProcessing.Linq.CEPSelectManyRewriter.Rewrite(Expression expression, Dictionary`2 expressionsVisited)
    //     at Microsoft.ComplexEventProcessing.Linq.OperatorExpressionRewriter.Rewrite(Expression expression)
    //     at Microsoft.ComplexEventProcessing.Linq.CepStream`1.ToCepExpression()
    //     at Microsoft.ComplexEventProcessing.Linq.CepStream`1.Translate(String application, String queryTemplateName)
    //     at Microsoft.ComplexEventProcessing.Linq.CepStream`1.ToQueryTemplate(String outputStreamName, String applicationName, String queryTemplateName)
    //     at Microsoft.ComplexEventProcessing.Application.CreateQueryTemplate[T](String queryTemplateName, CepStream`1 streamDefinition)
    //     at xonline.server.vortex.StreamInsightMediator.LoadQueryTemplate(Application application, String queryName) in d:\sd\r23\private\server\vortex\svc\StreamInsightMediator.cs:line 286
    //     at xonline.server.vortex.StreamInsightMediator.LoadQuery(Application application, StreamInsightConfigQuery qc) in d:\sd\r23\private\server\vortex\svc\StreamInsightMediator.cs:line 192
    //     at xonline.server.vortex.StreamInsightMediator.CreateQueries() in d:\sd\r23\private\server\vortex\svc\StreamInsightMediator.cs:line 162
    #endregion

    public class EventCountAggregate
    {
        public int TimeSpanInSeconds;
        public long Count;
        public string EventId;
    }

    public class ClickStreamCount
    {
        public int TimeSpanInSeconds;
        public long Count;
        public string AppArea;
        public string PageName;
        public string Events;
    }

    class StreamInsightCommon
    {
        public static void CreateQueryTemplates(Application application)
        {
            const string passthrough = "PassthroughTemplate";
            const string eventCount = "EventTypeCountTemplate";

            var passthroughEvents = CepStream<PassthroughEvent>.Create("PassthroughEvent");
            var eventCountEvents = CepStream<EventCountEvent>.Create("EventCountEvent");
            
            TimeSpan windowSpan;
            windowSpan = TimeSpan.FromSeconds(VortexConfig.Instance.Settings.DefaultEventTypeCountWindowSeconds ?? 10);

            // Passthrough
            var passthroughLinq =
                from e in passthroughEvents
                select e;

            // EventCount
            var eventCountLinq =
                from e in eventCountEvents
                group e by new { EventId = e.Id } into grouping
                from window in grouping.TumblingWindow(windowSpan, WindowOutputPolicy.ClipToWindowEnd)
                select new EventCountAggregate
                {
                    TimeSpanInSeconds = (int)windowSpan.TotalSeconds,
                    Count = window.Count(),
                    EventId = grouping.Key.EventId,
                };


            Trace.Normal("Creating static query template \"{0}\"", passthrough);
            application.CreateQueryTemplate(
                passthrough,
                "Simple passthrough query temlate",
                passthroughLinq);

            Trace.Normal("Creating static query template \"{0}\"", eventCount);
            application.CreateQueryTemplate(
                eventCount, 
                "Count of each event type over a " + windowSpan.TotalSeconds + " second window", 
                eventCountLinq);

        }
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\StreamInsightMediator.cs ===
// StreamInsightMediator.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Manages StreamInsight for the Vortex service.
// 
// Author: kgoodier 10/2009
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Xml;
using System.IO;
using System.Linq;
using System.Text;
using System.ServiceModel;

using xonline.common.service;
using xonline.common.mgmt;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Linq;
using Microsoft.ComplexEventProcessing.Diagnostics;
using Microsoft.ComplexEventProcessing.ManagementService;

namespace xonline.server.vortex
{

public class StreamInsightMediator : IDisposable
{
    private Server              _Server;
    private ServiceHost         _ServiceHost;
    private Application         _Application;
    private object              _QueriesLock;

    public Uri[] QueryNames
    {
        get
        {
            lock (_QueriesLock)
            {
                return _Application.Queries.Select(p => p.Value.Name).ToArray();
            }
        }
    }

    public StreamInsightMediator()
    {
        _QueriesLock = new object();

        Initialize();
    }

    private void Initialize()
    {
        CreateServer();
        CreateApplication("Vortex");
        StreamInsightCommon.CreateQueryTemplates(_Application);
        CreateAdapters();

        // @@@ Maybe this should live elsewhere
        CreateQueries();
    }

    public void Dispose()
    {
        if (_Server != null)
        {
            _Server.Dispose();
        }
    }

    public List<string> QueryList()
    {
        lock (_QueriesLock)
        {
            return _Application.Queries
                .Select(p => p.Value.ShortName.PadRight(20) + ": " + p.Value.Description)
                .ToList();
        }
    }

    #region StreamInsight Query Configuration - imported from tool

    private Query InstantiateQuery(Application app, QueryConfig configInfo)
    {
        Query queryOld;

        lock (_QueriesLock)
        {
            if (_Application.Queries.TryGetValue(configInfo.QueryName, out queryOld))
            {
                queryOld.Stop();
                queryOld.Delete();
            }
        }

        QueryTemplate queryTemplate;
        try
        {
            queryTemplate = _Application.QueryTemplates[configInfo.QueryTemplateShortName];
        }
        catch (KeyNotFoundException e)
        {
            throw new KeyNotFoundException(String.Format(
                "Unable to find query template {0} referenced by query {1}",
                configInfo.QueryTemplateShortName,
                configInfo.QueryName), e);
        }
        QueryBinder queryBinder = new QueryBinder(queryTemplate);

        foreach (var ib in configInfo.InputBindings)
        {
            // Provide good defaults for time generation
            AdvanceTimeGenerationSettings atgs;
            if (ib.TimeAdvanceFrequencyInEvents > 0)
            {
                atgs = new AdvanceTimeGenerationSettings(
                    TimeSpan.FromSeconds(ib.TimeAdvanceFrequencyInEvents ?? 1),
                    TimeSpan.FromSeconds(ib.TimeAdvanceSlackInSeconds ?? 0),
                    true);
            }
            else
            {
                atgs = new AdvanceTimeGenerationSettings(
                    TimeSpan.FromSeconds(ib.TimeAdvanceFrequencyInSeconds ?? 1),
                    TimeSpan.FromSeconds(ib.TimeAdvanceSlackInSeconds ?? 0),
                    true);
            }
            var ats = new AdvanceTimeSettings(atgs, null, AdvanceTimePolicy.Adjust);

            if (string.IsNullOrEmpty(ib.InputQueryName))
            {
                // Hard-coded to CAKE input adapter
                // @@@ Does CAKE input adapter need config? yes. remove later.

                var adapterConfig = new cake.VeiInputAdapterConfig()
                {
                    MaxEventQueueSize = 1000,
                    StreamName = ib.BindToQueryTemplateStreamName,
                    InitialConfig = VortexConfig.Instance.EventIngestion
                };

                InputAdapter inputAdapter = _Application.InputAdapters["VeiInputAdapter"];
                try
                {
                    queryBinder.BindProducer(
                        ib.BindToQueryTemplateStreamName,
                        inputAdapter,
                        adapterConfig,
                        EventShape.Point,
                        ats);
                }
                catch (InvalidOperationException e)
                {
                    if (e.Message.Contains("doesn't have an input stream"))
                    {
                        string inputs = "";
                        queryTemplate.QueryTemplateInputs.Values.ToList().ForEach(i => inputs += i.StreamName.ToString() + " ");
                        string message = String.Format(
                            "Error binding input stream {0} of query {1} to query template {2}. Available input streams: {3}.",
                            ib.BindToQueryTemplateStreamName,
                            configInfo.QueryName,
                            configInfo.QueryTemplateShortName,
                            inputs);
                        throw new InvalidOperationException(message, e);
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            else
            {
                // Hook up to the output of another query
                Query inputQuery;
                inputQuery = _Application.Queries[ib.InputQueryName];

                queryBinder.BindProducer(
                    ib.BindToQueryTemplateStreamName,
                    inputQuery,
                    ats);
            }
        }
        
        if (string.IsNullOrEmpty(configInfo.OutputBinding.OutputPublishedStreamName))
        {
            // Hard-coded to CAKE output adapter
            // @@@ Does CAKE output adapter need config? yes. remove later.

            var adapterConfig = new cake.VeiOutputAdapterConfig()
            {
                QueryName = configInfo.QueryName,
                InitialConfig = VortexConfig.Instance.EventIngestion
            };

            OutputAdapter outputAdapter = _Application.OutputAdapters["VeiOutputAdapter"];

            queryBinder.AddConsumer(
                configInfo.QueryName + " Consumer",
                outputAdapter,
                adapterConfig,
                EventShape.Point,
                StreamEventOrder.ChainOrdered);
        }
        else
        {
            // Publish to a stream name
            // @@@ which override to use??
            queryBinder.BindOutputToPublishedStream(
                EventShape.Point,
                StreamEventOrder.ChainOrdered);
        }

        Query query;

        lock (_QueriesLock)
        {
             query = _Application.CreateQuery(
                configInfo.QueryName,
                configInfo.QueryDescription,
                queryBinder);
        }

        // Start it?
        query.Start();

        return query;
    }

    #endregion

    #region Query Actions
    
    public bool QueryStart(string queryShortName)
    {
        return QueryAction(queryShortName, q => q.Start());
    }

    public bool QueryStop(string queryShortName)
    {
        return QueryAction(queryShortName, q => q.Stop());
    }
    
    private bool QueryAction(string queryShortName, Action<Query> action)
    {
        lock (_QueriesLock)
        {
            List<Query> queries = String.IsNullOrEmpty(queryShortName)
                ? _Application.Queries.Select(p => p.Value).ToList()
                : _Application.Queries
                    .Where(p => string.Equals(p.Value.ShortName, queryShortName, StringComparison.OrdinalIgnoreCase))
                    .Select(p => p.Value)
                    .ToList();

            if (queries.Count == 0)
            {
                return false;
            }

            foreach (Query query in queries)
            {
                try
                {
                    action(query);
                }
                catch (Exception e)
                {
                    // @@@ different event id
                    Xom.NtEvent(XEvent.Id.VORTEX_SI_QUERY_START, e,
                                "Query \"{0}\" failure", query.Name);

                    // continue or throw?
                    throw;
                }
            }
        }
        return true;
    }

    #endregion

    #region StreamInsight Intialization

    private void CreateServer()
    {
        string instanceName = "Default";
        _Server = Server.Create(instanceName);
        _ServiceHost = new ServiceHost(_Server.CreateManagementService());

        // Using an IP address, rather than a hostname or localhost, seems to allow remote 
        // clients to connect. Connecting locally works either way. The error for the remote
        // case is:
        //
        //      A first chance exception of type 'System.ComponentModel.Win32Exception' 
        //      occurred in System.ServiceModel.dll
        //      
        //      Additional information: Security Support Provider Interface (SSPI) authentication 
        //      failed. The server may not be running in an account with identity 'host/kgxblob'. 
        //      If the server is running in a service account (Network Service for example), 
        //      specify the account's ServicePrincipalName as the identity in the EndpointAddress 
        //      for the server. If the server is running in a user account, specify the account's 
        //      UserPrincipalName as the identity in the EndpointAddress for the server.
        // 
        // I tried lots of variations of explicitly specifying UPN and SPN identities to no avail.
        // So, I'm sticking with IP address for now. Seems reasonable, anyway.
        // @@@ I think we'd like to maybe use hostname in the future...

        // Ends up being something like:
        // http://10.124.133.57:10240/StreamInsight/Default
        string mgmtUrl = String.Format("http://{0}:{1}/{2}/{3}",
                                       VortexConfig.Instance.Settings.StreamInsightMgmtIp,
                                       VortexConfig.Instance.Settings.StreamInsightMgmtPort,
                                       "StreamInsight",
                                       instanceName);

        Trace.Normal("Creating management endpoint at {0}", mgmtUrl);
        Trace.Normal("Note: user must be in the group \"StreamInsightUsers$Default\" to use the management service");

        WSHttpBinding binding = new WSHttpBinding(SecurityMode.Message);
        binding.HostNameComparisonMode = HostNameComparisonMode.StrongWildcard;
        binding.Security.Message.ClientCredentialType = MessageCredentialType.Windows;

        var ep = _ServiceHost.AddServiceEndpoint(
            typeof(IManagementService),
            binding,
            mgmtUrl);

        _ServiceHost.Open();
    }

    private void CreateApplication(string name)
    {
        Application app;
        if (_Server.Applications.TryGetValue(name, out app))
        {
            throw new ArgumentException("Application with name \"" + name + "\" already exists");
        }

        _Application = _Server.CreateApplication(name);
    }

    private void CreateAdapters()
    {
        _Application.CreateInputAdapter<cake.VeiInputAdapterFactory>("VeiInputAdapter", "Configurable event ingestion input adapter");
        _Application.CreateOutputAdapter<cake.VeiOutputAdapterFactory>("VeiOutputAdapter", "Configurable event dispatching output adapter");
    }

    private void CreateQueries()
    {
        VortexConfig vc = VortexConfig.Instance;

        foreach (QueryConfig qc in vc.StreamInsightQueries.Values)
        {
            try
            {
                Query query;

                query = InstantiateQuery(_Application, qc);

                if (null != query)
                {
                    Trace.Normal("StreamInsightMediator::CreateQuery(): Adding query \"{0}\"", qc.QueryName);
                }
                else
                {
                    Xom.NtEvent(XEvent.Id.VORTEX_SI_QUERY_LOAD,
                                "Failed to load query {0} specified in config.", qc.QueryName);
                }
            }
            catch (Exception e)
            {
                Trace.Error("StreamInsightMediator::CreateQuery(): Failed to load query \"{0}\": {1}", qc.QueryName, e.ToString());
                throw;
            }
        }
    }

    #endregion

    public DiagnosticView GetDiagnosticView(string uri)
    {
        return _Server.GetDiagnosticView(new Uri(uri));
    }

}
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\ProjectInstaller.cs ===
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.Configuration.Install;
using System.ServiceProcess;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;

using xonline.common.config;
using xonline.common.service;

[RunInstallerAttribute(true)]
public class ProjectInstaller: System.Configuration.Install.Installer
{

    private ServiceInstaller serviceInstaller;
    private ServiceProcessInstaller processInstaller;

    /// <summary>
    /// Required designer variable.
    /// </summary>
    private System.ComponentModel.Container components = null;

    public ProjectInstaller()
    {
        // This call is required by the Designer.
        InitializeComponent();
    }

    /// <summary> 
    /// Clean up any resources being used.
    /// </summary>
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if(components != null)
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }


    private void InitializeComponent()
    {
        processInstaller = new ServiceProcessInstaller();
        serviceInstaller = new MyServiceInstaller();

        IComponentInfo compInfo = Config.GetComponent(Config.ComponentName);

        LSAUtil.GrantLogonRights( compInfo.Username );

        processInstaller.Account = System.ServiceProcess.ServiceAccount.User;
        processInstaller.Username = compInfo.Username;

        CSetupSecureResolver decoder = new CSetupSecureResolver();
        processInstaller.Password = decoder.UserSecret(compInfo.Password);

        serviceInstaller.ServiceName = Config.ComponentName;
        serviceInstaller.DisplayName = "Xbox Live Vortex Service";
        serviceInstaller.Description = "Sucks in logs and other data, chews it up, and spits it out";
        serviceInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
        serviceInstaller.Committed += new System.Configuration.Install.InstallEventHandler(this.OnCommitted);
        Installers.Add(serviceInstaller);
        Installers.Add(processInstaller);

    }

    private void OnCommitted(object sender, System.Configuration.Install.InstallEventArgs e)
    {
        System.ServiceProcess.ServiceController svc = new System.ServiceProcess.ServiceController(Config.ComponentName);
        if (svc.Status != ServiceControllerStatus.Running &&
            svc.Status != ServiceControllerStatus.StartPending)
        {
            svc.Start();
        }
    }
}

public class MyServiceInstaller : ServiceInstaller
{
    public override void Install(IDictionary stateSaver)
    {
        try
        {
            base.Install(stateSaver);
        }
        catch (Win32Exception e)
        {
            if (e.ErrorCode != -2147467259)  //  0x80004005
                throw;
            Context.LogMessage("Service install failed, but ignoring because it seems like the service was already installed. The exception was:");
            Context.LogMessage(e.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VeiConfig.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.Schema;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.service;
using xonline.common.utilities2;

namespace xonline.server.vortex
{
    /// <summary>
    /// Interface for StreamInsight adapters that are dynamically configurable
    /// </summary>
    public interface IDynamicConfigurableAdapter
    {
        /// <summary>
        /// Gets a description of the associated adapter.  This description is used
        /// primarily for debugging purposes, so it must help identify the target
        /// adapter.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// Triggers (re)configuration of the associated adapter.
        /// </summary>
        /// <param name="config">Configuration driving information.</param>
        void ConfigureAdapter(VortexEventIngestionConfig config);
    }

    /// <summary>
    /// Static class that tracks the dynamically configurable StreamInsight adapters.
    /// </summary>
    public static class DynamicallyConfiguredAdapters
    {
        private static readonly List<IDynamicConfigurableAdapter> Adapters = new List<IDynamicConfigurableAdapter>();

        /// <summary>
        /// Adds a dynamically configurable StreamInsight adapter to the list.
        /// </summary>
        /// <param name="adapter">Target adapter.</param>
        public static void AddAdapter(IDynamicConfigurableAdapter adapter)
        {
            lock (Adapters)
            {
                if (!Adapters.Contains(adapter))
                {
                    Trace.Low("DynamicallyConfiguredAdapters.AddAdapter() adapter added: {0}", adapter.Description);

                    Adapters.Add(adapter);
                }
            }
        }

        /// <summary>
        /// Removes a dynamically configurable StreamInsight adapter from the list.
        /// </summary>
        /// <param name="adapter">Target adapter.</param>
        public static void RemoveAdapter(IDynamicConfigurableAdapter adapter)
        {
            lock (Adapters)
            {
                Trace.Low("DynamicallyConfiguredAdapters.RemoveAdapter() removed added: {0}", adapter.Description);

                Adapters.Remove(adapter);
            }
        }

        /// <summary>
        /// Updates all the tracked configurable adapters with the new configuration data.
        /// </summary>
        /// <param name="config">Configuration driving information.</param>
        public static void NotifyConfigurationChange(VortexEventIngestionConfig config)
        {
            var successEvent = new StringBuilder();
            var failureEvent = new StringBuilder();

            successEvent.AppendLine("DynamicallyConfiguredAdapters.NotifyConfigurationChange() successfully updated adapters:");

            // dont allow adapter list to change mid-stream
            lock (Adapters)
            {
                // update all adapters
                foreach (var adapter in Adapters)
                {
                    // one adapters failure should not prevent another from being updated
                    try
                    {
                        adapter.ConfigureAdapter(config);

                        successEvent.AppendLine("  - " + adapter.Description);

                        Trace.Low("DynamicallyConfiguredAdapters.NotifyConfigurationChange() successfully updated adapter '{0}'", adapter.Description);
                    }
                    catch (Exception e)
                    {
                        Trace.Error("DynamicallyConfiguredAdapters.NotifyConfigurationChange() error updated adapter '{0}': {1}", adapter.Description, e);

                        // this way the failureEvent is empty until a failure actually happens
                        if (failureEvent.Length == 0)
                        {
                            failureEvent.AppendLine("DynamicallyConfiguredAdapters.NotifyConfigurationChange() failed adapter updates:");
                        }

                        failureEvent.AppendFormat("  - {0} : {1}", adapter.Description, e);
                        failureEvent.AppendLine();
                    }
                }
            }

            // write the success events to the event log
            Xom.NtEvent(XEvent.Id.VORTEX_VEI_ADAPTER_UPDATE_SUCCESS, successEvent.ToString());
            
            // write the failure details to the event log
            if (failureEvent.Length > 0)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_VEI_ADAPTER_UPDATE_FAILURE, failureEvent.ToString());
            }
        }
    }

    #region Vortex Event Ingestion Configuration

    public sealed class VortexEventIngestionConfig
    {
        private static readonly string c_DefaultCAKETemplates = 
@"<EventBuilderTemplates>
    <EventBuilder name='PassthroughEvent'>
        <EventTimestamp>$(Timestamp)</EventTimestamp>
        <Id>$(Id)</Id>
        <FlowToken>0</FlowToken>
        <Payload>$(*:|)</Payload>      
    </EventBuilder>
</EventBuilderTemplates>
";

         private static readonly string[] c_DefaultCAKELogs =  new string[] {
@"<Log id='%'>
    <Stream name='PassthroughEvent'>
        <EventBuilderRef name='PassthroughEvent'/>
    </Stream>
    <Stream name='EventCountEvent'>
        <EventBuilder name='EventCountEvent'>
            <Id>$(Id)</Id>
        </EventBuilder>
    </Stream>
</Log>",
        };

         private static readonly string[] c_DefaultCAKEQueries =  new string[] {
@"<Query name='PassthroughQuery'>
    <EventSink name='XomLogEventSink' initparams='target=remote;enable=yes'>
        <XomLogArea>VxPassthroughQuery</XomLogArea>
        <XomLogLevel>0</XomLogLevel>
        <WriteToTrace>true</WriteToTrace>
        <Message>$(Id)|$(Payload)</Message>
        <FlowToken>$(FlowToken)</FlowToken>
    </EventSink>
</Query>",

@"<Query name='EventTypeCountQuery'>
    <EventSink name='XomLogEventSink' initparams='target=remote;enable=yes'>
        <XomLogArea>VxEventTypeCountQuery</XomLogArea>
        <XomLogLevel>0</XomLogLevel>
        <WriteToTrace>true</WriteToTrace>
        <!--<Message>$(*:|)</Message>-->
        <Message>EVENTCOUNT|$(TimeSpanInSeconds)|$(Count)|$(EventId)</Message>
    </EventSink>
</Query>",
        };



        const string c_TemplateElementName = "EventBuilderTemplates";
        const string c_TemplateObjectBuilderChildElements = "EventBuilder";
        const string c_QueryElementName = "Query";
        const string c_LogElementName = "Log";
        const string c_SchemaDocumentFileName = "VeiConfig.xsd";

        // Cached Xml Schema Instance
        private static XmlSchema _schemaCache = null;
        public static XmlSchema SchemaCache
        {
            get
            {
                if (null == _schemaCache)
                {
                    using (XmlReader reader = XmlReader.Create(c_SchemaDocumentFileName))
                    {
                        Interlocked.Exchange<XmlSchema>(ref _schemaCache, XmlSchema.Read(reader, (s, e) => { }));
                    }
                }

                return _schemaCache;
            }
        }

        // Vortex Event Ingestion Config
        public List<VortexLogConfig> WildCardLogs { get; set; }
        public SerializableDictionary<string, VortexLogConfig> NamedLogs { get; set; }
        public SerializableDictionary<string, VortexQueryConfig> Queries { get; set; }

        public static VortexEventIngestionConfig LoadFromNpdb()
        {
            var config = new VortexEventIngestionConfig();
            var templates = LoadTemplatesFromNpdb();

            config.LoadLogsFromNpdb(templates);
            config.LoadQueriesFromNpdb();

            return config;
        }

        private static SerializableDictionary<string, VortexObjectMapperConfig> LoadTemplatesFromNpdb()
        {
            var result = new SerializableDictionary<string, VortexObjectMapperConfig>();
            var errors = new StringBuilder();

            string xmlValue = null;
            try
            {
                xmlValue = Config.GetSetting(Setting.vortex_cake_stream_recipe_template_xml);
            }
            catch (Exception e)
            {
                Trace.Error("VortexEventIngestionConfig.LoadTemplatesFromNpdb() Error getting setting {0}: {1}", Setting.vortex_cake_stream_recipe_template_xml, e.Message);
            }

            if (String.IsNullOrEmpty(xmlValue))
            {
                // Do some defaults
                xmlValue = c_DefaultCAKETemplates;
            }
                
            try
            {
                using (var configReader = new StringReader(xmlValue))
                {
                    StringBuilder validationErrors = new StringBuilder();

                    using (var xmlReader = CreateXmlReader(configReader, Setting.vortex_cake_stream_recipe_template_xml, validationErrors))
                    {
                        XmlDocument document = new XmlDocument();

                        // load the xml document; schema validation should occur here - errors will be written to validationErrors
                        document.Load(xmlReader);

                        // check the validity of the document
                        AssertDocumentIsValid(document, validationErrors, c_TemplateElementName, xmlValue);

                        // load each object mapper child in the template to the template dictionary, skipped failed items
                        foreach (XmlElement child in document.DocumentElement.SelectNodes(c_TemplateObjectBuilderChildElements))
                        {
                            try
                            {
                                // load the object mapper from the template, note these ones have names
                                VortexObjectMapperConfig mapper = VortexObjectMapperConfig.Parse(child);

                                result.Add(mapper.Name, mapper);

                                Trace.Low("VortexEventIngestionConfig.LoadTemplatesFromNpdb() added template '{0}'", mapper.Name);
                            }
                            catch (Exception e)
                            {
                                Trace.Error("VortexEventIngestionConfig.LoadTemplatesFromNpdb() error parsing template:\n{0}\n\n{1}", child.OuterXml, e);

                                errors.AppendLine("error parsing template:");
                                errors.AppendLine("xml:");
                                errors.AppendLine(child.OuterXml);
                                errors.AppendLine("error message: " + e.Message);
                                errors.AppendLine();
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Error("VortexEventIngestionConfig.LoadTemplatesFromNpdb() unexpected error: {0}", e);

                errors.AppendLine("unexpected error during template build:");
                errors.AppendLine("error details: " + errors.ToString());
            }

            if (errors.Length > 0)
            {
                Xom.NtEvent(
                    XEvent.Id.VORTEX_VEI_CONFIG_TEMPLATE_LOAD_ERROR, 
                    "VortexEventIngestionConfig.LoadTemplatesFromNpdb() errors encountered while loading templates\n{0}", 
                    errors.ToString());
                throw new Exception(errors.ToString());
            }

            return result;
        }

        private static void AssertDocumentIsValid(XmlDocument document, StringBuilder validationErrors, string expectedRoot, string settingValue)
        {
            // make sure no validation error were reported - validationErrors writing only occurs in the validation failure callback
            if (validationErrors.Length > 0)
            {
                string message;

                message = string.Format(
                    "xml invalidation errors occurred:{0}details:{0}{1}{0}{0}xml input:{0}{2}",
                    Environment.NewLine,
                    validationErrors,
                    settingValue);

                throw new InvalidDataException(message);
            }

            // make sure the root element name matches the expected name
            if (document.DocumentElement.Name != expectedRoot)
            {
                string message;

                message = string.Format(
                    "{0}: expected document root element {1}, but {2} was found.",
                    Setting.vortex_cake_stream_recipe_template_xml,
                    c_TemplateElementName,
                    document.DocumentElement.Name);

                throw new InvalidDataException(message);
            }
        }

        private void LoadLogsFromNpdb(SerializableDictionary<string, VortexObjectMapperConfig> templates)
        {
            var uniqueWildcardEnforcement = new Dictionary<string, string>();
            var wildcardReplacementExpr = new Regex("%%+");
            var errors = new StringBuilder();

            string[] xmlValues = null;
            try
            {
                xmlValues = Config.GetMultiSetting(MultiSetting.vortex_cake_log_config_xml);
            }
            catch (Exception e)
            {
                Trace.Error("VortexEventIngestionConfig.LoadLogsFromNpdb() Error getting setting {0}: {1}", MultiSetting.vortex_cake_log_config_xml, e);
            }

            if (xmlValues == null || xmlValues.Length == 0)
            {
                xmlValues = c_DefaultCAKELogs;
            }

            try
            {
                foreach (string setting in xmlValues)
                {
                    using (var configReader = new StringReader(setting))
                    {
                        StringBuilder validationErrors = new StringBuilder();

                        using (var xmlReader = CreateXmlReader(configReader, MultiSetting.vortex_cake_log_config_xml, validationErrors))
                        {
                            try
                            {
                                XmlDocument document = new XmlDocument();

                                // load the xml document; schema validation should occur here - errors will be written to validationErrors
                                document.Load(xmlReader);

                                // check the validity of the document
                                AssertDocumentIsValid(document, validationErrors, c_LogElementName, setting);

                                var log = VortexLogConfig.Parse(document.DocumentElement, templates);

                                // wild card logs and regular logs are kept separate
                                if (log.HasWildCards)
                                {
                                    // collapse all canonical representations to a normalized form, make sure the normalized for is unique
                                    string normalizedIdentifier = wildcardReplacementExpr.Replace(log.Identifier, "%");

                                    uniqueWildcardEnforcement.Add(normalizedIdentifier, null);

                                    // save the normalized representation
                                    log.Identifier = normalizedIdentifier;

                                    WildCardLogs.Add(log);
                                }
                                else
                                {
                                    NamedLogs.Add(log.Identifier, log);
                                }

                                Trace.Low(
                                    "VortexEventIngestionConfig.LoadLogsFromNpdb() log successfully loaded; name={0}, wildcard={1}, streams={2}", 
                                    log.Identifier, 
                                    log.HasWildCards, 
                                    string.Join(", ", log.Streams.Keys.ToArray()));
                            }
                            catch (ArgumentException e)
                            {
                                errors.AppendLine("key collision occured while adding log: " + e.Message);
                            }
                            catch (Exception e)
                            {
                                errors.AppendLine("unexpected error occured while adding individual log: " + e.ToString());
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                errors.AppendLine("unexpected error occured while processing logs: " + e.ToString());
            }

            if (errors.Length > 0)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_VEI_CONFIG_LOG_LOAD_ERROR, "VortexEventIngestionConfig.LoadLogsFromNpdb() error load logs\n{0}", errors);
                throw new Exception(errors.ToString());
            }
        }

        private void LoadQueriesFromNpdb()
        {
            var errors = new StringBuilder();

            string[] xmlValues = null;
            try
            {
                xmlValues = Config.GetMultiSetting(MultiSetting.vortex_cake_query_config_xml);
            }
            catch (Exception e)
            {
                Trace.Error("VortexEventIngestionConfig.LoadQueriesFromNpdb() Error getting setting {0}: {1}", MultiSetting.vortex_cake_query_config_xml, e);
            }

            if (xmlValues == null || xmlValues.Length == 0)
            {
                xmlValues = c_DefaultCAKEQueries;
            }

            try
            {
                foreach (string setting in xmlValues)
                {
                    using (var configReader = new StringReader(setting))
                    {
                        StringBuilder validationErrors = new StringBuilder();

                        using (var xmlReader = CreateXmlReader(configReader, MultiSetting.vortex_cake_query_config_xml, validationErrors))
                        {
                            try
                            {
                                XmlDocument document = new XmlDocument();

                                // load the xml document; schema validation should occur here - errors will be written to validationErrors
                                document.Load(xmlReader);

                                // check the validity of the document
                                AssertDocumentIsValid(document, validationErrors, c_QueryElementName, setting);

                                var query = VortexQueryConfig.Parse(document.DocumentElement);

                                Queries.Add(query.Name, query);
                                
                                Trace.Low(
                                    "VortexEventIngestionConfig.LoadQueriesFromNpdb() query successfully loaded; name={0}, sinks={1}",
                                    query.Name,
                                    string.Join(", ", query.EventSinks.Keys.ToArray()));
                            }
                            catch (ArgumentException e)
                            {
                                errors.AppendLine("key collision occured while adding query: " + e.Message);
                            }
                            catch (Exception e)
                            {
                                errors.AppendLine("unexpected error occured while adding individual query: " + e.ToString());
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                errors.AppendLine("unexpected error occured while processing queries: " + e.ToString());
            }

            if (errors.Length > 0)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_VEI_CONFIG_LOG_LOAD_ERROR, "VortexEventIngestionConfig.LoadQueriesFromNpdb() error load queries\n{0}", errors);
                throw new Exception(errors.ToString());
            }
        }

        private static XmlReader CreateXmlReader(TextReader input, string context, StringBuilder errorReport)
        {
            XmlReaderSettings settings = new XmlReaderSettings();

            try
            {
                settings.Schemas.Add(SchemaCache);
                settings.ValidationType = ValidationType.Schema;
                settings.ValidationEventHandler +=
                    (s, a) =>
                    {
                        errorReport.AppendFormat("invalid schema in {0}({1},{2}) - {3}",
                            context,
                            a.Exception.LineNumber,
                            a.Exception.LinePosition,
                            a.Message);

                        errorReport.AppendLine();
                    };

                Trace.Low("VortexEventIngestionConfig.CreateXmlReader() schema validator loaded successfully");
                        
                return XmlReader.Create(input, settings);
            }
            catch (Exception e)
            {
                Xom.NtEvent(
                    XEvent.Id.VORTEX_VEI_CONFIG_SCHEMA_VALIDATOR_ERROR,
                    "VortexEventIngestionConfig.CreateXmlReader() failed to load the schema validator, configuration data will not be validated:\n{0}", e);

                Trace.Error("VortexEventIngestionConfig.CreateXmlReader() failed to load the schema validator:\n{0}", e);

                return XmlReader.Create(input);
            }
        }

        public VortexEventIngestionConfig()
        {
            WildCardLogs = new List<VortexLogConfig>();
            NamedLogs = new SerializableDictionary<string, VortexLogConfig>();
            Queries = new SerializableDictionary<string, VortexQueryConfig>();
        }
    }

    public sealed class VortexObjectMapperConfig
    {
        const string c_ObjectMapperNameAttribute = "name";

        // Object Mapper Configuration    
        public string Name { get; set; }
        public SerializableDictionary<string, string> FieldExpressions { get; set; }

        public static string ParseReferenceName(XmlElement reference)
        {
            return reference.Attributes[c_ObjectMapperNameAttribute].InnerText;
        }

        public static VortexObjectMapperConfig Parse(XmlElement definition)
        {
            VortexObjectMapperConfig config = new VortexObjectMapperConfig();

            if (definition.HasAttribute(c_ObjectMapperNameAttribute))
            {
                config.Name = definition.Attributes[c_ObjectMapperNameAttribute].InnerText;
            }

            foreach (XmlNode child in definition.ChildNodes)
            {
                if (child is XmlElement)
                {
                    try
                    {
                        // Read the recipe for the field
                        config.FieldExpressions.Add(child.Name, child.InnerText);
                    }
                    catch (ArgumentException)
                    {
                        Xom.NtEvent(
                            XEvent.Id.VORTEX_VEI_CONFIG_DUPLICATE_OBJECT_MAPPER_FIELD,
                            "VortexObjectMapperConfig.Parse() duplicate field '{0}' found in:\n{1}",
                            child.Name, definition.OuterXml);

                        Trace.Error("VortexObjectMapperConfig.Parse() duplicate field '{0}' found", child.Name);
                    }
                }
            }

            return config;
        }

        public VortexObjectMapperConfig()
        {
            Name = "";
            FieldExpressions = new SerializableDictionary<string, string>();
        }

        /// <summary>
        /// Computes the hash code associated with the object mapper.
        /// </summary>
        /// <returns>Returns the hash code associated with the object mapper.</returns>
        /// <remarks>
        /// Object mapper hash codes are used to eliminate duplication of object mapper
        /// creation and registration work during setting refreshes.
        /// </remarks>
        public override int GetHashCode()
        {
            int hash = 0;

            foreach (var entry in FieldExpressions)
            {
                hash ^= ("K:" + entry.Key + "V:" + entry.Value).GetHashCode();
            }

            return hash;
        }
    }

    public sealed class VortexStreamConfig
    {
        // Xml Schema
        const string c_StreamNameAttribute = "name";
        const string c_StreamEventBuilderChildElements = "EventBuilder";
        const string c_StreamEventBuilderRefChildElements = "EventBuilderRef";

        // Stream Configuration
        public string Name { get; set; }
        public List<VortexObjectMapperConfig> Recipes { get; set; }

        public static VortexStreamConfig Parse(XmlElement definition, Dictionary<string, VortexObjectMapperConfig> templates)
        {
            VortexStreamConfig config = new VortexStreamConfig();

            config.Name = definition.Attributes[c_StreamNameAttribute].InnerText;

            // add the in place defined event builders
            foreach (XmlElement child in definition.SelectNodes(c_StreamEventBuilderChildElements))
            {
                config.Recipes.Add(VortexObjectMapperConfig.Parse(child));
            }

            // add the template referenced event builders
            foreach (XmlElement child in definition.SelectNodes(c_StreamEventBuilderRefChildElements))
            {
                string name;

                name = VortexObjectMapperConfig.ParseReferenceName(child);

                try
                {
                    config.Recipes.Add(templates[name]);
                }
                catch (KeyNotFoundException)
                {
                    Xom.NtEvent(
                        XEvent.Id.VORTEX_VEI_CONFIG_TEMPLATE_REFERENCE_MISSING,
                        "VortexStreamConfig.Parse() a stream with name '{0}' contained a reference to a non-existing EventBuilder template '{1}'",
                        config.Name,
                        name);

                    Trace.Error("VortexStreamConfig.Parse() a stream with name '{0}' contained a reference to a non-existing EventBuilder template '{1}'", config.Name, name);
                }
            }

            return config;
        }

        public VortexStreamConfig()
        {
            Recipes = new List<VortexObjectMapperConfig>();
        }
    }

    public sealed class VortexLogConfig
    {
        // Xml Schema
        const string c_LogIdAttribute = "id";
        const string c_LogStreamChildElments = "Stream";

        // Log Target Configuration
        public bool HasWildCards { get; set; }
        public string Identifier { get; set; }
        public SerializableDictionary<string, VortexStreamConfig> Streams { get; set; }

        public static VortexLogConfig Parse(XmlElement definition, Dictionary<string, VortexObjectMapperConfig> templates)
        {
            VortexLogConfig config = new VortexLogConfig();

            config.Identifier = definition.Attributes[c_LogIdAttribute].InnerText;
            config.HasWildCards = config.Identifier.Contains("%");

            foreach (XmlElement child in definition.SelectNodes(c_LogStreamChildElments))
            {
                VortexStreamConfig stream;

                stream = VortexStreamConfig.Parse(child, templates);

                try
                {
                    config.Streams.Add(stream.Name, stream);
                }
                catch (ArgumentException)
                {
                    Xom.NtEvent(
                        XEvent.Id.VORTEX_VEI_CONFIG_DUPLICATE_STREAM_NAME,
                        "VortexLogConfig.Parse() duplicate stream name '{0}' found in log with identifier '{1}'",
                        stream.Name, config.Identifier);

                    Trace.Error("VortexLogConfig.Parse() duplicate stream name '{0}' found in log with identifier '{1}'", stream.Name, config.Identifier);
                }
            }

            return config;
        }

        public VortexLogConfig()
        {
            Streams = new SerializableDictionary<string, VortexStreamConfig>();
        }
    }

    public sealed class VortexEventSinkConfig
    {
        // Xml Schema
        const string c_EventSinkNameAttribute = "name";
        const string c_EventSinkInitParamsAttribute = "initparams";

        // Log Target Configuration
        public string Name { get; set; }
        public string InitParams { get; set; }
        public VortexObjectMapperConfig Recipe { get; set; }

        public static VortexEventSinkConfig Parse(XmlElement definition)
        {
            VortexEventSinkConfig config = new VortexEventSinkConfig();

            config.Name = definition.Attributes[c_EventSinkNameAttribute].InnerText;
            var initParams = definition.Attributes[c_EventSinkInitParamsAttribute];
            config.InitParams = initParams != null ? initParams.InnerText : String.Empty;
            config.Recipe = VortexObjectMapperConfig.Parse(definition);

            return config;
        }

        public VortexEventSinkConfig()
        {
        }
    }

    public sealed class VortexQueryConfig
    {
        // Xml Schema
        const string c_QueryNameAttribute = "name";
        const string c_QueryEventSinkChildElements = "EventSink";

        // Query Configuration
        public string Name { get; set; }
        public SerializableDictionary<string, VortexEventSinkConfig> EventSinks { get; set; }

        public static VortexQueryConfig Parse(XmlElement definition)
        {
            VortexQueryConfig config = new VortexQueryConfig();

            config.Name = definition.Attributes[c_QueryNameAttribute].InnerText;

            foreach (XmlElement child in definition.SelectNodes(c_QueryEventSinkChildElements))
            {
                VortexEventSinkConfig sink;

                sink = VortexEventSinkConfig.Parse(child);

                try
                {
                    config.EventSinks.Add(sink.Name, sink);
                }
                catch (ArgumentException)
                {
                    Xom.NtEvent(
                        XEvent.Id.VORTEX_VEI_CONFIG_DUPLICATE_SINK_NAME,
                        "VortexQueryConfig.Parse() duplicate EventSink name '{0}' found in query with name '{1}'",
                        sink.Name, config.Name);

                    Trace.Error("VortexQueryConfig.Parse() duplicate EventSink name '{0}' found in query with name '{1}'", sink.Name, config.Name);
                }
            }

            return config;
        }

        public VortexQueryConfig()
        {
            EventSinks = new SerializableDictionary<string, VortexEventSinkConfig>();
        }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VeiPayloadReader.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.IO;

using Microsoft.ComplexEventProcessing;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.vortex.cake
{
    // A dissertation on PayloadReader behavior.
    //
    // Every payload reader, on the input side, must support $(Id) and $(Timestamp) named 
    // fields.
    //
    // They must not include the Id and Timestamp when enumerating all fields, such as via 
    // the universal set join $(*:|) operator.  If the CAKE recipe wants these fields, 
    // they must be called out explicitly.
    //
    //


    public abstract class PayloadReader
    {
        public abstract Context CreateContext(object payload);
        
        public abstract T ReadNamedField<T>(Context context, string name, Func<object, T> converter);
        public abstract T ReadOrdinalField<T>(Context context, int ordinal, Func<object, T> converter);

        public abstract int GetOrdinalCount(Context context);

        public abstract string[] GetNamedFields(Context context);

        /// <summary>
        /// Reports access to a field, by name, that does not exist in the target payload type.
        /// </summary>
        /// <param name="name">Name of the field.</param>
        /// <param name="payloadType">The name of the type of the payload</param>
        protected void ReportInvalidFieldByName(string name, string payloadType)
        {
            VortexCounters.Current.InvalidFieldAccess.Increment();

            Trace.Error("{0}.ReadNamedField() the specified field named '{1}' is not present in '{2}'", GetType().Name, name, payloadType);
        }

        /// <summary>
        /// Reports access to a field, by ordinal, that does not exist in the target payload type.
        /// </summary>
        /// <param name="ordinal">Ordinal of the field.</param>
        /// <param name="payloadType">The name of the type of the payload</param>
        protected void ReportInvalidFieldByOrdinal(int ordinal, string payloadType)
        {
            VortexCounters.Current.InvalidFieldAccess.Increment();

            Trace.Error("{0}.ReadNamedField() the specified field with ordinal '{1}' is not present in '{2}'", GetType().Name, ordinal, payloadType);
        }

        protected const string FIELD_ID = "id";
        protected const string FIELD_TIMESTAMP = "timestamp";
        protected const string FIELD_FLOKEN = "floken";

        #region PayloadReader.Context

        public class Context : IDisposable
        {
            private object _payload;
            private string _identifier;

            public object Payload
            {
                get
                {
                    return _payload;
                }
            }

            public string Identifier
            {
                get
                {
                    return _identifier;
                }
            }

            public Context(object payload, string identifier)
            {
                this._payload = payload;
                this._identifier = identifier;
            }

            public virtual void Dispose()
            {
            }

            public override string ToString()
            {
                return string.Format(
                    "id={0},payload={1}",
                    Identifier,
                    Payload);
            }
        }

        protected class Context<T> : Context
        {
            private T _payload;
            public new T Payload
            {
                get
                {
                    return _payload;
                }
            }

            public Context(T payload, string identifier) : base(payload, identifier)
            {
                this._payload = payload;
            }
        }

        #endregion
    }

    /// <summary>
    /// This class implements the PayloadReader abstract class.  It is responsible for
    /// reading output UntypedEvent field values.
    /// </summary>
    public class QueryOutputPayloadReader : PayloadReader
    {
        private readonly CepEventType _queryType;

        /// <summary>
        /// Initializes a new instance of the QueryOutputPayloadReader class.  Each
        /// reader is associated with a particular event type.
        /// </summary>
        /// <param name="queryType">Expected event type of payloads handled by this instance.</param>
        public QueryOutputPayloadReader(CepEventType queryType)
        {
            // Note the ordering of the fields in queryType is, it seems, alphabetical. .Net provides
            // no ordering guarantees, so StreamInsight has decided to sort the list, it appears.
            _queryType = queryType;
        }

        /// <summary>
        /// Attempts to get the ordinal for a field with the specified name.  UntypedEvent fields are
        /// accessed by ordinal.
        /// </summary>
        /// <param name="name">Name of the field associated with the ordinal lookup.</param>
        /// <param name="ord">Receives the ordinal associated with the field name.</param>
        /// <returns>Returns true if the specified name is present; false otherwise.</returns>
        private bool OrdinalOf(string name, out int ord)
        {
            CepEventTypeField etf;

            ord = 0;
            if (_queryType.Fields.TryGetValue(name, out etf))
            {
                ord = etf.Ordinal;
                
                return true;
            }

            return false;
        }

        /// <summary>
        /// Creates the payload reader context.
        /// </summary>
        /// <param name="payload">UntypedEvent output from the query.</param>
        /// <returns>Returns a new Context&lt;UntypedEvent&gt; object wrapping the supplied payload.</returns>
        public override PayloadReader.Context CreateContext(object payload)
        {
            return new Context<UntypedEvent>((UntypedEvent)payload, _queryType.ShortName);
        }

        /// <summary>
        /// Reads a field from an UntypedEvent by name.
        /// </summary>
        /// <typeparam name="T">Target type for output.</typeparam>
        /// <param name="context">Payload contextual information.</param>
        /// <param name="name">Name of the desired field.</param>
        /// <param name="converter">Type conversion lamdba expression generated by the expression builder.</param>
        /// <returns>Returns the value associated with the field.  If the field is not present default(T) is returned.</returns>
        public override T ReadNamedField<T>(PayloadReader.Context context, string name, Func<object, T> converter)
        {
            int ordinal;

            if (OrdinalOf(name, out ordinal))
            {
                return ReadOrdinalField(context, ordinal, converter);
            }

            ReportInvalidFieldByName(name, _queryType.ShortName);

            return converter(null);
        }

        /// <summary>
        /// Reads a field from an UntypedEvent by ordinal.
        /// </summary>
        /// <typeparam name="T">Target type for output.</typeparam>
        /// <param name="context">Payload contextual information.</param>
        /// <param name="ordinal">Ordinal of the desired field.</param>
        /// <param name="converter">Type conversion lamdba expression generated by the expression builder.</param>
        /// <returns>Returns the value associated with the field.  If the field is not present default(T) is returned.</returns>
        public override T ReadOrdinalField<T>(PayloadReader.Context context, int ordinal, Func<object, T> converter)
        {
            if (ordinal < _queryType.Fields.Count)
            {
                Context<UntypedEvent> peContext = (Context<UntypedEvent>)context;

                return converter(peContext.Payload.GetField(ordinal));
            }

            ReportInvalidFieldByOrdinal(ordinal, _queryType.ShortName);

            return converter(null);
        }

        /// <summary>
        /// Gets the number of ordinal fields present for the payload.  For UntypedEvents this
        /// is equal to the number of fields since they are looked up by ordinal.
        /// </summary>
        /// <param name="context">Payload contextual information.</param>
        /// <returns>Returns the number of ordinal fields.</returns>
        /// <remarks>The UntypedEvents have no gaps in their ordinal range.</remarks>
        public override int GetOrdinalCount(PayloadReader.Context context)
        {
            return 0;
        }

        /// <summary>
        /// Gets the named fields associated with this payload.  UntypedEvents are ordinal
        /// based so their are no names here.
        /// </summary>
        /// <param name="context">Payload contextual information.</param>
        /// <returns>
        /// Returns an array of strings containing the field names.  
        /// This array will always be empty.
        /// </returns>
        /// <remarks>
        /// Names are not enumerated the CepEventType since this would result in double 
        /// reporting for the universal set join operation.
        /// </remarks>
        public override string[] GetNamedFields(PayloadReader.Context context)
        {
            return _queryType.Fields.Keys.ToArray();
        }

    }


    /// <summary>
    /// This class implements the PayloadReader abstract class.  It is responsible for
    /// reading the binary messages that come from the vortex protocol binary format.
    /// </summary>
    public class VortexProtocolPayloadReader : PayloadReader
    {
        public VortexProtocolPayloadReader()
        {
        }

        public override PayloadReader.Context CreateContext(object payload)
        {
            return new Context<VxEvent>((VxEvent)payload, ((VxEvent)payload).EventId.ToString());
        }

        public override T ReadNamedField<T>(PayloadReader.Context context, string name, Func<object, T> converter)
        {
            // VxEvent exposes a few fields as named fields. These are baked in to the
            // protocol, you could say.  EventId and BaseTimestamp are the only current 
            // ones. Future ones would include the SpecialFields (?).

            // @@@ TODO: settle on how to expose SpecialFields.

            Context<VxEvent> ctx = (Context<VxEvent>)context;

            // @@@ A dictionary mapping the name to a delegate or something may be better.
            if (name.Equals("eventid", StringComparison.OrdinalIgnoreCase) ||
                name.Equals(FIELD_ID, StringComparison.OrdinalIgnoreCase))
            {
                return converter(ctx.Payload.EventId);
            }
            else if (name.Equals(FIELD_TIMESTAMP, StringComparison.OrdinalIgnoreCase))
            {
                return converter(ctx.Payload.Timestamp);
            }

            // @@@ implement FIELD_FLOKEN. probably via a base class that also implements 
            // other special tokens.

            ReportInvalidFieldByName(name, "VxEvent");

            return converter(null);
        }

        public override T ReadOrdinalField<T>(PayloadReader.Context context, int ordinal, Func<object, T> converter)
        {
            Context<VxEvent> ctx = (Context<VxEvent>)context;

            object val;
            if (ctx.Payload.EventFields.TryGetField((uint)ordinal, out val))
            {
                return converter(val);
            }

            ReportInvalidFieldByOrdinal(ordinal, "VxEvent:" + ctx.Identifier);

            return converter(null);
        }

        public override int GetOrdinalCount(PayloadReader.Context context)
        {
            // We want to return the max(ordinal), not the count. Gaps in the ordinals
            // should be treated as default values. This is for the wildcard operator
            // when we want to turn this into a pipe-delimited string -- we need to 
            // maintain the original ordinality. Also, note field-ids are 1-based.

            Context<VxEvent> ctx = (Context<VxEvent>)context;
            return (int)ctx.Payload.EventFields.MaxFieldOrdinal;
        }

        public override string[] GetNamedFields(PayloadReader.Context context)
        {
            // You can ask for the named fields in the reciple explicitly,
            // but the universal set join won't expose them to the $(*) operator.
            //return _NamedFields;
            return new string[] { };
        }
    }


    /// <summary>
    /// This class implements the PayloadReader abstract class.  It is responsible for
    /// reading the text logline messages that come from the LogString api. These are
    /// pipe-delimited strings.
    /// </summary>
    public class LogStringPayloadReader : PayloadReader
    {
        class LogStringPayload
        {
            public string EventId;
            public DateTime Timestamp;
            public Floken FlowToken;
            public string[] Fields;
            public int NumHeaderFields;
        };

        public LogStringPayloadReader()
        {
        }

        public override PayloadReader.Context CreateContext(object payload)
        {
            // Possible formats include the following. Payload is always optional,
            // I suppose. But that would be weird. Id is not optional.
            //
            // Timestamp | Floken | Id | Payload...
            // Timestamp | Id | Payload...
            // Id | Payload...

            string logline = (string)payload;
            string[] fields = logline.Split(C_SEPS, StringSplitOptions.None);

            // Set defaults
            Floken floken = Floken.None;
            DateTime timestamp = DateTime.UtcNow;
            string id = fields.Length > 0 ? fields[0] : logline;
            int numHeaderFields = 1;

            // Assume id is in field[0] unless we detect otherwise.
            if (fields.Length >= 2)
            {
                if (DateTime.TryParse(fields[0], out timestamp))
                {
                    if (fields[1].StartsWith("FT"))
                    {
                        floken = new Floken(fields[1]);
                        // exception if there aren't at least 3 fields. just let it happen?
                        id = fields[2];
                        numHeaderFields = 3;
                    }
                    else
                    {
                        id = fields[1];
                        numHeaderFields = 2;
                    }
                }
                else
                {
                    timestamp = DateTime.UtcNow;
                }
            }

            // @@@ TODO: do we include the id in the list of NamedFields AND in the OrdinalFields?
            // If so, we'll end up enumerating it twice in the wildcard mapping for converting to
            // a string. Not what we want. But we *do* want it exposed as NamedField, so maybe 
            // not expose it as an OrdinalField?  But then we're off-by-one... oh the humanity.

            var logStringPayload = new LogStringPayload()
            {
                EventId = id,
                Timestamp = timestamp,
                FlowToken = floken,
                Fields = fields,
                NumHeaderFields = numHeaderFields,
            };
                
            return new Context<LogStringPayload>(logStringPayload, id);
        }

        public override T ReadNamedField<T>(PayloadReader.Context context, string name, Func<object, T> converter)
        {
            Context<LogStringPayload> ctx = (Context<LogStringPayload>)context;

            // @@@ A dictionary mapping the name to a delegate or something may be better.
            if (name.Equals(FIELD_ID, StringComparison.OrdinalIgnoreCase))
            {
                return converter(ctx.Payload.EventId);
            }
            else if (name.Equals(FIELD_TIMESTAMP, StringComparison.OrdinalIgnoreCase))
            {
                return converter(ctx.Payload.Timestamp);
            }
            else if (name.Equals(FIELD_FLOKEN, StringComparison.OrdinalIgnoreCase))
            {
                // If the floken wasn't in the received payload, then we should fall through
                // and use the (TBD) base class' implementation to retrieve floken and other
                // special fields.
                return converter(ctx.Payload.FlowToken);
            }

            ReportInvalidFieldByName(name, "LogStringPayload");

            return converter(null);
        }

        public override T ReadOrdinalField<T>(PayloadReader.Context context, int ordinal, Func<object, T> converter)
        {
            // Remember we are 1-based
            if (ordinal < 1)
            {
                return converter(null);
            }

            Context<LogStringPayload> ctx = (Context<LogStringPayload>)context;
            int adjustedOrdinal = ctx.Payload.NumHeaderFields + ordinal - 1;

            if (adjustedOrdinal < ctx.Payload.Fields.Length)
            {
                return converter(ctx.Payload.Fields[adjustedOrdinal]);
            }

            ReportInvalidFieldByOrdinal(ordinal, "LogStringPayload:" + ctx.Identifier);

            return converter(null);
        }

        public override int GetOrdinalCount(PayloadReader.Context context)
        {
            Context<LogStringPayload> ctx = (Context<LogStringPayload>)context;

            // Exclude the fixed/header/named fields from the count.
            // Remember we are 1-based
            return ctx.Payload.Fields.Length - ctx.Payload.NumHeaderFields;
        }

        public override string[] GetNamedFields(PayloadReader.Context context)
        {
            // You can ask for the named fields in the recipe explicitly,
            // but the universal set join won't expose them to the $(*) operator.
            //return _NamedFields;
            return new string[] { };
        }

        private readonly char[] C_SEPS = new char[] { '|' };
    }


    /// <summary>
    /// This class implements the PayloadReader abstract class.  It is responsible for
    /// reading the text logline messages that come from the LogString api. These are
    /// pipe-delimited strings.
    /// </summary>
    public class LogString2PayloadReader : PayloadReader
    {
        public LogString2PayloadReader()
        {
        }

        public override PayloadReader.Context CreateContext(object payload)
        {
            NameValueCollection nvc = (NameValueCollection)payload;
            return new Context<NameValueCollection>(nvc, nvc["v1"]);
        }

        public override T ReadNamedField<T>(PayloadReader.Context context, string name, Func<object, T> converter)
        {
            Context<NameValueCollection> ctx = (Context<NameValueCollection>)context;
            object result = null;

            if (name.Equals(FIELD_ID, StringComparison.OrdinalIgnoreCase))
            {
                result = ctx.Payload["v1"];
            }
            else if (name.Equals(FIELD_TIMESTAMP, StringComparison.OrdinalIgnoreCase))
            {
                result = DateTime.UtcNow; // @@@ TODO this is wrong! maybe! not sure!
            }
            else if (name.Equals(FIELD_FLOKEN, StringComparison.OrdinalIgnoreCase))
            {
                // @@@ TODO maybe the console reported it. Define the v field for it. If not 
                // sent up, use base class to retrieve it (and other special fields).
                result = Floken.None;
            }
            else
            {
                // Prepend the name on. Is this a hack to do this here? It's the behavior we 
                // want for LogString2, but not other payload readers. So no?
                string val = ctx.Payload[name];
                if (val != null)
                {
                    result = name + "=" + val;
                }
            }

            // Accessing an invalid key with a NameValueCollection returns null, not an exception.
            if (null == result)
            {
                ReportInvalidFieldByName(name, "NameValueCollection:" + ctx.Payload["v1"]);
            }

            return converter(result);
        }

        public override T ReadOrdinalField<T>(PayloadReader.Context context, int ordinal, Func<object, T> converter)
        {
            ReportInvalidFieldByOrdinal(ordinal, "NameValueCollection");

            return converter(null);
        }

        public override int GetOrdinalCount(PayloadReader.Context context)
        {
            return 0;
        }

        class LogString2ParamsComparer : IComparer<string>
        {
            private int GetParamState(string x)
            {
                if (String.IsNullOrEmpty(x))
                {
                    return 3;
                }

                int st = 2;
                if (x.StartsWith("v", StringComparison.OrdinalIgnoreCase))
                {
                    st--;
                    if (x.Length == 2)
                    {
                        st--;
                    }
                }
                return st;
            }

            public int Compare(string x, string y)
            {
                // v params come first. v2 is before v10.

                // 2 -> not a "v" param
                // 1 -> "vXX" param
                // 0 -> "vX" param
                int stX = GetParamState(x);
                int stY = GetParamState(y);

                if (stX != stY)
                {
                    return stX - stY;
                }
                else
                {
                    return String.Compare(x, y, StringComparison.OrdinalIgnoreCase);
                }
            }
        }

        public override string[] GetNamedFields(PayloadReader.Context context)
        {
            Context<NameValueCollection> ctx = (Context<NameValueCollection>)context;
            
            // Select only the vXX params, and sort them.
            string[] allKeys = ctx.Payload.AllKeys;

            var sortedKeys = allKeys
                .OrderBy(k => k, new LogString2ParamsComparer())
                .Where(k => !String.IsNullOrEmpty(k))
                .Where(k => !k.Equals("v1", StringComparison.OrdinalIgnoreCase));

            var allKeysFinal = sortedKeys.ToArray();
            return allKeysFinal;

            // @@@ TODO Need to remove v1 and timestamp field
            // @@@ Need to sort?
            //return ctx.Payload.AllKeys;
        }
    }


    public class NumberRange : IEnumerable<int>
    {
        private int _min;
        private int _max;

        public NumberRange(int min, int max)
        {
            this._min = min;
            this._max = max;
        }

        public NumberRange(int max)
            : this(0, max)
        {
        }

        #region IEnumerable<int> Members

        public IEnumerator<int> GetEnumerator()
        {
            return new Enumerator(_min, _max);
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            return new Enumerator(_min, _max);
        }

        #endregion

        private class Enumerator : IEnumerator<int>
        {
            private int _current;
            private int _min;
            private int _max;
            private bool _moved;

            public Enumerator(int min, int max)
            {
                this._current = min;
                this._min = min;
                this._max = max;
                this._moved = false;
            }

            public int Current
            {
                get { return _current; }
            }

            public void Dispose()
            {
            }

            object IEnumerator.Current
            {
                get { return (object)_current; }
            }

            public bool MoveNext()
            {
                bool result;

                result = _moved ?
                    _current++ < _max :
                    _current <= _max;

                _moved = true;

                return result;
            }

            public void Reset()
            {
                _current = _min;
                _moved = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VeiOutputAdapter.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Adapters;

using xonline.common.mgmt;
using xonline.common.service;
namespace xonline.server.vortex.cake
{
    /// <summary>
    /// Configuration data for the CAKE Output Adapter.
    /// </summary>
    public class VeiOutputAdapterConfig
    {
        public VortexEventIngestionConfig InitialConfig { get; set; }
        public string QueryName { get; set; }
    }

    /// <summary>
    /// CAKE Output Adapter Factory.  This class is responsible for creating Untyped Point 
    /// Output Adapters.
    /// </summary>
    public class VeiOutputAdapterFactory : IOutputAdapterFactory<VeiOutputAdapterConfig>
    {
        /// <summary>
        /// This method creates an output adapter.
        /// </summary>
        /// <param name="configInfo">Configuration data used to drive output adapter configuration.</param>
        /// <param name="eventShape">Shape of event, this adapter factory only supports point shapes.</param>
        /// <param name="cepEventType">Type associated with the stream the adapter will be bound.</param>
        /// <returns>Returns a new instance of the Cake Output Adapter (VeiOutputAdapter).</returns>
        public OutputAdapterBase Create(VeiOutputAdapterConfig configInfo, EventShape eventShape, CepEventType cepEventType)
        {
            switch (eventShape)
            {
                case EventShape.Point:
                    return new VeiOutputAdapter(configInfo, cepEventType);
                default:
                    throw new InvalidOperationException("Unexpected event shape specified, Point expected: " + eventShape);
            }
        }

        /// <summary>
        /// Does nothing, this factory consumes no resources requiring explicit disposal.
        /// </summary>
        public void Dispose()
        {
        }
    }

    /// <summary>
    /// This output adapter is responsible for feeding the StreamInsight query
    /// processed events to their respective output destinations.
    /// </summary>
    /// <remarks>
    /// Process Overview - The Big Picture
    ///     1. Event arrives in StreamInsight InputStream from CAKE
    ///     2. The event is fed through one or more StreamInsight QueryTemplates
    ///     3. The event is finally queued into this output adapter processed.
    ///     4. This output adapter pulls events off the processed queue and sends them to SinkBuilder.
    ///     5. An object is built and dispatched via the IDispatchedSink associated with the SinkBuilder.
    /// </remarks>
    public class VeiOutputAdapter : PointOutputAdapter, IDynamicConfigurableAdapter
    {
        internal const string c_EventDestructionTraceMessage = "VeiOutputAdapter[{0}].DestroySinkBuilder() destroying sink builder associated with type='{1}'";
        internal const string c_EventUpdateSkippedTraceMessage = "VeiOutputAdapter[{0}].CreateSinkBuilders() using existing sink builder associated with type='{1}'";
        internal const string c_EventUpdatedTraceMessage = "VeiOutputAdapter[{0}].CreateSinkBuilders() updating sink builder associated with type='{1}'";
        internal const string c_EventAddedTraceMessage = "VeiOutputAdapter[{0}].CreateSinkBuilders() creating sink builder associated with type='{1}'";

        private VeiOutputAdapterConfig          _config;
        private CepEventType                    _cepEventType;
        private Dictionary<string, OMContext>   _omLookup;
        private QueryOutputPayloadReader        _payloadReader;

        /// <summary>
        /// Gets the name of the query this output adapter is bound to.
        /// </summary>
        public string QueryName
        {
            get
            {
                return _config.QueryName;
            }
        }

        /// <summary>
        /// Gets a description of the output adapter.  This description contains useful debugging information.
        /// </summary>
        public string Description
        {
            get
            {
                return string.Format("Output Adapter [QueryName={0}, QueryProjection={1}]", QueryName, _cepEventType.ShortName);
            }
        }

        /// <summary>
        /// Gets the SinkBuilders associated with the input adapter.
        /// </summary>
        internal Dictionary<string, OMContext> SinkBuilders
        {
            get
            {
                return _omLookup;
            }
        }

        /// <summary>
        /// Initializes a new instance of the VeiOutputAdapter.  SinkBuilders are initialized using the
        /// VortexEventIngestionConfig specified in the VeiOutputAdapterConfig data.
        /// </summary>
        /// <param name="config">Contains initialization contextual information.</param>
        /// <param name="cepEventType">Query output type associated with the StreamInsight query this output adapter is subscribed to.</param>
        public VeiOutputAdapter(VeiOutputAdapterConfig config, CepEventType cepEventType)
        {
            this._config = config;
            this._cepEventType = cepEventType;
            this._omLookup = new Dictionary<string, OMContext>();
            this._payloadReader = new QueryOutputPayloadReader(cepEventType);

            // supply initial configuration
            ConfigureAdapter(_config.InitialConfig);

            // sign-up for configuration change notification
            DynamicallyConfiguredAdapters.AddAdapter(this);
        }

        /// <summary>
        /// Disposes the external resources tied to this adapter.  The adapter is removed from
        /// the adapter configuration change notification list.
        /// </summary>
        /// <param name="disposing">Ignored parameter, perhaps the base class pays it some mind.</param>
        protected override void Dispose(bool disposing)
        {
            // remove from configuration notification tracking list
            DynamicallyConfiguredAdapters.RemoveAdapter(this);

            // configure an empty set of object mappers - this will destroy the existing
            try
            {
                ConfigureAdapter(new VortexEventIngestionConfig());
            }
            catch (Exception)
            { }

            base.Dispose(disposing);
        }

        /// <summary>
        /// Register object mappers associated with QueryTemplate this output adapter is subscribed to.
        /// </summary>
        /// <param name="config">Configuration data used to drive output adapter configuration.</param>
        /// <remarks>
        /// Note that this gets invoked upon initialization, and during run-time
        /// in response to setting changes.
        /// </remarks>
        public void ConfigureAdapter(VortexEventIngestionConfig config)
        {
            VortexQueryConfig queryConfig;
            List<VortexEventSinkConfig> creationCtx = null;

            if (!config.Queries.TryGetValue(QueryName, out queryConfig))
            {
                //Trace.High("VeiOutputAdapter[{0}].ConfigureInputAdapter() this event adapter contains no sink definitions", QueryName);

                Xom.NtEvent(
                    XEvent.Id.VORTEX_VEI_OUTPUT_ADAPTER_NO_SINKS,
                    "VeiOutputAdapter[{0}].ConfigureInputAdapter() this event adapter contains no sink definitions",
                    QueryName);

                // fatality!
                throw new ArgumentException("This output adapter contains no sink definitions for query " + QueryName);             
            }

            creationCtx = queryConfig.EventSinks.Values.ToList();

            // generate a list of removed sink builder - this list will drive destruction
            var destroyNames =
                (
                    from sb in _omLookup.Keys
                    where !creationCtx.Any(creation => creation.Name == sb)
                    select sb
                ).ToArray();

            // destroys all the sinks on the destruction list
            Array.ForEach(destroyNames, item => DestroySinkBuilder(item));

            // creates all the sinks on the creation list
            creationCtx.ForEach(item => CreateSinkBuilders(item.Name, item.InitParams, item.Recipe));
        }

        private void DestroySinkBuilder(string sink)
        {
            OMContext resident;

            lock (_omLookup)
            {
                if (_omLookup.TryGetValue(sink, out resident))
                {
                    Trace.Low(c_EventDestructionTraceMessage, QueryName, sink);

                    _omLookup.Remove(sink);
                }
                else
                {
                    Trace.Low("VeiOutputAdapter[{0}].DestroySinkBuilder() sink builder associated with type='{1}' was not found", QueryName, sink);
                }
            }
        }

        /// <summary>
        /// Creates and registers the SinkBuilder associated with the specified input event
        /// transformation recipe.
        /// </summary>
        /// <param name="sink">Name of the sink type associated with the sink builder.</param>
        /// <param name="mapper">Object mapper configuration information.  Contains all field recipes.</param>
        /// <remarks>
        /// This method relies on a table of hash values to determine if the specified object
        /// mapper has already been configured.  This is done to prevent an object mapper for
        /// registering for the same input event twice.
        /// </remarks>
        private void CreateSinkBuilders(string sink, string initParams, VortexObjectMapperConfig mapper)
        {
            OMContext resident;
            int hash;

            hash = mapper.GetHashCode();

            lock (_omLookup)
            {
                if (_omLookup.TryGetValue(sink, out resident))
                {
                    /// Attempt to short circuit object creation
                    if (hash == Interlocked.Exchange(ref resident.Hash, hash))
                    {
                        Trace.Low(c_EventUpdateSkippedTraceMessage, QueryName, sink);

                        return;
                    }

                    Trace.Low(c_EventUpdatedTraceMessage, QueryName, sink);

                    lock (resident)
                    {
                        _omLookup.Remove(sink);
                    }
                }
                else
                {
                    Trace.Low(c_EventAddedTraceMessage, QueryName, sink);

                    _omLookup[sink] = resident = new OMContext()
                    {
                        Hash = hash
                    };
                }
            }

            lock (resident)
            {
                Type type;

                if (TryGetType(sink, out type))
                {
                    var eb = SinkBuilder.Create(mapper, type, QueryName, initParams);

                    if (hash == Interlocked.CompareExchange(ref resident.Hash, hash, hash))
                    {
                        resident.Mapper = eb;
                    }
                    else
                    {
                        Trace.Low("VeiOutputAdapter[{0}].CreateSinkBuilders() sink builder hash mismatch for type='{1}' {2:X}!={3:X}", QueryName, sink, resident.Hash, hash);
                    }
                }
                else
                {
                    Trace.Error("VeiOutputAdapter[{0}].CreateSinkBuilders() error creating sink builder associated with type='{1}', target sink type not valid", QueryName, sink);

                    Xom.NtEvent(
                        XEvent.Id.VORTEX_VEI_OUTPUT_ADAPTER_INVALID_SINK,
                        "VeiOutputAdapter[{0}].CreateSinkBuilders() error creating sink builder associated with type='{1}', target sink type not valid",
                        QueryName,
                        sink);
                }
            }
        }

        /// <summary>
        /// Attempts to get the type associated with the specified type name.  The type specified by
        /// the name argument must exist and implement the IDispatchedSink interface.
        /// </summary>
        /// <param name="typeName">Name of the target type.</param>
        /// <param name="type">Receives the output type.</param>
        /// <returns>Returns a true indicating the type was found as is a valid IDispatchedSink; false otherwise.</returns>
        private bool TryGetType(string typeName, out Type type)
        {
            // Get the full namespace prefixed class name
            if (!typeName.Contains("."))
            {
                typeName = string.Format("{0}.{1}", typeof(VeiOutputAdapter).Namespace, typeName);
            }

            type = Type.GetType(typeName, false, true);

            return null != type && type.GetInterface(typeof(IDispatchedSink).Name) != null;
        }

        #region StreamInsight State Control

        /// <summary>
        /// StreamInsight state control, transitions the input adapter into an active state.
        /// Start the event pump.
        /// </summary>
        public override void Resume()
        {
            ConsumeEvents();
        }

        /// <summary>
        /// StreamInsight state control, transitions the input adapter into an active state.
        /// Start the event pump.
        /// </summary>
        public override void Start()
        {
            ConsumeEvents();
        }

        #endregion

        /// <summary>
        /// Consumes the events on the output adapter queue in response to Resume()
        /// and Start() StreamInsight state control calls.
        /// </summary>
        private void ConsumeEvents()
        {
            try
            {
                while (true)
                {
                    PointEvent current;

                    if (AdapterState.Stopping == AdapterState)
                    {
                        // the adapter is being asked to stop - process the last item if present

                        if (DequeueOperationResult.Success == Dequeue(out current))
                        {
                            // dispatch the item to the sinks
                            DispatchEvent(ref current);
                        }

                        // acknowledge stop
                        Stopped();

                        // give up StreamInsights worker thread
                        return;
                    }

                    // NOTE: at any point during execution of the code below, if the Adapter state
                    // changes to Stopping, the engine will resume the adapter (i.e. call Resume())
                    // one more time, and the stopping condition will be trapped at the check above.

                    if (DequeueOperationResult.Empty == Dequeue(out current))
                    {
                        // the adapter state is suspended or stopped.

                        // indicate readiness to be resumed
                        Ready();

                        // give up StreamInsights worker thread
                        return;
                    }
                    else
                    {
                        DispatchEvent(ref current);
                    }
                }
            }
            catch (Exception e)
            {
                Trace.Error("VeiOutputAdapter[{0}].ConsumeEvents() error consume event : {1}", QueryName, e);

                VortexCounters.Current.OuputEventDispatchFailures.Increment();
            }
        }

        /// <summary>
        /// Dispatches the event to the sink builders associated with StreamInsight Query
        /// this output adapter is bound to.
        /// </summary>
        /// <param name="current"></param>
        private void DispatchEvent(ref PointEvent current)
        {
            try
            {
                PayloadReader.Context payloadCtx;

                // only dispatch Insert events, ignore CTI
                if (current.EventKind == EventKind.Insert)
                {
                    // create a payload context for the current point event
                    payloadCtx = _payloadReader.CreateContext(current);

                    // contention should exist only between this and CreateSinkBuilder()
                    lock (_omLookup)
                    {
                        // map and dispatch the payload to all the sink builders
                        foreach (var pair in _omLookup)
                        {
                            try
                            {
                                pair.Value.Mapper.MapAndDispatchPayload(_payloadReader, payloadCtx);
                            }
                            catch (Exception e)
                            {
                                Trace.Error("VeiOutputAdapter[{0}].DispathEvent() error dispatching event to sink='{1}': {2}", QueryName, pair.Key, e);

                                VortexCounters.Current.OuputEventDispatchFailures.Increment();
                            }
                        }
                    }
                }
            }
            finally
            {
                // make sure to free up the native memory held by StreamInsight
                ReleaseEvent(ref current);
            }
        }

        /// <summary>
        /// Object Mapper contextual information, used in the update process to
        /// determine whether an existing mapper requires updating.
        /// </summary>
        internal sealed class OMContext
        {
            public SinkBuilder Mapper { get; set; }
            public int Hash;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VeiObjectMapper.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Reflection;
using System.IO;
using System.Threading;

using Microsoft.ComplexEventProcessing;
using xonline.common.utilities2;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.server.vortex.cake
{
    /// <summary>
    /// The Baker - abstract base class for the classes that map input data to
    /// to output data using the configuration perscribed recipe.
    /// </summary>
	public abstract class ObjectMapper
	{
        /// <summary>
        /// Delegate responsible for mapping the data in the source object to a field in the target
        /// object.
        /// </summary>
        /// <param name="pr">provides an interface into the target object data.</param>
        /// <param name="prc">provides contextual information, including the target object itself, used by the payload reader.</param>
        /// <param name="target">Object the field belongs to.</param>
        public delegate void FieldRecipe(PayloadReader pr, PayloadReader.Context prc, object target);

        private readonly static Dictionary<string, FieldRecipe> _expressionCache;
        
        private readonly List<FieldRecipe> _recipes;

        /// <summary>
        /// Initializes static expression caches.
        /// </summary>
        static ObjectMapper()
        {
            _expressionCache = new Dictionary<string, FieldRecipe>();
        }

        /// <summary>
        /// Initializes an instance of a subclass.
        /// </summary>
        public ObjectMapper()
        {
            _recipes = new List<FieldRecipe>();
        }

        /// <summary>
        /// Builds the field recipes for the fields in the target object type.
        /// </summary>
        /// <param name="config">Configuration data used to drive the process.</param>
        public void BuildRecipes(VortexObjectMapperConfig config)
        {
            // only build the recipes if they have not yet been built
            if (_recipes.Count == 0)
            {
                ConstructionParameters parameters;

                parameters = CreateConstructionParameters();

                foreach (var field in config.FieldExpressions)
                {
                    FieldRecipe recipe;
                    string key;

                    key = GetExpressionKey(field.Key, field.Value);

                    if (!string.IsNullOrEmpty(key) && _expressionCache.TryGetValue(key, out recipe))
                    {
                        Trace.Low("ObjectMapper.BuildRecipes() using cached expression for '{0}'", key);

                        _recipes.Add(recipe);
                    }
                    else
                    {
                        if (BuildFieldRecipe(parameters, field.Key, field.Value, out recipe))
                        {
                            _recipes.Add(recipe);

                            if (!string.IsNullOrEmpty(key))
                            {
                                Trace.Low("ObjectMapper.BuildRecipes() caching expression  in '{0}'", key);

                                _expressionCache[key] = recipe;
                            }
                        }
                    }
                    
                }
            }
        }

        /// <summary>
        /// Bakes a cake! Creates a new object of the target type and uses the Cake recipe to populate
        /// the fields of this new object, before dispatching it.
        /// </summary>
        /// <param name="reader">provides an interface to the source objects data.</param>
        /// <param name="context">contains contextual information for the reader, including the source object.</param>
        public void MapAndDispatchPayload(PayloadReader reader, PayloadReader.Context context)
        {
            object target;

            target = CreateTargetObject();

            _recipes.ForEach(fieldMap => fieldMap(reader, context, target));

            DispatchObject(target);
        }

        /// <summary>
        /// Create ExpressionTree construction parameters.  These parameters are the ones used
        /// by the top level lambda expression that eventually gets compiled in a FieldRecipe.
        /// </summary>
        /// <returns>Returns the ExpressionTree construction parameters.</returns>
        protected ConstructionParameters CreateConstructionParameters()
        {
            ObjectMapper.ConstructionParameters parameters;

            parameters = new ConstructionParameters();
            parameters.PayloadReader = Expression.Parameter(typeof(PayloadReader), "reader");
            parameters.PayloadReaderContext = Expression.Parameter(typeof(PayloadReader.Context), "context");
            parameters.TargetObject = Expression.Parameter(typeof(object), "obj");

            return parameters;
        }

        /// <summary>
        /// When implemented by the subclass, this method will be used to generate a
        /// key identifying the expression that can be used to reliably cache FieldExpressions.
        /// </summary>
        /// <param name="field">Name of the field the epxression belongs to.</param>
        /// <param name="expression">Recipe for constructing the field, uses the CAKE simple token language.</param>
        /// <returns>Returns a cache key.</returns>
        protected abstract string GetExpressionKey(string field, string expression);

        /// <summary>
        /// When implemented by the subclass, this method will be used to create an instance
        /// of the target object to be used in the object mapping process.
        /// </summary>
        /// <returns>Return an instance of the target object.</returns>
        protected abstract object CreateTargetObject();

        /// <summary>
        /// When implemented by the subclass, this method will be used build the field recipe for
        /// the specified field.  The mechanim to write the field value veries from subclass to 
        /// subclass which is why the work of constructing the expression is delegated to them.
        /// </summary>
        /// <param name="parameters">ExpressionTree construction parameters.</param>
        /// <param name="field">Name of the field being built.</param>
        /// <param name="expression">Recipe for constructing the field, uses the CAKE simple token language.</param>
        /// <param name="recipe">Compiled version of the recipe desribed by the expression parameter.</param>
        /// <returns>Returns a value indicating whether the expression should be added.</returns>
        protected abstract bool BuildFieldRecipe(ConstructionParameters parameters, string field, string expression, out FieldRecipe recipe);

        /// <summary>
        /// When implemented by the subclass, this method will be responsible for dispatching
        /// the recently mapped object.
        /// </summary>
        /// <param name="target">Object to dispatch.</param>
        protected abstract void DispatchObject(object target);

        #region Nested Classes

        /// <summary>
        /// ExpressionTree construction parameters.  These are the input parameters
        /// used by the ExpressionTree top level lambda expression.
        /// </summary>
        public struct ConstructionParameters
        {
            public ParameterExpression PayloadReader { get; set; }
            public ParameterExpression PayloadReaderContext { get; set; }
            public ParameterExpression TargetObject { get; set; }
            
            /// <summary>
            /// Returns an array containing the three lambda expression parameters. This
            /// is useful when building the LambdaExpression.
            /// </summary>
            /// <returns>Returns an array containing the three lambda expressions.</returns>
            public ParameterExpression[] GetParameterArray()
            {
                return new ParameterExpression[] {
                    PayloadReader,
                    PayloadReaderContext,
                    TargetObject
                };
            }
        }

        #endregion
    }

    /// <summary>
    /// An object mapper that is tooled for performing object mapping onto
    /// StreamInsight untyped events.
    /// </summary>
    public class EventBuilder : ObjectMapper
    {
        private static MethodInfo setFieldMethod;

        private VeiInputAdapter _inputAdapter;
        private CepEventType _eventType;
        private string _eventId;

        /// <summary>
        /// Static constructor used to initialize static MethodInfo cache.
        /// </summary>
        static EventBuilder()
        {
            Type[] parameters;

            parameters = new Type[] { typeof(int), typeof(object) };

            setFieldMethod = typeof(Event).GetMethod("SetField", parameters);
        }

        /// <summary>
        /// Creates an instance of the EventBuilder type and builds the recipes.
        /// </summary>
        /// <param name="config">Configuration object containing recipe details.</param>
        /// <param name="eventType">Streaming binding type information.</param>
        /// <param name="eventId">EventId associated with the processing.</param>
        /// <param name="inputAdapter">InputAdapter this EventBuilder is bound to.</param>
        /// <returns>Returns an EventBuilder instance.</returns>
        public static EventBuilder Create(VortexObjectMapperConfig config, CepEventType eventType, string eventId, VeiInputAdapter inputAdapter)
        {
            EventBuilder result;

            result = new EventBuilder(eventType, eventId, inputAdapter);
            result.BuildRecipes(config);

            return result;
        }

        /// <summary>
        /// Initializes a new instance of the EventBuilder class.
        /// </summary>
        /// <param name="eventType">Streaming binding type information.</param>
        /// <param name="eventId">EventId associated with the processing.</param>
        /// <param name="inputAdapter">InputAdapter this EventBuilder is bound to.</param>
        private EventBuilder(CepEventType eventType, string eventId, VeiInputAdapter inputAdapter)
        {
            this._eventType = eventType;
            this._eventId = eventId;
            this._inputAdapter = inputAdapter;
        }

        /// <summary>
        /// Generates a key identifying the field expression, which can be used to reliably 
        /// cache FieldExpressions.
        /// </summary>
        /// <param name="field">Name of the field the epxression belongs to.</param>
        /// <param name="expression">Recipe for constructing the field, uses the CAKE simple token language.</param>
        /// <returns>Returns a cache key or null if not supported.</returns>
        protected override string GetExpressionKey(string field, string expression)
        {
            CepEventTypeField eventField;

            if (_eventType.Fields.TryGetValue(field, out eventField))
            {
                return string.Format("({0}){1}={2}", eventField.Type.ClrType.Name, eventField.Ordinal, expression);
            }

            return null;
        }

        /// <summary>
        /// Creates a new instance of the Event type to be used as the target of
        /// the object mapping process.
        /// </summary>
        /// <returns>Return an instance of the target object.</returns>
        protected override object CreateTargetObject()
        {
            return new Event();
        }

        /// <summary>
        /// Build the recipe associated with the specified field and expression.
        /// </summary>
        /// <param name="parameters">ExpressionTree construction parameters.</param>
        /// <param name="field">Name of the field being built.</param>
        /// <param name="expression">Recipe for constructing the field, uses the CAKE simple token language.</param>
        /// <param name="recipe">Compiled version of the recipe desribed by the expression parameter.</param>
        /// <returns>Returns a value indicating whether the expression should be added.</returns>
        /// <remarks>
        /// Fields are rejected if and only if the specified field is not present in the set of fields
        /// exposed by the event type associated with the bound stream.
        /// </remarks>
        protected override bool BuildFieldRecipe(ObjectMapper.ConstructionParameters parameters, string field, string expression, out ObjectMapper.FieldRecipe recipe)
        {
            CepEventTypeField eventField;

            recipe = null;

            if (_eventType.Fields.TryGetValue(field, out eventField))
            {
                // create an expression that invokes the SetField method with the specified value
                recipe = Expression.Lambda<ObjectMapper.FieldRecipe>(
                    Expression.Call(
                        Expression.Convert(parameters.TargetObject, typeof(Event)),
                        setFieldMethod, 
                        Expression.Constant(eventField.Ordinal), 
                        Expression.Convert(TextParser.GenerateExpressionTree(parameters, expression, eventField.Type.ClrType), typeof(object))),
                    parameters.GetParameterArray()).Compile();

                return true;
            }
            else
            {
                Trace.Error("EventBuilder.BuildFieldRecipe() error field '{0}' expected in stream '{1}' for event id '{2}'", field, _inputAdapter.StreamName, _eventId);
                
                Xom.NtEvent(
                    XEvent.Id.VORTEX_VEI_EVENT_BUILDER_FIELD_MISSING,
                    "EventBuilder.BuildFieldRecipe() error field '{0}' expected in stream '{1}' for event id '{2}'", 
                    field, 
                    _inputAdapter.StreamName, 
                    _eventId);

                return false;
            }
        }

        /// <summary>
        /// Enqueues the event in the InputAdapter this EventBuilder is bound to.
        /// </summary>
        /// <param name="target">PointEvent to enqueue.</param>
        protected override void DispatchObject(object target)
        {
            _inputAdapter.EnqueueEvent((Event)target);
        }

        /// <summary>
        /// Light weight event object handled by the EventBuilder.
        /// </summary>
        public class Event
        {
            private static long CurrentSequenceNumber = 0;

            public Dictionary<int, object> Fields { get; set; }
            public DateTime StartTime { get; set; }
            public readonly long SequenceNumber;

            /// <summary>
            /// Initializes a new instance of the Event type.
            /// </summary>
            public Event()
            {
                Fields = new Dictionary<int, object>();
                StartTime = DateTime.UtcNow;
                SequenceNumber = Interlocked.Increment(ref CurrentSequenceNumber);
            }

            /// <summary>
            /// Updates the value for an ordinal identified field.
            /// </summary>
            /// <param name="ordinal">Ordinal associated with the updated field.</param>
            /// <param name="value">Value to assign to the field.</param>
            public void SetField(int ordinal, object value)
            {
                Fields[ordinal] = value;
            }
        }
    }

    /// <summary>
    /// An object mapper that is tooled for performing object mapping onto
    /// IDispatchedSink types.
    /// </summary>
    public class SinkBuilder : ObjectMapper
    {
        private static string _requiredInterface = typeof(IDispatchedSink).Name;

        private Type _targetType;
        private string _queryName;

        /// <summary>
        /// Creates an instance of the SinkBuilder type and builds the recipes.
        /// </summary>
        /// <param name="config">Configuration object containing recipe details.</param>
        /// <param name="targetType">IDispatchedSink type whose fields are render by this recipe.</param>
        /// <param name="queryName">The name of the query that provides the input data for this SinkBuilder.</param>
        /// <returns>Returns an SinkBuilder instance.</returns>
        public static SinkBuilder Create(VortexObjectMapperConfig config, Type targetType, string queryName, string initParams)
        {
            SinkBuilder result;

            // All SinkBuilder types must implement the IDispatchedSink interface
            if (targetType.GetInterface(_requiredInterface) == null)
            {
                throw new InvalidDataException(string.Format(
                    "targetType '{0}' does not implement the {1} interface", 
                    targetType.Name, 
                    _requiredInterface));
            }

            result = new SinkBuilder(targetType, queryName);
            result.BuildRecipes(config);

            var method = targetType.GetMethod("Initialize", BindingFlags.Static | BindingFlags.Public);
            if (method != null)
            {
                Trace.Normal("SinkBuilder: Initializing sink {0} for query {1} with params \"{2}\"",
                    targetType.Name, queryName, initParams);
                method.Invoke(null, new object[] { queryName, initParams });
            }
            else
            {
                Xom.NtEvent(XEvent.Id.VORTEX_SINKBUILDER_NO_INITIALIZE, 
                    "SinkBuilder: Unable to initialize sink {0} for query {1} with params \"{2}\" - can't find static Initialize(string, string) method.",
                    targetType.Name, queryName, initParams);
            }
            return result;
        }

        /// <summary>
        /// Intializes a new instance of the SinkBuilder type.
        /// </summary>
        /// <param name="targetType">IDispatchedSink type whose fields are render by this recipe.</param>
        /// <param name="queryName">The name of the query that provides the input data for this SinkBuilder.</param>
        private SinkBuilder(Type targetType, string queryName)
        {
            this._targetType = targetType;
            this._queryName = queryName;
        }

        /// <summary>
        /// Generates a key identifying the field expression, which can be used to reliably 
        /// cache FieldExpressions.
        /// </summary>
        /// <param name="field">Name of the field the epxression belongs to.</param>
        /// <param name="expression">Recipe for constructing the field, uses the CAKE simple token language.</param>
        /// <returns>Returns a cache key or null if not supported.</returns>
        protected override string GetExpressionKey(string field, string expression)
        {
            MethodInfo propertySetterMethod;

            propertySetterMethod = _targetType.GetMethod("set_" + field);

            if (null != propertySetterMethod)
            {
                return string.Format("({0}){1}.{2}={3}", propertySetterMethod.GetParameters()[0].ParameterType, _targetType.FullName, field, expression);
            }

            return null;
        }

        /// <summary>
        /// Creates a new instance of the Event type to be used as the target of
        /// the object mapping process.
        /// </summary>
        /// <returns>Return an instance of the target object.</returns>
        protected override object CreateTargetObject()
        {
            return Activator.CreateInstance(_targetType);
        }

        /// <summary>
        /// Build the recipe associated with the specified field and expression.
        /// </summary>
        /// <param name="parameters">ExpressionTree construction parameters.</param>
        /// <param name="field">Name of the field being built.</param>
        /// <param name="expression">Recipe for constructing the field, uses the CAKE simple token language.</param>
        /// <param name="recipe">Compiled version of the recipe desribed by the expression parameter.</param>
        /// <returns>Returns a value indicating whether the expression should be added.</returns>
        /// <remarks>
        /// Fields are rejected if and only if the specified field is not present in the set of properties
        /// with setters exposed by the target IDispatchedSink type associated with this EventBuilder.
        /// </remarks>
        protected override bool BuildFieldRecipe(ObjectMapper.ConstructionParameters parameters, string field, string expression, out ObjectMapper.FieldRecipe recipe)
        {
            MethodInfo propertySetterMethod;

            recipe = null;

            // locate method associated with the setter on the specified property
            propertySetterMethod = _targetType.GetMethod("set_" + field);

            if (null != propertySetterMethod)
            {
                recipe = Expression.Lambda<ObjectMapper.FieldRecipe>(
                    Expression.Call(
                        Expression.Convert(parameters.TargetObject, _targetType), 
                        propertySetterMethod, 
                        TextParser.GenerateExpressionTree(parameters, expression, propertySetterMethod.GetParameters()[0].ParameterType)),
                    parameters.GetParameterArray()).Compile();

                return true;
            }
            else
            {
                Trace.Error("SinkBuilder.BuildFieldRecipe() error field '{0}' expected in type '{1}' for query '{2}'", field, _targetType.FullName, _queryName);

                Xom.NtEvent(
                    XEvent.Id.VORTEX_VEI_SINK_BUILDER_FIELD_MISSING,
                    "SinkBuilder.BuildFieldRecipe() error field '{0}' expected in type '{1}' for query '{2}'",
                    field,
                    _targetType.FullName,
                    _queryName);

                return false;
            }
        }

        /// <summary>
        /// Executes the target IDispatchedSink's custom Dispatch logic.
        /// </summary>
        /// <param name="target">PointEvent to enqueue.</param>
        protected override void DispatchObject(object target)
        {
            ((IDispatchedSink)target).Dispatch();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VeiSink.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.vortex.cake
{
    public interface IDispatchedSink
    {
        void Dispatch();

        // Must also implement this:
        //     static void Initialize(string queryName, string initParams);
        // @@@ But I don't know how to force that into an interface.
    }

	class VeiSink
	{
	}

    /// <summary>
    /// This EventSink is responsible dispatching events via Xom logging
    /// areas.  The properties exposed by this EventSink participate
    /// in configuring the log area.
    /// </summary>
    public class XomLogEventSink : IDispatchedSink
    {
        /// <summary>
        /// Name of the logging area.
        /// </summary>
        public string XomLogArea                { get; set; }
        
        /// <summary>
        /// Integer value of the enum for xonline.common.mgmt.LogLevel i.e. L_NORMAL=1, which is the default
        /// </summary>
        public sbyte  XomLogLevel               { get; set; }
        
        /// <summary>
        /// Indicates whether a trace should be written for this message
        /// </summary>
        public bool   WriteToTrace              { get; set; }

        /// <summary>
        /// Message to send to the specified xom log area
        /// </summary>
        public string Message                   { get; set; }

        /// <summary>
        /// Optional flow token for logline
        /// </summary>
        public ulong FlowToken                  { get; set; }

        /// <summary>
        /// Initializes a new instance of the XomLogEventSink.  Initializes the default
        /// values for this type.
        /// </summary>
        public XomLogEventSink()
        {
            XomLogLevel = (int)LogLevel.L_NORMAL;
            WriteToTrace = true;
        }

        static public void Initialize(string queryName, string initParams)
        {
            //string areaName = (string)parameters[0];
            //string areaSettings = (string)parameters[1];

            XomLoggingControl.RegisterNewArea("Vx" + queryName, initParams);
        }

        /// <summary>
        /// Writes the payload to the Xom log area, and trace if the event message allows it.
        /// </summary>
        public void Dispatch()
        {
            LogLevel level;

            if (Enum.IsDefined(typeof(LogLevel), XomLogLevel))
            {
                level = (LogLevel)XomLogLevel;
            }
            else
            {
                Trace.Low("XomLogEventSink.Dispatch() error the specified XomLogLevel '{0}' is not valid, using the default value of L_NORMAL.", XomLogLevel);

                level = LogLevel.L_NORMAL;
            }

            try
            {
                Floken floken = new Floken(FlowToken);
                Xom.Trace(XomLogArea, new XomLogTargetContext(floken), level, "{0}", Message);
            }
            catch (Exception e)
            {
                Trace.Error("XomLogEventSink.Dispatch() error writing trace, area='{0}', level='{1}', error='{2}'", XomLogArea, level, e.Message);
            }

            if (WriteToTrace)
            {
                Trace.Low("[{0}] {1}", XomLogArea, Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VortexCommon.cs ===
// VortexCommon.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Generic holder 
// 
// Author: kgoodier 10/2009
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;

using xonline.common.mgmt;

namespace xonline.server.vortex
{

/// <summary>
/// Represents a basic event (message). Does minimal parsing of the payload, which is represented
/// as a big string and nothing more. As the event flows through the Vortex system, the fields may
/// get refined with better and more accurate values by specialized parsers.
/// </summary>
public class GenericStringEvent
{
    public DateTime Timestamp { get; set; }
    public string Id { get; set; }
    public string RawPayload { get; set; }

    /// <summary>
    /// Given the 'GenericStringEvent.ToString()' representation of an event, parses it.
    /// </summary>
    /// <param name="line"></param>
    /// <returns>true if succeeded, false if failed.</returns>
    public bool Parse(string line)
    {
        int idxSep1;
        int idxSep2;
        string timestamp;

        idxSep1 = line.IndexOf("|", 0);
        if (idxSep1 > -1)
        {
            timestamp = line.Substring(0, idxSep1);
            try
            {
                this.Timestamp = DateTime.Parse(timestamp);
            }
            catch (Exception)
            {
                this.Timestamp = DateTime.MinValue;
            }

            idxSep2 = line.IndexOf("|", idxSep1 + 1);
            if (idxSep2 > -1)
            {
                this.Id = line.Substring(idxSep1 + 1, idxSep2 - idxSep1 - 1);
                if (line.Length > idxSep2 + 1)
                {
                    this.RawPayload = line.Substring(idxSep2 + 1);
                }
                // RawPayload is optional, as long as we have a timestamp and id
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Converts to a '|' separated representation.
    /// </summary>
    public override string ToString()
    {
        return String.Format("{0}|{1}|{2}", Timestamp.ToString("yyyy/MM/dd HH:mm:ss.fff"), Id, RawPayload);
    }
}


/// <summary>
/// Represent a basic event with the payload parsed into name/value pairs. Useful for input
/// like the WebInstrumentation format, which provides delimted fields contained name/value
/// pairs. 
/// </summary>
public class GenericParsedEvent
{
    public DateTime Timestamp { get; set; }
    public string Id { get; set; }
    public NameValueCollection Fields { get; set; }

    public bool ParseFields(string line)
    {
        return ParseFields(line, '|');
    }

    public bool ParseFields(string line, char separator)
    {
        Fields = new NameValueCollection();

        string[] fields = line.Split(separator);
        foreach (string field in fields)
        {
            string[] pairs = field.Split('=');
            if (pairs.Length == 1)
            {
                Fields.Add(null, pairs[0]);
            }
            else if (pairs.Length == 2)
            {
                Fields.Add(pairs[0], pairs[1]);
            }
            else
            {
                // @@@ uhhhh
                return false;
            }
        }

        return true;
    }

    public override string ToString()
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendFormat("{0}|{1}", Timestamp, Id);
        foreach (string fieldName in Fields.Keys)
        {
            string prefix = String.IsNullOrEmpty(fieldName) ? "" : (fieldName + "=");
            string[] fieldValues = Fields.GetValues(fieldName);
            if (fieldValues != null)
            {
                foreach (string fieldValue in fieldValues)
                {
                    sb.AppendFormat("|{0}{1}", prefix, fieldValue);
                }
            }
        }
        return sb.ToString();
    }
}


/// <summary>
/// Trace class - handy wrappers for making tracing prettier and easier 
/// </summary>
internal static class Trace
{
    internal static void Low(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.VortexTrace, LogLevel.L_LOW, format, args);
    }

    internal static void Normal(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.VortexTrace, LogLevel.L_NORMAL, format, args);
    }

    internal static void High(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.VortexTrace, LogLevel.L_HIGH, format, args);
    }

    internal static void Error(string format, params object[] args)
    {
        Xom.Trace(XomAreaName.VortexTrace, LogLevel.L_ERROR, format, args);
    }

    private static string Timestamp
    {
        get
        {
            DateTime dt = DateTime.Now;
            return dt.ToString(@"hh:mm:ss.fff ");
        }
    }

}





} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VeiInputAdapter.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Adapters;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.vortex.cake
{
    /// <summary>
    /// Configuration data for the CAKE Input Adapter.
    /// </summary>
    public class VeiInputAdapterConfig
    {
        public VortexEventIngestionConfig InitialConfig { get; set; }
        public int MaxEventQueueSize { get; set; }
        public string StreamName { get; set; }
    }

    /// <summary>
    /// CAKE Input Adapter Factory.  This class is responsible for creating Untyped Point 
    /// Input Adapters.
    /// </summary>
    public class VeiInputAdapterFactory : IInputAdapterFactory<VeiInputAdapterConfig>
    {
        /// <summary>
        /// This method creates an input adapter.
        /// </summary>
        /// <param name="configInfo">Configuration data used to drive input adapter configuration.</param>
        /// <param name="eventShape">Shape of event, this adapter factory only supports point shapes.</param>
        /// <param name="cepEventType">Type associated with the stream the adapter will be bound.</param>
        /// <returns>Returns a new instance of the Cake Input Adapter (VeiInputAdapter).</returns>
        public InputAdapterBase Create(VeiInputAdapterConfig configInfo, EventShape eventShape, CepEventType cepEventType)
        {
            switch (eventShape)
            {
                case EventShape.Point:
                    return new VeiInputAdapter(configInfo, cepEventType);
                default:
                    throw new InvalidOperationException("Unexpected event shape specified, Point expected: " + eventShape);
            }
        }

        /// <summary>
        /// Does nothing, this factory consumes no resources requiring explicit disposal.
        /// </summary>
        public void Dispose()
        {
        }
    }

    /// <summary>
    /// This input adapter is responsible for feeding the CAKE processed events into
    /// the stream insight queries.  ObjectMappers are configured here as well.
    /// </summary>
    /// <remarks>
    /// Process Overview - The Big Picture
    ///     1. Event arrives at one of the input providers
    ///     2. The event is identified, a payload reader, and payload reader context is provided
    ///     3. Each object mapper subscribed to the specific event will transform the payload to an EventBuiler.Event
    ///     4. Transformed EventBuilder.Events are pushed to queue of the input adapter associated with object mapper
    ///     5. Input adapters read EventBuilder.Events from the queue and map them to PointEvents and send them to StreamInsight
    /// </remarks>
    public class VeiInputAdapter : PointInputAdapter, IDynamicConfigurableAdapter
	{
        internal const string c_EventDestructionTraceMessage = "VeiInputAdapter[{0}].DestroyEventBuilder() destroying event builder associated with id='{1}'";
        internal const string c_EventUpdateSkippedTraceMessage = "VeiInputAdapter[{0}].CreateEventBuilders() using existing event builder associated with id='{1}'";
        internal const string c_EventUpdatedTraceMessage = "VeiInputAdapter[{0}].CreateEventBuilders() updating event builder associated with id='{1}'";
        internal const string c_EventAddedTraceMessage = "VeiInputAdapter[{0}].CreateEventBuilders() creating event builder associated with id='{1}'";

        private VeiInputAdapterConfig           _config;
        private CepEventType                    _cepEventType;
        private Dictionary<string, OMContext>   _omLookup;
        private Queue<EventBuilder.Event>       _eventQueue;
        private AutoResetEvent                  _queueFilled;

        /// <summary>
        /// Gets the name associated with stream this input adapter is bound to.
        /// </summary>
        public string StreamName
        {
            get
            {
                return _config.StreamName;
            }
        }

        /// <summary>
        /// Gets a description of the input adapter.  This description contains useful debugging information.
        /// </summary>
        public string Description
        {
            get
            {

                return string.Format("Input Adapter [StreamName={0}, StreamType={1}]", StreamName, _cepEventType.ShortName);
            }
        }

        /// <summary>
        /// Gets the EventBuilders associated with the input adapter.
        /// </summary>
        internal Dictionary<string, OMContext> EventBuilders
        {
            get
            {
                return _omLookup;
            }
        }

        /// <summary>
        /// Intializes a instance of the VeiInputAdapter.  During initialization the
        /// object mappers associated with this input adapter will be created.
        /// </summary>
        /// <param name="config">Configuration data used to drive input adapter configuration.</param>
        /// <param name="cepEventType">Type associated with the stream the adapter will be bound.</param>
        public VeiInputAdapter(VeiInputAdapterConfig config, CepEventType cepEventType)
        {
            this._config = config;
            this._cepEventType = cepEventType;
            this._omLookup = new Dictionary<string, OMContext>();
            this._eventQueue = new Queue<EventBuilder.Event>();
            this._queueFilled = new AutoResetEvent(false);
            
            // supply initial configuration
            ConfigureAdapter(config.InitialConfig);

            // sign-up for configuration change notification
            DynamicallyConfiguredAdapters.AddAdapter(this);
        }

        /// <summary>
        /// Disposes the external resources tied to this adapter.  The adapter is removed from
        /// the adapter configuration change notification list.
        /// </summary>
        /// <param name="disposing">Ignored parameter, perhaps the base class pays it some mind.</param>
        protected override void Dispose(bool disposing)
        {
            // remove from configuration notification tracking list
            DynamicallyConfiguredAdapters.RemoveAdapter(this);

            // configure an empty set of object mappers - this will destroy the existing
            ConfigureAdapter(new VortexEventIngestionConfig());

            base.Dispose(disposing);
        }

        /// <summary>
        /// Register object mappers associated with the attached input stream.
        /// </summary>
        /// <param name="config">Configuration data used to drive input adapter configuration.</param>
        /// <remarks>
        /// Note that this gets invoked upon initialization, and during run-time
        /// in response to setting changes.
        /// </remarks>
        public void ConfigureAdapter(VortexEventIngestionConfig config)
        {
            // generate a list of specified event builders - both named and wildcarded
            var creationCtx =
                (   // select named entries
                    from nlc in config.NamedLogs
                    where nlc.Value.Streams.ContainsKey(StreamName)
                    from om in nlc.Value.Streams[StreamName].Recipes
                    select new StreamContext()
                    {
                        Log = nlc.Value,
                        Mapper = om
                    }
                ).Union
                (   // select wildcard entries
                    from nlc in config.WildCardLogs
                    where nlc.Streams.ContainsKey(StreamName)
                    from om in nlc.Streams[StreamName].Recipes
                    select new StreamContext()
                    {
                        Log = nlc,
                        Mapper = om
                    }
                ).ToArray();

            // generate a list of removed event builders - this list will drive destruction
            var destroyNames =
                (
                    from e in _omLookup.Keys
                    where !Array.Exists(creationCtx, sc => sc.Log.Identifier == e)
                    select e
                ).ToArray();

            
            // Destroy the unmentioned event builders
            Array.ForEach(
                destroyNames,
                id => DestroyEventBuiler(id));

            // Create the event builders
            Array.ForEach(
                creationCtx,
                omctx => CreateEventBuilders(omctx.Log.Identifier, omctx.Log.HasWildCards, omctx.Mapper));
        }

        /// <summary>
        /// Performs the work neccessary to removing an object mapper from the system.
        /// </summary>
        /// <param name="logId"></param>
        /// <remarks>
        /// Subscriptions for the associated object mapper are destroyed.  The object mapper
        /// is also removed from the object mapper lookup table.
        /// </remarks>
        private void DestroyEventBuiler(string logId)
        {
            OMContext resident;

            lock (_omLookup)
            {
                if (_omLookup.TryGetValue(logId, out resident))
                {
                    Trace.Low(c_EventDestructionTraceMessage, _config.StreamName, logId);

                    UnRegisterObjectMapper(logId, resident.HasWildCards, resident.Mapper);

                    _omLookup.Remove(logId);
                }
                else
                {
                    Trace.Low("VeiInputAdapter[{0}].DestroyEventBuilder() event builder associated with id='{1}' was not found", _config.StreamName, logId);
                }
            }
        }

        /// <summary>
        /// Creates and registers the EventBuilder associated with the specified input event
        /// transformation recipe.
        /// </summary>
        /// <param name="logId">Input Event Identifier the created event builder will subscribe to.</param>
        /// <param name="hasWildcards">Indicates whether the indentifier contains wildcards.</param>
        /// <param name="mapper">Object mapper configuration information.  Contains all field recipes.</param>
        /// <remarks>
        /// This method relies on a table of hash values to determine if the specified object
        /// mapper has already been configured.  This is done to prevent an object mapper for
        /// registering for the same input event twice.
        /// </remarks>
        private void CreateEventBuilders(string logId, bool hasWildcards, VortexObjectMapperConfig mapper)
        {
            OMContext resident;
            int hash;

            hash = mapper.GetHashCode();

            lock (_omLookup)
            {
                if (_omLookup.TryGetValue(logId, out resident))
                {
                    /// Attempt to short circuit object creation
                    if (hash == Interlocked.Exchange(ref resident.Hash, hash))
                    {
                        Trace.Low(c_EventUpdateSkippedTraceMessage, _config.StreamName, logId);

                        return;
                    }

                    Trace.Low(c_EventUpdatedTraceMessage, _config.StreamName, logId);

                    lock (resident)
                    {
                        UnRegisterObjectMapper(logId, resident.HasWildCards, resident.Mapper);
                    }

                    resident.HasWildCards = hasWildcards;
                }
                else
                {
                    Trace.Low(c_EventAddedTraceMessage, _config.StreamName, logId);

                    _omLookup[logId] = resident = new OMContext()
                    {
                        Hash = hash,
                        HasWildCards = hasWildcards
                    };
                }
            }

            lock (resident)
            {
                var eb = EventBuilder.Create(mapper, _cepEventType, logId, this);

                if (hash == Interlocked.CompareExchange(ref resident.Hash, hash, hash))
                {
                    resident.Mapper = eb;
                    RegisterObjectMapper(logId, resident.HasWildCards, eb);
                }
                else
                {
                    Trace.Low("VeiInputAdapter[{0}].CreateEventBuilders() event builder hash mismatch for log='{1}' {2:X}!={3:X}", StreamName, logId, resident.Hash, hash);
                }
            }
        }

        /// <summary>
        /// Subscribes the specified event builder to the specified log event identitier.
        /// </summary>
        /// <param name="logId">Input Event id to subscribe the specified event builder to.</param>
        /// <param name="hasWildcards">Indicates whether wildcards are present in the identifier.</param>
        /// <param name="builder">Target EventBuilder.</param>
        public void RegisterObjectMapper(string logId, bool hasWildcards, EventBuilder builder)
        {
            VeiEventDispatcher.InputDispatcher.RegisterSubscription(logId, hasWildcards, builder);
        }

        /// <summary>
        /// Unsubscribes the specified event builder from the specified log event identifier.
        /// </summary>
        /// <param name="logId">Input Event ident to unsubscribe the specified event builder from.</param>
        /// <param name="hasWildcards">Indicates whether wildcards are present in the identifier.</param>
        /// <param name="builder">Target EventBuilder.</param>
        public void UnRegisterObjectMapper(string logId, bool hasWildcards, EventBuilder builder)
        {
            VeiEventDispatcher.InputDispatcher.UnregisterSubscription(logId, hasWildcards, builder);
        }

        /// <summary>
        /// Moves the intermediate event object to the queue.  Intermediate objects are used due
        /// to StreamInsight imposed requirements on the lifetime of StreamInsight events.
        /// </summary>
        /// <param name="ev">Target object mapped intermediate event.</param>
        public void EnqueueEvent(EventBuilder.Event ev)
        {
            int  maxQueue = Math.Max(_config.MaxEventQueueSize, 0);
            bool eviction = false;

            lock (_eventQueue)
            {
                if (maxQueue == 0 || _eventQueue.Count < maxQueue)
                {
                    _eventQueue.Enqueue(ev);

                    VortexCounters.Current.IncomingMessageQueue.Increment();
                }
                else
                {
                    _eventQueue.Dequeue();

                    _eventQueue.Enqueue(ev);

                    eviction = true;
                }
            }

            // post message about eviction
            if (eviction)
            {
                Trace.High("VeiInputAdapter[{0}].EnqueueEvent() an old event was evicted from queue.", _config.StreamName);

                VortexCounters.Current.InputQueueEvictions.Increment();
            }

            IndicateEventAvailable();
        }

        #region StreamInsight State Control

        /// <summary>
        /// StreamInsight state control, transitions the input adapter into an active state.
        /// Start the event pump.
        /// </summary>
        public override void Resume()
        {
            Xom.NtEvent(XEvent.Id.VORTEX_VEI_INPUT_ADAPTER_RESUME, "VeiInputAdapter[{0}].Start() input adapter resumed ", _config.StreamName);
            
            Trace.High("VeiInputAdapter[{0}].Start() input adapter resumed ", _config.StreamName);
            
            IntermediateEventPump();
        }

        /// <summary>
        /// StreamInsight state control, transitions the input adapter into an active state.
        /// Start the event pump.
        /// </summary>
        public override void Start()
        {
            Xom.NtEvent(XEvent.Id.VORTEX_VEI_INPUT_ADAPTER_START, "VeiInputAdapter[{0}].Start() input adapter started ", _config.StreamName);

            Trace.High("VeiInputAdapter[{0}].Start() input adapter started ", _config.StreamName);

            IntermediateEventPump();
        }

        #endregion

        /// <summary>
        /// Waits for an immediate event to become available.  This method blocks if there
        /// are no items in the queue for 50ms or until an item arrives in the queue, which
        /// ever one comes first.
        /// </summary>
        /// <returns>Returns a value indicating whether a value is present in the queue.</returns>
        private bool WaitForEvents()
        {
            int timeout = 50; //TODO::Promote to a setting

            return _eventQueue.Count > 0 || _queueFilled.WaitOne(timeout, false);
        }

        /// <summary>
        /// Indicates that an event is available in the intermediate event queue.
        /// </summary>
        private void IndicateEventAvailable()
        {
            _queueFilled.Set();
        }

        /// <summary>
        /// Drains the intermediate event pump, converter each intermediate event into
        /// an untyped point event and moving it to the StreamInsight event queue.
        /// </summary>
        private void IntermediateEventPump()
        {
            // Run until StreamInsight indicates that you need to stop
            while (true)
            {
                while (!WaitForEvents())
                {
                    // StreamInsight communicated its intention to stop - acknowledge and exit
                    if (AdapterState.Stopping == AdapterState)
                    {
                        Stopped();
                        return;
                    }
                }

                // StreamInsight communicated its intention to stop - acknowledge and exit
                if (AdapterState.Stopping == AdapterState)
                {
                    Stopped();
                    return;
                }

                // Drain all the events from the intermediate event queue
                while (_eventQueue.Count > 0)
                {
                    var point = CreateInsertEvent();
                    var item = _eventQueue.Peek();

                    if (null == point)
                    {
                        IndicateEventAvailable();

                        break;
                    }

                    try
                    {
                        // Get start time and preprocessed fields from intermediate object
                        point.StartTime = item.StartTime;
                        foreach (var field in item.Fields)
                        {
                            point.SetField(field.Key, field.Value);
                        }

                        // Attempt to move the StreamInsight event to the StreamInsight event queue
                        var result = Enqueue(ref point);

                        if (EnqueueOperationResult.Full == result)
                        {
                            // No more room - release event quit for now so StreamInsight can catch up
                            ReleaseEvent(ref point);
                            point = null;
                            Ready();

                            return;
                        }
                        else
                        {
                            point = null;
                            // StreamInsight event successfully added, so remove the intermediate event from the queue.
                            lock (_eventQueue)
                            {
                                // Make sure the expected intermediate event has not been evicted already
                                if (item.SequenceNumber == _eventQueue.Peek().SequenceNumber)
                                {
                                    _eventQueue.Dequeue();
                                }
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        if (point != null)
                        {
                            ReleaseEvent(ref point);
                            point = null;
                        }

                        Trace.Error("VeiInputAdapter[{0}].EnqueueEvent() : adapter event processing error : {1}", _config.StreamName, e.Message);

                        Xom.NtEvent(
                            XEvent.Id.VORTEX_VEI_INPUT_ADAPTER_CONSUMPTION_ERROR,
                            e,
                            "VeiInputAdapter[{0}].EnqueueEvent() unexpected exception encountered while processing events",
                            StreamName);
                    }
                }
            }
        }

        /// <summary>
        /// Initialization contextual information structure used to capture
        /// the associated LINQ results.
        /// </summary>
        private struct StreamContext
        {
            public VortexLogConfig          Log { get; set; }
            public VortexObjectMapperConfig Mapper { get; set; }
        }

        /// <summary>
        /// Object Mapper contextual information, used in the update process to
        /// determine whether an existing mapper requires updating.
        /// </summary>
        internal sealed class OMContext
        {
            public EventBuilder Mapper { get; set; }
            public bool         HasWildCards { get; set; }
            public int          Hash;
        }
	}

    /// <summary>
    /// Class responsible for managing object mapper subscriptions to both
    /// in-flowing and out-flowing events.
    /// </summary>
    public sealed class VeiEventDispatcher
    {
        public readonly static VeiEventDispatcher InputDispatcher = new VeiEventDispatcher();

        private readonly List<KeyValuePair<string, WildcardInfo>> _wildcardNameRegistry;
        private readonly Dictionary<string, List<ObjectMapper>> _nameRegistry;
        private readonly ReaderWriterLockSlim _wnlock;
        private readonly ReaderWriterLockSlim _nlock;

        /// <summary>
        /// Initializes a new instance of the VeiEventDispatcher class, duh.
        /// </summary>
        private VeiEventDispatcher()
        {
            _wildcardNameRegistry = new List<KeyValuePair<string, WildcardInfo>>();
            _nameRegistry = new Dictionary<string,List<ObjectMapper>>();
            _wnlock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
            _nlock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
        }

        /// <summary>
        /// Dispatches the event to all the object mappers subscribed to it
        /// either via direct name or wildcard name match.
        /// </summary>
        /// <param name="reader">PayloadReader capable of reading the payload.</param>
        /// <param name="payload">Payload carrying the event data.</param>
        public void DispatchEvent(PayloadReader reader, object payload)
        {
            PayloadReader.Context context = reader.CreateContext(payload);
            bool dispatched = false;

            // Attempt to dispatch to the wildcard subscribers
            _wnlock.EnterReadLock();
            try
            {
                foreach (var set in _wildcardNameRegistry)
                {
                    if (set.Value.RegularExpression.IsMatch(context.Identifier))
                    {
                        if (set.Value.Subscribers.Count > 0)
                        {
                            set.Value.Subscribers.ForEach((om) => { om.MapAndDispatchPayload(reader, context); });
                            dispatched = true;
                        }
                    }
                }
            }
            finally
            {
                _wnlock.ExitReadLock();
            }

            // Attempt to dispatch to the named subscribers
            _nlock.EnterReadLock();
            try
            {
                List<ObjectMapper> subscribers;

                if (_nameRegistry.TryGetValue(context.Identifier, out subscribers))
                {
                    if (subscribers.Count > 0)
                    {
                        subscribers.ForEach((om) => { om.MapAndDispatchPayload(reader, context); });
                        dispatched = true;
                    }
                }
            }
            finally
            {
                _nlock.ExitReadLock();
            }

            if (dispatched == false)
            {
                Trace.High("VeiEventDispatcher.DispatchEvent() event with identifier '{0}' was not dispatched", context.Identifier);

                VortexCounters.Current.UndispatchedOutputEvents.Increment();
            }

        }

        /// <summary>
        /// Subscribes an object mapper to the specified event source.
        /// </summary>
        /// <param name="identifier">Identifier associated target event source.</param>
        /// <param name="wildcard">Determines whether the identifier contains wild cards.</param>
        /// <param name="mapper">Object mapper to subscribe to the specified event source.</param>
        public void RegisterSubscription(string identifier, bool wildcard, ObjectMapper mapper)
        {
            if (wildcard)
            {
                _wnlock.EnterWriteLock();
                try
                {
                    var item = _wildcardNameRegistry.Find(i => i.Key == identifier);

                    // create a new entry if the item is not found, as indicated by presence of default(T)
                    if (string.IsNullOrEmpty(item.Key))
                    {
                        item = new KeyValuePair<string, WildcardInfo>(identifier, new WildcardInfo(identifier));
                        
                        _wildcardNameRegistry.Add(item);
                    }

                    Trace.Low("VeiEventDispatcher.RegisterSubscription() wildcarded entry registered id={0}", identifier);

                    item.Value.Subscribers.Add(mapper);
                }
                finally
                {
                    _wnlock.ExitWriteLock();
                }
            }
            else
            {
                _nlock.EnterWriteLock();
                try
                {
                    List<ObjectMapper> mappers;

                    // create a new entry if the item is not found
                    if (!_nameRegistry.TryGetValue(identifier, out mappers))
                    {
                        mappers = new List<ObjectMapper>();

                        _nameRegistry[identifier] = mappers;
                    }

                    Trace.Low("VeiEventDispatcher.RegisterSubscription() named entry registered id={0}", identifier);

                    mappers.Add(mapper);
                }
                finally
                {
                    _nlock.ExitWriteLock();
                }
            }
        }

        /// <summary>
        /// Unsubscribes an object mapper to the specified event source.
        /// </summary>
        /// <param name="identifier">Identifier associated target event source.</param>
        /// <param name="wildcard">Determines whether the identifier contains wild cards.</param>
        /// <param name="mapper">Object mapper to unsubscribe from the specified event source.</param>
        public void UnregisterSubscription(string identifier, bool wildcard, ObjectMapper mapper)
        {
            if (wildcard)
            {
                _wnlock.EnterWriteLock();
                try
                {
                    var item = _wildcardNameRegistry.Find(i => i.Key == identifier);

                    // entry found, remove this mapper from the subscriber list
                    if (!string.IsNullOrEmpty(item.Key))
                    {
                        Trace.Low("VeiEventDispatcher.UnregisterSubscription() wildcarded entry unregistered id={0}", identifier);

                        item.Value.Subscribers.Remove(mapper);
                    }
                    else
                    {
                        Trace.Low("VeiEventDispatcher.UnregisterSubscription() wildcarded entry not found id={0}", identifier);
                    }
                }
                finally
                {
                    _wnlock.ExitWriteLock();
                }
            }
            else
            {
                _nlock.EnterWriteLock();
                try
                {
                    List<ObjectMapper> mappers;

                    // entry found, remove this mapper from the subscriber list
                    if (_nameRegistry.TryGetValue(identifier, out mappers))
                    {
                        Trace.Low("VeiEventDispatcher.UnregisterSubscription() named entry unregistered id={0}", identifier);

                        mappers.Remove(mapper);
                    }
                    else
                    {
                        Trace.Low("VeiEventDispatcher.UnregisterSubscription() named entry not found id={0}", identifier);
                    }
                }
                finally
                {
                    _nlock.ExitWriteLock();
                }
            }
        }

        /// <summary>
        /// Wildcard event subscriber information.
        /// </summary>
        private struct WildcardInfo
        {
            public Regex RegularExpression { get; set; }
            public List<ObjectMapper> Subscribers { get; set; }

            /// <summary>
            /// Initializes a new instance of the WildcardInfo structure.
            /// </summary>
            /// <param name="identifier">Identifier used to create the regular expression.</param>
            public WildcardInfo(string identifier) : this()
            {
                // sanitize the string a bit first
                identifier = identifier.Replace(".", @"\.");
                identifier = identifier.Replace("%", @".*");

                RegularExpression = new Regex("^" + identifier + "$");
                Subscribers = new List<ObjectMapper>();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestCake.cs ===
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Reflection;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;

using xonline.server.vortex;
using xonline.server.vortex.cake;

namespace xonline.test.vortexdvt
{
    [TestGroup, DVT]
    public partial class CAKE
    {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VortexConfig.cs ===
// VortexConfig.cs
//
// Copyright (c) 2009 Microsoft Corporation. All Rights Reserved.
//
// Vortex Service
// Xbox Live
//
// Nice configuration wrapper
// 
// Author: kgoodier 10/2009
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.IO;
using System.Threading;
using System.Reflection;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.utilities2;

using xonline.server.vortex.cake;

namespace xonline.server.vortex
{

public delegate void VortexSettingsChanged(VortexConfig vc);

public class VortexSettingsConfig
{
    public string ComponentName { get; set; }
    public int? HttpPort { get; set; }
    public string HttpPrefix { get; set; }
    public int? UdpPort { get; set; }
    public string StreamInsightMgmtIp { get; set; }
    public int? StreamInsightMgmtPort { get; set; }

    public int? MaxIOThreads { get; set; }
    public int? MinIOThreads { get; set; }
    public int? MaxWorkerThreads { get; set; }
    public int? MinWorkerThreads { get; set; }
    public int? DefaultEventTypeCountWindowSeconds { get; set; }
    public int? DefaultInputEventQueueSize { get; set; }

    internal void Merge(VortexSettingsConfig vsc)
    {
        // Note: vsc gets priority, but not every field is necessarily specified.

        if (!String.IsNullOrEmpty(vsc.ComponentName))       ComponentName = vsc.ComponentName;
        if (vsc.HttpPort != null)                           HttpPort = vsc.HttpPort;
        if (!String.IsNullOrEmpty(vsc.HttpPrefix))          HttpPrefix = vsc.HttpPrefix;
        if (vsc.UdpPort != null)                            UdpPort = vsc.UdpPort;
        if (!String.IsNullOrEmpty(vsc.StreamInsightMgmtIp)) StreamInsightMgmtIp = vsc.StreamInsightMgmtIp;
        if (vsc.StreamInsightMgmtPort != null)              StreamInsightMgmtPort = vsc.StreamInsightMgmtPort;

        if (vsc.MaxIOThreads != null)                       MaxIOThreads = vsc.MaxIOThreads;
        if (vsc.MaxWorkerThreads != null)                   MaxWorkerThreads = vsc.MaxWorkerThreads;
        if (vsc.MinIOThreads != null)                       MinIOThreads = vsc.MinIOThreads;
        if (vsc.MinWorkerThreads != null)                   MinWorkerThreads = vsc.MinWorkerThreads;
        if (vsc.DefaultEventTypeCountWindowSeconds != null) DefaultEventTypeCountWindowSeconds = vsc.DefaultEventTypeCountWindowSeconds;
        if (vsc.DefaultInputEventQueueSize != null)         DefaultInputEventQueueSize = vsc.DefaultInputEventQueueSize;
    }
}

#region StreamInsight Query Configuration - imported from tool

// What does this config class mean?
// - we can bind input to either the CAKE input adapter or other queries.
// - we can bind output to the CAKE output adapter or a named stream.
// - we support point events only
// - we cannot bind input to an arbitrary input adapter.
// - we cannot bind output to an arbitrary output adapter.
// - we do not support interval or edge events. though, this depends on input,
//   so maybe CAKE can help with this.
//

public class QueryConfig
{
    public string QueryName;
    public string QueryDescription;
    public string QueryTemplateShortName;

    // One per query template input stream
    public InputBindingConfig[] InputBindings;

    // Only one output
    public OutputBindingConfig OutputBinding;
}

public class InputBindingConfig
{
    // Required
    public string BindToQueryTemplateStreamName;

    // Optional-ish. If null, assumes CAKE input adapter. If not null, binds to
    // an existing query's output. If can't find that, tries a published stream 
    // name (?).
    public string InputQueryName { get; set; }

    // Optional. Good defaults provided otherwise.
    public double? TimeAdvanceFrequencyInSeconds { get; set; }
    public uint? TimeAdvanceFrequencyInEvents { get; set; }
    public double? TimeAdvanceSlackInSeconds { get; set; }
    public string EventShape { get; set; }
}

public class OutputBindingConfig
{
    // Optional. If null, constructs a meaningful default name and sends output
    // to CAKE output adapter. If not null, publishes to a name but doesn't
    // hook up to an output adapter. The published name will look like:
    //     cep:/Server/Application/MyApp/PublishedStream/<OutputQueryName>
    public string OutputPublishedStreamName { get; set; }

    // Optional. Good defaults provided otherwise.
    public string EventShape { get; set; }
}

#endregion

public class VortexConfig
{
    // Input file
    const string c_VortexConfigFile     = "VortexConfig.xml";

    // Output file
    const string c_VortexConfigLogFile  = "VortexConfigLog.xml";

    // Singleton
    private static VortexConfig _instance = null;
    public static VortexConfig Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = VortexConfig.Create();
            }
            return _instance;
        }
    }

    // Called whenever the settings have changed
    public static event VortexSettingsChanged OnVortexSettingsChanged;

    // Helpers
    private static FileSystemWatcher _FileWatcher;
    private static int _ConfigReloadScheduled = 0;

    // NOTE: Members here get serialized to/from XML

    // Configuration objects
    public VortexSettingsConfig Settings { get; set; }
    public VortexEventIngestionConfig EventIngestion { get; set; }
    public SerializableDictionary<string, QueryConfig> StreamInsightQueries { get; set; }

    static VortexConfig()
    {
        // Register for setting changes
        Config.SettingChange += OnSettingChange;
    }

    public VortexConfig()
    {
        Settings = new VortexSettingsConfig();
        StreamInsightQueries = new SerializableDictionary<string, QueryConfig>();
    }

    private static VortexConfig Create()
    {
        //_FileWatcherChangeCount = 0;

        // Watch for changes to the local config file
        _FileWatcher = new FileSystemWatcher();
        _FileWatcher.Path = System.Environment.CurrentDirectory;
        _FileWatcher.Filter = c_VortexConfigFile;
        _FileWatcher.NotifyFilter = NotifyFilters.LastWrite;
        _FileWatcher.Changed += new FileSystemEventHandler(OnConfigFileChanged);
        _FileWatcher.EnableRaisingEvents = true;

        VortexConfig vortexConfig = null;
        VortexConfig vortexConfigXml = null;

        // Try to load initial from npdb
        vortexConfig = LoadFromNpdb();

        // Merge in local xml
        vortexConfigXml = LoadFromXml(c_VortexConfigFile);

        // Merge
        vortexConfig.MergeConfig(vortexConfigXml);

        // Save it
        SaveToXml(c_VortexConfigLogFile, vortexConfig);

        return vortexConfig;
    }

    /// <summary>
    /// Loads config from the NPDB. Will not throw an exception.
    /// </summary>
    /// <returns>Config object if successful, null if not.</returns>
    private static VortexConfig LoadFromNpdb()
    {
        Trace.Normal("VortexConfig: Loading config from NPDB");
        VortexConfig vc = new VortexConfig();
        try
        {
            IInterfaceInfo iiHttp = Config.GetInterface(Interface.vortexinh);
            IInterfaceInfo iiUdp = Config.GetInterface(Interface.vortexinh_udp);

            vc.Settings = new VortexSettingsConfig()
            {
                ComponentName = Config.ComponentName,
                HttpPort = iiHttp.Port,
                HttpPrefix = iiHttp.VDir,
                UdpPort = iiUdp.Port,
                StreamInsightMgmtIp = iiHttp.IPAddress.ToString(),
                StreamInsightMgmtPort = iiHttp.Port,

                MaxIOThreads = Config.GetIntSetting(Setting.vortex_maxIoThreads),
                MinIOThreads = Config.GetIntSetting(Setting.vortex_minIoThreads),
                MaxWorkerThreads = Config.GetIntSetting(Setting.vortex_maxWorkerThreads),
                MinWorkerThreads = Config.GetIntSetting(Setting.vortex_minWorkerThreads),
                DefaultEventTypeCountWindowSeconds = Config.GetIntSetting(Setting.vortex_defaultEventTypeCountWindowSeconds),
                DefaultInputEventQueueSize = Config.GetIntSetting(Setting.vortex_defaultInputEventQueueSize)
            };

            vc.EventIngestion = VortexEventIngestionConfig.LoadFromNpdb();

            //
            // Populate StreamInsight query instances. 
            // Fake it for now. Put it in NPDB later.
            //

            var qc = new QueryConfig()
            {
                QueryName = "PassthroughQuery",
                QueryDescription = "Basic passthrough of string payloads",
                QueryTemplateShortName = "PassthroughTemplate",
                InputBindings = new InputBindingConfig[]
                {
                    new InputBindingConfig() {
                        BindToQueryTemplateStreamName = "PassthroughEvent",
                        TimeAdvanceFrequencyInEvents = 1,
                        TimeAdvanceSlackInSeconds = 0
                    }
                },
                OutputBinding = new OutputBindingConfig()
                {
                }
            };
            vc.StreamInsightQueries[qc.QueryName] = qc;

            qc = new QueryConfig()
            {
                QueryName = "EventTypeCountQuery",
                QueryDescription = "Counts of all unique events",
                QueryTemplateShortName = "EventTypeCountTemplate",
                InputBindings = new InputBindingConfig[]
                {
                    new InputBindingConfig() {
                        BindToQueryTemplateStreamName = "EventCountEvent"
                    }
                },
                OutputBinding = new OutputBindingConfig()
                {
                }
            };
            vc.StreamInsightQueries[qc.QueryName] = qc;


            return vc;
        }
        catch (Exception e)
        {
            Trace.Error("Unable to load config from NPDB");
            Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_NPDB, e,
                        "Error while loading configuration from NPDB. Service will attempt local config.");
        }
        
        return vc;
    }

    /// <summary>
    /// Loads config from an XML file. Will not throw an exception.
    /// </summary>
    /// <param name="inputFilename"></param>
    /// <returns>Config object if successful, null if not</returns>
    private static VortexConfig LoadFromXml(string inputFilename)
    {
        Trace.Normal("VortexConfig: Loading config from {0}", inputFilename);
        try
        {
            XmlSerializerNamespaces xsn = new XmlSerializerNamespaces();
            xsn.Add(String.Empty, String.Empty);
            XmlSerializer serializer = new XmlSerializer(typeof(VortexConfig));

            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.CheckCharacters = false;
            using (XmlReader reader = XmlReader.Create(inputFilename, xmlSettings))
            {
                object o = serializer.Deserialize(reader);
                return (VortexConfig)o;
            }
        }
        catch (FileNotFoundException)
        {
            Trace.Normal("Unable to find local config file {0}", inputFilename);
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_LOCAL, e,
                        "Error while loading configuration from local xml file {0}. This config info will not be merged in.",
                        inputFilename);
        }

        return null;
    }

    /// <summary>
    /// Merge vc with current configuration. Input vc gets priority.
    /// </summary>
    /// <param name="vc">VortexConfig to be merged</param>
    private void MergeConfig(VortexConfig vc)
    {
        Trace.Normal("VortexConfig: Merging NPDB and local configuration");

        if (vc == null)
        {
            return;
        }

        this.Settings.Merge(vc.Settings);

        foreach (var kvp in vc.StreamInsightQueries)
        {
            this.StreamInsightQueries[kvp.Key] = kvp.Value;
        }

        foreach (var namedLog in vc.EventIngestion.NamedLogs.Values)
        {
            this.EventIngestion.NamedLogs[namedLog.Identifier] = namedLog;
        }

        foreach (var wildcardLog in vc.EventIngestion.WildCardLogs)
        {
            // note the wildcard identifiers are normalized
            int index = this.EventIngestion.WildCardLogs.FindIndex(v => v.Identifier == wildcardLog.Identifier);

            if (-1 == index)
            {
                // entry does not exist, add new
                this.EventIngestion.WildCardLogs.Add(wildcardLog);
            }
            else
            {
                // wildcard identifier is present in existing set, update existing definition
                this.EventIngestion.WildCardLogs[index] = wildcardLog;
            }
        }

        foreach (var query in vc.EventIngestion.Queries.Values)
        {
            this.EventIngestion.Queries[query.Name] = query;
        }
    }

    /// <summary>
    /// Serializes a VortexConfig to an XML file. Will not throw an exception.
    /// </summary>
    /// <param name="outputFilename"></param>
    /// <param name="vc"></param>
    private static void SaveToXml(string outputFilename, VortexConfig vc)
    {
        Trace.Normal("VortexConfig: Saving configuration to {0}", outputFilename);

        try
        {
            XmlSerializerNamespaces xsn = new XmlSerializerNamespaces();
            xsn.Add(String.Empty, String.Empty);
            XmlSerializer serializer = new XmlSerializer(typeof(VortexConfig));

            XmlWriterSettings xmlSettings = new XmlWriterSettings();
            xmlSettings.CheckCharacters = false;
            xmlSettings.Encoding = System.Text.Encoding.ASCII;
            xmlSettings.NewLineHandling = NewLineHandling.Entitize;
            xmlSettings.NewLineOnAttributes = false;
            xmlSettings.Indent = true;
            using (XmlWriter writer = XmlWriter.Create(outputFilename, xmlSettings))
            {
                serializer.Serialize(writer, vc, xsn);
            }
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_SAVE, e,
                        "Error while saving configuration to xml file {0}. This is for reference only.",
                        outputFilename);
        }
    }

    // -------------------------------------------------------------------------
    // ScheduleConfigReload - schedules a full reload of all settings 2 seconds
    // in the future on a background thread.
    // -------------------------------------------------------------------------
    private static void ScheduleConfigReload()
    {
        int fReloadAlreadyScheduled = Interlocked.CompareExchange(ref _ConfigReloadScheduled, 1, 0);
        if (fReloadAlreadyScheduled == 1)
        {
            // Already have a pending reload
            Trace.Normal("Config reload already scheduled");
            return;
        }

        // Spawn this off on another thread so we can get our back-to-back callbacks. 
        // This event seems to be called synchronously when the config file changes,
        // and npdb setting changes are likely to happen in groups. So let's just do
        // one actual reload, k?

        ThreadPool.QueueUserWorkItem((WaitCallback)(s =>
        {
            // Note: s is unused
            try
            {
                try
                {
                    // Pause a bit, wait for other quick writes to happen
                    Thread.Sleep(2000);
                }
                finally
                {
                    // Let other things get scheduled now. This is the last chance we can
                    // do this and not miss any potential changes, as the remaining reload
                    // code is not atomic.
                    _ConfigReloadScheduled = 0;
                }

                Trace.Normal("Reloading config...");
                
                // Do delayed action of retrieving new settings
                VortexConfig vc = LoadFromNpdb();
                VortexConfig.Instance.MergeConfig(vc);

                // Local overrides
                VortexConfig vc2 = LoadFromXml(c_VortexConfigFile);
                VortexConfig.Instance.MergeConfig(vc2);

                // Tell everybody
                VortexConfig.OnVortexSettingsChanged(VortexConfig.Instance);

                Trace.Normal("Done reloading config.");
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_CONFIG_RELOAD, e,
                            "Error while reloading settings. Ignoring change.");
            }
        }));
    }

    // -------------------------------------------------------------------------
    // OnSettingChange - handles changes to local xml file settings
    // -------------------------------------------------------------------------
    private static void OnConfigFileChanged(object sender, FileSystemEventArgs eventArgs)
    {
        Trace.Normal("Config file \"{0}\" changed, scheduling a reload", c_VortexConfigFile);
        ScheduleConfigReload();
    }

    // -------------------------------------------------------------------------
    // OnSettingChange - handles changes to npdb settings
    // -------------------------------------------------------------------------
    private static void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
    {
        Trace.Normal("NPDB setting \"{0}\" changed to value \"{1}\", scheduling a reload", eventArgs.Setting, eventArgs.ValueNew); 
        ScheduleConfigReload();
    }

}

}  // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestBinaryProtocol.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Data;
using System.Data.Sql;
using System.Data.SqlClient;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
using System.Data.SqlTypes;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;
using xonline.common.utilities2;
using xonline.common.protocol;
using xonline.common.core.etx;
using xonline.common.sql.sqlclient;

namespace xonline.test.vortexdvt 
{

[TestGroup, DVT]
[CompoundCase("VortexFD", VirtualInterface.vortexfd, VirtualInterface.vortexfd_udp)]
[CompoundCase("VortexINH", VirtualInterface.vortexinh, VirtualInterface.vortexinh_udp)]
public partial class ProtocolTests 
{

    // Splunk regular expressions for the SOMETHINGCOOL events:
    //
    // # For VortexDVT
    // EXTRACT-COOLSTART = ^[^\|]+\|(?:FT\w+\|)?SOMETHINGCOOLSTART\|(?P<ClientTimestamp>[^\|]*)\|(?P<IpAddress>[^\|]*)\|(?P<MachineId>[^\|]*)\|(?P<Resource>[^\|]*)
    // EXTRACT-COOLEND = ^[^\|]+\|(?:FT\w+\|)?SOMETHINGCOOLEND\|(?P<ClientTimestamp>[^\|]*)\|(?P<IpAddress>[^\|]*)\|(?P<Resource>[^\|]*)\|(?P<Status>[^\|]*)
    // 

    public static string DvtManifestString = 
@"<?xml version='1.0' encoding='utf-8'?>
<etxmanifest
    xmlns:win='http://manifests.microsoft.com/win/2004/08/windows/events'
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
>
  <instrumentation>
    <globaleventproducers>
      <producer symbol='DvtTestProducer' id='E5743D51C3384707B95A75D457945A38'>
        <description>Description of DvtTestProducer</description>
        <events>
          <event value='0' symbol='TestEvent1' logstringid='TESTEVT1' category='Standard' header='1'>
            <description>Description of TestEvent1</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='TestInt' inType='Int32'/>
              <data ordinal='3' name='TestString' inType='AnsiString'/>
              <data ordinal='4' name='SeqNum' inType='UInt64'/>
            </datafields>
          </event>
          <event value='1' symbol='TestEvent2' logstringid='TESTEVT2' category='Standard' header='1'>
            <description>Description of TestEvent2</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='TestInt' inType='Int32'/>
              <data ordinal='3' name='TestString' inType='AnsiString'/>
              <data ordinal='4' name='TestNegative' inType='Int16'/>
              <data ordinal='5' name='TestFloat' inType='Double'/>
              <data ordinal='6' name='SeqNum' inType='UInt64'/>
              <data ordinal='7' name='MachineId' inType='UInt64' autovalue='MachineId' autovaluecreator='LiveService'/>
            </datafields>
          </event>
          <event value='2' symbol='TestEvent3' logstringid='TESTEVT3' category='Standard' header='1'>
            <description>Description of TestEvent3</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='TestInt' inType='Int32'/>
              <data ordinal='3' name='SeqNum' inType='UInt64'/>
              <data ordinal='4' name='Timestamp' inType='UInt64' autovalue='Timestamp' autovaluecreator='LiveService'/>
              <data ordinal='5' name='IPAddress' inType='UInt32' autovalue='Ipv4Address' autovaluecreator='LiveService'/>
              <data ordinal='6' name='MachineId' inType='UInt64' autovalue='MachineId' autovaluecreator='LiveService'/>
              <data ordinal='7' name='FlowToken' inType='UInt64' autovalue='FlowToken' autovaluecreator='LiveService'/>
              <data ordinal='8' name='TestString' inType='AnsiString'/>
            </datafields>
          </event>
          <event value='3' symbol='StartSomethingCool' logstringid='SOMETHINGCOOLSTART' category='Standard' header='1'>
            <description>Start event for something really cool</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='ClientTimestamp' inType='Int64'/>
              <data ordinal='3' name='IPAddress' inType='AnsiString' autovalue='Ipv4Address' autovaluecreator='LiveService'/>
              <data ordinal='4' name='MachineId' inType='UInt64' autovalue='MachineId' autovaluecreator='LiveService'/>
              <data ordinal='5' name='Resource' inType='AnsiString'/>
            </datafields>
          </event>
          <event value='4' symbol='EndSomethingCool' logstringid='SOMETHINGCOOLEND' category='Standard' header='1'>
            <description>End event for something really cool</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='ClientTimestamp' inType='Int64'/>
              <data ordinal='3' name='IPAddress' inType='AnsiString' autovalue='Ipv4Address' autovaluecreator='LiveService'/>
              <data ordinal='4' name='Resource' inType='AnsiString'/>
              <data ordinal='5' name='Status' inType='UInt32'/>
            </datafields>
          </event>
          <event value='5' symbol='SigninTime' logstringid='SigninTime' category='Standard' header='1'>
            <description>Existing SiginTime event for testing of StringSvr measurement perf counters</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='ElapsedTime' inType='UInt32'/>
              <data ordinal='3' name='SeqNum' inType='UInt64'/>
            </datafields>
          </event>
          <event value='6' symbol='EPIXDownloadFail' logstringid='EPIXDownloadFail' category='Standard' header='1'>
            <description>Existing EPIXDownloadFail event for testing of StringSvr failure perf counters</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='Url' inType='AnsiString'/>
              <data ordinal='3' name='SeqNum' inType='UInt64'/>
            </datafields>
          </event>
          <event value='7' symbol='TestEvent4' logstringid='TESTEVT4' category='Standard' header='1'>
            <description>Description of TestEvent4</description>
            <datafields>
              <data ordinal='1' name='SeqNum' inType='UInt64'/>
              <data ordinal='2' name='Timestamp' inType='UInt64' autovalue='Timestamp' autovaluecreator='LiveService'/>
              <data ordinal='3' name='Timestamp2' inType='UInt64' autovalue='Timestamp' autovaluecreator='LiveUploaderDynamic'/>
              <data ordinal='4' name='Timestamp3' inType='AnsiString' autovalue='Timestamp' autovaluecreator='LiveUploaderDynamic'/>
              <data ordinal='5' name='SampleFiletime' inType='UInt64'/>
              <data ordinal='6' name='SampleGuid' inType='GUID' />
              <data ordinal='7' name='SampleFlowtoken' inType='UInt64' autovalue='FlowToken' autovaluecreator='LogMacro' />
              <data ordinal='8' name='Marker' inType='AnsiString' />
            </datafields>
          </event>
          <event value='8' symbol='TestEvent10' logstringid='TESTEVT10' category='Standard' header='1'>
            <description>More autovalue tests</description>
            <datafields>
              <data ordinal='1' name='SeqNum' inType='UInt64'/>
              <data ordinal='2' name='CountryId' inType='UInt8' autovalue='CountryId' autovaluecreator='LiveService'/>
              <data ordinal='3' name='CountryIdString' inType='AnsiString' autovalue='CountryId' autovaluecreator='LiveService'/>
              <data ordinal='4' name='CultureId' inType='AnsiString' autovalue='CultureId' autovaluecreator='LiveService'/>
              <data ordinal='5' name='LanguageId' inType='UInt8' autovalue='LanguageId' autovaluecreator='LiveService'/>
              <data ordinal='6' name='LanguageIdString' inType='AnsiString' autovalue='LanguageId' autovaluecreator='LiveService'/>
              <data ordinal='7' name='MembershipType' inType='UInt8' autovalue='MembershipType' autovaluecreator='LiveService'/>
              <data ordinal='8' name='MembershipTypeString' inType='AnsiString' autovalue='MembershipType' autovaluecreator='LiveService'/>
            </datafields>
          </event>
          <event value='9' symbol='TestEventOutTypes' logstringid='TESTEVTOUTTYPES' category='Standard' header='1'>
            <description>More autovalue tests</description>
            <datafields>
              <data ordinal='1' name='SeqNum' inType='UInt64'/>
              <data ordinal='2' name='HResult' inType='UInt32' outType='HResult'/>
              <data ordinal='3' name='Title' inType='UInt32' outType='TitleName'/>
            </datafields>
          </event>

        </events>
      </producer>
    </globaleventproducers>
  </instrumentation>
</etxmanifest>";

    private static void RemoveEventOrProducer(Blob blobId)
    {
        string sqlDelMappings = String.Format("delete from t_etx_producer_event_mappings where vb_producer_fingerprint = 0x{0} or vb_event_fingerprint = 0x{0}", blobId);
        string sqlDelEvents = String.Format("delete from t_etx_manifest_events where vb_event_fingerprint = 0x{0}", blobId);
        string sqlDelProducers = String.Format("delete from t_etx_manifest_producers where vb_producer_fingerprint = 0x{0}", blobId);


        string connStr = Config.GetSingleInterface(Interface.npdb).SqlConnectionString;
        
        using (SqlConnection sql = new SqlConnection(connStr))
        {
            sql.Open();

            using (SqlCommand cmd = new SqlCommand(sqlDelMappings, sql))
            {
                cmd.CommandType = CommandType.Text;
                cmd.ExecuteNonQuery();
            }
            using (SqlCommand cmd = new SqlCommand(sqlDelEvents, sql))
            {
                cmd.CommandType = CommandType.Text;
                cmd.ExecuteNonQuery();
            }

            using (SqlCommand cmd = new SqlCommand(sqlDelProducers, sql))
            {
                cmd.CommandType = CommandType.Text;
                cmd.ExecuteNonQuery();
            }                
        }

    }

    [TestCase, Description("Remove ETX manifest for DVTs from NPDB")]
    public void RemoveDvtManifest()
    {
        EtxManifest man = new EtxManifest(System.Xml.Linq.XElement.Parse(DvtManifestString));
        foreach (Producer p in man.Producers)
        {
            foreach (Event e in p.Events)
                RemoveEventOrProducer(e.Fingerprint);
            RemoveEventOrProducer(p.Fingerprint);
        }
        Global.XEnv.ForceConfigReload(VortexUtil.vortex_Interface);

    }

    [TestCase, Description("Prop ETX manifest for DVTs to NPDB")]
    public void PropDvtManifest()
    {
        EtxManifest man = new EtxManifest(System.Xml.Linq.XElement.Parse(DvtManifestString));
        foreach (Producer p in man.Producers)
        {
            EtxLoader.NPDB.UploadProducer(p);
        }
        Global.XEnv.ForceConfigReload(VortexUtil.vortex_Interface);
    }

    [TestGroup, DVT]
    [CompoundCase("DirectUdp", 0)]
    [CompoundCase("SgUdp", 1)]
    [CompoundCase("LogBinary", 2)]
    public class BinaryProtocol : VortexDVTTestBaseGroup
    {
        private IVxTransport _transport;

        public void Reset()
        {
            _transport = null;
            Init();
        }

        public void Init()
        {
            if (_transport != null)
                return;

            string virtualInterface = (string)Parent.Parent.MyValues[0];
            string virtualInterfaceUdp = (string)Parent.Parent.MyValues[1];

            int transType = (int)MyValues[0];
            switch (transType)
            {
            case 0:
                _transport = new DirectUdpTransport(virtualInterfaceUdp);
                break;
            case 1:
                _transport = new SgUdpTransport(virtualInterfaceUdp);
                break;
            case 2:
                _transport = new LogBinaryTransport(virtualInterface);
                break;
            }
        }

        public void Send(byte[] message)
        {
            Init();
            _transport.Send(message);
        }

        public byte[] MakeVxMessage(uint baseEventId, params object[] fields)
        {
            return MakeVxMessage(baseEventId, new object[][] { fields });
        }

        public byte[] MakeVxMessage(uint baseEventId, object[][] fields)
        {
            MemoryStream ms = new MemoryStream(1000);
            VortexBinaryWriter bw = new VortexBinaryWriter(ms);

            // Protocol
            bw.Write((byte)VxProtocol.VxProtocolType.Etx);  // 1=Etx
            // Etx headers
            bw.Write((long)0);

            // Each VxEvent
            foreach (object[] messages in fields)
            {
                Blob producerId = Blob.Parse("E5743D51C3384707B95A75D457945A38");
                VxEvent ve = new VxEvent(producerId, baseEventId++, DateTime.UtcNow);
                uint fieldOrdinal = 1;
                // Each field
                foreach (object o in messages)
                {
                    if (o != null)
                    {
                        ve.EventFields.AddField(fieldOrdinal, o);
                    }
                    fieldOrdinal++;
                }
                ve.WriteStream(bw);
            }

            return ms.ToArray();
        }

        private uint _sequenceNum = 0;
        private uint _sequenceNumCoolStart = 0;
        private uint _sequenceNumCoolEnd = 0;

        [TestCase, Description("Send message with 1 event to Vortex")]
        [StressTest]
        public void BasicMessageWithLogStringId()
        {
            Send(MakeVxMessage(0, "TESTEVT1FromTest", 100, "Hello world1!", _sequenceNum++));
        }

        [TestCase, Description("Send message with 1 event to Vortex")]
        [StressTest]
        public void BasicMessageWithoutLogStringId()
        {
            Send(MakeVxMessage(0, null, 101, "Hello world2!", _sequenceNum++));
        }

        [TestCase, Description("Send message with 2 events to Vortex")]
        [StressTest]
        public void BasicMessage2()
        {
            var msg = new object[][] {
                new object[] { null, 102, "Hello world3!", _sequenceNum++ },
                new object[] { null, 202, "Goodbye!", -2, 1.5, _sequenceNum++ }
            };
            Send(MakeVxMessage(0, msg));
        }

        [TestCase, Description("Send message with 3 events to Vortex. 3rd one has lots of autovalues.")]
        [StressTest]
        public void AdvMessage3()
        {
            var msg = new object[][] {
                new object[] { null, 103, "Hello world!", _sequenceNum++ },
                new object[] { null, 203, "Goodbye!", -2, 1.5, _sequenceNum++ },
                new object[] { null, 303, _sequenceNum++, null, null, null, null, "DONE" }
            };
            Send(MakeVxMessage(0, msg));
        }

        [TestCase, Description("Send message with various fields that require prettifying to Vortex.")]
        [StressTest]
        public void Message4_Prettify()
        {
            ulong ft1 = (ulong)DateTime.UtcNow.ToFileTimeUtc();
            Thread.Sleep(50);
            ulong ft2 = (ulong)DateTime.UtcNow.ToFileTimeUtc();
            Thread.Sleep(50);
            string ftstr3 = DateTime.UtcNow.ToString("yyyy/MM/dd HH:mm:ss.fff");
            Thread.Sleep(50);
            ulong ft4 = (ulong)DateTime.UtcNow.ToFileTimeUtc();
            Guid guid1 = Guid.NewGuid();
            var msg = new object[][] {
                new object[] { _sequenceNum++, null, null, null, null, null, null, "done1" },
                new object[] { _sequenceNum++, ft1, ft2, ftstr3, ft4, guid1.ToByteArray(), (ulong)0x1122334455667788, "done2" },
                new object[] { _sequenceNum++, null, ft2, ftstr3, ft4, guid1.ToByteArray(), (ulong)0x1122334455667788, "done3" },
                new object[] { _sequenceNum++, ulong.MinValue, ulong.MaxValue, "", ulong.MinValue, new byte[1] { 0xFF }, (uint)0x11223344, "done4" },
            };
            Send(MakeVxMessage(7, msg[0]));
            Send(MakeVxMessage(7, msg[1]));
            Send(MakeVxMessage(7, msg[2]));
            Send(MakeVxMessage(7, msg[3]));
        }

        [TestCase, Description("Send message with user/console autovalues")]
        [StressTest]
        public void Message10_FancyAutovalues()
        {
            Init();

            const uint userFlags_US_Silver_English = 0x2306700;      // US    (103, 0x67), Silver     (3), english  (1)
            const uint userFlags_HK_Silver_English = 0x2602700;      // HK    (39, 0x27),  Gold       (3), english  (1)
            const uint userFlags_JP_FamilyGold_Japanese = 0x4903500; // Japan (53, 0x35), FamilyGold (9), japanese (2)
            var msg = new object[] { _sequenceNum++ };

            Authdata_Xenon2 ad = new Authdata_Xenon2();

            // Just defaults
            // Expect: console language Russian, no users
            //SgClient.SetDefaultAuthdata(ad);
            ad.wAuthDataVersion = 4;
            ad.wAuthDataSize = Authdata_Xenon2.SIZE;
            ad.wMajorVersion = 0xF;
            ad.wMinorVersion = 0xF;
            ad.wBuildNumber = 0x0001;
            ad.wQFENumber = 0x01;
            ad.dwAuthDataFlags = Authdata_Xenon2.FLAGS_ISXENON;
            byte[] defKey = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
            Array.Copy(defKey, ad.abKey, ad.abKey.Length);
            ad.dwTitleID = 0xC0FE0800;
            ad.dwTitleVersion = 1;
            ad.dwTitleRegion = 1;
            ad.qwXboxID = 0xFA00000012345678;
            ad.users = new XUserID[4];
            ad.users[0] = new XUserID();
            ad.users[1] = new XUserID();
            ad.users[2] = new XUserID();
            ad.users[3] = new XUserID();
            ad.SetPrivileges(new uint[] { 0x102d3bfe, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfffc0000 });
            ad.flowToken = xonline.common.service.Floken.NewFloken().FlowToken;


            // Results are going to be something like:
            //
            // TESTEVT10|1|0|0|ru-RU|C|ru|0|None
            // TESTEVT10|1|67|US|en-US|1|en|3|Silver
            // TESTEVT10|1|27|HK|en-HK|1|en|6|Gold
            // TESTEVT10|1|27|HK|en-HK|1|en|6|Gold
            // TESTEVT10|1|35|JP|ja-JP|2|ja|9|FamilyGold
            // 

            // Console language
            ad.wLanguageID = 12;  // russian

            Global.RO.Debug(ad.ToString());
            _transport.SetAuthdata(ad);
            Send(MakeVxMessage(8, msg));

            // One user, slot 2/4 (primary)
            // Expect: US, silver, english
            ad.users[1] = new XUserID() {
                qwUserID = 0x9000001111111,
                dwUserFlags = userFlags_US_Silver_English
            };
            _transport.SetAuthdata(ad);
            Send(MakeVxMessage(8, msg));

            // Another user, slot 1/4 (primary)
            // Expect: JP, gold, french
            ad.users[0] = new XUserID() {
                qwUserID = 0x9000002222222,
                dwUserFlags = userFlags_HK_Silver_English 
            };
            _transport.SetAuthdata(ad);
            Send(MakeVxMessage(8, msg));

            // Another user, slot 4/4 (not primary)
            // Expect: JP, gold, french
            ad.users[3] = new XUserID() {
                qwUserID = 0x9000003333333,
                dwUserFlags = userFlags_JP_FamilyGold_Japanese
            };
            _transport.SetAuthdata(ad);
            Send(MakeVxMessage(8, msg));

            // Remove first two users
            // Expect: JP, family gold, japanese
            ad.users[0] = new XUserID() {
                qwUserID = 0,
                dwUserFlags = 0
            };
            ad.users[1] = new XUserID() {
                qwUserID = 0,
                dwUserFlags = 0
            };
            _transport.SetAuthdata(ad);
            Send(MakeVxMessage(8, msg));


        }

        [TestCase, Description("Send message not in manifest.")]
        [StressTest]
        public void NotInManifest()
        {
            Send(MakeVxMessage(9999, "TESTEVT4FromTest", 404, _sequenceNum++));
        }

        [TestCase, Description("Send message not in manifest.")]
        [StressTest]
        public void NotInManifestX10()
        {
            var msg = new object[][] {
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
                new object[] { "TESTEVT4FromTestX10", 404, _sequenceNum++ },
            };
            Send(MakeVxMessage(100, msg));
        }

        [TestCase, Description("Send a COOLSTART event")]
        public void StartSomethingCool()
        {
            string resource = "/resource/" + _sequenceNumCoolStart++;
            Send(MakeVxMessage(3, null, (long)DateTime.UtcNow.ToFileTimeUtc(), null, null, resource));
        }

        [TestCase, Description("Send a COOLEND event")]
        public void EndSomethingCool()
        {
            string resource = "/resource/" + _sequenceNumCoolEnd++;
            uint status = 0;
            if ((_sequenceNumCoolEnd % 5) == 0)
                status = 0x8015000A;
            Send(MakeVxMessage(4, null, (long)DateTime.UtcNow.ToFileTimeUtc(), null, resource, status));
        }

        [TestCase, Description("Send a measurement event (SigninTime)")]
        public void MeasurementMessage_BelowThresh()
        {
            // SigninTime|4000 = 0xFA0
            Send(MakeVxMessage(5, null, (uint)4000, _sequenceNum++));
        }

        [TestCase, Description("Send a measurement event (SigninTime)")]
        public void MeasurementMessage_AboveThresh()
        {
            // SigninTime|5000 = 0x1388
            Send(MakeVxMessage(5, null, (uint)5000, _sequenceNum++));
        }

        [TestCase, Description("Send a failure event (EPIXDownloadFail)")]
        public void FailureMessage()
        {
            Send(MakeVxMessage(6, null, "/foo/bar", _sequenceNum++));
        }

        [TestCase, Description("Send an TESTEVTOUTTYPES event")]
        public void OutTypeEvent()
        {
            Send(MakeVxMessage(9, _sequenceNum++, (uint)0x8015B00B, (uint)0xFFFE07D1));
            Send(MakeVxMessage(9, _sequenceNum++, (uint)0x1234ABCD, (uint)0x1234ABCD));
            Send(MakeVxMessage(9, _sequenceNum++, (uint)0, (uint)0));
            Send(MakeVxMessage(9, _sequenceNum++, (ulong)0x8015B00B, (ulong)0xFFFE07D1)); // same thing really
            Send(MakeVxMessage(9, _sequenceNum++, null, null));
        }

        [TestCase, Description("Send an TESTEVTOUTTYPES event with invalid wiretypes")]
        public void OutTypeEvent_Negative()
        {
            Send(MakeVxMessage(9, _sequenceNum++, (int)-2146062325, (int)-129071));
            Send(MakeVxMessage(9, _sequenceNum++, (long)-2146062325, (long)-129071));
            Send(MakeVxMessage(9, _sequenceNum++, (long)0x8015B00B, (long)0xFFFE07D1)); // same thing really
            Send(MakeVxMessage(9, _sequenceNum++, (string)"0x1234ABCD", (string)"0x1234ABCD"));
            Send(MakeVxMessage(9, _sequenceNum++, (byte[])new byte[] { 1 }, (byte[])new byte[] { 2 }));
        }

    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VeiParser.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;

namespace xonline.server.vortex.cake
{
    /// <summary>
    /// Class responsible for parsing CAKE recipes into ExpressionTree graphs.
    /// </summary>
    public sealed class TextParser
    {
        public const string OrdinalMatchGroup = "ordinal";
        public const string HintMatchGroup = "hint";
        public const string DelimiterMatchGroup = "delimiter";
        public const string LowMatchGroup = "low";
        public const string HighMatchGroup = "high";
        public const string NameMatchGroup = "name";

        /// <summary>
        /// Regular expressions used to extract terms.  These expressions are listed
        /// in an order reflective of the associated term's precedence.
        /// </summary>
        private static List<KeyValuePair<TermType, Regex>> TermExpressions { get; set; }

        /// <summary>
        /// Initializes and populates the TermExpressions static member.
        /// </summary>
        static TextParser()
        {
            string delimiter;
            string hint;
            string lohigh;

            TermExpressions = new List<KeyValuePair<TermType, Regex>>();

            // Optional hint used to determine base in integer conversions, if hex (x) not specified decimal assumed
            hint = @"(%(?<hint>[^\)]*)){0,1}";
            // Optional delimiting marker inserted between set join items: ie $(1-3:|) same as $1|$2|$3
            delimiter = @"(:(?<delimiter>[^\)]*)){0,1}";
            // LOW and HIGH range in ordinal and named set join: ie $(22-33) or $(Base[22-33])
            lohigh = @"(?<low>\d+)-(?<high>\d+)";

            // 1: Escape Sequences - These cannot be nested due to their priority, their
            //    priority in this simple scheme disallows escape sequence nesting
            AddTermExpression(TermType.Literal, @"\\."); 
            // 2: Universal Set Join
            AddTermExpression(TermType.UniversalSetJoin, @"\$\(\*" + delimiter + @"\)");
            // 3: Ordinaled Set Join
            AddTermExpression(TermType.OrdinalSetJoin, @"\$\(" + lohigh + delimiter + @"\)");
            // 4: Named Set Join
            AddTermExpression(TermType.NamedSetJoin, @"\$\((?<name>[^\[]*)\[" + lohigh + @"\]" + delimiter + @"\)");
            // 5: Ordinalled Token
            AddTermExpression(TermType.OrdinalToken, @"\$(?<ordinal>\d+)");
            // 6: Ordinalled Token form 2
            AddTermExpression(TermType.OrdinalToken, @"\$\((?<ordinal>\d+)" + hint + @"\)");
            // 7: Named Token
            AddTermExpression(TermType.NamedToken, @"\$\((?<name>\w+)" + hint + @"\)");
            // 8: Regular Literals
            AddTermExpression(TermType.Literal, @"(.|\n)+");
        }

        #region Expression Tree Building Helpers

        /// <summary>
        /// Parses a CAKE receipe into an ExpressionTree graph.
        /// </summary>
        /// <param name="parameters">Structure containing Lambda expression input parameters.</param>
        /// <param name="expression">Recipe for building the target field.</param>
        /// <param name="targetType">Type associated with the target field.</param>
        /// <returns>Returns the root element of the Expression graph representing the CAKE recipe.</returns>
        public static Expression GenerateExpressionTree(ObjectMapper.ConstructionParameters parameters, string expression, Type targetType)
        {
            LexTerm[] expressionTerms;
            Expression result;

            expressionTerms = ExtractExpressionTerms(expression);
            result = null;

            if (expressionTerms.Length == 0)
            {
                // use default(T) when no terms are present.
                result = targetType.IsValueType ?
                    Expression.Constant(Activator.CreateInstance(targetType)) :
                    Expression.Constant(null);
            }
            else
            {
                Type cast = null;

                if (LexTerm.ArithmaticRequiresCast(targetType, out cast))
                {
                    // use (T)((C)t1+ (C)t2 + (C)t3 + ... + (C)tn) when terms are present
                    result = Expression.Convert(
                        expressionTerms
                            .Select(term => (Expression)Expression.Convert(term.BuildExpression(parameters, targetType), cast))
                            .Aggregate((term1, term2) => Expression.Add(term1, term2)),
                        targetType);
                }
                else
                {
                    // use t1 + t2 + t3 + ... + tn when terms are present
                    result = expressionTerms
                        .Select(term => term.BuildExpression(parameters, targetType))
                        .Aggregate((term1, term2) => Add(term1, term2, targetType));
                }
            }

            return result;
        }

        /// <summary>
        /// Builds an add expression for the specified terms.
        /// </summary>
        /// <param name="term1">Left operand.</param>
        /// <param name="term2">Right operand.</param>
        /// <param name="targetType">Type associated with input and result.</param>
        /// <returns>Returns an Expression representing the required work to add.</returns>
        private static Expression Add(Expression term1, Expression term2, Type targetType)
        {
            if (targetType == typeof(string))
            {
                if (null == _addStringMethod)
                {
                    _addStringMethod = typeof(TextParser).GetMethod("AddString", BindingFlags.NonPublic | BindingFlags.Static);
                }

                return Expression.Call(_addStringMethod, term1, term2);
            }
            else
            {
                return Expression.Add(term1, term2);
            }
        }

        private static MethodInfo _addStringMethod = null;
        /// <summary>
        /// Adds two strings together.
        /// </summary>
        /// <param name="term1">Left operand.</param>
        /// <param name="term2">Right operand.</param>
        /// <returns>Returns the result of a string add.</returns>
        private static string AddString(string term1, string term2)
        {
            return term1 + term2;
        }

        #endregion

        #region Term Extraction Helpers

        /// <summary>
        /// Parses the CAKE recipe into the simple language terms.
        /// </summary>
        /// <param name="expression">Recipe for building the target field.</param>
        /// <returns>Returns an array of parsed expression terms.</returns>
        /// <remarks>
        /// This method is made public for unit testing purposes.
        /// </remarks>
        public static LexTerm[] ExtractExpressionTerms(string expression)
        {
            List<LexTerm> results;

            results = new List<LexTerm>();

            if (!string.IsNullOrEmpty(expression))
            {
                List<Match> cache;
                Regex escape;
                int start = 0;
                int cut;
                
                cache = TermExpressions.ConvertAll<Match>(a => null);
                escape = new Regex(@"\\(.)");

                // match all the way up to the end of the expression
                while (start < expression.Length)
                {
                    LexTerm term = null;

                    // reset the match cut-off to the end of the expression
                    cut = expression.Length;

                    // find the first term which matches the current position in the string
                    for (int i = 0; i < TermExpressions.Count; i++)
                    {
                        Match match;

                        // check the match cache from previous (while) iterations
                        if (null != cache[i] && start == cache[i].Index)
                        {
                            term = new LexTerm()
                            {
                                Match = cache[i],
                                TermType = TermExpressions[i].Key
                            };

                            start += term.Match.Length;

                            // reset the match cache
                            ClearMatchCache(cache, i);

                            break;
                        }

                        match = TermExpressions[i].Value.Match(expression, start, cut - start);

                        // check to see if a match was found for term [i]
                        if (match.Success)
                        {
                            // verify that the match occurred at the start
                            if (match.Index == start)
                            {
                                term = new LexTerm()
                                {
                                    Match = match,
                                    TermType = TermExpressions[i].Key
                                };

                                start += term.Match.Length;

                                break;
                            }
                            else
                            {
                                // cache this match
                                cache[i] = match;

                                // prohibit lower priority terms from running into this term.
                                cut = match.Index;
                            }
                        }
                    }

                    // remove escapes from literal text
                    term.Text =
                        term.TermType == TermType.Literal ?
                        escape.Replace(term.Match.Value, "$1") :
                        term.Match.Value;

                    // get hint if present
                    term.Hint = term.Match.Groups[HintMatchGroup].Value;

                    if (term.TermType != TermType.Literal || results.Count == 0 || results[results.Count - 1].TermType != TermType.Literal)
                    {
                        results.Add(term);
                    }
                    else
                    {
                        // coalesce literal terms: escapes split literals it is neccessary these be rejoined
                        results[results.Count - 1].Text += term.Text;
                    }
                }
            }

            return results.ToArray();
        }

        /// <summary>
        /// Reset the match cache for items at and after the specificed index.
        /// </summary>
        /// <param name="target">Cache whose items will be reset.</param>
        /// <param name="start">Index associated with the first item to reset.</param>
        private static void ClearMatchCache(List<Match> target, int start)
        {
            for (int c = start; c < target.Count; c++)
            {
                target[c] = null;
            }
        }

        /// <summary>
        /// Helper method for constructing term order prioritized regular expressions.
        /// </summary>
        /// <param name="termType">Language term associated with the entry.</param>
        /// <param name="regex">Expression that recognizeds the associated langauge term.</param>
        private static void AddTermExpression(TermType termType, string regex)
        {
            TermExpressions.Add(new KeyValuePair<TermType,Regex>(termType, new Regex(regex)));
        }

        #endregion
    }

    /// <summary>
    /// Represents a Term in the CAKE recipe simple language.
    /// </summary>
    public class LexTerm
    {
        private const int c_ConversionModeChangeType = 1;
        private const int c_ConversionModeStringParse = 2;
        private const int c_ConversionModeConstructor = 4;

        public TermType TermType { get; set; }
        public Match    Match { get; set; }
        public string   Text { get; set; }
        public string   Hint { get; set; }

        // static cached method info items
        private static Dictionary<string, MethodInfo> stringToIntegralConverters;
        private static Dictionary<string, MethodInfo> integralConverters;
        private static Dictionary<string, Type> integralCastMapping;
        private static Dictionary<string, int> literalConversionModeCache;
        private static Dictionary<string, MethodBase> stringParsers;

        private static MethodInfo getTypeMethod;
        private static MethodInfo toStringMethod;
        private static MethodInfo normalizeHexString;
        private static MethodInfo changeType;
        private static MethodInfo readOrdinalFieldGeneric;
        private static MethodInfo readNamedFieldGeneric;
        private static MethodInfo universalSetJoinImplementation;
        private static MethodInfo ordinalSetJoinImplementation;
        private static MethodInfo namedSetJoinImplementation;

        /// <summary>
        /// Static constructor used to initialize all the MethodInfo caches used to
        /// drive down initialization costs associated with reflection.
        /// </summary>
        static LexTerm()
        {
            Type convert = typeof(Convert);
            Type[] stringParameters = new Type[] { typeof(string), typeof(int) };
            Type[] objectParameters = new Type[] { typeof(object) };
            Type[] changeParameters = new Type[] { typeof(object), typeof(Type) };

            // Caches details about literal Parsers
            stringParsers = new Dictionary<string, MethodBase>();

            // Caches details about literal Parsing
            literalConversionModeCache = new Dictionary<string, int>();

            // Initialize all the ToIntegralType MethodInfo caches for string conversion
            stringToIntegralConverters = new Dictionary<string, MethodInfo>();
            
            stringToIntegralConverters.Add(typeof(Byte).Name, convert.GetMethod("ToByte", stringParameters));
            stringToIntegralConverters.Add(typeof(UInt16).Name, convert.GetMethod("ToUInt16", stringParameters));
            stringToIntegralConverters.Add(typeof(UInt32).Name, convert.GetMethod("ToUInt32", stringParameters));
            stringToIntegralConverters.Add(typeof(UInt64).Name, convert.GetMethod("ToUInt64", stringParameters));

            stringToIntegralConverters.Add(typeof(SByte).Name , convert.GetMethod("ToSByte", stringParameters));
            stringToIntegralConverters.Add(typeof(Int16).Name , convert.GetMethod("ToInt16", stringParameters));
            stringToIntegralConverters.Add(typeof(Int32).Name , convert.GetMethod("ToInt32", stringParameters));
            stringToIntegralConverters.Add(typeof(Int64).Name , convert.GetMethod("ToInt64", stringParameters));

            // Initialize all the ToIntegralType MethodInfo caches for non-string conversion
            integralConverters = new Dictionary<string, MethodInfo>();

            integralConverters.Add(typeof(Byte).Name, convert.GetMethod("ToByte", objectParameters));
            integralConverters.Add(typeof(UInt16).Name, convert.GetMethod("ToUInt16", objectParameters));
            integralConverters.Add(typeof(UInt32).Name, convert.GetMethod("ToUInt32", objectParameters));
            integralConverters.Add(typeof(UInt64).Name, convert.GetMethod("ToUInt64", objectParameters));

            integralConverters.Add(typeof(SByte).Name, convert.GetMethod("ToSByte", objectParameters));
            integralConverters.Add(typeof(Int16).Name, convert.GetMethod("ToInt16", objectParameters));
            integralConverters.Add(typeof(Int32).Name, convert.GetMethod("ToInt32", objectParameters));
            integralConverters.Add(typeof(Int64).Name, convert.GetMethod("ToInt64", objectParameters));

            // Initialize integral arithmetic cast type mapping, not all integral types support adding - a cast is required for them
            integralCastMapping = new Dictionary<string, Type>();

            integralCastMapping.Add(typeof(Byte).Name, typeof(UInt32));
            integralCastMapping.Add(typeof(UInt16).Name, typeof(UInt32));

            integralCastMapping.Add(typeof(SByte).Name, typeof(Int32));
            integralCastMapping.Add(typeof(Int16).Name, typeof(Int16));

            // Initialize all other cached MethodInfo items.
            getTypeMethod = typeof(object).GetMethod("GetType");
            toStringMethod = typeof(LexTerm).GetMethod("ConvertToString", BindingFlags.NonPublic | BindingFlags.Static);
            normalizeHexString = typeof(LexTerm).GetMethod("NormalizeHexString", BindingFlags.NonPublic | BindingFlags.Static);
            changeType = convert.GetMethod("ChangeType", changeParameters);
            readOrdinalFieldGeneric = typeof(PayloadReader).GetMethod("ReadOrdinalField");
            readNamedFieldGeneric = typeof(PayloadReader).GetMethod("ReadNamedField");
            universalSetJoinImplementation = typeof(LexTerm).GetMethod("UniversalSetJoinImplementation", BindingFlags.NonPublic | BindingFlags.Static);
            ordinalSetJoinImplementation = typeof(LexTerm).GetMethod("OrdinalSetJoinImplementation", BindingFlags.NonPublic | BindingFlags.Static);
            namedSetJoinImplementation = typeof(LexTerm).GetMethod("NamedSetJoinImplementation", BindingFlags.NonPublic | BindingFlags.Static);
        }

        /// <summary>
        /// Builds an expression representing this term.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="targetType">Type associated with targeted field.</param>
        /// <returns>Returns an Expression representing this term.</returns>
        public Expression BuildExpression(ObjectMapper.ConstructionParameters parameters, Type targetType)
        {
            switch (TermType)
            {
                case TermType.OrdinalToken:
                    return BuildOrdinalToken(parameters, targetType);
                case TermType.NamedToken:
                    return BuildNamedToken(parameters, targetType);
                case TermType.UniversalSetJoin:
                    return BuildUniversalSetJoin(parameters, targetType);
                case TermType.NamedSetJoin:
                    return BuildNamedSetJoin(parameters, targetType);
                case TermType.OrdinalSetJoin:
                    return BuildOrdinalSetJoin(parameters, targetType);
                default:
                    return BuildLiteral(parameters, targetType);
            }
        }

        #region Term Expression Builders

        /// <summary>
        /// Builds an expression representing a literal value.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="targetType">Type associated with targeted field.</param>
        /// <returns>Returns an Expression representing a literal value.</returns>
        private Expression BuildLiteral(ObjectMapper.ConstructionParameters parameters, Type targetType)
        {
            int flags;

            flags = GetConversionMode(targetType);

            switch (flags)
            {
                case c_ConversionModeChangeType:
                    return Expression.Constant(Convert.ChangeType(Text, targetType));
                case c_ConversionModeStringParse:
                    return Expression.Constant(stringParsers[targetType.Name].Invoke(null, new object[] { Text }));
                case c_ConversionModeConstructor:
                    return Expression.Constant(Activator.CreateInstance(targetType, Text));
                default:
                    throw new InvalidDataException("Dont know how to initialize type: " + targetType.Name);
            }
        }

        /// <summary>
        /// Gets the Conversion Mode associated with the specified type.
        /// </summary>
        /// <param name="targetType">Type to lookup conversion mode against.</param>
        /// <returns>Returns an integer representing the conversion mode.</returns>
        private static int GetConversionMode(Type targetType)
        {
            int flags = 0;

            if (!literalConversionModeCache.TryGetValue(targetType.Name, out flags))
            {
                MethodBase method;

                if (targetType.GetInterface("IConvertible") != null)
                {
                    flags = c_ConversionModeChangeType;
                }
                else if (null != (method = targetType.GetMethod("Parse")))
                {
                    stringParsers[targetType.Name] = method;
                    flags = c_ConversionModeStringParse;
                }
                else if (null != (method = targetType.GetConstructor(new Type[] { typeof(string) })))
                {
                    stringParsers[targetType.Name] = method;
                    flags = c_ConversionModeConstructor;
                }

                literalConversionModeCache[targetType.Name] = flags;
            }
            return flags;
        }

        /// <summary>
        /// Builds an expression representing a runtime data fetch from the payload via a field ordinal.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="targetType">Type associated with targeted field.</param>
        /// <returns>Returns an Expression representing run-time data fetch from the payload.</returns>
        private Expression BuildOrdinalToken(ObjectMapper.ConstructionParameters parameters, Type targetType)
        {
            Expression ordinal;
            LambdaExpression converter;

            ordinal = Expression.Constant(int.Parse(Match.Groups[TextParser.OrdinalMatchGroup].Value));
            converter = BuildConversionExpression(parameters, targetType);

            return BuildReadOrdinalFieldExpression(parameters, ordinal, converter);
        }

        /// <summary>
        /// Builds an expression representing a runtime data fetch from the payload via a field name.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="targetType">Type associated with targeted field.</param>
        /// <returns>Returns an Expression representing run-time data fetch from the payload.</returns>
        private Expression BuildNamedToken(ObjectMapper.ConstructionParameters parameters, Type targetType)
        {
            Expression name;
            LambdaExpression converter;

            name = Expression.Constant(Match.Groups[TextParser.NameMatchGroup].Value);
            converter = BuildConversionExpression(parameters, targetType);

            return BuildReadNamedFieldExpression(parameters, name, converter);
        }

        /// <summary>
        /// Builds an expression representing run-time data fetch and data join of all fields in the payload.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="targetType">Type associated with targeted field.</param>
        /// <returns>Returns an Expression representing run-time data fetch and join from the payload.</returns>
        private Expression BuildUniversalSetJoin(ObjectMapper.ConstructionParameters parameters, Type targetType)
        {
            Expression delimiter;
            LambdaExpression converter;

            if (targetType != typeof(string))
            {
                throw new InvalidDataException("target type must be a string for universal set join: " + targetType.Name);
            }

            delimiter = Expression.Constant(Match.Groups[TextParser.DelimiterMatchGroup].Value ?? "");
            converter = BuildConversionExpression(parameters, targetType);

            return Expression.Call(
                universalSetJoinImplementation,
                parameters.PayloadReader,
                parameters.PayloadReaderContext,
                converter,
                delimiter);
        }
        
        /// <summary>
        /// Builds an expression representing run-time data fetch and data join of all ordinal fields in the payload.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="targetType">Type associated with targeted field.</param>
        /// <returns>Returns an Expression representing run-time data fetch and join from the payload.</returns>
        private Expression BuildOrdinalSetJoin(ObjectMapper.ConstructionParameters parameters, Type targetType)
        {
            Expression delimiter;
            Expression high;
            Expression low;
            LambdaExpression converter;

            if (targetType != typeof(string))
            {
                throw new InvalidDataException("target type must be a string for universal set join: " + targetType.Name);
            }

            delimiter = Expression.Constant(Match.Groups[TextParser.DelimiterMatchGroup].Value ?? "");
            high = Expression.Constant(int.Parse(Match.Groups[TextParser.HighMatchGroup].Value));
            low = Expression.Constant(int.Parse(Match.Groups[TextParser.LowMatchGroup].Value));
            converter = BuildConversionExpression(parameters, targetType);

            return Expression.Call(
                ordinalSetJoinImplementation,
                parameters.PayloadReader,
                parameters.PayloadReaderContext,
                converter,
                delimiter,
                high,
                low);
        }

        /// <summary>
        /// Builds an expression representing run-time data fetch and data join of all named fields in the payload in the specified range.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="targetType">Type associated with targeted field.</param>
        /// <returns>Returns an Expression representing run-time data fetch and join from the payload.</returns>
        private Expression BuildNamedSetJoin(ObjectMapper.ConstructionParameters parameters, Type targetType)
        {
            Expression delimiter;
            Expression name;
            Expression high;
            Expression low;
            LambdaExpression converter;

            if (targetType != typeof(string))
            {
                throw new InvalidDataException("target type must be a string for universal set join: " + targetType.Name);
            }

            delimiter = Expression.Constant(Match.Groups[TextParser.DelimiterMatchGroup].Value ?? "");
            name = Expression.Constant(Match.Groups[TextParser.NameMatchGroup].Value);
            high = Expression.Constant(int.Parse(Match.Groups[TextParser.HighMatchGroup].Value));
            low = Expression.Constant(int.Parse(Match.Groups[TextParser.LowMatchGroup].Value));
            converter = BuildConversionExpression(parameters, targetType);

            return Expression.Call(
                namedSetJoinImplementation,
                parameters.PayloadReader,
                parameters.PayloadReaderContext,
                converter,
                delimiter,
                name,
                high,
                low);
        }

        #endregion

        #region Expression Builder Helper Methods

        /// <summary>
        /// Determines whether arithmetic is unsupported directly in the target type.
        /// Some integral types like Int16 dont support the + operator.
        /// </summary>
        /// <param name="targetType">Target type to check for cast against.</param>
        /// <param name="castType">Casting type for the specified type, if neccessary.</param>
        /// <returns>Returns a value indiciating whether casting is required to perform arithmatic against the type.  castType should be ignored if this returns false</returns>
        public static bool ArithmaticRequiresCast(Type targetType, out Type castType)
        {
            return integralCastMapping.TryGetValue(targetType.Name, out castType);
        }

        /// <summary>
        /// Helper method used to create an Expression representing the PayaloadReader.ReadOrdinalField[T] call.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="ordinal">Expression containing the ordinal value.</param>
        /// <param name="lambda">Expression containing the conversion lambda expression.</param>
        /// <returns>Returns a MethodCallExpression representing a PayloadReader.ReadOrdinalField[T] method invoke.</returns>
        private MethodCallExpression BuildReadOrdinalFieldExpression(ObjectMapper.ConstructionParameters parameters, Expression ordinal, LambdaExpression lambda)
        {
            MethodInfo readOrdinalField;

            readOrdinalField = readOrdinalFieldGeneric.MakeGenericMethod(lambda.Body.Type);

            return Expression.Call(
                parameters.PayloadReader,
                readOrdinalField,
                parameters.PayloadReaderContext,
                ordinal,
                lambda);
        }

        /// <summary>
        /// Helper method used to create an Expression representing the PayaloadReader.ReadNamedField[T] call.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="ordinal">Expression containing the ordinal value.</param>
        /// <param name="lambda">Expression containing the conversion lambda expression.</param>
        /// <returns>Returns a MethodCallExpression representing a PayloadReader.ReadNamedField[T] method invoke.</returns>
        private MethodCallExpression BuildReadNamedFieldExpression(ObjectMapper.ConstructionParameters parameters, Expression name, LambdaExpression lambda)
        {
            MethodInfo readNamedField;

            readNamedField = readNamedFieldGeneric.MakeGenericMethod(lambda.Body.Type);

            return Expression.Call(
                parameters.PayloadReader,
                readNamedField,
                parameters.PayloadReaderContext,
                name,
                lambda);
        }

        /// <summary>
        /// Helper method used to create a strongly typed lambda expression for type conversion.
        /// </summary>
        /// <param name="parameters">Expression construction contextual parameters.</param>
        /// <param name="targetType">Output type of the lamdba expression.</param>
        /// <returns>Returns a LamdbaExpression represent the perscribed type conversion.</returns>
        private LambdaExpression BuildConversionExpression(ObjectMapper.ConstructionParameters parameters, Type targetType)
        {
            ParameterExpression input = Expression.Parameter(typeof(object), "input");
            BinaryExpression isString = Expression.Equal(Expression.Call(input, getTypeMethod), Expression.Constant(typeof(string)));
            BinaryExpression isGuid = Expression.Equal(Expression.Call(input, getTypeMethod), Expression.Constant(typeof(Guid)));
            BinaryExpression isByteArray = Expression.Equal(Expression.Call(input, getTypeMethod), Expression.Constant(typeof(Byte[])));
            MethodInfo method = null;

            // String Data Conversion
            if (targetType == typeof(string))
            {
                Trace.Low("LexTerm.BuildConversionExpression() building ToString() converter for {0}", targetType.Name);

                /*  Building Lambda Expression Func<object, string>
                 *  input =>
                 *      input == null ?
                 *          null :
                 *          ConvertToStirng(input);       */

                return Expression.Lambda(
                    Expression.GetFuncType(typeof(object), targetType),
                    Expression.Condition(
                        Expression.Equal(input, Expression.Constant(null)),
                            Expression.Convert(Expression.Constant(null), typeof(string)),
                            Expression.Call(toStringMethod, input)),
                    input);
            }
            // Guid Conversions are limited, accepts string, byte[16], Guid
            else if (targetType == typeof(Guid))
            {
                Trace.Low("LexTerm.BuildConversionExpression() building Guid converter");

                /*  Building Lamda Expression Func<object, Guid>
                 *  input =>
                 *      input == null ? default(Guid) :
                 *      input.GetType() == typeof(string) ? new Guid((string)input) :
                 *      input.GetType() == typeof(Guid) ? (Guid)input :
                 *      input.GetType() == typeof(byte[]) ? new Guid((byte[])input) :
                 *      default(Guid);                                                  */

                return Expression.Lambda(
                    Expression.GetFuncType(typeof(object), targetType),
                    Expression.Condition(Expression.Equal(input, Expression.Constant(null)),
                        Expression.Constant(new Guid()),
                        Expression.Condition(isString, // try the string ctor
                            Expression.New(targetType.GetConstructor(new Type[] { typeof(string) }), Expression.Convert(input, typeof(string))),
                            Expression.Condition(isGuid, // try the Guid cast
                                Expression.Convert(input, typeof(Guid)),
                                Expression.Condition(isByteArray, // try the byte[] ctor
                                    Expression.New(targetType.GetConstructor(new Type[] { typeof(byte[]) }), Expression.Convert(input, typeof(byte[]))),
                                    Expression.Constant(new Guid()))))),
                    input);
            }
            // Integral Data Expressions
            else if (stringToIntegralConverters.TryGetValue(targetType.Name, out method))
            {
                int @base = Hint.Contains("x") ? 16 : 10;

                Trace.Low("LexTerm.BuildConversionExpression() building ToInteger({0}) converter for {1}", @base, targetType.Name);

                /*  Building Lambda Expression Func<object, T> where T is integral
                 *  input =>
                 *      input == null ?
                 *          default(T) :
                 *          typeof(string) == input.GetType() ?
                 *              Convert.ToInteger(NormalizeHexString(input), @base) :
                 *              typeof(UInt32) == input.GetType() ?      - BEGIN Generated by GetIntegerConversion
                 *                  (T)(UInt32)input :
                 *                  typeof(Int32) == input.GetType() ?
                 *                      (T)(Int32)input :
                 *                      ...
                 *                          (T)(Int16)input  :
                 *                          Convert.ToInteger(input);    - END Generated by GetIntegerConversion   */

                return Expression.Lambda(
                    Expression.GetFuncType(typeof(object), targetType),
                    Expression.Condition(
                        Expression.Equal(input, Expression.Constant(null)),
                        Expression.Constant(Activator.CreateInstance(targetType)),
                        Expression.Condition(
                            isString,
                            Expression.Call(
                                method,
                                Expression.Call(normalizeHexString, input),
                                Expression.Constant(@base)),
                            GetIntegerConversion(input, targetType))),
                    input);
            }
            // Non-Integral Data Expression
            else
            {
                Expression convert = null;

                // Determine and Build the correct conversion operation for the type
                switch (GetConversionMode(targetType))
                {
                    case c_ConversionModeStringParse:
                        Trace.Low("LexTerm.BuildConversionExpression() building T.Parse(string) converter for {0}", targetType.Name);

                        /*  Build Conversion SubExpression for static string Parser
                         *  CONVERT =
                         *      typeof(string) == input.GetType() ?
                         *          T.Parse((string)input) :
                         *          (T)input;       */

                        convert =
                            Expression.Condition(
                                isString,
                                Expression.Call(
                                    (MethodInfo)stringParsers[targetType.Name],
                                    Expression.Convert(input, typeof(string))),
                                Expression.Convert(input, targetType));

                        break;

                    case c_ConversionModeConstructor:
                        Trace.Low("LexTerm.BuildConversionExpression() building new T(string) converter for {0}", targetType.Name);

                        /*  Build Conversion SubExpression for string accepting ctor
                         *  CONVERT =
                         *      typeof(string) == input.GetType() ?
                         *          new T((string)input) :
                         *          (T)input;       */

                        convert =
                            Expression.Condition(
                                isString,
                                Expression.New(
                                    (ConstructorInfo)stringParsers[targetType.Name],
                                    Expression.Convert(input, typeof(string))),
                                Expression.Convert(input, targetType));

                        break;

                    default:
                        Trace.Low("LexTerm.BuildConversionExpression() building ChangeType() converter for {0}", targetType.Name);

                        /*  Build Conversion SubExpression for (assumed) IConvertible type
                         *  CONVERT = 
                         *      ChangeType(input, typeof(T));       */

                        convert =
                            Expression.Convert(
                                Expression.Call(changeType, input, Expression.Constant(targetType)),
                                targetType);

                        break;
                }

                /*  Building Lambda Expression Func<object, T>
                 *  input =>
                 *      input == null ?
                 *          default(T) : 
                 *          CONVERT;        */

                return Expression.Lambda(
                    Expression.GetFuncType(typeof(object), targetType),
                    Expression.Condition(
                        Expression.Equal(input, Expression.Constant(null)),
                        targetType.IsValueType ?
                            (Expression)Expression.Constant(Activator.CreateInstance(targetType)) :
                            (Expression)Expression.Convert(Expression.Constant(null), targetType),
                        convert),
                    input);
            }
        }

        /// <summary>
        /// Attempts to create an expression to explicitly cast between integral types
        /// before call the Convert.To[Integer] method.
        /// </summary>
        /// <param name="parameter">Expression representing the parameter.</param>
        /// <param name="target">Target type of the result.</param>
        /// <returns>Returns an expression that casts from input to the target type.</returns>
        private Expression GetIntegerConversion(Expression parameter, Type target)
        {
            return
                ConditionalIntegerDoubleCast(parameter, typeof(UInt32), target,
                ConditionalIntegerDoubleCast(parameter, typeof(Int32), target,
                ConditionalIntegerDoubleCast(parameter, typeof(UInt64), target,
                ConditionalIntegerDoubleCast(parameter, typeof(Int64), target,
                ConditionalIntegerDoubleCast(parameter, typeof(sbyte), target,
                ConditionalIntegerDoubleCast(parameter, typeof(Int16), target,
                ConditionalIntegerDoubleCast(parameter, typeof(byte), target,
                ConditionalIntegerDoubleCast(parameter, typeof(UInt16), target,
                    Expression.Call(integralConverters[target.Name], parameter)))))))));
        }

        /// <summary>
        /// Attempts a double integer cast from object, to intermediate integer
        /// to target integer when the object is of the intermediate type.  Otherwise
        /// the alternative expression will be used.
        /// </summary>
        /// <param name="parameter">Expression representing the parameter to be casted.</param>
        /// <param name="intermediateType">Intermediate type of the double cast.</param>
        /// <param name="targetType">Target type of the double cast.</param>
        /// <param name="alternative">Expression to use instead of double casting when the parameters type is not the intermediate Type.</param>
        /// <returns>Returns a conditional expression that executes either the double cast or the alternative.</returns>
        /// <remarks>
        /// An example of a "double cast"
        /// (UInt64)(Int64)-1
        /// </remarks>
        private Expression ConditionalIntegerDoubleCast(Expression parameter, Type intermediateType, Type targetType, Expression alternative)
        {
            return Expression.Condition(
                Expression.Equal(Expression.Call(parameter, getTypeMethod), Expression.Constant(intermediateType)),
                Expression.Convert(Expression.Convert(parameter, intermediateType), targetType),
                alternative);
        }

        #endregion

        #region Expression Referenced Methods

        /// <summary>
        /// Removes the 0x prefix from hex strings if present.
        /// </summary>
        /// <param name="input">input hex string.</param>
        /// <returns>Returns a hex string with 0x prefix removed if present.</returns>
        /// <remarks>This method's name is referenced in the static constructor, keep it up to date.</remarks>
        private static string NormalizeHexString(object input)
        {
            string str = (string)input;

            return str.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ?
                str.Substring(2) :
                str;
        }

        /// <summary>
        /// Converts the target object to a string.
        /// </summary>
        /// <param name="input">Input object to convert to a string.  This value cannot be null.</param>
        /// <returns>Returns the string representation of the specified input.</returns>
        private static string ConvertToString(object input)
        {
            byte[] bytes;

            if (null != ((bytes = input as byte[])))
            {
                var text = new StringBuilder();

                for (int c = 0; c < bytes.Length; c++)
                {
                    text.AppendFormat("{0:x2}", bytes[c]);
                }

                return text.ToString();
            }

            return input.ToString();
        }

        #region Set Join Implementations
        
        /// <summary>
        /// Implementation of the universal set join operation.  Universal set join terms will
        /// invoke this method at run-time.
        /// </summary>
        /// <param name="reader">Payload reader used to access the object payload.</param>
        /// <param name="context">Payload reader contextual information including the object payload.</param>
        /// <param name="converter">Conversion delegate used map an object to a string.</param>
        /// <param name="delimiter">String the joined strings.</param>
        /// <returns>Returns a string constructed by joining all fields in the payload.</returns>
        /// <remarks>This method's name is referenced in the static constructor, keep it up to date.</remarks>
        private static string UniversalSetJoinImplementation(PayloadReader reader, PayloadReader.Context context, Func<object, string> converter, string delimiter)
        {
            StringBuilder result = new StringBuilder();
            int marker;

            marker = 0;

            foreach (string name in reader.GetNamedFields(context))
            {
                if (marker++ > 0) 
                    result.Append(delimiter);
                result.Append(reader.ReadNamedField<string>(context, name, converter)); 
            }

            foreach (int ord in new NumberRange(reader.GetOrdinalCount(context) - 1))
            {
                if (marker++ > 0) 
                    result.Append(delimiter); 
                result.Append(reader.ReadOrdinalField<string>(context, ord, converter));
            }

            return result.ToString();
        }

        /// <summary>
        /// Implementation of the ordinal set join operation.  Ordinal set join terms will
        /// invoke this method at run-time.
        /// </summary>
        /// <param name="reader">Payload reader used to access the object payload.</param>
        /// <param name="context">Payload reader contextual information including the object payload.</param>
        /// <param name="converter">Conversion delegate used map an object to a string.</param>
        /// <param name="delimiter">String the joined strings.</param>
        /// <param name="high">Inclusive upper ordinal range in the join.</param>
        /// <param name="low">Inclusive lower ordinal range in the join.</param>
        /// <returns>Returns a string constructed by joining all ordinal fields in the payload for a specific range.</returns>
        /// <remarks>This method's name is referenced in the static constructor, keep it up to date.</remarks>
        private static string OrdinalSetJoinImplementation(PayloadReader reader, PayloadReader.Context context, Func<object, string> converter, string delimiter, int high, int low)
        {
            StringBuilder result = new StringBuilder();
            int marker;

            marker = 0;

            foreach (int ord in new NumberRange(low, high))
            {
                if (marker++ > 0)
                    result.Append(delimiter);
                result.Append(reader.ReadOrdinalField<string>(context, ord, converter));
            }

            return result.ToString();
        }

        /// <summary>
        /// Implementation of the named set join operation.  Named set join terms will
        /// invoke this method at run-time.
        /// </summary>
        /// <param name="reader">Payload reader used to access the object payload.</param>
        /// <param name="context">Payload reader contextual information including the object payload.</param>
        /// <param name="converter">Conversion delegate used map an object to a string.</param>
        /// <param name="delimiter">String the joined strings.</param>
        /// <param name="base">Field name prefix.</param>
        /// <param name="high">Inclusive upper ordinal suffix range in the join.</param>
        /// <param name="low">Inclusive lower ordinal suffix range in the join.</param>
        /// <returns>Returns a string constructed by joining all ordinal suffixed named fields in the payload for a specific range.</returns>
        /// <remarks>This method's name is referenced in the static constructor, keep it up to date.</remarks>
        private static string NamedSetJoinImplementation(PayloadReader reader, PayloadReader.Context context, Func<object, string> converter, string delimiter, string @base, int high, int low)
        {
            StringBuilder result = new StringBuilder();
            int marker;

            marker = 0;

            foreach (int ord in new NumberRange(low, high))
            {
                if (marker++ > 0)
                    result.Append(delimiter);
                result.Append(reader.ReadNamedField<string>(context, @base + ord.ToString(), converter));
            }

            return result.ToString();
        }

        #endregion

        #endregion
    }

    /// <summary>
    /// Terms in the simple recipe tokenized language.
    /// </summary>
    public enum TermType
    {
        Literal,
        OrdinalToken,
        NamedToken,
        UniversalSetJoin,
        OrdinalSetJoin,
        NamedSetJoin
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\MyWebTransaction.cs ===
using System;
using System.Collections.Generic;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Globalization;
using System.Diagnostics;

using ServerTestFramework.LiveService;

namespace xonline.test.vortexdvt
{
    public class MyWebTransaction
    {
        /// <summary>
        /// IP or DNS name of server
        /// </summary>
        public IPEndPoint endPoint = null;

        /// <summary>
        /// FD transactions can be UDP or TCP now
        /// </summary>
        public enum Transports
        {
            TCP,
            UDP
        }

        /// <summary>
        /// Use the UDP protocol transport for delivery
        /// </summary>
        public Transports transport = Transports.TCP;

        public static int sReceiveTimeOut = 35000;
        public static int sSendTimeOut = 35000;

        public int ReceiveTimeOut = sReceiveTimeOut;
        public int SendTimeOut = sSendTimeOut;

        // if this flag is set to true then we will not wait for any UDP response.
        public bool IgnoreUDPReceive = false;

        /// <summary>
        /// http status in response
        /// </summary>
        public HttpStatusCode httpStatus
        {
            get { return _httpStatus; }
        }
        private HttpStatusCode _httpStatus = HttpStatusCode.NotFound;

        /// <summary>
        /// Buffer sized to contain raw contents of response
        /// </summary>
        public byte[] ResponseContents
        {
            get { return _respBuff; }
        }
        private byte[] _respBuff = null;

        [ThreadStatic]
        static byte[] responseData;

        /// <summary>
        /// Value returned in XErr header field when http response status is 500.
        /// </summary>
        public uint XErr
        {
            get { return _XErr; }
        }
        private uint _XErr = HResult.E_FAIL;

        public bool AppendSGIPPort = false;


        /// <summary>
        /// HTTP response header for client-side throttling
        /// </summary>
        public uint XDelay
        {
            get { return _XDelay; }
        }
        private uint _XDelay = 0;

        private int GetEndOfHeaderIndex(byte[] bytes)
        {
            // There may or may not be a complete header at this point
            int endOfHeader = -1;
            for (int i = 3; i < bytes.Length; i++)
            {
                if (bytes[i - 3] == '\r' && bytes[i - 2] == '\n' && bytes[i - 1] == '\r' && bytes[i] == '\n')
                {
                    endOfHeader = i;
                    break;
                }
            }
            return (endOfHeader);
        }

        private string GetHeaderString(byte[] bytes)
        {
            string header = null;
            int eohIdx = GetEndOfHeaderIndex(bytes);
            if (0 != eohIdx)
            {
                // We have header
                header = Encoding.ASCII.GetString(bytes, 0, eohIdx + 1);
            }
            return (header);
        }

        public Dictionary<string, string> GetHeader()
        {
            if (responseData == null)
            {
                return null;
            }

            string headerString = GetHeaderString(responseData);
            if (headerString == null)
            {
                return null;
            }
            Dictionary<string, string> headerDict = new Dictionary<string, string>();
            string[] fields = headerString.Split('\n');
            foreach (string field in fields)
            {
                string[] parts = field.Split(new char[] { ':' }, 2);
                if (parts.Length == 2)
                {
                    headerDict.Add(parts[0].Trim(), parts[1].Trim());
                }
            }
            return headerDict;
        }


        private uint HexToInt(byte b)
        {
            if (b >= 'a')
                return (uint)b - 'a' + 10;
            if (b >= 'A')
                return (uint)b - 'A' + 10;
            return (uint)b - '0';
        }

        private void ParseReturn(byte[] data, out HttpStatusCode StatusCode, out uint ixErr, out uint ixDelay, out int contentLen)
        {
            // FAKE!
            StatusCode = HttpStatusCode.OK;
            ixErr = 0;
            ixDelay = 0;
            contentLen = 0;
            return;

#if false
            int iError = 0;
            int i;
            int len = data.Length;
            contentLen = 0;

            /*
             *  This code will dump []data to the console. Every now and then this will come in handy
             * to diagnose things. I recommend we keep this here.
                        ASCIIEncoding AE=new ASCIIEncoding();
                        char []buf=new Char[data.Length];
                        int len2=AE.GetDecoder().GetChars(data,0,data.Length,buf,0);
                        for (i=0; i<len2; i++)
                            Console.Write(buf[i]);
                        Console.WriteLine("\n");
             */

            fixed (byte* pData = data)
            {
                // find HTTP error code
                byte* p = pData + 9;
                iError = (*(p) - '0') * 100;
                iError += (*(p + 1) - '0') * 10;
                iError += (*(p + 2) - '0');

                // find XError code
                ixErr = 0;
                ixDelay = 0;
                for (i = 5; i < len; i += 2)
                {
                    if (p[i] <= 0x0D)
                    {
                        // this is a part of a CRLF. Let's see which
                        if (p[i] == 0x0D)
                            i += 2;
                        else
                            i++;

                        if (p[i] == 0x0D && p[i + 1] == 0x0A)
                            break;

                        if (p[i] == 'X')
                        {
                            if (p[i + 1] != '-' || (p[i + 2] != 'E' && p[i + 2] != 'D'))
                                continue;
                            // this may be X-Err or X-Delay (but don't be fooled by X-Event)
                            if (p[i + 2] == 'E' && p[i + 3] == 'r' && p[i + 4] == 'r')
                            {
                                i += 7;
                                int j = i;
                                ixErr = 0;
                                int digits = 0;
                                while (p[j] >= '0' && digits < 8)
                                {
                                    ixErr <<= 4;
                                    ixErr += HexToInt(p[j]);
                                    j++;
                                    digits++;
                                }
                            }
                            else    //'D'
                            {
                                i += 9;
                                int j = i;
                                ixDelay = 0;
                                while (p[j] >= '0' && p[j] <= '9')
                                {
                                    ixDelay *= 10;
                                    ixDelay += (uint)(p[j] - '0');
                                    j++;
                                }
                            }
                        }
                        else if ((p[i] == 'C') && (p[i + 1] == 'o') && (p[i + 2] == 'n') && (p[i + 3] == 't'))
                        {
                            if ((p[i + 7] == '-') && (p[i + 8] == 'L'))
                            {
                                int j = i + 16; // j is the beginning of contentLen
                                contentLen = 0;
                                while (p[j] > 0x0D)
                                {
                                    contentLen = contentLen * 10 + (p[j] - '0');
                                    j++;
                                }
                            }
                        }
                    }
                }
            }
            StatusCode = HttpStatusCode.InternalServerError;

            switch (iError)
            {
                case 200:
                    StatusCode = HttpStatusCode.OK;
                    break;
                case 100:
                    StatusCode = HttpStatusCode.Continue;
                    break;
                case 400:
                    StatusCode = HttpStatusCode.BadRequest;
                    break;
                case 401:
                    StatusCode = HttpStatusCode.Unauthorized;
                    break;
                case 403:
                    StatusCode = HttpStatusCode.Forbidden;
                    break;
                case 404:
                    StatusCode = HttpStatusCode.NotFound;
                    break;
                case 405:
                    StatusCode = HttpStatusCode.MethodNotAllowed;
                    break;
                case 500:
                    StatusCode = HttpStatusCode.InternalServerError;
                    break;
                case 503:
                    StatusCode = HttpStatusCode.ServiceUnavailable;
                    break;
                default:
                    throw new Exception("Unknown http status code " + iError);
            }
#endif

        }

        // ----------------------------------------
        // Method: Execute
        //  Does http POST to url built from server and service and loads results into
        //  ResponseContents and XErr when appropriate.
        //  Params:
        //      reqStream - XRL data packed and ready for request contents.
        //  Returns
        //      true -  http rstatus is 200 or 500, the only possible values returned by a FD code.
        //                  XErr and ResponseContents are worth checking out.
        //      false - http status is something else.  XErr isn't set, but ResponseContents might not be empty.
        //
        //  This version also accepts a port number. The request will be sent out from that port
        //
        static int counter = 0;

        public class MyTcpClient : System.Net.Sockets.TcpClient
        {
            public ushort Bind()
            {
                Client.Bind(new IPEndPoint(IPAddress.Any, 0));
                return (ushort)((IPEndPoint)Client.LocalEndPoint).Port;
            }
            public new Socket Client
            {
                get
                {
                    return base.Client;
                }
            }
        }

        public class MyUdpClient : System.Net.Sockets.UdpClient
        {
            public ushort Bind()
            {
                Client.Bind(new IPEndPoint(IPAddress.Any, 0));
                return (ushort)((IPEndPoint)Client.LocalEndPoint).Port;
            }
            public new Socket Client
            {
                get
                {
                    return base.Client;
                }
            }
        }

        public bool ExecuteTCP(byte[] httpHeader, MemoryStream reqStream, bool noContinue, bool fReadResponse)
        {
            MyTcpClient localClient = null;
            System.Net.Sockets.NetworkStream outStream = null;

            try
            {
                try
                {
                    int retries = 0;
                    while (true)
                    {
                        localClient = new MyTcpClient();
                        localClient.ReceiveTimeout = ReceiveTimeOut;
                        localClient.SendTimeout = SendTimeOut;

                        try
                        {
                            localClient.Connect(endPoint);
                            break;
                        }
                        catch (System.Net.Sockets.SocketException)
                        {
                            retries++;
                            if (retries == 5)
                            {
                                throw;
                            }
                        }
                    }
                }
                catch (Exception)
                {
                    Interlocked.Increment(ref counter);
                    throw;
                }

                outStream = localClient.GetStream();

                if (responseData == null)
                {
                    responseData = new byte[localClient.ReceiveBufferSize];
                }
                int contentLen;
                if (noContinue)
                {
                    //local memory stream should be disposed via using
                    using (MemoryStream fullReq = new MemoryStream())
                    {
                        fullReq.Write(httpHeader, 0, httpHeader.Length);
                        //only write out the body (POST) if one was provided
                        if (reqStream != null && reqStream.Length > 0)
                            fullReq.Write(reqStream.GetBuffer(), 0, (int)reqStream.Length);

                        byte[] data = fullReq.GetBuffer();
                        if (data.Length > 0)    //only write to the stream if we have any data
                            outStream.Write(data, 0, (int)fullReq.Length);
                    }
                }
                else
                {
                    outStream.Write(httpHeader, 0, httpHeader.Length);

                    // This is where we get our Continue (100)
                    outStream.Read(responseData, 0, responseData.Length);
                    ParseReturn(responseData, out _httpStatus, out _XErr, out _XDelay, out contentLen);
                    if (_httpStatus != HttpStatusCode.Continue)
                    {
                        // We didn't get a continue... just exit
                        _XErr = 1;
                        return false;
                    }

                    // This is where we write out request
                    // only write out the body (POST) if one was provided
                    if (reqStream != null && reqStream.Length > 0)
                    {
                        byte[] data = reqStream.GetBuffer();
                        outStream.Write(data, 0, (int)reqStream.Length);
                    }
                }

                if (!fReadResponse)
                {
                    return true;
                }

                int bytesRead = outStream.Read(responseData, 0, responseData.Length);

                ParseReturn(responseData, out _httpStatus, out _XErr, out _XDelay, out contentLen);

                //The HEAD method is identical to GET except that the server DOES NOT return a message-body in the response.
                // if the request type is head do not read data.
                if (_httpStatus == HttpStatusCode.OK && !IsHeadRequest(httpHeader))
                {
                    int dataIndex = 0;
                    for (int i = 0; i < bytesRead - 3; i++)
                    {
                        if (responseData[i] == 0x0D && responseData[i + 1] == 0x0A &&
                            responseData[i + 2] == 0x0D && responseData[i + 3] == 0x0A)
                        {
                            dataIndex = i + 4;
                            break;
                        }
                    }

                    _respBuff = new byte[contentLen];
                    if (contentLen + dataIndex > bytesRead)
                    {
                        Array.Copy(responseData, dataIndex, _respBuff, 0, bytesRead - dataIndex);

                        int index = bytesRead - dataIndex;
                        while (index < contentLen)
                        {
                            if (contentLen - index > 1024)
                                index += outStream.Read(_respBuff, index, 1024);
                            else
                                index += outStream.Read(_respBuff, index, contentLen - index);
                        }
                    }
                    else
                    {
                        Array.Copy(responseData, dataIndex, _respBuff, 0, contentLen);
                    }
                }

                // Send and receive should be shutdown independently of each other
                // Do a half-close on the underlying socket
                Socket s = localClient.Client;
                s.Shutdown(SocketShutdown.Send);

                // Give the other side time to close its part (our "receive" half) of the connection
                while (s.Receive(responseData) > 0)
                {
                }

                s.Close();
            }
            finally
            {
                if (outStream != null)
                    outStream.Close();
                localClient.Close();
            }

            if (_httpStatus != HttpStatusCode.OK)
            {
                // We didn't get a continue... just ext
                if (_httpStatus == HttpStatusCode.Continue)
                {
                    //  This should never happen - we don't support multiple Continues
                    _XErr = 2;
                    return false;
                }
                return false;
            }

            return true;
        }
        /*
         * Panaroma is making head request and XRlScan test uses this.
         * The HEAD method is identical to GET except that the server DOES NOT return a message-body in the response.
         * this code comparesthe first 4 Chars to "HEAD"
         */
        public bool IsHeadRequest(byte[] httpHeader)
        {
            if (httpHeader[0] == 72 && httpHeader[1] == 69 && httpHeader[2] == 65 && httpHeader[3] == 68)
                return true;

            return false;
        }

        public bool ExecuteUDP(byte[] httpHeader, MemoryStream reqStream)
        {
            MyUdpClient localClient = new MyUdpClient();
            localClient.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, ReceiveTimeOut);
            localClient.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, SendTimeOut);

            try
            {
                try
                {
                    localClient.Connect(endPoint);
                }
                catch (Exception e)
                {
                    Interlocked.Increment(ref counter);
                    throw e;
                }

                int contentLen;

                MemoryStream fullReq = new MemoryStream((int)(httpHeader.Length + reqStream.Length));

                fullReq.Write(httpHeader, 0, httpHeader.Length);
                fullReq.Write(reqStream.GetBuffer(), 0, (int)reqStream.Length);

                byte[] data = fullReq.GetBuffer();

                localClient.Send(data, data.Length);

                if (!IgnoreUDPReceive)
                {
                    byte[] responseData = localClient.Receive(ref endPoint);
                    int bytesRead = responseData.Length;
                    ParseReturn(responseData, out _httpStatus, out _XErr, out _XDelay, out contentLen);
                    if (_httpStatus == HttpStatusCode.OK)
                    {
                        int dataIndex = 0;
                        for (int i = 0; i < bytesRead - 3; i++)
                        {
                            if (responseData[i] == 0x0D && responseData[i + 1] == 0x0A &&
                                responseData[i + 2] == 0x0D && responseData[i + 3] == 0x0A)
                            {
                                dataIndex = i + 4;
                                break;
                            }
                        }

                        _respBuff = new byte[contentLen];
                        if (contentLen + dataIndex > bytesRead)
                        {
                            throw new Exception("FDTransaction: corrupt UDP response");
                        }
                        else
                        {
                            Array.Copy(responseData, dataIndex, _respBuff, 0, contentLen);
                        }
                    }
                }
                else
                {
                    _respBuff = new byte[0];
                    _httpStatus = HttpStatusCode.OK;
                    this._XErr = HResult.S_OK;
                }
            }
            finally
            {
                localClient.Close();
            }

            if (_httpStatus != HttpStatusCode.OK)
            {
                // We didn't get a continue... just ext
                if (_httpStatus == HttpStatusCode.Continue)
                {
                    //  This should never happen - we don't support multiple Continues
                    _XErr = 2;
                    return false;
                }
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\svc\VortexSvc.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Net;
using System.Text;
using System.Threading;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;

// Not implemented yet, but I tried. Maybe again.
// [assembly: xonline.common.installer.XomWindowsServiceInstallerAttribute(
//     Interface.vortex,
//     "Xbox Live Vortex Service",
//     "Sucks in logs and other data, chews it up, and spits it out")]

[assembly: ConfigAttribute(Component.vortexinh)]
[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.VortexTrace)]

namespace xonline.server.vortex
{
    public class VortexSvc : System.ServiceProcess.ServiceBase
    {
        private bool                    _fRunAsConsole = false;
        private InputEventMediator      _inputEventMediator;

        private StreamInsightMediator   _streamMediator;

        // Singleton
        private static VortexSvc _instance = null;
        public static VortexSvc Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new VortexSvc();
                }
                return _instance;
            }
        }

        public bool RunningAsConsole
        {
            get { return _fRunAsConsole; }
        }

        public InputEventMediator EventProvider
        {
            get { return _inputEventMediator; }
        }

        public StreamInsightMediator StreamInsightInstance
        {
            get { return _streamMediator; }
        }

        public VortexSvc()
        {  
        }

        
        // Set things in motion so your service can do its work.
        protected override void OnStart(string[] args)
        {
            Trace.Normal("Starting up Vortex");

            // Every 5 seconds, request an additional 10 seconds from the SCM. Use a 
            // threadpool thread. Disposing the timer will stop it. Vortex tends to
            // take a while to start sometimes, but it will never get permanently
            // stuck.

            if (!_fRunAsConsole)
            {
                int watchdogPeriodInMs = 5000;
                using (Timer watchdogTimer = new Timer(
                    p => base.RequestAdditionalTime(watchdogPeriodInMs * 2),
                    null,
                    0,
                    watchdogPeriodInMs))
                {
                    InitService();
                    _inputEventMediator.Start();
                }
            }
            else
            {
                // Hmm, awkward to refactor with the using() block.
                InitService();
                _inputEventMediator.Start();
            }
        }
 
        /// Stop this service.
        protected override void OnStop()
        {
            Trace.Normal("Shutting down Vortex");
            try
            {
                CloseService();
            }
            catch (Exception e)
            {
                // Not so great to have unhandled exceptions past here
                Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_STOP_ERROR, e,
                    "Unhandled error while shutting down the service. Please investigate and fix the code.");
            }
            _instance = null;
            Trace.Normal("Vortex is now dead");
        }

        private void InitService()
        {                   
            try
            {
                // Try to set current path to where our exe lives, to make diagnostic logging easier
                try
                {
                    string location = System.Reflection.Assembly.GetExecutingAssembly().Location;
                    string directory = System.IO.Path.GetDirectoryName(location);
                    System.Environment.CurrentDirectory = directory;
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_INIT_WARNING, e, 
                                "Failed setting the current directory, ignoring");
                }

                // XomLoggingControl.Init determines the current assembly, and will detect XblCore
                // if we don't override it here.
                try
                {
                    // This ensures we (vortex) get registered, not xblcore.
                    Config.Assembly = System.Reflection.Assembly.GetExecutingAssembly();

                    // This ensures our xmgmt name is our actual component name:
                    // e :vortexinh
                    // and not the name of the .exe:
                    // e :vortexsvc
                    // XomControlConnection.cs is responsible for this, but i'm hesitant 
                    // to change that code. Fortunately jelien provided this override 
                    // already.
                    XomLoggingControl.OverrideAssemblyName = Config.ComponentName;

                    XomLoggingControl.Init();
                    XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_INIT_ERROR, e, 
                                "Failed initializing XomLogging (no logging will be available)");
                    throw;
                }

                // Force singleton to initialize
                VortexConfig vcinst = VortexConfig.Instance;

                // Set up the non-IIS healthcheck listener
                try
                {
                    xonline.common.health.HealthListener.InitializeHealthListener(vcinst.Settings.ComponentName);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_INIT_ERROR, e, 
                                "Failed initializing the Healthcheck system, continuing for now (no healthchecks will be available)");
                }

                // Get event management stuff initialized
                _inputEventMediator = new InputEventMediator();

                // Get StreamInsight stuff initialized
                _streamMediator = new StreamInsightMediator();
              
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.VORTEX_SERVICE_INIT_ERROR, e, 
                            "Unexpected runtime error while initializing the Vortex service");
                throw;
            }
        }

        private void CloseService()
        {
            //xonline.common.health.HealthListener.ShutdownHealthListener();

            _inputEventMediator.Stop();

            if (StreamInsightInstance != null)
            {
                StreamInsightInstance.QueryStop(null);
                StreamInsightInstance.Dispose();
            }

            XomLoggingControl.Close();
        }

        void RunAsConsole(string[] args)
        {
            _fRunAsConsole = true;
            OnStart(args);

            try
            {
                Console.WriteLine("Running as console.  Type \"help\" for commands.");

                Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);

                while (_fRunAsConsole)
                {
                    string sCommand = Console.ReadLine();
                    if (String.IsNullOrEmpty(sCommand))
                        continue;

                    string sResponse = "Invalid Command\r\n";
                    try
                    {
                        ControlRequestEventArgs cmdArgs = new ControlRequestEventArgs(sCommand, 0);
                        sResponse = HandleManangementCommand(cmdArgs);
                    }
                    catch (Exception e)
                    {
                        Console.Write("Error: " + e.ToString() + "\r\n\r\n");
                    }

                    Console.Write(sResponse);
                }
            }
            finally
            {
                OnStop();
            }
        }

        void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            OnStop();
        }

        string HandleManangementCommand(ControlRequestEventArgs args)
        {
            string helpText = @"
VortexSvc Help:
querylist         : list StreamInsight queries
querystart <name> : start a query
querystop <name>  : stop a query
quit              : stop console process
";
            switch (args.Command.ToLower())
            {
                case "querylist":
                {
                    args.Handled = true;
                    if (StreamInsightInstance == null)
                        return "StreamInsight is disabled";

                    List<string> names = StreamInsightInstance.QueryList();
                    StringBuilder sb = new StringBuilder();
                    names.ForEach(n => sb.AppendFormat("{0}\r\n", n));
                    return sb.ToString();
                }

                case "querystart":
                {
                    args.Handled = true;
                    if (StreamInsightInstance == null)
                        return "StreamInsight is disabled";

                    if (args.CommandArgs.Length != 1)
                        return "Error: <queryname> is a required parameter";
                    if (StreamInsightInstance.QueryStart(args.CommandArgs[0]))
                        return "Success!";
                    else
                        return "Query not found.";
                }

                case "querystop":
                {
                    args.Handled = true;
                    if (StreamInsightInstance == null)
                        return "StreamInsight is disabled";

                    if (args.CommandArgs.Length != 1)
                        return "Error: <queryname> is a required parameter";
                    if (StreamInsightInstance.QueryStop(args.CommandArgs[0]))
                        return "Success!";
                    else
                        return "Query not found.";
                }

                case "help":
                    // leave handled as false to allow for all handlers to process help.
                    return helpText;

                case "quit":
                    args.Handled = true;
                    if (_fRunAsConsole != true)
                    {
                        return "Running in service mode. Cannot quit.\r\n";
                    }
                    else
                    {
                        _fRunAsConsole = false;
                        return "Exiting.\r\n";
                    }

                default:
                    return "";
            }
        }

        // The main entry point for the process
        static void Main(string[] args)
        {           
            VortexSvc srv = VortexSvc.Instance;

            bool fRunAsConsole = false;
            
            foreach (string sArg in args)
            {
                if (sArg.ToLower().Contains("console"))
                {
                    fRunAsConsole = true;
                }
            }

            if (fRunAsConsole)
            {
                srv.RunAsConsole(args);
            }
            else
            {
                System.ServiceProcess.ServiceBase.Run(srv);
            }
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string sResponse = VortexSvc.Instance.HandleManangementCommand(args);
                XomControlConnection.SendMessage(sResponse, args.RequestId);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }
    }        

    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestDemonstrateAdapters.cs ===
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.IO;
using System.Text;
using System.Threading;
using System.Reflection;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;

using xonline.server.vortex;
using xonline.server.vortex.cake;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Adapters;
using Microsoft.ComplexEventProcessing.Linq;

namespace xonline.test.vortexdvt
{
    public class TestAdapterConfig
    {

    }

    public partial class CAKE
    {
        [TestGroup, DVT]
        public class InputAdapterDemonstrations : VeiTestBaseGroup
        {
            Server _siServer = null;
            Application _siAppplication = null;
            CepStream<TestEvent> _siInputStream1 = null;
            CepStream<TestEvent> _siInputStream2 = null;
            CepStream<TestEvent> _siInputStreamO = null;
            OutputAdapter _siOutputAdapter = null;
            OutputAdapter _siOutputAdapterO = null;
            InputAdapter _siInputAdapter = null;
            InputAdapter _siInputAdapterO = null;

            CepStream<TestEvent> _siLinqQuery1 = null;
            CepStream<TestEvent> _siLinqQuery2 = null;
            CepStream<TestEvent> _siLinqQueryO = null;

            QueryTemplate _siQueryTemplate1 = null;
            QueryTemplate _siQueryTemplate2 = null;
            QueryTemplate _siQueryTemplateO = null;

            QueryBinder _siQueryBinder1 = null;
            QueryBinder _siQueryBinder2 = null;
            QueryBinder _siQueryBinderO = null;

            Query _siQuery1 = null;
            Query _siQuery2 = null;
            Query _siQueryO = null;

            [TestGroupSetup]
            public void SetupStreamInsight()
            {
                VeiInputAdapterConfig inputConfig1;
                VeiInputAdapterConfig inputConfig2;
                VeiOutputAdapterConfig outputConfig;
                VortexEventIngestionConfig config;

                AdvanceTimeGenerationSettings atgs;
                AdvanceTimeSettings ats;

                bool success = false;
                
                atgs = new AdvanceTimeGenerationSettings(1, TimeSpan.FromMilliseconds(1.0), false);
                ats = new AdvanceTimeSettings(atgs, null, AdvanceTimePolicy.Drop);

                Global.RO.Info("Setting up StreamInsight system");

                config = Konfiguration.KonfigurationUpdates.CreateConfig(
                    Konfiguration.KonfigurationUpdates.CreateLogConfig("WS-%", true,
                        Konfiguration.KonfigurationUpdates.CreateDefaultStreamConfig("TestStream1")),
                    Konfiguration.KonfigurationUpdates.CreateLogConfig("PS-Log", false,
                        Konfiguration.KonfigurationUpdates.CreateDefaultStreamConfig("TestStream2")),
                    Konfiguration.KonfigurationUpdates.CreateQueryConfig("QueryO",
                        Konfiguration.KonfigurationUpdates.CreateEventSinkConfig(
                            typeof(TestDispatch1).FullName,
                            Konfiguration.KonfigurationUpdates.CreateObjectMapperConfig("", "Message", "F1=$0,F2=$1")),
                        Konfiguration.KonfigurationUpdates.CreateEventSinkConfig(
                            typeof(TestDispatch2).FullName,
                            Konfiguration.KonfigurationUpdates.CreateObjectMapperConfig("", "Field1", "$0", "Field2", "$1"))
                            
                        ));

                inputConfig1 = new VeiInputAdapterConfig();
                inputConfig1.InitialConfig = config;
                inputConfig1.MaxEventQueueSize = 25;
                inputConfig1.StreamName = "TestStream1";

                inputConfig2 = new VeiInputAdapterConfig();
                inputConfig2.InitialConfig = config;
                inputConfig2.MaxEventQueueSize = 25;
                inputConfig2.StreamName = "TestStream2";

                outputConfig = new VeiOutputAdapterConfig();
                outputConfig.QueryName = "QueryO";
                outputConfig.InitialConfig = config;

                Global.RO.Info("Creating StreamInsight Application...");

                try
                {
                    _siServer = Server.Create("DevelopmentInstance");
                }
                catch (InvalidOperationException e)
                {
                    Global.RO.Fatal("Unable to create a local StreamInsight server under the 'DevelopmentInstance' instance name, please verify that the specified StreamInsight instance exists. " + e.Message);
                    throw;
                }

                try
                {
                    _siAppplication = _siServer.CreateApplication("CakeDVTApplication");
                    _siInputStream1 = CepStream<TestEvent>.Create("TestStream1");
                    _siInputStream2 = CepStream<TestEvent>.Create("TestStream2");
                    _siInputStreamO = CepStream<TestEvent>.Create("TestStreamO");

                    Global.RO.Info("Creating StreamInsight Adapters...");

                    _siOutputAdapter = _siAppplication.CreateOutputAdapter<TestOutputAdapterFactory>("TestOutputAdapter", "");
                    _siOutputAdapterO = _siAppplication.CreateOutputAdapter<VeiOutputAdapterFactory>("TestOutputAdapterO", "");
                    _siInputAdapter = _siAppplication.CreateInputAdapter<VeiInputAdapterFactory>("TestInputAdapter", "");
                    _siInputAdapterO = _siAppplication.CreateInputAdapter<TestInputAdapterFactory>("TestInputAdapterO", "");

                    Global.RO.Info("Buidling Queries...");

                    _siLinqQuery1 =
                        from e in _siInputStream1
                        select new TestEvent
                        {
                            Field1 = e.Field1,
                            Field2 = e.Field2
                        };

                    _siLinqQuery2 =
                        from e in _siInputStream2
                        select new TestEvent
                        {
                            Field1 = -e.Field1,
                            Field2 = -e.Field2
                        };

                    _siLinqQueryO =
                        from e in _siInputStreamO
                        select e;

                    _siQueryTemplate1 = _siAppplication.CreateQueryTemplate("TestQueryTemplate1", "", _siLinqQuery1);
                    _siQueryTemplate2 = _siAppplication.CreateQueryTemplate("TestQueryTemplate2", "", _siLinqQuery2);
                    _siQueryTemplateO = _siAppplication.CreateQueryTemplate("TestQueryTemplateO", "", _siLinqQueryO);

                    _siQueryBinder1 = new QueryBinder(_siQueryTemplate1);
                    _siQueryBinder2 = new QueryBinder(_siQueryTemplate2);
                    _siQueryBinderO = new QueryBinder(_siQueryTemplateO);

                    Global.RO.Info("Binding Queries...");

                    _siQueryBinder1.AddConsumer<TestEvent>("OutputAdapterBinding1", _siOutputAdapter, new TestAdapterConfig(), EventShape.Point, StreamEventOrder.FullyOrdered);
                    _siQueryBinder2.AddConsumer<TestEvent>("OutputAdapterBinding2", _siOutputAdapter, new TestAdapterConfig(), EventShape.Point, StreamEventOrder.FullyOrdered);
                    _siQueryBinderO.AddConsumer<TestEvent>("OutputAdapterBindingO", _siOutputAdapterO, outputConfig, EventShape.Point, StreamEventOrder.FullyOrdered);

                    _siQueryBinder1.BindProducer<TestEvent>("TestStream1", _siInputAdapter, inputConfig1, EventShape.Point, ats);
                    _siQueryBinder2.BindProducer<TestEvent>("TestStream2", _siInputAdapter, inputConfig2, EventShape.Point, ats);
                    _siQueryBinderO.BindProducer<TestEvent>("TestStreamO", _siInputAdapterO, new TestAdapterConfig(), EventShape.Point, ats);

                    _siQuery1 = _siAppplication.CreateQuery("Query1", "", _siQueryBinder1);
                    _siQuery2 = _siAppplication.CreateQuery("Query2", "", _siQueryBinder2);
                    _siQueryO = _siAppplication.CreateQuery("QueryO", "", _siQueryBinderO);

                    Global.RO.Info("Starting Queries...");

                    _siQuery1.Start();
                    _siQuery2.Start();
                    _siQueryO.Start();

                    Global.RO.Success("StreamInsight Successfully Initialized");

                    success = true;
                }
                finally
                {
                    if (!success)
                    {
                        _siServer.Dispose();
                        _siServer = null;
                    }
                }
            }

            [TestGroupTearDown]
            public void TearDownStreamSight()
            {
                Global.RO.Info("Tearing down StreamInsight system");

                Global.RO.Info("Stoping and Destroying StreamInsight Queries...");

                _siQuery1.Stop();
                _siQuery2.Stop();
                _siQueryO.Stop();

                _siQuery1.Delete();
                _siQuery2.Delete();
                _siQueryO.Delete();

                _siQuery1 = null;
                _siQuery2 = null;
                _siQueryO = null;

                Global.RO.Info("Destroying StreamInsight Query Templates...");
                
                _siQueryTemplate1.Delete();
                _siQueryTemplate2.Delete();
                _siQueryTemplateO.Delete();

                _siQueryTemplate1 = null;
                _siQueryTemplate2 = null;
                _siQueryTemplateO = null;

                Global.RO.Info("Destroying StreamInsight Adapters...");
                
                _siInputAdapter.Delete();
                _siInputAdapterO.Delete();
                _siOutputAdapter.Delete();
                _siOutputAdapterO.Delete();

                _siInputAdapter = null;
                _siInputAdapterO = null;
                _siOutputAdapter = null;
                _siOutputAdapterO = null;

                Global.RO.Info("Destroying StreamInsight Application...");

                _siAppplication.Delete();
                _siServer.Dispose();

                _siAppplication = null;
                _siServer = null;

                Global.RO.Success("StreamInsight Successfully Uninitialized");
            }

            private class Counter 
            {
                public int sum11, sum12;
                public int sum21, sum22;

                public Counter()
                {
                    sum11 = sum12 = sum21 = sum22 = 0;
                }
            }

            private Action<string> GetCounterUpdater(Counter counter)
            {
                Action<string> result =
                    s =>
                    {
                        if (s.StartsWith("result<"))
                        {
                            string[] items = s.Split('<', ',', '>');
                            int i1 = int.Parse(items[1]);
                            int i2 = int.Parse(items[2]);

                            if ((i1 > 0) && (i2 > 0))
                            {
                                counter.sum11 += Math.Abs(i1);
                                counter.sum12 += Math.Abs(i2);
                            }
                            else if ((i1 < 0) && (i2 < 0))
                            {
                                counter.sum21 += Math.Abs(i1);
                                counter.sum22 += Math.Abs(i2);
                            }
                            else
                            {
                                Global.RO.Fatal("Item dropped: {0}, {1}", i1, i2);
                            }

                            Global.RO.Info("Trace Intercepted [{0}]", s);
                        }
                    };

                return result;
            }

            [TestCase]
            public void Demonstrating_InputAdapter()
            {
                InputDataReader reader = new InputDataReader();
                Action<string> subscription;
                Counter actual;
                Counter expected;

                actual = new Counter();
                expected = new Counter();

                subscription = GetCounterUpdater(actual);

                Trace.TraceSubscriber += subscription;

                try
                {
                    for (int c = 0; c < 12; c++)
                    {
                        int i1, i2;

                        i1 = 1 << c;
                        i2 = 1 << (c + 1);

                        if (c % 2 == 1)
                        {
                            InputData input;

                            input = new InputData();
                            input.Identifier = "WS-FiddleStick";
                            input.Payload[0] = i1;
                            input.Payload[1] = i2;

                            expected.sum11 += i1;
                            expected.sum12 += i2;

                            VeiEventDispatcher.InputDispatcher.DispatchEvent(reader, input);
                        }

                        InputData data;

                        data = new InputData();
                        data.Identifier = "PS-Log";
                        data.Payload[0] = i1;
                        data.Payload[1] = i2;

                        expected.sum21 += i1;
                        expected.sum22 += i2;

                        VeiEventDispatcher.InputDispatcher.DispatchEvent(reader, data);
                    }

                    // forcing queries to be flushed
                    System.Threading.Thread.Sleep(500);

                    InputData term1;
                    InputData term2;

                    term1 = new InputData();
                    term1.Identifier = "WS-FiddleStick";
                    term1.Payload[0] = 0;
                    term1.Payload[1] = 0;

                    term2 = new InputData();
                    term2.Identifier = "PS-Log";
                    term2.Payload[0] = 0;
                    term2.Payload[1] = 0;

                    Global.RO.Info("Sending terminator items...");

                    VeiEventDispatcher.InputDispatcher.DispatchEvent(reader, term1);
                    VeiEventDispatcher.InputDispatcher.DispatchEvent(reader, term2);

                    System.Threading.Thread.Sleep(500);

                    _siQuery1.Stop();
                    _siQuery2.Stop();

                    Global.RO.Info("[{0},{1},{2},{3}]", actual.sum11, actual.sum12, actual.sum21, actual.sum22);

                    AssertEquals(expected.sum11, actual.sum11, "Sum(WS-%).Field1");
                    AssertEquals(expected.sum12, actual.sum12, "Sum(WS-%).Field2");
                    AssertEquals(expected.sum21, actual.sum21, "Sum(PS-Log).Field1");
                    AssertEquals(expected.sum22, actual.sum22, "Sum(PS-Log).Field2");
                }
                finally
                {
                    Trace.TraceSubscriber -= subscription;
                }
            }

            [TestCase]
            public void Demonstrating_OutputAdapter()
            {
                Action<string> subscription;
                List<string> expectedItems;
                AutoResetEvent asr = new AutoResetEvent(false);

                Global.RO.Info("Starting Queries...");

                expectedItems = new List<string>();
                expectedItems.Add("Dispatch1:F1=1,F2=1");
                expectedItems.Add("Dispatch1:F1=2,F2=4");
                expectedItems.Add("Dispatch1:F1=3,F2=9");
                expectedItems.Add("Dispatch1:F1=4,F2=16");
                expectedItems.Add("Dispatch2:1:1");
                expectedItems.Add("Dispatch2:2:4");
                expectedItems.Add("Dispatch2:3:9");
                expectedItems.Add("Dispatch2:4:16");

                subscription = s =>
                {
                    expectedItems.Remove(s);
                    if (expectedItems.Count == 0)
                        asr.Set();
                };

                Trace.TraceSubscriber += subscription;

                try
                {
                    Global.RO.Info("Waiting for input adapter to start...");
                    TestInputAdapter.Started.WaitOne();

                    TestInputAdapter.Write.Set();

                    // forcing queries to be flushed
                    Global.RO.Info("Waiting for events to be written...");
                    TestInputAdapter.Written.WaitOne();
                    TestInputAdapter.Written.Reset();

                    Global.RO.Info("Waiting 200ms before sending pulse...");
                    Thread.Sleep(200);

                    TestInputAdapter.Pulse.Set();
                    Global.RO.Info("Waiting for pulse to be written...");
                    TestInputAdapter.Written.WaitOne();
                    TestInputAdapter.Written.Reset();

                    Global.RO.Info("Waiting for the test to complete, for up to 5 seconds...");
                    asr.WaitOne(5000, false);

                    _siQuery1.Stop();
                    _siQuery2.Stop();
                    _siQueryO.Stop();

                    Global.RO.Info("ExpectedItems\n[\n  {0}\n]", string.Join("\n  ", expectedItems.ToArray()));

                    AssertEquals(expectedItems.Count, 0, "ExpectedItems.Count");
                }
                finally
                {
                    Trace.TraceSubscriber -= subscription;
                    asr.Close();
                }
            }

            #region Input Adapter

            public class TestInputAdapterFactory : IInputAdapterFactory<TestAdapterConfig>
            {
                public InputAdapterBase Create(TestAdapterConfig configInfo, EventShape eventShape, CepEventType cepEventType)
                {
                    return new TestInputAdapter();
                }

                public void Dispose()
                {
                    
                }
            }

            public class TestInputAdapter : PointInputAdapter
            {
                public static ManualResetEvent Pulse = new ManualResetEvent(false);
                public static ManualResetEvent Write = new ManualResetEvent(false);
                public static ManualResetEvent Written = new ManualResetEvent(false);
                public static ManualResetEvent Started = new ManualResetEvent(false);

                private bool _advanced = false;
                private bool _ran = false;

                protected override void Dispose(bool disposing)
                {
                    base.Dispose(disposing);

                    if (!_advanced)
                    {
                        Global.RO.Fatal("FATAL time advance never occurred");
                    }
                }

                public override void Resume()
                {
                    MakeEvents();
                }

                public override void Start()
                {
                    _ran = false;
                    _advanced = false;

                    Write.Reset();
                    Pulse.Reset();
                    Written.Reset();
                    Started.Set();
                    
                    MakeEvents();
                }

                private void MakeEvents()
                {
                    //EnqueueCtiEvent(DateTimeOffset.UtcNow);

                    //Thread.Sleep(10);

                    while (true)
                    {
                        if (AdapterState.Stopping == AdapterState)
                        {
                            Stopped();
                            return;
                        }

                        if (!_ran)
                        {
                            if (Write.WaitOne(10, false))
                            {
                                for (int c = 1; c <= 5; c++)
                                {
                                    PointEvent pe = CreateInsertEvent();

                                    pe.StartTime = DateTime.UtcNow;
                                    pe.SetField(0, c);
                                    pe.SetField(1, c * c);

                                    if (Enqueue(ref pe) == EnqueueOperationResult.Full)
                                    {
                                        ReleaseEvent(ref pe);
                                        Ready();

                                        return;
                                    }
                                }

                                //EnqueueCtiEvent(DateTimeOffset.UtcNow + TimeSpan.FromSeconds(1));
                                
                                _ran = true;

                                Written.Set();
                            }
                        }

                        if (Pulse.WaitOne(10, false))
                        {
                            PointEvent pe = CreateInsertEvent();

                            Pulse.Reset();

                            if (null != pe)
                            {
                                pe.StartTime = DateTime.UtcNow;
                                pe.SetField(0, 0);
                                pe.SetField(1, 0);

                                if (Enqueue(ref pe) == EnqueueOperationResult.Full)
                                {
                                    Global.RO.Error("ERROR unable to add enqueue pulse event, queue full.");

                                    ReleaseEvent(ref pe);
                                    Ready();

                                    return;
                                }
                                else
                                {
                                    Global.RO.Info("INFO writing advance event");
                                    _advanced = true;
                                }
                            }
                            else
                            {
                                Trace.Error("ERROR unable to create pulse event");
                            }

                            Written.Set();
                        }
                    }
                }
            }

            #endregion

            #region Output Adapter

            public class TestOutputAdapterFactory : IOutputAdapterFactory<TestAdapterConfig>
            {
                public OutputAdapterBase Create(TestAdapterConfig config, EventShape eventShape, CepEventType cepEventType)
                {
                    return new TestOutputAdapter(cepEventType);
                }

                public void Dispose()
                {

                }
            }

            public class TestOutputAdapter : PointOutputAdapter
            {
                private CepEventType eventType;

                public TestOutputAdapter(CepEventType eventType)
                {
                    this.eventType = eventType;
                }

                public override void Resume()
                {
                    EventConsumer(null);
                }

                public override void Start()
                {
                    EventConsumer(null);
                }

                private void EventConsumer(object context)
                {
                    while (true)
                    {
                        PointEvent @event;

                        if (AdapterState.Stopping == AdapterState)
                        {
                            var r = Dequeue(out @event);

                            if (DequeueOperationResult.Success == r)
                            {
                                ReleaseEvent(ref @event);
                            }

                            Stopped();

                            return;
                        }

                        var result = Dequeue(out @event);

                        if (DequeueOperationResult.Empty == result)
                        {
                            Ready();
                            return;
                        }
                        else
                        {
                            try
                            {
                                if (@event.EventKind == EventKind.Insert)
                                {
                                    string output;

                                    output = string.Format("result<{0},{1}>", @event.GetField(0), @event.GetField(1));

                                    Trace.Low(output);
                                }
                            }
                            finally
                            {
                                ReleaseEvent(ref @event);
                            }
                        }
                    }
                }
            }

            #endregion

            #region Target Type
		 
            public class TestEvent
            {
                public int Field1 = 0;
                public int Field2 = 0;
            }

	        #endregion

            #region Dispatch
            public class TestDispatch1 : IDispatchedSink
            {
                public string Message { get; set; }

                #region IDispatchedSink Members

                public void Dispatch()
                {
                    Trace.Low("Dispatch1:{0}", Message);
                }

                #endregion
            }

            public class TestDispatch2 : IDispatchedSink
            {
                public int Field1 { get; set; }
                public int Field2 { get; set; }

                #region IDispatchedSink Members

                public void Dispatch()
                {
                    Trace.Low("Dispatch2:{0}:{1}", Field1, Field2);
                }

                #endregion
            }
            #endregion
        }

        internal class InputData
        {
            internal string Identifier { get; set; }
            internal object[] Payload { get; set; }

            public InputData()
            {
                Payload = new object[2];
            }
        }

        internal class InputDataReader : PayloadReader
        {
            public override PayloadReader.Context CreateContext(object payload)
            {
                return new Context<InputData>((InputData)payload, ((InputData)payload).Identifier);
            }

            public override T ReadNamedField<T>(PayloadReader.Context context, string name, Func<object, T> converter)
            {
                return converter(null);
            }

            public override T ReadOrdinalField<T>(PayloadReader.Context context, int ordinal, Func<object, T> converter)
            {
                return converter(((Context<InputData>)context).Payload.Payload[ordinal]);
            }

            public override int GetOrdinalCount(PayloadReader.Context context)
            {
                return ((Context<InputData>)context).Payload.Payload.Length;
            }

            public override string[] GetNamedFields(PayloadReader.Context context)
            {
                return new string[0];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestLogString2.cs ===
using System;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Web;
using System.Web.Hosting;
using System.IO;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.config;

namespace xonline.test.vortexdvt 
{

public partial class ProtocolTests 
{

    [TestGroup, DVT]
    [CompoundCase("Direct", 0)]
    [CompoundCase("ActiveAuth", 1)]
    public class LogString2 : VortexDVTTestBaseGroup
    {
        protected readonly bool _fKeepAlive = false;
        protected string _apiName;
        protected string _apiNameAA;
        protected string _apiNameFast;

        public void SetupApis()
        {
            IVirtualInterfaceInfo viiaa = Config.GetVirtualInterface(VirtualInterface.authsg);
            IVirtualInterfaceInfo vii = Config.GetVirtualInterface((string)Parent.Parent.MyValues[0]);

            _apiNameFast = "/" + vii.VDir + "/LogString2.ashx";

            _apiName = String.Format("http://{0}:{1}/{2}/{3}",
                                     vii.IPAddressString,
                                     vii.Port,
                                     vii.VDir,
                                     "LogString2.ashx");

            _apiNameAA = String.Format("http://{0}:{1}/{2}/{3}",
                                       viiaa.IPAddressString,
                                       viiaa.Port,
                                       vii.VDir,
                                       "LogString2.ashx");

            Global.RO.Debug(_apiName);
            Global.RO.Debug(_apiNameAA);
            Global.RO.Debug(_apiNameFast);

        }

        protected string Send(string requestStr, string method, byte[] content, bool fKeepAlive)
        {
            if (_apiName == null || _apiNameAA == null)
            {
                SetupApis();
            }

            string url;
            int transType = (int)MyValues[0];
            switch (transType)
            {
            case 0:
                url = _apiName + requestStr;
                return PostRequest(url, method, content, fKeepAlive, false);
            case 1:
                // use activeauth
                url = _apiNameAA + requestStr;
                return PostRequest(url, method, content, fKeepAlive, true);
            default:
                return null;
            }
        }

        [TestCase, Description("No params, GET")]
        [StressTest]
        public void NoParams()
        {
            string requestStr = "";
            string responseStr = Send(requestStr, "GET", null, _fKeepAlive);
        }

        [TestCase, Description("Very basic params, GET")]
        [StressTest]
        public void IdAndTimestampOnly()
        {
            string requestStr = "?v1=IdAndTimestampOnly&v35=" + DateTime.UtcNow.ToFileTimeUtc();
            string responseStr = Send(requestStr, "GET", null, _fKeepAlive);
        }

        [TestCase, Description("More params, GET")]
        [StressTest]
        public void MoreParams()
        {
            string requestStr = "?v1=MoreParams&v35=" + DateTime.UtcNow.ToFileTimeUtc();
            requestStr = requestStr + "&v2=foo&v3=bar&v4=1&v5=0xFFFE07D1&v6=" + HttpUtility.UrlEncode(DateTime.Now.ToString());
            string responseStr = Send(requestStr, "GET", null, _fKeepAlive);
        }

        [TestCase, Description("More params, GET")]
        [StressTest]
        public void ClickStreamRequest()
        {
            //string requestStr = 
            //"?vid=FA093CF3CF3D02BF&v2=en-US&v3=0:00&v4=en&v5=US&v6=Gold&v9=640x480i S 
            //TV&v10=4,0,4,0&v11=11747&v12=11156&v13=100.000&v14=1,1,1,0&v15=0,0,0,0,0,0,0&v16=0&v17=0,0,0,0,0,0,0,0&v18=0,0,0,disabled&v7=homepage&v1=Epix&v36=homepage&v31=Notlight&v32=Facebook&v33=0&v35=homepage/Notlight/0&v34=0/Facebook&pageName=homepage/Notlight/0/Facebook&events=event6&v8=D=pageName&en=UTF-8";
            //requestStr = System.Web.HttpUtility.UrlEncode(requestStr);
            string requestStr2 = "?vid=FA093CF3CF3D02BF&v2=en-US&v3=0%3A00&v4=en&v5=US&v6=Gold&v9=640x480i%20S%20TV&v10=4%2C0%2C4%2C0&v11=11747&v12=11156&v13=100.000&v14=1%2C1%2C1%2C0&v15=0%2C0%2C0%2C0%2C0%2C0%2C0&v16=0&v17=0%2C0%2C0%2C0%2C0%2C0%2C0%2C0&v18=0%2C0%2C0%2Cdisabled&v7=homepage&v1=Epix&v36=homepage&v31=Notlight&v32=Facebook&v33=0&v35=homepage%2FNotlight%2F0&v34=0%2FFacebook&pageName=homepage%2FNotlight%2F0%2FFacebook&events=event6&v8=D=pageName&en=UTF-8";
            string responseStr = Send(requestStr2, "GET", null, _fKeepAlive);
        }

        [TestCase, Description("")]
        [StressTest]
        public void IdAndTimestampOnly_KeepAlive()
        {
            string requestStr = "?v1=IdAndTimestampOnly&v35=" + DateTime.UtcNow.ToFileTimeUtc();
            string responseStr = Send(requestStr, "GET", null, true);
        }

        [TestCase, Description("")]
        [StressTest]
        public void IdAndTimestampOnly_FastTCP()
        {
            IPEndPoint viIP = Global.XEnv.GetVirtualInterface((string)Parent.MyValues[0]);
            string requestStr = "?v1=IdAndTimestampOnly&v35=" + DateTime.UtcNow.ToFileTimeUtc();
            PostRequestFast(viIP, "GET", _apiNameFast + requestStr, null, true);
        }

        [TestCase, Description("")]
        public void Sparse_5000Params_Neg()
        {
            string responseStr = Send("?v1=TooMany&v5000=z", "GET", null, true);
        }

        [TestCase, Description("")]
        public void Sparse_10000000Params_Neg()
        {
            string responseStr = Send("?v1=TooMany&v10000000=z", "GET", null, true);
        }

        [TestCase, Description("")]
        public void EdgeCases_Neg()
        {
            string responseStr;
            responseStr = Send("?v", "GET", null, true);
            responseStr = Send("?v1", "GET", null, true);
            responseStr = Send("?v=1", "GET", null, true);
            responseStr = Send("?a1=a", "GET", null, true);
            responseStr = Send("?1=v", "GET", null, true);
            responseStr = Send("?v1=b&v", "GET", null, true);
            responseStr = Send("?v1=c&v3", "GET", null, true);
            responseStr = Send("?v1=d&v=3", "GET", null, true);
            responseStr = Send("?v1=&3=e", "GET", null, true);
            responseStr = Send("?v1=f&v3g", "GET", null, true);
            responseStr = Send("?v999", "GET", null, true);
            responseStr = Send("?=h", "GET", null, true);
            responseStr = Send("?=v1=i", "GET", null, true);
            responseStr = Send("?v=v1=j", "GET", null, true);
        }

        [TestCase, Description("Send a failure event (EPIXDownloadFail)")]
        [StressTest]
        public void FailureMessage()
        {
            string requestStr = "?v1=EPIXDownloadFail&v2=" + DateTime.UtcNow.ToFileTimeUtc();
            string responseStr = Send(requestStr, "GET", null, _fKeepAlive);
        }

        [TestCase, Description("Send an invalid URL")]
        public void InvalidUrlGET()
        {
            string url;
            int transType = (int)MyValues[0];
            switch (transType)
            {
            case 0:
                url = _apiName + "invalid?v1=InvalidUrl&v2=fooberries";
                PostRequest(url, "GET", null, false, false);
                break;
            case 1:
                // use activeauth
                url = _apiNameAA + "invalid?v1=InvalidUrl&v2=fooberriesAA";
                PostRequest(url, "GET", null, false, false);
                break;
            }
        }

    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestLogString.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;
using xonline.common.protocol;

namespace xonline.test.vortexdvt 
{

public partial class ProtocolTests 
{

    [TestGroup, DVT]
    public class LogString : VortexDVTTestBaseGroup
    {
        private int _sequenceNum = 0;

        protected string Send(params string[] loglines)
        {
            string apiName = VortexDVTTestBaseGroup.BuildUrl("logstring.ashx", (string)Parent.MyValues[0]);

            StringLogRequest req = new StringLogRequest();
            string suffix = "";
            foreach (string line in loglines)
            {
                req.logLines += line + suffix;
                suffix = "\n";
            }
            return VortexUtil.PostRequest(apiName, "POST", req.GetBytes(), false);
        }

        [TestCase, Description("Send message with 1 event via LogString to Vortex")]
        [StressTest]
        public void BasicMessage()
        {
            Send("VXDVT1|100|Hello world!|" + _sequenceNum++);
        }

        [TestCase, Description("Send message with 2 events via LogString to Vortex")]
        [StressTest]
        public void BasicMessage2()
        {
            string msg = "VXDVT2|200|Hello world!|" + _sequenceNum++;
            msg += "\nVXDVT3|300|Goodbye!|-1|" + _sequenceNum++;
            Send(msg);
        }


        [TestCase, Description("Send a measurement event (SigninTime)")]
        [StressTest]
        public void MeasurementMessage_BelowThresh()
        {
            // 4000 = 0xFA0
            Send("SigninTime|FA0|" + _sequenceNum++);
        }

        [TestCase, Description("Send a measurement event (SigninTime)")]
        [StressTest]
        public void MeasurementMessage_AboveThresh()
        {
            // 5000 = 0x1388
            Send("SigninTime|1388|" + _sequenceNum++);
        }

        [TestCase, Description("Send a failure event (EPIXDownloadFail)")]
        [StressTest]
        public void FailureMessage()
        {
            Send("EPIXDownloadFail|/foo/bar|" + _sequenceNum++);
        }

        [TestCase, Description("Send bad failure and measurement events")]
        public void InvalidForPerfCounter()
        {
            // Failure
            Send("epixdownloadfail|/foo/bar|" + _sequenceNum++);
            Send("|EPIXDownloadFail|/foo/bar|" + _sequenceNum++);
            Send("");

            // Measurement
            Send("signintime|1388|" + _sequenceNum++);
            Send("SigninTime");
            Send("SigninTime|");
            Send("SigninTime||");
            Send("SigninTime|0x10000|" + _sequenceNum++);
            Send("SigninTime|foo|" + _sequenceNum++);
        }

        [TestCase, Description("Send a failure event (EPIXDownloadFail)")]
        [StressTest]
        public void InvalidUrlPOST()
        {
            string apiName = VortexDVTTestBaseGroup.BuildUrl("logstring.ashxinvalid", (string)Parent.MyValues[0]);

            StringLogRequest req = new StringLogRequest();
            req.logLines = "InvalidRequest|fooberries|" + _sequenceNum++;
            VortexUtil.PostRequest(apiName, "POST", req.GetBytes(), false);
        }

    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestPayloadReader.cs ===
using System;
using System.Linq;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Diagnostics;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;

using xonline.server.vortex;
using xonline.server.vortex.cake;

namespace xonline.test.vortexdvt
{
    public class TestPayloadReader : PayloadReader
    {
        public override PayloadReader.Context CreateContext(object payload)
        {
            return new TestContext((Dictionary<string, object>)payload);
        }

        public override T ReadNamedField<T>(PayloadReader.Context context, string name, Func<object, T> converter)
        {
            TestContext tc = (TestContext)context;
            object field;

            if (tc.Payload.TryGetValue(name, out field))
            {
                return converter(field);
            }

            return converter(null);
        }

        public override T ReadOrdinalField<T>(PayloadReader.Context context, int ordinal, Func<object, T> converter)
        {
            TestContext tc = (TestContext)context;
            object field;

            if (tc.Payload.TryGetValue(ordinal.ToString(), out field))
            {
                return converter(field);
            }

            return converter(null);
        }

        public override int GetOrdinalCount(PayloadReader.Context context)
        {
            TestContext tc = (TestContext)context;
            int tmp = 0;

            var ordinals =
                from e in tc.Payload.Keys
                where int.TryParse(e, out tmp)
                select int.Parse(e);

            return ordinals.Count() > 0 ? ordinals.Max() + 1 : 0;
        }

        public override string[] GetNamedFields(PayloadReader.Context context)
        {
            TestContext tc = (TestContext)context;
            int tmp = 0;

            var names =
                from e in tc.Payload.Keys
                where !int.TryParse(e, out tmp)
                orderby e
                select e;

            return names.ToArray();
        }

        private class TestContext : PayloadReader.Context<Dictionary<string, object>>
        {
            public new Dictionary<string, object> Payload
            {
                get
                {
                    return base.Payload;
                }
            }

            public TestContext(Dictionary<string, object> payload) : base(payload, payload["id"].ToString())
            {

            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestPerfCounters.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.server.vortex
{
    public class VortexCounters
    {
        static public VortexCounters Current = new VortexCounters();

        public MockPerformanceCounter InputIOThreadsAvailable = new MockPerformanceCounter();

        public MockPerformanceCounter InputIOThreadsMax = new MockPerformanceCounter();

        public MockPerformanceCounter InputIOThreadsMin = new MockPerformanceCounter();

        public MockPerformanceCounter InputWorkerThreadsAvailable = new MockPerformanceCounter();

        public MockPerformanceCounter InputWorkerThreadsMax = new MockPerformanceCounter();

        public MockPerformanceCounter InputWorkerThreadsMin = new MockPerformanceCounter();

        public MockPerformanceCounter IncomingMessageQueue = new MockPerformanceCounter();

        public MockPerformanceCounter MessagesDroppedRateTooOld = new MockPerformanceCounter();

        public MockPerformanceCounter MessagesDroppedTotalTooOld = new MockPerformanceCounter();

        public MockPerformanceCounter MessageQueueRemainingWorker = new MockPerformanceCounter();

        public MockPerformanceCounter InputQueueEvictions = new MockPerformanceCounter();

        public MockPerformanceCounter UndispatchedOutputEvents = new MockPerformanceCounter();

        public MockPerformanceCounter OuputEventDispatchFailures = new MockPerformanceCounter();

        public MockPerformanceCounter InvalidFieldAccess = new MockPerformanceCounter();

        public MockPerformanceCounter MessagesInProgress = new MockPerformanceCounter();

        public MockPerformanceCounter EventsWithoutManifestRate = new MockPerformanceCounter();

        public MockPerformanceCounter EventsWithoutManifestTotal = new MockPerformanceCounter();

        public MockPerformanceCounter AverageMessageBatchSize = new MockPerformanceCounter();

        public MockPerformanceCounter AverageMessageBatchSizeBase = new MockPerformanceCounter();

        public MockPerformanceCounter AverageMessageContextSwitchRate = new MockPerformanceCounter();

        public MockPerformanceCounter AverageMessageLatency = new MockPerformanceCounter();

        public MockPerformanceCounter AverageMessageLatencyBase = new MockPerformanceCounter();

        public MockPerformanceCounter MessageQueueDiscarded = new MockPerformanceCounter();

        public MockPerformanceCounter SGInfoLookupsInProgress = new MockPerformanceCounter();

        public MockPerformanceCounter XomLogInProgress = new MockPerformanceCounter();

    }

    public class VortexMessageCounters
    {
        public virtual VortexMessageCounters this[string transport]
        {
            get
            {
                return GetInstance(transport);
            }
        }

        public VortexMessageCounters GetInstance(string name)
        {
            return Current;
        }

        static public VortexMessageCounters Current = new VortexMessageCounters();

        public MockPerformanceCounter IncomingBytesRate = new MockPerformanceCounter();

        public MockPerformanceCounter IncomingBytesTotal = new MockPerformanceCounter();

        public MockPerformanceCounter IncomingMessagesRate = new MockPerformanceCounter();

        public MockPerformanceCounter IncomingMessagesTotal = new MockPerformanceCounter();

        public MockPerformanceCounter IncomingMessagesInProgress = new MockPerformanceCounter();

        public MockPerformanceCounter IncomingEventsRate = new MockPerformanceCounter();

        public MockPerformanceCounter IncomingEventsTotal = new MockPerformanceCounter();

        public MockPerformanceCounter AverageEventsPerMessage = new MockPerformanceCounter();

        public MockPerformanceCounter AverageEventsPerMessageBase = new MockPerformanceCounter();

        public MockPerformanceCounter AverageMessageSize = new MockPerformanceCounter();

        public MockPerformanceCounter AverageMessageSizeBase = new MockPerformanceCounter();

        public MockPerformanceCounter IoOperationsPending = new MockPerformanceCounter();

        public MockPerformanceCounter IoReceiveBufferAvailableBytes = new MockPerformanceCounter();

    }

    public class MockPerformanceCounter
    {
        public void Increment()
        {

        }

        public void IncrementBy(long val)
        {

        }

        public void Decrement()
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestEtxManifestHelper.cs ===
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Specialized;
using System.Xml;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Vortex;
using ServerTestFramework.Core.Utilities;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.core.etx;
using xonline.common.core.etx.collections;
using xonline.common.utilities2;
using xonline.server.vortex.fd;
using xonline.server.vortex.common;

namespace xonline.test.vortexdvt
{

[TestGroup, DVT]
public class EtxManifestHelperTest : VortexDVTTestBaseGroup
{

    public static string TestManifest1String = 
@"<?xml version='1.0' encoding='utf-8'?>
<etxmanifest>
  <instrumentation>
    <globaleventproducers>
      <producer symbol='TestProducer1' id='E5743D51C3384707B95A75D457945A38' header='1'>
        <description>Description of TestProducer1</description>
        <events>
          <event value='0' symbol='TestEvent1' category='Standard' logstringid='TESTEVENT1'>
            <description>Description of TestEvent1</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='Op' inType='UInt32'/>
              <data ordinal='3' name='ConsoleId' inType='Binary' outType='ConsoleId' autovalue='ConsoleId' autovaluecreator='LiveUploaderDynamic'/>
              <data ordinal='4' name='FlowToken' inType='UInt64' outType='FlowToken' autovalue='FlowToken' autovaluecreator='LiveService'/>
            </datafields>
          </event>
          <event value='1' symbol='TestEvent2' category='Standard' header='1'>
            <description>Description of TestEvent2</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='Op' inType='UInt32'/>
              <data ordinal='3' name='ConsoleId' inType='Binary' outType='ConsoleId' autovalue='ConsoleId' autovaluecreator='LiveUploaderDynamic'/>
              <data ordinal='4' name='MachineId' inType='UInt64' autovalue='MachineId' autovaluecreator='LiveService'/>
            </datafields>
          </event>
          <event value='2' symbol='TestEvent3' category='OfflineClickstream' logstringid='TESTEVENT3'>
            <description>Description of TestEvent3</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' autovalue='LogStringId' autovaluecreator='LiveService'/>
              <data ordinal='2' name='Op' inType='UInt32'/>
              <data ordinal='3' name='ConsoleId' inType='Binary' outType='ConsoleId' autovalue='ConsoleId' autovaluecreator='LiveUploaderDynamic'/>
              <data ordinal='4' name='FlowToken' inType='UInt64' outType='FlowToken' autovalue='FlowToken' autovaluecreator='LiveService'/>
            </datafields>
          </event>
        </events>
      </producer>
    </globaleventproducers>
  </instrumentation>
</etxmanifest>";

    public void GetEvent0(out VxEvent vxEvent, out Event etxEvent)
    {
        Blob producerId = Blob.Parse("E5743D51C3384707B95A75D457945A38");

        vxEvent = new VxEvent(producerId, 0, DateTime.Now);
        vxEvent.EventFields.AddField(2, (uint)4);
        vxEvent.EventFields.AddField(3, new byte[] { 37, 45, 96, 153, 4 });
        
        EtxManifest TestManifest1 = new EtxManifest(XmlReader.Create(new StringReader(TestManifest1String)));
        Producer prod = TestManifest1.Producers[ProducerCollectionKeys.Fingerprint, producerId];
        etxEvent = prod.Events[EventCollectionKeys.Ordinal, vxEvent.EventId];
    }

    [TestCase]
    public void TestClassifyEvents()
    {
        EtxManifest TestManifest1 = new EtxManifest(XmlReader.Create(new StringReader(TestManifest1String)));

        VxEvent ve1 = new VxEvent(Blob.Parse("E5743D51C3384707B95A75D457945A38"), 1, DateTime.Now);
        ve1.EventFields.AddField(1, "TESTEVT1FOO");
        ve1.EventFields.AddField(2, (uint)4);
        List<VxEvent> eventList = new List<VxEvent>() 
        {
            ve1
        };

        List<VxEventWithManifest> eventsWithManifests;
        AutoValueSource avs = EtxManifestHelper.ClassifyEvents(eventList, TestManifest1, true, false, out eventsWithManifests);
        ValueCheck.IsTrue(eventsWithManifests != null, "eventsWithManifests != null");
        ValueCheck.IsTrue(eventsWithManifests.Count == 1, "eventsWithManifests.Count == 1");
        ValueCheck.IsTrue(eventsWithManifests[0].EventManifest != null, "eventsWithManifests[0] has manifest");
        ValueCheck.IsTrue((avs & AutoValueSource.SGInfo) > 0, "SGInfo source");
        ValueCheck.IsTrue((avs & AutoValueSource.EtxManifest) > 0, "EtxManifest source");
    }

    [TestCase]
    public void TestClassifyEventsIFLC()
    {
        // Only event 2 (OfflineClickstream) is allowed through IFLC

        EtxManifest TestManifest1 = new EtxManifest(XmlReader.Create(new StringReader(TestManifest1String)));

        VxEvent ve1 = new VxEvent(Blob.Parse("E5743D51C3384707B95A75D457945A38"), 1, DateTime.Now);
        ve1.EventFields.AddField(1, "TESTEVT1FOO");
        ve1.EventFields.AddField(2, (uint)1);
        VxEvent ve2 = new VxEvent(Blob.Parse("E5743D51C3384707B95A75D457945A38"), 2, DateTime.Now);
        ve2.EventFields.AddField(1, "TESTEVT3FOO");
        ve2.EventFields.AddField(2, (uint)2);
        List<VxEvent> eventList = new List<VxEvent>() 
        {
            ve1,
            ve2,
        };

        List<VxEventWithManifest> eventsWithManifests;
        AutoValueSource avs = EtxManifestHelper.ClassifyEvents(eventList, TestManifest1, true, true, out eventsWithManifests);
        ValueCheck.IsTrue(eventsWithManifests != null, "eventsWithManifests != null");
        ValueCheck.IsTrue(eventsWithManifests.Count == 1, "eventsWithManifests.Count == 1");  // not 2
        ValueCheck.IsTrue(eventsWithManifests[0].EventManifest != null, "eventsWithManifests[0] has manifest");
        ValueCheck.IsTrue(eventsWithManifests[0].EventData.EventId == ve2.EventId, "eventsWithManifests[0].EventId == ve2.EventId");
        ValueCheck.IsTrue((avs & AutoValueSource.SGInfo) > 0, "SGInfo source");
        ValueCheck.IsTrue((avs & AutoValueSource.EtxManifest) > 0, "EtxManifest source");
    }

    [TestGroup]
    public class WriteFieldOutputValue_Positive
    {

        [TestCase]
        public void TestWriteFieldOutputValue_String()
        {
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue("foo", OutputType.String, sb);
            EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1, 2, 3, 4 }, OutputType.String, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "foo01020304", sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_Number()
        {
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue((byte)254, OutputType.Number, sb);
            EtxManifestHelper.WriteFieldOutputValue((sbyte)-1, OutputType.Number, sb);
            EtxManifestHelper.WriteFieldOutputValue((ushort)40000, OutputType.Number, sb);
            EtxManifestHelper.WriteFieldOutputValue((short)-30000, OutputType.Number, sb);
            EtxManifestHelper.WriteFieldOutputValue((uint)600000, OutputType.Number, sb);
            EtxManifestHelper.WriteFieldOutputValue((int)-500000, OutputType.Number, sb);
            EtxManifestHelper.WriteFieldOutputValue((ulong)8000000, OutputType.Number, sb);
            EtxManifestHelper.WriteFieldOutputValue((long)-7000000, OutputType.Number, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "254-140000-30000600000-5000008000000-7000000", sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_HexNumber()
        {
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue((byte)128, OutputType.HexNumber, sb);
            EtxManifestHelper.WriteFieldOutputValue((sbyte)-1, OutputType.HexNumber, sb);
            EtxManifestHelper.WriteFieldOutputValue((ushort)32, OutputType.HexNumber, sb);
            EtxManifestHelper.WriteFieldOutputValue((short)-2, OutputType.HexNumber, sb);
            EtxManifestHelper.WriteFieldOutputValue((uint)48, OutputType.HexNumber, sb);
            EtxManifestHelper.WriteFieldOutputValue((int)-3, OutputType.HexNumber, sb);
            EtxManifestHelper.WriteFieldOutputValue((ulong)64, OutputType.HexNumber, sb);
            EtxManifestHelper.WriteFieldOutputValue((long)-4, OutputType.HexNumber, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "80FF20FFFE30FFFFFFFD40FFFFFFFFFFFFFFFC", sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_Float()
        {
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue((float)1.2, OutputType.Float, sb);
            EtxManifestHelper.WriteFieldOutputValue((double)-1.3, OutputType.Float, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "1.2-1.3", sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_DateTime()
        {
            string dtStr = "2010/01/02 03:04:05.123";
            DateTime dt = DateTime.Parse(dtStr);

            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue((long)dt.ToFileTimeUtc(), OutputType.DateTime, sb);
            EtxManifestHelper.WriteFieldOutputValue((ulong)dt.ToFileTimeUtc(), OutputType.DateTime, sb);
            EtxManifestHelper.WriteFieldOutputValue(dt, OutputType.DateTime, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", dtStr + dtStr + dtStr, sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_Ipv4Address()
        {
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue((uint)0x04030201, OutputType.Ipv4Address, sb);
            EtxManifestHelper.WriteFieldOutputValue((IPAddress)IPAddress.Parse("1.2.3.4"), OutputType.Ipv4Address, sb);
            EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1, 2, 3, 4 }, OutputType.Ipv4Address, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "1.2.3.41.2.3.41.2.3.4", sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_GUID()
        {
            byte[] guidbytes = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
            string guidstr = "04030201-0605-0807-090a-0b0c0d0e0f10";

            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue(guidbytes, OutputType.GUID, sb);
            EtxManifestHelper.WriteFieldOutputValue(new Guid(guidbytes), OutputType.GUID, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", guidstr + guidstr, sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_FlowToken()
        {
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue((ulong)0x01020304050607EE, OutputType.FlowToken, sb);
            EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), OutputType.FlowToken, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "FT01020304050607EEFT01020304050607EE", sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_HResult()
        {
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue((uint)0x8015B00B, OutputType.HResult, sb);
            EtxManifestHelper.WriteFieldOutputValue((uint)0x8FFFFFF1, OutputType.HResult, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "0x8015B00B:XONLINE_E_SIGNATURE_LICENSE_COUNT_EXCEEDED0x8FFFFFF1:", sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_XexVersion()
        {
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue((uint)0x21076003, OutputType.XexVersion, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "2.1.1888.3", sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_TitleName()
        {
            // Not quite working yet
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue((uint)0x4D53082A, OutputType.TitleName, sb);
            EtxManifestHelper.WriteFieldOutputValue((uint)0x4D01ABCD, OutputType.TitleName, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "0x4D53082A:Halo 30x4D01ABCD:", sb.ToString());
        }

        [TestCase]
        public void TestWriteFieldOutputValue_ConsoleId()
        {
            // Positive cases, nothing should throw
            StringBuilder sb = new StringBuilder();
            EtxManifestHelper.WriteFieldOutputValue(new byte[] { 37, 45, 96, 153, 4 }, OutputType.ConsoleId, sb);
            EtxManifestHelper.WriteFieldOutputValue((ulong)0x0499602D25, OutputType.ConsoleId, sb);
            ro.Debug(sb.ToString());
            ValueCheck.Test<string, string>("String", "012345678905012345678905", sb.ToString());
        }

    }

    [TestGroup]
    public class WriteFieldOutputValue_Negative
    {
        public void CatchEx(Type expectedException, params Action[] actionList)
        {
            foreach (Action act in actionList)
            {
                try
                {
                    act();
                    throw new Exception("No exception thrown, expected one of type " + expectedException);
                }
                catch (Exception e)
                {
                    ro.Debug("Got exception type {0}: {1}", e.GetType(), e.Message);
                    if (e.GetType() != expectedException)
                    {
                        throw;
                    }
                }
            }
        }
        
        [TestCase]
        public void TestWriteFieldOutputValue_String()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.String;
            CatchEx(typeof(ArgumentException), 
                () => EtxManifestHelper.WriteFieldOutputValue((uint)0x1, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue((float)1.2, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_Number()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.Number;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((float)1.2, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("foo", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(DateTime.UtcNow, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_HexNumber()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.HexNumber;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((float)1.2, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("foo", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_Float()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.Float;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((int)4, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("foo", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_DateTime()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.DateTime;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((int)4, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue((uint)1000000, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("2010/01/02 13:00:01.234", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_Ipv4Address()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.Ipv4Address;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((int)4, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue((ulong)1000000, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("2010/01/02 13:00:01.234", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_GUID()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.GUID;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((int)4, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue((ulong)1000000, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("2010/01/02 13:00:01.234", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_FlowToken()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.FlowToken;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((int)4, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue((long)1000000, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("2010/01/02 13:00:01.234", ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_HResult()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.HResult;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((int)4, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue((ulong)1000000, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1,2,3,4 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("2010/01/02 13:00:01.234", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_XexVersion()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.XexVersion;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((int)4, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue((ulong)1000000, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1, 2, 3, 4 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("2010/01/02 13:00:01.234", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_TitleName()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.TitleName;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((int)4, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue((ulong)1000000, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1, 2, 3, 4 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("2010/01/02 13:00:01.234", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

        [TestCase]
        public void TestWriteFieldOutputValue_ConsoleId()
        {
            StringBuilder sb = new StringBuilder();
            OutputType ot = OutputType.ConsoleId;
            CatchEx(typeof(ArgumentException),
                () => EtxManifestHelper.WriteFieldOutputValue((uint)4, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue((long)1000000, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1, 2, 3, 4 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new byte[] { 1, 2, 3, 4, 5, 6 }, ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue("2010/01/02 13:00:01.234", ot, sb),
                () => EtxManifestHelper.WriteFieldOutputValue(new Floken(0x01020304050607EE), ot, sb)
            );
        }

    }

    [TestCase]
    public void TestApplyManifest()
    {
        VxEvent vxEvent;
        Event etxEvent;
        GetEvent0(out vxEvent, out etxEvent);
        ValueCheck.IsTrue(vxEvent != null, "vxEvent not null");
        ValueCheck.IsTrue(etxEvent != null, "etxEvent not null");

        VxEventWithManifest vx = new VxEventWithManifest() 
        {
            EventData = vxEvent,
            EventManifest = etxEvent,
            HeaderData = new VxEvent.VortexFieldCollection(),
            HeaderManifest = etxEvent.HeaderFields,
        };

        object obj;
        int idx;
        ro.Debug(EtxManifestHelper.ToLogString(vx, out idx));
        ValueCheck.IsTrue(vxEvent.EventFields.Count == 2, "count is 2");
        ValueCheck.IsTrue(vxEvent.EventFields.MaxFieldOrdinal == 3, "maxfieldordinal is 3");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(1, out obj) == false, "trygetfield(1) false");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(2, out obj) == true, "trygetfield(2) true");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(3, out obj) == true, "trygetfield(3) true");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(4, out obj) == false, "trygetfield(4) false");

        EtxManifestHelper.ApplyManifest(vx, null, null);
        ro.Debug(EtxManifestHelper.ToLogString(vx, out idx)); 
        ValueCheck.IsTrue(vxEvent.EventFields.Count == 4, "count is 4");
        ValueCheck.IsTrue(vxEvent.EventFields.MaxFieldOrdinal == 4, "maxfieldordinal is 4");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(1, out obj) == true, "trygetfield(1) true");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(2, out obj) == true, "trygetfield(2) true");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(3, out obj) == true, "trygetfield(3) true");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(4, out obj) == true, "trygetfield(4) true");
        ValueCheck.IsTrue(vxEvent.EventFields.GetField(4) == null, "getfield(4) == null");

        xonline.common.service.SGInfo sginfo = new xonline.common.service.HTTPAuthData(new Floken(0x0102030405060708));
        EtxManifestHelper.ApplyManifest(vx, sginfo, null);
        ro.Debug(EtxManifestHelper.ToLogString(vx, out idx)); 
        ValueCheck.IsTrue(vxEvent.EventFields.Count == 4, "count is 4");
        ValueCheck.IsTrue(vxEvent.EventFields.MaxFieldOrdinal == 4, "maxfieldordinal is 4");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(1, out obj) == true, "trygetfield(1) true");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(2, out obj) == true, "trygetfield(2) true");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(3, out obj) == true, "trygetfield(3) true");
        ValueCheck.IsTrue(vxEvent.EventFields.TryGetField(4, out obj) == true, "trygetfield(4) true");
        ValueCheck.IsTrue(vxEvent.EventFields.GetField(4) != null, "getfield(4) != null");
        ro.Debug(vxEvent.EventFields.GetField(4).ToString());

    }



    [TestCase]
    public void TestToLogString()
    {
        VxEvent vxEvent;
        Event etxEvent;
        GetEvent0(out vxEvent, out etxEvent);
        ValueCheck.IsTrue(vxEvent != null, "vxEvent not null");
        ValueCheck.IsTrue(etxEvent != null, "etxEvent not null");

        VxEventWithManifest vx = new VxEventWithManifest() 
        {
            EventData = vxEvent,
            EventManifest = etxEvent,
            HeaderData = new VxEvent.VortexFieldCollection(),
            HeaderManifest = etxEvent.HeaderFields,
        };
        int idx;

        string logstring = EtxManifestHelper.ToLogString(vx, out idx);
        ro.Debug(logstring);
        ValueCheck.IsTrue(logstring.StartsWith("|4|012345678905"), "StartsWith \"|4|012345678905\"");

        EtxManifestHelper.ApplyManifest(vx, null, null);
        logstring = EtxManifestHelper.ToLogString(vx, out idx);
        ro.Debug(logstring);
        ValueCheck.IsTrue(logstring.StartsWith("TESTEVENT1|4|012345678905|"), "StartsWith \"TESTEVT1|4|012345678905|\"");


    }


    [TestCase]
    public void TestConvertWireTypeToInType()
    {
        object val;

        ValueCheck.IsTrue(EtxManifestHelper.ConvertWireTypeToInType((ulong)byte.MaxValue, DataFieldType.UInt8, out val), "Line 1");
        ValueCheck.IsTrue((byte)val == byte.MaxValue, "Line 2");
        ValueCheck.IsTrue(EtxManifestHelper.ConvertWireTypeToInType((ulong)ushort.MaxValue, DataFieldType.UInt16, out val), "Line 3");
        ValueCheck.IsTrue((ushort)val == ushort.MaxValue, "Line 4");
        ValueCheck.IsTrue(EtxManifestHelper.ConvertWireTypeToInType((ulong)uint.MaxValue, DataFieldType.UInt32, out val), "Line 5");
        ValueCheck.IsTrue((uint)val == uint.MaxValue, "Line 6");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((ulong)ulong.MaxValue, DataFieldType.UInt64, out val), "Line 7");

        ValueCheck.IsTrue(EtxManifestHelper.ConvertWireTypeToInType((long)sbyte.MinValue, DataFieldType.Int8, out val), "Line 8");
        ValueCheck.IsTrue((sbyte)val == sbyte.MinValue, "Line 9");
        ValueCheck.IsTrue(EtxManifestHelper.ConvertWireTypeToInType((long)short.MinValue, DataFieldType.Int16, out val), "Line 10");
        ValueCheck.IsTrue((short)val == short.MinValue, "Line 11");
        ValueCheck.IsTrue(EtxManifestHelper.ConvertWireTypeToInType((long)int.MinValue, DataFieldType.Int32, out val), "Line 12");
        ValueCheck.IsTrue((int)val == int.MinValue, "Line 13");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((long)long.MinValue, DataFieldType.Int64, out val), "Line 14");

        Guid g = Guid.NewGuid();
        ValueCheck.IsTrue(EtxManifestHelper.ConvertWireTypeToInType((byte[])g.ToByteArray(), DataFieldType.GUID, out val), "Line guid");
        ValueCheck.IsTrue((Guid)val == g, "Line guid");
    }

    [TestCase]
    public void TestConvertWireTypeToInType_Negative()
    {
        object val;

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((byte)byte.MaxValue, DataFieldType.UInt8, out val), "Line 15");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((ushort)ushort.MaxValue, DataFieldType.UInt8, out val), "Line 16");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((uint)uint.MaxValue, DataFieldType.UInt8, out val), "Line 17");

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((byte)byte.MaxValue, DataFieldType.UInt16, out val), "Line 18");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((ushort)ushort.MaxValue, DataFieldType.UInt16, out val), "Line 19");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((uint)uint.MaxValue, DataFieldType.UInt16, out val), "Line 20");

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((byte)byte.MaxValue, DataFieldType.UInt32, out val), "Line 21");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((ushort)ushort.MaxValue, DataFieldType.UInt32, out val), "Line 22");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((uint)uint.MaxValue, DataFieldType.UInt32, out val), "Line 23");

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((byte)byte.MaxValue, DataFieldType.UInt64, out val), "Line 24");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((ushort)ushort.MaxValue, DataFieldType.UInt64, out val), "Line 25");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((uint)uint.MaxValue, DataFieldType.UInt64, out val), "Line 26");

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((sbyte)sbyte.MinValue, DataFieldType.Int8, out val), "Line 27");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((short)short.MinValue, DataFieldType.Int8, out val), "Line 28");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((int)int.MinValue, DataFieldType.Int8, out val), "Line 29");

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((sbyte)sbyte.MinValue, DataFieldType.Int16, out val), "Line 30");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((short)short.MinValue, DataFieldType.Int16, out val), "Line 31");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((int)int.MinValue, DataFieldType.Int16, out val), "Line 32");

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((sbyte)sbyte.MinValue, DataFieldType.Int32, out val), "Line 33");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((short)short.MinValue, DataFieldType.Int32, out val), "Line 34");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((int)int.MinValue, DataFieldType.Int32, out val), "Line 35");

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((sbyte)sbyte.MinValue, DataFieldType.Int64, out val), "Line 36");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((short)short.MinValue, DataFieldType.Int64, out val), "Line 37");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((int)int.MinValue, DataFieldType.Int64, out val), "Line 38");
    }

    [TestCase]
    public void TestConvertWireTypeToInType_CrossType_Negative()
    {
        object val;

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((ulong)byte.MaxValue, DataFieldType.Int8, out val), "Line 39");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((ulong)ushort.MaxValue, DataFieldType.Int16, out val), "Line 40");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((ulong)uint.MaxValue, DataFieldType.Int32, out val), "Line 41");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((ulong)ulong.MaxValue, DataFieldType.Int64, out val), "Line 42");

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((long)sbyte.MinValue, DataFieldType.UInt8, out val), "Line 43");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((long)short.MinValue, DataFieldType.UInt16, out val), "Line 44");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((long)int.MinValue, DataFieldType.UInt32, out val), "Line 45");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((long)long.MinValue, DataFieldType.UInt64, out val), "Line 46");
    }

    [TestCase]
    public void TestConvertWireTypeToInType_NotNumbers_Negative()
    {
        object val;

        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType(new byte[] { 1 }, DataFieldType.Binary, out val), "Line 47");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((float)1.1, DataFieldType.Float, out val), "Line 48");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((double)1.1, DataFieldType.Double, out val), "Line 49");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType("foo", DataFieldType.AnsiString, out val), "Line 50");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType(Guid.NewGuid(), DataFieldType.GUID, out val), "Line 51");

        // Flip double/float
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((float)1.1, DataFieldType.Double, out val), "Line 52");
        ValueCheck.IsFalse(EtxManifestHelper.ConvertWireTypeToInType((double)1.1, DataFieldType.Float, out val), "Line 53");
    }


} // end group

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestEventSinks.cs ===
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.IO;
using System.Text;
using System.Reflection;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;

using xonline.server.vortex;
using xonline.server.vortex.cake;

namespace xonline.test.vortexdvt
{
    public partial class CAKE
    {
        [TestGroup, DVT]
        public class EventSinks : VeiTestBaseGroup
        {
            [TestCase]
            public void Dispatch_XomLogEventSink()
            {
                Action<string> subscription;
                XomLogEventSink sink;
                bool passed;

                passed = false;

                subscription = s => passed |= s == "[SomeArea] a|b|c|d";

                Trace.TraceSubscriber += subscription;

                try
                {
                    sink = new XomLogEventSink()
                    {
                        XomLogArea = "SomeArea",
                        XomLogLevel = 1,
                        WriteToTrace = true,
                        Message = "a|b|c|d"
                    };

                    sink.Dispatch();

                    AssertTrue(passed, "Trace of [SomeArea] a|b|c|d not found");
                }
                finally
                {
                    Trace.TraceSubscriber -= subscription;
                }

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\Trace.cs ===
using System;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Web;
using System.Web.Hosting;
using System.IO;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;

namespace xonline.server.vortex
{
    internal static class Trace
    {
        internal static void Low(string format, params object[] args)
        {
            Dispatch(format, args);
            Global.RO.Info(format, args);
        }

        internal static void Normal(string format, params object[] args)
        {
            Dispatch(format, args);
            Global.RO.Info(format, args);
        }

        internal static void High(string format, params object[] args)
        {
            Dispatch(format, args);
            Global.RO.Info(format, args);
        }

        internal static void Error(string format, params object[] args)
        {
            Dispatch(format, args);
            Global.RO.Error(format, args);
        }

        private static void Dispatch(string format, params object[] args)
        {
            if (null != TraceSubscriber)
            {
                TraceSubscriber(string.Format(format, args));
            }
        }

        public static Action<string> TraceSubscriber = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestPayloadReaders.cs ===
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Reflection;
using System.Collections.Specialized;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;
using xonline.server.vortex;
using xonline.server.vortex.cake;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities2;

namespace xonline.test.vortexdvt
{
    public class PayloadReadersTestBaseGroup : VortexDVTTestBaseGroup
    {
        public static void AssertEquals<T>(T a, T b, string format, params object[] args)
        {
            string message;

            message = string.Format(
                "error {2} {0} != {1}", a, b, string.Format(format, args));

            if (null == a)
            {
                if (null != b)
                {
                    AssertFail(message);
                }
            }
            else
            {
                if (!a.Equals(b))
                {
                    AssertFail(message);
                }
            }
        }

        public static void AssertFail(string format, params object[] args)
        {
            Global.RO.Error(format, args);

            throw new StfException("assertion failed");
        }
    }


    [TestGroup, DVT]
    //[CompoundCase("LogString", PRType.LogString)]
    public class PayloadReaders : PayloadReadersTestBaseGroup
    {
        static Func<object, ulong> cvtToULong = (a) => (ulong)Convert.ChangeType(a, typeof(ulong));

        static Func<object, int> cvtToInt = (a) => 
        {
            if (a != null &&
                a is string &&
                ((string)a).Contains("="))
            {
               string[] fields = ((string)a).Split(new char[] { '=' });
               return (int)Convert.ChangeType(fields[1], typeof(int));
            }
            else
            {
                return (int)Convert.ChangeType(a, typeof(int));
            }
        };

        static Func<object, float> cvtToFloat = (a) => 
        {
            if (a != null &&
                a is string &&
                ((string)a).Contains("="))
            {
               string[] fields = ((string)a).Split(new char[] { '=' });
               return (float)Convert.ChangeType(fields[1], typeof(float));
            }
            else 
            {
                return (float)Convert.ChangeType(a, typeof(float));
            }
        };

        static Func<object, Floken> cvtToFloken = (a) => 
        {
            if (a is Floken)
                return (Floken)a;
            else if (a is string)
                return new Floken((string)a);
            else if (a is byte[])
                return new Floken(new BinaryReader(new MemoryStream((byte[])a)));
            else
                return Floken.None;
        };

        static Func<object, string> cvtToString = (a) =>
        {
            if (a == null)
                return null;
            else if (a.GetType() == typeof(byte[]))
                return UTF8Encoding.UTF8.GetString((byte[])a);
            else
                return (string)Convert.ChangeType(a, typeof(string));
        };

        static Func<object, DateTime> cvtToDateTime = (a) =>
        {
            if (a is DateTime)
                return (DateTime)a;
            else if (a is string)
            {
                string s = (string)a;
                if (s.Contains("="))
                {
                    string[] fields = s.Split(new char[] { '=' });
                    s = fields[1];
                }
                return (DateTime)DateTime.Parse(s);
            }
            else
                return (DateTime)DateTime.FromFileTimeUtc((long)Convert.ChangeType(a, typeof(long)));
        };

        [TestGroup, DVT]
        public class LogString : PayloadReadersTestBaseGroup
        {
            [TestCase]
            public void Basic()
            {
                var now = DateTime.UtcNow;
                var payload = "BASICID|1|Omega";
                var pr = new LogStringPayloadReader();
                var ctx = pr.CreateContext(payload);

                // Verify meta properties
                AssertEquals<int>(pr.GetOrdinalCount(ctx), 2, "OrdinalCount");
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 0, "NamedFieldsCount");

                // Verify the "fixed" named fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Id", cvtToString), "BASICID", "NamedField Id");
                var dt = pr.ReadNamedField<DateTime>(ctx, "Timestamp", cvtToDateTime);
                AssertEquals((DateTime.UtcNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}", dt.ToString());
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Foo", cvtToString), null, "Invalid named field");

                // Verify the ordinal fields
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 1, cvtToString), "1", "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), "Omega", "Ordinal1");
                AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 1, cvtToInt), 1, "Ordinal0");
            }

            [TestCase]
            public void Advanced()
            {
                var now = DateTime.UtcNow;
                var payload = "ADVID|1|Omega|2010/01/01 04:20:00.000|1.5|2147483647|Alpha Zeta||-2";
                var pr = new LogStringPayloadReader();
                var ctx = pr.CreateContext(payload);

                // Verify meta properties
                AssertEquals<int>(pr.GetOrdinalCount(ctx), 8, "OrdinalCount");
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 0, "NamedFieldsCount");

                // Verify the "fixed" named fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Id", cvtToString), "ADVID", "NamedField Id");
                var dt = pr.ReadNamedField<DateTime>(ctx, "Timestamp", cvtToDateTime);
                AssertEquals((DateTime.UtcNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}", dt.ToString());

                // Verify the ordinal fields as strings first, then as the real type
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 1, cvtToString), "1", "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), "Omega", "Ordinal1");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 3, cvtToString), "2010/01/01 04:20:00.000", "Ordinal2");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 4, cvtToString), "1.5", "Ordinal3");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 5, cvtToString), "2147483647", "Ordinal4");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 6, cvtToString), "Alpha Zeta", "Ordinal5");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 7, cvtToString), "", "Ordinal6");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 8, cvtToString), "-2", "Ordinal7");

                AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 1, cvtToInt), 1, "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), "Omega", "Ordinal1");
                AssertEquals<DateTime>(pr.ReadOrdinalField<DateTime>(ctx, 3, cvtToDateTime), DateTime.Parse("2010/01/01 04:20:00.000"), "Ordinal2");
                AssertEquals<float>(pr.ReadOrdinalField<float>(ctx, 4, cvtToFloat), 1.5f, "Ordinal3");
                AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 5, cvtToInt), 2147483647, "Ordinal4");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 6, cvtToString), "Alpha Zeta", "Ordinal5");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 7, cvtToString), "", "Ordinal6");
                AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 8, cvtToInt), -2, "Ordinal7");
            }

            [TestCase]
            public void UnknownFields()
            {
                var now = DateTime.UtcNow;
                var payload = "BASICID|1|Omega";
                var pr = new LogStringPayloadReader();
                var ctx = pr.CreateContext(payload);

                // Ask for some unknown fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Unknown", cvtToString), null, "NamedField Unknown");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 3, cvtToString), null, "Ordinal2");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 0, cvtToString), null, "Ordinal-1");

                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, int.MinValue, cvtToString), null, "OrdinalMinValue");

                try
                {
                    // @@@ TODO: in the PayloadReaders, when they return convert(null), is that the
                    // right thing to do?  Do we want a default integer value or not?

                    int i = pr.ReadOrdinalField<int>(ctx, 3, cvtToInt);
                    AssertEquals(false, true, "Should not have been able to convert a null to an int: {0}", i);
                }
                catch (InvalidCastException)
                { }

                // @@@kgoodier I don't think I broke this. Revisit and fix up.
//                 try
//                 {
//                     var a = pr.ReadOrdinalField<string>(ctx, int.MaxValue, cvtToString);
//                     AssertEquals(false, true, "Should not have been able to specify an index out of range, got: {0}", a);
//                 }
//                 catch (IndexOutOfRangeException)
//                 { }
            }

            [TestCase]
            public void ReuseReader()
            {
                var now = DateTime.UtcNow;
                var payload = "BASICID|1|Omega";
                var pr = new LogStringPayloadReader();
                var ctx = pr.CreateContext(payload);

                // Just verify one thing
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Id", cvtToString), "BASICID", "NamedField Id");

                // Now try re-using the payload reader
                var payload2 = "BASICID2|2|Theta";
                ctx = pr.CreateContext(payload2);

                // Verify meta properties
                AssertEquals<int>(pr.GetOrdinalCount(ctx), 2, "OrdinalCount");
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 0, "NamedFieldsCount");

                // Verify the "fixed" named fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Id", cvtToString), "BASICID2", "NamedField Id");
                var dt = pr.ReadNamedField<DateTime>(ctx, "Timestamp", cvtToDateTime);
                AssertEquals((DateTime.UtcNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}", dt.ToString());

                // Verify the ordinal fields
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 1, cvtToString), "2", "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), "Theta", "Ordinal1");
                AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 1, cvtToInt), 2, "Ordinal0");
            }

            [TestCase, Description("Various header field formats")]
            public void MultiFormatPos()
            {
                string nowStr = "2011/03/25 14:00:01.500";
                string[] payloads = new string[] {
                    "FMT0|1|Omega",
                    nowStr + "|FMT1|1|Omega",
                    nowStr + "|FT0|FMT2|1|Omega",
                    nowStr + "|FT1234567800000001|FMT3|1|Omega",
                    "FMT4",
                    nowStr + "|FMT5",
                    nowStr + "|FT0|FMT6",
                    nowStr + "|FT1234567800000001|FMT7"
                };

                LogStringPayloadReader pr = new LogStringPayloadReader();
                PayloadReader.Context[] ctx = new PayloadReader.Context[payloads.Length];
                for (int i = 0; i < payloads.Length; i++)
                {
                    ctx[i] = pr.CreateContext(payloads[i]);
                }

                // Verify "fixed" named fields Id and Timestamp
                for (int i = 0; i < payloads.Length; i++)
                {
                    AssertEquals<string>(pr.ReadNamedField<string>(ctx[i], "Id", cvtToString), "FMT" + i, "NamedField Id " + i);
                    if (i != 0 && i != 4)
                    {
                        DateTime fakeNow = DateTime.Parse("2011/03/25 14:00:01.500");
                        var dt = pr.ReadNamedField<DateTime>(ctx[i], "Timestamp", cvtToDateTime);
                        AssertEquals((fakeNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}, id {1}", dt.ToString(), i);
                    }
                    else
                    {
                        var dt = pr.ReadNamedField<DateTime>(ctx[i], "Timestamp", cvtToDateTime);
                        AssertEquals((DateTime.UtcNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}, id {1}", dt.ToString(), i);
                    }
                }

                AssertEquals<string>(pr.ReadNamedField<Floken>(ctx[2], "Floken", cvtToFloken).ToString(), "FT0", "Floken.Invalid 2");
                AssertEquals<string>(pr.ReadNamedField<Floken>(ctx[3], "Floken", cvtToFloken).ToString(), "FT1234567800000001", "Floken 3");
                AssertEquals<string>(pr.ReadNamedField<Floken>(ctx[6], "Floken", cvtToFloken).ToString(), "FT0", "Floken.Invalid 6");
                AssertEquals<string>(pr.ReadNamedField<Floken>(ctx[7], "Floken", cvtToFloken).ToString(), "FT1234567800000001", "Floken 7");

                // Verify the ordinal fields
                for (int i = 0; i < payloads.Length / 2; i++)
                {
                    AssertEquals<int>(pr.GetOrdinalCount(ctx[i]), 2, "OrdinalCount " + i);
                    AssertEquals<int>(pr.ReadOrdinalField<int>(ctx[i], 1, cvtToInt), 1, "Ordinal0 " + i);
                    AssertEquals<string>(pr.ReadOrdinalField<string>(ctx[i], 2, cvtToString), "Omega", "Ordinal1 " + i);
                }
                // Verify the ordinal fields
                for (int i = payloads.Length / 2; i < payloads.Length; i++)
                {
                    AssertEquals<int>(pr.GetOrdinalCount(ctx[i]), 0, "OrdinalCount " + i);
                }
            }

        } // end LogString 

        [TestGroup, DVT]
        public class LogString2 : PayloadReadersTestBaseGroup
        {
            #region Payload creators

            private NameValueCollection CreateBasicPayload()
            {
                // Like this:
                // "BASICID|1|Omega"

                NameValueCollection nv = new NameValueCollection();
                nv.Add("v1", "BASICID");
                nv.Add("v2", "1");
                nv.Add("v3", "Omega");
                return nv;
            }

            private NameValueCollection CreateAdvancedPayload()
            {
                // Like this:
                // "ADVID|1|Omega|2010/01/01 04:20:00.000|1.5|2147483647|Alpha Zeta||-2";

                NameValueCollection nv = new NameValueCollection();
                nv.Add("v1", "ADVID");
                nv.Add("v2", "1");
                nv.Add("v3", "Omega");
                nv.Add("v4", "2010/01/01 04:20:00.000");
                nv.Add("v5", "1.5");
                nv.Add("v6", "2147483647");
                nv.Add("v7", "Alpha Zeta");
                // skip v8
                nv.Add("v9", "-2");
                return nv;
            }

            private static string LS2Field(string key, string val)
            {
                // Do we include the key in the value or not?
                return key + "=" + val;
            }

            #endregion

            [TestCase]
            public void Basic()
            {
                var now = DateTime.UtcNow;
                var payload = CreateBasicPayload();
                var pr = new LogString2PayloadReader();
                var ctx = pr.CreateContext(payload);

                // Verify meta properties
                AssertEquals<int>(pr.GetOrdinalCount(ctx), 0, "OrdinalCount");
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 2, "NamedFieldsCount");
                AssertEquals<string>(pr.GetNamedFields(ctx)[0], "v2", "Named field");
                AssertEquals<string>(pr.GetNamedFields(ctx)[1], "v3", "Named field");

                // Verify the named fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v1", cvtToString), LS2Field("v1", "BASICID"), "NamedField v1");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v2", cvtToString), LS2Field("v2", "1"), "NamedField v2");
                //AssertEquals<int>(pr.ReadNamedField<int>(ctx, "v2", cvtToInt), 1, "NamedField v2");  // temporary failure
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v3", cvtToString), LS2Field("v3", "Omega"), "NamedField v3");

                // @@@ Need to support "timestamp"?
                //var dt = pr.ReadNamedField<DateTime>(ctx, "Timestamp", cvtToDateTime);
                //AssertEquals((DateTime.UtcNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}", dt.ToString());

                // No ordinal fields
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 1, cvtToString), null, "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), null, "Ordinal1");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 3, cvtToString), null, "Ordinal2");
            }

            [TestCase]
            public void Advanced()
            {
                var now = DateTime.UtcNow;
                var payload = CreateAdvancedPayload();
                var pr = new LogString2PayloadReader();
                var ctx = pr.CreateContext(payload);

                // Verify meta properties
                AssertEquals<int>(pr.GetOrdinalCount(ctx), 0, "OrdinalCount");
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 7, "NamedFieldsCount");
                AssertEquals<string>(pr.GetNamedFields(ctx)[0], "v2", "Named field");
                AssertEquals<string>(pr.GetNamedFields(ctx)[1], "v3", "Named field");
                AssertEquals<string>(pr.GetNamedFields(ctx)[2], "v4", "Named field");
                AssertEquals<string>(pr.GetNamedFields(ctx)[3], "v5", "Named field");
                AssertEquals<string>(pr.GetNamedFields(ctx)[4], "v6", "Named field");
                AssertEquals<string>(pr.GetNamedFields(ctx)[5], "v7", "Named field");
                AssertEquals<string>(pr.GetNamedFields(ctx)[6], "v9", "Named field");

                // Verify the "fixed" named fields
                // @@@ Need to support "timestamp"? need to expose "id"?
                //var dt = pr.ReadNamedField<DateTime>(ctx, "Timestamp", cvtToDateTime);
                //AssertEquals((DateTime.UtcNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}", dt.ToString());

                // Verify the named fields as strings first, then as the real type
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v1", cvtToString), LS2Field("v1", "ADVID"), "Ordinal1");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v2", cvtToString), LS2Field("v2", "1"), "Ordinal2");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v3", cvtToString), LS2Field("v3", "Omega"), "Ordinal3");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v4", cvtToString), LS2Field("v4", "2010/01/01 04:20:00.000"), "Ordinal4");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v5", cvtToString), LS2Field("v5", "1.5"), "Ordinal5");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v6", cvtToString), LS2Field("v6", "2147483647"), "Ordinal6");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v7", cvtToString), LS2Field("v7", "Alpha Zeta"), "Ordinal7");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v8", cvtToString), null, "Ordinal8");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v9", cvtToString), LS2Field("v9", "-2"), "Ordinal9");

                AssertEquals<int>(pr.ReadNamedField<int>(ctx, "v2", cvtToInt), 1, "Ordinal2");
                AssertEquals<DateTime>(pr.ReadNamedField<DateTime>(ctx, "v4", cvtToDateTime), DateTime.Parse("2010/01/01 04:20:00.000"), "Ordinal4");
                AssertEquals<float>(pr.ReadNamedField<float>(ctx, "v5", cvtToFloat), 1.5f, "Ordinal5");
                AssertEquals<int>(pr.ReadNamedField<int>(ctx, "v6", cvtToInt), 2147483647, "Ordinal6");
                AssertEquals<int>(pr.ReadNamedField<int>(ctx, "v9", cvtToInt), -2, "Ordinal9");

                // No ordinal fields
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 1, cvtToString), null, "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), null, "Ordinal1");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 3, cvtToString), null, "Ordinal2");


            }

            [TestCase]
            public void UnknownFields()
            {
                var now = DateTime.UtcNow;
                var payload = CreateBasicPayload();
                var pr = new LogString2PayloadReader();
                var ctx = pr.CreateContext(payload);

                // Ask for some unknown fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Unknown", cvtToString), null, "NamedField Unknown");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v1 ", cvtToString), null, "NamedField v1 ");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, " v1", cvtToString), null, "NamedField  v1");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, " v1 ", cvtToString), null, "NamedField  v1 ");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "&v1", cvtToString), null, "NamedField &v1");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v0", cvtToString), null, "NamedField v0");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "0", cvtToString), null, "NamedField 0");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "1", cvtToString), null, "NamedField 1");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "2", cvtToString), null, "NamedField 2");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "-1", cvtToString), null, "NamedField -1");

                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 3, cvtToString), null, "Ordinal2");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, -1, cvtToString), null, "Ordinal-1");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, int.MaxValue, cvtToString), null, "OrdinalMaxValue");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, int.MinValue, cvtToString), null, "OrdinalMinValue");

                try
                {
                    // @@@ TODO: in the PayloadReaders, when they return convert(null), is that the
                    // right thing to do?  Do we want a default integer value or not?

                    int i = pr.ReadNamedField<int>(ctx, "v0", cvtToInt);
                    AssertEquals(false, true, "Should not have been able to convert a null to an int: {0}", i);
                }
                catch (InvalidCastException)
                { }
            }

            [TestCase]
            public void ReuseReader()
            {
                var now = DateTime.UtcNow;
                var payload = CreateBasicPayload();
                var pr = new LogString2PayloadReader();
                var ctx = pr.CreateContext(payload);

                // Just verify one thing
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 2, "NamedFieldsCount");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v1", cvtToString), LS2Field("v1", "BASICID"), "NamedField v1");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v7", cvtToString), null, "NamedField v7");

                // Now try re-using the payload reader
                var payload2 = CreateAdvancedPayload();
                ctx = pr.CreateContext(payload2);

                // Verify meta properties
                AssertEquals<int>(pr.GetOrdinalCount(ctx), 0, "OrdinalCount");
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 7, "NamedFieldsCount");
                AssertEquals<string>(pr.GetNamedFields(ctx)[0], "v2", "Named field");
                AssertEquals<string>(pr.GetNamedFields(ctx)[6], "v9", "Named field");

                // Verify the named fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v1", cvtToString), LS2Field("v1", "ADVID"), "NamedField v1");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v2", cvtToString), LS2Field("v2", "1"), "NamedField v2");
                //AssertEquals<int>(pr.ReadNamedField<int>(ctx, "v2", cvtToInt), 1, "NamedField v2");  // @@@ temporary failure
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v3", cvtToString), LS2Field("v3", "Omega"), "NamedField v3");
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "v7", cvtToString), LS2Field("v7", "Alpha Zeta"), "NamedField v7");

                // No ordinal fields
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 1, cvtToString), null, "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), null, "Ordinal1");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 3, cvtToString), null, "Ordinal2");
            }


        } // end LogString 

        [TestGroup, DVT]
        public class VortexProtocol : PayloadReadersTestBaseGroup
        {
            #region Vortex Events

            private VxEvent CreateBasicPayload()
            {
                // Like this:
                // "2112|1|Omega"

                SpecialField sf1 = new SpecialField()
                {
                    Id = 1,
                    Value = "2112"
                };
                VxEvent vxevent = new VxEvent(Blob.Empty, 2112, DateTime.UtcNow);
                vxevent.EventFields.AddField(1, (int)1);
                vxevent.EventFields.AddField(2, "Omega");
            
                // Extra step - serialize and then deserialize
                MemoryStream ms = new MemoryStream(1000);
                vxevent.WriteStream(new VortexBinaryWriter(ms));
                ms.Position = 0;
                return new VxEvent(new VortexBinaryReader(ms));
            }

            private VxEvent CreateAdvancedPayload()
            {
                // Like this: 
                // "21122112|1|Omega|2010/01/01 04:20:00.000|1.5|2147483647|Alpha Zeta||-2";

                SpecialField sf1 = new SpecialField()
                {
                    Id = 1,
                    Value = "21122112"
                };
                VxEvent vxevent = new VxEvent(Blob.Empty, 21122112, DateTime.UtcNow);
                vxevent.EventFields.AddField(1, (int)1);
                vxevent.EventFields.AddField(2, "Omega");
                vxevent.EventFields.AddField(3, DateTime.Parse("2010/01/01 04:20:00.000"));
                // flip order on wire
                vxevent.EventFields.AddField(5, (int)(2147483647));
                vxevent.EventFields.AddField(4, (float)1.5);
                vxevent.EventFields.AddField(6, "Alpha Zeta");
                // skip 6
                vxevent.EventFields.AddField(8, (int)-2);
            
                // Extra step - serialize and then deserialize
                MemoryStream ms = new MemoryStream(1000);
                vxevent.WriteStream(new VortexBinaryWriter(ms));
                ms.Position = 0;
                return new VxEvent(new VortexBinaryReader(ms));
            }

            #endregion

            [TestCase]
            public void Basic()
            {
                var now = DateTime.UtcNow;
                var payload = CreateBasicPayload();
                var pr = new VortexProtocolPayloadReader();
                var ctx = pr.CreateContext(payload);

                // Verify meta properties
                AssertEquals<int>(pr.GetOrdinalCount(ctx), 2, "OrdinalCount");
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 0, "NamedFieldsCount");

                // Verify the "fixed" named fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Id", cvtToString), "2112", "NamedField Id");
                AssertEquals<ulong>(pr.ReadNamedField<ulong>(ctx, "Id", cvtToULong), 2112, "NamedField Id");
                AssertEquals<int>(pr.ReadNamedField<int>(ctx, "Id", cvtToInt), 2112, "NamedField Id");
                var dt = pr.ReadNamedField<DateTime>(ctx, "Timestamp", cvtToDateTime);
                AssertEquals((DateTime.UtcNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}", dt.ToString());

                // Verify the ordinal fields
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 1, cvtToString), "1", "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), "Omega", "Ordinal1");
                AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 1, cvtToInt), 1, "Ordinal0");
            }

            [TestCase]
            public void Advanced()
            {
                var now = DateTime.UtcNow;
                var payload = CreateAdvancedPayload();
                var pr = new VortexProtocolPayloadReader();
                var ctx = pr.CreateContext(payload);

                // Verify meta properties
                AssertEquals<int>(pr.GetOrdinalCount(ctx), 8, "OrdinalCount");
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 0, "NamedFieldsCount");

                // Verify the "fixed" named fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Id", cvtToString), "21122112", "NamedField Id");
                AssertEquals<ulong>(pr.ReadNamedField<ulong>(ctx, "Id", cvtToULong), 21122112, "NamedField Id");
                AssertEquals<int>(pr.ReadNamedField<int>(ctx, "Id", cvtToInt), 21122112, "NamedField Id");
                var dt = pr.ReadNamedField<DateTime>(ctx, "Timestamp", cvtToDateTime);
                AssertEquals((DateTime.UtcNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}", dt.ToString());

                // Verify the ordinal fields as strings first, then as the real type
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 1, cvtToString), "1", "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), "Omega", "Ordinal1");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 3, cvtToString), DateTime.Parse("2010/01/01 04:20:00.000").ToFileTimeUtc().ToString(), "Ordinal2");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 4, cvtToString), "1.5", "Ordinal3");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 5, cvtToString), "2147483647", "Ordinal4");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 6, cvtToString), "Alpha Zeta", "Ordinal5");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 7, cvtToString), null, "Ordinal6");  // @@@ "" or null desired?
                // @@@ test failure here
                //AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 8, cvtToString), "-2", "Ordinal7");  // 18446744073709551614 as a ulong...

                AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 1, cvtToInt), 1, "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), "Omega", "Ordinal1");
                AssertEquals<DateTime>(pr.ReadOrdinalField<DateTime>(ctx, 3, cvtToDateTime), DateTime.Parse("2010/01/01 04:20:00.000"), "Ordinal2");
                AssertEquals<float>(pr.ReadOrdinalField<float>(ctx, 4, cvtToFloat), 1.5f, "Ordinal3");
                AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 5, cvtToInt), 2147483647, "Ordinal4");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 6, cvtToString), "Alpha Zeta", "Ordinal5");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 7, cvtToString), null, "Ordinal6");
                // @@@ test failure here
                //AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 8, cvtToInt), -2, "Ordinal7");  // throws an OverflowException
            }

            [TestCase]
            public void UnknownFields()
            {
                var now = DateTime.UtcNow;
                var payload = CreateBasicPayload();
                var pr = new VortexProtocolPayloadReader();
                var ctx = pr.CreateContext(payload);

                // Ask for some unknown fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Unknown", cvtToString), null, "NamedField Unknown");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 3, cvtToString), null, "Ordinal2");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, -1, cvtToString), null, "Ordinal-1");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, int.MaxValue, cvtToString), null, "OrdinalMaxValue");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, int.MinValue, cvtToString), null, "OrdinalMinValue");

                try
                {
                    // @@@ TODO: in the PayloadReaders, when they return convert(null), is that the
                    // right thing to do?  Do we want a default integer value or not?

                    int i = pr.ReadOrdinalField<int>(ctx, 3, cvtToInt);
                    AssertEquals(false, true, "Should not have been able to convert a null to an int: {0}", i);
                }
                catch (InvalidCastException)
                { }
            }

            [TestCase]
            public void ReuseReader()
            {
                var now = DateTime.UtcNow;
                var payload = CreateAdvancedPayload();
                var pr = new VortexProtocolPayloadReader();
                var ctx = pr.CreateContext(payload);

                // Just verify one thing
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Id", cvtToString), "21122112", "NamedField Id");

                // Now try re-using the payload reader
                var payload2 = CreateBasicPayload();
                ctx = pr.CreateContext(payload2);

                // Verify meta properties
                AssertEquals<int>(pr.GetOrdinalCount(ctx), 2, "OrdinalCount");
                AssertEquals<int>(pr.GetNamedFields(ctx).Length, 0, "NamedFieldsCount");

                // Verify the "fixed" named fields
                AssertEquals<string>(pr.ReadNamedField<string>(ctx, "Id", cvtToString), "2112", "NamedField Id");
                AssertEquals<ulong>(pr.ReadNamedField<ulong>(ctx, "Id", cvtToULong), 2112, "NamedField Id");
                AssertEquals<int>(pr.ReadNamedField<int>(ctx, "Id", cvtToInt), 2112, "NamedField Id");
                var dt = pr.ReadNamedField<DateTime>(ctx, "Timestamp", cvtToDateTime);
                AssertEquals((DateTime.UtcNow - dt) < TimeSpan.FromSeconds(5), true, "Timestamp validation for {0}", dt.ToString());

                // Verify the ordinal fields
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 1, cvtToString), "1", "Ordinal0");
                AssertEquals<string>(pr.ReadOrdinalField<string>(ctx, 2, cvtToString), "Omega", "Ordinal1");
                AssertEquals<int>(pr.ReadOrdinalField<int>(ctx, 1, cvtToInt), 1, "Ordinal0");
            }


        } // end LogString 


    } // end PayloadReaders


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestVeiConfiguration.cs ===
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Reflection;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;

using xonline.server.vortex;
using xonline.server.vortex.cake;

using Microsoft.ComplexEventProcessing;

namespace xonline.test.vortexdvt
{
    public partial class CAKE
    {
        [TestGroup, DVT]
        public class Konfiguration : VeiTestBaseGroup
        {
            [TestGroup, DVT]
            public class KonfigurationSerialization : VeiTestBaseGroup
            {
                [TestCase]
                public void SerializeVortexLogConfig()
                {
                    string xml =
                        "<Log id='Log1'>" +
                        "  <Stream name='Stream1'>" +
                        "    <EventBuilderRef name='Template1' />" +
                        "  </Stream>" +
                        "  <Stream name='Stream2'>" +
                        "    <EventBuilder>" +
                        "      <InlineField1>Inline</InlineField1>" +
                        "    </EventBuilder>" +
                        "  </Stream>" +
                        "</Log>";

                    var obj = VortexLogConfig.Parse(CreateElement(xml), CreateTemplates());

                    AssertEquals(obj.Identifier, "Log1", "Log.Identifier");
                    AssertEquals(obj.HasWildCards, false, "Log.HasWildCards");
                    AssertPresent(obj.Streams, "Stream1", "Log.Streams[Stream1]");
                    AssertPresent(obj.Streams["Stream1"].Recipes, item => item.FieldExpressions.ContainsKey("TemplateField1"), "Log.Streams[Stream1].Recipes[Template1]");
                    AssertPresent(obj.Streams["Stream1"].Recipes, item => item.FieldExpressions.ContainsKey("TemplateField1") && item.FieldExpressions["TemplateField1"] == "Template", "Log.Streams[Stream1].Recipes[Template1].FieldExpressions[TemplateField1]");
                    AssertPresent(obj.Streams["Stream1"].Recipes, item => item.FieldExpressions.ContainsKey("TemplateField1") && item.FieldExpressions.Count == 1, "Log.Streams[Stream1].Recipes[Template1].Count");
                    AssertPresent(obj.Streams, "Stream2", "Log.Streams[Stream2]");
                    AssertPresent(obj.Streams["Stream2"].Recipes, item => item.FieldExpressions.ContainsKey("InlineField1"), "Log.Streams[Stream2].Recipes[Inline]");
                    AssertPresent(obj.Streams["Stream2"].Recipes, item => item.FieldExpressions.ContainsKey("InlineField1") && item.FieldExpressions["InlineField1"] == "Inline", "Log.Streams[Stream2].Recipes[Inline].FieldExpressions[InlineField1]");
                    AssertPresent(obj.Streams["Stream2"].Recipes, item => item.FieldExpressions.ContainsKey("InlineField1") && item.FieldExpressions.Count == 1, "Log.Streams[Stream2].Recipes[Inline].Count");
                }

                [TestCase]
                public void SerializeVortexStreamConfig()
                {
                    string xml =
                        "<Stream name='LifeStream'>" +
                        "  <EventBuilderRef name='Template1' />" +
                        "  <EventBuilder>" +
                        "    <InlineField1>Inline</InlineField1>" +
                        "  </EventBuilder>" +
                        "</Stream>";

                    var obj = VortexStreamConfig.Parse(CreateElement(xml), CreateTemplates());

                    AssertEquals(obj.Name, "LifeStream", "Stream.Name");
                    AssertPresent(obj.Recipes, item => item.FieldExpressions.ContainsKey("TemplateField1"), "Stream.Recipes[Template1]");
                    AssertPresent(obj.Recipes, item => item.FieldExpressions.ContainsKey("TemplateField1") && item.FieldExpressions["TemplateField1"] == "Template", "Stream.Recipes[Template1].FieldExpressions[TemplateField1]");
                    AssertPresent(obj.Recipes, item => item.FieldExpressions.ContainsKey("TemplateField1") && item.FieldExpressions.Count == 1, "Stream.Recipes[Template1].Count");
                    AssertPresent(obj.Recipes, item => item.FieldExpressions.ContainsKey("InlineField1"), "Stream.Recipes[Inline]");
                    AssertPresent(obj.Recipes, item => item.FieldExpressions.ContainsKey("InlineField1") && item.FieldExpressions["InlineField1"] == "Inline", "Stream.Recipes[Inline].FieldExpressions[InlineField1]");
                    AssertPresent(obj.Recipes, item => item.FieldExpressions.ContainsKey("InlineField1") && item.FieldExpressions.Count == 1, "Stream.Recipes[Inline].Count");
                }

                [TestCase]
                public void SerializeVortexObjectMapperConfig()
                {
                    string xml =
                        "<EventBuilder>" + // could have just as well been <EventSink ...>
                        "  <Field1>$1|$2</Field1>" +
                        "  <FieldA>Ninja Turtle</FieldA>" +
                        "  <FieldB></FieldB>" +
                        "</EventBuilder>";

                    var obj = VortexObjectMapperConfig.Parse(CreateElement(xml));

                    AssertEquals(obj.FieldExpressions["Field1"], "$1|$2", "ObjectMapper.Fields[Field1]");
                    AssertEquals(obj.FieldExpressions["FieldA"], "Ninja Turtle", "ObjectMapper.Fields[FieldA]");
                    AssertEquals(obj.FieldExpressions["FieldB"], "", "ObjectMapper.Fields[FieldB]");
                    AssertEquals(obj.FieldExpressions.Count, 3, "ObjectMapper.Fields.Count");
                }

                [TestCase]
                public void SerializeVortexQueryConfig()
                {
                    string xml =
                        "<Query name='SomeQuery'>" +
                        "  <EventSink name='Sink1' />" +
                        "  <EventSink name='SinkA' />" +
                        "  <EventSink name='SinkB'>" +
                        "    <AnotherField>Pied|er</AnotherField>" +
                        "  </EventSink>" +
                        "</Query>";

                    var obj = VortexQueryConfig.Parse(CreateElement(xml));

                    AssertEquals(obj.Name, "SomeQuery", "Query.Name");
                    AssertPresent(obj.EventSinks, "Sink1", "Query.EventSinks");
                    AssertEquals(obj.EventSinks["Sink1"].Name, "Sink1", "Query.EventSinks[Sink1].Name");
                    AssertPresent(obj.EventSinks, "SinkA", "Query.EventSinks");
                    AssertEquals(obj.EventSinks["SinkA"].Name, "SinkA", "Query.EventSinks[SinkA].Name");
                    AssertPresent(obj.EventSinks, "SinkB", "Query.EventSinks");
                    AssertEquals(obj.EventSinks["SinkB"].Name, "SinkB", "Query.EventSinks[SinkB].Name");
                    AssertEquals(obj.EventSinks["SinkB"].Recipe.FieldExpressions["AnotherField"], "Pied|er", "Query.EventSinks[SinkB].Recipe.FieldExpressions[AnotherField]");
                    AssertEquals(obj.EventSinks["SinkB"].Recipe.FieldExpressions.Count, 1, "Query.EventSinks[SinkB].Recipe.FieldExpressions.Count");
                    AssertEquals(obj.EventSinks.Count, 3, "Query.EventSinks.Count");
                }

                [TestCase]
                public void SerializeVortexEventSinkConfig()
                {
                    string xml =
                        "<EventSink name='SinkName'>" +
                        "  <Field1>$1|$2</Field1>" +
                        "  <FieldA>Ninja Turtle</FieldA>" +
                        "  <FieldB></FieldB>" +
                        "</EventSink>";

                    var obj = VortexEventSinkConfig.Parse(CreateElement(xml));

                    AssertEquals(obj.Name, "SinkName", "EventSink.Name");
                    AssertEquals(obj.Recipe.FieldExpressions["Field1"], "$1|$2", "EventSink.Fields[Field1]");
                    AssertEquals(obj.Recipe.FieldExpressions["FieldA"], "Ninja Turtle", "EventSink.Fields[FieldA]");
                    AssertEquals(obj.Recipe.FieldExpressions["FieldB"], "", "EventSink.Fields[FieldB]");
                    AssertEquals(obj.Recipe.FieldExpressions.Count, 3, "EventSink.Fields.Count");
                }

                #region Helper Methods

                private Dictionary<string, VortexObjectMapperConfig> CreateTemplates()
                {
                    Dictionary<string, VortexObjectMapperConfig> result = new Dictionary<string, VortexObjectMapperConfig>();
                    VortexObjectMapperConfig item;

                    item = new VortexObjectMapperConfig();
                    item.Name = "Template1";
                    item.FieldExpressions["TemplateField1"] = "Template";

                    result.Add(item.Name, item);

                    return result;
                }

                private XmlElement CreateElement(string xml)
                {
                    XmlDocument doc = new XmlDocument();

                    doc.LoadXml(xml);

                    return doc.DocumentElement;
                }

                #endregion
            }

            [TestGroup, DVT]
            public class KonfigurationUpdates : VeiTestBaseGroup
            {
                private string GetInputAddMessage(string stream, string log)
                {
                    return string.Format(VeiInputAdapter.c_EventAddedTraceMessage, stream, log);
                }

                private string GetInputDeleteMessage(string stream, string log)
                {
                    return string.Format(VeiInputAdapter.c_EventDestructionTraceMessage, stream, log);
                }

                private string GetInputSkippedMessage(string stream, string log)
                {
                    return string.Format(VeiInputAdapter.c_EventUpdateSkippedTraceMessage, stream, log);
                }

                private string GetInputUpdatedMessage(string stream, string log)
                {
                    return string.Format(VeiInputAdapter.c_EventUpdatedTraceMessage, stream, log);
                }

                private string GetOutputAddMessage(string stream, string log)
                {
                    return string.Format(VeiOutputAdapter.c_EventAddedTraceMessage, stream, log);
                }

                private string GetOutputDeleteMessage(string stream, string log)
                {
                    return string.Format(VeiOutputAdapter.c_EventDestructionTraceMessage, stream, log);
                }

                private string GetOutputSkippedMessage(string stream, string log)
                {
                    return string.Format(VeiOutputAdapter.c_EventUpdateSkippedTraceMessage, stream, log);
                }

                private string GetOutputUpdatedMessage(string stream, string log)
                {
                    return string.Format(VeiOutputAdapter.c_EventUpdatedTraceMessage, stream, log);
                }

                [TestCase]
                public void InputAdapterReconfigure_AddToEmpty()
                {
                    VeiInputAdapterConfig config;
                    string addedMessage;
                    bool added;

                    added = false;

                    config = new VeiInputAdapterConfig();
                    config.StreamName = "Stream1";
                    config.InitialConfig = CreateConfig(CreateDefaultLogConfig("Log1", false));

                    addedMessage = GetInputAddMessage("Stream1", "Log1");
                    
                    Action<string> subscriber =
                        s =>
                        {
                            added |= s == addedMessage;
                            Global.RO.Info("Trace Intercepted [{0}]", s);
                        };

                    xonline.server.vortex.Trace.TraceSubscriber += subscriber;

                    try
                    {
                        var inputAdapter = new VeiInputAdapter(config, CreateEventTypeFor(typeof(TestClass), true));

                        AssertEquals(inputAdapter.StreamName, "Stream1", "VeiInputAdapter.StreamName");
                        AssertPresent(inputAdapter.EventBuilders, "Log1", "VeiInputAdapters.EventBuilders");
                        AssertEquals(inputAdapter.EventBuilders.Count(), 1, "VeiInputAdapters.EventBuilders.Count");
                        AssertTrue(added, "Did not find the expected added trace message '{0}'", addedMessage);
                    }
                    finally
                    {
                        xonline.server.vortex.Trace.TraceSubscriber -= subscriber;
                    }
                }

                [TestCase]
                public void InputAdapterReconfigure_AddToNonEmpty()
                {
                    VeiInputAdapterConfig config;
                    VeiInputAdapter inputAdapter;
                    string skippedMessage;
                    string addedMessage;
                    bool skipped;
                    bool added;

                    skipped = false;
                    added = false;

                    config = new VeiInputAdapterConfig();
                    config.StreamName = "Stream1";
                    config.InitialConfig = CreateConfig(CreateDefaultLogConfig("Log1", false));

                    inputAdapter = new VeiInputAdapter(config, CreateEventTypeFor(typeof(TestClass), true));

                    skippedMessage = GetInputSkippedMessage("Stream1", "Log1");
                    addedMessage = GetInputAddMessage("Stream1", "Log2");

                    Action<string> subscriber =
                        s =>
                        {
                            skipped |= s == skippedMessage;
                            added |= s == addedMessage;
                            Global.RO.Info("Trace Intercepted [{0}]", s);
                        };

                    xonline.server.vortex.Trace.TraceSubscriber += subscriber;

                    try
                    {
                        config.InitialConfig = CreateConfig(
                            CreateDefaultLogConfig("Log1", false),
                            CreateDefaultLogConfig("Log2", false));

                        inputAdapter.ConfigureAdapter(config.InitialConfig);

                        AssertEquals(inputAdapter.StreamName, "Stream1", "VeiInputAdapter.StreamName");
                        AssertPresent(inputAdapter.EventBuilders, "Log1", "VeiInputAdapters.EventBuilders");
                        AssertPresent(inputAdapter.EventBuilders, "Log2", "VeiInputAdapters.EventBuilders");
                        AssertEquals(inputAdapter.EventBuilders.Count(), 2, "VeiInputAdapters.EventBuilders.Count");
                        AssertTrue(added, "Did not find the expected added trace message '{0}'", addedMessage);
                        AssertTrue(skipped, "Did not find the expected skipped trace message '{0}'", skippedMessage);
                    }
                    finally
                    {
                        xonline.server.vortex.Trace.TraceSubscriber -= subscriber;
                    }
                }

                [TestCase]
                public void InputAdapterReconfigure_DeleteFromNonEmpty()
                {
                    VeiInputAdapterConfig config;
                    VeiInputAdapter inputAdapter;
                    string deletedMessage;
                    bool deleted;

                    deleted = false;

                    config = new VeiInputAdapterConfig();
                    config.StreamName = "Stream1";
                    config.InitialConfig = CreateConfig(CreateDefaultLogConfig("Log1", false));

                    inputAdapter = new VeiInputAdapter(config, CreateEventTypeFor(typeof(TestClass), true));

                    deletedMessage = GetInputDeleteMessage("Stream1", "Log1");
                    
                    Action<string> subscriber =
                        s =>
                        {
                            deleted |= s == deletedMessage;
                            Global.RO.Info("Trace Intercepted [{0}]", s);
                        };

                    xonline.server.vortex.Trace.TraceSubscriber += subscriber;

                    try
                    {
                        config.InitialConfig = CreateConfig();

                        inputAdapter.ConfigureAdapter(config.InitialConfig);

                        AssertEquals(inputAdapter.StreamName, "Stream1", "VeiInputAdapter.StreamName");
                        AssertEquals(inputAdapter.EventBuilders.Count(), 0, "VeiInputAdapters.EventBuilders.Count");
                        AssertTrue(deleted, "Did not find the expected deleted trace message '{0}'", deletedMessage);
                    }
                    finally
                    {
                        xonline.server.vortex.Trace.TraceSubscriber -= subscriber;
                    }
                }

                [TestCase]
                public void InputAdapterReconfigure_AddAndDeleteFromNonEmpty()
                {
                    VeiInputAdapterConfig config;
                    VeiInputAdapter inputAdapter;
                    string deletedMessage;
                    string addedMessage;
                    bool deleted;
                    bool added;

                    deleted = false;
                    added = false;

                    config = new VeiInputAdapterConfig();
                    config.StreamName = "Stream1";
                    config.InitialConfig = CreateConfig(CreateDefaultLogConfig("Log1", false));

                    inputAdapter = new VeiInputAdapter(config, CreateEventTypeFor(typeof(TestClass), true));

                    deletedMessage = GetInputDeleteMessage("Stream1", "Log1");
                    addedMessage = GetInputAddMessage("Stream1", "Log2");

                    Action<string> subscriber =
                        s =>
                        {
                            deleted |= s == deletedMessage;
                            added |= s == addedMessage;
                            Global.RO.Info("Trace Intercepted [{0}]", s);
                        };

                    xonline.server.vortex.Trace.TraceSubscriber += subscriber;

                    try
                    {
                        config.InitialConfig = CreateConfig(
                            CreateDefaultLogConfig("Log2", false));

                        inputAdapter.ConfigureAdapter(config.InitialConfig);

                        AssertEquals(inputAdapter.StreamName, "Stream1", "VeiInputAdapter.StreamName");
                        AssertPresent(inputAdapter.EventBuilders, "Log2", "VeiInputAdapters.EventBuilders");
                        AssertEquals(inputAdapter.EventBuilders.Count(), 1, "VeiInputAdapters.EventBuilders.Count");
                        AssertTrue(added, "Did not find the expected added trace message '{0}'", addedMessage);
                        AssertTrue(deleted, "Did not find the expected deleted trace message '{0}'", deletedMessage);
                    }
                    finally
                    {
                        xonline.server.vortex.Trace.TraceSubscriber -= subscriber;
                    }
                }

                [TestCase]
                public void OutputAdapterReconfigure_AddToEmpty()
                {
                    VeiOutputAdapter outputAdapter;
                    VeiOutputAdapterConfig config;
                    string addedMessage;
                    bool added;

                    added = false;

                    config = new VeiOutputAdapterConfig();
                    config.QueryName = "Query1";
                    config.InitialConfig = CreateConfig(CreateDefaultQueryConfig("Query1"));

                    addedMessage = GetOutputAddMessage("Query1", typeof(TestClass).FullName);

                    Action<string> subscriber =
                        s =>
                        {
                            added |= s == addedMessage;
                            Global.RO.Info("Trace Intercepted [{0}]", s);
                        };

                    xonline.server.vortex.Trace.TraceSubscriber += subscriber;

                    try
                    {
                        outputAdapter = new VeiOutputAdapter(config, CreateEventTypeFor(typeof(TestClass), true));

                        AssertEquals(outputAdapter.QueryName, "Query1", "VeiOutputAdapter.QueryName");
                        AssertPresent(outputAdapter.SinkBuilders, typeof(TestClass).FullName, "VeiOutputAdapters.SinkBuilders");
                        AssertEquals(outputAdapter.SinkBuilders.Count(), 1, "VeiOutputAdapters.SinkBuilders.Count");
                        AssertTrue(added, "Did not find the expected added trace message '{0}'", addedMessage);
                    }
                    finally
                    {
                        xonline.server.vortex.Trace.TraceSubscriber -= subscriber;
                    }
                }

                [TestCase]
                public void OutputAdapterReconfigure_AddToNonEmpty()
                {
                    VeiOutputAdapter outputAdapter;
                    VeiOutputAdapterConfig config;
                    string skippedMessage;
                    string addedMessage;
                    bool skipped;
                    bool added;

                    skipped = false;
                    added = false;

                    config = new VeiOutputAdapterConfig();
                    config.QueryName = "Query1";
                    config.InitialConfig = CreateConfig(CreateDefaultQueryConfig("Query1"));

                    skippedMessage = GetOutputSkippedMessage("Query1", typeof(TestClass).FullName);
                    addedMessage = GetOutputAddMessage("Query1", typeof(TestClass2).FullName);

                    Action<string> subscriber =
                        s =>
                        {
                            skipped |= s == skippedMessage;
                            added |= s == addedMessage;
                            Global.RO.Info("Trace Intercepted [{0}]", s);
                        };

                    outputAdapter = new VeiOutputAdapter(config, CreateEventTypeFor(typeof(TestClass), true));

                    xonline.server.vortex.Trace.TraceSubscriber += subscriber;

                    try
                    {
                        config.InitialConfig = CreateConfig(CreateQueryConfig("Query1",
                            CreateDefaultEventSinkConfig(typeof(TestClass).FullName),
                            CreateDefaultEventSinkConfig(typeof(TestClass2).FullName)));

                        outputAdapter.ConfigureAdapter(config.InitialConfig);

                        AssertEquals(outputAdapter.QueryName, "Query1", "VeiOutputAdapter.QueryName");
                        AssertPresent(outputAdapter.SinkBuilders, typeof(TestClass).FullName, "VeiOutputAdapters.SinkBuilders");
                        AssertPresent(outputAdapter.SinkBuilders, typeof(TestClass2).FullName, "VeiOutputAdapters.SinkBuilders");
                        AssertEquals(outputAdapter.SinkBuilders.Count(), 2, "VeiOutputAdapters.SinkBuilders.Count");
                        AssertTrue(skipped, "Did not find the expected skipped trace message '{0}'", skippedMessage);
                        AssertTrue(added, "Did not find the expected added trace message '{0}'", addedMessage);
                    }
                    finally
                    {
                        xonline.server.vortex.Trace.TraceSubscriber -= subscriber;
                    }
                }

                [TestCase]
                public void OutputAdapterReconfigure_DeleteFromNonEmpty()
                {
                    VeiOutputAdapter outputAdapter;
                    VeiOutputAdapterConfig config;
                    string deletedMessage;
                    bool deleted;

                    deleted = false;

                    config = new VeiOutputAdapterConfig();
                    config.QueryName = "Query1";
                    config.InitialConfig = CreateConfig(CreateDefaultQueryConfig("Query1"));

                    deletedMessage = GetOutputDeleteMessage("Query1", typeof(TestClass).FullName);

                    Action<string> subscriber =
                        s =>
                        {
                            deleted |= s == deletedMessage;
                            Global.RO.Info("Trace Intercepted [{0}]", s);
                        };

                    outputAdapter = new VeiOutputAdapter(config, CreateEventTypeFor(typeof(TestClass), true));

                    xonline.server.vortex.Trace.TraceSubscriber += subscriber;

                    try
                    {
                        config.InitialConfig = CreateConfig(CreateQueryConfig("Query1"));

                        outputAdapter.ConfigureAdapter(config.InitialConfig);

                        AssertEquals(outputAdapter.QueryName, "Query1", "VeiOutputAdapter.QueryName");
                        AssertEquals(outputAdapter.SinkBuilders.Count(), 0, "VeiOutputAdapters.SinkBuilders.Count");
                        AssertTrue(deleted, "Did not find the expected deleted trace message '{0}'", deletedMessage);
                    }
                    finally
                    {
                        xonline.server.vortex.Trace.TraceSubscriber -= subscriber;
                    }
                }

                [TestCase]
                public void OutputAdapterReconfigure_AddAndDeleteFromNonEmpty()
                {
                    VeiOutputAdapter outputAdapter;
                    VeiOutputAdapterConfig config;
                    string deletedMessage;
                    string addedMessage;
                    bool deleted;
                    bool added;

                    deleted = false;
                    added = false;

                    config = new VeiOutputAdapterConfig();
                    config.QueryName = "Query1";
                    config.InitialConfig = CreateConfig(CreateDefaultQueryConfig("Query1"));

                    deletedMessage = GetOutputDeleteMessage("Query1", typeof(TestClass).FullName);
                    addedMessage = GetOutputAddMessage("Query1", typeof(TestClass2).FullName);

                    Action<string> subscriber =
                        s =>
                        {
                            deleted |= s == deletedMessage;
                            added |= s == addedMessage;
                            Global.RO.Info("Trace Intercepted [{0}]", s);
                        };

                    outputAdapter = new VeiOutputAdapter(config, CreateEventTypeFor(typeof(TestClass), true));

                    xonline.server.vortex.Trace.TraceSubscriber += subscriber;

                    try
                    {
                        config.InitialConfig = CreateConfig(CreateQueryConfig("Query1",
                            CreateDefaultEventSinkConfig(typeof(TestClass2).FullName)));

                        outputAdapter.ConfigureAdapter(config.InitialConfig);

                        AssertEquals(outputAdapter.QueryName, "Query1", "VeiOutputAdapter.QueryName");
                        AssertPresent(outputAdapter.SinkBuilders, typeof(TestClass2).FullName, "VeiOutputAdapters.SinkBuilders");
                        AssertEquals(outputAdapter.SinkBuilders.Count(), 1, "VeiOutputAdapters.SinkBuilders.Count");
                        AssertTrue(deleted, "Did not find the expected deleted trace message '{0}'", deletedMessage);
                        AssertTrue(added, "Did not find the expected added trace message '{0}'", addedMessage);
                    }
                    finally
                    {
                        xonline.server.vortex.Trace.TraceSubscriber -= subscriber;
                    }
                }

                #region Helper Methods

                #region Dont try this at home

                private static BindingFlags internalFetch = BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly;
                private static readonly ConstructorInfo CepETCtor = typeof(CepEventType).GetConstructor(internalFetch, null, new Type[] { typeof(Uri), typeof(Type), typeof(bool), typeof(bool), typeof(int) }, null);
                private static readonly FieldInfo CepETFields = typeof(CepEventType).GetField("_fields", BindingFlags.NonPublic | BindingFlags.Instance);
                private static readonly FieldInfo CepETFieldsByOrdinal = typeof(CepEventType).GetField("_fieldsByOrdinal", BindingFlags.NonPublic | BindingFlags.Instance);

                private static readonly ConstructorInfo CepETFCtor = typeof(CepEventTypeField).GetConstructor(internalFetch, null, new Type[] { typeof(string), typeof(CepEventType), typeof(CultureInfo), typeof(int), typeof(int), typeof(bool), typeof(bool) }, null);

                private CepEventTypeField CreateEventTypeField(Type clrType, string name, int ordinal)
                {
                    return (CepEventTypeField)CepETFCtor.Invoke(new object[] { name, CreateEventTypeFor(clrType, false), CultureInfo.CurrentCulture, ordinal, 0, true, false });
                }

                private CepEventType CreateEventTypeFor(Type type, bool addFields)
                {
                    CepEventType result;
                    Uri name;

                    name = new Uri(string.Format("cep:/Server/Application/TestVeiConfiguration/EventType/{0}", type.AssemblyQualifiedName));

                    result = (CepEventType)CepETCtor.Invoke(new object[] { name, type, false, false, 0 });

                    if (addFields)
                    {
                        Dictionary<string, CepEventTypeField> fields;
                        Dictionary<int, CepEventTypeField> fieldsByOrdinal;

                        fields = new Dictionary<string, CepEventTypeField>();
                        fieldsByOrdinal = new Dictionary<int, CepEventTypeField>();

                        MemberInfo[] members =
                            type.GetFields(BindingFlags.Instance | BindingFlags.Public)
                                .Cast<MemberInfo>()
                                .Union(type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty | BindingFlags.GetProperty))
                                .ToArray();

                        Array.Sort(members, (a, b) => a.Name.CompareTo(b.Name));

                        for (int c = 0; c < members.Length; c++)
                        {
                            CepEventTypeField field;
                            MemberInfo item;

                            item = members[c];
                            field = CreateEventTypeField(
                                item is PropertyInfo ? ((PropertyInfo)item).PropertyType : ((FieldInfo)item).FieldType, 
                                item.Name, 
                                c);

                            fields.Add(item.Name, field);
                            fieldsByOrdinal.Add(c, field);
                        }

                        CepETFields.SetValue(result, fields);
                        CepETFieldsByOrdinal.SetValue(result, fieldsByOrdinal);
                    }

                    return result;
                }

                #endregion

                internal static VortexObjectMapperConfig CreateObjectMapperConfig(string name, params string[] recipes)
                {
                    VortexObjectMapperConfig config;

                    config = new VortexObjectMapperConfig();
                    config.Name = name;
                    
                    for (int c = 0; c < recipes.Length / 2; c++)
                    {
                        config.FieldExpressions[recipes[c * 2]] = recipes[c * 2 + 1];
                    }

                    return config;
                }

                internal static VortexObjectMapperConfig CreateObjectMapperConfig(string name)
                {
                    VortexObjectMapperConfig config;

                    config = new VortexObjectMapperConfig();
                    config.Name = name;
                    config.FieldExpressions["Field1"] = "$0";
                    config.FieldExpressions["Field2"] = "$1";

                    return config;
                }

                internal static VortexStreamConfig CreateStreamConfig(string name, params VortexObjectMapperConfig[] recipes)
                {
                    VortexStreamConfig result;

                    recipes = recipes ?? new VortexObjectMapperConfig[0];

                    result = new VortexStreamConfig();
                    result.Name = name;

                    Array.ForEach(recipes, r => result.Recipes.Add(r));

                    return result;
                }

                internal static VortexStreamConfig CreateDefaultStreamConfig(string name)
                {
                    return CreateStreamConfig(name, CreateObjectMapperConfig("Object1"));
                }

                internal static VortexLogConfig CreateLogConfig(string name, bool hasWildCards, params VortexStreamConfig[] streams)
                {
                    VortexLogConfig result;

                    streams = streams ?? new VortexStreamConfig[0];

                    result = new VortexLogConfig();
                    result.Identifier = name;
                    result.HasWildCards = hasWildCards;

                    Array.ForEach(streams, s => result.Streams.Add(s.Name, s));

                    return result;
                }

                internal static VortexLogConfig CreateDefaultLogConfig(string name, bool hasWildCards)
                {
                    return CreateLogConfig(name, hasWildCards, CreateDefaultStreamConfig("Stream1"));
                }

                internal static VortexEventSinkConfig CreateEventSinkConfig(string name, VortexObjectMapperConfig recipe)
                {
                    VortexEventSinkConfig result;

                    result = new VortexEventSinkConfig();
                    result.Name = name;
                    result.Recipe = recipe;

                    return result;
                }

                internal static VortexEventSinkConfig CreateDefaultEventSinkConfig(string name)
                {
                    return CreateEventSinkConfig(name, CreateObjectMapperConfig("Object1"));
                }

                internal static VortexQueryConfig CreateQueryConfig(string name, params VortexEventSinkConfig[] sinks)
                {
                    VortexQueryConfig result;

                    sinks = sinks ?? new VortexEventSinkConfig[0];

                    result = new VortexQueryConfig();
                    result.Name = name;

                    Array.ForEach(sinks, sink => result.EventSinks.Add(sink.Name, sink));

                    return result;
                }

                internal static VortexQueryConfig CreateDefaultQueryConfig(string name)
                {
                    return CreateQueryConfig(name, CreateDefaultEventSinkConfig(typeof(TestClass).FullName));
                }

                internal static VortexEventIngestionConfig CreateConfig(params object[] items)
                {
                    VortexEventIngestionConfig result;

                    result = new VortexEventIngestionConfig();

                    Array.ForEach(
                        items,
                        item =>
                        {
                            if (item is VortexLogConfig)
                            {
                                VortexLogConfig vlc = (VortexLogConfig)item;

                                if (vlc.HasWildCards)
                                {
                                    result.WildCardLogs.Add(vlc);
                                }
                                else
                                {
                                    result.NamedLogs.Add(vlc.Identifier, vlc);
                                }
                            }
                            else
                            {
                                result.Queries.Add(((VortexQueryConfig)item).Name, (VortexQueryConfig)item);
                            }
                        }
                    );

                    return result;
                }

                private class TestClass : IDispatchedSink
                {
                    public int Field1 { get; set; }
                    public int Field2 { get; set; }

                    public void Dispatch()
                    {
                        throw new NotImplementedException();
                    }
                }

                private class TestClass2 : IDispatchedSink
                {
                    public int Field1 { get; set; }
                    public int Field2 { get; set; }

                    public void Dispatch()
                    {
                        throw new NotImplementedException();
                    }
                }

                #endregion
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestRequestContext.cs ===
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Reflection;
using System.Collections.Specialized;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Vortex;
using ServerTestFramework.Core.Utilities;

using xonline.server.vortex.fd;
using xonline.server.vortex.common;

namespace xonline.test.vortexdvt
{

[TestGroup, DVT]
public class RequestContextTests : VortexDVTTestBaseGroup
{
    internal void TestCallback1(RequestContext ctx)
    {
        ctx.MessageAutoValueSource |= AutoValueSource.EtxManifest;
    }

    internal void TestCallback2(RequestContext ctx)
    {
        ctx.MessageAutoValueSource |= AutoValueSource.VxEvent;
    }

    [TestCase]
    public void TestCompletePush1Level()
    {
        MessageReceivedEventArgs args = new MessageReceivedEventArgs();
        RequestContext ctx = RequestContext.Create(args);
        ValueCheck.IsTrue(ctx.MessageAutoValueSource == AutoValueSource.None, "Default MessageAutoValueSource");
        
        // Null, shouldn't throw
        ctx.Complete();
        ctx.Complete();

        // Test 1 level
        ctx.CompletePush(TestCallback1);
        ctx.Complete();
        ValueCheck.IsTrue((ctx.MessageAutoValueSource & AutoValueSource.EtxManifest) > 0, "Verify callback");
        ValueCheck.IsFalse((ctx.MessageAutoValueSource & AutoValueSource.VxEvent) > 0, "Verify callback");

        // Null, shouldn't throw
        ctx.Complete();

    }

    [TestCase]
    public void TestCompletePush2Level()
    {
        MessageReceivedEventArgs args = new MessageReceivedEventArgs();
        RequestContext ctx = RequestContext.Create(args);

        // Test 2 levels
        ctx.CompletePush(TestCallback2);
        ctx.CompletePush(TestCallback1);
        ValueCheck.IsFalse((ctx.MessageAutoValueSource & AutoValueSource.EtxManifest) > 0, "Verify callback");
        ValueCheck.IsFalse((ctx.MessageAutoValueSource & AutoValueSource.VxEvent) > 0, "Verify callback");
        ctx.Complete();
        ValueCheck.IsTrue((ctx.MessageAutoValueSource & AutoValueSource.EtxManifest) > 0, "Verify callback");
        ValueCheck.IsFalse((ctx.MessageAutoValueSource & AutoValueSource.VxEvent) > 0, "Verify callback");
        ctx.Complete();
        ValueCheck.IsTrue((ctx.MessageAutoValueSource & AutoValueSource.EtxManifest) > 0, "Verify callback");
        ValueCheck.IsTrue((ctx.MessageAutoValueSource & AutoValueSource.VxEvent) > 0, "Verify callback");
        ctx.Complete();
    }

    [TestCase]
    public void TestQueueUserWorkItem()
    {
        MessageReceivedEventArgs args = new MessageReceivedEventArgs();
        RequestContext ctx = RequestContext.Create(args);

        ctx.CompletePush(TestCallback2);
        ctx.QueueUserWorkItem(TestCallback1);
        Thread.Sleep(100);  // long enough?
        ValueCheck.IsTrue((ctx.MessageAutoValueSource & AutoValueSource.EtxManifest) > 0, "Verify callback");
        ValueCheck.IsFalse((ctx.MessageAutoValueSource & AutoValueSource.VxEvent) > 0, "Verify callback");
        ctx.Complete();
        ValueCheck.IsTrue((ctx.MessageAutoValueSource & AutoValueSource.EtxManifest) > 0, "Verify callback");
        ValueCheck.IsTrue((ctx.MessageAutoValueSource & AutoValueSource.VxEvent) > 0, "Verify callback");
        ctx.Complete();
    }

    [TestCase]
    public void TestQueueUserWorkItemNegative()
    {
        MessageReceivedEventArgs args = new MessageReceivedEventArgs();
        RequestContext ctx = RequestContext.Create(args);

        ctx.CompletePush(TestCallback2);
        ctx.QueueUserWorkItem(null);
        Thread.Sleep(100);  // long enough?
        ValueCheck.IsFalse((ctx.MessageAutoValueSource & AutoValueSource.EtxManifest) > 0, "Verify callback");
        ValueCheck.IsFalse((ctx.MessageAutoValueSource & AutoValueSource.VxEvent) > 0, "Verify callback");
        ctx.Complete();
        ValueCheck.IsFalse((ctx.MessageAutoValueSource & AutoValueSource.EtxManifest) > 0, "Verify callback");
        ValueCheck.IsTrue((ctx.MessageAutoValueSource & AutoValueSource.VxEvent) > 0, "Verify callback");
        ctx.Complete();
    }

    [TestCase]
    public void TestToStringBasic()
    {
        MessageReceivedEventArgs args = new MessageReceivedEventArgs()
        {
            RemoteEP = null,
            LocalEP = null,
            AuthZHdr = null,
            HttpAuthDataHdr = null,
            Lines = null,
            Events = null,
        };   
        RequestContext ctx = RequestContext.Create(args);
        ctx.SGInfoInstance = null;
        ctx.AAInfoInstance = null;
        string s = ctx.ToString();
        Global.RO.Debug(s);

        // [0.0.0.0:0 #5] SG:0/N AA:0/N
        ValueCheck.IsTrue(s.Contains(" 0.0.0.0:0 #"), "First part");
        ValueCheck.IsTrue(s.EndsWith("] SG:0/N"), "Last part");

        // Event text
        s = ctx.ToEventString();
        Global.RO.Debug(s);
    }

    [TestCase]
    public void TestToStringAdv()
    {
        MessageReceivedEventArgs args = new MessageReceivedEventArgs()
        {
            RemoteEP = new System.Net.IPEndPoint(0x01020304, 1000),
            LocalEP = new System.Net.IPEndPoint(0x05060708, 1001),
            AuthZHdr = "AUTHZHDRBLAHBLAH",
            HttpAuthDataHdr = "A",
            Lines = new List<string>() {
                "FOO|bar|0",
                "FOO2|baz|1|1.2.3.4",
            },
            Events = new List<xonline.common.protocol.VxEvent>() { 
                new xonline.common.protocol.VxEvent(new byte[] { 16 }, 1, DateTime.Now),
                new xonline.common.protocol.VxEvent(new byte[] { 16 }, 1, DateTime.Now),
                new xonline.common.protocol.VxEvent(new byte[] { 16 }, 1, DateTime.Now),
            },
        };
        RequestContext ctx = RequestContext.Create(args);
        ctx.SGInfoInstance = new xonline.common.service.SGInfo(1000, 0x01020304, 1);
        ctx.AAInfoInstance = null;

        string s = ctx.ToString();
        Global.RO.Debug(s);

        // [# 4.3.2.1:1000 #6] 3/V 2/L SG:1/Y AA:16/N
        string expected = String.Format("[{0} 4.3.2.1:1000 #", System.Threading.Thread.CurrentThread.ManagedThreadId);
        ValueCheck.IsTrue(s.StartsWith(expected), "First part");
        ValueCheck.IsTrue(s.EndsWith("] 3/V 2/L SG:1/Y AA:16/N"), "Last part");

        // Event text
        s = ctx.ToEventString();
        Global.RO.Debug(s);
        ValueCheck.IsTrue(s.Contains("----- AA Info"), "AA Info");
        ValueCheck.IsTrue(s.Contains("----- SG Info"), "SG Info");
        ValueCheck.IsTrue(s.Contains("----- LogString -----"), "LogString");
        ValueCheck.IsTrue(!s.Contains("----- LogString2 -----"), "LogString2");
        ValueCheck.IsTrue(s.Contains("----- VortexProtocol -----"), "Vortex Protocol");
    }


} // end group

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\vortexdvt.cs ===
using System;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Web;
using System.Web.Hosting;
using System.IO;
using System.Text;
using System.Security.Cryptography;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.config;

namespace xonline.test.vortexdvt 
{

public class VortexDVTTestBaseGroup : TestNode
{
    protected static Report           ro           = new Report("DVT");

    protected int _NumRequests; 

    [TestGroupSetup]
    public void Setup()
    {
        ServicePointManager.DefaultConnectionLimit = 100;
        _NumRequests = 0;
    }

    // ------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------
    public static string BuildUrl(string apiName, string virtualInterface)
    {
        string url;
        IVirtualInterfaceInfo vii = Config.GetVirtualInterface(virtualInterface);
        url = String.Format("http://{0}:{1}/{2}/{3}",
                            vii.IPAddressString,
                            vii.Port,
                            vii.VDir,
                            apiName);
        ro.Debug(url);
        return url;
    }

    public virtual byte[] GenerateHttpHeader(IPEndPoint endPoint, string httpMethod, string httpPath, int contentLength)
    {
        StringBuilder sbURL;

        sbURL = new StringBuilder();
        sbURL.Append(httpMethod + " " + httpPath);
        sbURL.Append(" HTTP/1.0\r\n");
        sbURL.Append("Host: " + endPoint.ToString() + "\r\n");
        sbURL.Append("Content-Type: text/xml\r\n");
        sbURL.Append("User-Agent: VortexDVT/0\r\n");
        sbURL.Append("Content-Length: " + contentLength + "\r\n\r\n");

        System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();
        return AE.GetBytes(sbURL.ToString());
    }



    // ------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------
    protected string PostRequest(string url, string method, byte[] content, bool fKeepAlive)
    {
        return PostRequest(url, method, content, fKeepAlive, false);
    }

    protected string PostRequest(string url, string method, byte[] content, bool fKeepAlive, bool fActiveAuth)
    {
        try
        {
            ro.Debug("HTTP Request: {0}", url);

            HttpWebRequest webreq = (HttpWebRequest)WebRequest.Create(url);
            webreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
            webreq.UserAgent = "20/7.7.7777.0";
            webreq.KeepAlive = fKeepAlive;
            webreq.Method = method;
            if (fActiveAuth)
            {
                webreq.Headers.Add("X-Floken", "01ABCDEF77777777");
                if (content == null)
                    webreq.ContentType = "text/xml"; // @@@?
                else
                    webreq.ContentType = "xon/20"; // 32 (0x20) is vortex

                int i = url.IndexOf('?');
                string queryString = (i >= 0) ? url.Substring(i + 1) : "";
                webreq.Headers.Add("X-IFLCDIGEST", CreateIflcDigest(queryString));
            }
            else
            {
                webreq.ContentType = "xon/20"; // 32 (0x20) is vortex
            }

            webreq.ContentLength = content == null ? 0 : content.Length;

            // Set all headers prior to this!
            if (content != null)
            {
                // This initiates the send, btw
                webreq.GetRequestStream().Write(content, 0, content.Length);
            }

            //ro.Debug("Request headers:\n{0}", webreq.Headers);

            //if (_NumRequests >= 0)
            //{
            //    ShowServicePointProperties(webreq.ServicePoint);
            //}
            _NumRequests++;

            // Finish and get response
            HttpWebResponse webresp = (HttpWebResponse)webreq.GetResponse();

            //ro.Debug("Response headers:\n{0}", webresp.Headers);

            // Read body
            StreamReader sr = new StreamReader(webresp.GetResponseStream());
            string contentResponse = sr.ReadToEnd();

            webresp.Close();
            sr.Close();

            return contentResponse;
        }
        catch (WebException we)
        {
            // We throw, so no need to print this
            // ro.Error("Got WebException:\n{0}", we.ToString());
            ro.Warn("WebException: {0}, Status {1}", we.Message, we.Status);

            if (we.Response != null)
            {
                StreamReader sr = null;
                try
                {
                    ro.Debug("WebException Response headers:\n{0}", we.Response.Headers);

//                     sr = new StreamReader(we.Response.GetResponseStream());
//                     String s = sr.ReadToEnd();

                }
                finally 
                {
                    we.Response.Close();
                    if (sr != null)
                        sr.Close();
                }
            }

            throw;
        }
    }

    protected void PostRequestFast(IPEndPoint endPoint, string method, string url, string content, bool fReadResponse)
    {
        byte[] httpHeader = GenerateHttpHeader(endPoint, method, url, 0);

        MyWebTransaction xAct = new MyWebTransaction();
        xAct.endPoint = endPoint;

        xAct.ExecuteTCP(httpHeader, null, true, fReadResponse);
        
    }


    public static void ShowServicePointProperties(ServicePoint sp)
    {
        ro.Debug ("ServicePoint: HashCode = " + sp.GetHashCode());

        // Display the ServicePoint Internet resource address.
        ro.Debug ("ServicePoint: Address = {0} ", sp.Address.ToString ());

        // Display the date and time that the ServicePoint was last 
        // connected to a host.
        ro.Debug ("ServicePoint: IdleSince = " + sp.IdleSince.ToString ());

        // Display the maximum length of time that the ServicePoint instance  
        // is allowed to maintain an idle connection to an Internet  
        // resource before it is recycled for use in another connection.
        ro.Debug ("ServicePoint: MaxIdleTime = " + sp.MaxIdleTime);

        ro.Debug ("ServicePoint: ConnectionName = " + sp.ConnectionName);

        // Display the maximum number of connections allowed on this 
        // ServicePoint instance.
        ro.Debug ("ServicePoint: ConnectionLimit = " + sp.ConnectionLimit);

        // Display the number of connections associated with this 
        // ServicePoint instance.
        ro.Debug ("ServicePoint: CurrentConnections = " + sp.CurrentConnections);

        if (sp.Certificate == null)
            ro.Debug ("ServicePoint: Certificate = (null)");
        else
            ro.Debug ("ServicePoint: Certificate = " + sp.Certificate.ToString ());

        if (sp.ClientCertificate == null)
            ro.Debug ("ServicePoint: ClientCertificate = (null)");
        else
            Console. WriteLine ("ServicePoint: ClientCertificate = " + sp.ClientCertificate.ToString ());

        ro.Debug ("ServicePoint: ProtocolVersion = " + sp.ProtocolVersion.ToString ());
        ro.Debug ("ServicePoint: SupportsPipelining = " + sp.SupportsPipelining);
        ro.Debug ("ServicePoint: UseNagleAlgorithm = " + sp.UseNagleAlgorithm.ToString ());
        ro.Debug ("ServicePoint: Expect 100-continue = " + sp.Expect100Continue.ToString ());
    }

    private static readonly byte[] keyMask = new byte[] 
    {
        0xbb, 0xe9, 0x98, 0x69, 0xb9, 0x8d, 0xc8, 0xfd, 
        0x8a, 0x69, 0x19, 0xb9, 0x09, 0x88, 0xc8, 0xfd,
        0x2b, 0x09, 0xd9, 0x69, 0x39, 0xa9
    };
    private static readonly byte[] protectedKey = new byte[]
    {
        0xa7, 0x80, 0xa9, 0x04, 0x22, 0x4f, 0xd6, 0x1e, 0x03, 0x5f, 0x51, 0x02, 0xae, 0x34, 0xcb, 0x7a
    };

    public static string CreateIflcDigest(string queryString)
    {
        // Make value for the X-IFLCDIGEST header

        byte[] content = System.Text.Encoding.UTF8.GetBytes(queryString);

        // Get key
        byte[] signingKey = new byte[protectedKey.Length];
        for (int i = 0; i < protectedKey.Length; i++)
        {
            signingKey[i] = (byte)(keyMask[i] ^ protectedKey[i]);
        }

        using (HMACSHA1 hasher = new HMACSHA1(signingKey, true))
        {
            MemoryStream streamContent = new MemoryStream(content);
            byte[] computedSignature = hasher.ComputeHash(streamContent);

            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            foreach (byte chunk in computedSignature)
            {
                sb.Append(chunk.ToString("X2"));
            }

            return sb.ToString();
        }
    }


}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\dvt\TestVeiParsing.cs ===
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.IO;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Reflection;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;

using xonline.server.vortex;
using xonline.server.vortex.cake;

namespace xonline.test.vortexdvt
{
    public class VeiTestBaseGroup : TestNode
    {
        public static Dictionary<string, object> GenerateTestPayload()
        {
            Dictionary<string, object> result;

            result = new Dictionary<string, object>();
            result["id"] = "payloadId";

            return result;
        }

        public static Delegate DynCompileExpression(string expression, Type targetType)
        {
            MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

            compileExpression = compileExpression.MakeGenericMethod(targetType);

            return (Delegate)compileExpression.Invoke(null, new object[] { expression });
        }

        public static Func<PayloadReader, PayloadReader.Context, T> CompileExpression<T>(string expression)
        {
            ObjectMapper.ConstructionParameters parameters;

            parameters = new ObjectMapper.ConstructionParameters();

            parameters.PayloadReader = Expression.Parameter(typeof(PayloadReader), "pr");
            parameters.PayloadReaderContext = Expression.Parameter(typeof(PayloadReader.Context), "prc");
            parameters.TargetObject = Expression.Parameter(typeof(object), "o");

            return Expression.Lambda<Func<PayloadReader, PayloadReader.Context, T>>(
                TextParser.GenerateExpressionTree(parameters, expression, typeof(T)),
                parameters.PayloadReader,
                parameters.PayloadReaderContext).Compile();
        }

        public static void AssertLexTerms(string name, LexTerm[] terms, params TermType[] expectedTypes)
        {
            StringBuilder message;
            bool different;

            message = new StringBuilder();

            message.AppendLine();
            message.AppendLine("=============== " + name + ":LexTerm Verification Failed ===============");
            message.AppendLine("       Supplied Values  Expected Values  Supplied Text");
            different = terms.Length != expectedTypes.Length;

            for (int c = 0; c < Math.Max(terms.Length, expectedTypes.Length); c++)
            {
                message.AppendFormat("  {0,2:0}.  ", c);
                message.AppendFormat("{0,-16} ", c < terms.Length ? terms[c].TermType.ToString() : "");
                message.AppendFormat("{0,-16} ", c < expectedTypes.Length ? expectedTypes[c].ToString() : "");
                message.AppendFormat("{0,-16} ", c < terms.Length ? terms[c].Text.ToString() : "");
                message.AppendLine();

                if (!different && terms[c].TermType != expectedTypes[c])
                {
                    different = true;
                }
            }

            if (different)
            {
                AssertFail(message.ToString());
            }
        }

        public static void AssertEquals<T>(T a, T b, string format, params object[] args)
        {
            string message;

            message = string.Format(
                "error {2} {0} != {1}", a, b, string.Format(format, args));

            if (null == a)
            {
                if (null != b)
                {
                    AssertFail(message);
                }
            }
            else
            {
                if (!a.Equals(b))
                {
                    AssertFail(message);
                }
            }
        }

        public static void AssertTrue(bool item, string format, params object[] args)
        {
            if (!item)
            {
                AssertFail(string.Format("error not true {0}", string.Format(format, args)));
            }
        }

        public static void AssertPresent<K, T>(IDictionary<K, T> dictionary, K key, string format, params object[] args)
        {
            if (!dictionary.ContainsKey(key))
            {
                AssertFail(string.Format("error {1} : item '{0}' not found in dictionary.", key, string.Format(format, args)));
            }
        }

        public static void AssertPresent<T>(IEnumerable<T> collection, Func<T, bool> predicate, string format, params object[] args)
        {
            if (!collection.Any(predicate))
            {
                AssertFail(string.Format("error {0} : item could not be found in collection.", string.Format(format, args)));
            }
        }

        public static void AssertFail(string format, params object[] args)
        {
            Global.RO.Error(format, args);

            throw new StfException("assertion failed");
        }
    }

    public partial class CAKE
    {
        [TestGroup, DVT]
        public class Parsing : VeiTestBaseGroup
        {
            #region Lex Unit Tests

            [TestGroup, DVT]
            public class TermParsingUnits : VeiTestBaseGroup
            {
                #region Single Term Parsing

                [TestGroup, DVT]
                public class SingleTermParsing : VeiTestBaseGroup
                {

                    [TestCase]
                    public void Lex_SingleLiteral()
                    {
                        LexTerm[] terms;

                        terms = TextParser.ExtractExpressionTerms(@"H\ello World!");

                        AssertLexTerms("", terms, TermType.Literal);
                        AssertEquals(terms[0].Hint, "", "LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "Hello World!", "LexTerm[0].Text");
                    }

                    [TestCase]
                    public void Lex_SingleOrdinalToken()
                    {
                        LexTerm[] terms;

                        terms = TextParser.ExtractExpressionTerms(@"$240");

                        AssertLexTerms("A", terms, TermType.OrdinalToken);
                        AssertEquals(terms[0].Hint, "", "A:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$240", "A:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.OrdinalMatchGroup].Value, "240", "A:LexTerm[0].Match[Ordinal]");

                        terms = TextParser.ExtractExpressionTerms(@"$(240)");

                        AssertLexTerms("B", terms, TermType.OrdinalToken);
                        AssertEquals(terms[0].Hint, "", "B:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(240)", "B:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.OrdinalMatchGroup].Value, "240", "B:LexTerm[0].Match[Ordinal]");

                        terms = TextParser.ExtractExpressionTerms(@"$(240%x)");

                        AssertLexTerms("C", terms, TermType.OrdinalToken);
                        AssertEquals(terms[0].Hint, "x", "C:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(240%x)", "C:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.OrdinalMatchGroup].Value, "240", "C:LexTerm[0].Match[Ordinal]");
                    }

                    [TestCase]
                    public void Lex_SingleNamedToken()
                    {
                        LexTerm[] terms;

                        terms = TextParser.ExtractExpressionTerms(@"$(Dessert)");

                        AssertLexTerms("A", terms, TermType.NamedToken);
                        AssertEquals(terms[0].Hint, "", "A:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(Dessert)", "A:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.NameMatchGroup].Value, "Dessert", "A:LexTerm[0].Match[Name]");

                        terms = TextParser.ExtractExpressionTerms(@"$(Dessert%x)");

                        AssertLexTerms("B", terms, TermType.NamedToken);
                        AssertEquals(terms[0].Hint, "x", "B:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(Dessert%x)", "B:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.NameMatchGroup].Value, "Dessert", "B:LexTerm[0].Match[Name]");
                    }

                    [TestCase]
                    public void Lex_SingleUniversalSetJoin()
                    {
                        LexTerm[] terms;

                        terms = TextParser.ExtractExpressionTerms(@"$(*)");

                        AssertLexTerms("A", terms, TermType.UniversalSetJoin);
                        AssertEquals(terms[0].Hint, "", "A:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(*)", "A:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.DelimiterMatchGroup].Value, "", "A:LexTerm[0].Match[Delimiter]");

                        terms = TextParser.ExtractExpressionTerms(@"$(*:|)");

                        AssertLexTerms("B", terms, TermType.UniversalSetJoin);
                        AssertEquals(terms[0].Hint, "", "B:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(*:|)", "B:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.DelimiterMatchGroup].Value, "|", "B:LexTerm[0].Match[Delimiter]");
                    }

                    [TestCase]
                    public void Lex_SingleOrdinalSetJoin()
                    {
                        LexTerm[] terms;

                        terms = TextParser.ExtractExpressionTerms(@"$(23-465)");

                        AssertLexTerms("A", terms, TermType.OrdinalSetJoin);
                        AssertEquals(terms[0].Hint, "", "A:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(23-465)", "A:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.LowMatchGroup].Value, "23", "A:LexTerm[0].Match[Low]");
                        AssertEquals(terms[0].Match.Groups[TextParser.HighMatchGroup].Value, "465", "A:LexTerm[0].Match[High]");
                        AssertEquals(terms[0].Match.Groups[TextParser.DelimiterMatchGroup].Value, "", "A:LexTerm[0].Match[Delimiter]");

                        terms = TextParser.ExtractExpressionTerms(@"$(23-465:|)");

                        AssertLexTerms("B", terms, TermType.OrdinalSetJoin);
                        AssertEquals(terms[0].Hint, "", "B:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(23-465:|)", "B:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.LowMatchGroup].Value, "23", "B:LexTerm[0].Match[Low]");
                        AssertEquals(terms[0].Match.Groups[TextParser.HighMatchGroup].Value, "465", "B:LexTerm[0].Match[High]");
                        AssertEquals(terms[0].Match.Groups[TextParser.DelimiterMatchGroup].Value, "|", "B:LexTerm[0].Match[Delimiter]");
                    }

                    [TestCase]
                    public void Lex_SingleNamedSetJoin()
                    {
                        LexTerm[] terms;

                        terms = TextParser.ExtractExpressionTerms(@"$(Spinach[23-465])");

                        AssertLexTerms("A", terms, TermType.NamedSetJoin);
                        AssertEquals(terms[0].Hint, "", "A:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(Spinach[23-465])", "A:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.NameMatchGroup].Value, "Spinach", "A:LexTerm[0].Match[Name]");
                        AssertEquals(terms[0].Match.Groups[TextParser.LowMatchGroup].Value, "23", "A:LexTerm[0].Match[Low]");
                        AssertEquals(terms[0].Match.Groups[TextParser.HighMatchGroup].Value, "465", "A:LexTerm[0].Match[High]");
                        AssertEquals(terms[0].Match.Groups[TextParser.DelimiterMatchGroup].Value, "", "A:LexTerm[0].Match[Delimiter]");

                        terms = TextParser.ExtractExpressionTerms(@"$(Spinach[23-465]:|)");

                        AssertLexTerms("B", terms, TermType.NamedSetJoin);
                        AssertEquals(terms[0].Hint, "", "B:LexTerm[0].Hint");
                        AssertEquals(terms[0].Text, "$(Spinach[23-465]:|)", "B:LexTerm[0].Text");
                        AssertEquals(terms[0].Match.Groups[TextParser.NameMatchGroup].Value, "Spinach", "B:LexTerm[0].Match[Name]");
                        AssertEquals(terms[0].Match.Groups[TextParser.LowMatchGroup].Value, "23", "B:LexTerm[0].Match[Low]");
                        AssertEquals(terms[0].Match.Groups[TextParser.HighMatchGroup].Value, "465", "B:LexTerm[0].Match[High]");
                        AssertEquals(terms[0].Match.Groups[TextParser.DelimiterMatchGroup].Value, "|", "B:LexTerm[0].Match[Delimiter]");
                    }

                }

                #endregion

                #region Multiple Term Parsing

                [TestGroup, DVT]
                public class MultiTermParsing : VeiTestBaseGroup
                {

                    [TestCase]
                    public void Lex_MultiTermOneOfEach()
                    {
                        LexTerm[] terms;

                        terms = TextParser.ExtractExpressionTerms(@"Text|\$(Tricky)|$1|$(2)|$(Name)|$(*:X)|$(1-2:Y)|$(Name[1-2]:Z)");

                        AssertLexTerms("", terms,
                            TermType.Literal,
                            TermType.OrdinalToken,
                            TermType.Literal,
                            TermType.OrdinalToken,
                            TermType.Literal,
                            TermType.NamedToken,
                            TermType.Literal,
                            TermType.UniversalSetJoin,
                            TermType.Literal,
                            TermType.OrdinalSetJoin,
                            TermType.Literal,
                            TermType.NamedSetJoin);

                        AssertEquals(terms[0].Text, @"Text|$(Tricky)|", "LexTerm[0].Text");
                        AssertEquals(terms[1].Match.Groups[TextParser.OrdinalMatchGroup].Value, "1", "LexTerm[1].Match[Ordinal]");
                        AssertEquals(terms[2].Text, "|", "LexTerm[2].Text");
                        AssertEquals(terms[3].Match.Groups[TextParser.OrdinalMatchGroup].Value, "2", "LexTerm[3].Match[Ordinal]");
                        AssertEquals(terms[4].Text, "|", "LexTerm[4].Text");
                        AssertEquals(terms[5].Match.Groups[TextParser.NameMatchGroup].Value, "Name", "LexTerm[5].Match[Name]");
                        AssertEquals(terms[6].Text, "|", "LexTerm[6].Text");
                        AssertEquals(terms[8].Text, "|", "LexTerm[8].Text");
                        AssertEquals(terms[9].Match.Groups[TextParser.LowMatchGroup].Value, "1", "LexTerm[9].Match[Low]");
                        AssertEquals(terms[9].Match.Groups[TextParser.HighMatchGroup].Value, "2", "LexTerm[9].Match[High]");
                        AssertEquals(terms[10].Text, "|", "LexTerm[10].Text");
                        AssertEquals(terms[11].Match.Groups[TextParser.NameMatchGroup].Value, "Name", "LexTerm[11].Match[Name]");
                        AssertEquals(terms[11].Match.Groups[TextParser.LowMatchGroup].Value, "1", "LexTerm[11].Match[Low]");
                        AssertEquals(terms[11].Match.Groups[TextParser.HighMatchGroup].Value, "2", "LexTerm[11].Match[High]");
                    }

                    [TestCase]
                    public void Lex_MultiTermEscapePrecidenceCheck()
                    {
                        LexTerm[] terms;

                        terms = TextParser.ExtractExpressionTerms(@"abc\d\e\f\g\$($(Alph\a)");

                        AssertLexTerms("", terms, TermType.Literal);
                        AssertEquals(terms[0].Text, "abcdefg$($(Alpha)", "LexTerm[0].Text");
                    }

                }

                #endregion
            }

            #endregion

            #region Expression Generation Unit Tests

            [TestGroup, DVT]
            public class ExpressionGenerationUnits : VeiTestBaseGroup
            {
                #region Integral Expression Generation

                [TestGroup, DVT]
                [CompoundCase("SByte", "System.SByte")]
                [CompoundCase("Int16", "System.Int16")]
                [CompoundCase("Int32", "System.Int32")]
                [CompoundCase("Int64", "System.Int64")]
                [CompoundCase("Byte", "System.Byte")]
                [CompoundCase("UInt16", "System.UInt16")]
                [CompoundCase("UInt32", "System.UInt32")]
                [CompoundCase("UInt64", "System.UInt64")]
                public class IntegralExpressionGen : VeiTestBaseGroup
                {
                    [TestCase]
                    public void FromIntegralObject()
                    {
                        Delegate expr1;
                        Delegate expr2;
                        Delegate expr3;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr1 = (Delegate)compileExpression.Invoke(null, new object[] { "$1" });
                        expr2 = (Delegate)compileExpression.Invoke(null, new object[] { "$2" });
                        expr3 = (Delegate)compileExpression.Invoke(null, new object[] { "$0$1$2" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload["0"] = 13;
                        payload["1"] = 22;

                        AssertEquals(expr1.DynamicInvoke(pr, prc), Convert.ChangeType(22, target), "expr($1)");
                        AssertEquals(expr2.DynamicInvoke(pr, prc), Convert.ChangeType(0, target), "expr($2)");
                        AssertEquals(expr3.DynamicInvoke(pr, prc), Convert.ChangeType(35, target), "expr($0$1$2$3)");
                    }

                    [TestCase]
                    public void FromString()
                    {
                        Delegate expr1;
                        Delegate expr2;
                        Delegate expr3;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr1 = (Delegate)compileExpression.Invoke(null, new object[] { "$(0%x)" });
                        expr2 = (Delegate)compileExpression.Invoke(null, new object[] { "$(4%x)" });
                        expr3 = (Delegate)compileExpression.Invoke(null, new object[] { "$0$1$2" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload["0"] = "13";
                        payload["1"] = "22";
                        payload["4"] = "0x10";

                        AssertEquals(expr1.DynamicInvoke(pr, prc), Convert.ChangeType(19, target), "expr($(0%x))");
                        AssertEquals(expr2.DynamicInvoke(pr, prc), Convert.ChangeType(16, target), "expr($(4%x))");
                        AssertEquals(expr3.DynamicInvoke(pr, prc), Convert.ChangeType(35, target), "expr($0$1$2)");
                    }

                    [TestCase]
                    public void WithLiterals()
                    {
                        Delegate expr1;
                        Delegate expr2;
                        Delegate expr3;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr1 = (Delegate)compileExpression.Invoke(null, new object[] { "19" });
                        expr2 = (Delegate)compileExpression.Invoke(null, new object[] { "1$0" });
                        expr3 = (Delegate)compileExpression.Invoke(null, new object[] { "1$(0)1$(1)1" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload["0"] = "13";
                        payload["1"] = "22";

                        AssertEquals(expr1.DynamicInvoke(pr, prc), Convert.ChangeType(19, target), "expr(19)");
                        AssertEquals(expr2.DynamicInvoke(pr, prc), Convert.ChangeType(14, target), "expr(1$0)");
                        AssertEquals(expr3.DynamicInvoke(pr, prc), Convert.ChangeType(38, target), "expr(1$(0)1$(1)1)");
                    }

                    [TestCase]
                    public void FromNegativeSByte()
                    {
                        Delegate expr1;
                        SByte value;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr1 = (Delegate)compileExpression.Invoke(null, new object[] { "$0" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        value = -1;
                        payload["0"] = value;

                        if (target == typeof(SByte))
                        {
                            SByte output = (SByte)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int16))
                        {
                            Int16 output = (Int16)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int32))
                        {
                            Int32 output = (Int32)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int64))
                        {
                            Int64 output = (Int64)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Byte))
                        {
                            Byte output = (Byte)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt16))
                        {
                            UInt16 output = (UInt16)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt32))
                        {
                            UInt32 output = (UInt32)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt64))
                        {
                            UInt64 output = (UInt64)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                    }

                    [TestCase]
                    public void FromNegativeInt16()
                    {
                        Delegate expr1;
                        Int16 value;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr1 = (Delegate)compileExpression.Invoke(null, new object[] { "$0" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        value = -1;
                        payload["0"] = value;

                        if (target == typeof(SByte))
                        {
                            SByte output = (SByte)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int16))
                        {
                            Int16 output = (Int16)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int32))
                        {
                            Int32 output = (Int32)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int64))
                        {
                            Int64 output = (Int64)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Byte))
                        {
                            Byte output = (Byte)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt16))
                        {
                            UInt16 output = (UInt16)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt32))
                        {
                            UInt32 output = (UInt32)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt64))
                        {
                            UInt64 output = (UInt64)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                    }

                    [TestCase]
                    public void FromNegativeInt32()
                    {
                        Delegate expr1;
                        Int32 value;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr1 = (Delegate)compileExpression.Invoke(null, new object[] { "$0" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        value = -1;
                        payload["0"] = value;

                        if (target == typeof(SByte))
                        {
                            SByte output = (SByte)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int16))
                        {
                            Int16 output = (Int16)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int32))
                        {
                            Int32 output = (Int32)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int64))
                        {
                            Int64 output = (Int64)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Byte))
                        {
                            Byte output = (Byte)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt16))
                        {
                            UInt16 output = (UInt16)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt32))
                        {
                            UInt32 output = (UInt32)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt64))
                        {
                            UInt64 output = (UInt64)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                    }

                    [TestCase]
                    public void FromNegativeInt64()
                    {
                        Delegate expr1;
                        SByte value;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr1 = (Delegate)compileExpression.Invoke(null, new object[] { "$0" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        value = -1;
                        payload["0"] = value;

                        if (target == typeof(SByte))
                        {
                            SByte output = (SByte)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int16))
                        {
                            Int16 output = (Int16)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int32))
                        {
                            Int32 output = (Int32)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Int64))
                        {
                            Int64 output = (Int64)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(Byte))
                        {
                            Byte output = (Byte)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt16))
                        {
                            UInt16 output = (UInt16)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt32))
                        {
                            UInt32 output = (UInt32)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                        else if (target == typeof(UInt64))
                        {
                            UInt64 output = (UInt64)value;
                            AssertEquals(expr1.DynamicInvoke(pr, prc), output, "expr($0)");
                        }
                    }
                }

                #endregion

                #region Non-Integral Expression Generation

                [TestGroup, DVT]
                [CompoundCase("Guid From String", "System.Guid", "08496d63-cac5-4d57-af95-d61fdf0952f0", "08496d63-cac5-4d57-af95-d61fdf0952f0")]
                [CompoundCase("Guid From Bytes", "System.Guid", "08496d63-cac5-4d57-af95-d61fdf0952f0", 0)]
                public class GuidExpressionGen : VeiTestBaseGroup
                {
                    static object[] objs = new object[] 
                    {
                        new byte[] { 0x63, 0x6d, 0x49, 0x08,   0xc5, 0xca,   0x57, 0x4d,   0xaf, 0x95, 0xd6, 0x1f, 0xdf, 0x09, 0x52, 0xf0 }
                    };

                    [TestCase]
                    public void TestConversion()
                    {
                        Delegate expr;
                        string literal;
                        object value;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        literal = (string)MyValues[1];
                        value = MyValues[2] is int ? objs[(int)MyValues[2]] : MyValues[2];

                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr = (Delegate)compileExpression.Invoke(null, new object[] { "$0" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload["0"] = value;

                        // literal contains the expected canonical representation of the converted object 
                        AssertEquals(expr.DynamicInvoke(pr, prc).ToString(), literal, "expr($0)", literal);
                    }
                }

                [TestGroup, DVT]
                [CompoundCase("Byte[]", "System.Byte[]", "feedbadbeef2babe", 0)]
                public class ByteArrayExpressionGen : VeiTestBaseGroup
                {
                    static object[] objs = new object[] 
                    {
                        new Byte[] { 0xfe, 0xed, 0xba, 0xdb, 0xee, 0xf2, 0xba, 0xbe }
                    };

                    [TestCase]
                    public void TestConversion()
                    {
                        Delegate expr;
                        string literal;
                        object value;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        literal = (string)MyValues[1];
                        value = MyValues[2] is int ? objs[(int)MyValues[2]] : MyValues[2];

                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr = (Delegate)compileExpression.Invoke(null, new object[] { "$0" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload["0"] = value;

                        // literal contains the expected canonical representation of the converted object 
                        AssertEquals(MakeString((Byte[])expr.DynamicInvoke(pr, prc)), literal, "expr($0)", literal);
                    }

                    private string MakeString(Byte[] array)
                    {
                        return string.Join("", Array.ConvertAll(array, b => string.Format("{0:x2}", b)).ToArray());
                    }
                }

                [TestGroup, DVT]
                [CompoundCase("Float", "System.Single", "1.618034", 1.618034f)]
                [CompoundCase("Double", "System.Double", "2.71828182845904", 2.71828182845904d)]
                [CompoundCase("Decimal", "System.Decimal", "3.1415926535897932384626433832795028", 0)]
                [CompoundCase("Bool", "System.Boolean", "true", true)]
                [CompoundCase("DateTime", "System.DateTime", "10/01/1983 23:59", 1)]
                [CompoundCase("TimeSpan", "System.TimeSpan", "1:15:30.50", 2)]
                [CompoundCase("Guid", "System.Guid", "08496d63-cac5-4d57-af95-d61fdf0952f0", 3)]
                [CompoundCase("Char", "System.Char", "J", 'J')]
                [CompoundCase("String", "System.String", "The CAKE is not a lie", "The CAKE is not a lie")]
                public class NonIntegralExpressionGen : VeiTestBaseGroup
                {
                    static object[] objs = new object[] 
                    {
                        3.1415926535897932384626433832795028m,
                        DateTime.Parse("10/01/1983 23:59"),
                        TimeSpan.Parse("1:15:30.50"),
                        new Guid("08496d63-cac5-4d57-af95-d61fdf0952f0")
                    };

                    [TestCase]
                    public void SimpleLiteral()
                    {
                        Delegate expr;
                        string literal;
                        object value;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        literal = (string)MyValues[1];
                        value = MyValues[2] is int ? objs[(int)MyValues[2]] : MyValues[2];

                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr = (Delegate)compileExpression.Invoke(null, new object[] { literal });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        AssertEquals(expr.DynamicInvoke(pr, prc), value, "expr({0})", literal);
                    }

                    [TestCase]
                    public void SimplePayloadValue()
                    {
                        Delegate expr;
                        string literal;
                        object value;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        literal = (string)MyValues[1];
                        value = MyValues[2] is int ? objs[(int)MyValues[2]] : MyValues[2];

                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr = (Delegate)compileExpression.Invoke(null, new object[] { "$0" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload["0"] = literal;

                        AssertEquals(expr.DynamicInvoke(pr, prc), value, "expr($0)", literal);
                    }

                    [TestCase]
                    public void SimpleDefaultValue()
                    {
                        Delegate expr;
                        string literal;
                        object value;
                        Type target;

                        target = Type.GetType((string)MyValues[0]);
                        literal = (string)MyValues[1];
                        value = target.IsValueType ?
                            Activator.CreateInstance(target) :
                            null;

                        MethodInfo compileExpression = typeof(VeiTestBaseGroup).GetMethod("CompileExpression");

                        compileExpression = compileExpression.MakeGenericMethod(target);

                        expr = (Delegate)compileExpression.Invoke(null, new object[] { "$0" });

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        AssertEquals(expr.DynamicInvoke(pr, prc), value, "expr($0)", literal);
                    }
                }

                #endregion

                #region Set Join Expression Generation

                [TestGroup, DVT]
                public class SetJoinExpressionGeneraion : VeiTestBaseGroup
                {
                    [TestCase]
                    public void UniversalSetJoin()
                    {
                        Delegate expr = DynCompileExpression("$(*:|)", typeof(string));

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload.Clear();

                        payload["0"] = 0;
                        payload["1"] = 1;
                        payload["3"] = 3;
                        payload["Alpha"] = "Alpha";
                        payload["v1"] = "v1";
                        payload["v3"] = "v3";
                        payload["null"] = null;

                        AssertEquals(expr.DynamicInvoke(pr, prc), "Alpha||v1|v3|0|1||3", "expr($(*:|))");
                    }

                    [TestCase]
                    public void OrdinalSetJoin()
                    {
                        Delegate expr = DynCompileExpression("$(0-4:|)", typeof(string));

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload.Clear();

                        payload["0"] = 0;
                        payload["1"] = 1;
                        payload["3"] = 3;
                        payload["Alpha"] = "Alpha";
                        payload["v1"] = "v1";
                        payload["v3"] = "v3";
                        payload["null"] = null;

                        AssertEquals(expr.DynamicInvoke(pr, prc), "0|1||3|", "expr($(0-4:|))");
                    }

                    [TestCase]
                    public void NamedSetJoin()
                    {
                        Delegate expr = DynCompileExpression("$(v[1-4]:|)", typeof(string));

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload.Clear();

                        payload["0"] = 0;
                        payload["1"] = 1;
                        payload["3"] = 3;
                        payload["Alpha"] = "Alpha";
                        payload["v1"] = "v1";
                        payload["v3"] = "v3";
                        payload["null"] = null;

                        AssertEquals(expr.DynamicInvoke(pr, prc), "v1||v3|", "expr($(0-4:|))");
                    }
                }

                #endregion

                #region String Conversion in Expressions

                [TestGroup, DVT]
                [CompoundCase("SByte", "System.SByte", "-127", (SByte)(-127))]
                [CompoundCase("Int16", "System.Int16", "-32767", (Int16)(-32767))]
                [CompoundCase("Int32", "System.Int32", "-2147483647", (Int32)(-2147483647))]
                [CompoundCase("Int64", "System.Int64", "-9223372036854775807", (Int64)(-9223372036854775808))]
                [CompoundCase("Byte", "System.Byte", "255", (Byte)(255))]
                [CompoundCase("UInt16", "System.UInt16", "65535", (UInt16)(65535))]
                [CompoundCase("UInt32", "System.UInt32", "4294967295", (UInt32)(4294967295))]
                [CompoundCase("UInt64", "System.UInt64", "18446744073709551615", (UInt64)(18446744073709551615))]
                [CompoundCase("Float", "System.Single", "1.618034", 1.618034f)]
                [CompoundCase("Double", "System.Double", "2.71828182845904", 2.71828182845904d)]
                [CompoundCase("Decimal", "System.Decimal", "3.1415926535897932384626433832795028", 0)]
                [CompoundCase("Bool", "System.Boolean", "True", true)]
                [CompoundCase("DateTime", "System.DateTime", "10/01/1983 23:59", 1)]
                [CompoundCase("TimeSpan", "System.TimeSpan", "1:15:30.50", 2)]
                [CompoundCase("Guid", "System.Guid", "08496d63-cac5-4d57-af95-d61fdf0952f0", 3)]
                [CompoundCase("Char", "System.Char", "J", 'J')]
                [CompoundCase("String", "System.String", "The CAKE is not a lie", "The CAKE is not a lie")]
                public class StringConversionInExpressions : VeiTestBaseGroup
                {
                    static object[] objs = new object[] 
            {
                3.1415926535897932384626433832795028m,
                DateTime.Parse("10/01/1983 23:59"),
                TimeSpan.Parse("1:15:30.50"),
                new Guid("08496d63-cac5-4d57-af95-d61fdf0952f0")
            };

                    [TestCase]
                    public void SimpleCast()
                    {
                        Delegate expr = DynCompileExpression("$0", typeof(string));
                        string literal;
                        object value;

                        literal = (string)MyValues[1];
                        value = MyValues[2];

                        if (value is int)
                        {
                            int v = (int)value;
                            if (v >= 0 && v < objs.Length)
                            {
                                value = objs[v];
                            }
                        }

                        var payload = GenerateTestPayload();
                        var pr = new TestPayloadReader();
                        var prc = pr.CreateContext(payload);

                        payload["0"] = value;

                        AssertEquals(expr.DynamicInvoke(pr, prc), value.ToString(), "expr($0)");
                    }
                }

                #endregion
            }

            #endregion
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\StringSvrBackCompat.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.StringServer;

using xonline.common.config;
using System.Text.RegularExpressions;
using ServerTestFramework.LiveService.Vortex;

[assembly: RootNode(typeof(StringServTest.StringServTest))]

namespace StringServTest
{
    // Xbox Live DistMon Constants
    public class XboxLiveDistMonConstants
    {
        public const int NumSiteIds = 25;
        public const int TestCDNTimeLowerBound = 5;
        public const int TestCDNTimeUpperBound = 1000;
        public const int TestCDNTimeThreshold = 800;
        public const int TestSigninTimeLowerBound = 100;
        public const int TestSigninTimeUpperBound = 4200;
        public const int TestSigninTimeThreshold = 3600;
        public const String ExampleTimestamp = "0100";
        public const String ExampleHresult = "80155110";
        
        /// <summary>
        /// This constant represents the buffer size, in bytes, used on the Xbox 360 client for distributed monitoring.
        /// </summary>
        public const int ConsoleBufferSize = 400;

        // Category names used specifically for distributed monitoring

        public const string VortexFailureCounterCategoryName = "XBL Vortex FD - Failure Monitoring";
        public const string VortexMeasurementCounterCategoryName = "XBL Vortex FD - Measurement Threshold Monitoring";

    };

    /// <summary>
    /// Client-side test of String Server front door service
    /// </summary>
    public class StringServTest : ServerTestFramework.TestNode
    {
        // these constants are determined by ops/sitecfg/xrlscan.mess
        // which limits the number of bytes XRLScan will allow in URL payloads
        const uint MAXNUMTITLES = 1027;
        const uint MAXNUMSTRINGS = 7;

        const uint MAXSTRINGLENID = 9994;

        // determined by  max size of string in DB  (update: now set in ini file)
        const uint MAXSTRINGLEN = 512;
        const uint MAXVETLEN = 512;
        const int XMGMTTIMETOWAIT = 20 * 60 * 1000; // 20 minutes

        public StringServTest()
        {
            //functional tests
            foreach (TestNode n in GetTests())
            {
                AddChild(n);
            }

            //stress tests
            foreach (System.Type t in GetStressTests())
            {
                TestNode n=TestNode.ConstructFromType(t);
                n.Name="StringServTest "+n.Name;
                AddChild(n, false, true);
            }
        }

        // See Xbox 360 Console Software #32453. Xmgmt commands take a really long time
        // due to poor npdb performance. To get good results we increase the timeout values.
        public static void ExecuteXmgmtCommand(string InterfaceName, string Command)
        {
            int sendTimeout = ManagementConsole.sendTimeout = XMGMTTIMETOWAIT;
            int receiveTimeout = ManagementConsole.receiveTimeout = XMGMTTIMETOWAIT;

            Global.XEnv.ExecuteXmgmtCommand(InterfaceName, Command);

            ManagementConsole.sendTimeout = sendTimeout;
            ManagementConsole.receiveTimeout = receiveTimeout;
        }

        public static void ExecuteXmgmtCommandOneServer(string serverName, string Command)
        {
            int sendTimeout = ManagementConsole.sendTimeout = XMGMTTIMETOWAIT;
            int receiveTimeout = ManagementConsole.receiveTimeout = XMGMTTIMETOWAIT;

            Global.XEnv.ExecuteXmgmtCommandOneServer(serverName, Command);

            ManagementConsole.sendTimeout = sendTimeout;
            ManagementConsole.receiveTimeout = receiveTimeout;
        }
        private static string NpdbConnectionString
        {
            get
            {
                return "Data Source=" + Config.NpdbServer + ";Initial Catalog=" + Config.NpdbDatabase + ";Integrated Security=SSPI;Application Name=StringServTest;Pooling=false";
            }
        }


        public System.Collections.Generic.List<System.Type> GetStressTests()
        {
            System.Collections.Generic.List<System.Type> Tests = new System.Collections.Generic.List<System.Type>();
        

            return Tests;
        }

        public System.Collections.Generic.List<TestNode> GetTests()
        {
            System.Collections.Generic.List<TestNode> tl=new System.Collections.Generic.List<TestNode>();

            tl.Add(new LogStringBackCompat());

            return tl;
        }


        




        

        [Owner("ilatham"), TestFrequency("Daily"), EnvRequirement(""), TestCasePriority(2)]
        [CompoundCase("LogString.ashx", false)]
        public class LogStringBackCompat : TestNode
        {
            public static string _logRoot = "E$\\logroot";
            public static string _stringServer = "xepooliis009";
            public static string _fu = "FU|FFFF0004|0|90000000002A4|1C6BFEA53A160FD";
            public static string _ban_vw = "BAN_VW|F213421180449836|9000000146A29|1C6BFEDF3B05EF0|0";
            public static string _ban_cl = "BAN_CL|901B921B594DF660|9000000146A29|1C6BFEDFA598A60|2";
            public static string _mp_p = "MP_P|901B921B594DF660|FFFE07D18000001B|9000000146A29|1C6BFEDFA598A60";
            public static bool useBinary;

            [TestGroupSetup]
            public void Setup()
            {
            }
            [TestGroupTearDown]
            public void Shutdown()
            {
            }

            public override void PreRun()
            {
                useBinary = (bool)MyValues[0];

                // the setup_logroot from npdb
                _logRoot = Global.XEnv.GetSetting("setup_logroot");

                string[] stringSvrs = Global.XEnv.GetServerListByInterface(Interface.vortexfd);
                _stringServer = stringSvrs[0];

                // create the new target, and add it to vortexfd
                // the problem here is the same stringSvr name is used on all servers
                StringServTest.ExecuteXmgmtCommand(Interface.vortexfd, "e :vortexfd newtarget reportlog Type=File;Prefix=" + _logRoot + "\\app\\vortexfd\\report\\" + _stringServer + ".vortexfd.;rotationtime=120;rotationsize=1000000000");
                StringServTest.ExecuteXmgmtCommand(Interface.vortexfd, "e :vortexfd addtarget reportlog vortexoutput");
            }

            public LogStringBackCompat()
            {
                AddChild(new P_LogImmediateString());
                AddChild(new P_LogMultipleStrings());
                AddChild(new P_LogMultipleStrings_Mixed());

                AddChild(new P_NpdbSettings());
                AddChild(new P_Xmgmt_FlushCache());

                AddChild(new P_LogLine_VeryLong());
                AddChild(new P_LargeNumberOfLogLines());

                AddChild(new P_LogMultipleStrings_Duplicate());
                AddChild(new P_NoPipeInLogLine());
                AddChild(new P_TwoCarriageReturns());
                //AddChild(new P_NullCharacter());
                AddChild(new P_LogLine_Empty());


                // Multisetting Syntax Test Cases
                AddChild(new P_EmptySettingValue());
                AddChild(new P_SingleMeasurementSettingValue());
                AddChild(new P_SingleAPIFailureSettingValue());
                AddChild(new P_DuplicateSettingValues());
                AddChild(new P_MixedSettingValues());

                // Behavior Test Cases
                AddChild(new P_ValidFailLogString());
                AddChild(new P_ValidMeasurementLogString());
                AddChild(new N_InvalidSettingString());
                AddChild(new P_ValidLogString2());
                AddChild(new P_MultipleValidLogStrings());
                AddChild(new P_MultipleValidLogStrings2());
                AddChild(new P_ForeignLogString());

                // Performance Counter Test Cases
                AddChild(new P_PerformanceCounterIncrease());
                AddChild(new P_PerformanceCounterDecrease());

                // Threshold Test Cases
                AddChild(new N_PrefixOnlyMeasurement());
                AddChild(new N_FailureCountWithThreshold());
                AddChild(new P_MeasurementsBelowThreshold());
                AddChild(new P_MeasurementsAboveThreshold());
                AddChild(new P_MeasurementsMoreThanThreeFields());
            }

            #region Multisetting Test Cases

            /// <summary>
            /// Multisetting Test Class
            /// </summary>
            public class MultisettingTests : BaseTests
            {
                // Member Variables
                SqlConnection cxn = null;
                System.Collections.Generic.List<String> multisettingBackup = new System.Collections.Generic.List<String>();

                protected virtual void Process()
                {
                    // Do Nothing in base case
                }

                protected override void Execute()
                {
                    cxn = new SqlConnection(NpdbConnectionString);
                    try
                    {
                        // Backup current settings
                        cxn.Open();
                        BackupMultisettings();
                        cxn.Close();

                        // Execute Test
                        Process();
                    }
                    finally
                    {
                        // Restore backed up settings
                        // if an exception occured before the close in the above try loop completed, then we'd double crash here without this if check
                        if(cxn.State == System.Data.ConnectionState.Closed)
                            cxn.Open();
                        RestoreMultisettings();
                        cxn.Close();

                        // clear the settings
                        StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    }
                }

                /// <summary>
                /// Backs up existing multisettings on NPDB
                /// </summary>
                /// <param name="cxn">Open Sql Connection Object</param>
                private void BackupMultisettings()
                {
                    // Clear the current backup list
                    multisettingBackup.Clear();

                    // Backup the current stringsvr_logStringPrefix multisettings
                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = "SELECT vc_value FROM t_multisetting_overrides WHERE vc_multisetting = 'stringsvr_logStringPrefix'";
                    SqlDataReader sqlDataReader = sqlCommand.ExecuteReader();

                    while (sqlDataReader.Read())
                    {
                        multisettingBackup.Add(sqlDataReader.GetString(0));
                    }

                    sqlDataReader.Close();

                    // Delete the current stringsvr_logStringPrefix multisettings
                    sqlCommand.CommandText = "DELETE FROM t_multisetting_overrides WHERE vc_multisetting = 'stringsvr_logStringPrefix'";
                    sqlCommand.ExecuteNonQuery();
                }

                /// <summary>
                /// Restores backed-up multisettings to NPDB
                /// </summary>
                /// <param name="cxn">Open Sql Connection Object</param>
                private void RestoreMultisettings()
                {
                    // restore the database to the state it was in when we started
                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = "DELETE FROM t_multisetting_overrides WHERE vc_multisetting = 'stringsvr_logStringPrefix'";
                    sqlCommand.ExecuteNonQuery();

                    foreach (String s in multisettingBackup)
                    {
                        sqlCommand.CommandText = "INSERT INTO t_multisetting_overrides (vc_environment, vc_component, i_site_id, vc_server, vc_multisetting, vc_value) VALUES ('" + xonline.common.config.Config.Environment + "', 'ALL', -1, 'ALL', 'stringsvr_logStringPrefix', '" + s + "')";
                        sqlCommand.ExecuteNonQuery();
                    }
                }

                /// <summary>
                /// Adds a multsetting value on NPDB
                /// </summary>
                /// <param name="cxn">Open Sql Connection Object</param>
                /// <param name="value">Multisetting Value to Add</param>
                protected void AddMultisettingValue(params String[] args)
                {
                    cxn.Open();
                    SqlCommand sqlCommand = cxn.CreateCommand();
                    foreach (String value in args)
                    {
                        sqlCommand.CommandText = "INSERT INTO t_multisetting_overrides (vc_environment, vc_component, i_site_id, vc_server, vc_multisetting, vc_value) VALUES ('" + xonline.common.config.Config.Environment + "', 'ALL', -1, 'ALL', 'stringsvr_logStringPrefix', '" + value + "')";
                        sqlCommand.ExecuteNonQuery();
                    }
                    cxn.Close();
                }

                /// <summary>
                /// Invokes Health URL to force-create performance counters
                /// </summary>
                protected void CallHealthURL()
                {
                    // Invoke Health Check URL
                    // TODO: get the healthcheck URL properly from p_config_get_server_healthchecks
                    StringBuilder sbURL = new StringBuilder();
                    Global.RO.Info("Calling HealthURL http://" + _stringServer + ":11000/vortexfd/health.ashx?op=status");
                    sbURL.Append("http://");
                    sbURL.Append(_stringServer + ":11000/vortexfd/health.ashx?op=status");

                    HttpWebRequest httpReq = (HttpWebRequest)WebRequest.Create(sbURL.ToString());
                    HttpWebResponse httpResp = null;
                    httpReq.ProtocolVersion = HttpVersion.Version11;
                    httpReq.Method = "GET";
                    httpReq.UserAgent = ((int)XOService.StringService).ToString("x") + "/1.0.5849";

                    httpResp = (HttpWebResponse)httpReq.GetResponse();
                }

                /// <summary>
                /// Executes a LogString request to the string server
                /// </summary>
                /// <param name="request"></param>
                /// <param name="logLine"></param>
                protected void ExecuteLogRequest(ref XRLLogStringVortex request, String logLine)
                {
                    request.logLinesLength = (ushort)logLine.Length;
                    request.logLine = logLine;
                    // Valid log
                    if (!request.Execute(Global.XEnv.GetInterface(Interface.vortexfd, _stringServer)))
                        throw new UnexpectedTestResultException("XRLLogString execute failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK)
                        throw new UnexpectedTestResultException(String.Format("XRLLogString execute returned XErr=0x{0:x}", request.XErr));
                }

                protected static void AssertTrue(Boolean returnValue, String errorString)
                {
                    if (!returnValue)
                    {
                        throw new UnexpectedTestResultException(errorString);
                    }
                }

                protected static void AssertInstanceExists(PerformanceCounterCategory cat, String instance, String errorString)
                {
                    if (!cat.InstanceExists(instance))
                    {
                        throw new UnexpectedTestResultException(errorString);
                    }
                }

                protected static void AssertInstanceDoesntExist(PerformanceCounterCategory cat, String instance, String errorString)
                {
                    if (cat.InstanceExists(instance))
                    {
                        throw new UnexpectedTestResultException(errorString);
                    }
                }
            }

            // -- BVT Test Cases --
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_EmptySettingValue : MultisettingTests
            {
                protected override void Process()
                {
                    PerformanceCounterCategory cat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);
                    String[] original = cat.GetInstanceNames();
                    System.Collections.Generic.List<String> originalInstances = new System.Collections.Generic.List<string>();
                    foreach (String instanceName in original)
                    {
                        originalInstances.Add(instanceName);
                    }

                    // Add Empty Setting Value
                    AddMultisettingValue("");

                    // Refresh and load up vortexfd with the new multisetting
                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");

                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    CallHealthURL();

                    // Check that no new instances are created other than _total_
                    // Enumerate the instances and check only defaults created
                    String[] newInstances = cat.GetInstanceNames();

                    for (int n = 0; n < newInstances.Length; n++)
                    {
                        if (newInstances[n] != "_total_")
                            originalInstances.Remove(newInstances[n]);
                    }

                    // Check that there is only 1 default
                    AssertTrue(originalInstances.Count == 1, "Non-default counter instance created");
                    AssertTrue(originalInstances[0] == "_total_", "Non-default counter instance created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_SingleMeasurementSettingValue : MultisettingTests
            {
                protected override void Process()
                {
                    // Add Measurement Setting Value
                    AddMultisettingValue("prefix=TestSingleMeasurement;type=measurement;threshold=4500");

                    // Refresh and load up vortexfd with the new multisetting
                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");

                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory cat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, _stringServer);

                    CallHealthURL();

                    AssertInstanceExists(cat, "TestSingleMeasurement", "No Measurement performance counter instance named TestSingleMeasurement created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_SingleAPIFailureSettingValue : MultisettingTests
            {
                protected override void Process()
                {
                    // Add API Failure Setting Value
                    AddMultisettingValue("prefix=TestSingleAPIFailure;type=failure");

                    // Refresh and load up vortexfd with the new multisetting
                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");

                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory cat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);

                    CallHealthURL();

                    AssertInstanceExists(cat, "TestSingleAPIFailure", "No API Failure performance counter instance named TestSingleAPIFailure created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            /// <summary>
            /// Duplicate Setting Values are ignored
            /// </summary>
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_DuplicateSettingValues : MultisettingTests
            {
                protected override void Process()
                {
                    // Add Several Mixed Setting Values
                    AddMultisettingValue("prefix=TestDuplicateSettingsFail;type=failure",
                                        "prefix=TestDuplicateSettingsMeasure;type=measurement;threshold=3600",
                                        "prefix=TestDuplicateSettingsFail;type=failure",
                                        "prefix=TestDuplicateSettingsMeasure;type=measurement;threshold=4200",
                                        "prefix=TestDuplicateSettingsMeasure;type=measurement;threshold=4200");

                    // Refresh and load up vortexfd with the new multisetting
                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");

                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory failureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);
                    PerformanceCounterCategory measureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, _stringServer);

                    CallHealthURL();

                    AssertInstanceExists(failureCat, "TestDuplicateSettingsFail", "No API Failure performance counter instance named TestDuplicateSettingsFail created");
                    AssertInstanceExists(measureCat, "TestDuplicateSettingsMeasure", "No Measurement performance counter instance named TestDuplicateSettingsMeasure created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_MixedSettingValues : MultisettingTests
            {
                protected override void Process()
                {
                    // Add Several Mixed Setting Values
                    AddMultisettingValue("prefix=TestMixedSettingsFail0;type=failure",
                                        "prefix=TestMixedSettingsMeasure0;type=measurement;threshold=3600",
                                        "prefix=TestMixedSettingsFail1;type=failure",
                                        "prefix=TestMixedSettingsMeasure1;type=measurement;threshold=4200",
                                        "prefix=TestMixedSettingsMeasure2;type=measurement;threshold=4200",
                                        "prefix=TestMixedSettingsFail2;type=failure");

                    // Refresh and load up vortexfd with the new multisetting
                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");

                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory failureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);
                    PerformanceCounterCategory measureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, _stringServer);

                    CallHealthURL();

                    for (int n = 0; n < 3; n++)
                    {
                        AssertInstanceExists(failureCat, "TestMixedSettingsFail" + n.ToString(), "No API Failure performance counter instance named TestMixedSettingsFail" + n.ToString() + " created");
                        AssertInstanceExists(measureCat, "TestMixedSettingsMeasure" + n.ToString(), "No Measurement performance counter instance named TestMixedSettingsMeasure" + n.ToString() + " created");
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            // -- Functional Test Cases are covered by Behavior --

            #endregion

            #region DistMon Behavior Tests

            // -- BVT Tests --
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_ValidFailLogString : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestValid_APIFail_S01 Setting Value
                    AddMultisettingValue("prefix=TestValid_APIFail_S01;type=failure");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    ExecuteLogRequest(ref request, "TestValid_APIFail_S01|" + _stringServer + "|" + XboxLiveDistMonConstants.ExampleHresult + "|" + XboxLiveDistMonConstants.ExampleTimestamp);

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory failureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);

                    CallHealthURL();

                    AssertInstanceExists(failureCat, "TestValid_APIFail_S01", "No API Failure performance counter instance named TestValid_APIFail_S01 created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_ValidMeasurementLogString : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestValid_CDNTime Setting Value
                    AddMultisettingValue("prefix=TestValid_CDNTime;type=measurement;threshold=4500");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    ExecuteLogRequest(ref request, "TestValid_CDNTime|500|" + XboxLiveDistMonConstants.ExampleTimestamp);

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory measureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, _stringServer);

                    CallHealthURL();

                    AssertInstanceExists(measureCat, "TestValid_CDNTime", "No Measurement performance counter instance named TestValid_CDNTime created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class N_InvalidSettingString : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestInvalidSetting_APIFail_S01 Setting Value
                    AddMultisettingValue("prefix=TestInvalidSetting_APIFail_S01");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    ExecuteLogRequest(ref request, "TestInvalidSetting_APIFail_S01|" + _stringServer + "|" + XboxLiveDistMonConstants.ExampleHresult + "|" + XboxLiveDistMonConstants.ExampleTimestamp);

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory failureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);

                    CallHealthURL();

                    AssertInstanceDoesntExist(failureCat, "TestInvalidSetting_APIFail_S01", "API Failure performance counter instance named TestInvalidSetting_APIFail_S01 should not have been created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            /// <summary>
            /// Tests incomplete logStrings which should still parse and create counters
            /// </summary>
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_ValidLogString2 : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestValidLog2_APIFail_S01 Setting Value
                    AddMultisettingValue("prefix=TestValidLog2_APIFail_S01;type=failure");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    ExecuteLogRequest(ref request, "TestValidLog2_APIFail_S01|");

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory failureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);

                    CallHealthURL();

                    AssertInstanceExists(failureCat, "TestValidLog2_APIFail_S01", "No API Failure performance counter instance named TestValidLog2_APIFail_S01 created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_MultipleValidLogStrings : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestValid_APIFail_S01 Setting Value
                    AddMultisettingValue("prefix=TestMultipleValid_APIFail_S01;type=failure",
                                        "prefix=TestMultipleValid_APIFail_S02;type=failure",
                                        "prefix=TestMultipleValid_CDNTime;type=measurement;threshold=4500",
                                        "prefix=TestMultipleValid_SigninTime;type=measurement;threshold=3600");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    int n = 0;
                    // TestMultipleValid_APIFail_S01 x 5
                    for (n = 0; n < 5; n++)
                    {
                        ExecuteLogRequest(ref request, "TestMultipleValid_APIFail_S01|" + _stringServer + "|" + XboxLiveDistMonConstants.ExampleHresult + "|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    // TestMultipleValid_APIFail_S02 x 10
                    for (n = 0; n < 10; n++)
                    {
                        ExecuteLogRequest(ref request, "TestMultipleValid_APIFail_S02|" + _stringServer + "|" + XboxLiveDistMonConstants.ExampleHresult + "|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    // TestMultipleValid_CDNTime x 5
                    for (n = 0; n < 5; n++)
                    {
                        ExecuteLogRequest(ref request, "TestMultipleValid_CDNTime|500|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    // TestMultipleValid_SigninTime x 10
                    for (n = 0; n < 10; n++)
                    {
                        ExecuteLogRequest(ref request, "TestMultipleValid_SigninTime|4500|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory failureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);
                    PerformanceCounterCategory measureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, _stringServer);

                    CallHealthURL();

                    // Check for instance existence
                    AssertInstanceExists(failureCat, "TestMultipleValid_APIFail_S01", "No API Failure performance counter instance named TestMultipleValid_APIFail_S01 created");
                    AssertInstanceExists(failureCat, "TestMultipleValid_APIFail_S02", "No API Failure performance counter instance named TestMultipleValid_APIFail_S02 created");
                    AssertInstanceExists(measureCat, "TestMultipleValid_CDNTime", "No Measurement performance counter instance named TestMultipleValid_CDNTime created");
                    AssertInstanceExists(measureCat, "TestMultipleValid_SigninTime", "No Measurement performance counter instance named TestMultipleValid_SigninTime created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            /// <summary>
            /// Incomplete/Invalid LogStrings should still parse and create counters
            /// </summary>
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_MultipleValidLogStrings2 : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestValid_APIFail_S01 Setting Value
                    AddMultisettingValue("prefix=TestMultipleInvalid_APIFail_S02;type=failure",
                                        "prefix=TestMultipleInvalid_CDNTime;type=measurement;threshold=4500");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    // - These create perf counters -
                    ExecuteLogRequest(ref request, "TestMultipleInvalid_APIFail_S02");
                    ExecuteLogRequest(ref request, "TestMultipleInvalid_APIFail_S0");
                    ExecuteLogRequest(ref request, "TestMultipleInvalid_APIFail_S02|||");
                    ExecuteLogRequest(ref request, "TestMultipleInvalid_APIFail_S02||servername|valuehere");
                    ExecuteLogRequest(ref request, "TestMultipleInvalid_CDNTim|500");
                    ExecuteLogRequest(ref request, "TestMultipleInvalid_CDNTime||" + XboxLiveDistMonConstants.ExampleTimestamp + "|");
                    ExecuteLogRequest(ref request, "TestMultipleInvalid_CDNTime|||");
                    ExecuteLogRequest(ref request, "TestMultipleInvalid_CDNTime|timestamp|valuehere");
                    ExecuteLogRequest(ref request, "TestMultipleInvalid_CDNTime|timestampservername|valuehere");

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory failureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);
                    PerformanceCounterCategory measureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, _stringServer);

                    CallHealthURL();

                    // Prefixes not registered in Multisetting should not be there
                    AssertInstanceDoesntExist(failureCat, "TestMultipleInvalid_APIFail_S0", "API Failure performance counter instance named TestMultipleInvalid_APIFail_S0 should not have been created");
                    AssertInstanceDoesntExist(measureCat, "TestMultipleInvalid_CDNTim", "Measurement performance counter instance named TestMultipleInvalid_CDNTim should not have been created");

                    // Prefixes registered in Multisetting should be there
                    AssertInstanceExists(failureCat, "TestMultipleInvalid_APIFail_S02", "No API Failure performance counter instance named TestMultipleInvalid_APIFail_S02 created");
                    AssertInstanceExists(measureCat, "TestMultipleInvalid_CDNTime", "No Measurement performance counter instance named TestMultipleInvalid_CDNTime created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            // -- Functional Tests --

            /// <summary>
            /// Unicode characters should not stop logString parsing in DistMon
            /// </summary>
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_ForeignLogString : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestValid_APIFail_S01 Setting Value
                    AddMultisettingValue("prefix=TestForeignString;type=failure");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    ExecuteLogRequest(ref request, "TestForeignString|u" + _stringServer + "|" + XboxLiveDistMonConstants.ExampleHresult);

                    // Check that just default perf-counter instances are created and health check passes
                    PerformanceCounterCategory failureCat = new PerformanceCounterCategory(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, _stringServer);

                    CallHealthURL();

                    AssertInstanceExists(failureCat, "TestForeignString", "No API Failure performance counter instance named TestForeignString created");

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            // -- Performance Counter Tests --
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_PerformanceCounterIncrease : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();
                    string prefixName = "AVortexTestPerfCounterIncrease";

                    // Add TestValid_APIFail_S01 Setting Value
                    AddMultisettingValue("prefix=" + prefixName + ";type=failure");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    CallHealthURL();
                    
                    // Send a couple requests to make sure our perf counter category gets created
                    DateTime start = System.DateTime.Now;
                    int n = 0;
                    int requestsLogged = 0;
                    for (n = 0; n < 5; n++)
                    {
                        ExecuteLogRequest(ref request, prefixName + "|" + _stringServer + "|" + XboxLiveDistMonConstants.ExampleHresult + "|" + XboxLiveDistMonConstants.ExampleTimestamp);
                        requestsLogged++;
                    }
                    Global.RO.Info(String.Format("logged {0} requests over {1} seconds", requestsLogged, System.DateTime.Now.Subtract(start).TotalSeconds));


                    // Record First Counter Value
                    float firstCounterValue = 0;

                    // Check for counter value
                    PerformanceCounter firstCounter = new PerformanceCounter(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, "Failures Seen Rate", prefixName, _stringServer);
                    firstCounterValue = firstCounter.NextValue();

                    // Send 200 requests
                    start = System.DateTime.Now;
                    requestsLogged = 0;
                    for (n = 0; n < 200; n++)
                    {
                        ExecuteLogRequest(ref request, prefixName + "|" + _stringServer + "|" + XboxLiveDistMonConstants.ExampleHresult + "|" + XboxLiveDistMonConstants.ExampleTimestamp);
                        requestsLogged++;
                    }
                    Global.RO.Info(String.Format("logged {0} requests over {1} seconds", requestsLogged, System.DateTime.Now.Subtract(start).TotalSeconds));


                    // Record Second Counter Value
                    float secondCounterValue = 0;

                    start = System.DateTime.Now;
                    // Check for counter value
                    //PerformanceCounter secondCounter = new PerformanceCounter(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, "Failures Seen Rate", prefixName, _stringServer);
                    while ((secondCounterValue <= firstCounterValue) && (System.DateTime.Now.Subtract(start).TotalSeconds < 10) )
                    {
                        secondCounterValue = firstCounter.NextValue();
                        System.Threading.Thread.Sleep(1000 * 1);
                    }

                    AssertTrue(secondCounterValue > firstCounterValue, String.Format("Counter Rate did not increase: {0} to {1}", firstCounterValue, secondCounterValue));
                    Global.RO.Info(String.Format("Counter Rate went from {0} to {1} over {2} seconds", firstCounterValue, secondCounterValue, System.DateTime.Now.Subtract(start).TotalSeconds));

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_PerformanceCounterDecrease : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestValid_APIFail_S01 Setting Value
                    AddMultisettingValue("prefix=TestPerfCounterDecrease;type=failure");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    CallHealthURL();

                    int n = 0;
                    // Send 200 requests
                    for (n = 0; n < 200; n++)
                    {
                        ExecuteLogRequest(ref request, "TestPerfCounterDecrease|" + _stringServer + "|" + XboxLiveDistMonConstants.ExampleHresult + "|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    // Record First Counter Value
                    float firstCounterValue = 0;

                    // Check for counter value
                    PerformanceCounter firstCounter = new PerformanceCounter(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, "Failures Seen Rate", "TestPerfCounterDecrease", _stringServer);
                    firstCounterValue = firstCounter.NextValue();

                    // Send 100 requests
                    for (n = 0; n < 100; n++)
                    {
                        ExecuteLogRequest(ref request, "TestPerfCounterDecrease|" + _stringServer + "|" + XboxLiveDistMonConstants.ExampleHresult + "|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    // Record Second Counter Value
                    float secondCounterValue = 0;

                    // Check for counter value
                    PerformanceCounter secondCounter = new PerformanceCounter(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, "Failures Seen Rate", "TestPerfCounterDecrease", _stringServer);
                    secondCounterValue = secondCounter.NextValue();

                    AssertTrue(firstCounterValue >= secondCounterValue, String.Format("Counter Rate did not decrease: {0} to {1}", firstCounterValue, secondCounterValue));

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            // -- Threshold Tests --
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class N_PrefixOnlyMeasurement : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestPrefixOnlyMeasurement Setting Value
                    AddMultisettingValue("prefix=TestPrefixOnlyMeasurement;type=measurement;threshold=3600");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    CallHealthURL();

                    int n = 0;
                    // Send 100 requests
                    for (n = 0; n < 100; n++)
                    {
                        ExecuteLogRequest(ref request, "TestPrefixOnlyMeasurement");
                    }

                    // Check for counter value
                    PerformanceCounter counter = new PerformanceCounter(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, "Measurement Thresholds Exceeded Rate", "TestPrefixOnlyMeasurement", _stringServer);
                    float counterValue = counter.NextValue();

                    AssertTrue(counterValue < 10.0f, String.Format("Counter Rate increased when it shouldn't have: {0}", counterValue));

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class N_FailureCountWithThreshold : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestFailureThreshold Setting Value
                    AddMultisettingValue("prefix=TestFailureThreshold;type=failure;threshold=4200");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    CallHealthURL();

                    int n = 0;
                    // Check for counter value
                    // NOTE: A before & after of RawValue was taken instead of NextValue() as 
                    //      NextValue kept returning '0' instead of the calculated Rate
                    PerformanceCounter counter = new PerformanceCounter(XboxLiveDistMonConstants.VortexFailureCounterCategoryName, "Failures Seen Rate", "TestFailureThreshold", _stringServer);
                    long counterValue1 = counter.RawValue;

                    // Send 200 requests
                    for (n = 0; n < 200; n++)
                    {
                        // Threshold value is below Multisetting
                        ExecuteLogRequest(ref request, "TestFailureThreshold|200|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    long counterValue2 = counter.RawValue;

                    AssertTrue(counterValue1 < counterValue2, String.Format("Counter Rate did not respond to failure logs: Before Logs {0}, After Logs {1}", counterValue1, counterValue2));

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_MeasurementsBelowThreshold : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestFailureThreshold Setting Value
                    // threshold here is in decimal
                    AddMultisettingValue("prefix=TestMeasurementsBelowThreshold;type=measurement;threshold=3600");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    CallHealthURL();

                    int n = 0;
                    // Check for counter value
                    PerformanceCounter counter = new PerformanceCounter(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, "Measurement Thresholds Exceeded Rate", "TestMeasurementsBelowThreshold", _stringServer);
                    long counterValue1 = counter.RawValue;

                    // Send 100 requests. These requests should all be ignored, making the RawValue the same
                    for (n = 0; n < 100; n++)
                    {
                        // threshold here is in hex
                        ExecuteLogRequest(ref request, "TestMeasurementsBelowThreshold|30|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    long counterValue2 = counter.RawValue;

                    AssertTrue(counterValue1 == counterValue2, String.Format("Counter Rate accepted logs below threshold: Before Logs {0}, After Logs {1}", counterValue1, counterValue2));

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_MeasurementsAboveThreshold : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestFailureThreshold Setting Value
                    // threshold here is in decimal
                    AddMultisettingValue("prefix=TestMeasurementsAboveThreshold;type=measurement;threshold=3600");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    CallHealthURL();

                    int n = 0;
                    // Check for counter value
                    PerformanceCounter counter = new PerformanceCounter(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, "Measurement Thresholds Exceeded Rate", "TestMeasurementsAboveThreshold", _stringServer);
                    long counterValue1 = counter.RawValue;

                    // Send 100 requests. These requests should all be accepted, raising the RawValue
                    for (n = 0; n < 100; n++)
                    {
                        // threshold here is in hex
                        ExecuteLogRequest(ref request, "TestMeasurementsAboveThreshold|4000|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    long counterValue2 = counter.RawValue;

                    AssertTrue(counterValue1 < counterValue2, String.Format("Counter Rate did not accept logs above threshold: Before Logs {0}, After Logs {1}", counterValue1, counterValue2));

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_MeasurementsMoreThanThreeFields : MultisettingTests
            {
                protected override void Process()
                {
                    request = CreateXRLLogStringRequest();

                    // Add TestFailureThreshold Setting Value
                    // threshold here is in decimal
                    AddMultisettingValue("prefix=TestMeasurementsMoreThanThreeFields;type=measurement;threshold=3600");

                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    // sleep 3 second
                    System.Threading.Thread.Sleep(3000);

                    CallHealthURL();

                    int n = 0;
                    // Check for counter value
                    PerformanceCounter counter = new PerformanceCounter(XboxLiveDistMonConstants.VortexMeasurementCounterCategoryName, "Measurement Thresholds Exceeded Rate", "TestMeasurementsMoreThanThreeFields", _stringServer);
                    long counterValue1 = counter.RawValue;

                    // Send 100 requests. These requests should all be accepted, raising the RawValue
                    for (n = 0; n < 100; n++)
                    {
                        // threshold here is in hex
                        ExecuteLogRequest(ref request, "TestMeasurementsMoreThanThreeFields|4000|foo|bar|baz|wahoo|" + XboxLiveDistMonConstants.ExampleTimestamp);
                    }

                    long counterValue2 = counter.RawValue;

                    AssertTrue(counterValue1 < counterValue2, String.Format("Counter Rate did not accept logs above threshold: Before Logs {0}, After Logs {1}", counterValue1, counterValue2));

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            #endregion

            #region Test Cases
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_LogImmediateString : BaseTests
            {
                protected override void Init()
                {
                    base.Init();
                    request = CreateXRLLogStringRequest();
                    // 1 line
                    szLogLine = _fu;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_LogMultipleStrings : BaseTests
            {
                protected override void Init()
                {
                    base.Init();
                    request = CreateXRLLogStringRequest();
                    // 3 lines
                    szLogLine = _fu + "\nSTMULTI|1|2|3|4|5|6|P_LogMultipleStrings2\n" + _mp_p;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_LogMultipleStrings_Mixed : BaseTests
            {
                protected override void Init()
                {
                    base.Init();

                    request = CreateXRLLogStringRequest();
                    szLogLine = _mp_p + "\n" + _ban_cl + "\n" + _fu + "\n" + _ban_vw;
                    // CacheFlush Xmgmt command after the call
                    this.runXmgmtCacheFlush = true;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_NpdbSettings : BaseTests
            {
                protected override void Execute()
                {
                    base.Init();
                    request = CreateXRLLogStringRequest();
                    //szLogLine = "TESTAGG|1|2|3|4|TESTING|P_LogAggregatStrings_NpdbSettings00\nREPORTAGG|1|2|3|4|P_LogAggregatStrings_NpdbSettings01";
                    szLogLine = "REPORTAGG|1|2|3|4|P_LogAggregatStrings_NpdbSettings1\nTESTAGG|1|2|3|4|TESTING|P_LogAggregatStrings_NpdbSettings2\nREPORTAGG|1|2|3|4|TESTING|P_LogAggregatStrings_NpdbSettings3";
                    AddUniqueTestId(ref szLogLine);

                    try
                    {
                        // change NPDB settings
                        //Global.XEnv.OverrideSetting("ALL", "ALL", "vortexfd_flushStringsInterval", "10001", -1);
                        //Global.XEnv.OverrideSetting("ALL", "ALL", "vortexfd_reportingAggregateKeys", "REPORTAGG,TESTAGG", -1);
                        StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");

                        // sleep 3 second
                        System.Threading.Thread.Sleep(3000);

                        request.logLinesLength = (ushort)szLogLine.Length;
                        request.logLine = szLogLine;
                        // first log
                        if (!request.Execute(Global.XEnv.GetInterface(Interface.vortexfd, _stringServer)))
                            throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());
                        if (request.XErr != HResult.S_OK)
                            throw new UnexpectedTestResultException(String.Format("XRLLogString first execute returned XErr=0x{0:x}", request.XErr));

                        // second log
                        if (!request.Execute(Global.XEnv.GetInterface(Interface.vortexfd, _stringServer)))
                            throw new UnexpectedTestResultException("XRLLogString second execute failed: " + request.GetDumpString());
                        if (request.XErr != HResult.S_OK)
                            throw new UnexpectedTestResultException(String.Format("XRLLogString second execute returned XErr=0x{0:x}", request.XErr));

                        // verify the result, nothing will be sent to reporting
                        LSALines = null;    // no aggregate lines
                        //LSLines = null;
                        Global.RO.Info("First verify");
                        DoSecondRequest();
                        VerifyResponse(szLogLine + "\n" + szLogLine, ref LSLines, ref LSALines);

                        // sleep 8 second;
                        System.Threading.Thread.Sleep(8000);

                        // verify the result of aggregate log lines, counts: 2, 2, 1
                        LSALines = new ArrayList();
                        //LSALines.Add("REPORTAGG|1|2|3|4|P_LogAggregatStrings_NpdbSettings01|2");
                        //LSALines.Add("TESTAGG|1|2|3|4|TESTING|P_LogAggregatStrings_NpdbSettings00|2");
                        LSALines.Add("REPORTAGG|1|2|3|4|P_LogAggregatStrings_NpdbSettings1|2");
                        LSALines.Add("TESTAGG|1|2|3|4|TESTING|P_LogAggregatStrings_NpdbSettings2|2");
                        LSALines.Add("REPORTAGG|1|2|3|4|TESTING|P_LogAggregatStrings_NpdbSettings3|2");
                        AddUniqueTestId(LSALines);

                        LSLines = null;     // no immediate lines
                        LSALines = null;
                        Global.RO.Info("Second verify");
                        DoSecondRequest();
                        // Verify using only log lines appeared after the last VerifyResponse
                        VerifyResponseAfterLastRequest(szLogLine, ref LSLines, ref LSALines);

                        // sleep 10 second;
                        System.Threading.Thread.Sleep(10000);

                        // verify the result again, all cleared
                        LSALines = null;    // no aggregate lines
                        LSLines = null;     // no immediate lines
                        Global.RO.Info("Third verify");
                        DoSecondRequest();
                        // Verify using only log lines appeared after the last VerifyResponse
                        VerifyResponseAfterLastRequest(szLogLine, ref LSLines, ref LSALines);
                    }
                    finally
                    {
                        // clear the settings
                        //Global.XEnv.DeleteOverrideSetting("ALL", "ALL", "vortexfd_flushStringsInterval", -1);
                        //Global.XEnv.DeleteOverrideSetting("ALL", "ALL", "vortexfd_reportingAggregateKeys", -1);
                        StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_Xmgmt_FlushCache : BaseTests
            {
                protected override void Execute()
                {
                    base.Init();
                    request = CreateXRLLogStringRequest();
                    szLogLine = "REPORTAGG|1|2|3|4|P_Xmgmt_FlushCache1\nBAN_CL|1|2|3|4|TESTING|P_Xmgmt_FlushCache2\nREPORTAGG|1|2|3|4|TESTING|P_Xmgmt_FlushCache3";
                    AddUniqueTestId(ref szLogLine);

                    request.logLinesLength = (ushort)szLogLine.Length;
                    request.logLine = szLogLine;
                    // first log
                    if (!request.Execute(Global.XEnv.GetInterface(Interface.vortexfd, _stringServer)))
                        throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK)
                        throw new UnexpectedTestResultException(String.Format("XRLLogString first execute returned XErr=0x{0:x}", request.XErr));

                    // second log
                    if (!request.Execute(Global.XEnv.GetInterface(Interface.vortexfd, _stringServer)))
                        throw new UnexpectedTestResultException("XRLLogString second execute failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK)
                        throw new UnexpectedTestResultException(String.Format("XRLLogString second execute returned XErr=0x{0:x}", request.XErr));

                    // CacheFlush Xmgmt command
                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd cacheflush");

                    // verify the result, counts: 2, 2, 2
                    //LSLines = null;
                    LSALines.Add("REPORTAGG|1|2|3|4|P_Xmgmt_FlushCache1|2");
                    LSALines.Add("BAN_CL|1|2|3|4|TESTING|P_Xmgmt_FlushCache2|2");
                    LSALines.Add("REPORTAGG|1|2|3|4|TESTING|P_Xmgmt_FlushCache3|2");
                    AddUniqueTestId(LSALines);

                    DoSecondRequest();
                    LSALines = null;
                    VerifyResponse(szLogLine + "\n" + szLogLine, ref LSLines, ref LSALines);

                    // CacheFlush Xmgmt command the second time
                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd cacheflush");

                    // verify the result again, all cleared
                    LSLines = null;
                    LSALines = null;
                    DoSecondRequest();
                    // Verify using only log lines appeared after the last VerifyResponse
                    VerifyResponseAfterLastRequest(szLogLine, ref LSLines, ref LSALines);

                    ResultCode = TEST_RESULTS.PASSED;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_LogLine_VeryLong : BaseTests
            {
                protected override void Init()
                {
                    base.Init();
                    request = CreateXRLLogStringRequest();
                    szLogLine = "STIMMEDIATE|1|2|3|4|111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111P_LogLine_VeryLong";
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_LargeNumberOfLogLines : BaseTests
            {
                protected override void Init()
                {
                    base.Init();
                    request = CreateXRLLogStringRequest();
                    szLogLine = "";
                    for (int i = 1; i <= 8; i++)
                    {
                        szLogLine += "STIMMEDIATE";
                        szLogLine += "|1|2|3|4|11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111P_LogLine_VeryLong" + i + "\n";
                    }
                    LSALines = null;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_LogMultipleStrings_Duplicate : BaseTests
            {
                protected override void Init()
                {
                    base.Init();

                    request = CreateXRLLogStringRequest();
                    szLogLine = "STIMMEDIATE|1|2|3|4|P_LogMultipleStrings_Duplicate1\nREPORTAGG|1|2|3|4|TESTING|P_LogMultipleStrings_Duplicate2\n";
                    szLogLine += "REPORTAGG|1|2|3|4|TESTING|P_LogMultipleStrings_Duplicate2\nSTIMMEDIATE|1|2|3|4|P_LogMultipleStrings_Duplicate1";

                    LSALines.Add("REPORTAGG|1|2|3|4|TESTING|P_LogMultipleStrings_Duplicate2|2");
                    AddUniqueTestId(LSALines);
                    LSALines = null;
                    // CacheFlush Xmgmt command after the call

                    this.runXmgmtCacheFlush = true;
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_NoPipeInLogLine : BaseTests
            {
                protected override void Init()
                {
                    base.Init();
                    request = CreateXRLLogStringRequest();
                    szLogLine = "STIMMEDIATE";
                }
            }

            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_TwoCarriageReturns : BaseTests
            {
                protected override void Init()
                {
                    base.Init();
                    //Global.XEnv.OverrideSetting("ALL", "ALL", "vortexfd_reportingAggregateKeys", "TESTAGG,REPORTAGG", -1);
                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");

                    request = CreateXRLLogStringRequest();
                    szLogLine = "\nSTIMMEDIATE|1|2|3|4|P_TwoCarriageReturns1\n\nREPORTAGG|1|2|3|4|TESTING|P_TwoCarriageReturns2\n";

                    // CacheFlush Xmgmt command after the call
                    this.runXmgmtCacheFlush = true;
                }
            }

            // ignored for now
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_NullCharacter : BaseTests
            {
                protected override void Init()
                {
                    base.Init();
                    request = CreateXRLLogStringRequest();
                    szLogLine = "STIMMEDIATE|1|2|3|4|P_NullCharacter1\n\0TESTAGG|1|2|3|4|TESTING|P_NullCharacter2";
                }
            }

            /// <summary>
            /// Verified by the NT event log
            /// Bug 65699
            /// </summary>
            [Owner("emzephir"), TestFrequency("Daily"), EnvRequirement("")]
            public class P_LogLine_Empty : BaseTests
            {
                protected override void Init()
                {
                    base.Init();
                    request = CreateXRLLogStringRequest();
                    szLogLine = "";
                }
            }

            /////////////////////////////////////////////////////////////////
            // Negative test cases

            #endregion

            public class BaseTests : TestBase
            {
                public uint Expected_XErr = 0;   // if > 0, negative test cases and need to verify the exception thrown is correct
                public ArrayList LSLines = null;
                public ArrayList LSALines = null;

                public XRLLogStringVortex request = null;
                public string szLogLine = null;

                public bool runXmgmtCacheFlush = false;

                protected string uniqueTestId;

                // Stores the date/time of the last log line request for this test
                // This can be used to limit results to only the log lines after the last request
                protected DateTime lastRequestTime = DateTime.MinValue;

                protected string fixFileBuffer;

                protected const int ID_INDEX = 1; //Index of the id field for a given logline.

                protected virtual void Init()
                {
                    LSLines = new ArrayList();
                    LSALines = new ArrayList();

                    // "BAN_CL" and "BAN_VW" log lines are expected to be coalesced by this test.  This used to be in the database in prod as an
                    // aggregated key, but we make it explicit here to make sure that it's always present.

                    //Global.XEnv.OverrideSetting("ALL", "ALL", "vortexfd_reportingAggregateKeys", "TESTAGG,REPORTAGG,BAN_CL,BAN_VW", -1);
                    StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd configcacherefresh");

                    uniqueTestId = String.Format("{0}-{1}", this.GetType().Name, Guid.NewGuid());
                }

                /// <summary>
                /// Adds unique test id to a string
                /// </summary>
                /// <param name="logLine">Log line to add unique test id into</param>
                protected void AddUniqueTestId(ref string logLine)
                {
                    Regex regex = new Regex(@"^(?<key>.*?)\|", RegexOptions.Multiline);
                    string uniqueLogLine;

                    if (regex.IsMatch(logLine))
                    {
                        uniqueLogLine = regex.Replace(logLine, "${key}|" + uniqueTestId + "|");
                    }
                    else
                    {
                        uniqueLogLine = logLine + "-" + uniqueTestId;
                    }

                    logLine = uniqueLogLine;
                }

                protected void AddUniqueTestId(ArrayList logArray)
                {
                    for (int i = 0; i < logArray.Count; i++)
                    {
                        string logLine = (string)logArray[i];
                        AddUniqueTestId(ref logLine);
                        logArray[i] = logLine;
                    }
                }

                protected override void Execute()
                {
                    Init();

                    AddUniqueTestId(ref szLogLine);
                    request.logLinesLength = (ushort)szLogLine.Length;
                    request.logLine = szLogLine;

                    // here make the call only hitting one FD, the first one in the VIP
                    // so we can verify the report log files
                    bool ret = request.Execute(Global.XEnv.GetInterface(Interface.vortexfd, _stringServer));
                    if (Expected_XErr != 0)
                    {
                        if (ret)
                            throw new UnexpectedTestResultException("XRLLogString should have failed.");
                        if (request.XErr != Expected_XErr)
                            throw new UnexpectedTestResultException(String.Format("XRLLogString returned unexpected error XErr=0x{0:X}, expected XErr=0x{1:X}", request.XErr, Expected_XErr));
                    }
                    else
                    {
                        if (!ret)
                            throw new UnexpectedTestResultException("XRLLogString failed: " + request.GetDumpString());
                        if (request.XErr != HResult.S_OK)
                            throw new UnexpectedTestResultException(String.Format("XRLLogString returned XErr=0x{0:x}", request.XErr));

                        // CacheFlush Xmgmt command
                        if (runXmgmtCacheFlush)
                            StringServTest.ExecuteXmgmtCommandOneServer(_stringServer, "e :vortexfd cacheflush");

                        DoSecondRequest();

                        VerifyResponse(szLogLine, ref LSLines, ref LSALines);
                    }

                    ResultCode = TEST_RESULTS.PASSED;
                }

                protected void DoSecondRequest()
                {
                    System.Threading.Thread.Sleep(1500);    // give enough time to verify the results

                    // have to do second request, because the log file buffer
                    fixFileBuffer = "fixfilebuffer|simplelogline";
                    AddUniqueTestId(ref fixFileBuffer);

                    XRLLogStringVortex request = CreateXRLLogStringRequest();
                    request.logLinesLength = (ushort)fixFileBuffer.Length;
                    request.logLine = fixFileBuffer;

                    // here make the call only hitting one FD, the first one in the VIP
                    // so we can verify the report log files
                    if (!request.Execute(Global.XEnv.GetInterface(Interface.vortexfd, _stringServer)))
                        throw new UnexpectedTestResultException("XRLLogString simple logline failed: " + request.GetDumpString());
                    if (request.XErr != HResult.S_OK)
                        throw new UnexpectedTestResultException(String.Format("XRLLogString simple logline returned XErr=0x{0:x}", request.XErr));

                    System.Threading.Thread.Sleep(500);    // give enough time to verify the results
                }

                public void VerifyResponse(string szLogLine, ref ArrayList LSLines, ref ArrayList LSALines)
                {
                    VerifyResponse(szLogLine, ref LSLines, ref LSALines, DateTime.MinValue);
                }

                public void VerifyResponseAfterLastRequest(string szLogLine, ref ArrayList LSLines, ref ArrayList LSALines)
                {
                    VerifyResponse(szLogLine, ref LSLines, ref LSALines, lastRequestTime);
                }

                private void VerifyResponse(string szLogLine, ref ArrayList LSLines, ref ArrayList LSALines, DateTime startDateTime)
                {
                    ArrayList lsLines = new ArrayList();
                    ArrayList lsaLines = new ArrayList();
                    GetLogResults(out lsLines, out lsaLines, startDateTime);

                    string[] lines = szLogLine.Split(new char[] { '\n' });
                    string temp = "";
                    if (LSLines == null)
                    {
                        LSLines = new ArrayList();
                    }
                    else if (LSLines.Count == 0)
                    {
                        foreach (string logline in lines)
                        {
                            if (logline.Length <= 0)    // skip empty lines
                                continue;
                            //if (logline.IndexOf("TESTAGG") == 0 || logline.IndexOf("REPORTAGG") == 0 || logline.IndexOf("BAN_VW") == 0 || logline.IndexOf("BAN_CL") == 0)
                            //    continue;
                            else if (logline.Length > 0)
                            {
                                temp = logline.Replace('|', '|');
                                LSLines.Add(temp);
                            }
                        }
                    }

                    if (LSALines == null)
                    {
                        LSALines = new ArrayList();
                    }
                    else if (LSALines.Count == 0)
                    {
                        foreach (string logline in lines)
                        {
                            if (logline.Length <= 0)    // skip empty lines
                                continue;
                            //if (logline.IndexOf("TESTAGG") == 0 || logline.IndexOf("REPORTAGG") == 0 || logline.IndexOf("BAN_VW") == 0 || logline.IndexOf("BAN_CL") == 0)
                            //{
                            //    int index = logline.IndexOf('|');
                            //    temp = logline;
                            //    if (index >= 0)
                            //    {
                            //        temp = logline.Substring(0, index);
                            //    }
                            //    temp = temp + "|1";
                            //    LSALines.Add(temp);
                            //}
                            else
                                continue;
                        }
                    }

                    // compare
                    Global.RO.Info("CompareTwoArrayList(LSLines, lsLines)");
                    CompareTwoArrayList(LSLines, lsLines);
                    Global.RO.Info("CompareTwoArrayList(LSALines, lsaLines)");
                    CompareTwoArrayList(LSALines, lsaLines);

                    Global.RO.Info("CompareTwoArrayList(lsLines, LSLines)");
                    CompareTwoArrayList(lsLines, LSLines);
                    Global.RO.Info("CompareTwoArrayList(lsaLines, LSALines)");
                    CompareTwoArrayList(lsaLines, LSALines);
                }

                public void GetLogResults(out ArrayList lsLines, out ArrayList lsaLines)
                {
                    GetLogResults(out lsLines, out lsaLines, DateTime.MinValue);
                }

                public void GetLogResults(out ArrayList lsLines, out ArrayList lsaLines, DateTime startDateTime)
                {
                    lsLines = new ArrayList();
                    lsaLines = new ArrayList();
                    StreamReader sr = null;
                    FileInfo finfo = null;
                    DateTime newestTime = DateTime.UtcNow.AddYears(-10);
                    string newestFile = "";

                    try
                    {
                        bool fileFound = false;
                        string[] logFiles = null;

                        // replace the C: with C$ for logroot
                        _logRoot = _logRoot.Replace(':', '$');

                        string logPath = @"\\" + _stringServer + @"\" + LogStringBackCompat._logRoot + @"\app\vortexfd\report\";
                        Global.RO.Info("Checking path:" + logPath);

                        logFiles = Directory.GetFiles(logPath, @"*.vortexfd.*.log");
                        if (logFiles.Length != 0)
                        {
                            Global.RO.Info("Found " + logFiles.Length + " files on server " + _stringServer);
                            foreach (string logFile in logFiles)
                            {
                                finfo = new FileInfo(logFile);
                                // Grab all the files within 5 minutes UTC
                                if (finfo.LastWriteTimeUtc < (DateTime.Now.ToUniversalTime() - new TimeSpan(0, 0, 5, 0, 0)))
                                {
                                    Global.RO.Info("Ignoring file due to LastWriteTimeUtc being more than 5 minutes old: " + logFile);
                                    continue;
                                }
                                string localFile = @".\" + finfo.Name;
                                File.Copy(logFile, localFile, true);
                                Global.RO.Info("File has been copied over: " + logFile);

                                // get the newest time and local file
                                if (finfo.LastWriteTimeUtc > newestTime)
                                {
                                    newestTime = finfo.LastWriteTimeUtc;
                                    newestFile = localFile;
                                }
                                fileFound = true;
                            }
                        }
                        else
                        {
                            Global.RO.Info("No Files found on server: " + _stringServer);
                        }

                        if (fileFound)
                        {
                            // We found the log file. Search for the log message we're looking for				
                            sr = new StreamReader(newestFile);
                            string line = null;
                            Global.RO.Info("Verify LOG message was received. File: " + newestFile);

                            sr.Close();
                            sr = new StreamReader(newestFile);  // read again
                            while ((line = sr.ReadLine()) != null)
                            {
                                // Format of log line
                                // 2006/08/02 06:56:30.196|LS-STIMMEDIATE|1|2|3|4
                                // 2006/08/02 06:56:30.196|LSA-TESTAGG|1|2|3|4|TESTING|4

                                // If there's a start time specified, skip all entries before that time
                                if (startDateTime != DateTime.MinValue)
                                {
                                    DateTime dtMsg = DateTime.Parse(line.Substring(0, line.IndexOf('|')));
                                    if (dtMsg < startDateTime)
                                    {
                                        Global.RO.Debug("Skipping due to date check: {0}", line);
                                        continue;
                                    }
                                }

                                // Check whether the line contains the uniqueTestId, skip anything not related to this test
                                if (!line.Contains(uniqueTestId))
                                {
                                    Global.RO.Debug("Skipping due to missing uniqueTestId check: {0}", line);
                                    continue;
                                }

                                // Save the latest log time for future reference
                                DateTime lineTime = DateTime.Parse(line.Substring(0, line.IndexOf('|')));
                                if (lineTime > lastRequestTime)
                                {
                                    lastRequestTime = lineTime;
                                }

                                Global.RO.Info("LogLine:" + line);

                                for (int k = 0; k < ID_INDEX; k++) //Loop over ID_INDEX-1 times to extract the headers before the id.
                                {
                                    line = line.Substring(line.IndexOf('|') + 1);
                                }

                                if (line.IndexOf("LS-" + fixFileBuffer) == 0)
                                {
                                    Global.RO.Debug("Skipping due to being the LS-fixfilebuffer line: {0}", line);
                                    continue;
                                }
                                else if (line.IndexOf("LS-") == 0)
                                {
                                    lsLines.Add(line.Substring(3));
                                }
                                else if (line.IndexOf("LSA-") == 0)
                                {
                                    lsaLines.Add(line.Substring(4));
                                }
                                else
                                {
                                    throw new UnexpectedTestResultException("Wrong type of log line!!!");
                                }
                            }
                        }
                    }
                    finally
                    {
                        if (sr != null) sr.Close();
                        finfo = null;
                        // Delete file that was copied                
                        //File.Delete(logFile); this is causing a file in use exception
                    }
                }

                public void CompareTwoArrayList(ArrayList first, ArrayList second)
                {
                    ValueCheck.Test("ArrayList count", first.Count, second.Count);
                    for (int i = 0; i < first.Count; i++)
                    {
                        bool found = false;
                        for (int j = 0; j < second.Count; j++)
                        {
                            if ((string)first[i] == (string)second[j])
                            {
                                found = true;
                                break;
                            }
                        }
                        if (!found)
                        {
                            throw new UnexpectedTestResultException("string not found: " + (string)first[i]);
                        }
                    }
                }

                public XRLLogStringVortex CreateXRLLogStringRequest()
                {
                    if (LogStringBackCompat.useBinary)
                    {
                        XRLLogStringVortex xrl = new XRLLogBinaryVortex();
                        return xrl;
                    }
                    else
                    {
                        XRLLogStringVortex xrl = new XRLLogStringVortex();
                        return xrl;
                    }
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\etxManifest.cs ===
using System;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using System.Text;
using System.IO;
using System.Xml.Serialization;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.STFLive;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;
using System.Threading;
using System.Security.Cryptography;

using System.Data;
using System.Data.Sql;
using System.Data.SqlTypes;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.stfutil;
using xonline.common.protocol;
using xonline.common.utilities2;
using xonline.common.sql.sqlclient;

using xonline.common.core.etx;

namespace xonline.test.vortex
{
    #region Raw manifest test cases
    /// <summary>
    /// This is the basic ETX manifest test case, which splits on two paths depending on the input. 
    /// 1 XML means it's an Load XML case, 2 or more xmls means it's a merge case. 
    /// 
    /// </summary>
    public class EtxManifestXMLTestCase : SerializableTestCase
    {        
        #region Constructors and Initialization
        public EtxManifestXMLTestCase() : base()
        {            
        }

        public EtxManifestXMLTestCase(string name)
            : base(name)
        {            
        }        
        #endregion

        /// <summary>
        /// Run method of the test case. Splits up into LoadXML and MergeXML depending on the input.
        /// </summary>
        /// <returns></returns>
        public override void Run()
        {
            try
            {
                if (InputXmls.Count == 1)
                    LoadXMLTest();
                else if (InputXmls.Count > 1)
                    MergeXMLTest();
            }
            catch (Exception ex)
            {
                if (String.IsNullOrEmpty(XMLExpectedException) || !ex.Message.Contains(XMLExpectedException))
                    throw;
                else
                    Global.RO.Debug("Found expected exception");
            }
        }

        /// <summary>
        /// Takes an XML and passes it through the validatemanifest method.
        /// </summary>
        public void LoadXMLTest()
        {            
            string rawManifest = InputXmls[0];            
            ValidateManifest(rawManifest);
        }

        /// <summary>
        /// Takes a couple of XMLs, merges them A.Merge(B) then grabs the third input xml (expected output)
        /// and then calls ValidateManifest to validate that the output of the new merged object matches the
        /// expected result.
        /// </summary>
        public void MergeXMLTest()
        {
            string xmlA = InputXmls[0];
            string xmlB = InputXmls[1];
            string expectedResult = null;

            if (InputXmls.Count > 2)
                expectedResult = InputXmls[2];

            string mergedXmlFromA = EtxMergeManifests(xmlA, xmlB);

            if (String.IsNullOrEmpty(expectedResult))
                throw new Exception("Had no expected result supplied by the test case, but the case succeeded. SO FAIL!");            
            else
                ValidateManifest(expectedResult, mergedXmlFromA);            
        }        
        
        /// <summary>
        /// Core validation method. It tries to load up rawXml into memory (or goes with producedXml if it's not null.
        /// After that it normalizes the expected xml to match certain behaviors of the object model 
        /// (reordering fields for example), then runs it through a gauntlet - uses DeepEquals to ensure that
        /// the output xml of a loaded object, a self merged object, and an object merged against an empty object
        /// all match the expected value.
        /// </summary>
        /// <param name="rawXml"></param>
        /// <param name="producedXml"></param>
        public void ValidateManifest(string rawXml, string producedXml)
        {
            if (String.IsNullOrEmpty(producedXml))
                producedXml = EtxReadManifest(rawXml);
            string normalizedXml = NormalizeInputXML(rawXml);
            string selfMergedXml = EtxSelfMerge(rawXml);
            string emptyMergeXml = EtxFromEmptyMerge(rawXml);
            string tornToPiecesXml = EtxTearShUp(rawXml);

            XDocument originalDocument = XDocument.Parse(normalizedXml, LoadOptions.None);
            XDocument selfMergedDocument = new XDocument(XDocument.Parse(selfMergedXml, LoadOptions.None));
            XDocument emptyMergedDocument = new XDocument(XDocument.Parse(emptyMergeXml, LoadOptions.None));
            XDocument producedDocument = new XDocument(XDocument.Parse(producedXml, LoadOptions.None));
            XDocument tornDocument = new XDocument(XDocument.Parse(tornToPiecesXml, LoadOptions.None));
            
            if (!XDocument.DeepEquals(originalDocument.Root, producedDocument.Root))            
                throw new Exception(String.Format("The XMLs loaded and produced are not the same!\r\n\r\nXML A:\r\n{0}\r\n\r\nXML B:\r\n{1}", originalDocument.Root, producedDocument.Root));
            if (!XDocument.DeepEquals(originalDocument.Root, selfMergedDocument.Root))
                throw new Exception(String.Format("The XMLs loaded and merged are not the same!\r\n\r\nXML A:\r\n{0}\r\n\r\nXML B:\r\n{1}", originalDocument.Root, selfMergedDocument.Root));
            //if (!XDocument.DeepEquals(originalDocument.Root, emptyMergedDocument.Root))
                //throw new Exception(String.Format("The XMLs produced and imported are not the same!\r\n\r\nXML A:\r\n{0}\r\n\r\nXML B:\r\n{1}", originalDocument.Root, emptyMergedDocument.Root));
            if (!XDocument.DeepEquals(originalDocument.Root, tornDocument.Root))
                throw new Exception(String.Format("The XML that had every item serialized and deserialized individually was not the same!\r\n\r\nXML A:\r\n{0}\r\n\r\nXML B:\r\n{1}", originalDocument.Root, emptyMergedDocument.Root));

            Global.RO.Debug("You made it through the gauntlet. Congratulations. You are a great winner.");
        }
        /// <summary>
        ///  Sends null to ValidateManifest. This loads the XML up and the "expected" is this input and the comparison
        ///  is done against the output of the loaded object's serialization.
        /// </summary>
        /// <param name="rawXml"></param>
        public void ValidateManifest(string rawXml)
        {
            ValidateManifest(rawXml, null);
        }

        /// <summary>
        /// Used to transform input xml string into an output xml string produced by the EtxManifest object.
        /// </summary>
        /// <param name="rawXml"></param>
        /// <returns></returns>
        public string EtxReadManifest(string rawXml)
        {
            XmlReaderSettings settings = new XmlReaderSettings();
            if (VortexPlugin.UseSchemaValidation)            
                settings = EtxLoader.NPDB.DownloadValidationSettings();            
                
            XmlReader srcManifestReader = XmlReader.Create(new StringReader(rawXml), settings);
            XmlSerializer serializer = new XmlSerializer(typeof(EtxManifest));

            MemoryStream ms = new MemoryStream();
            EtxManifest item = new EtxManifest(srcManifestReader);
            serializer.Serialize(ms, item);
            ms.Position = 0;

            StreamReader reader = new StreamReader(ms);

            return reader.ReadToEnd();
        }
        /// <summary>
        /// Produces the output of two merged manifest objects. Creates A and B then merges them and produces the output
        /// serialization.
        /// </summary>
        /// <param name="xmlA"></param>
        /// <param name="xmlB"></param>
        /// <returns></returns>
        public string EtxMergeManifests(string xmlA, string xmlB)
        {
            XmlReader srcManifestReaderA = XmlReader.Create(new StringReader(xmlA));
            XmlReader srcManifestReaderB = XmlReader.Create(new StringReader(xmlB));

            XmlSerializer serializer = new XmlSerializer(typeof(EtxManifest));

            MemoryStream ms = new MemoryStream();
            EtxManifest itemA = new EtxManifest(srcManifestReaderA);
            EtxManifest itemB = new EtxManifest(srcManifestReaderB);

            //For now this is true, expected exception means there's probably a difference between them but this may not be the case later.
            if (!String.IsNullOrEmpty(this.XMLExpectedException))
            {
                bool hashException = true;
                if (itemA.GetHashCode() == itemB.GetHashCode())
                    throw new Exception("The two etx manifests to merge had the same hash code! No wai!");                    

                foreach (Producer p in itemA.Producers)
                {
                    Producer p2;

                    if (itemB.Producers.TryGetValue(xonline.common.core.etx.collections.ProducerCollectionKeys.Fingerprint, p.Fingerprint, out p2))
                    {
                        foreach (Event e in p.Events)
                        {
                            Event e2;
                            if (p2.Events.TryGetValue(xonline.common.core.etx.collections.EventCollectionKeys.Fingerprint, e.Fingerprint, out e2))
                            {
                                foreach (DataField df in e.DataFields)
                                {
                                    DataField df2;
                                    if (e2.DataFields.TryGetValue(xonline.common.core.etx.collections.DataFieldCollectionKeys.Ordinal, df.Ordinal, out df2))
                                    {
                                        //Check the hashcode for the datafield.
                                        if (!EqualsThroughXml(df, df2) && df.GetHashCode() == df2.GetHashCode())
                                            throw new Exception("The two datafields to merge had the same hash code! No wai!");

                                        //Check the tostring output.
                                        if (EqualsThroughXml(df, df2) && !df.ToString().Equals(df2.ToString()))
                                            throw new Exception("The tostrings of the datafields were different even though the data was the same.");                                        
                                    }
                                }

                                //Stupid edge case :( values aren't counted towards the hash code. 
                                hashException = (e2.Value != e.Value) || (e2.Deprecated != e.Deprecated);
                                //Check the hashcode for the event.
                                if (!hashException && (!EqualsThroughXml(e, e2) && e2.GetHashCode() == e.GetHashCode()))
                                    throw new Exception("The two events to merge had the same hash code! No wai!");                                
                            }
                        }
                        //Check the hashcode for the producer. Event ordinal edge case bubbles up to here.
                        if (!hashException && (!EqualsThroughXml(p, p2) && (p2.GetHashCode() == p.GetHashCode())))
                            throw new Exception("The two producers to merge had the same hash code! No wai!");
                    }
                }                
            }

            itemA.Merge(itemB);
            serializer.Serialize(ms, itemA);
            ms.Position = 0;

            StreamReader reader = new StreamReader(ms);

            return reader.ReadToEnd();

        }
        /// <summary>
        /// Returns the result of merging a manifest against itself (should be no-op)
        /// </summary>
        /// <param name="rawXml"></param>
        /// <returns></returns>
        public string EtxSelfMerge(string rawXml)
        {
            XmlReaderSettings settings = new XmlReaderSettings();
            if (VortexPlugin.UseSchemaValidation)
                settings = EtxLoader.NPDB.DownloadValidationSettings();

            XmlReader srcManifestReader = XmlReader.Create(new StringReader(rawXml), settings);            

            XmlSerializer serializer = new XmlSerializer(typeof(EtxManifest));

            MemoryStream ms = new MemoryStream();
            
            EtxManifest item = new EtxManifest(srcManifestReader);
            item.Merge(item);
            serializer.Serialize(ms, item);
            ms.Position = 0;

            StreamReader reader = new StreamReader(ms);
            return reader.ReadToEnd();
        }
        
        /// <summary>
        /// Merges an empty object with the new one to ensure an empty document can absorb a well defined object.
        /// </summary>
        /// <param name="rawXml"></param>
        /// <returns></returns>
        public string EtxFromEmptyMerge(string rawXml)
        {
            string emptyStructure = "<etxmanifest xmlns:win=\"http://manifests.microsoft.com/win/2004/08/windows/events\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"><instrumentation></instrumentation></etxmanifest>";
            XmlReader srcManifestReader = XmlReader.Create(new StringReader(rawXml));
            XmlReader emptyManifestReader = XmlReader.Create(new StringReader(emptyStructure));
            XmlSerializer serializer = new XmlSerializer(typeof(EtxManifest));

            MemoryStream ms = new MemoryStream();
            EtxManifest emptyItem = new EtxManifest(emptyManifestReader);
            EtxManifest item = new EtxManifest(srcManifestReader);
            emptyItem.Merge(item);

            serializer.Serialize(ms, emptyItem);
            ms.Position = 0;

            StreamReader reader = new StreamReader(ms);
            return reader.ReadToEnd();
        }

        /// <summary>
        /// Takes a manifest, and for each item, deserializes and serializes using both XmlReader and 
        /// XElement constructors.
        /// </summary>
        /// <param name="rawXml"></param>
        /// <returns></returns>
        public string EtxTearShUp(string rawXml)
        {            
            XmlReader srcManifestReader = XmlReader.Create(new StringReader(rawXml));            
            XmlSerializer manifestSerializer = new XmlSerializer(typeof(EtxManifest));            

            MemoryStream ms = new MemoryStream();                        
            EtxManifest item = new EtxManifest(srcManifestReader);

            List<Producer> ps = new List<Producer>(item.Producers);

            foreach (Producer p in ps)
            {                
                List<Event> es = new List<Event>(p.Events);
                foreach (Event e in es)
                {
                    List<DataField> dfs = new List<DataField>(e.DataFields);
                    foreach (DataField f in dfs)
                    {
                        e.DataFields.Remove(f);
                        e.DataFields.Add((DataField)this.SerializeAndDeserialize(f));

                        //For good measure call tostring here. Just for sanity and to check that we never cause an exception through it.
                        string fs1 = f.ToString(), fs2 = f.ToString();

                        //Why not go ahead and recalculate myself some fingerprints?
                        e.InvalidateFingerprint();

                        if (fs1 != fs2)
                            throw new Exception(String.Format("Weird error - the tostrings were different!!! 1: {0} 2: {1}", fs1, fs2));
                    }
                    p.Events.Remove(e);
                    p.Events.Add((Event)this.SerializeAndDeserialize(e));
                }
                item.Producers.Remove(p);
                item.Producers.Add((Producer)this.SerializeAndDeserialize(p));                
            }
            manifestSerializer.Serialize(ms, item);
            ms.Position = 0;

            StreamReader reader = new StreamReader(ms);
            return reader.ReadToEnd();
        }

        /// <summary>
        /// Takes a SchemaObject and deserializes and reserializes it. 
        /// There's probably a cleaner way to do this than iffing the type 
        /// but I'll revisit later.
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        public SchemaObject SerializeAndDeserialize(SchemaObject o)
        {
            MemoryStream ms = new MemoryStream();
            XmlSerializer eventSerializer = new XmlSerializer(typeof(Event));
            XmlSerializer producerSerializer = new XmlSerializer(typeof(Producer));
            XmlSerializer datafieldSerializer = new XmlSerializer(typeof(DataField));
            
            if (o is Event)
            {
                eventSerializer.Serialize(ms, o);
                ms.Position = 0;
                XDocument evtXml = XDocument.Parse((new StreamReader(ms)).ReadToEnd());
                Event tempEvent = new Event(XElement.Parse(evtXml.ToString()));
                ms.SetLength(0);
                eventSerializer.Serialize(ms, tempEvent);                
                ms.Position = 0;
                return new Event(XmlReader.Create(ms));
            }                
            else if (o is Producer)
            {
                producerSerializer.Serialize(ms, o);
                ms.Position = 0;
                XDocument pXml = XDocument.Parse((new StreamReader(ms)).ReadToEnd());
                Producer tempProducer = new Producer(XElement.Parse(pXml.ToString()));
                ms.SetLength(0);
                producerSerializer.Serialize(ms, tempProducer);                
                ms.Position = 0;
                return new Producer(XmlReader.Create(ms));
            }
            else if (o is DataField)
            {
                datafieldSerializer.Serialize(ms, o);
                ms.Position = 0;
                XDocument dfXml = XDocument.Parse((new StreamReader(ms)).ReadToEnd());
                DataField tempDf = new DataField(XElement.Parse(dfXml.ToString()));
                ms.SetLength(0);
                datafieldSerializer.Serialize(ms, tempDf);                
                ms.Position = 0;
                return new DataField(XmlReader.Create(ms));
            }
            return null;
        }

        /// <summary>
        /// Get the string xml representation.
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        public string ToXmlString(SchemaObject o)
        {
            MemoryStream ms = new MemoryStream();
            XmlSerializer eventSerializer = new XmlSerializer(typeof(Event));
            XmlSerializer producerSerializer = new XmlSerializer(typeof(Producer));
            XmlSerializer datafieldSerializer = new XmlSerializer(typeof(DataField));

            if (o is Event)
            {
                eventSerializer.Serialize(ms, o);
                ms.Position = 0;
                return (new StreamReader(ms)).ReadToEnd();                
            }
            else if (o is Producer)
            {
                producerSerializer.Serialize(ms, o);
                ms.Position = 0;
                return (new StreamReader(ms)).ReadToEnd();                
            }
            else if (o is DataField)
            {
                datafieldSerializer.Serialize(ms, o);
                ms.Position = 0;
                return (new StreamReader(ms)).ReadToEnd();                
            }
            return null;
        }

        public bool EqualsThroughXml(SchemaObject a, SchemaObject b)
        {
            return ToXmlString(a).Equals(ToXmlString(b));
        }        

        /// <summary>
        /// The serializer does a lot of small trickery to the input to make it prettier. This method morphs the input to 
        /// the expected output.
        /// </summary>
        /// <param name="rawXml"></param>
        /// <returns></returns>
        public string NormalizeInputXML(string rawXml)
        {
            XDocument testXml = XDocument.Parse(rawXml);


            //Handle null datafields. 
            var eventNodes = from e in testXml.Descendants("event")
                         where e.Elements("datafields").Count() == 0
                         select e;
            	
            foreach (XElement xEvent in eventNodes)
            {
                if (xEvent.FirstNode == null)
                    xEvent.Add(new XElement("datafields", null));
                else
                    xEvent.LastNode.AddAfterSelf(new XElement("datafields", null));
            }

            //Handle null globaleventproducers
            var instrumentationNodes = from i in testXml.Descendants("instrumentation")
                                       where i.Elements("globaleventproducers").Count() == 0
                                       select i;

            foreach (XElement xInstr in instrumentationNodes)
            {
                if (xInstr.FirstNode == null)
                    xInstr.Add(new XElement("globaleventproducers", null));
                else
                    xInstr.LastNode.AddAfterSelf(new XElement("globaleventproducers", null));
            }

            //Handle extra globaleventproducers            
            var instrNode = testXml.Descendants("instrumentation").ElementAt(0);            
            var globalProducerNodes = from e in instrNode.Elements("globaleventproducers")
                                      select e;            

            int count = globalProducerNodes.Count();
            for (int k = count - 1; k > 0; k--)            
                globalProducerNodes.ElementAt(k).Remove();

            //Handle extra datafields            
            eventNodes = from e in testXml.Descendants("event")
                                      select e;
                        
            foreach (XElement evt in eventNodes)
            {
                var datafieldsNodes = evt.Elements("datafields");
                int datafieldCount = datafieldsNodes.Count();
                for (int k = datafieldCount - 1; k > 0; k--)
                    datafieldsNodes.ElementAt(k).Remove();
            }            

            //Reorder data attributes and add outTypes
            var dataNodes = from data in testXml.Descendants("data")
                            select data;

            foreach (XElement element in dataNodes)
            {
                string inType = element.Attribute("inType").Value;                
                string autoValue = GetAttributeHelper(element, "autovalue");
                if (!String.IsNullOrEmpty(inType))
                {
                    DataFieldType t = (DataFieldType)Enum.Parse(typeof(DataFieldType), inType);                                       
                    if (string.IsNullOrEmpty(autoValue))
                        element.SetAttributeValue("outType", this.GetOutTypeDefault(t, null, true));
                    else
                    {
                        AutoValues a = (AutoValues)Enum.Parse(typeof(AutoValues), autoValue);
                        element.SetAttributeValue("outType", this.GetOutTypeDefault(t, a, true));
                    }
                }
                var name = element.Attribute("name");
                var ordinal = element.Attribute("ordinal");
                ordinal.Remove();
                name.Remove();

                var otherAttributes = element.Attributes().ToList();

                element.SetAttributeValue(ordinal.Name, ordinal.Value);
                element.SetAttributeValue(name.Name, name.Value);

                foreach (XAttribute att in otherAttributes)
                {
                    att.Remove();
                    element.SetAttributeValue(att.Name, att.Value);
                }
            }

            // reorder event attributes and insert fingerprints, indexes and header versions where needed
            int eventPositionIndex = 0;
            XElement curParent = null;
            foreach (XElement element in eventNodes)
            {
                if (curParent != element.Parent)
                {
                    curParent = element.Parent;
                    eventPositionIndex = 0;
                }               
                
                element.SetAttributeValue("index", eventPositionIndex++);
                
                if (element.Attribute("header") == null)
                    element.SetAttributeValue("header", 0);

                InsertFingerprint(element);
                
                string[] attributeOrder = new string[] { "id", "value", "index", "symbol", "category", "logstringid", "omniturearea", "description", "header", "deprecated" };

                foreach (string a in attributeOrder)
                {
                    XAttribute attr = element.Attribute(a);
                    if (attr != null)
                    {
                        attr.Remove();
                        element.SetAttributeValue(attr.Name, attr.Value);
                    }
                }
            }

            //Handle extra events nodes
            var producersWithExtraEvents = from e in testXml.Descendants("producer")
                                           where e.Elements("events").Count() > 0
                                           select e;
            foreach (XElement ele in producersWithExtraEvents)
            {
                var eventsNodes = ele.Elements("events");
                count = eventsNodes.Count();
                for (int k = count - 1; k > 0; k--)
                    eventsNodes.ElementAt(k).Remove();       
            }

            //Handle no events nodes
            var producersWithNoEvents = from e in testXml.Descendants("producer")
                                           where e.Elements("events").Count() == 0
                                           select e;
            foreach (XElement ele in producersWithNoEvents)
            {
                ele.Add(new XElement("events", null));                
            }

            //Reorder events
            var reorderEvtNodes = from e in testXml.Descendants("event")
                              orderby e.Attribute("index").ToString()
                              select e;

            count = reorderEvtNodes.Count();
            List<XElement> inorderEvtNodes = reorderEvtNodes.ToList<XElement>();
            for (int k = 0; k < count; k++)
            {                
                var parent = inorderEvtNodes[k].Parent;                
                inorderEvtNodes[k].Remove();
                parent.Add(inorderEvtNodes[k]);                
            }

            if (globalProducerNodes.Count() > 0)
            {   
                XElement gp = globalProducerNodes.First();
                                
                //Reorder producers by fingerprint to match the serialization output.
                var producers = from p in testXml.Descendants("producer")
                                        orderby p.Attribute("id").ToString()
                                               select p;

                var pArr = producers.ToArray();

                foreach (XElement p in pArr)
                {
                    p.Remove();
                    gp.Add(p);
                }                
            }
            return testXml.ToString();
        }

        public OutputType GetOutTypeDefault(DataFieldType inType, AutoValues? autoValue, bool oldValues)
        {
            OutputType t = OutputType.String;
            if (inType == DataFieldType.AnsiString || inType == DataFieldType.UnicodeString)
                return OutputType.String;

            switch (inType)
            {                   
                case DataFieldType.UnicodeString:                    
                case DataFieldType.AnsiString:
                    t = OutputType.String;
                    break;
                case DataFieldType.Int8:                    
                case DataFieldType.Int16:                                    
                case DataFieldType.Int32:                
                case DataFieldType.Int64:
                    t = OutputType.Number;
                    break;
                case DataFieldType.UInt8:                    
                case DataFieldType.UInt16:                    
                case DataFieldType.UInt32:                    
                case DataFieldType.UInt64:
                    t = OutputType.HexNumber;
                    break;
                case DataFieldType.Float:
                    t = OutputType.Float;
                    break;                    
                case DataFieldType.Double:
                    t = OutputType.Float;
                    break;
                case DataFieldType.Binary:
                    t = OutputType.String;
                    break;
                case DataFieldType.GUID:
                    t = OutputType.GUID;
                    break;
                default:
                    throw new Exception("What are you trying to test here? We dunno this intype. Tests might need an update.");                    
            }
            if (autoValue != null)
            {
                if (oldValues)
                {
                    switch (autoValue)
                    {
                        case AutoValues.Ipv4Address:
                        case AutoValues.TitleId:
                        case AutoValues.Timestamp:
                        case AutoValues.FlowToken:
                        case AutoValues.SystemVersion:
                            t = OutputType.HexNumber;
                            break;
                        case AutoValues.ConsoleId:
                            t = OutputType.String;
                            break;
                        default:
                            break;
                    }
                }
                else
                {
                    switch (autoValue)
                    {
                        case AutoValues.Ipv4Address:
                            t = OutputType.Ipv4Address;
                                break;
                        case AutoValues.TitleId:
                            t = OutputType.TitleName;
                            break;
                        case AutoValues.Timestamp:
                            t = OutputType.DateTime;
                            break;
                        case AutoValues.FlowToken:
                            t = OutputType.FlowToken;
                            break;
                        case AutoValues.SystemVersion:
                            t = OutputType.XexVersion;
                            break;
                        case AutoValues.ConsoleId:
                            t = OutputType.ConsoleId;
                            break;
                        default:
                            break;
                    }
                }
            }
            
            return t;
        }
      
        /// <summary>
        /// Ripped straight out of the dev code and reviewed. Used to make sure we 
        /// don't screw around with this and notice if we do.
        /// </summary>
        /// <returns>Returns a blob containing the MD5 hash of a given Event.</returns>
        public void InsertFingerprint(XElement e)
        {
            if (String.IsNullOrEmpty(GetAttributeHelper(e, "id")))
            {
                List<byte> buffer;

                using (MD5 md5 = MD5.Create())
                {
                    buffer = new List<byte>();

                    // encode event details
                    
                    buffer.AddRange(GetBytes(GetAttributeHelper(e, "symbol"))); buffer.Add(0);                      
                    buffer.AddRange(GetBytes(GetAttributeHelper(e, "logstringid"))); buffer.Add(0);
                    buffer.AddRange(GetBytes(GetAttributeHelper(e, "omniturearea"))); buffer.Add(0);

                    var fields = e.Descendants("data");
                    // encode sorted field details
                    foreach (XElement field in fields)
                    {
                        buffer.AddRange(GetBytes(Convert.ToUInt32(GetAttributeHelper(field, "ordinal"))));
                        buffer.AddRange(GetBytes(GetAttributeHelper(field, "name"))); buffer.Add(0);

                        string inType = GetAttributeHelper(field, "inType");

                        if (inType.Contains(":"))
                            inType = inType.Split(':')[1];

                        buffer.AddRange(GetBytes(inType)); buffer.Add(0);
                        buffer.AddRange(GetBytes(GetAttributeHelper(field, "autovalue"))); buffer.Add(0);
                        buffer.AddRange(GetBytes(GetAttributeHelper(field, "omniturevar"))); buffer.Add(0);
                        buffer.Add(GetAttributeHelper(field, "deprecated") == "1" ? (byte)1 : (byte)0);                        
                        buffer.AddRange(GetBytes(GetAttributeHelper(field, "outType"))); buffer.Add(0);
                    }

                    e.SetAttributeValue("id", ((Blob)md5.ComputeHash(buffer.ToArray())).ToString());
                }
            }            
        }
        
        public string GetAttributeHelper(XElement e, string attributeName)
        {
            if (e.Attribute(attributeName) == null)
                return String.Empty;
            else
                return e.Attribute(attributeName).Value;
        }

        /// <summary>
        /// Gets a byte array from a uint.
        /// </summary>
        /// <param name="value">Uint value to convert.</param>
        /// <returns>Returns the byte array associated with the value.</returns>
        private static byte[] GetBytes(uint value)
        {
            return BitConverter.GetBytes(value);
        }

        /// <summary>
        /// Gets a byte array from a nullable type
        /// </summary>
        /// <typeparam name="T">Value type of nullable</typeparam>
        /// <param name="value">Value to convert to a byte array.</param>
        /// <returns>Returns the byte array associated with the value.</returns>
        public static byte[] GetBytes<T>(T? value) where T : struct
        {
            if (!value.HasValue)
            {
                return new byte[0];
            }

            return Encoding.UTF8.GetBytes(value.ToString());
        }

        /// <summary>
        /// Gets a byte array from a string.
        /// </summary>
        /// <param name="value">String value to convert</param>
        /// <returns>Returns the byte array associated with the value.</returns>
        public static byte[] GetBytes(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return new byte[0];
            }

            return Encoding.UTF8.GetBytes(value);
        }
    }        

     

    /// <summary>
    /// Test case groups, no test code logic here.
    /// </summary>
    [TestGroup, Owner("wisgt"), Description("EtxManifest test cases. See 'ManifestTests.xml' for full details.")]
    public class EtxManifestCases : TestNode
    {
        [TestGroup, Owner("wisgt"), Description("Full Manifest test cases")]
        public class Manifest : FilteredETXGroup
        {
            public Manifest()
                : base()
            {
            }
        }

        [TestGroup, Owner("wisgt"), Description("Producer test cases")]
        public class Producers : FilteredETXGroup
        {
            public Producers()
                : base()
            {
            }
        }

        [TestGroup, Owner("wisgt"), Description("Events section specific test cases")]
        public class Events : FilteredETXGroup
        {
            public Events()
                : base()
            {
            }
        }

        [TestGroup, Owner("wisgt"), Description("Event merging test cases")]
        public class EventMerge : FilteredETXGroup
        {
            public EventMerge()
                : base()
            {
            }
        }

        [TestGroup, Owner("wisgt"), Description("Manifest merging test cases")]
        public class ManifestMerge : FilteredETXGroup
        {
            public ManifestMerge()
                : base()
            {
            }
        }

        [TestGroup, Owner("wisgt"), Description("Producer merging test cases")]
        public class ProducerMerge : FilteredETXGroup
        {
            public ProducerMerge()
                : base()
            {
            }
        }

        [TestGroup, Owner("wisgt"), Description("Producer merging test cases")]
        public class MiscCases : TestNode
        {
            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Daily"), Description("Checks the parent chain of EtxManifest objects.")]
            public class ParentChain : TestNode
            {
                public override void Run()
                {
                    EtxManifest manifest = new EtxManifest();
                    Producer producer = new Producer("TestSymbol", new byte[] { 0 });
                    Event evt = new Event(1, "Test");
                    DataField df = new DataField(1, "TestName");
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Daily"), Description("Check .Equals against nulls for the ExtManifest datatypes.")]
            public class NullChecks : TestNode
            {
                public override void Run()
                {
                    EtxManifest manifest = new EtxManifest();
                    Producer producer = new Producer("TestSymbol", new byte[] { 0 });
                    Event evt = new Event(1, "Test");
                    DataField df = new DataField(1, "TestName");

                    if (df.Equals(null) || evt.Equals(null) || producer.Equals(null) || manifest.Equals(null))
                        throw new Exception("An ETX Api object was somehow equal to null.");

                    
                    ValidateException((x) => { manifest.Merge(null); }, null, "Value cannot be null");
                    ValidateException((x) => { evt.Merge(null); }, null, "Value cannot be null");
                    ValidateException((x) => { producer.Merge(null); }, null, "Value cannot be null");
                    ValidateException((x) => { Event e = new Event((XmlReader)null); }, null, "Value cannot be null");
                    ValidateException((x) => { Event e = new Event((XElement)null); }, null, "Value cannot be null");
                }

                delegate void ThrowingMethod(object value);
                private void ValidateException(ThrowingMethod m, object value, string expectedException)
                {
                    try
                    {
                        m.Invoke(value);
                    }
                    catch (Exception ex)
                    {
                        if (!ex.Message.Contains(expectedException))
                            throw;
                    }
                }
            }

            

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Daily"), Description("Check .Equals against nulls for the ExtManifest datatypes.")]
            public class GetHashcodes : TestNode
            {
                public override void Run()
                {
                    EtxManifest manifest = new EtxManifest();                    
                    Producer producer = new Producer("TestSymbol", new byte[] { 0 });
                    Event evt = new Event(1, "Test");                    
                    
                    DataField df = new DataField(1, "TestName");
                    
                    EtxManifest manifest2 = new EtxManifest();
                    Producer producer2 = new Producer("TestSymbol", new byte[] { 0 });
                    Producer producer3 = new Producer("TestSymbolDifferent", new byte[] { 0 });
                    Event evt2 = new Event(1, "Test");
                    DataField df2 = new DataField(1, "TestName");

                    evt2.Deprecated = true;
                    evt2.Description = "Someotherthing";                    
                    producer2.Description = "Someotherthing";                    

                    if (df.GetHashCode() != df2.GetHashCode())
                        throw new Exception("Hash codes were different for semantically identical datafields.");
                    if (evt.GetHashCode() != evt2.GetHashCode())
                        throw new Exception("Hash codes were different for semantically identical events.");
                    if (producer.GetHashCode() != producer2.GetHashCode())
                        throw new Exception("Hash codes were different for semantically identical producers.");

                    df2.InType = DataFieldType.Double;
                    df2.Deprecated = true;
                    evt2.OmnitureArea = "AnotherArea";

                    if (df.GetHashCode() == df2.GetHashCode())
                        throw new Exception("Hash codes were the same for different objects.");                    
                    if (evt.GetHashCode() == evt2.GetHashCode())
                        throw new Exception("Hash codes were the same for different objects.");
                    if (producer.GetHashCode() == producer3.GetHashCode())
                        throw new Exception("Hash codes were the same for different objects.");
                }
            }
        }
    }
    #endregion

    #region Etx Manifest server facing test cases
    /// <summary>
    /// ETX manifest server facing test cases. They read ETX manifests from a test case XML file, prop them all up to the server, 
    /// config cache refresh (Right now this might not work though) and then generate data matching each manifest and watch for results as usual.
    /// </summary>
    public class EtxManifestServerTestCase : SerializableTestCase
    {
        public static EtxManifest GlobalTestManifest = new EtxManifest();
        public List<EtxManifest> LocalTestManifests = new List<EtxManifest>();

        protected static readonly string url = LogstringBase.BuildUrl("logbinary.ashx");
        public enum AutoValueSource { SGInfo, AAInfo };
        public AutoValueSource Source = AutoValueSource.SGInfo;
        #region Constructors and Initialization
        public EtxManifestServerTestCase()
            : base()
        {            
        }

        public EtxManifestServerTestCase(string name)
            : base(name)
        {            
        }
        #endregion

        /// <summary>
        /// Run method of the test case. 
        /// </summary>
        /// <returns></returns>
        public override void Run()
        {
            try
            {
                if (XMLParent == "Propping")
                    ProppingTest();
                else if (XMLParent == "SpecialField")
                    SpecialFieldTest();
                else
                {
                    foreach (EtxManifest man in LocalTestManifests)
                        ManifestTest(man);
                }
            }
            catch (Exception ex)
            {
                if (String.IsNullOrEmpty(XMLExpectedException) || !ex.Message.Contains(XMLExpectedException))
                    throw;
                else
                    Global.RO.Debug("Found expected exception");
            }
        }

        /// <summary>
        /// Takes a manifest XML, generates data for it, then sends the vortex binary protocol message to the server that matches this manifest, along
        /// with generated autovalues and regular values where needed.
        /// </summary>
        public void ManifestTest(EtxManifest LocalTestManifest)
        {            
            VortexHTTPBinary binary = new VortexHTTPBinary(url);
            binary.EtxEventManifest = LocalTestManifest;
            if (Source == AutoValueSource.AAInfo)
            {
                binary.SetAAInfo = true;
                binary.UseXRL = false;
                binary.SetSGInfo = false;
            }
            else if (Source == AutoValueSource.SGInfo)
            {
                binary.SetSGInfo = true;
                binary.SetAAInfo = false;
            }

            foreach (Producer p in LocalTestManifest.Producers)
            {
                binary.GenerateDataForManifestProducer(p);
                binary.SendRequest();
                binary.ClearParametersAndHeaders();
            }            
        }

        public void ProppingTest()
        {
            Source = AutoValueSource.SGInfo;
            try
            {
                foreach (EtxManifest man in LocalTestManifests)
                {
                    UploadManifest(man, false);
                    ConfigCacheReload();
                    ManifestTest(man);
                }                
            }            
            finally
            {
                foreach (EtxManifest man in LocalTestManifests)
                {
                    foreach (Producer p in man.Producers)
                    {
                        RemoveProducer(p, false);
                    }                    
                }
                ConfigCacheReload();
            }
        }

        public void SpecialFieldTest()
        {
            Source = AutoValueSource.SGInfo;
            EtxManifest ghetto = LocalTestManifests[0];
            EtxManifest real = LocalTestManifests[1];
            
            try
            {                
                UploadManifest(real, false);
                ConfigCacheReload();
                VortexProtocolInputBase.VerifyCleanser = false;
                ManifestTest(ghetto);             
            }
            finally
            {
                VortexProtocolInputBase.VerifyCleanser = true;
                foreach (Producer p in real.Producers)
                {
                    RemoveProducer(p, false);
                }                
                ConfigCacheReload();
            }
        }

        public DataFieldType GetNativeAutovalueType(DataField df)
        {
            DataFieldType returnType = df.InType;
            if (df.AutoValue != null && df.AutoValueCreator != null && df.AutoValueCreator == AutoValueCreators.LiveService)
            {
                switch (df.AutoValue)
                {
                    case AutoValues.CountryId:                        
                    case AutoValues.MembershipType:
                    case AutoValues.LanguageId:
                        returnType = DataFieldType.UInt8;
                        break;
                    default:
                        returnType = df.InType;
                        break;
                        
                }
            }
            return returnType;
        }        

        /// <summary>
        /// Pushes the global test manifest 
        /// </summary>
        public static void PropTestManifest()
        {
            foreach (Producer p in GlobalTestManifest.Producers)
                UploadProducer(p, false);
            ConfigCacheReload();
        }

        /// <summary>
        /// Remove the global test manifest 
        /// </summary>
        public static void RemoveTestManifest()
        {
            foreach (Producer p in GlobalTestManifest.Producers)
                RemoveProducer(p, false);
            ConfigCacheReload();
        }

        private static void ConfigCacheReload()
        {
            Global.XEnv.ForceConfigReload(VortexUtil.vortex_Interface);
            Global.XEnv.ForceConfigReload(Interface.cleanser);
            Thread.Sleep(500);
        }

        protected static MixSettingsManagementV2Client CreateMixSettingsManagementClient ()
        {
            // create binding to use
            System.ServiceModel.BasicHttpBinding wsb = new System.ServiceModel.BasicHttpBinding();
            wsb.Name = "Vortex Mix";
            wsb.CloseTimeout = TimeSpan.Parse("00:01:00");
            wsb.OpenTimeout = TimeSpan.Parse("00:01:00");
            wsb.ReceiveTimeout = TimeSpan.Parse("00:10:00");
            wsb.SendTimeout = TimeSpan.Parse("00:01:00");
            wsb.ReaderQuotas.MaxStringContentLength = 4194304;

            wsb.BypassProxyOnLocal = false;
            wsb.HostNameComparisonMode =
                System.ServiceModel.HostNameComparisonMode.StrongWildcard;
            wsb.MaxBufferPoolSize = 524288;
            wsb.MaxReceivedMessageSize = 6553600;
            wsb.MessageEncoding =
                System.ServiceModel.WSMessageEncoding.Text;
            wsb.TextEncoding = System.Text.Encoding.UTF8;
            wsb.UseDefaultWebProxy = true;
            wsb.AllowCookies = false;

            wsb.Security.Transport.ProxyCredentialType = System.ServiceModel.HttpProxyCredentialType.None;
            wsb.Security.Mode = System.ServiceModel.BasicHttpSecurityMode.None;

            // create endpoint to call
            System.Net.IPEndPoint ipEndPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.mixsettingsmanagement);
            string uri = "http://" + ipEndPoint.ToString() + "/mixsettingsmanagement/mixsettingsmanagementV2.svc";
            System.ServiceModel.EndpointAddress epa = new System.ServiceModel.EndpointAddress(uri);

            return new MixSettingsManagementV2Client(wsb, epa);
        }

        protected static bool _MixAPIEnabled = false;

        protected static void EnableMixAPI ()
        {
            string query = String.Format("exec wsp_MSins_t_partner_allowed_apis {0},'{1}','{2}'",
                1, // @i_partner_id
                "MixSettingsManagement.IngestEtxManifest", // @vc_api_name
                DateTime.UtcNow); // @dt_changed
            ServerTestFramework.Database.StaticWebDB.ExecuteNonQuery(query);
            Global.XEnv.ExecuteXmgmtCommand(Interface.mixsettingsmanagement, "e :Xonline.Mix.SettingsManagement.Service reloadpartners");
        }

        protected static void UploadManifestMix (EtxManifest manifest)
        {
            if (!_MixAPIEnabled)
            {
                EnableMixAPI();
                _MixAPIEnabled = true;
            }

            MixSettingsManagementV2Client client = CreateMixSettingsManagementClient();

            XmlSerializer serializer = new XmlSerializer(typeof(EtxManifest));
            MemoryStream ms = new MemoryStream();
            serializer.Serialize(ms, manifest);
            ms.Position = 0;

            string result = null;

            using (System.ServiceModel.OperationContextScope scope = new System.ServiceModel.OperationContextScope(client.InnerChannel))
            {
                // add the headers to the client
                System.ServiceModel.Channels.HttpRequestMessageProperty msgProperty =
                    new System.ServiceModel.Channels.HttpRequestMessageProperty();

                msgProperty.Headers.Add("Subject-Name", "DebugPartner");
                msgProperty.Headers.Add("Client-IP-Port", "1.1.1.1:1000");
                msgProperty.Headers.Add("RequestId", ServerTestFramework.Utilities.RandomEx.GlobalRandGen.NextUlong().ToString("X16"));

                System.ServiceModel.OperationContext.Current.OutgoingMessageProperties[System.ServiceModel.Channels.HttpRequestMessageProperty.Name] = 
                    msgProperty;

                result = client.IngestEtxManifest((new StreamReader(ms)).ReadToEnd());
            }

            // verify result
            if (string.IsNullOrEmpty(result))
            {
                throw new UnexpectedTestResultException("MIX result was null or empty.");
            }

            XmlDocument resultDoc = new XmlDocument();
            resultDoc.LoadXml(result);

            XmlNodeList errors = resultDoc.SelectNodes("/result/errors/item");

            if (errors != null && errors.Count > 0)
            {
                string errorString = "";

                foreach (XmlNode node in errors)
                {
                    XmlNode exc = node.SelectSingleNode("exception");

                    if (exc == null)
                    {
                        errorString += string.Format("\n{0}\n   --- End of server exception ---",
                            node.SelectSingleNode("description").InnerText);
                    }
                    else
                    {
                        errorString += string.Format("\n{0}\n{1}\n   --- End of server exception ---",
                            exc.SelectSingleNode("message").InnerText,
                            exc.SelectSingleNode("stack").InnerText);
                    }
                }

                throw new UnexpectedTestResultException("MIX result contained errors:" + errorString);
            }
        }

        protected static IEnumerable<string> EtxListToIEnumerable (string etxList)
        {
            StringReader reader = new StringReader(etxList);
            // throw away the header
            reader.ReadLine();

            string line = null;
            while ((line = reader.ReadLine()) != null)
            {
                yield return line;
            }
        }

        protected static void VerifyManifestUpload (EtxManifest manifest)
        {
            // convert manifest producers into a list similar to the one returned by vortex
            var myProducers = from p in manifest.Producers select string.Format("  {0} :: FP={1}", p.Symbol, p.Fingerprint);

            foreach (ManagementConsole.XmgmtResponse resp in
                ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortexfd etxlist"))
            {
                if (!resp.Result)
                {
                    throw new UnexpectedTestResultException("Error getting the etxlist: " + resp.Response);
                }

                var etxProducers = EtxListToIEnumerable(resp.Response);

                // get the producers in my manifest that are not in the vortex response
                var myExtras = from p in myProducers
                               where !(etxProducers.Contains(p))
                               select p;

                if (myExtras.Any())
                {
                    throw new UnexpectedTestResultException(myExtras.Aggregate("Producers were missing:", (start, p) => start + '\n' + p));
                }
            }
        }

        public static void UploadProducer(Producer producer, bool configCacheReload)
        {
            EtxManifest manifest = null;

            if (VortexPlugin.UseMixForManifests)
            {
                manifest = new EtxManifest();
                manifest.Producers.Add(producer);
                UploadManifestMix(manifest);
            }
            else
            {
                xonline.common.core.etx.EtxLoader.NPDB.UploadProducer(producer);
            }

            if (configCacheReload)
            {
                ConfigCacheReload();
            }

            if ((configCacheReload || VortexPlugin.UseMixForManifests) && VortexPlugin.VerifyManifestUpload)
            {
                if (manifest == null)
                {
                    manifest = new EtxManifest();
                    manifest.Producers.Add(producer);
                }

                VerifyManifestUpload(manifest);
            }
        }

        public static void UploadManifest(EtxManifest manifest, bool configCacheReload)
        {
            if (VortexPlugin.UploadManifests)
            {
                if (VortexPlugin.UseMixForManifests)
                {
                    UploadManifestMix(manifest);
                }
                else
                {
                    xonline.common.core.etx.EtxLoader.NPDB.UploadManifest(manifest);
                }

                if (configCacheReload)
                {
                    ConfigCacheReload();
                }

                if ((configCacheReload || VortexPlugin.UseMixForManifests) && VortexPlugin.VerifyManifestUpload)
                {
                    VerifyManifestUpload(manifest);
                }
            }
        }

        public static void RemoveProducer(Producer producer, bool configCacheReload)
        {
            foreach (Event e in producer.Events)
                RemoveEventOrProducer(e.Fingerprint);
            RemoveEventOrProducer(producer.Fingerprint);
            if (configCacheReload)
            {
                ConfigCacheReload();
            }
        }

        private static void RemoveEventOrProducer(Blob blobId)
        {
	    if (VortexPlugin.UnpropEvents)
	    {
               string sqlDelMappings = String.Format("delete from t_etx_producer_event_mappings where vb_producer_fingerprint = 0x{0} or vb_event_fingerprint = 0x{0}", blobId);
               string sqlDelEvents = String.Format("delete from t_etx_manifest_events where vb_event_fingerprint = 0x{0}", blobId);
               string sqlDelProducers = String.Format("delete from t_etx_manifest_producers where vb_producer_fingerprint = 0x{0}", blobId);


               string connStr = Config.GetSingleInterface(Interface.npdb).SqlConnectionString;
            
               using (SqlConnection sql = new SqlConnection(connStr))
               {
                   sql.Open();
   
                   using (SqlCommand cmd = new SqlCommand(sqlDelMappings, sql))
                   {
                       cmd.CommandType = CommandType.Text;
                       cmd.ExecuteNonQuery();
                   }
                   using (SqlCommand cmd = new SqlCommand(sqlDelEvents, sql))
                   {
                       cmd.CommandType = CommandType.Text;
                       cmd.ExecuteNonQuery();
                   }
   
                   using (SqlCommand cmd = new SqlCommand(sqlDelProducers, sql))
                   {
                       cmd.CommandType = CommandType.Text;
                       cmd.ExecuteNonQuery();
                   }                
               }
	    }
        }

        public static void UploadHeader(Event hdrEvent)
        {
            xonline.common.core.etx.EtxLoader.NPDB.UploadHeaderDefinition((byte)hdrEvent.Value, hdrEvent);
        }        

        /// <summary>
        /// Used to produce a string from an etx manifest object
        /// </summary>
        /// <param name="rawXml"></param>
        /// <returns></returns>
        public static string ReadEtxManifest(EtxManifest manifest)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(EtxManifest));
            MemoryStream ms = new MemoryStream();
            serializer.Serialize(ms, manifest);
            ms.Position = 0;
            StreamReader reader = new StreamReader(ms);
            string originalString = reader.ReadToEnd();
            XDocument doc = XDocument.Parse(originalString);
            return doc.ToString(); //Get rid of the serialization wrapper.
        }
    }          

    [TestGroup, Owner("wisgt"), Description("EtxManifest test cases. See 'ManifestServerTests.xml' for full details.")]
    public class EtxManifestServerTestCases : VortexTestGroup
    {
        protected static readonly string url = LogstringBase.BuildUrl("logbinary.ashx");
        protected const string TEST_MANIFEST_PRODUCER_ID = "9000";
        
        public override void PreRun(RUN_TYPE type)
        {
            base.PreRun(type);
            EtxManifestServerTestCase.PropTestManifest();
            PropHeaders();            
        }


        [Serializable]
        public class EventWrapper : IXmlSerializable
        {            
            public Event e = null;


            #region IXmlSerializable Members

            public System.Xml.Schema.XmlSchema GetSchema()
            {
                throw new NotImplementedException();
            }

            public void ReadXml(XmlReader reader)
            {
                string xmlVal = reader.ReadInnerXml();
                e = new Event(XElement.Parse(xmlVal.ToString()));
            }

            public void WriteXml(XmlWriter writer)
            {
                throw new NotImplementedException();
            }

            #endregion
        }
        private void PropHeaders()
        {
            XmlSerializer serializer = new XmlSerializer(typeof(List<EventWrapper>), new Type[] { typeof(EventWrapper) });
            
            Global.RO.Debug("Loading event header xmls to prop from SuitesData\\Vortex\\testheaders.xml");
            FileStream fs = new FileStream(@"SuitesData\Vortex\testheaders.xml", FileMode.Open);
            try
            {
                List<EventWrapper> el = (List<EventWrapper>)serializer.Deserialize(fs);

                foreach (EventWrapper e in el)
                {
                    EtxManifestServerTestCase.UploadHeader(e.e);
                }
            }
            finally
            {
                fs.Close();
            }            
        }

        public override void PostRun(RUN_TYPE type)
        {
            base.PostRun(type);
            EtxManifestServerTestCase.RemoveTestManifest();
        }

        [TestGroup, Owner("wisgt"), Description("Test cases that send SGInfo")]
        public class SGInfo : FilteredEtxServerGroup
        {
            public SGInfo()
                : base()
            {
            }
        }

        [TestGroup, Owner("wisgt"), Description("Test cases that send AAInfo")]
        public class AAInfo : FilteredEtxServerGroup
        {
            public AAInfo()
                : base()
            {
            }
        }        
        
        [TestGroup, Owner("wisgt"), Description("Test cases that send none")]
        public class None : FilteredEtxServerGroup
        {
            public None()
                : base()
            {
            }
        }        

        [TestCase, Owner("wisgt"), Description("Manifest propping related cases")]
        public class Propping : FilteredEtxServerGroup
        {
            public Propping()
                : base()
            {
            }
        }        
        [TestCase, Owner("wisgt"), Description("Special field related cases")]
        public class SpecialField: FilteredEtxServerGroup
        {
            public SpecialField()
                : base()
            {
            }
        }        

    }
    #endregion

    #region XML test case infrastructure related stuff.
    /// <summary>
    /// Filtered Etx server test case group.  It loads up test cases dynamically from an XML. It stores the local XML
    /// to each test case, and also creates a global shared manifest which is later pushed into the server
    /// </summary>
    public class FilteredEtxServerGroup : TestNode
    {
        public FilteredEtxServerGroup()
        {
            XmlSerializer serializer = new XmlSerializer(typeof(List<EtxManifestServerTestCase>));
            Global.RO.Debug("Loading {0} test cases from SuitesData\\Vortex\\etxservertests.xml", this.Name);
            FileStream fs = new FileStream(@"SuitesData\Vortex\etxservertests.xml", FileMode.Open);
            List<EtxManifestServerTestCase> l = (List<EtxManifestServerTestCase>)serializer.Deserialize(fs);
            fs.Close();

            var fl = from t in l
                     where t.XMLParent.Contains(this.Name)
                     select t;

            foreach (EtxManifestServerTestCase tc in fl)
            {
                try
                {
                    tc.Source = (EtxManifestServerTestCase.AutoValueSource)Enum.Parse(typeof(EtxManifestServerTestCase.AutoValueSource), this.Name);
                }
                catch (Exception)
                {

                }

                tc.TaggingData.AddTagValue("Priority", tc.XMLPriority);
                AddChild(tc, true, false);

                foreach (string ix in tc.InputXmls)
                {
                    EtxManifest LocalTestManifest = new EtxManifest();
                    try
                    {
                        EtxManifest man = new EtxManifest(XmlReader.Create(new StringReader(ix), EtxLoader.NPDB.DownloadValidationSettings()));
                        foreach (Producer pro in man.Producers)
                        {
                            if (!tc.XMLParent.Contains("Propping") && !tc.XMLParent.Contains("SpecialField"))
                            {
                                if (EtxManifestServerTestCase.GlobalTestManifest.Producers.Fingerprints.ContainsKey(pro.Fingerprint))
                                {
                                    try
                                    {
                                        EtxManifestServerTestCase.GlobalTestManifest.Producers[xonline.common.core.etx.collections.ProducerCollectionKeys.Fingerprint, pro.Fingerprint].Events.AddRange(pro.Events);
                                    }
                                    catch (Exception ex)
                                    {
                                        if (!ex.Message.Contains("Symbol") || !tc.XMLParent.Contains("|"))
                                        {
                                            throw;
                                        }
                                        //Likely just test cases that share a manifest and are conflicting. Leave it alone.                                    
                                    }
                                }
                                else
                                    EtxManifestServerTestCase.GlobalTestManifest.Producers.Add(pro);
                            }
                            LocalTestManifest.Producers.Add(pro);
                        }
                        tc.LocalTestManifests.Add(LocalTestManifest);
                    }
                    catch (Exception ex)
                    {
                        Global.RO.Info("Failed to load test case:" + tc.Name);
                        Global.RO.Info(ex.Message);
                        Global.RO.Info(ex.StackTrace);
                    }
                }
            }
        }
    }
    
    /// <summary>
    /// Filtered XML test case group.  It loads up test cases dynamically from an XML.
    /// No test code logic here.
    /// </summary>
    public class FilteredETXGroup : TestNode
    {
        public FilteredETXGroup()
        {
            XmlSerializer serializer = new XmlSerializer(typeof(List<EtxManifestXMLTestCase>));
            Global.RO.Debug("Loading {0} test cases from SuitesData\\Vortex\\manifesttests.xml", this.Name);
            FileStream fs = new FileStream(@"SuitesData\Vortex\manifesttests.xml", FileMode.Open);
            List<EtxManifestXMLTestCase> l = (List<EtxManifestXMLTestCase>)serializer.Deserialize(fs);
            fs.Close();

            var fl = from t in l
                     where this.Name.Equals(t.XMLParent, StringComparison.InvariantCultureIgnoreCase)
                     select t;

            foreach (EtxManifestXMLTestCase tc in fl)
            {
                tc.TaggingData.AddTagValue("Priority", tc.XMLPriority);
                AddChild(tc, true, false);
            }
        }
    }
#endregion    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\MixSettingsManagementClient.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.settingsmanagement.contracts/V2", ClrNamespace="xonline.mix.settingsmanagement.contracts.V2")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.common.contracts", ClrNamespace="xonline.mix.common.contracts")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://www.microsoft.com/practices/EnterpriseLibrary/2007/01/wcf/validation", ClrNamespace="www.microsoft.com.practices.EnterpriseLibrary._2007._01.wcf.validation")]

namespace xonline.mix.settingsmanagement.contracts.V2
{
    using System.Runtime.Serialization;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="LiveHiveConfig", Namespace="http://xonline.mix.settingsmanagement.contracts/V2")]
    public partial class LiveHiveConfig : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Guid BetaGroupIdField;
        
        private System.Nullable<ushort> BuildField;
        
        private xonline.mix.settingsmanagement.contracts.V2.PlatformType PlatformTypeField;
        
        private System.Nullable<ushort> QfeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.Guid BetaGroupId
        {
            get
            {
                return this.BetaGroupIdField;
            }
            set
            {
                this.BetaGroupIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<ushort> Build
        {
            get
            {
                return this.BuildField;
            }
            set
            {
                this.BuildField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.settingsmanagement.contracts.V2.PlatformType PlatformType
        {
            get
            {
                return this.PlatformTypeField;
            }
            set
            {
                this.PlatformTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<ushort> Qfe
        {
            get
            {
                return this.QfeField;
            }
            set
            {
                this.QfeField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PlatformType", Namespace="http://xonline.mix.settingsmanagement.contracts/V2")]
    public enum PlatformType : byte
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xbox1 = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        XboxCom = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xenon = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Marketplace = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PC = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Mobile = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        WebGames = 6,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="LiveHiveSetting", Namespace="http://xonline.mix.settingsmanagement.contracts/V2")]
    public partial class LiveHiveSetting : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig ConfigField;
        
        private string NameField;
        
        private string ValueField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig Config
        {
            get
            {
                return this.ConfigField;
            }
            set
            {
                this.ConfigField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                this.NameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Value
        {
            get
            {
                return this.ValueField;
            }
            set
            {
                this.ValueField = value;
            }
        }
    }
}
namespace xonline.mix.common.contracts
{
    using System.Runtime.Serialization;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MixClientFaultBase", Namespace="http://xonline.mix.common.contracts")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(xonline.mix.common.contracts.MixClientFault))]
    public partial class MixClientFaultBase : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private bool IsRetryableField;
        
        private string MessageField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRetryable
        {
            get
            {
                return this.IsRetryableField;
            }
            set
            {
                this.IsRetryableField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Message
        {
            get
            {
                return this.MessageField;
            }
            set
            {
                this.MessageField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    public partial class MixClientFault : xonline.mix.common.contracts.MixClientFaultBase
    {
        
        private uint HResultField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint HResult
        {
            get
            {
                return this.HResultField;
            }
            set
            {
                this.HResultField = value;
            }
        }
    }
}
namespace www.microsoft.com.practices.EnterpriseLibrary._2007._01.wcf.validation
{
    using System.Runtime.Serialization;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ValidationFault", Namespace="http://www.microsoft.com/practices/EnterpriseLibrary/2007/01/wcf/validation")]
    public partial class ValidationFault : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationDetail[] DetailsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationDetail[] Details
        {
            get
            {
                return this.DetailsField;
            }
            set
            {
                this.DetailsField = value;
            }
        }
    }
}
namespace Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF
{
    using System.Runtime.Serialization;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ValidationDetail", Namespace="http://schemas.datacontract.org/2004/07/Microsoft.Practices.EnterpriseLibrary.Val" +
        "idation.Integration.WCF")]
    public partial class ValidationDetail : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string KeyField;
        
        private string MessageField;
        
        private string TagField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Key
        {
            get
            {
                return this.KeyField;
            }
            set
            {
                this.KeyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Message
        {
            get
            {
                return this.MessageField;
            }
            set
            {
                this.MessageField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Tag
        {
            get
            {
                return this.TagField;
            }
            set
            {
                this.TagField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.settingsmanagement.contracts/V2", ConfigurationName="MixSettingsManagementV2")]
public interface MixSettingsManagementV2
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/GetSet" +
        "tings", ReplyAction="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/GetSet" +
        "tingsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.contracts.MixClientFault), Action="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/GetSet" +
        "tingsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(www.microsoft.com.practices.EnterpriseLibrary._2007._01.wcf.validation.ValidationFault), Action="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/GetSet" +
        "tingsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.settingsmanagement.contracts.V2.LiveHiveSetting[] GetSettings(xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig config);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/SetSet" +
        "ting", ReplyAction="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/SetSet" +
        "tingResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(www.microsoft.com.practices.EnterpriseLibrary._2007._01.wcf.validation.ValidationFault), Action="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/SetSet" +
        "tingValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.contracts.MixClientFault), Action="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/SetSet" +
        "tingMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SetSetting(xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig config, xonline.mix.settingsmanagement.contracts.V2.LiveHiveSetting setting);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/Ingest" +
        "EtxManifest", ReplyAction="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/Ingest" +
        "EtxManifestResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(www.microsoft.com.practices.EnterpriseLibrary._2007._01.wcf.validation.ValidationFault), Action="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/Ingest" +
        "EtxManifestValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.contracts.MixClientFault), Action="http://xonline.mix.settingsmanagement.contracts/V2/MixSettingsManagementV2/Ingest" +
        "EtxManifestMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    string IngestEtxManifest(string xmlManifest);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface MixSettingsManagementV2Channel : MixSettingsManagementV2, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixSettingsManagementV2Client : System.ServiceModel.ClientBase<MixSettingsManagementV2>, MixSettingsManagementV2
{
    
    public MixSettingsManagementV2Client()
    {
    }
    
    public MixSettingsManagementV2Client(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixSettingsManagementV2Client(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixSettingsManagementV2Client(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixSettingsManagementV2Client(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public xonline.mix.settingsmanagement.contracts.V2.LiveHiveSetting[] GetSettings(xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig config)
    {
        return base.Channel.GetSettings(config);
    }
    
    public void SetSetting(xonline.mix.settingsmanagement.contracts.V2.LiveHiveConfig config, xonline.mix.settingsmanagement.contracts.V2.LiveHiveSetting setting)
    {
        base.Channel.SetSetting(config, setting);
    }
    
    public string IngestEtxManifest(string xmlManifest)
    {
        return base.Channel.IngestEtxManifest(xmlManifest);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\VortexPlugin.cs ===
using System;

using ServerTestFramework;

using STFGui.Plugins;

using PropertyDescription = System.ComponentModel.DescriptionAttribute;

namespace xonline.test.vortex
{
    public class VortexPlugin : IPluginPreferences
    {
        protected class VortexSTF : ICloneable
        {
            public VortexSTF ()
            {
                UseMixForManifests = true;
                VerifyManifestUpload = true;
		        UseSchemaValidation = true;
		        UnpropEvents = true;
                UploadManifests = true;
            }

            // If you add new fields, need to add them in here
            #region ICloneable Members

            public object Clone ()
            {
                VortexSTF ans = new VortexSTF();

                // copy every value
                ans.UseMixForManifests = UseMixForManifests;
                ans.VerifyManifestUpload = VerifyManifestUpload;
		        ans.UseSchemaValidation = UseSchemaValidation;
    		    ans.UnpropEvents = UnpropEvents;
                ans.UploadManifests = UploadManifests;
                return ans;
            }

            #endregion

            [PropertyDescription("If true, use Mix to upload manifests; if false, upload them directly.")]
            public bool UseMixForManifests { get; set; }

            [PropertyDescription("If true, verifies the manifest uploads using xmgmt commands; if false, does not.")]
            public bool VerifyManifestUpload { get; set; }

            [PropertyDescription("If true, uses the XSD when running local manifest tests.")]
            public bool UseSchemaValidation{ get; set; }
            
            [PropertyDescription("If true, cleans up events after the tests are done.")]
            public bool UnpropEvents{ get; set; }

            [PropertyDescription("If true, props manifests.")]
            public bool UploadManifests { get; set; }
        }

        #region Vortex Test Access

        /// <summary>
        /// Should control the use of MIX to upload manifest data to the database.
        /// </summary>
        public static bool UseMixForManifests { get { return _prefObj.UseMixForManifests; } }

        /// <summary>
        /// Should control the overall upload of manifests into the database.
        /// </summary>
        public static bool UploadManifests { get { return _prefObj.UploadManifests; } }

        /// <summary>
        /// Should control the use of xmgmt to verify successful upload of manifests.
        /// </summary>
        public static bool VerifyManifestUpload { get { return _prefObj.UseMixForManifests; } }

        /// <summary>
        /// Should control the use of schema to validate local in-memory client manifest tests
        /// </summary>
        public static bool UseSchemaValidation { get { return _prefObj.UseSchemaValidation; } }

        /// <summary>
        /// Should control the cleanup of test events from the database.
        /// </summary>
        public static bool UnpropEvents { get { return _prefObj.UnpropEvents; } }

        #endregion

        #region IPluginPreferences Members

        protected static VortexSTF _prefObj = new VortexSTF();

        ICloneable IPluginPreferences.PluginPreferences
        {
            get
            {
                return _prefObj;
            }
            set
            {
                _prefObj = (VortexSTF)value;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\VortexLogWeb.cs ===
namespace xonline.test.vortex
{
    using ServerTestFramework;
    using xonline.common.core.etx;
    using ServerTestFramework.LiveService.Vortex;
    using System.Net;

    [TestGroup, Owner("JKonkle"), Description("Test cases for LogWeb_V1")]
    public class LogWeb_V1 : VortexTestGroup 
    {
        /// <summary>
        /// Constant string for the web page enpoint name
        /// </summary>
        protected static readonly string url = LogWeb_V1.BuildUrl("LogWeb_V1.ashx");

        /// <summary>
        /// Builds a URL by looking up the VIP and appending the apiName
        /// </summary>
        /// <param name="apiName">Name of the web page entry point</param>
        /// <returns>Full HTTP URL pointing to vortex and the supplied apiName</returns>
        public static string BuildUrl(string apiName)
        {
            string url;
            IPEndPoint viIP;

            viIP = Global.XEnv.GetVirtualInterface(VortexUtil.vortex_VirtualInterface);
            url = "http://" + viIP.ToString() + "/vortex/" + apiName;

            Global.RO.Debug(url);
            return url;
        }

        /// <summary>
        /// Builds a DataField with specified AutoValue, defaulting creator to LiveService
        /// </summary>
        /// <param name="ordinal">The field number</param>
        /// <param name="name">Name of the Datafield</param>
        /// <param name="autoValue">AutoValue source</param>
        /// <returns>DataField object that is built</returns>
        private DataField BuildDataField(uint ordinal, string name, AutoValues autoValue)
        {
            DataField df = new DataField(ordinal, name);
            df.AutoValueCreator = AutoValueCreators.LiveService;
            df.AutoValue = autoValue;
            return df;
        }

        /// <summary>
        /// Builds a DataField object with specified values
        /// </summary>
        /// <param name="ordinal">The field number</param>
        /// <param name="name">Name of the DataField</param>
        /// <param name="autoValue">AutoValue source</param>
        /// <param name="text">Text for the AutoValue field name</param>
        /// <param name="inType">Input type</param>
        /// <param name="outType">Output type</param>
        /// <returns>DataField object that is built</returns>
        private DataField BuildDataField(uint ordinal, string name, AutoValues autoValue, string text, DataFieldType inType, OutputType outType)
        {
            DataField df = new DataField(ordinal, name);
            df.AutoValueCreator = AutoValueCreators.LiveService;
            df.AutoValue = autoValue;
            df.Text = text;
            df.InType = inType;
            df.OutType = outType;
            
            return df;
        }
            

        /// <summary>
        /// Setup by adding a test manifest to NPDB
        /// Will be under XboxCom-Test
        /// </summary>
        public override void OneTimeSetup()
        {
            EtxManifest manifest = new EtxManifest();
            Event evt = new Event(1, "Test", FingerprintAlgorithm.SequentialEvent.GenerateFingerprint("XboxComTest", "Test", 0)) { HeaderVersion = 4 };
            
            evt.Category = EventCategory.Clickstream;
            
            Producer prod = new Producer("XboxComTest", FingerprintAlgorithm.SequentialProducer.GenerateFingerprint("XboxComTest", 0));
            evt.DataFields.Add(new DataField(1, "evt"));
            evt.DataFields.Add(new DataField(2, "evn"));
            evt.DataFields.Add(new DataField(3, "loc"));
            evt.DataFields.Add(new DataField(4, "page"));
            evt.DataFields.Add(new DataField(5, "cookies"));
            evt.DataFields.Add(new DataField(6, "ht"));
            evt.DataFields.Add(new DataField(7, "wd"));
            evt.DataFields.Add(new DataField(8, "res"));
            evt.DataFields.Add(new DataField(9, "colors"));
            evt.DataFields.Add(new DataField(10, "flashVer"));
            evt.DataFields.Add(new DataField(11, "silverVer"));
            evt.DataFields.Add(new DataField(12, "dt"));
            evt.DataFields.Add(new DataField(13, "url"));
            evt.DataFields.Add(BuildDataField(14, "Cookie", AutoValues.LookupRequestHeader));
            evt.DataFields.Add(BuildDataField(15, "s_nr", AutoValues.LookupCookie));
            evt.DataFields.Add(BuildDataField(16, "someVIvalue", AutoValues.LookupCookie, "s_vi", DataFieldType.AnsiString, OutputType.String));
            evt.DataFields.Add(BuildDataField(17, "User-Agent", AutoValues.LookupRequestHeader));
            prod.Events.Add(evt);
            manifest.Producers.Add(prod);
            
            EtxManifestServerTestCase.UploadManifest(manifest, true);
        }

        [TestCase, Description("Simple test cast")]
        public void SimpleCase()
        {
            VortexWeb vw = new VortexWeb(url);
            vw.CustomQS = "?evt=Test&evn=0&loc=en-us&page=TestPage&cookies=y&ht=681&wd=1448&res=1600x1200&dt=Wed%2C%2016%20Mar%202011%2023%3A36%3A10%20UTC%20420&url=http%3A//roymo4/ETXTrackingTest.aspx";
            vw.Cookie = "s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1|2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420";
            //vw.Headers.Add("Host", "www.xbox.com");
            //vw.Headers.Add("Test1", "XY)#@}}{||");
            vw.ExpectedString = "XboxComTest-Test|Test|0|en-us|TestPage|y|681|1448|1600x1200||||Wed, 16 Mar 2011 23:36:10 UTC 420|http://roymo4/ETXTrackingTest.aspx|s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1,2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420|1294273639243|[CS]v1,2692863385010622-6000010360005961[CE]|VortexDVT/0.1";
            vw.SendRequest();   
        }

        [TestCase, Description("Backwards check of matching current version by specifying n+1")]
        public void EvnPlusOne()
        {
            VortexWeb vw = new VortexWeb(url);
            vw.CustomQS = "?evt=Test&evn=1&loc=en-us&page=TestPage&cookies=y&ht=681&wd=1448&res=1600x1200&dt=Wed%2C%2016%20Mar%202011%2023%3A36%3A10%20UTC%20420&url=http%3A//roymo4/ETXTrackingTest.aspx";
            vw.Cookie = "s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1|2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420";
            vw.ExpectedString = "XboxComTest-Test|Test|1|en-us|TestPage|y|681|1448|1600x1200||||Wed, 16 Mar 2011 23:36:10 UTC 420|http://roymo4/ETXTrackingTest.aspx|s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1,2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420|1294273639243|[CS]v1,2692863385010622-6000010360005961[CE]|VortexDVT/0.1";
            vw.SendRequest();   
        }

        [TestCase, Description("Backwards check of matching current version by specifying n+2: should return n=0 manifest")]
        public void EvnPlusTwo()
        {
            VortexWeb vw = new VortexWeb(url);
            vw.CustomQS = "?evt=Test&evn=2&loc=en-us&page=TestPage&cookies=y&ht=681&wd=1448&res=1600x1200&dt=Wed%2C%2016%20Mar%202011%2023%3A36%3A10%20UTC%20420&url=http%3A//roymo4/ETXTrackingTest.aspx";
            vw.Cookie = "s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1|2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420";
            vw.ExpectedString = "XboxComTest-Test|Test|2|en-us|TestPage|y|681|1448|1600x1200||||Wed, 16 Mar 2011 23:36:10 UTC 420|http://roymo4/ETXTrackingTest.aspx|s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1,2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420|1294273639243|[CS]v1,2692863385010622-6000010360005961[CE]|VortexDVT/0.1";
            vw.SendRequest();
        }

        [TestCase, Description("Backwards check of matching current version by specifying n+3: should return n=0 manifest")]
        public void EvnPlus999()
        {
            VortexWeb vw = new VortexWeb(url);
            vw.CustomQS = "?evt=Test&evn=999&loc=en-us&page=TestPage&cookies=y&ht=681&wd=1448&res=1600x1200&dt=Wed%2C%2016%20Mar%202011%2023%3A36%3A10%20UTC%20420&url=http%3A//roymo4/ETXTrackingTest.aspx";
            vw.Cookie = "s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1|2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420";
            vw.ExpectedString = "XboxComTest-Test|Test|999|en-us|TestPage|y|681|1448|1600x1200||||Wed, 16 Mar 2011 23:36:10 UTC 420|http://roymo4/ETXTrackingTest.aspx|s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1,2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420|1294273639243|[CS]v1,2692863385010622-6000010360005961[CE]|VortexDVT/0.1";
            vw.SendRequest();
        }

        [TestCase, Description("Check special characters")]
        public void SpecialChars()
        {
            VortexWeb vw = new VortexWeb(url);
            vw.CustomQS = "?evt=Test&evn=0&loc=en-us&page=TestPage&cookies=y&ht=681&wd=1448&res=1600x1200&dt=Wed%2C%2016%20Mar%202011%2023%3A36%3A10%20UTC%20420&url=http%3A//roymo4/ETXTrackingTest.aspx";
            vw.Cookie = "s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1|2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420";
            vw.ExpectedString = "XboxComTest-Test|Test|0|en-us|TestPage|y|681|1448|1600x1200||||Wed, 16 Mar 2011 23:36:10 UTC 420|http://roymo4/ETXTrackingTest.aspx|s_pers=%20s_nr%3D1294273639230-New%7C1296865639230%3B%20s_vnum%3D1325809639232%2526vn%253D1%7C1325809639232%3B%20s_invisit%3Dtrue%7C1294275439237%3B; s_nr=1294273639243; s_vi=[CS]v1,2692863385010622-6000010360005961[CE]; UtcOffsetMinutes=-420|1294273639243|[CS]v1,2692863385010622-6000010360005961[CE]|VortexDVT/0.1";
            vw.SendRequest();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\VortexProtocol.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.STFLive;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;
using xonline.common.stfutil;
using xonline.common.protocol;

namespace xonline.test.vortex
{
    [TestGroup, Owner("wisgt"), Description("Actual Vortex protocol test cases")]    
    [CompoundCase("RawProtocol", "None")]    
    [CompoundCase("ThroughVortex", "VortexSvc")]
    public class VortexProtocolTests : TestNode
    {        
        public enum ToggleFields
        {
            Fields = 1,
            SpecialFields = 2,
            Both = 3
        }

        public override void PreRun()
        {
            if (MyValues[0].ToString() != "None")
            {
                BaseXomListener.StartXomListener(VortexUtil.vortex_Component, "VortexOutput", VortexUtil.vortex_Interface);
                BaseXomListener.StartXomListener(VortexUtil.vortex_Component, "VortexOutputUnknown", VortexUtil.vortex_Interface);
            }            
        }        

        public override void PostRun()
        {
            BaseXomListener.StopAllXomListeners();
        }        

        public static string BuildUrl(string apiName)
        {
            string url;
            IPEndPoint viIP;

            viIP = Global.XEnv.GetVirtualInterface(VortexUtil.vortex_VirtualInterface);
            url = "http://" + viIP.ToString() + "/vortex/" + apiName;

            Global.RO.Debug(url);
            return url;
        }

        public static void TryFeedThroughVortex(VortexEtxMessage message, bool expectSuccess)
        {            
            /*
            VortexUDPBinary udpBinary = new VortexUDPBinary(VortexUtil.vortex_VirtualInterface);
            udpBinary.UseDirect = true;
            udpBinary.CustomMessage = message;
            udpBinary.ValidateNotProcessed = !expectSuccess;
            */

            //VortexHTTPBinary httpBinary = new VortexHTTPBinary(LogstringBase.BuildUrl("logbinary.ashx"));

            VortexHTTPBinary httpBinary = new VortexHTTPBinary(BuildUrl("LogBinary.ashx"));
            httpBinary.CustomMessage = message;
            httpBinary.ValidateNotProcessed = !expectSuccess;

            //udpBinary.SendRequest();            
            httpBinary.SendRequest();            
        }
                
        /// <summary>
        /// Playing around with fields and events. 
        /// </summary>        
        /// 
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies fields and event logic.")]
        [AsyncGroup(8, 8)]
        //ToggleFields: 0 is nothing, 1 is regular fields, 2 is special fields, 3 is both
        //#Varints| #Blobs | #Singles | #Doubles | #String | #SVarInt |  blob length | #events  |ToggleFields 
        [CompoundCase("Varint",             1, 0, 0, 0, 0, 0, 5, 1,   ToggleFields.Fields)]
        [CompoundCase("SVarint",            0, 0, 0, 0, 0, 1, 5, 1, ToggleFields.Fields)]
        [CompoundCase("String",             0, 0, 0, 0, 1, 0, 5, 1, ToggleFields.Fields)]
        [CompoundCase("Blob",               0, 1, 0, 0, 0, 0, 5, 2, ToggleFields.Fields)]
        [CompoundCase("Single",             0, 0, 1, 0, 0, 0, 5, 2, ToggleFields.Fields)]
        [CompoundCase("Double",             0, 0, 0, 1, 0, 0, 5, 2, ToggleFields.Fields)]
        [CompoundCase("VarintBlob",         2, 2, 0, 0, 0, 0, 5, 2, ToggleFields.Fields)]
        [CompoundCase("VarintSingle",       2, 0, 2, 0, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("VarintDouble",       2, 0, 0, 2, 0, 0, 5, 3, ToggleFields.Both)]
        [CompoundCase("VarintVarInt",       2, 0, 0, 0, 0, 0, 0, 2, ToggleFields.Both)]
        [CompoundCase("BlobSingle",         0, 2, 2, 0, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("BlobDouble",         0, 2, 0, 2, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("BlobBlob",           0, 2, 0, 0, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("SingleDouble",       0, 0, 2, 2, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("SingleSingle",       0, 0, 2, 0, 0, 0, 5, 2, ToggleFields.Both)]        
        [CompoundCase("DoubleDouble",       0, 0, 0, 2, 0, 0, 5, 2, ToggleFields.Both)]        
        [CompoundCase("3_Types_VBS",        2, 2, 2, 0, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("3_Types_VBD",        2, 2, 0, 2, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("3_Types_VSD",        2, 0, 2, 2, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("3_Types_SDB",        0, 2, 2, 2, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("4_Types",            2, 2, 2, 2, 0, 0, 5, 2, ToggleFields.Both)]
        [CompoundCase("AllTypes",           2, 2, 2, 2, 2, 2, 5, 2, ToggleFields.Both)]
        [CompoundCase("100Events",          2, 2, 2, 2, 0, 0, 5, 100, ToggleFields.Both)]        
        [CompoundCase("256Fields",          43, 43, 43, 43, 42, 42, 5, 1, ToggleFields.Fields)]        
        [CompoundCase("257Fields",          43, 43, 43, 43, 43, 42, 5, 1, ToggleFields.Fields)]                
        [CompoundCase("1Event",             2, 2, 2, 2, 0, 0, 5, 1, ToggleFields.Both)]        
        [CompoundCase("OnlyFields",         2, 2, 2, 2, 0, 0, 5, 20, ToggleFields.Fields)]
        [CompoundCase("OnlySpecialFields",  2, 2, 2, 2, 0, 0, 5, 15, ToggleFields.SpecialFields)]
        [CompoundCase("BigBlob",            2, 2, 2, 2, 0, 0, 300, 15, ToggleFields.Both)]        
        public class FieldsAndEvents : VortexProtocolBase
        {
            public override void Run()
            {
                MemoryStream ms = new MemoryStream();
                int numVarInts = (int)MyValues[0];
                int numBlobs = (int)MyValues[1];
                int numSingles = (int)MyValues[2];
                int numDoubles = (int)MyValues[3];
                int numStrings = (int)MyValues[4];
                int numSVarInts = (int)MyValues[5];
                int blobLength = (int)MyValues[6];
                int numEvents = (int)MyValues[7];
                ToggleFields toggleFields = (ToggleFields)MyValues[8];                

                int totalFields = numVarInts + numBlobs + numSingles + numDoubles + numStrings + numSVarInts;

                List<VortexEtxEvent> vortexEvents = new List<VortexEtxEvent>();
                
                for (uint j = 0; j < numEvents; j++)
                {
                    List<VortexEtxField> fields = new List<VortexEtxField>();                    

                    int tempNumVarInts = numVarInts;
                    int tempNumSVarInts = numSVarInts;
                    int tempNumStrings = numStrings;
                    int tempNumBlobs = numBlobs;
                    int tempNumSingles = numSingles;
                    int tempNumDoubles = numDoubles;
                    int tempTotalFields = totalFields;
                    //Round robin time!
                    uint ordinal = 1;
                    if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                    {
                        fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.String, VortexEtxEvent.LOGSTRINGID_ORDINAL, "MyTestPrefix")));
                        tempTotalFields++;
                    }

                    while (ordinal <= tempTotalFields)
                    //Round robin time!                    
                    {
                        if (0 < tempNumVarInts--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)                            
                                fields.Add(new VortexEtxField(EtxFieldType.VarInt, ordinal++, (ulong)rand.Next(0, Int32.MaxValue)));                            
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)                           
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.VarInt, ordinal, (ulong)rand.Next(0, Int32.MaxValue)))); //just ints                
                                                        
                        }

                        if (0 < tempNumSingles--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.Single, ordinal++, (float)(7.8f / Convert.ToSingle(rand.Next()))));
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.Single, ordinal, (float)(7.8f / Convert.ToSingle(rand.Next())))));                            
                        }

                        if (0 < tempNumDoubles--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.Double, ordinal++, (double)(7.8 / Convert.ToDouble(rand.Next()))));
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.Double, ordinal, (double)(7.8 / Convert.ToDouble(rand.Next())))));                            
                        }

                        if (0 < tempNumBlobs--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.Blob, ordinal++, VortexUtil.GenerateRandomBlob(blobLength))); 
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.Blob, ordinal, VortexUtil.GenerateRandomBlob(blobLength)))); //just ints                                                    
                        }

                        if (0 < tempNumSVarInts--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, ordinal++, rand.Next()));
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.SVarInt, ordinal, rand.Next()))); //just ints                                            
                        }

                        if (0 < tempNumStrings--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.String, ordinal++, rand.Next().ToString()));              
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.String, ordinal, rand.Next().ToString()))); //just ints                                            
                        }
                    }                    
                    vortexEvents.Add(new VortexEtxEvent(fields, new byte[] { 0 }, j));
                    fields.Clear();
                }

                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(vortexEvents);
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;               

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }        
        
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        [CompoundCase("UnusedProtocolType", VortexProtocolType.Unused, "Unrecognized protocol type")]
        [CompoundCase("InvalidProtocolType", VortexProtocolType.Invalid, "Unrecognized protocol type")]        
        public class ProtocolType : VortexProtocolBase
        {
            public override void Run()
            {
                VortexProtocolType type = (VortexProtocolType) MyValues[0];
                string expectedError = (string)MyValues[1];
                
                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 1, rand.Next()));                                

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 0);
                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, type);
                message.Write(ms);
                ms.Position = 0;
                
                message.ReadAndValidateEtxMessages(ms, expectedError);
                
                if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, String.IsNullOrEmpty(expectedError));
            }
        }

         //777 is a magic value for "DateTime.Now"
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        [CompoundCase("HugeBaseTimestamp", Int64.MaxValue, (Int64)777, "Not a valid Win32 FileTime", "Bad Request")]
        [CompoundCase("ZeroBaseTimestamp", (Int64)0, (Int64)777, null, null)]
        [CompoundCase("HugeDeltaTimestamp", (Int64)777, Int64.MaxValue, "Not a valid Win32 FileTime", "Bad Request")]
        [CompoundCase("ZeroDeltaTimestamp", (Int64)777,     (Int64)777,       null, null)]
        [CompoundCase("HugeBaseHugeDelta", Int64.MaxValue, Int64.MaxValue, "Not a valid Win32 FileTime", "Bad Request")]
        [CompoundCase("ZeroBaseZeroDelta", (Int64)0, (Int64)0, null, null)]        
        public class TimeStamps : VortexProtocolBase
        {
            public override void Run()
            {
                long baseTimeStamp = (long)MyValues[0];
                long deltaTimeStamp = (long)MyValues[1];

                if (deltaTimeStamp == 777)
                    deltaTimeStamp = DateTime.Now.ToFileTimeUtc();

                if (baseTimeStamp == 777)
                    baseTimeStamp = DateTime.Now.ToFileTimeUtc(); 
               
                string expectedError = (string)MyValues[2];
                string expectedServerError = (string)MyValues[3];

                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 1, rand.Next()));

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 0);
                etxMessage.DeltaTimestamp = deltaTimeStamp;
                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                etxMessageBatch.BaseTimestamp = baseTimeStamp;
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms, expectedError);

                if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, String.IsNullOrEmpty(expectedServerError));
            }
        }
        
        [AsyncGroup(7,7)]
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies types")]        
        [CompoundCase("UInt16.MinValue",  UInt16.MinValue)]
        [CompoundCase("UInt16.MaxValue",  UInt16.MaxValue)]
        [CompoundCase("UInt32.MinValue",  UInt32.MinValue)]
        [CompoundCase("UInt32.MaxValue",  UInt32.MaxValue)]
        [CompoundCase("UInt64.MinValue",  UInt64.MinValue)]
        [CompoundCase("UInt64.MaxValue",  UInt64.MaxValue)]
        [CompoundCase("Byte.MinValue",    Byte.MinValue)]
        [CompoundCase("Byte.MaxValue",    Byte.MaxValue)]        
        public class VarInt : VortexProtocolBase
        {
            public override void Run()
            {
                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();                
                //Add everything under the sun
                object myVal = MyValues[0];
                fields.Add(new VortexEtxField(EtxFieldType.VarInt, 1, myVal));
                

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 0);
                etxMessage.ProducerId = new byte[] { 0 };
                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);                
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }

        [AsyncGroup(7, 7)]
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Integer cycle.")]        
        public class VarIntCycle : VortexProtocolBase
        {
            public override void Run()
            {                
                int max = Int16.MaxValue;
                int min = Int16.MinValue;

                for (int i = min; i <= max; i++)
                {
                    MemoryStream ms = new MemoryStream();
                    List<VortexEtxField> fields = new List<VortexEtxField>();

                    fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 1, i));
                    if (i >= 0)
                        fields.Add(new VortexEtxField(EtxFieldType.VarInt, 2, (uint)i));

                    VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 0);
                    etxMessage.ProducerId = new byte[] { 0 };
                    VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                    VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                    message.Write(ms);
                    ms.Position = 0;

                    message.ReadAndValidateEtxMessages(ms);
                }
            }
        }
        
        [AsyncGroup(7, 7)]
        [CompoundCase("SByte.MinValue", SByte.MinValue)]
        [CompoundCase("SByte.MaxValue", SByte.MaxValue)]
        [CompoundCase("Int16.MinValue", Int16.MinValue)]
        [CompoundCase("Int16.MaxValue", Int16.MaxValue)]
        [CompoundCase("Int32.MinValue", Int32.MinValue)]
        [CompoundCase("Int32.MaxValue", Int32.MaxValue)]
        [CompoundCase("Int64.MinValue", Int64.MinValue)]
        [CompoundCase("Int64.MaxValue", Int64.MaxValue)]
        public class SVarInt : VortexProtocolBase
        {
            public override void Run()
            {
                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                
                object myVal = MyValues[0];
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 1, myVal));


                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 0);
                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        //[CompoundCase("All0", new byte[] { 0, 0, 0 })]
        [CompoundCase("End", new byte[] { 4, 0, 1 })]
        [CompoundCase("Start", new byte[] { 1, 0, 0 })]
        //[CompoundCase("012", new byte[] { 0, 1, 2 })]
        [CompoundCase("122", new byte[] { 1, 2, 2 })]
        [CompoundCase("121", new byte[] { 1, 2, 1 })]
        [CompoundCase("Middle", new byte[] { 3, 1, 0, 0 })]
        [CompoundCase("MiddleWithTwo", new byte[] { 3, 1, 0, 0, 2, 0, 0 })]
        [CompoundCase("Long", new byte[] { 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0 })]
        [CompoundCase("LongMixed", new byte[] { 4, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 5, 6, 6, 7, 4, 3, 2, 1, 0 })]
        public class ProducerIdRuns : VortexProtocolBase
        {
            public override void Run()
            {
                byte[] ProducerIdSequence = (byte[])MyValues[0];
                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 1, rand.Next()));


                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch();
                byte lastNonZero = 0;
                for (int k = 0; k < ProducerIdSequence.Length; k++)
                {
                    byte val = ProducerIdSequence[k];
                    byte[] arr;
                    if (val != 0)
                    {
                        lastNonZero = val;
                        arr = new byte[] { val };
                    }
                    else
                        arr = new byte[] { };

                    VortexEtxEvent etxMessage = new VortexEtxEvent(fields, arr, (uint)k + 1);
                    if (val == 0 && lastNonZero != 0)
                        etxMessage.ExpectedProducerId = new byte[] { lastNonZero };

                    etxMessageBatch.AddEvent(etxMessage);
                }

                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }


        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        [CompoundCase("0", (uint)0)]
        [CompoundCase("1", (uint)1)]
        [CompoundCase("1000", (uint)1000)]
        [CompoundCase("HugeID", UInt32.MaxValue)]
        public class ProducerID : VortexProtocolBase
        {
            public override void Run()
            {
                uint id = (uint)MyValues[0];

                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 1, rand.Next()));

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, BitConverter.GetBytes(id), 1);
                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }

        //Actual blob length, Reported blob length. #Varints after.
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        [CompoundCase("Match", 3, 3, 2, null)]
        [CompoundCase("OverrunWithData", 3, 4, 2, "local tostrings")]
        [CompoundCase("UnderrunWithData", 4, 3, 2, "end of the stream")]
        [CompoundCase("OverrunWithoutData", 3, 4, 0, "end of the stream")]
        [CompoundCase("UnderrunWithoutData", 4, 3, 0, "end of the stream")]
        public class Blobs : VortexProtocolBase
        {
            public override void Run()
            {
                int length = Convert.ToInt32(MyValues[0]);
                int reportedLength = Convert.ToInt32(MyValues[1]);
                int numberOfVarints = Convert.ToInt32(MyValues[2]);
                string expectedError = (string)MyValues[3];

                BlobTestHelper helper = new BlobTestHelper();
                helper.arr = VortexUtil.GenerateRepeatedBlob(length, 77);
                helper.length = reportedLength;

                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 1, helper));

                for (int k = 0; k < numberOfVarints; k++)
                    fields.Add(new VortexEtxField(EtxFieldType.SVarInt, (uint)k + 2, 1024));

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 0);
                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms, expectedError);

                //if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                //  VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        [CompoundCase("NormalString", "NormalString")]
        [CompoundCase("EmptyString", "")]
        [CompoundCase("UnicodeString", 5)]
        [CompoundCase("HugeUnicodeString", 1000)]
        public class LogstringAndString : VortexProtocolBase
        {
            public override void Run()
            {
                string str;
                if (MyValues[0] is string)
                    str = (string)MyValues[0];
                else
                    str = new VortexUtil.RandomUnicodeString().GetString((int)MyValues[0]);

                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.Special, 1, new VortexEtxField(EtxFieldType.String, VortexEtxEvent.LOGSTRINGID_ORDINAL, str)));
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 2, rand.Next()));
                fields.Add(new VortexEtxField(EtxFieldType.String, 3, str));

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 1);
                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }        

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        [CompoundCase("0", 0)]
        [CompoundCase("1", 1)]
        //[CompoundCase("MaxID", UInt32.MaxValue >> 3)]         //Extremely Bad
        //[CompoundCase("MaxIDMinus1", unchecked((UInt32.MaxValue>>3)-1))]        
        public class FieldId : VortexProtocolBase
        {
            public override void Run()
            {
                uint id = Convert.ToUInt32(MyValues[0]);

                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, id, rand.Next()));

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 0);
                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }


        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies fields and event logic, in many many ways.")]
        public class GodCase : VortexProtocolBase
        {
            public override void Run()
            {
                int cap = 3;
                int iterations = (int)Math.Pow(cap + 1, 7); // 7 positions, 3 possible values on each.
                int numVarInts = -1;
                int numBlobs = -1;
                int numSingles = -1;
                int numDoubles = -1;
                int numStrings = -1;
                int numSVarInts = -1;
                int numEvents = -1;

                //Prepare for crazyness...

                Global.RO.Debug("Running through {0} iterations.", iterations);
                while (iterations-- > 0)
                {
                    while (numVarInts++ < cap || (numVarInts = -1) != -1)
                        while (numBlobs++ < cap || (numBlobs = -1) != -1)
                            while (numSingles++ < cap || (numSingles = -1) != -1)
                                while (numDoubles++ < cap || (numDoubles = -1) != -1)
                                    while (numStrings++ < cap || (numStrings = -1) != -1)
                                        while (numSVarInts++ < cap || (numSVarInts = -1) != -1)
                                            while (numEvents++ < cap || (numEvents = -1) != -1)
                                            {
                                                DoRun(numVarInts, numBlobs, numSingles, numDoubles, numStrings, numSVarInts, numEvents);
                                                iterations--;
                                            }
                }
            }

            public void DoRun(int numVarInts, int numBlobs, int numSingles, int numDoubles, int numStrings, int numSVarInts, int numEvents)
            {
                MemoryStream ms = new MemoryStream();

                int blobLength = 5;

                ToggleFields toggleFields = (ToggleFields.Both);

                int totalFields = numVarInts + numBlobs + numSingles + numDoubles + numStrings + numSVarInts;

                List<VortexEtxEvent> vortexEvents = new List<VortexEtxEvent>();

                for (uint j = 0; j < numEvents; j++)
                {
                    List<VortexEtxField> fields = new List<VortexEtxField>();

                    int tempNumVarInts = numVarInts;
                    int tempNumSVarInts = numSVarInts;
                    int tempNumStrings = numStrings;
                    int tempNumBlobs = numBlobs;
                    int tempNumSingles = numSingles;
                    int tempNumDoubles = numDoubles;
                    int tempTotalFields = totalFields;
                    //Round robin time!
                    uint ordinal = 1;
                    if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                    {
                        fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.String, 1, "MyTestPrefix")));
                        tempTotalFields++;
                    }

                    while (ordinal <= tempTotalFields)
                    {
                        if (0 < tempNumVarInts--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.VarInt, ordinal++, (ulong)rand.Next(0, Int32.MaxValue)));
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.VarInt, ordinal, (ulong)rand.Next(0, Int32.MaxValue)))); //just ints                

                        }

                        if (0 < tempNumSingles--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.Single, ordinal++, (float)(7.8f / Convert.ToSingle(rand.Next()))));
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.Single, ordinal, (float)(7.8f / Convert.ToSingle(rand.Next())))));
                        }

                        if (0 < tempNumDoubles--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.Double, ordinal++, (double)(7.8 / Convert.ToDouble(rand.Next()))));
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.Double, ordinal, (double)(7.8 / Convert.ToDouble(rand.Next())))));
                        }

                        if (0 < tempNumBlobs--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.Blob, ordinal++, VortexUtil.GenerateRandomBlob(blobLength)));
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.Blob, ordinal, VortexUtil.GenerateRandomBlob(blobLength)))); //just ints                                                    
                        }

                        if (0 < tempNumSVarInts--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, ordinal++, rand.Next()));
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.SVarInt, ordinal, rand.Next()))); //just ints                                            
                        }

                        if (0 < tempNumStrings--)
                        {
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.Fields)
                                fields.Add(new VortexEtxField(EtxFieldType.String, ordinal++, rand.Next().ToString()));
                            if (toggleFields == ToggleFields.Both || toggleFields == ToggleFields.SpecialFields)
                                fields.Add(new VortexEtxField(EtxFieldType.Special, ordinal++, new VortexEtxField(EtxFieldType.String, ordinal, rand.Next().ToString()))); //just ints                                            
                        }
                    }

                    vortexEvents.Add(new VortexEtxEvent(fields, VortexUtil.GenerateRandomBlob(blobLength), j));
                    fields.Clear();
                }

                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(vortexEvents);
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);
            }
        }

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        public class VP_0Events : VortexProtocolBase
        {
            public override void Run()
            {
                VortexProtocolType type = VortexProtocolType.DistMon;

                MemoryStream ms = new MemoryStream();

                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch();
                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, type);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, false);
            }
        }        

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        public class EventId_OutOfOrderAndGaps : VortexProtocolBase
        {
            public override void Run()
            {

                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 1, rand.Next()));

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 5);
                VortexEtxEvent etxMessage2 = new VortexEtxEvent(fields, 3);
                VortexEtxEvent etxMessage3 = new VortexEtxEvent(fields, 8);

                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);
                etxMessageBatch.AddEvent(etxMessage2);
                etxMessageBatch.AddEvent(etxMessage3);

                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        public class FieldId_OutOfOrderAndGaps : VortexProtocolBase
        {
            public override void Run()
            {

                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 9, rand.Next()));
                fields.Add(new VortexEtxField(EtxFieldType.VarInt, 3, (uint)rand.Next(0,Int32.MaxValue)));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 2, VortexUtil.GenerateRandomBlob(5)));
                fields.Add(new VortexEtxField(EtxFieldType.String, 7, rand.Next().ToString()));
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 4, rand.Next()));
                

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 1);                

                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);                

                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }                

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Verifies error scenarios for protocol types.")]
        public class FieldId_Duplicate : VortexProtocolBase
        {
            public override void Run()
            {
                MemoryStream ms = new MemoryStream();
                byte[] Blob1 = VortexUtil.GenerateRandomBlob(5);
                byte[] Blob2 = VortexUtil.GenerateRandomBlob(5);
                uint varint = (uint)rand.Next(0, Int32.MaxValue);
                int svarint = rand.Next();
                float floatVal = (float)(7.8f / Convert.ToSingle(rand.Next()));
                double doubleVal = (double)(7.8d / Convert.ToSingle(rand.Next()));

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 1, Blob1));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 1, Blob2));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 2, Blob1));
                fields.Add(new VortexEtxField(EtxFieldType.VarInt, 2, varint));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 3, Blob1));
                fields.Add(new VortexEtxField(EtxFieldType.String, 3, "Value"));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 4, Blob1));
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 4, svarint));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 5, Blob1));
                fields.Add(new VortexEtxField(EtxFieldType.Single, 5, floatVal));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 6, Blob1));
                fields.Add(new VortexEtxField(EtxFieldType.Double, 6, doubleVal));
                //Reverse now                                
                fields.Add(new VortexEtxField(EtxFieldType.VarInt, 7, varint));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 7, Blob2));
                fields.Add(new VortexEtxField(EtxFieldType.String, 8, "Value"));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 8, Blob2));
                fields.Add(new VortexEtxField(EtxFieldType.SVarInt, 9, svarint));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 9, Blob2));
                fields.Add(new VortexEtxField(EtxFieldType.Single, 10, floatVal));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 10, Blob2));
                fields.Add(new VortexEtxField(EtxFieldType.Double, 11, doubleVal));
                fields.Add(new VortexEtxField(EtxFieldType.Blob, 11, Blob2));
                
                

                List<VortexEtxField> expectedFields = new List<VortexEtxField>();

                expectedFields.Add(new VortexEtxField(EtxFieldType.Blob, 1, Blob2));
                expectedFields.Add(new VortexEtxField(EtxFieldType.VarInt, 2, varint));
                expectedFields.Add(new VortexEtxField(EtxFieldType.String, 3, "Value"));
                expectedFields.Add(new VortexEtxField(EtxFieldType.SVarInt, 4, svarint));
                expectedFields.Add(new VortexEtxField(EtxFieldType.Single, 5, floatVal));
                expectedFields.Add(new VortexEtxField(EtxFieldType.Double, 6, doubleVal));
                //Reverse now                                                
                expectedFields.Add(new VortexEtxField(EtxFieldType.Blob, 7, Blob2));
                expectedFields.Add(new VortexEtxField(EtxFieldType.Blob, 8, Blob2));
                expectedFields.Add(new VortexEtxField(EtxFieldType.Blob, 9, Blob2));
                expectedFields.Add(new VortexEtxField(EtxFieldType.Blob, 10, Blob2));
                expectedFields.Add(new VortexEtxField(EtxFieldType.Blob, 11, Blob2));
                

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 5);                

                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);                

                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                etxMessage.Fields = expectedFields;
                message.ReadAndValidateEtxMessages(ms);

                if (Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }
        }
        
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
        public class VPGuid : VortexProtocolBase
        {

            public override void Run()
            {
                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.Guid, 1, Guid.NewGuid()));                                               

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 5);

                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);

                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;
                
                message.ReadAndValidateEtxMessages(ms);

                if (Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }

        }

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Sends a raw datetime object as a vortex field.")]
        public class VPDateTime : VortexProtocolBase
        {

            public override void Run()
            {
                MemoryStream ms = new MemoryStream();

                List<VortexEtxField> fields = new List<VortexEtxField>();
                fields.Add(new VortexEtxField(EtxFieldType.DateTime, 1, DateTime.Now));

                VortexEtxEvent etxMessage = new VortexEtxEvent(fields, 5);

                VortexEtxEventBatch etxMessageBatch = new VortexEtxEventBatch(etxMessage);

                VortexEtxMessage message = new VortexEtxMessage(etxMessageBatch, VortexProtocolType.DistMon);
                message.Write(ms);
                ms.Position = 0;

                message.ReadAndValidateEtxMessages(ms);

                if (Parent.MyValues[0].ToString() == "VortexSvc")
                    VortexProtocolTests.TryFeedThroughVortex(message, true);
            }

        }        
       
        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement(""), TestFrequency("Manual"), TestCasePriority(1), Description("Test used to measure logstring vs logbinary data size")]
        public class SizeComparison : VortexNode
        {

            public override void Run()
            {
                VortexUDPBinary udp = new VortexUDPBinary(VortexUtil.vortex_Interface);
                VortexLS ls = new VortexLS("http://whatever.com/Blah.ashx");

                Random rand = new Random();

                //CREATELIVEACCOUNT|FA00000012341234|3000084CD700C|3000084CD700C|0|0x80153003|XEN5oi71iie78i5|johnsmith@xbltest.com|98052|103|1|0|FFFE07DE||0|
                ls.AddUpdateParameter(0, DateTime.Now.ToString());
                
                ls.AddUpdateParameter(1, "CREATELIVEACCOUNT");
                ls.AddUpdateParameter(2, "FA00000012341234");
                ls.AddUpdateParameter(3, "3000084CD700C");
                ls.AddUpdateParameter(4, "3000084CD700C");
                ls.AddUpdateParameter(5, "0");
                ls.AddUpdateParameter(6, "0x80153003");
                ls.AddUpdateParameter(7, "XEN5oi71iie78i5");
                ls.AddUpdateParameter(8, "johnsmith@xbltest.com");
                ls.AddUpdateParameter(9, "98052");
                ls.AddUpdateParameter(10, "103");
                ls.AddUpdateParameter(11, "1");
                ls.AddUpdateParameter(12, "0");
                ls.AddUpdateParameter(13, "FFFE07DE");
                ls.AddUpdateParameter(14, "0");                

                udp.AddUpdateParameter(EtxFieldType.String, 1, "CREATELIVEACCOUNT");
                udp.AddUpdateParameter(EtxFieldType.SVarInt, 2, 0xFA00000012341234);
                udp.AddUpdateParameter(EtxFieldType.VarInt, 3, 0x3000084CD700C);
                udp.AddUpdateParameter(EtxFieldType.VarInt, 4, 0x3000084CD700C);
                udp.AddUpdateParameter(EtxFieldType.VarInt, 5, 0);
                udp.AddUpdateParameter(EtxFieldType.VarInt, 6, 0x80153003);
                udp.AddUpdateParameter(EtxFieldType.String, 7, "XEN5oi71iie78i5");
                udp.AddUpdateParameter(EtxFieldType.String, 8, "johnsmith@xbltest.com");
                udp.AddUpdateParameter(EtxFieldType.VarInt, 9, 98052);
                udp.AddUpdateParameter(EtxFieldType.VarInt, 10, 103);
                udp.AddUpdateParameter(EtxFieldType.VarInt, 11, 1);
                udp.AddUpdateParameter(EtxFieldType.VarInt, 12, 0);
                udp.AddUpdateParameter(EtxFieldType.VarInt, 13, 0xFFFE07DE);
                udp.AddUpdateParameter(EtxFieldType.VarInt, 14, 0);                
                
                
                byte[] vrtxP = udp.BuildMessage();
                byte[] lsP = UTF8Encoding.UTF8.GetBytes(ls.BuildContent());

                int vrtxPLength = vrtxP.Length-1;
                while (vrtxPLength != 0 && vrtxP[vrtxPLength] == 0)
                    vrtxPLength--;
                vrtxPLength++;
                Global.RO.Warn("Calculating size for logline:" + ls.BuildContent());
                Global.RO.Warn("Byte size for Vortex protocol:{0}", vrtxPLength);
                Global.RO.Warn("Byte size for logstring protocols:{0}", lsP.Length);
                Global.RO.Warn("{0}% decrease", ((float)(lsP.Length-vrtxPLength) / (float)lsP.Length) * 100);                
            }

        }       

        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement("XblobOnly"), TestFrequency("Manual"), TestCasePriority(1), Description("Takes data from the etx client folder and sends it over to vortex server side. NOT A REAL TEST CASE RIGHT NOW.")]
        public class ClientDataTest : VortexNode
        {
            public override void OneTimeCleanup()
            {
                base.OneTimeCleanup();
            }
            public override void Run()
            {
                try
                {
                    string path = "SuitesData\\Vortex\\EtxClientData";

                    DirectoryInfo dInfo = new DirectoryInfo(path);
                    FileInfo[] info = dInfo.GetFiles("*.etx");

                    foreach (FileInfo file in info)
                    {
                        byte[] rawBytes = File.ReadAllBytes(file.FullName);
                        VortexHTTPBinary vrtxHttp = new VortexHTTPBinary(BuildUrl("LogBinary.ashx"));
                        vrtxHttp.CustomContent = rawBytes;
                        vrtxHttp.ExpectedResultOverrides = new string[] { "temporaryfail" };

                        MemoryStream str = new MemoryStream(rawBytes);

                        try
                        {
                            List<VxEvent> evts = VxProtocol.ReadStream(str);

                            Global.RO.Debug("Sending the following events to Vortex.");
                            foreach (VxEvent evt in evts)
                                Global.RO.Debug("{0}\r\n", evt.ToString());

                            vrtxHttp.SendRequest();
                        }
                        finally
                        {
                            str.Close();
                        }
                    }                    
                }
                catch (Exception)
                {
                    //Not a test case.
                }
            }
        }       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\VortexPrivacy.cs ===
namespace xonline.test.vortex
{
    using ServerTestFramework;
    using xonline.common.core.etx;
    using System;
    using ServerTestFramework.LiveService.Vortex;
    using System.Linq;
    using System.Collections.Generic;

    [TestGroup, Owner("jkonkle"), Description("Vortex privacy test cases for BingBox DCR.")]
    public class VortexPrivacy : VortexTestGroup
    {
        protected static string PRIVACY_MANIFEST =
            @"<?xml version='1.0' encoding='utf-8'?>
<etxmanifest
    xmlns:win='http://manifests.microsoft.com/win/2004/08/windows/events'
    xmlns:xs='http://www.w3.org/2001/XMLSchema'>
  <instrumentation>
    <globaleventproducers>
      <producer symbol='VortexTestProducer' id='FFFE07D1'>
        <description>Vortex testing producer for BingBox DCR</description>
        <events>
          <event category='Standard' index='0' value='1' symbol='BingBoxLBI' logstringid='BingBoxLBI' header='5'>
            <description>BingBox LBI test</description>
            <metadata>
                <privacy treatments='LBI' />
            </metadata>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString'/>
              <data ordinal='2' name='StringValue' inType='AnsiString'/>
              <data ordinal='3' name='SgNonce' inType='UInt64' outType='SgNonce'/>
              <data ordinal='4' name='Floken' inType='UInt64' outType='FlowToken'/>
              <data ordinal='5' name='IP' inType='UInt32' outType='Ipv4Address'/>
              <data ordinal='6' name='Xuid' inType='UInt64' outType='Xuid'/>
              <data ordinal='7' name='LBIGuid' inType='GUID' outType='LBIOnlyGUID'/>
            </datafields>
          </event>          
          <event category='Standard' index='1' value='2' symbol='BingBoxMBI' logstringid='BingBoxMBI' header='5'>
            <description>MBI output for BingBox tests</description>
            <metadata>
                <privacy treatments='MBI' />
            </metadata>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString'/>
              <data ordinal='2' name='StringValue' inType='AnsiString'/>
              <data ordinal='3' name='SgNonce' inType='UInt64' outType='SgNonce'/>
              <data ordinal='4' name='Floken' inType='UInt64' outType='FlowToken'/>
              <data ordinal='5' name='IP' inType='UInt32' outType='Ipv4Address'/>
              <data ordinal='6' name='Xuid' inType='UInt64' outType='Xuid'/>
              <data ordinal='7' name='LBIGuid' inType='GUID' outType='LBIOnlyGUID'/>
            </datafields>
          </event>
          <event category='Standard' index='2' value='3' symbol='BingBoxMBILBI' logstringid='BingBoxMBILBI' header='5'>
            <description>BingBox MBI LBI test</description>
            <metadata>
                <privacy treatments='LBI,MBI' />
            </metadata>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString'/>
              <data ordinal='2' name='StringValue' inType='AnsiString'/>
              <data ordinal='3' name='SgNonce' inType='UInt64' outType='SgNonce'/>
              <data ordinal='4' name='Floken' inType='UInt64' outType='FlowToken'/>
              <data ordinal='5' name='IP' inType='UInt32' outType='Ipv4Address'/>
              <data ordinal='6' name='Xuid' inType='UInt64' outType='Xuid'/>
              <data ordinal='7' name='LBIGuid' inType='GUID' outType='LBIOnlyGUID'/>
            </datafields>
          </event>          
          <event category='Standard' index='3' value='4' symbol='BingBoxEmpty' logstringid='BingBoxEmpty' header='5'>
            <description>BingBox empty treatment test</description>
            <metadata>
                <privacy treatments='' />
            </metadata>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString'/>
              <data ordinal='2' name='StringValue' inType='AnsiString'/>
              <data ordinal='3' name='SgNonce' inType='UInt64' outType='SgNonce'/>
              <data ordinal='4' name='Floken' inType='UInt64' outType='FlowToken'/>
              <data ordinal='5' name='IP' inType='UInt32' outType='Ipv4Address'/>
              <data ordinal='6' name='Xuid' inType='UInt64' outType='Xuid'/>
              <data ordinal='7' name='LBIGuid' inType='GUID' outType='LBIOnlyGUID'/>
            </datafields>
          </event>          
          <event category='Standard' index='4' value='5' symbol='BingBoxBogus' logstringid='BingBoxBogus' header='5'>
            <description>BingBox bogus value test</description>
            <metadata>
                <privacy treatments='XBI' />
            </metadata>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString'/>
              <data ordinal='2' name='StringValue' inType='AnsiString'/>
              <data ordinal='3' name='SgNonce' inType='UInt64' outType='SgNonce'/>
              <data ordinal='4' name='Floken' inType='UInt64' outType='FlowToken'/>
              <data ordinal='5' name='IP' inType='UInt32' outType='Ipv4Address'/>
              <data ordinal='6' name='Xuid' inType='UInt64' outType='Xuid'/>
              <data ordinal='7' name='LBIGuid' inType='GUID' outType='LBIOnlyGUID'/>
            </datafields>
          </event>          
          <event category='Standard' index='5' value='6' symbol='BingBoxLBIBogus' logstringid='BingBoxLBIBogus' header='5'>
            <description>BingBox LBI and a bogus value test</description>
            <metadata>
                <privacy treatments='LBI,XBI' />
            </metadata>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString'/>
              <data ordinal='2' name='StringValue' inType='AnsiString'/>
              <data ordinal='3' name='SgNonce' inType='UInt64' outType='SgNonce'/>
              <data ordinal='4' name='Floken' inType='UInt64' outType='FlowToken'/>
              <data ordinal='5' name='IP' inType='UInt32' outType='Ipv4Address'/>
              <data ordinal='6' name='Xuid' inType='UInt64' outType='Xuid'/>
              <data ordinal='7' name='LBIGuid' inType='GUID' outType='LBIOnlyGUID'/>
            </datafields>
          </event>          
        </events>
      </producer>
    </globaleventproducers>
  </instrumentation>
</etxmanifest>";

        protected static readonly string binaryUrl = LogstringBase.BuildUrl("logbinary.ashx");

        public override void OneTimeSetup()
        {
            EtxManifest man = new EtxManifest(System.Xml.Linq.XElement.Parse(PRIVACY_MANIFEST));
            foreach (Producer p in man.Producers)
                EtxManifestServerTestCase.UploadProducer(p, true);
        }
        /// <summary>
        /// BingBox DCR case - tests each of the privacy types with each of the privacy outTypes
        /// </summary>
        [TestCase, TestCasePriority(1), TestFrequency("Daily"), Description("BingBox DCR")]
        [CompoundCase("BingBoxLBI", "BingBoxLBI", 0, PrivacyTreatments.LBI)]
        [CompoundCase("BingBoxMBI", "BingBoxMBI", 1, PrivacyTreatments.MBI)]
        [CompoundCase("BingBoxMBILBI", "BingBoxMBILBI", 2, PrivacyTreatments.LBI | PrivacyTreatments.MBI)]
        [CompoundCase("BingBoxEmpty", "BingBoxEmpty", 3, PrivacyTreatments.PassThrough)]
        [CompoundCase("BingBoxBogus", "BingBoxBogus", 4, PrivacyTreatments.LBI)]
        [CompoundCase("BingBoxLBIBogus", "BingBoxLBIBogus", 5, PrivacyTreatments.LBI)]
        public class BingBox : VortexNode
        {
            public override void Run()
            {
                EtxManifest man = new EtxManifest(System.Xml.Linq.XElement.Parse(PRIVACY_MANIFEST));
                
                VortexHTTPBinary vp = new VortexHTTPBinary(binaryUrl);
                vp.EtxEventManifest = man;
                 
                vp.ProducerID = man.Producers.First().Fingerprint;

                int temp = (int)MyValues[1];
                uint eventNum = (uint)temp;

                vp.AddUpdateParameter(eventNum, new VortexEtxField(EtxFieldType.String, 1, MyValues[0]));
                vp.AddUpdateParameter(eventNum, new VortexEtxField(EtxFieldType.String, 2, "Blah"));
                vp.AddUpdateParameter(eventNum, new VortexEtxField(EtxFieldType.VarInt, 3, UInt64.MaxValue));
                vp.AddUpdateParameter(eventNum, new VortexEtxField(EtxFieldType.VarInt, 4, UInt64.MaxValue));
                vp.AddUpdateParameter(eventNum, new VortexEtxField(EtxFieldType.VarInt, 5, UInt32.MaxValue));
                vp.AddUpdateParameter(eventNum, new VortexEtxField(EtxFieldType.VarInt, 6, UInt64.MaxValue));
                vp.AddUpdateParameter(eventNum, new VortexEtxField(EtxFieldType.Guid, 7, Guid.NewGuid()));
                vp.BuildContent();
                vp.PrivacyTreatment = (PrivacyTreatments)MyValues[2];
                
                vp.SendRequest(true);
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\vortex.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Cache;
using System.Net.Security;
using System.Web;
using System.Web.Hosting;
using System.IO;
using System.Net.Sockets; //Remove me
using System.Text;
using System.Threading;
using System.ServiceProcess;
using System.Xml;
using System.Linq;

using ServerTestFramework;
using ServerTestFramework.STFLive;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using System.Data;
using System.Data.Sql;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.stfutil;
using xonline.common.core.etx;

namespace xonline.test.vortex
{

    [TestGroup, Owner("wisgt"), Description("Test cases around the protocols supported by Vortex.")]
    public class ProtocolTests : TestNode
    {
        [TestGroup, Owner("wisgt"), Description("Logstring 2 endpoint Vortex test cases")]
        [AsyncGroup(1, 1)]
        public class LogString2 : VortexTestGroup
        {
            #region LS2 cases

            #region input cases



            /// <summary>
            /// Basic test case, goes through vortex, verifies the pipeline works. If this doesn't work, something is screwy.
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
            public class LS2_Basic : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.AddUpdateParameter(LS2Fields.Area, "LS2_Basic");

                    ls2.SendRequest();
                }
            }

            /// <summary>
            /// Basic test case, goes through vortex, verifies the pipeline works. If this doesn't work, something is screwy.
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
            public class LS2_DuplicateIDs : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);
                    ls2.CustomQS = "?v1=value1&v1=value2&v2=v2&v1=value3&v2=v22";

                    ls2.SendRequest();
                }
            }

            /// <summary>
            /// Basic test case, goes through vortex, verifies the pipeline works. If this doesn't work, something is screwy.
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
            public class LS2_UppercaseV1 : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);
                    ls2.CustomQS = "?V1=v1&v2=v2";

                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Empty area.")]
            public class LS2_EmptyCategory : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.GenerateParameters(20);
                    ls2.AddUpdateParameter(LS2Fields.Area, "");
                    ls2.ValidateNotProcessed = true;
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("No parameters.")]
            public class LS2_NoParams : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);
                    ls2.ValidateNotProcessed = true;
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("1 non-area parameter.")]
            public class LS2_1Param_NotID : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.AddUpdateParameter(7, "Blah");
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Same as the basic case, but with keepalive on.")]
            public class LS2_BasicCase_KeepAlive : Logstring2Base
            {

                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);
                    ls2.KeepAlive = true;

                    ls2.AddUpdateParameter(LS2Fields.Area, "TestArea");

                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("20 total parameters, ignores type just generates strings.")]
            public class LS2_GeneratedParams : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.GenerateParameters(20);

                    ls2.AddUpdateParameter(LS2Fields.Area, "LS2_GeneratedParams");

                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Sends an empty query string.")]
            public class LS2_EmptyQS : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);
                    ls2.CustomQS = "?";
                    ls2.ValidateNotProcessed = true;
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Sends a null query string.")]
            public class LS2_NoQS : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);
                    ls2.CustomQS = "";
                    ls2.ValidateNotProcessed = true;
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Sends a bunch of separator characters.")]
            public class LS2_OnlySeparators : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.CustomQS = "?&&&&&&&&&&&&&&&&&&&&&&&&&&&&";
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Only & characters, basically empty key value pairs.")]
            public class LS2_OnlySeparatorsWithEquals : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.CustomQS = "?&=&=&=&=&=&=&=&=&=&=&=&=&=&=";
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Nasty querystring.")]
            public class LS2_MalformedQS : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.CustomQS = "?^?^?^?%?%?%?^?T%^?%^?&^??%&^%&^?%^?%&?^%?&?^%?%&?";
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Format tags to mess with String.Format calls")]
            public class LS2_FormatTags : Logstring2Base
            {
                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.CustomQS = "?v1={0}{1}{500}Ohyeah";

                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Escaped format tags to mess with String.Format calls")]
            public class LS2_EscapedFormatTags : Logstring2Base
            {

                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.CustomQS = "?v1={{0}}{{1}}{{500}}Ohyeah";

                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Logstring2 named field test.")]
            public class LS2_NamedFields : Logstring2Base
            {

                public override void Run()
                {
                    //@@@Add more combinations.
                    VortexLS2 ls2 = new VortexLS2(url);
                    ls2.CustomQS = "?events=blah&v1=eventstest&stuff=jerk&v2=boop&bloop=blah&stuff=jerk";
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Logstring2 with sparse fields. It should do stuff like |Field1||||Field5 but on a larger scale")]
            public class LS2_Sparse : Logstring2Base
            {

                public override void Run()
                {
                    //@@@Add more combinations.
                    VortexLS2 ls2 = new VortexLS2(url);
                    ls2.AddUpdateParameter(1, "first");
                    ls2.AddUpdateParameter(103, "second, far away!");
                    ls2.SendRequest();
                }
            }
            #endregion

            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("A few additional parameters.")]
            public class LS2_MultipleParams : Logstring2Base
            {

                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);
                    ls2.AddUpdateParameter(LS2Fields.Area, "LS2_MultipleParams");
                    ls2.AddUpdateParameter(2, "foo");
                    ls2.AddUpdateParameter(3, "bar");
                    ls2.AddUpdateParameter(4, "1");
                    ls2.AddUpdateParameter(5, "0xFFFE07D1");
                    ls2.AddUpdateParameter(6, DateTime.Now.ToString());
                    ls2.SendRequest();
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Loops over ASCII chars 0 through 127.")]
            public class LS2_SpecialCharacters_Value : Logstring2Base
            {

                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);

                    ls2.AddUpdateParameter(LS2Fields.Area, "LS2_SpecialCharacters");

                    //0-100 Splitting them up to not go over the max query string limit. Most of these are encoded when sending the request.
                    StringBuilder val = new StringBuilder(String.Empty); //Throw in non-alphabetical ASCII and extended chars
                    for (int k = 1; k <= 100; k++)
                        val.Append((char)k);

                    ls2.AddUpdateParameter(3, val.ToString());
                    ls2.SendRequest();

                    //101-200
                    val = new StringBuilder(String.Empty); //Throw in non-alphabetical ASCII and extended chars
                    for (int k = 101; k <= 125; k++)
                        val.Append((char)k);

                    ls2.AddUpdateParameter(3, val.ToString());
                    ls2.SendRequest();

                    /*128-255 death
                    val = new StringBuilder(String.Empty); //Throw in non-alphabetical ASCII and extended chars
                    for (int k = 201; k <= 255; k++)
                        val.Append((char)k);

                    ls2.AddUpdateParameter(3, val.ToString());
                    ls2.SendRequest();
                     */
                }
            }

            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Non alphabetic characters in the ID field.")]
            public class LS2_SpecialCharacters_Key : Logstring2Base
            {

                public override void Run()
                {
                    VortexLS2 ls2 = new VortexLS2(url);
                    string funkyKVP = HttpUtility.UrlEncode("let'strythis;\n");
                    funkyKVP += "=value";
                    ls2.CustomQS = String.Format("?v1=LS2_SpecialCharacters_Key&{0}", funkyKVP);
                    ls2.SendRequest();
                }
            }

            #endregion LS2 cases
        }

        [TestGroup, Owner("wisgt"), Description("Logstring endpoint Vortex test cases")]
        public class LogString : VortexTestGroup
        {
            #region LS cases

            [TestGroup, Owner("wisgt"), Description("Unbatched test cases - single lines.")]
            [AsyncGroup(2, 2)]
            public class NonBatched : VortexTestGroup
            {
                /// <summary>
                /// Basic case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
                public class LS_Basic : LogstringBase
                {

                    public override void Run()
                    {
                        VortexLS ls = new VortexLS(url);

                        ls.AddUpdateParameter(1, "LS_BaseCase");
                        ls.AddUpdateParameter(2, Convert.ToString(DateTime.UtcNow.ToFileTimeUtc(), 16));

                        ls.SendRequest();
                    }

                }

                /// <summary>
                /// Basic case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
                public class LS_XML : LogstringBase
                {
                    public override void Run()
                    {
                        VortexLS ls = new VortexLS(url);

                        ls.AddUpdateParameter(1, testUploadXml.Replace("'", "\""));
                        ls.ValidateNotProcessed = true;

                        ls.SendRequest();
                    }
                }

                /// <summary>
                /// Basic case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
                public class LS_XML_FakeBinary : LogstringBase
                {
                    public override void Run()
                    {
                        try
                        {
                            VortexLS ls = new VortexLS(url.Replace("LogString.ashx", "LogBinary.ashx"));

                            ls.AddUpdateParameter(1, testUploadXml.Replace("'", "\""));
                            ls.UseXRL = false;
                            ls.ValidateNotProcessed = true;

                            ls.SendRequest();
                        }
                        catch (WebException ex)
                        {
                            //Check for BadRequest
                            if (ex.Response == null || !(((HttpWebResponse)ex.Response).StatusCode == HttpStatusCode.BadRequest))
                                throw;
                            else
                                ro.Debug("Obtained the expected error status code.");
                        }
                    }
                }

                /// <summary>
                /// Basic case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, with an empty string as the first field and validates that it is not received.")]
                public class LS_EmptyID : LogstringBase
                {

                    public override void Run()
                    {
                        VortexLS ls = new VortexLS(url);

                        ls.AddUpdateParameter(1, String.Empty);
                        ls.AddUpdateParameter(2, Convert.ToString(DateTime.UtcNow.ToFileTimeUtc(), 16));
                        ls.ValidateNotProcessed = true;

                        ls.SendRequest();
                    }

                }

                [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Weird Unicode characters, oh no!!")]
                public class LS_Unicode : LogstringBase
                {
                    public override void Run()
                    {
                        VortexLS ls = new VortexLS(url);

                        ls.AddUpdateParameter(3, "LS2_SpecialCharacters");
                        VortexUtil.RandomUnicodeString r = new VortexUtil.RandomUnicodeString();
                        string val = r.GetString(10);
                        ls.AddUpdateParameter(2, "id!!");
                        ls.AddUpdateParameter(3, val);
                        ls.SendRequest();
                    }
                }

                /// <summary>
                /// Basic case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("No http content.")]
                public class LS_EmptyContent : LogstringBase
                {
                    public override void Run()
                    {
                        VortexLS ls = new VortexLS(url);

                        ls.CustomContent = String.Empty;
                        ls.ValidateNotProcessed = true;
                        ls.SendRequest();
                    }
                }

                /// <summary>
                /// Basic case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Similar to LS_EmptyContent, but this one has the first few bytes specifying 0 length rather than completely empty content.")]
                public class LS_EmptyLogstrings : LogstringBase
                {
                    public override void Run()
                    {
                        VortexLS ls = new VortexLS(url);
                        ls.ValidateNotProcessed = true;
                        //This will generate a logstring call with a body that has the first 2 bytes set to 0 to indicate zero length, and nothing else.
                        ls.SendRequest();
                    }
                }
            }

            [TestGroup, Owner("wisgt"), Description("Batched test cases - multiple lines.")]
            public class Batched : VortexTestGroup
            {
                /// <summary>
                /// Basic batched case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Basic case, but with 100 batched lines. This should output 100 events.")]
                public class LS_BasicBatched : LogstringBase
                {

                    public override void Run()
                    {
                        try
                        {
                            BaseXomListener.Logging = false; //Too chatty in this case
                            VortexLSBatch batch = new VortexLSBatch(url);
                            ro.Debug("Preparing 100 requests in a batch.");
                            for (int k = 0; k < 100; k++)
                            {
                                VortexLS lsLine = new VortexLS(url);
                                lsLine.AddUpdateParameter(1, "LS_BaseCaseLine" + k.ToString());
                                lsLine.AddUpdateParameter(2, Convert.ToString(DateTime.UtcNow.ToFileTimeUtc(), 16));
                                batch.AddVortexReq(lsLine);
                            }
                            ro.Debug("Sending the requests and validating.");
                            batch.SendBatchedReq();
                        }
                        finally
                        {
                            BaseXomListener.Logging = true; //Too chatty in this case
                        }
                    }

                }

                /// <summary>
                /// Basic batched case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Batched loglines, but some of them are empty strings.")]
                public class LS_BatchedWithEmpties : LogstringBase
                {

                    public override void Run()
                    {
                        VortexLSBatch batch = new VortexLSBatch(url);

                        VortexLS ls1 = new VortexLS(url);
                        VortexLS ls2 = new VortexLS(url);
                        VortexLS ls3 = new VortexLS(url);
                        batch.AddVortexReq(ls1);
                        batch.AddVortexReq(ls2);
                        batch.AddVortexReq(ls3);


                        ro.Debug("First try with all full.");
                        ls1.AddUpdateParameter(1, "LS_BatchedWithEmpties1");
                        ls2.AddUpdateParameter(1, "LS_BatchedWithEmpties2");
                        ls3.AddUpdateParameter(1, "LS_BatchedWithEmpties3");

                        batch.SendBatchedReq();

                        ro.Debug("Now with 1 being clear.");
                        ls1.ClearParameters();
                        ls1.ValidateNotProcessed = true;
                        batch.SendBatchedReq();

                        ro.Debug("Now with 2 being clear.");
                        ls1.AddUpdateParameter(1, "LS_BatchedWithEmpties1");
                        ls1.ValidateNotProcessed = false;
                        ls2.ClearParameters();
                        ls2.ValidateNotProcessed = true;
                        batch.SendBatchedReq();

                        ro.Debug("Now with 3 being clear.");
                        ls2.AddUpdateParameter(3, "LS_BatchedWithEmpties1");
                        ls2.ValidateNotProcessed = false;
                        ls3.ClearParameters();
                        ls3.ValidateNotProcessed = true;
                        batch.SendBatchedReq();
                    }

                }
                /// <summary>
                /// Basic batched case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("400 loglines in one call.")]
                public class LS_HugeBatched : LogstringBase
                {

                    public override void Run()
                    {
                        BaseXomListener.Logging = false; //Too chatty in this case
                        try
                        {
                            VortexLSBatch batch = new VortexLSBatch(url);

                            ro.Debug("Sending 400 requests in a single batch..");
                            for (int k = 0; k < 400; k++)
                            {
                                VortexLS lsLine = new VortexLS(url);
                                lsLine.AddUpdateParameter(1, "LS_BaseCaseLine" + k.ToString());
                                lsLine.AddUpdateParameter(2, Convert.ToString(DateTime.UtcNow.ToFileTimeUtc(), 16));
                                batch.AddVortexReq(lsLine);
                            }

                            ro.Debug("Sending and validating the results.");
                            batch.SendBatchedReq();
                        }
                        finally
                        {
                            BaseXomListener.Logging = true;
                        }
                    }

                }

                [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Huge string. Should go through.")]
                public class LS_HugeNonBatched : LogstringBase
                {

                    public override void Run()
                    {
                        VortexLS ls = new VortexLS(url);

                        StringBuilder crappyString = new StringBuilder(String.Empty);
                        for (int k = 0; k < 500; k++)
                            crappyString.Append("Hello Sir.");
                        ls.AddUpdateParameter(1, "Oh.");
                        ls.AddUpdateParameter(2, crappyString.ToString());
                        ls.SendRequest();
                    }
                }

                /// <summary>
                /// Basic batched case
                /// </summary>
                [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Only end of line characters to send a lot of empty loglines.")]
                public class LS_OnlySeparators : LogstringBase
                {
                    public override void Run()
                    {
                        BaseXomListener.Logging = false; //Too chatty in this case
                        try
                        {
                            VortexLS ls = new VortexLS(url);

                            ro.Debug("Sending only separator characters (EOL).");
                            StringBuilder crappyString = new StringBuilder(String.Empty);
                            for (int k = 0; k < 250; k++)
                                crappyString.Append("\n");

                            ls.AddUpdateParameter(1, crappyString.ToString());

                            ls.SendRequest(false);

                            VortexLS emptyLs = new VortexLS(url);
                            emptyLs.ValidateNotProcessed = true;

                            ro.Debug("Validating the results. We should not receive any empties. One check is sufficient since all 250 would have been the same.");
                        }
                        finally
                        {
                            BaseXomListener.Logging = true;
                        }
                    }
                }
            }

            #endregion LS2 cases
        }

        [TestGroup, Owner("wisgt"), Description("Logstring UDP test cases")]
        public class VortexProtocolUDP : VortexTestGroup
        {
            protected static readonly string url = LogstringBase.BuildUrl("logbinary.ashx");

            #region VPUDP cases
            /// <summary>
            /// Basic case
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
            public class UDP_Types : LogstringBase
            {
                public override void Run()
                {
                    VortexUDPBinaryXRL vp = new VortexUDPBinaryXRL(url);

                    vp.AddUpdateParameter(EtxFieldType.VarInt, 0, (ulong)7777);
                    vp.AddUpdateParameter(EtxFieldType.VarInt, 1, (ulong)8888);
                    vp.AddUpdateParameter(EtxFieldType.SVarInt, 2, 9999);
                    vp.AddUpdateParameter(EtxFieldType.SVarInt, 3, 10101010);
                    vp.AddUpdateParameter(EtxFieldType.Blob, 4, new byte[] { 10, 8, 255, 16 });
                    vp.AddUpdateParameter(EtxFieldType.Single, 5, (float)13);
                    vp.AddUpdateParameter(EtxFieldType.Double, 6, (double)14);
                    vp.SendRequest();
                }
            }


            /// <summary>
            /// Basic case
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
            public class Basic : VortexNode
            {
                public override void Run()
                {
                    VortexUDPBinaryXRL bn = new VortexUDPBinaryXRL(url);

                    bn.AddUpdateParameter(EtxFieldType.VarInt, 0, (ulong)7777);
                    bn.AddUpdateParameter(EtxFieldType.SVarInt, 1, DateTime.UtcNow.ToFileTimeUtc());

                    bn.SendRequest();
                }

            }

            /// <summary>
            /// Basic case
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("No http content.")]
            public class EmptyMessage : VortexNode
            {

                public override void Run()
                {
                    VortexUDPBinaryXRL vp = new VortexUDPBinaryXRL(url);

                    vp.ValidateNotProcessed = true;
                    vp.SendRequest();
                }

            }

#if false //This is killing stuff right now due to a bug.
        /// <summary>
        /// Basic batched case
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Huge string. Should be rejected.")]
        public class UDP_HugeNonBatched : LogstringBase
        {

            public override void Run()
            {
                VortexLS_UDP ls = new VortexLS_UDP(virtualInterface);
                ls.UseDirect = true;
                StringBuilder crappyString = new StringBuilder(String.Empty);
                for (int k = 0; k < 1000; k++)
                    crappyString.Append("Hello Sir.");
                ls.AddUpdateParameter(1, "Oh.");
                ls.AddUpdateParameter(2, crappyString.ToString());
                ls.ValidateNotProcessed = true;
                ls.SendRequest();
            }

        }
#endif
            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Huge string. Should make it!")]
            public class LessHugeNonBatched : VortexNode
            {
                public override void Run()
                {
                    VortexUDPBinaryXRL bn = new VortexUDPBinaryXRL(url);

                    for (uint k = 0; k < 275; k++)
                        bn.AddUpdateParameter(EtxFieldType.VarInt, k, k * 111);
                    bn.SendRequest();
                }
            }

            /// <summary>
            /// Basic case
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
            public class BasicBatched : VortexNode
            {
                public override void Run()
                {
                    VortexUDPBinaryXRL bn = new VortexUDPBinaryXRL(url);

                    Global.RO.Debug("Try with 1, 2, 3 and 4 items.");
                    for (uint k = 0; k < 4; k++)
                    {
                        bn.AddUpdateParameter(k, EtxFieldType.VarInt, 0, (ulong)7777);
                        bn.AddUpdateParameter(k, EtxFieldType.SVarInt, 1, DateTime.UtcNow.ToFileTimeUtc());
                        bn.SendRequest();
                    }
                }
            }
            #endregion VPUDP cases
        }

        [TestGroup, Owner("wisgt"), Description("Logstring UDP test cases")]
        public class VortexProtocolHTTP : VortexTestGroup
        {
            protected static readonly string url = LogstringBase.BuildUrl("logbinary.ashx");

            /// <summary>
            /// Basic case
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
            public class Basic : VortexNode
            {
                public override void Run()
                {
                    VortexHTTPBinary vp = new VortexHTTPBinary(url);

                    vp.AddUpdateParameter(EtxFieldType.VarInt, 0, (uint)7777);
                    vp.AddUpdateParameter(EtxFieldType.SVarInt, 1, -10101010);
                    vp.AddUpdateParameter(EtxFieldType.Blob, 2, new byte[] { 8, 8, 8, 8 });
                    vp.AddUpdateParameter(EtxFieldType.Single, 3, (float)13);
                    vp.AddUpdateParameter(EtxFieldType.Double, 4, (double)14);
                    vp.SendRequest();
                }
            }

            /// <summary>
            /// Basic case
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
            public class XML : VortexNode
            {
                public override void Run()
                {
                    VortexHTTPBinary vp = new VortexHTTPBinary(url);

                    vp.AddUpdateParameter(EtxFieldType.String, 1, testUploadXml.Replace("'", "\""));
                    vp.SendRequest();
                }
            }

            /// <summary>
            /// Basic case
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("No http content.")]
            public class EmptyMessage : VortexNode
            {

                public override void Run()
                {
                    VortexHTTPBinary vp = new VortexHTTPBinary(url);

                    vp.ValidateNotProcessed = true;
                    vp.SendRequest();
                }

            }
            [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Loops over ASCII chars 0 through 127.")]
            public class Vx_SpecialCharacters_Value : Logstring2Base
            {

                public override void Run()
                {
                    VortexHTTPBinary vx = new VortexHTTPBinary(url);

                    vx.AddUpdateParameter(EtxFieldType.String, 1, "Vx_SpecialCharacters");

                    //0-100 Splitting them up to not go over the max query string limit. Most of these are encoded when sending the request.
                    StringBuilder val = new StringBuilder(String.Empty); //Throw in non-alphabetical ASCII and extended chars
                    for (int k = 1; k <= 255; k++)
                        val.Append((char)k);

                    vx.AddUpdateParameter(EtxFieldType.String, 2, val.ToString());
                    vx.SendRequest();
                }
            }

            /// <summary>
            /// Big, but not *too* big.
            /// </summary>
            [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Huge string. Should be rejected.")]
            public class LessHugeNonBatched : VortexNode
            {
                public override void Run()
                {
                    VortexHTTPBinary bn = new VortexHTTPBinary(url);

                    for (uint k = 0; k < 350; k++)
                        bn.AddUpdateParameter(EtxFieldType.VarInt, k, (uint)k * 111);
                    bn.SendRequest();
                }
            }
        }
    }

    [TestGroup, Owner("wisgt"), Description("Vortex stress cases, ready to party.")]
    public class VortexStress : VortexTestGroup
    {
        protected static string STRESS_MANIFEST =
            @"<?xml version='1.0' encoding='utf-8'?>
<etxmanifest
    xmlns:win='http://manifests.microsoft.com/win/2004/08/windows/events'
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
>
  <instrumentation>
    <globaleventproducers>
      <producer symbol='ServerStressTestProducer' id='9898'>
        <description>Description of ServerStressTestProducer</description>
        <events>
          <event category='Standard' index='0' value='1' symbol='BaseBinaryStress' logstringid='BaseBinaryStress' header='2'>
            <description>Description of BaseBinaryStress</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString'/>
              <data ordinal='2' name='StringValue' inType='AnsiString'/>              
            </datafields>
          </event>          
          <event category='Standard' index='1' value='2' symbol='BinaryConsoleBufferSize' logstringid='BinaryConsoleBufferSize' header='2'>
            <description>Description of BinaryConsoleBufferSize</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' />
              <data ordinal='2' name='Type' inType='AnsiString'/>
              <data ordinal='3' name='Num1' inType='UInt32'/>
              <data ordinal='4' name='SNum2' inType='Int32' />
              <data ordinal='5' name='Num3' inType='UInt32' />
              <data ordinal='6' name='SNum4' inType='Int32'/>
              <data ordinal='7' name='Num5' inType='UInt32' />
              <data ordinal='8' name='SNum6' inType='Int32'/>
              <data ordinal='9' name='Num7' inType='UInt32' />
              <data ordinal='10' name='SNum8' inType='Int32'/>
              <data ordinal='12' name='Num9' inType='UInt32'/>
              <data ordinal='13' name='SNum10' inType='Int32'/>
              <data ordinal='14' name='Num11' inType='UInt32'/>
              <data ordinal='15' name='SNum12' inType='Int32'/>              
            </datafields>
          </event>
            <event category='Standard' index='2' value='3' symbol='BinaryConsoleBufferSizeAutoValued' logstringid='BinaryConsoleBufferSizeAutoValued' header='2'>
            <description>Description of BinaryConsoleBufferSize</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString' />
              <data ordinal='2' name='Type' inType='AnsiString'/>
              <data ordinal='3' name='Num1' inType='UInt32'/>
              <data ordinal='4' name='SNum2' inType='Int32' />
              <data ordinal='5' name='Num3' inType='UInt32' />
              <data ordinal='6' name='SNum4' inType='Int32'/>
              <data ordinal='7' name='CountryId' inType='UInt8' autovalue='CountryId' autovaluecreator='LiveService'/>
              <data ordinal='8' name='FlowToken' inType='UInt64' autovalue='FlowToken' autovaluecreator='LiveService'/>
              <data ordinal='9' name='Ipv4Address' inType='AnsiString' autovalue='Ipv4Address' autovaluecreator='LiveService'/>
              <data ordinal='10' name='LanguageId' inType='UInt8' autovalue='LanguageId' autovaluecreator='LiveService'/>
              <data ordinal='11' name='MachineId' inType='UInt64' autovalue='MachineId' autovaluecreator='LiveService'/>
              <data ordinal='12' name='Timestamp' inType='AnsiString' autovalue='Timestamp' autovaluecreator='LiveService'/>
              <data ordinal='13' name='TitleId' inType='UInt32' autovalue='TitleId' autovaluecreator='LiveService'/>              
            </datafields>
          </event>
        </events>
      </producer>
    </globaleventproducers>
  </instrumentation>
</etxmanifest>";

        protected static string STRESS_COMPANION_MANIFEST =
    @"<?xml version='1.0' encoding='utf-8'?>
<etxmanifest
    xmlns:win='http://manifests.microsoft.com/win/2004/08/windows/events'
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
>
  <instrumentation>
    <globaleventproducers>
      <producer symbol='CompanionProducer' id='9999'>
        <description>Description of ServerStressTestProducer</description>
        <events>
          <event category='Standard' value='1' symbol='Companion' logstringid='Companion' header='2' index='0'>
            <description>Description of BaseBinaryStress</description>
            <datafields>
              <data ordinal='1' name='Id' inType='AnsiString'/>
              <data ordinal='2' name='StringValue' inType='AnsiString'/>              
            </datafields>
          </event>                    
        </events>
      </producer>
    </globaleventproducers>
  </instrumentation>
</etxmanifest>";


        protected static readonly string binaryUrl = LogstringBase.BuildUrl("logbinary.ashx");

        public override void OneTimeSetup()
        {
            EtxManifest man = new EtxManifest(System.Xml.Linq.XElement.Parse(STRESS_MANIFEST));
            foreach (Producer p in man.Producers)
                EtxManifestServerTestCase.UploadProducer(p, true);
        }
        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement("Stress"), TestCasePriority(1), TestFrequency("Manual"), Description("It's on now! 400 Loglines fire and forget call. Very nice for stressing the processing layer without putting too much stress on the input layer.")]
        [StressTest]
        [CompoundCase("1", 1)]
        [CompoundCase("10", 10)]
        [CompoundCase("100", 100)]
        [CompoundCase("400", 400)]
        public class LS_BatchedStress : LogstringBase
        {
            public override void Run()
            {
                int loopVal = Convert.ToInt32(MyValues[0]);
                VortexLSBatch batch = new VortexLSBatch(url);

                for (int k = 0; k < loopVal; k++)
                {
                    lock (stressLoopdyLock)
                    {
                        stressLoopdyLoop++;
                        if (stressLoopdyLoop > 1000) //Arbitrary number of simultaneous types for the SI query.
                            stressLoopdyLoop = 0;
                    }

                    VortexLS lsLine = new VortexLS(url);
                    lsLine.GenerateParameters(8);
                    lsLine.AddUpdateParameter(1, "LS_BaseCaseLine" + stressLoopdyLoop.ToString());
                    batch.AddVortexReq(lsLine);
                }

                batch.SendBatchedReq(false);
            }
        }

        [TestCase, EnvRequirement("Stress"), TestCasePriority(1), TestFrequency("Manual"), Description("No HTTPWebRequest. No vaidation. Just turbowrite. Max Steel")]
        [StressTest]
        public class LS2_FastStress : Logstring2Base
        {
            public override void Run()
            {

                VortexLS2 ls2 = new VortexLS2("/vortex/LogString2.ashx");

                IPEndPoint viIP = Global.XEnv.GetVirtualInterface(VortexUtil.vortex_Interface);
                ls2.GenerateParameters(30);

                lock (stressLoopdyLock)
                {
                    stressLoopdyLoop++;
                    if (stressLoopdyLoop >= 1000) //Arbitrary number of simultaneous types for the SI query.
                        stressLoopdyLoop = 0;

                    ls2.AddUpdateParameter(LS2Fields.Area, stressLoopdyLoop.ToString());
                }

                ls2.SendRequestFast(viIP, true);
            }
        }

        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement("Stress"), TestCasePriority(2), TestFrequency("Manual"), Description("Basic stress case with one logline.")]
        [StressTest]
        [CompoundCase("1", 1)]
        [CompoundCase("10", 10)]
        [CompoundCase("100", 100)]
        [CompoundCase("400", 400)]
        public class HttpBinaryStress : VortexNode
        {
            public override void Run()
            {
                int loopVal = Convert.ToInt32(MyValues[0]);
                VortexEtxEventBatch batch = new VortexEtxEventBatch();

                for (int k = 0; k < loopVal; k++)
                {
                    lock (stressLoopdyLock)
                    {
                        stressLoopdyLoop++;
                        if (stressLoopdyLoop > 1000)
                            stressLoopdyLoop = 0;
                    }

                    VortexHTTPBinary vp = new VortexHTTPBinary(binaryUrl);
                    vp.ProducerID = BitConverter.GetBytes(Convert.ToInt32("0x9898", 16)).Reverse().ToArray();
                    vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 1, "BaseBinaryStress"));
                    vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.VarInt, 2, stressLoopdyLoop));
                    vp.BuildContent();

                    batch.AddEvent(vp.SentMessage.Batch.Events[0]);
                    batch.Events[batch.Events.Count - 1].EventId = 1;
                }

                VortexEtxMessage etxMessage = new VortexEtxMessage(batch, VortexProtocolType.DistMon);

                VortexHTTPBinary vpBatch = new VortexHTTPBinary(binaryUrl);
                vpBatch.CustomMessage = etxMessage;
                //vpBatch.SendRequestFast(Global.XEnv.GetVirtualInterface(VortexUtil.vortex_Interface), true);
                vpBatch.SendRequest(false);
            }
        }

        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement("Stress"), TestCasePriority(2), TestFrequency("Manual"), Description("Basic stress case with one logline.")]
        [StressTest]
        [CompoundCase("1", 1)]
        [CompoundCase("10", 10)]
        [CompoundCase("100", 100)]
        [CompoundCase("400", 400)]
        public class UDPBinaryStress : VortexNode
        {
            public override void Run()
            {
                int loopVal = Convert.ToInt32(MyValues[0]);
                VortexEtxEventBatch batch = new VortexEtxEventBatch();

                for (int k = 0; k < loopVal; k++)
                {
                    lock (stressLoopdyLock)
                    {
                        stressLoopdyLoop++;
                        if (stressLoopdyLoop > 1000)
                            stressLoopdyLoop = 0;
                    }

                    VortexUDPBinaryXRL vp = new VortexUDPBinaryXRL(binaryUrl);
                    vp.ProducerID = BitConverter.GetBytes(Convert.ToInt16("0x9898", 16));
                    vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 1, "BaseBinaryStress"));
                    vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.VarInt, 2, stressLoopdyLoop));
                    vp.BuildContent();
                    batch.AddEvent(vp.SentMessage.Batch.Events[0]);
                    batch.Events[batch.Events.Count - 1].EventId = 0;
                }

                VortexEtxMessage etxMessage = new VortexEtxMessage(batch, VortexProtocolType.DistMon);
                VortexUDPBinaryXRL vpBatch = new VortexUDPBinaryXRL(binaryUrl);
                vpBatch.CustomMessage = etxMessage;
                vpBatch.SendRequest(false);
            }
        }

        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement("Stress"), TestCasePriority(2), TestFrequency("Manual"), Description("Basic stress case with one logline.")]
        [StressTest]
        public class HTTPBinaryConsoleBufferSize : VortexNode
        {
            private static Random rand = new Random();
            public override void Run()
            {
                int ordinalCount = 15;
                VortexEtxEventBatch batch = new VortexEtxEventBatch();
                int bufferSize = 0;

                VortexHTTPBinary vp = new VortexHTTPBinary(binaryUrl);
                vp.ProducerID = BitConverter.GetBytes(Convert.ToInt16("0x9898", 16));
                vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 1, "BinaryConsoleBufferSize"));
                vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 2, "HTTP"));

                for (int k = 3; k <= ordinalCount; k++)
                {
                    if (k % 2 == 0)
                        vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.SVarInt, (uint)k, rand.Next(Int32.MaxValue)));
                    else
                        vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.VarInt, (uint)k, Convert.ToUInt32(rand.Next(0, Int32.MaxValue))));
                }

                byte[] content = vp.BuildContent();
                while (bufferSize < 1024)
                {
                    bufferSize += content.Length;
                    batch.AddEvent(vp.SentMessage.Batch.Events[0]);
                    batch.Events[batch.Events.Count - 1].EventId = 1;
                }

                VortexEtxMessage etxMessage = new VortexEtxMessage(batch, VortexProtocolType.DistMon);

                VortexHTTPBinary vpBatch = new VortexHTTPBinary(binaryUrl);
                vpBatch.CustomMessage = etxMessage;
                vpBatch.SendRequest(false);
            }
        }

        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement("Stress"), TestCasePriority(2), TestFrequency("Manual"), Description("Basic stress case with one logline.")]
        [StressTest]
        [CompoundCase("SG", false)]
        [CompoundCase("Direct", true)]
        public class UDPBinaryConsoleBufferSize : VortexNode
        {
            private static Random rand = new Random();
            public override void Run()
            {
                int ordinalCount = 15;
                bool useDirect = (bool)MyValues[0];
                VortexEtxEventBatch batch = new VortexEtxEventBatch();
                int bufferSize = 0;

                VortexUDPBinaryXRL vp = new VortexUDPBinaryXRL(binaryUrl);
                vp.ProducerID = BitConverter.GetBytes(Convert.ToInt16("0x9898", 16));
                vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 1, "BinaryConsoleBufferSize"));
                vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 2, "UDP"));

                for (int k = 3; k <= ordinalCount; k++)
                {
                    if (k % 2 == 0)
                        vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.SVarInt, (uint)k, rand.Next(Int32.MaxValue)));
                    else
                        vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.VarInt, (uint)k, Convert.ToUInt32(rand.Next(0, Int32.MaxValue))));
                }

                byte[] content = vp.BuildContent();
                while (bufferSize < 1024)
                {
                    bufferSize += content.Length;
                    batch.AddEvent(vp.SentMessage.Batch.Events[0]);
                    batch.Events[batch.Events.Count - 1].EventId = 1;
                }

                VortexEtxMessage etxMessage = new VortexEtxMessage(batch, VortexProtocolType.DistMon);

                VortexUDPBinaryXRL vpBatch = new VortexUDPBinaryXRL(binaryUrl);
                vpBatch.CustomMessage = etxMessage;
                vpBatch.SendRequest(false);
            }
        }

        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement("Stress"), TestCasePriority(2), TestFrequency("Manual"), Description("Basic stress case with one logline.")]
        [StressTest]
        [CompoundCase("Max1", 1)]
        [CompoundCase("Max10", 10)]
        [CompoundCase("Max100", 100)]
        [CompoundCase("Max500", 500)]
        [CompoundCase("Max1000", 1000)]
        public class HTTPBinaryConsoleBufferSizeAutoValued : VortexNode
        {
            private static Random rand = new Random();
            private static Dictionary<int, byte[]> contentDict = new Dictionary<int, byte[]>();
            protected static int currentItem;
            protected static object currentItemLock = new Object();
            public override void Run()
            {
                int maxVal = Convert.ToInt32(MyValues[0]);
                int myItem = 0;
                lock (currentItemLock)
                {
                    currentItem++;
                    if (currentItem > maxVal)
                        currentItem = 1;
                    myItem = currentItem;
                }

                if (!contentDict.ContainsKey(currentItem))
                {
                    int ordinalCount = 6;
                    VortexEtxEventBatch batch = new VortexEtxEventBatch();
                    int bufferSize = 0;

                    VortexHTTPBinary vp = new VortexHTTPBinary(binaryUrl);
                    vp.ProducerID = BitConverter.GetBytes(Convert.ToInt16("0x9898", 16)); ;
                    vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 1, "BinaryConsoleBufferSize"));
                    vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 2, "HTTP"));
                    vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.VarInt, 3, (uint)currentItem));
                    vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.SVarInt, 4, currentItem));

                    for (int k = 5; k <= ordinalCount; k++)
                    {
                        if (k % 2 == 0)
                            vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.SVarInt, (uint)k, rand.Next(Int32.MaxValue)));
                        else
                            vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.VarInt, (uint)k, Convert.ToUInt32(rand.Next(0, Int32.MaxValue))));
                    }

                    byte[] content = vp.BuildContent();
                    while (bufferSize < 1024)
                    {
                        bufferSize += content.Length;
                        batch.AddEvent(vp.SentMessage.Batch.Events[0]);
                        batch.Events[batch.Events.Count - 1].EventId = 2;
                    }

                    VortexEtxMessage etxMessage = new VortexEtxMessage(batch, VortexProtocolType.DistMon);

                    VortexHTTPBinary vpBatch = new VortexHTTPBinary(binaryUrl);
                    vpBatch.CustomMessage = etxMessage;
                    vpBatch.SendRequest(false);
                    contentDict.Add(myItem, vpBatch.BuildContent());
                }
                else
                {
                    VortexHTTPBinary vpBatch = new VortexHTTPBinary(binaryUrl);
                    vpBatch.CustomContent = contentDict[myItem];
                    vpBatch.SendRequest(false);
                }
            }
        }

        [TestCase, EnvRequirement("Stress"), TestCasePriority(2), TestFrequency("Manual"), Description("Uploads a producer.")]
        [StressTest]
        public class UploadProducerStressCompanion : VortexNode
        {
            private static DateTime LastTime = DateTime.Now.AddDays(-1);
            private static bool propped = false;
            public override void Run()
            {
                if ((DateTime.Now - LastTime).TotalSeconds > 1)
                {
                    LastTime = DateTime.Now;

                    EtxManifest man = new EtxManifest(System.Xml.Linq.XElement.Parse(STRESS_COMPANION_MANIFEST));
                    foreach (Producer p in man.Producers)
                    {
                        if (propped)
                            EtxManifestServerTestCase.RemoveProducer(p, true);
                        else
                            EtxManifestServerTestCase.UploadProducer(p, true);

                        propped = !propped;
                    }
                }
            }
        }

        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement("Stress"), TestCasePriority(2), TestFrequency("Manual"), Description("Basic stress case with one logline.")]
        [StressTest]
        [CompoundCase("SG", false)]
        [CompoundCase("Direct", true)]
        public class UDPBinaryConsoleBufferSizeAutovalued : VortexNode
        {
            private static Random rand = new Random();
            public override void Run()
            {
                int ordinalCount = 6;
                bool useDirect = (bool)MyValues[0];
                VortexEtxEventBatch batch = new VortexEtxEventBatch();
                int bufferSize = 0;

                VortexUDPBinaryXRL vp = new VortexUDPBinaryXRL(binaryUrl);
                vp.ProducerID = BitConverter.GetBytes(Convert.ToInt16("0x9898", 16));
                vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 1, "BinaryConsoleBufferSize"));
                vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.String, 2, "UDP"));

                for (int k = 3; k <= ordinalCount; k++)
                {
                    if (k % 2 == 0)
                        vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.SVarInt, (uint)k, rand.Next(Int32.MaxValue)));
                    else
                        vp.AddUpdateParameter(new VortexEtxField(EtxFieldType.VarInt, (uint)k, Convert.ToUInt32(rand.Next(0, Int32.MaxValue))));
                }

                byte[] content = vp.BuildContent();
                while (bufferSize < 1024)
                {
                    bufferSize += content.Length;
                    batch.AddEvent(vp.SentMessage.Batch.Events[0]);
                    batch.Events[batch.Events.Count - 1].EventId = 2;
                }

                VortexEtxMessage etxMessage = new VortexEtxMessage(batch, VortexProtocolType.DistMon);

                VortexUDPBinaryXRL vpBatch = new VortexUDPBinaryXRL(binaryUrl);
                vpBatch.CustomMessage = etxMessage;
                vpBatch.SendRequest(false);                
            }
        }
    }

    [TestGroup, Owner("wisgt"), Description("Vortex configuration test cases")]
    public class VortexConfig : VortexTestGroup
    {
        #region Test cases

        /// <summary>
        /// Bad endpoint test case.
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Sends in a logstring request to a bad endpoint.")]
        public class LS_BadUrl : VortexConfigBase
        {
            public override void Run()
            {
                string myUrl = LogstringBase.BuildUrl("LS_BadUrl.ashx");

                VortexLS ls = new VortexLS(myUrl);

                ls.AddUpdateParameter(1, "LS_BadUrl");
                ls.AddUpdateParameter(2, Convert.ToString(DateTime.UtcNow.ToFileTimeUtc(), 16));
                ls.UseXRL = false;
                ls.ValidateNotProcessed = true;
                try
                {
                    ls.SendRequest();
                }
                catch (WebException ex)
                {
                    //Check for BadRequest
                    if (ex.Response == null || !(((HttpWebResponse)ex.Response).StatusCode == HttpStatusCode.InternalServerError))
                        throw;
                    else
                        ro.Debug("Obtained the expected error status code.");
                }
            }
        }

        /// <summary>
        /// Bad endpoint test case.
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Sends in a logstring request to a bad endpoint.")]
        public class LS_UrlMissingSegment : VortexConfigBase
        {

            public override void Run()
            {
                string myUrl = LogstringBase.BuildUrl("LS_UrlMissingSegment.ashx");
                myUrl = myUrl.Replace("/vortex/", "/");

                VortexLS ls = new VortexLS(myUrl);

                ls.AddUpdateParameter(1, "LS_BadUrl");
                ls.AddUpdateParameter(2, Convert.ToString(DateTime.UtcNow.ToFileTimeUtc(), 16));
                ls.ValidateNotProcessed = true;
                ls.UseXRL = false;
                try
                {
                    ls.SendRequest();
                }
                catch (WebException ex)
                {
                    //Check for BadRequest
                    if (ex.Response == null || !(((HttpWebResponse)ex.Response).StatusCode == HttpStatusCode.NotFound))
                        throw;
                    else
                        ro.Debug("Obtained the expected error status code.");
                }
            }
        }

        /// <summary>
        /// Bad endpoint test case.
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Sends in a logstring request to a bad endpoint.")]
        public class LS_UrlExtraSegment : VortexConfigBase
        {

            public override void Run()
            {
                string myUrl = LogstringBase.BuildUrl("LS_UrlExtraSegment.ashx");
                myUrl = myUrl.Replace("/vortex/", "/vortex/vortex/");

                VortexLS ls = new VortexLS(myUrl);

                ls.AddUpdateParameter(1, "LS_BadUrl");
                ls.AddUpdateParameter(2, Convert.ToString(DateTime.UtcNow.ToFileTimeUtc(), 16));
                ls.UseXRL = false;

                try
                {
                    ls.SendRequest();
                }
                catch (WebException ex)
                {
                    //Check for BadRequest
                    if (ex.Response == null || !(((HttpWebResponse)ex.Response).StatusCode == HttpStatusCode.InternalServerError))
                        throw;
                    else
                        ro.Debug("Obtained the expected error status code.");
                }
            }
        }

        //StreamInsight is dumb. It overallocates and AVs, bug 416506 on their side. 
        //This case could work if the bug did not exist (it would also need tweaking the field size
        //4080 was just from playing around tracking down the bug.
#if false 
        /// <summary>
        /// Big category
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Large string for the payload. Overflows SI when you add 1 char.")]
        public void PayloadSize()
        {
            string lsUrl = LogString.BuildUrl("LogString.ashx");
            const int SI_FIELD_MAX = 4080; //Temporarily 256 because StreamInsight CTP 3 sucks. This case will probably need revamping to the 8k pagelimit in their RC.
            int pipeCount = 1; //The raw payload should look like this: |CHAR(SI_FIELD_MAX) so we need to subtract the number of pipes                        

            VortexLS ls = new VortexLS(lsUrl);

            StringBuilder cat = new StringBuilder(String.Empty);

            for (int k = 0; k < SI_FIELD_MAX - pipeCount; k++)
                cat.Append("X");
            ro.Debug("Sending {0} characters in a payload field. This should work.", SI_FIELD_MAX.ToString());
            ls.AddUpdateParameter(2, cat.ToString());
            ls.SendRequest();

            cat.Append("X"); //Do a ++. 
            ls.ClearParameters();
            ls.AddUpdateParameter(2, cat.ToString());

            ro.Debug("Now sending one more character than before, this should be rejected by streaminsight and so we should not see it be output.");
            ls.ValidateNotProcessed = true;
            ls.SendRequest();
        }        
#endif


        [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Stops and starts the service to test query creation and config file loading"), EnvRequirement("XblobOnly")]
        public class VortexThreadsNPDBConfig : VortexConfigBase
        {
            public override void Run()
            {
                string counterName = "Input I/O Threads - Max";
                string categoryName = "XBL Vortex FD - Service";
                string instanceName = "_total_";
                long expectedVal = 314;

                try
                {
                    long[] startState = GetPerformanceCounterValues(categoryName, counterName, instanceName);

                    UpdateNPDBSetting(Setting.vortex_maxIoThreads, expectedVal.ToString());
                    UpdateNPDBSetting(Setting.vortex_maxWorkerThreads, expectedVal.ToString());
                    Thread.Sleep(10000);//Give it a lil
                    long[] updated = GetPerformanceCounterValues(categoryName, counterName, instanceName);

                    foreach (long l in updated)
                    {
                        Global.RO.Debug("Verifying value {0} expecting {1}", l, expectedVal);
                        if (l != expectedVal)
                            throw new Exception("One of the counters was not updated!");
                    }

                    Global.RO.Debug("Check that things still work.");
                    ValidatePassthrough(true);

                    Global.RO.Debug("Revert the changes.");
                    RestoreNPDBSettings();
                    Thread.Sleep(10000);//Give it a lil

                    Global.RO.Debug("Make sure the settings have been restored.");

                    long[] final = GetPerformanceCounterValues(categoryName, counterName, instanceName);

                    for (int k = 0; k < final.Length; k++)
                    {
                        Global.RO.Debug("Verifying value {0} expecting {1}", final[k], startState[k]);
                        if (final[k] != startState[k])
                        {
                            if (final[k] != expectedVal) //Exception because counters are sticky right now if NPDB contains 0. If we add defaults into NPDB we can take this out.
                                throw new Exception("One of the counters did not match its original state!");
                        }
                    }

                    Global.RO.Debug("Check that things still work after reverting.");
                    ValidatePassthrough(true);
                }
                finally
                {
                    try
                    {
                        RestoreNPDBSettings();
                    }
                    catch (Exception ex)
                    {
                        //Whatever 
                        Global.RO.Debug("Could not restart the query, the system may be in a bad state. Exception:" + ex.Message);
                    }
                }
            }
        }

        /// <summary>
        /// Stops and starts the service. VERY NAUGHTY.
        /// </summary>        
        [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Stops and starts the service to test query creation and config file loading"), EnvRequirement("XblobOnly")]
        public class VortexSvcTest : VortexConfigBase
        {
            public override void Run()
            {
                try
                {
                    IPEndPoint[] ipEps = ManagementListener.GetXmgmtEndPoints(VortexUtil.vortex_Interface);
                    string ip = ipEps[0].Address.ToString();
                    string approot = Global.XEnv.GetSetting("setup_approot");
                    string generatedConfigPath = String.Format("\\\\{0}\\{1}\\vortexfd\\VortexfdConfigLog.xml", ip, approot.Replace(":", "$"));
                    string loadConfigPath = generatedConfigPath.Replace("VortexfdConfigLog", "VortexfdConfig");

                    Global.RO.Debug("Stop the listeners and restart the service after creating a config file, then run a basic test.");

                    StopListeners();
                    StopService();

                    File.Copy(generatedConfigPath, loadConfigPath, true);

                    StartService();
                    StartListeners();

                    ValidatePassthrough(true);

                    Global.RO.Debug("Now delete the config file and try again to make sure things are still cool.");

                    File.Delete(loadConfigPath);

                    //Now try it normally again                    
                    RestartService();
                    ValidatePassthrough(true);
                }
                finally
                {
                    try
                    {
                        StartService();
                    }
                    catch (Exception)
                    {
                    }
                }
            }
        }

#if false //Vortex INH is out for now

        [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Stops and starts the service to test query creation and config file loading"), EnvRequirement("XblobOnly")]
        public class VortexTraceNPDBConfig : VortexConfigBase
        {
            public override void Run()
            {
                try
                {                     
                    Thread.Sleep(1000);
                    ValidateAreaTrace(true);
                    UpdateNPDBSetting(Setting.xmgmt_area_VortexTrace, "");                    
                    RestartService();

                    //Since I nulled it out, it should be level -1 and not log anything.                   
                    ValidateAreaTrace(false);
                    RestoreNPDBSettings();                    
                    RestartService();     
           
                    //Upon restoring log level should be 0.                    
                    ValidateAreaTrace(true);                    
                }
                finally
                {
                    try
                    {
                        BaseXomListener.RestartXomListeners();                        
                        RestoreNPDBSettings();
                    }
                    catch (Exception ex)
                    {
                        //Whatever 
                        Global.RO.Debug("Could not restart the query, the system may be in a bad state. Exception:" + ex.Message);
                    }
                }
            }
        }

        /// <summary>
        /// Stops and starts the passthrough query. VERY NAUGHTY.
        /// </summary>        
        [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Stops and starts the service to test query creation and config file loading"), EnvRequirement("XblobOnly")]
        public class VortexQueryStopStartPassthrough : VortexConfigBase
        {
            public override void Run()
            {
                try
                {
                    string output;
                    ValidatePassthrough(true);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystop " + passthroughQueryName, out output);
                    ValidatePassthrough(false);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystart " + passthroughQueryName, out output);
                    ValidatePassthrough(true);
                }
                finally
                {
                    try
                    {
                        //Don't leave queries off! Bad!
                        string output;
                        ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystart " + passthroughQueryName, out output);
                    }
                    catch (Exception ex)
                    {
                        //Whatever 
                        Global.RO.Debug("Could not restart the query, the system may be in a bad state. Exception:" + ex.Message);
                    }
                }
            }
        }
        /// <summary>
        /// Stops and starts the clickstream query. VERY NAUGHTY.
        /// </summary>        
        [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Stops and starts the service to test query creation and config file loading"), EnvRequirement("XblobOnly")]
        public class VortexQueryStopStartClickstream : VortexConfigBase
        {
            public override void Run()
            {
                try
                {
                    string output;
                    ValidateHistogram(true);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystop " + eventTypeCountQueryName, out output);
                    ValidateHistogram(false);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystart " + eventTypeCountQueryName, out output);
                    ValidateHistogram(true);
                }
                finally
                {
                    try
                    {
                        //Don't leave queries off! Bad!
                        string output;
                        ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystart " + eventTypeCountQueryName, out output);
                    }
                    catch (Exception ex)
                    {
                        //Whatever 
                        Global.RO.Debug("Could not restart the query, the system may be in a bad state. Exception:" + ex.Message);
                    }
                }
            }
        }
        /// <summary>
        /// Stops and starts the clickstream query. VERY NAUGHTY.
        /// </summary>        
        [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Stops and starts the service to test query creation and config file loading"), EnvRequirement("XblobOnly")]
        public class VortexQueryStopCSTestPassthrough : VortexConfigBase
        {
            public override void Run()
            {
                try
                {
                    string output;
                    ValidatePassthrough(true);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystop " + eventTypeCountQueryName, out output);
                    ValidatePassthrough(true);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystart " + eventTypeCountQueryName, out output);
                    ValidatePassthrough(true);
                }
                finally
                {
                    try
                    {
                        //Don't leave queries off! Bad!
                        string output;
                        ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystart " + eventTypeCountQueryName, out output);
                    }
                    catch (Exception ex)
                    {
                        //Whatever 
                        Global.RO.Debug("Could not restart the query, the system may be in a bad state. Exception:" + ex.Message);
                    }
                }
            }
        }
        /// <summary>
        /// Stops and starts the clickstream query. VERY NAUGHTY.
        /// </summary>        
        [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Stops and starts the service to test query creation and config file loading"), EnvRequirement("XblobOnly")]
        public class VortexQueryStopAll : VortexConfigBase
        {
            public override void Run()
            {

                try
                {
                    string output;
                    ValidatePassthrough(true);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystop " + eventTypeCountQueryName, out output);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystop " + passthroughQueryName, out output);
                    ValidateSilent(true);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystart " + eventTypeCountQueryName, out output);
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystart " + passthroughQueryName, out output);
                    ValidatePassthrough(true);
                }
                finally
                {
                    try
                    {
                        //Don't leave queries off! Bad!
                        string output;
                        ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortex querystart " + eventTypeCountQueryName, out output);
                    }
                    catch (Exception ex)
                    {
                        //Whatever 
                        Global.RO.Debug("Could not restart the query, the system may be in a bad state. Exception:" + ex.Message);
                    }
                }
            }
        }              
#endif

        #endregion Test cases
    }

#if false //Vortex INH is out for now.
    [TestGroup, Owner("wisgt"), Description("Query specific test cases. Clickstream, Eventtypecount, etc.")]    
    public class QuerySpecific : VortexTestGroup
    {
#if false //These dudes are gone from Vortex so disabling them for now.
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Histogram test case - multiple concurrent types.")]
        public class LS2_ClickstreamHistogram_Basic : Logstring2Base
        {

            public override void Run()
            {
                int eventCount = 1;

                //Set up the different events
                List<VortexLS2> types = new List<VortexLS2>();
                List<VortexHistogram> validators = new List<VortexHistogram>();

                for (int k = 0; k < eventCount; k++)
                {
                    VortexLS2 newType = new VortexLS2(url);
                    newType.AddUpdateParameter(LS2Fields.Area, "Area" + k.ToString());
                    newType.AddUpdateParameter(LS2Fields.PageName, "TheOnlyPage");
                    newType.AddUpdateParameter(LS2Fields.EventType, "TheOnlyEventType");
                    types.Add(newType);

                    VortexHistogram newValidator = new VortexHistogram("Area" + k.ToString(), "TheOnlyPage", "TheOnlyEventType", k % 10 + 1, defaultQueryWindowSize); //Max of 10                
                    validators.Add(newValidator);
                }

                ro.Debug("Flush out the stuff that's there...");
                VortexLS2 flusher = new VortexLS2(url);
                flusher.AddUpdateParameter(1, "flush");
                flusher.SendRequest(true);
                VortexLogBase.FlushXomLogCache();

                ro.Debug("Send the payload:");
                //
                for (int k = 0; k < eventCount; k++) //For every event type
                {
                    for (int j = 0; j < k % 10 + 1; j++) //Send index%10+1 (1 through 10) total point events
                        types[k].SendRequest(false);
                }

                ro.Debug("Now flush and validate!");
                flusher.SendRequest();
                foreach (VortexHistogram vH in validators)
                    vH.Validate();
            }
        }

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Histogram test case - multiple concurrent types.")]
        public class LS2_ClickstreamHistogram_Multiple : Logstring2Base
        {

            public override void Run()
            {
                BaseXomListener.Logging = false; //Too chatty in this case
                try
                {
                    int eventCount = 20;

                    //Set up the different events
                    List<VortexLS2> types = new List<VortexLS2>();
                    List<VortexHistogram> validators = new List<VortexHistogram>();

                    for (int k = 0; k < eventCount; k++)
                    {
                        VortexLS2 newType = new VortexLS2(url);
                        newType.AddUpdateParameter(LS2Fields.Area, "Area" + k.ToString());
                        newType.AddUpdateParameter(LS2Fields.PageName, "TheOnlyPage");
                        newType.AddUpdateParameter(LS2Fields.EventType, "TheOnlyEventType");
                        types.Add(newType);

                        VortexHistogram newValidator = new VortexHistogram("Area" + k.ToString(), "TheOnlyPage", "TheOnlyEventType", k % 10 + 1, defaultQueryWindowSize); //Max of 10                    
                        validators.Add(newValidator);
                    }

                    ro.Debug("Flush out the stuff that's there...");
                    VortexLS2 flusher = new VortexLS2(url);
                    flusher.SendRequest();
                    VortexLogBase.FlushXomLogCache();

                    ro.Debug("Sending the payload:");
                    //
                    for (int k = 0; k < eventCount; k++) //For every event type
                    {
                        for (int j = 0; j < k % 10 + 1; j++) //Send index%10+1 (1-10) total point events
                            types[k].SendRequest(false);
                    }

                    ro.Debug("Validating the results.");
                    foreach (VortexHistogram vH in validators)
                        vH.Validate();
                }
                finally
                {
                    BaseXomListener.Logging = true;
                }
            }
        }

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Histogram test case - high number of values that almost guarantees a split. The purpose here is to split and make sure the aggregation additions add up to the expected value")]
        public class LS2_ClickstreamHistogram_HighCount : Logstring2Base
        {

            public override void Run()
            {
                BaseXomListener.Logging = false; //Too chatty in this case
                try
                {
                    VortexLS2 type = new VortexLS2(url);
                    type.AddUpdateParameter(LS2Fields.Area, "TheOnlyArea");
                    type.AddUpdateParameter(LS2Fields.PageName, "TheOnlyPage");
                    type.AddUpdateParameter(LS2Fields.EventType, "TheOnlyType");

                    VortexHistogram validator = new VortexHistogram("TheOnlyArea", "TheOnlyPage", "TheOnlyType", 500, defaultQueryWindowSize); //Max of 10                            

                    ro.Debug("Flush out the stuff that's there...");
                    VortexLS2 flusher = new VortexLS2(url);
                    flusher.AddUpdateParameter(1, "flush");
                    flusher.SendRequest(true);
                    VortexLogBase.FlushXomLogCache(); //Dump all that junk.

                    ro.Debug("Sending the payload 50 times:");
                    for (int k = 0; k < 500; k++)
                        type.SendRequest(false);

                    flusher.SendRequest();
                    ro.Debug("Validating the results.");
                    validator.Validate();

                }
                finally
                {
                    BaseXomListener.Logging = true;
                }
            }
        }
#endif

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Histogram test case - multiple concurrent types.")]
        public class LS2_EventtypeCount_Basic : Logstring2Base
        {

            public override void Run()
            {
                int eventCount = 1;

                //Set up the different events
                List<VortexLS2> types = new List<VortexLS2>();
                List<VortexEventtypeCount> validators = new List<VortexEventtypeCount>();

                for (int k = 0; k < eventCount; k++)
                {
                    VortexLS2 newType = new VortexLS2(url);
                    newType.AddUpdateParameter(LS2Fields.Area, "Area" + k.ToString());
                    newType.AddUpdateParameter(LS2Fields.PageName, "TheOnlyPage");
                    newType.AddUpdateParameter(LS2Fields.EventType, "TheOnlyEventType");
                    types.Add(newType);

                    VortexEventtypeCount newValidator = new VortexEventtypeCount("Area" + k.ToString(), k % 10 + 1, defaultQueryWindowSize); //Max of 10                
                    validators.Add(newValidator);
                }

                ro.Debug("Flush out the stuff that's there...");
                VortexLS2 flusher = new VortexLS2(url);
                flusher.AddUpdateParameter(1, "flush");
                flusher.SendRequest(true);
                VortexLogBase.FlushXomLogCache();

                ro.Debug("Send the payload:");
                //
                for (int k = 0; k < eventCount; k++) //For every event type
                {
                    for (int j = 0; j < k % 10 + 1; j++) //Send index%10+1 (1 through 10) total point events
                        types[k].SendRequest(false);
                }

                ro.Debug("Now flush and validate!");
                flusher.SendRequest();
                foreach (VortexEventtypeCount vH in validators)
                    vH.Validate();
            }
        }

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Histogram test case - multiple concurrent types.")]
        public class LS2_EventtypeCount_Multiple : Logstring2Base
        {

            public override void Run()
            {
                BaseXomListener.Logging = false; //Too chatty in this case
                try
                {
                    int eventCount = 20;

                    //Set up the different events
                    List<VortexLS2> types = new List<VortexLS2>();
                    List<VortexEventtypeCount> validators = new List<VortexEventtypeCount>();

                    for (int k = 0; k < eventCount; k++)
                    {
                        VortexLS2 newType = new VortexLS2(url);
                        newType.AddUpdateParameter(LS2Fields.Area, "Area" + k.ToString());
                        newType.AddUpdateParameter(LS2Fields.PageName, "TheOnlyPage");
                        newType.AddUpdateParameter(LS2Fields.EventType, "TheOnlyEventType");
                        types.Add(newType);

                        VortexEventtypeCount newValidator = new VortexEventtypeCount("Area" + k.ToString(), k % 10 + 1, defaultQueryWindowSize); //Max of 10                    
                        validators.Add(newValidator);
                    }

                    ro.Debug("Flush out the stuff that's there...");
                    VortexLS2 flusher = new VortexLS2(url);
                    flusher.AddUpdateParameter(LS2Fields.Area, "flush");
                    flusher.SendRequest();
                    VortexLogBase.FlushXomLogCache();

                    ro.Debug("Sending the payload:");
                    //
                    for (int k = 0; k < eventCount; k++) //For every event type
                    {
                        for (int j = 0; j < k % 10 + 1; j++) //Send index%10+1 (1-10) total point events
                            types[k].SendRequest(false);
                    }

                    ro.Debug("Validating the results.");
                    foreach (VortexEventtypeCount vH in validators)
                        vH.Validate();
                }
                finally
                {
                    BaseXomListener.Logging = true;
                }
            }
        }

        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("Daily"), Description("Histogram test case - high number of values that almost guarantees a split. The purpose here is to split and make sure the aggregation additions add up to the expected value")]
        public class LS2_EventtypeCount_HighCount : Logstring2Base
        {

            public override void Run()
            {
                BaseXomListener.Logging = false; //Too chatty in this case
                try
                {
                    VortexLS2 type = new VortexLS2(url);
                    type.AddUpdateParameter(LS2Fields.Area, "TheOnlyArea");
                    type.AddUpdateParameter(LS2Fields.PageName, "TheOnlyPage");
                    type.AddUpdateParameter(LS2Fields.EventType, "TheOnlyType");

                    VortexEventtypeCount validator = new VortexEventtypeCount("TheOnlyArea", 500, defaultQueryWindowSize); //Max of 10                            

                    ro.Debug("Flush out the stuff that's there...");
                    VortexLS2 flusher = new VortexLS2(url);
                    flusher.AddUpdateParameter(1, "flush");
                    flusher.SendRequest(true);
                    VortexLogBase.FlushXomLogCache(); //Dump all that junk.

                    ro.Debug("Sending the payload 50 times:");
                    for (int k = 0; k < 500; k++)
                        type.SendRequest(false);

                    flusher.SendRequest();
                    ro.Debug("Validating the results.");
                    validator.Validate();

                }
                finally
                {
                    BaseXomListener.Logging = true;
                }
            }
        }
    }
#endif

#if false //Basically taken out during CAKE. Since it may come back letting it sit here and I'll remove it if it never comes back.
    [TestGroup, Owner("wisgt"), Description("Logstring UDP test cases")]
    public class LogStringUDP : VortexTestGroup
    {
    #region LSUDP cases
        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(1), TestFrequency("BVT"), Description("Just sends in a simple request, and verifies it comes out successfully.")]
        public class LS_UDP_Basic : LogstringBase
        {

            public override void Run()
            {
                VortexLS_UDP ls = new VortexLS_UDP(virtualInterface);

                ls.AddUpdateParameter(1, "LS_BaseCase");
                ls.AddUpdateParameter(2, Convert.ToString(DateTime.UtcNow.ToFileTimeUtc(), 16));

                ls.SendRequest();
            }

        }

        [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Weird Unicode characters, oh no!!")]
        public class LS_UDP_Unicode : LogstringBase
        {

            public override void Run()
            {
                VortexLS_UDP ls = new VortexLS_UDP(virtualInterface);

                ls.AddUpdateParameter(3, "LS2_SpecialCharacters");
                VortexUtil.RandomUnicodeStringr = new RandomUnicodeString();
                string val = r.GetString(200);
                ls.AddUpdateParameter(2, "id!!");
                ls.AddUpdateParameter(3, val);
                ls.SendRequest();
            }

        }

        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("No http content.")]
        public class LS_UDP_EmptyMessage : LogstringBase
        {

            public override void Run()
            {
                VortexLS_UDP ls = new VortexLS_UDP(virtualInterface);
                try
                {
                    ls.CustomMessage = String.Empty;
                    ls.SendRequest();
                }
                catch (WebException ex)
                {
                    //Check for BadRequest
                    if (!(((HttpWebResponse)ex.Response).StatusCode == HttpStatusCode.BadRequest))
                        throw;
                    else
                        ro.Debug("Obtained the expected error status code.");
                }
            }

        }

        /// <summary>
        /// Basic batched case
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Only end of line characters to send a lot of empty loglines.")]
        public class LS_UDP_OnlySeparators : LogstringBase
        {

            public override void Run()
            {
                VortexLS_UDP ls = new VortexLS_UDP(virtualInterface);

                StringBuilder crappyString = new StringBuilder(String.Empty);
                for (int k = 0; k < 250; k++)
                    crappyString.Append("|");

                ls.AddUpdateParameter(1, crappyString.ToString());

                ls.SendRequest(true);
            }

        }

        /// <summary>
        /// Basic batched case
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Huge string. Should be rejected.")]
        public class LS_UDP_HugeNonBatched : LogstringBase
        {

            public override void Run()
            {
                VortexLS_UDP ls = new VortexLS_UDP(virtualInterface);
                ls.UseDirect = true;
                StringBuilder crappyString = new StringBuilder(String.Empty);
                for (int k = 0; k < 1000; k++)
                    crappyString.Append("Hello Sir.");
                ls.AddUpdateParameter(1, "Oh.");
                ls.AddUpdateParameter(2, crappyString.ToString());
                ls.ValidateNotProcessed = true;
                ls.SendRequest();
            }

        }

        /// <summary>
        /// Basic batched case
        /// </summary>
        [TestCase, EnvRequirement(""), TestCasePriority(2), TestFrequency("Regression"), Description("Huge string. Should be rejected.")]
        public class LS_UDP_LessHugeNonBatched : LogstringBase
        {

            public override void Run()
            {
                VortexLS_UDP ls = new VortexLS_UDP(virtualInterface);
                ls.UseDirect = true;

                StringBuilder crappyString = new StringBuilder(String.Empty);
                for (int k = 0; k < 500; k++)
                    crappyString.Append("Hello Sir.");
                ls.AddUpdateParameter(1, "Oh.");
                ls.AddUpdateParameter(2, crappyString.ToString());
                ls.ValidateNotProcessed = false;
                ls.SendRequest();
            }

        }

        /// <summary>
        /// Basic case
        /// </summary>
        [TestCase, EnvRequirement("Stress"), TestCasePriority(2), TestFrequency("Manual"), Description("Basic stress case with one logline.")]
        [StressTest]
        public class LS_UDP_BasicStress : LogstringBase
        {

            public override void Run()
            {
                VortexLS_UDP ls = new VortexLS_UDP(virtualInterface);
                ls.UseDirect = true;
                ls.AddUpdateParameter(1, "LS_BaseCase");
                ls.AddUpdateParameter(2, Convert.ToString(DateTime.UtcNow.ToFileTimeUtc(), 16));

                ls.SendRequest(false);
            }

        }
    #endregion LSUDP cases
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\VortexTestBase.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;
using System.ServiceProcess;
using System.Threading;
using System.Diagnostics;
using System.Xml.Serialization;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService.Vortex;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.common.protocol;

using CAKE = ServerTestFramework.LiveService.Vortex.CAKE;

namespace xonline.test.vortex
{
    /// <summary>
    /// Base class for a Vortex test group. Does a few universally needed things, like
    /// set up listeners and contains the default query window size.
    /// </summary>
    public class VortexTestGroup : TestNode
    {
        //this is just to test an xml being uploaded to logstring. Etx manifest is arbitrary.
        public static string testUploadXml = @"<?xml version='1.0' encoding='UTF-8' standalone='no' ?>
<InstrConfig version='3'>
    <ULIntervalSecs>300</ULIntervalSecs>
    <Srcs>
        <Src id='BCK' target='0' />
        <Src id='DHW' target='100' />
        <Src id='FPT' target='0' flags='1E' />
        <Src id='FU' target='0' />
        <Src id='MDR' target='0' flags='1E' />
        <Src id='ODD' target='.5' />
        <Src id='QOS' target='.5' />
        <Src id='SHW' target='100' />
        <Src id='TEM' target='.5' />
        <Src id='PAS' target='100' />
        <Src id='PAA' target='100' />
        <Src id='PAL' target='100' />
        <Src id='PAF' target='100' />
        <Src id='PAI' target='100' />
        <Src id='PAT' target='100' />
        <Src id='PDE' target='100' mininterval='300' />        
        <Src id='API_FailS1' target='10' mininterval='300' />
        <Src id='API_FailS2' target='10' mininterval='300' />
        <Src id='API_FailS3' target='10' mininterval='300' />
        <Src id='API_FailS4' target='10' mininterval='300' />
        <Src id='API_FailS5' target='10' mininterval='300' />
        <Src id='API_FailS6' target='10' mininterval='300' />
        <Src id='API_FailS7' target='10' mininterval='300' />
        <Src id='API_FailS8' target='10' mininterval='300' />
        <Src id='API_FailS9' target='10' mininterval='300' />
        <Src id='API_FailS10' target='10' mininterval='300' />
        <Src id='API_FailS11' target='10' mininterval='300' />
        <Src id='API_FailS12' target='10' mininterval='300' />
        <Src id='API_FailS13' target='10' mininterval='300' />
        <Src id='API_FailS14' target='10' mininterval='300' />
        <Src id='API_FailS15' target='10' mininterval='300' />
        <Src id='API_FailS16' target='10' mininterval='300' />
        <Src id='API_FailS17' target='10' mininterval='300' />
        <Src id='API_FailS18' target='10' mininterval='300' />
        <Src id='API_FailS19' target='10' mininterval='300' />
        <Src id='API_FailS20' target='10' mininterval='300' />
        <Src id='API_FailS21' target='10' mininterval='300' />
        <Src id='API_FailS22' target='10' mininterval='300' />
        <Src id='API_FailS23' target='10' mininterval='300' />
        <Src id='API_FailS24' target='10' mininterval='300' />
        <Src id='API_FailS25' target='10' mininterval='300' />
        <Src id='API_FailS26' target='10' mininterval='300' />
        <Src id='API_FailS27' target='10' mininterval='300' />
        <Src id='EPIXDownloadFail' target='10' mininterval='300' />
        <Src id='EPIXAuthorFail' target='10' mininterval='300' />
        <Src id='CDNTimeEpix' target='10' mininterval='300' />
        <Src id='SigninTime' target='10' mininterval='300' />
        <Src id='XNACrash' target='10' mininterval='300' />
        <Src id='DASHEXTFail' target='10' mininterval='300' />
        <Src id='SYSEXTFail' target='10' mininterval='300' />
    </Srcs>
</InstrConfig>
";
        public static readonly int defaultQueryWindowSize = 60;
        
        public override void PreRun(RUN_TYPE runType)
        {            
            if (runType == RUN_TYPE.FUNCTIONAL)
                StartListeners();
        }
        public override void PostRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
                StopListeners();            
        }        

        public static void StartListeners()
        {
            //VortexLogBase.StartXomListener(VortexUtil.vortex_Component, clickstreamQuery, VortexUtil.vortex_Interface);
            //VortexLogBase.StartXomListener(VortexUtil.vortex_Component, BaseXomListener.eventTypeCountQuery, VortexUtil.vortex_Interface);
            //VortexLogBase.StartXomListener(VortexUtil.vortex_Component, BaseXomListener.passthroughQuery, VortexUtil.vortex_Interface);
            VortexLogBase.StartXomListener(VortexUtil.vortex_Component, "VortexOutput", VortexUtil.vortex_Interface);
            VortexLogBase.StartXomListener(VortexUtil.vortex_Component, "VortexOutputUnknown", VortexUtil.vortex_Interface);
            
            Thread.Sleep(5000); //On rare cases the first test case can beat the listener set up on the server side.
        }

        public static void StopListeners()
        {
            //VortexLogBase.StopXomListener(VortexUtil.vortex_Component, clickstreamQuery, VortexUtil.vortex_Interface);
            //VortexLogBase.StopXomListener(VortexUtil.vortex_Component, BaseXomListener.eventTypeCountQuery, VortexUtil.vortex_Interface);
            //VortexLogBase.StopXomListener(VortexUtil.vortex_Component, BaseXomListener.passthroughQuery, VortexUtil.vortex_Interface);
            VortexLogBase.StopXomListener(VortexUtil.vortex_Component, "VortexOutput", VortexUtil.vortex_Interface);
            VortexLogBase.StopXomListener(VortexUtil.vortex_Component, "VortexOutputUnknown", VortexUtil.vortex_Interface);
        }                
    }

    /// <summary>
    /// Base class for a Vortex cake test case group. Has
    /// helpers for NPDB and CAKE configuration related stuff.
    /// </summary>
    public class VortexCakeGroup : VortexTestGroup
    {
        #region set of CAKE defaults
        public static CAKE.EventBuilder defaultPassthroughBuilder;
        public static CAKE.EventBuilder defaultEventCountBuilder;
        public static CAKE.Log defaultPtLog;
        public static CAKE.Stream defaultPassthroughStream;
        public static CAKE.Stream defaultEventcountStream;
        public static CAKE.EventSink defaultPassthroughSink;
        public static CAKE.EventSink defaultEventCountSink;
        public static CAKE.Query defaultPassthroughQuery;
        public static CAKE.Query defaultEventCountQuery;
        #endregion


        public static void SetupCAKEPassthrough()
        {
            defaultPassthroughBuilder = CAKE.EventBuilder.Create("PassthroughEvent",
            new string[] { "EventTimestamp", "Id", "FlowToken", "Payload" },
            new string[] { "$(Timestamp)", "$(Id)", "0", "$(*:|)" });
            defaultPassthroughStream = CAKE.Stream.Create("PassthroughEvent", defaultPassthroughBuilder);

            if (defaultPtLog == null)            
                defaultPtLog = CAKE.Log.Create("%", defaultPassthroughStream);            
            else
            {
                defaultPtLog.DeleteFromServer();
                if (defaultPtLog.Streams.Count == 2)
                    defaultPtLog.RemoveStream(defaultPassthroughStream.Name);

                defaultPtLog.AddStream(defaultPassthroughStream);
            }

            defaultPassthroughSink = CAKE.EventSink.Create("XomLogEventSink",
             new string[] { "XomLogArea", "XomLogLevel", "WriteToTrace", "Message", "FlowToken" },
             new string[] { BaseXomListener.passthroughQuery, "0", "true", "$(Id)|$(Payload)", "$(FlowToken)" });
            defaultPassthroughQuery = CAKE.Query.Create(VortexNode.passthroughQueryName, defaultPassthroughSink);

            defaultPtLog.AddUpdateToServer();
            defaultPassthroughQuery.AddUpdateToServer();
        }

        public static void SetupCAKEEventCount()
        {
            defaultEventCountBuilder = CAKE.EventBuilder.Create("EventCountEvent", "Id", "$(Id)");
            defaultEventcountStream = CAKE.Stream.Create("EventCountEvent", defaultEventCountBuilder);

            defaultPtLog.DeleteFromServer();
            if (defaultPtLog == null)
                defaultPtLog = CAKE.Log.Create("%", defaultEventcountStream);
            else
            {
                defaultPtLog.DeleteFromServer();
                if (defaultPtLog.Streams.Count == 2)
                    defaultPtLog.RemoveStream(defaultEventcountStream.Name);

                defaultPtLog.AddStream(defaultEventcountStream);
            }

            defaultEventCountSink = CAKE.EventSink.Create("XomLogEventSink",
                new string[] { "XomLogArea", "XomLogLevel", "WriteToTrace", "Message" },
                new string[] { BaseXomListener.eventTypeCountQuery, "0", "true", "EVENTCOUNT|$(TimeSpanInSeconds)|$(Count)|$(EventId)" });
            defaultEventCountQuery = CAKE.Query.Create(VortexNode.eventTypeCountQueryName, defaultEventCountSink);

            defaultPtLog.AddUpdateToServer();
            defaultEventCountQuery.AddUpdateToServer();
        }

        public static void SetupCAKEDefaults()
        {
            SetupCAKEPassthrough();
            SetupCAKEEventCount();
        }
    }    
    
    /// <summary>
    /// Base class for logstring2 test cases.
    /// </summary>
    public class Logstring2Base : VortexNode
    {
        protected readonly bool _fKeepAlive = false;
        protected static readonly string url = Logstring2Base.BuildUrl("LogString2.ashx");
        

        public static string BuildUrl(string apiName)
        {
            string url;
            IPEndPoint viIP;

            viIP = Global.XEnv.GetVirtualInterface(Interface.authsg);
            url = "http://" + viIP.ToString() + "/vortex/" + apiName;

            Global.RO.Debug(url);
            return url;
        }
    }

    /// <summary>
    /// Base class for logstring test cases.
    /// </summary>
    public class LogstringBase : VortexNode
    {
        protected readonly bool _fKeepAlive = false;
        protected static readonly string url = LogstringBase.BuildUrl("LogString.ashx");        

        public static string BuildUrl(string apiName)
        {
            string url;
            IPEndPoint viIP;

            viIP = Global.XEnv.GetVirtualInterface(VortexUtil.vortex_VirtualInterface);
            url = "http://" + viIP.ToString() + "/vortex/" + apiName;

            Global.RO.Debug(url);
            return url;
        }
    }

    /// <summary>
    /// Used as a base for Vortex config cases. Has helpers to do things like
    /// stop and start the service and do BVT level validations.
    /// </summary>
    public class VortexConfigBase : VortexNode
    {
        protected static readonly string url = Logstring2Base.BuildUrl("LogString2.ashx");
        protected static readonly string lsUrl = LogstringBase.BuildUrl("LogString.ashx");
        protected Dictionary<string, SettingState> NPDBSettings = new Dictionary<string, SettingState>();
        private List<ServiceController> VortexServices;

        /// <summary>
        /// Constructor.
        /// </summary>
        public VortexConfigBase()
        {
            IPEndPoint[] ipEps = ManagementListener.GetXmgmtEndPoints(VortexUtil.vortex_Interface);
            VortexServices = new List<ServiceController>();
            foreach (IPEndPoint ipEp in ipEps)
            {
                string ip = ipEp.Address.ToString();
                VortexServices.Add(new ServiceController("vortexfd", ip));
            }
        }   

        /// <summary>
        /// Updates a specific NPDB setting to a specific value, then keeps track of the previous state to
        /// restore later. 
        /// </summary>
        /// <param name="setting"></param>
        /// <param name="settingValue"></param>
        public void UpdateNPDBSetting(string setting, string settingValue)
        {
            NPDBSettings.Add(setting, Global.XEnv.OverrideSetting(VortexUtil.vortex_Component, "ALL", setting, settingValue));
            Global.XEnv.ForceConfigReload(VortexUtil.vortex_Interface);
        }        

        /// <summary>
        /// Restores a specific recorded NPDB settings change.
        /// </summary>
        /// <param name="setting"></param>
        public void RestoreNPDBSetting(string setting)
        {
            
            if (NPDBSettings.ContainsKey(setting))            
                Global.XEnv.RestoreOverrideSettingState(NPDBSettings[setting]);            

            NPDBSettings.Remove(setting);
            
            Global.XEnv.ForceConfigReload(VortexUtil.vortex_Interface);
        }

        /// <summary>
        /// Restores all recorded NPDB settings changes.
        /// </summary>
        public void RestoreNPDBSettings()
        {
            try
            {
                foreach (SettingState state in NPDBSettings.Values)
                {                    
                    Global.XEnv.RestoreOverrideSettingState(state);
                }
            }
            catch (Exception ex)
            {
                Global.RO.Debug("This could be serious business. Failed to restore one or more NPDB settings because of exception: " + ex.Message);
                throw ex;
            }
            finally
            {
                NPDBSettings.Clear();
            }
            
            Global.XEnv.ForceConfigReload(VortexUtil.vortex_Interface);
        }

        #region Helper methods
        /// <summary>
        /// Validates that absolutely nothing has been heard on the listeners.
        /// </summary>
        /// <param name="expectSilence"></param>
        public void ValidateSilent(bool expectSilence)
        {
            BaseXomListener.FlushXomLogCache();
            ValidatePassthrough(false);            

            int countSnapshot = BaseXomListener.CachedLogCount;
            if ((countSnapshot > 0) && expectSilence)
                throw new Exception(String.Format("We had {0} items in the cache No Way!", countSnapshot));
        }

        /// <summary>
        /// This is essentially a BVT level check of the passthrough query
        /// </summary>
        /// <param name="expectSuccess"></param>
        public void ValidatePassthrough(bool expectSuccess)
        {
            Thread.Sleep(5000); //Give it a second to stop or start.
            if (expectSuccess)
                Global.RO.Debug("Validating that the passthrough pipeline works.");
            else
                Global.RO.Debug("Validating that the passthrough pipeline does not work.");

            VortexLS ls = new VortexLS(lsUrl);

            ls.AddUpdateParameter(1, "LS_ValidatePassthrough");            

            try
            {
                ls.SendRequest();
            }
            catch (Exception ex)
            {
                //@@@TODO:Check proper exception
                if (expectSuccess)
                    throw ex;
                else
                    return;
            }

            if (!expectSuccess)
                throw new Exception("Should not have successfully received a message on the listener.");
        }

        /// <summary>
        /// This is essentially a BVT level check of the passthrough query
        /// </summary>
        /// <param name="expectSuccess"></param>
        public void ValidateAreaTrace(bool expectSuccess)
        {
            Thread.Sleep(5000); //Give it a second to stop or start.
            if (expectSuccess)
                Global.RO.Debug("Validating that the tracing pipeline works.");
            else
                Global.RO.Debug("Validating that the tracing pipeline does not work.");

            VortexLS ls = new VortexLS(url);

            ls.AddUpdateParameter(1, "Validate_Passthrough");                        

            try
            {
                BaseXomListener.StopAllXomListeners();
                BaseXomListener.StartXomListener(VortexUtil.vortex_Component, "vortextrace", VortexUtil.vortex_Interface);
                ls.SendRequest();
                BaseXomListener.StopXomListener(VortexUtil.vortex_Component, "vortextrace", VortexUtil.vortex_Interface);
                BaseXomListener.RestartXomListeners();                
            }
            catch (Exception)
            {
                //@@@TODO:Check proper exception
                if (expectSuccess)
                    throw;
                else
                    return;
            }
            finally
            {
                BaseXomListener.RestartXomListeners();
            }

            if (!expectSuccess)
                throw new Exception("Should not have successfully received a message on the listener.");
        }

        /// <summary>
        /// This is essentially a BVT level check of the clickstream histogram query
        /// </summary>
        /// <param name="expectSuccess"></param>
        public void ValidateHistogram(bool expectSuccess)
        {
            try
            {
                int eventCount = 1;

                //Set up the different events
                List<VortexLS2> types = new List<VortexLS2>();
                List<VortexEventtypeCount> validators = new List<VortexEventtypeCount>();

                for (int k = 0; k < eventCount; k++)
                {
                    VortexLS2 newType = new VortexLS2(url);
                    newType.AddUpdateParameter(LS2Fields.Area, "Area" + k.ToString());
                    newType.AddUpdateParameter(LS2Fields.PageName, "TheOnlyPage");
                    newType.AddUpdateParameter(LS2Fields.EventType, "TheOnlyEventType");
                    types.Add(newType);

                    VortexEventtypeCount newValidator = new VortexEventtypeCount("Area" + k.ToString(), k % 10 + 1, VortexTestGroup.defaultQueryWindowSize); //Max of 10
                    validators.Add(newValidator);
                }

                ro.Debug("Flush out the stuff that's there...");
                VortexLS2 flusher = new VortexLS2(url);
                flusher.AddUpdateParameter(1, "flush");
                flusher.SendRequest();
                VortexLogBase.FlushXomLogCache();

                ro.Debug("Send the payload:");
                //
                for (int k = 0; k < eventCount; k++) //For every event type
                {
                    for (int j = 0; j < k % 10 + 1; j++) //Send index%10+1 (1 through 10) total point events
                        types[k].SendRequest(false);
                }

                ro.Debug("Now flush and validate!");
                flusher.SendRequest();
                foreach (VortexEventtypeCount vH in validators)
                    vH.Validate();
            }
            catch (Exception ex)
            {
                //@@@TODO:Check proper exception
                if (expectSuccess)
                    throw ex;
                else
                    return;
            }

            if (!expectSuccess)
                throw new Exception("Should not have successfully received a message on the listener.");
        }
        
        public long[] GetPerformanceCounterValues(string category, string counterName, string instanceName)
        {
            string[] vortexServers = Global.XEnv.GetServerListByInterface(Interface.vortexfd);                

            List<long> results = new List<long>();
            foreach (string srv in vortexServers)
            {
                PerformanceCounter counter = new PerformanceCounter(category, counterName, instanceName, srv);
                results.Add(counter.RawValue);
            }

            return results.ToArray();
        }

        /// <summary>
        /// Starts the vortex service and waits for it to be ready.
        /// </summary>
        public void StartService()
        {
            DateTime start = DateTime.Now;
            foreach (ServiceController svc in VortexServices)
            {
                svc.Start();
                svc.WaitForStatus(ServiceControllerStatus.Running, new TimeSpan(0,0,60));
            }

            //Max of a minute
            while ((DateTime.Now - start).TotalSeconds < 60)
            {
                Global.RO.Debug("Calling List Areas to verify that vortex is up and running.");

                string result = String.Empty;
                try
                {
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortexfd la", out result);
                }
                catch (Exception)
                {
                    //Swallow
                }
                if (result.Contains("vortextrace"))
                    return;
                else
                    Thread.Sleep(3000);
            }

        }

        /// <summary>
        /// Stop and start.
        /// </summary>
        public void RestartService()
        {
            RestartService(false);
            Thread.Sleep(10000); //Stupid queries... take a bit to wake up.
        }

        /// <summary>
        ///  Best effort makes it try to start it up even if it was down or something weird.
        /// </summary>
        public void RestartService(bool bestEffort)
        {
            BaseXomListener.StopAllXomListeners();
            try
            {
                StopService();
            }
            catch (Exception)            
            {
                Global.RO.Warn("While trying to stop the vortex service something screwed up.");
                if (!bestEffort)                
                    throw;
            }
            try
            {
                StartService();
            }
            catch (Exception)
            {
                Global.RO.Warn("While trying to start the vortex service something screwed up.");
                if (!bestEffort)
                    throw;
                else
                    StartService(); // Try one more time...
            }
            BaseXomListener.RestartXomListeners();
        }

        /// <summary>
        /// Stops the vortex service and waits for it to be *really* down.
        /// </summary>
        public void StopService()
        {
            DateTime start = DateTime.Now;
            foreach (ServiceController svc in VortexServices)
            {
                svc.Stop();
                svc.WaitForStatus(ServiceControllerStatus.Stopped, new TimeSpan(0, 0, 60));
            }

            //Max of a minute
            while ((DateTime.Now - start).TotalSeconds < 60)
            {
                Global.RO.Debug("Calling List Areas to verify that vortex is no longer up and running.");
                string result = String.Empty;
                try
                {
                    ManagementConsole.ExecuteOnAll(VortexUtil.vortex_Interface, "e :vortexfd la", out result);
                }
                catch (Exception)
                {
                    //swallow
                }
                if (result.Contains("Process/Component not found"))
                {
                    Thread.Sleep(5000); //Give it some more time, sometimes it's still not REALLY up.
                    return;
                }
                else
                    Thread.Sleep(3000);
            }            
        }
        #endregion Helper methods


    }

    /// <summary>
    /// Basis for vortex CAKE configuration cases. Contains helper methods for
    /// manipulating NPDB.
    /// </summary>
    public class VortexCAKEConfigBase : VortexConfigBase
    {
        public const string PassthroughStreamName = "PassthroughEvent";
        public const string EventTypeStream = "EventCountEvent";            
        protected List<CAKE.NPDBSetting> settings = new List<CAKE.NPDBSetting>();        

        public override void PreRun()
        {
            EmptyCake();
            VortexCakeGroup.SetupCAKEDefaults();            
        }
        
        /// </summary>
        public override void PostRun()
        {
            ResetCAKE(true);
            ValidatePassthrough(true);
        }        

        protected void AddToCAKE(CAKE.NPDBSetting setting)
        {
            setting.AddUpdateToServer();
            settings.Add(setting);
        }        

        /// <summary>
        /// Empties out cake from NPDB and then reloads it.
        /// The best effort flag is used for "finallys". Tries its best 
        /// to start the process if it's in a bad state.
        /// </summary>
        /// <param name="bestEffortRestart"></param>
        protected void ResetCAKE(bool bestEffortRestart)
        {
            EmptyCake();            
            RestartService(bestEffortRestart);                                    
        }

        /// <summary>
        /// Default of false to catch crash issues.
        /// </summary>
        protected void ResetCAKE()
        {
            ResetCAKE(false);
        }

        /// <summary>
        /// Empties out cake from NPDB but does not reload it.
        /// </summary>
        public void EmptyCake()
        {
            settings.Clear();
            CAKE.Query query = new CAKE.Query();
            CAKE.Log log = new CAKE.Log();
            //UberLame
            log.DeleteALLFromServer();
            query.DeleteALLFromServer();
        }

        /// <summary>
        /// Used for the parser test cases. Sets up a single new logline with a specific recipe
        /// </summary>
        /// <param name="recipe"></param>
        /// <param name="loglineId"></param>
        protected void SetupTestParser(string recipe, string loglineId)
        {
            CAKE.EventBuilder testBuilder = CAKE.EventBuilder.Create("TestBuilder", "Payload", recipe);
            CAKE.Stream testPassthroughStream = CAKE.Stream.Create("PassthroughEvent", testBuilder);            
            CAKE.Log log = CAKE.Log.Create(loglineId, testPassthroughStream); 

            AddToCAKE(log);            
            
            RestartService();            
        }

        /// <summary>
        /// Used for the parser test cases. 
        /// Sends ID, then we add value0, then we add value1, then finally we add value2-9
        /// Essentially: 
        ///  TestName
        ///  TestName|value0
        ///  TestName|value0|value1
        ///  TestName|value0|value1|value2|value3|value4|value5|value6|value7|value8|value9
        /// </summary>
        /// <param name="loglineId"></param>
        /// <param name="expectedValues"></param>
        protected void SendValidateLogstringParserMessage(string loglineId, string[] expectedValues)
        {
            VortexLS ls = new VortexLS(LogstringBase.BuildUrl("LogString.ashx"));

            ls.AddUpdateParameter(0, loglineId);
            ls.ExpectedResultOverride = expectedValues[0];            
            ls.SendRequest();

            ls.AddUpdateParameter(1, "value0");
            ls.ExpectedResultOverride = expectedValues[1];
            ls.SendRequest();

            ls.AddUpdateParameter(2, "value1");
            ls.ExpectedResultOverride = expectedValues[2];
            ls.SendRequest();

            for (int k = 2; k < 10; k++)
                ls.AddUpdateParameter(k + 1, "value" + k.ToString());
            ls.ExpectedResultOverride = expectedValues[3];
            ls.SendRequest();
        }
    }

    /// <summary>
    /// Contains some common Vortex stuff. Base class of other lower level node types.
    /// </summary>
    public class VortexNode : TestNode
    {
        protected static Report ro = new Report("VortexTest");
        public const string passthroughQueryName = "PassthroughQuery";
        //protected const string clickStreamQueryName = "ClickStreamCount";
        public const string eventTypeCountQueryName = "EventTypeCountQuery";
        protected static int stressLoopdyLoop;
        protected static object stressLoopdyLock = new Object();
    }    

    /// <summary>
    /// Used as a base for vortex protocol test cases.
    /// </summary>
    public class VortexProtocolBase : TestNode
    {
        protected Random rand = new Random();
    }

    /// <summary>
    /// Used for manifest related test cases read from an XML file.
    /// </summary>
    public class SerializableTestCase : TestNode, IXmlSerializable
    {
        public List<string> InputXmls { get; set; }
        public string XMLExpectedException { get; set; }
        public string XMLPriority { get; set; }
        public string XMLParent { get; set; }

        public SerializableTestCase()
        {
            Init();
        }

        public SerializableTestCase(string name)
            : base(name)
        {
            Init();
        }

        public void Init()
        {
            InputXmls = new List<string>();
        }

        #region IXmlSerializable Members

        public System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }

        public void ReadXml(XmlReader reader)
        {
            if (reader.NodeType == XmlNodeType.None)
                reader.ReadToFollowing(this.GetType().Name);

            this.Name = reader["name"];
            this.Desc = reader["description"];
            this.XMLParent = reader["parent"];

            this.XMLPriority = reader["priority"];

            reader.ReadStartElement(this.GetType().Name);
            while (reader.NodeType != System.Xml.XmlNodeType.EndElement && reader.NodeType != XmlNodeType.None)
            {
                if (reader.Name == "InputXML")
                    InputXmls.Add(reader.ReadInnerXml());
                else if (reader.Name == "ExpectedException")
                {
                    reader.ReadStartElement("ExpectedException");
                    XMLExpectedException = reader.ReadString();
                    reader.ReadEndElement();
                }
            }
            reader.ReadEndElement();
        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteAttributeString("name", Name);
            writer.WriteAttributeString("description", Desc);
            writer.WriteAttributeString("priority", XMLPriority);
            writer.WriteAttributeString("name", XMLParent);

            foreach (string input in InputXmls)
            {
                writer.WriteStartElement("InputXML");
                writer.WriteValue(input);
                writer.WriteEndElement();
            }

            if (XMLExpectedException != null)
            {
                writer.WriteStartElement("ExpectedException");
                writer.WriteValue(XMLExpectedException);
                writer.WriteEndElement();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\EtxTestdataViewer\EtxTestdataViewer.cs ===
using System;
using System.IO;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

using xonline.common.protocol;
using xonline.common.utilities2;

namespace EtxTestDataViewer
{
    public partial class EtxTestdataViewer : Form
    {
        public EtxTestdataViewer()
        {            
            InitializeComponent();
        }

        private void txtDirectory_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
                UpdateFileView();
        }

        private void UpdateFileView()
        {
            string directory = txtDirectory.Text;

            if (!String.IsNullOrEmpty(directory) && Directory.Exists(directory))
            {
                lvFiles.Items.Clear();
                DirectoryInfo info = new DirectoryInfo(directory);
                FileInfo[] files = info.GetFiles("*.etx");

                foreach (FileInfo file in files)
                    lvFiles.Items.Add(file.Name);
            }
        }

        private void lvFiles_ItemSelectionChanged(object sender, ListViewItemSelectionChangedEventArgs e)
        {
            string fileName = e.Item.Text;
            string filePath = txtDirectory.Text + "\\" + fileName;
            dvFields.Rows.Clear();
            if (File.Exists(filePath))
            {
                StringBuilder content = new StringBuilder();
                FileStream str = new FileStream(filePath, FileMode.Open);
                try
                {
                    List<VxEvent> currentEvents = VxProtocol.ReadStream(str);
                    dvFields.AllowUserToAddRows = true;
                    foreach (VxEvent evt in currentEvents)
                    {
                        content.AppendFormat("Producer ID:{0}\r\nEvent ID:{1}\r\nTimestamp:{2}\r\nLogstring Logline:\r\n{3}\r\n", (evt.ProducerId != null) && (evt.ProducerId.Length > 0) ? evt.ProducerId.ToString() : "N/A", evt.EventId, evt.Timestamp, evt.ToString());

                        VxEvent.VortexFieldCollection coll = evt.EventFields;
                        uint max = coll.MaxFieldOrdinal;

                        for (uint k = 0; k <= max; k++)
                        {
                            object o;

                            if (coll.TryGetField(k, out o))
                            {
                                object value;
                                string type = String.Empty;
                                if (o is SpecialField)
                                {
                                    SpecialField sf = o as SpecialField;
                                    value = sf.Value;                                    
                                }
                                else                                
                                    value = o;
                                
                                type = value.GetType().ToString() + " " + type;
                                if (value is Byte[])
                                    value = ((Blob)(byte[])value);
                                
                                dvFields.Rows.Insert(dvFields.Rows.Count - 1, new string[] { k.ToString(), evt.EventId.ToString(), type, value.ToString() });
                            }
                        }

                        content.AppendFormat("\r\n\r\n");
                    }
                    content.AppendFormat("Summary:\r\n");
                    foreach (VxEvent evt in currentEvents)
                    {                        
                        content.AppendFormat(evt.ToString() + "\r\n");
                    }
                    content.AppendFormat("\r\n\r\n");
                    dvFields.AllowUserToAddRows = false;
                }
                catch (Exception ex)
                {
                    content.Append("-----------------------------\r\n");
                    content.AppendFormat("Error: " + ex.Message + "\r\n");
                    content.AppendFormat("Error: " + ex.StackTrace + "\r\n");
                    content.Append("-----------------------------\r\n");
                }
                finally
                {
                    str.Close();
                }
                if (content.Length == 0)
                    content.Append(File.ReadAllText(filePath));

                txtContents.Text = content.ToString();
            }
        }

        private void EtxTestDataViewer_Load(object sender, EventArgs e)
        {
            UpdateFileView();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\test\vortexstf\VortexCake.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.STFLive;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Vortex;

using xonline.common.config;
using xonline.common.stfutil;

using CAKE = ServerTestFramework.LiveService.Vortex.CAKE;

namespace xonline.test.vortex
{
    #if false //Vortex test cases are out until Vortex INH work comes back to life. Disabling. :(
    [TestGroup, Owner("wisgt"), Description("Test cases related to CAKE functionality.")]
    public class CAKETests : TestNode
    {
        /// <summary>
        /// @@@TODO: Assign frequency and priority
        /// </summary>
        [TestGroup, Owner("wisgt"), Description("CAKE XML config test cases")]
        class VortexCakeConfigCases : VortexTestGroup
        {
            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a log item with an empty id. Should be either blocked or skipped and should not interfere with regular operation."), EnvRequirement("XblobOnly")]
            public class Log_EmptyID : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    CAKE.EventBuilder eventCountBuilder = CAKE.EventBuilder.Create("EventCountEvent", "Id", "$(Id)");
                    CAKE.Stream eventCountStream = CAKE.Stream.Create("EventCountEvent", eventCountBuilder);
                    CAKE.Log log = CAKE.Log.Create("", eventCountStream);

                    AddToCAKE(log);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);
                    ResetCAKE(false);
                    ValidatePassthrough(true);
                    return TEST_RESULTS.PASSED;
                }

            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a log item with null id. Should be either blocked or skipped and should not interfere with regular operation."), EnvRequirement("XblobOnly")]
            public class Log_NoID : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    CAKE.EventBuilder eventCountBuilder = CAKE.EventBuilder.Create("EventCountEvent", "Id", "$(Id)");
                    CAKE.Stream eventCountStream = CAKE.Stream.Create("EventCountEvent", eventCountBuilder);
                    CAKE.Log log = CAKE.Log.Create(null, eventCountStream);

                    AddToCAKE(log);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a duplicate log item. This second one should be either blocked or skipped and should not interfere with regular operation."), EnvRequirement("XblobOnly")]
            public class Log_DuplicateLogs : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    CAKE.Stream badStream = CAKE.Stream.Create("ZBadEvent", VortexCakeGroup.defaultPassthroughBuilder);
                    CAKE.Log badLog = CAKE.Log.Create("%", badStream); //Null                                
                    AddToCAKE(badLog);

                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Deletes all log items from NPDB overrides. Vortex should start with default built-in defaults. This should not interfere with regular operation."), EnvRequirement("XblobOnly")]
            public class Log_NoLogsDefined : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    VortexCakeGroup.defaultPtLog.DeleteALLFromServer();

                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }


            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a log item with no streams defined. Should be either blocked or skipped and should not interfere with regular operation."), EnvRequirement("XblobOnly")]
            public class Log_NoStreamsDefined : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    CAKE.Log log = new CAKE.Log(this.Name);

                    AddToCAKE(log);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a stream with a null name. Should be skipped or blocked. This should not interfere with regular operation."), EnvRequirement("XblobOnly")]
            public class Stream_NullName : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    CAKE.EventBuilder eventCountBuilder = CAKE.EventBuilder.Create("EventCountEvent", "Id", "$(Id)");
                    CAKE.Stream badStream = CAKE.Stream.Create(null, eventCountBuilder);
                    CAKE.Log log = CAKE.Log.Create("SomeLogline", badStream);

                    AddToCAKE(log);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }


            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a stream with an empty name. Should be skipped or blocked. This should not interfere with regular operation."), EnvRequirement("XblobOnly")]
            public class Stream_EmptyName : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    CAKE.EventBuilder eventCountBuilder = CAKE.EventBuilder.Create("EventCountEvent", "Id", "$(Id)");
                    CAKE.Stream badStream = CAKE.Stream.Create(String.Empty, eventCountBuilder);
                    CAKE.Log log = CAKE.Log.Create("SomeLogline", badStream);

                    AddToCAKE(log);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a stream with no builders. Should be skipped or blocked. This should not interfere with regular operation."), EnvRequirement("XblobOnly")]
            public class Stream_NoBuilders : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    CAKE.Stream badStream = new CAKE.Stream("EventCountEvent");
                    CAKE.Log log = CAKE.Log.Create("SomeLogline", badStream);

                    AddToCAKE(log);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a stream with multiple builders. @@@TODO:Need to look into what the definition is for this. For now at least this should not interfere with regular operation."), EnvRequirement("XblobOnly")]
            public class Stream_MultipleBuilders : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    CAKE.EventBuilder eventCountBuilder = CAKE.EventBuilder.Create("EventCountEvent", "Id", "$(Id)");
                    CAKE.EventBuilder eventCountBuilder2 = CAKE.EventBuilder.Create("EventCountEvent2", "Id", "$(Id)");
                    CAKE.Stream eventCountStream = CAKE.Stream.Create("EventCountEvent", eventCountBuilder);
                    eventCountStream.Builders.Add(eventCountBuilder2);
                    CAKE.Log log = CAKE.Log.Create("SomeLine", eventCountStream);

                    AddToCAKE(log);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a stream that does not map to a SI object. Should not affect operation."), EnvRequirement("XblobOnly")]
            public class Stream_NoSIMapping : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    CAKE.EventBuilder eventCountBuilder = CAKE.EventBuilder.Create("EventCountEvent", "Id", "$(Id)");
                    CAKE.Stream eventCountStream = CAKE.Stream.Create("BadEventCrap", eventCountBuilder);
                    CAKE.Log log = CAKE.Log.Create("SomeLine", eventCountStream);

                    AddToCAKE(log);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a query with no sinks. Should not affect operation."), EnvRequirement("XblobOnly")]
            public class Query_NoSinks : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    VortexCakeGroup.defaultEventCountQuery.DeleteFromServer();

                    CAKE.Query eventCountQuery = new CAKE.Query(VortexNode.eventTypeCountQueryName);

                    AddToCAKE(eventCountQuery);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a duplicate of a query. Should not affect operation."), EnvRequirement("XblobOnly")]
            public class Query_DuplicateQueries : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    CAKE.Query eventCountQuery = new CAKE.Query(VortexNode.eventTypeCountQueryName);

                    AddToCAKE(eventCountQuery);
                    RestartService();
                }

                public override void Run()
                {
                    Global.RO.Debug("Trying passthrough, should work because it picked up the first one and ignored the second.");
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a query with a null name. Should be skipped or blocked and should not affect operation."), EnvRequirement("XblobOnly")]
            public class Query_NullName : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    CAKE.Query eventCountQuery = new CAKE.Query(null);

                    AddToCAKE(eventCountQuery);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a query with an empty name. "), EnvRequirement("XblobOnly")]
            public class Query_EmptyName : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    CAKE.Query eventCountQuery = new CAKE.Query(String.Empty);

                    AddToCAKE(eventCountQuery);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a query with a name that does not match any real Vortex query."), EnvRequirement("XblobOnly")]
            public class Query_BadName : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    CAKE.Query eventCountQuery = new CAKE.Query("SomeCrapOrOther");

                    AddToCAKE(eventCountQuery);
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Removes all queries from NPDB. Defaults should be loaded."), EnvRequirement("XblobOnly")]
            public class Query_NoQueries : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    VortexCakeGroup.defaultEventCountQuery.DeleteFromServer();
                    VortexCakeGroup.defaultPassthroughQuery.DeleteFromServer();

                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a sink with no fields. Should be skipped. "), EnvRequirement("XblobOnly")]
            public class Sink_NoFields : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    EmptyCake();
                    VortexCakeGroup.SetupCAKEPassthrough();

                    CAKE.EventSink eventCountSink = CAKE.EventSink.Create("XomLogEventSink",
                        new string[] { },
                        new string[] { });
                    CAKE.Query eventCountQuery = CAKE.Query.Create(VortexNode.eventTypeCountQueryName, eventCountSink);

                    AddToCAKE(eventCountQuery);

                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a sink with a null name. Should be skipped."), EnvRequirement("XblobOnly")]
            public class Sink_NullName : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    EmptyCake();
                    VortexCakeGroup.SetupCAKEPassthrough();

                    CAKE.EventSink eventCountSink = CAKE.EventSink.Create(null,
                        new string[] { "XomLogArea", "XomLogLevel", "WriteToTrace", "Message" },
                        new string[] { BaseXomListener.eventTypeCountQuery, "0", "true", "EVENTCOUNT|$(TimeSpanInSeconds)|$(Count)|$(EventId)" });
                    CAKE.Query eventCountQuery = CAKE.Query.Create(VortexNode.eventTypeCountQueryName, eventCountSink);

                    AddToCAKE(eventCountQuery);

                    RestartService();

                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a sink with an empty name. Should be skipped."), EnvRequirement("XblobOnly")]
            public class Sink_EmptyName : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    VortexCakeGroup.SetupCAKEPassthrough();

                    CAKE.EventSink eventCountSink = CAKE.EventSink.Create("",
                        new string[] { "XomLogArea", "XomLogLevel", "WriteToTrace", "Message" },
                        new string[] { BaseXomListener.eventTypeCountQuery, "0", "true", "EVENTCOUNT|$(TimeSpanInSeconds)|$(Count)|$(EventId)" });
                    CAKE.Query eventCountQuery = CAKE.Query.Create(VortexNode.eventTypeCountQueryName, eventCountSink);

                    AddToCAKE(eventCountQuery);

                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Creates a sink with an empty name. Should be skipped."), EnvRequirement("XblobOnly")]
            public class Sink_InvalidXomLogLevel : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();

                    VortexCakeGroup.SetupCAKEDefaults();

                    VortexCakeGroup.defaultPassthroughQuery.DeleteFromServer();

                    CAKE.EventSink passthroughSink = CAKE.EventSink.Create("XomLogEventSink",
                        new string[] { "XomLogArea", "XomLogLevel", "WriteToTrace", "Message", "FlowToken" },
                        new string[] { BaseXomListener.passthroughQuery, "8128", "true", "$(Id)|$(Payload)", "$(FlowToken)" });
                    CAKE.Query passthroughQuery = CAKE.Query.Create(VortexNode.passthroughQueryName, passthroughSink);

                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }


            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Removes all overrides from CAKE and falls through to defaults."), EnvRequirement("XblobOnly")]
            public class CAKE_Nothing : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    EmptyCake();
                    RestartService();
                }

                public override void Run()
                {
                    ValidatePassthrough(true);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description("Sends bad XML to each of the items. Not done."), EnvRequirement("XblobOnly")]
            public class CAKE_MalformedXML : VortexCAKEConfigBase
            {
                public override void PreRun()
                {
                    base.PreRun();
                    EmptyCake();
                    RestartService();
                }

                public override void Run()
                {
                    throw new NotImplementedException();
                    /*ValidatePassthrough(false);
                    ResetCAKE();
                    ValidatePassthrough(true);
                     */
                }
            }


        }

        [TestGroup, Owner("wisgt"), Description("CAKE XML config test cases")]
        class VortexCakeParserCases : VortexTestGroup
        {
            //Test assuming we send ID, then we add value0, then we add value1, then finally we add value2-9
            //Essentially: 
            //  TestName
            //  TestName|value0
            //  TestName|value0|value1
            //  TestName|value0|value1|value2|value3|value4|value5|value6|value7|value8|value9
            [TestCase, TestCasePriority(2), TestFrequency("Regression"), Description(""), EnvRequirement("XblobOnly")]
            [CompoundCase("1Item", "$0", new string[] { "", "value0", "value0", "value0" })]
            [CompoundCase("2Items", "$0$1", new string[] { "", "value0", "value0value1", "value0value1" })]
            [CompoundCase("3Items", "$0$2$4", new string[] { "", "value0", "value0", "value0value2value4" })]
            [CompoundCase("3WithLiterals", "What up son $0|$2|$4 What up son", new string[] { "What up son || What up son", "What up son value0|| What up son", "What up son value0|| What up son", "What up son value0|value2|value4 What up son" })]
            [CompoundCase("Edges", "$0|$1|$8|$9", new string[] { "|||", "value0|||", "value0|value1||", "value0|value1|value8|value9" })]
            [CompoundCase("OutOfRange", "$1000", new string[] { "", "", "", "" })]
            [CompoundCase("NamedMatching", "$(id)", new string[] { "NamedMatching", "NamedMatching", "NamedMatching", "NamedMatching" })]
            [CompoundCase("NamedNotMatching", "$(id2)", new string[] { "", "", "", "" })]
            [CompoundCase("BadParentheses", "$(id2", new string[] { "$(id2", "$(id2", "$(id2", "$(id2" })]
            [CompoundCase("NamedSpecialCharacter", "$(id;)", new string[] { "$(id;)", "$(id;)", "$(id;)", "$(id;)" })]
            [CompoundCase("OrdinalTwoDollars", "$$0", new string[] { "$", "$value0", "$value0", "$value0" })]
            [CompoundCase("NamedTwoDollars", "$$(id)", new string[] { "$NamedTwoDollars", "$NamedTwoDollars", "$NamedTwoDollars", "$NamedTwoDollars" })]
            [CompoundCase("ParenthesesWithoutDollar", "($0)", new string[] { "()", "(value0)", "(value0)", "(value0)" })]
            [CompoundCase("OrdinalSetJoinLiteral", "$(0-5:|)", new string[] { "|||||", "value0|||||", "value0|value1||||", "value0|value1|value2|value3|value4|value5" })]
            [CompoundCase("OrdinalSetJoinNoLiteral", "$(0-5)", new string[] { "", "value0", "value0value1", "value0value1value2value3value4value5" })]
            [CompoundCase("UniversalSetJoinLiteral", "$(*:|)", new string[] { "", "value0", "value0|value1", "value0|value1|value2|value3|value4|value5|value6|value7|value8|value9" })]
            [CompoundCase("UniversalSetJoinNoLiteral", "$(*)", new string[] { "", "value0", "value0value1", "value0value1value2value3value4value5value6value7value8value9" })]
            public class Logstring_Parser_Base : VortexCAKEConfigBase
            {
                string name;
                string recipe;
                string[] expectedResults;
                public override void PreRun()
                {
                    name = Name;
                    recipe = (string)MyValues[0];
                    string[] expectedResultsOrig = (string[])MyValues[1];
                    expectedResults = new string[expectedResultsOrig.Length];
                    for (int k = 0; k < expectedResults.Length; k++)
                        expectedResults[k] = "|" + expectedResultsOrig[k];

                    VortexCakeGroup.SetupCAKEDefaults();
                    SetupTestParser(recipe, name);
                }

                public override void Run()
                {
                    SendValidateLogstringParserMessage(name, expectedResults);
                    return TEST_RESULTS.PASSED;
                }

                public override void PostRun()
                {
                    EmptyCake();
                }

            }

        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\EtxTestdataViewer\Program.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace EtxTestDataViewer
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new EtxTestdataViewer());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\EtxTestdataViewer\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("EtxTestDataViewer")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("EtxTestDataViewer")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8269d70e-2f74-4d82-a51b-d154f9aa9377")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\EtxTestdataViewer\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace EtxTestDataViewer.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("EtxTestDataViewer.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VortexLogFeeder\FeederForm.cs ===
using System;
using System.Configuration;
using System.Threading;
using System.Text.RegularExpressions;
using System.IO;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace VortexLogFeeder
{
    public partial class FeederForm : Form
    {
        public FeederForm()
        {
            InitializeComponent();
            LoadConfig();
        }
        
        #region Event handlers
        private void btnFeed_Click(object sender, EventArgs e)
        {            
            int multiplier;
            Int32.TryParse(txtMultiplier.Text, out multiplier); 
            
            try
            {                                   
                Logstring2Feeder ls2Feeder = new Logstring2Feeder(txtUrl.Text, txtFile.Text, multiplier, Convert.ToInt32(txtSecondsCap.Text), new ScreenLog(Log)); //Kick stuff off.                
                LogstringFeeder lsFeeder = new LogstringFeeder(txtUrl.Text, txtFile.Text, multiplier, Convert.ToInt32(txtSecondsCap.Text), new ScreenLog(Log)); //Kick stuff off.                
                ls2Feeder.StartFeeding();
                lsFeeder.StartFeeding();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message, "Muy bad!");
            }
        }        

        private void Feeder_FormClosed(object sender, FormClosedEventArgs e)
        {
            Logstring2Feeder.KillThreads();
            SaveConfig();
        }

        private void btnStopFeeders_Click(object sender, EventArgs e)
        {
            Logstring2Feeder.KillThreads();
        }
        #endregion Event handlers

        private void Log(string log, int level)
        {
            if (InvokeRequired)
            {
                this.Invoke(new Action<string, int>(Log), log, level);
                return;
            }

            if (chkLog.Checked || level == 0)
            {
                if (txtLog.Text.Length > 20000)
                    txtLog.Clear();
                txtLog.Text += String.Format("{0}\r\n\r\n", log);
                this.txtLog.SelectionStart = txtLog.Text.Length;
                this.txtLog.ScrollToCaret();
            }
        }

        private void LoadConfig()
        {
            string temp = ConfigurationManager.AppSettings["urlText"];

            if (!String.IsNullOrEmpty(temp))
                txtUrl.Text = temp;

            temp = ConfigurationManager.AppSettings["filePath"];

            if (!String.IsNullOrEmpty(temp))
                txtFile.Text = temp;
        }

        private void SaveConfig()
        {
            Configuration config = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
            KeyValueConfigurationCollection settings = config.AppSettings.Settings;

            if (null == settings["urlText"])
                settings.Add("urlText", txtUrl.Text);
            else
                settings["urlText"].Value = txtUrl.Text;

            if (null == settings["filePath"])
                settings.Add("filePath", txtFile.Text);
            else
                settings["filePath"].Value = txtFile.Text;

            config.Save();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\EtxTestdataViewer\EtxTestdataViewer.Designer.cs ===
namespace EtxTestDataViewer
{
    partial class EtxTestdataViewer
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.txtDirectory = new System.Windows.Forms.TextBox();
            this.lblDirectory = new System.Windows.Forms.Label();
            this.txtContents = new System.Windows.Forms.TextBox();
            this.lblContents = new System.Windows.Forms.Label();
            this.lvFiles = new System.Windows.Forms.ListView();
            this.lblFiles = new System.Windows.Forms.Label();
            this.formSplitter = new System.Windows.Forms.SplitContainer();
            this.dvFields = new System.Windows.Forms.DataGridView();
            this.colOrdinal = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colEvtOrdinal = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colType = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colValue = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.formSplitter.Panel1.SuspendLayout();
            this.formSplitter.Panel2.SuspendLayout();
            this.formSplitter.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.dvFields)).BeginInit();
            this.SuspendLayout();
            // 
            // txtDirectory
            // 
            this.txtDirectory.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.txtDirectory.Location = new System.Drawing.Point(16, 24);
            this.txtDirectory.Name = "txtDirectory";
            this.txtDirectory.Size = new System.Drawing.Size(762, 20);
            this.txtDirectory.TabIndex = 0;
            this.txtDirectory.Text = "C:\\";
            this.txtDirectory.KeyDown += new System.Windows.Forms.KeyEventHandler(this.txtDirectory_KeyDown);
            // 
            // lblDirectory
            // 
            this.lblDirectory.AutoSize = true;
            this.lblDirectory.Location = new System.Drawing.Point(13, 8);
            this.lblDirectory.Name = "lblDirectory";
            this.lblDirectory.Size = new System.Drawing.Size(52, 13);
            this.lblDirectory.TabIndex = 1;
            this.lblDirectory.Text = "Directory:";
            // 
            // txtContents
            // 
            this.txtContents.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.txtContents.Font = new System.Drawing.Font("Courier New", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.txtContents.Location = new System.Drawing.Point(16, 76);
            this.txtContents.Multiline = true;
            this.txtContents.Name = "txtContents";
            this.txtContents.ReadOnly = true;
            this.txtContents.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
            this.txtContents.Size = new System.Drawing.Size(762, 275);
            this.txtContents.TabIndex = 2;
            // 
            // lblContents
            // 
            this.lblContents.AutoSize = true;
            this.lblContents.Location = new System.Drawing.Point(13, 60);
            this.lblContents.Name = "lblContents";
            this.lblContents.Size = new System.Drawing.Size(52, 13);
            this.lblContents.TabIndex = 3;
            this.lblContents.Text = "Contents:";
            // 
            // lvFiles
            // 
            this.lvFiles.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.lvFiles.Location = new System.Drawing.Point(5, 24);
            this.lvFiles.Name = "lvFiles";
            this.lvFiles.Size = new System.Drawing.Size(169, 717);
            this.lvFiles.TabIndex = 4;
            this.lvFiles.UseCompatibleStateImageBehavior = false;
            this.lvFiles.View = System.Windows.Forms.View.List;
            this.lvFiles.ItemSelectionChanged += new System.Windows.Forms.ListViewItemSelectionChangedEventHandler(this.lvFiles_ItemSelectionChanged);
            // 
            // lblFiles
            // 
            this.lblFiles.AutoSize = true;
            this.lblFiles.Location = new System.Drawing.Point(3, 8);
            this.lblFiles.Name = "lblFiles";
            this.lblFiles.Size = new System.Drawing.Size(31, 13);
            this.lblFiles.TabIndex = 5;
            this.lblFiles.Text = "Files:";
            // 
            // formSplitter
            // 
            this.formSplitter.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.formSplitter.Dock = System.Windows.Forms.DockStyle.Fill;
            this.formSplitter.FixedPanel = System.Windows.Forms.FixedPanel.Panel1;
            this.formSplitter.Location = new System.Drawing.Point(0, 0);
            this.formSplitter.Name = "formSplitter";
            // 
            // formSplitter.Panel1
            // 
            this.formSplitter.Panel1.Controls.Add(this.lvFiles);
            this.formSplitter.Panel1.Controls.Add(this.lblFiles);
            // 
            // formSplitter.Panel2
            // 
            this.formSplitter.Panel2.Controls.Add(this.dvFields);
            this.formSplitter.Panel2.Controls.Add(this.txtContents);
            this.formSplitter.Panel2.Controls.Add(this.lblContents);
            this.formSplitter.Panel2.Controls.Add(this.txtDirectory);
            this.formSplitter.Panel2.Controls.Add(this.lblDirectory);
            this.formSplitter.Size = new System.Drawing.Size(986, 754);
            this.formSplitter.SplitterDistance = 190;
            this.formSplitter.SplitterWidth = 5;
            this.formSplitter.TabIndex = 6;
            // 
            // dvFields
            // 
            this.dvFields.AllowUserToAddRows = false;
            this.dvFields.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.dvFields.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.dvFields.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.colOrdinal,
            this.colEvtOrdinal,
            this.colType,
            this.colValue});
            this.dvFields.Location = new System.Drawing.Point(16, 357);
            this.dvFields.Name = "dvFields";
            this.dvFields.ReadOnly = true;
            this.dvFields.RowHeadersVisible = false;
            this.dvFields.Size = new System.Drawing.Size(762, 384);
            this.dvFields.TabIndex = 4;
            // 
            // colOrdinal
            // 
            this.colOrdinal.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
            this.colOrdinal.HeaderText = "Ordinal";
            this.colOrdinal.Name = "colOrdinal";
            this.colOrdinal.ReadOnly = true;
            this.colOrdinal.Width = 65;
            // 
            // colEvtOrdinal
            // 
            this.colEvtOrdinal.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
            this.colEvtOrdinal.HeaderText = "EventId";
            this.colEvtOrdinal.Name = "colEvtOrdinal";
            this.colEvtOrdinal.ReadOnly = true;
            this.colEvtOrdinal.Width = 69;
            // 
            // colType
            // 
            this.colType.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.AllCells;
            this.colType.HeaderText = "Type";
            this.colType.Name = "colType";
            this.colType.ReadOnly = true;
            this.colType.Width = 56;
            // 
            // colValue
            // 
            this.colValue.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.Fill;
            this.colValue.HeaderText = "Value";
            this.colValue.Name = "colValue";
            this.colValue.ReadOnly = true;
            // 
            // EtxTestdataViewer
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(986, 754);
            this.Controls.Add(this.formSplitter);
            this.Name = "EtxTestdataViewer";
            this.Text = "Etx Testdata Viewer";
            this.Load += new System.EventHandler(this.EtxTestDataViewer_Load);
            this.formSplitter.Panel1.ResumeLayout(false);
            this.formSplitter.Panel1.PerformLayout();
            this.formSplitter.Panel2.ResumeLayout(false);
            this.formSplitter.Panel2.PerformLayout();
            this.formSplitter.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.dvFields)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TextBox txtDirectory;
        private System.Windows.Forms.Label lblDirectory;
        private System.Windows.Forms.TextBox txtContents;
        private System.Windows.Forms.Label lblContents;
        private System.Windows.Forms.ListView lvFiles;
        private System.Windows.Forms.Label lblFiles;
        private System.Windows.Forms.SplitContainer formSplitter;
        private System.Windows.Forms.DataGridView dvFields;
        private System.Windows.Forms.DataGridViewTextBoxColumn colOrdinal;
        private System.Windows.Forms.DataGridViewTextBoxColumn colEvtOrdinal;
        private System.Windows.Forms.DataGridViewTextBoxColumn colType;
        private System.Windows.Forms.DataGridViewTextBoxColumn colValue;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\EtxTestdataViewer\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace EtxTestDataViewer.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VortexLogFeeder\Program.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace VortexLogFeeder
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new FeederForm());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VortexLogFeeder\FeederForm.Designer.cs ===
namespace VortexLogFeeder
{
    partial class FeederForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.splitContainer1 = new System.Windows.Forms.SplitContainer();
            this.chkLog = new System.Windows.Forms.CheckBox();
            this.btnStopFeeders = new System.Windows.Forms.Button();
            this.btnFeed = new System.Windows.Forms.Button();
            this.txtFile = new System.Windows.Forms.TextBox();
            this.lblCap = new System.Windows.Forms.Label();
            this.txtUrl = new System.Windows.Forms.TextBox();
            this.txtSecondsCap = new System.Windows.Forms.TextBox();
            this.lblPath = new System.Windows.Forms.Label();
            this.lblSpeed = new System.Windows.Forms.Label();
            this.lblUrl = new System.Windows.Forms.Label();
            this.txtMultiplier = new System.Windows.Forms.TextBox();
            this.txtLog = new System.Windows.Forms.TextBox();
            this.toolTipURL = new System.Windows.Forms.ToolTip(this.components);
            this.splitContainer1.Panel1.SuspendLayout();
            this.splitContainer1.Panel2.SuspendLayout();
            this.splitContainer1.SuspendLayout();
            this.SuspendLayout();
            // 
            // splitContainer1
            // 
            this.splitContainer1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splitContainer1.FixedPanel = System.Windows.Forms.FixedPanel.Panel1;
            this.splitContainer1.IsSplitterFixed = true;
            this.splitContainer1.Location = new System.Drawing.Point(0, 0);
            this.splitContainer1.Name = "splitContainer1";
            this.splitContainer1.Orientation = System.Windows.Forms.Orientation.Horizontal;
            // 
            // splitContainer1.Panel1
            // 
            this.splitContainer1.Panel1.Controls.Add(this.chkLog);
            this.splitContainer1.Panel1.Controls.Add(this.btnStopFeeders);
            this.splitContainer1.Panel1.Controls.Add(this.btnFeed);
            this.splitContainer1.Panel1.Controls.Add(this.txtFile);
            this.splitContainer1.Panel1.Controls.Add(this.lblCap);
            this.splitContainer1.Panel1.Controls.Add(this.txtUrl);
            this.splitContainer1.Panel1.Controls.Add(this.txtSecondsCap);
            this.splitContainer1.Panel1.Controls.Add(this.lblPath);
            this.splitContainer1.Panel1.Controls.Add(this.lblSpeed);
            this.splitContainer1.Panel1.Controls.Add(this.lblUrl);
            this.splitContainer1.Panel1.Controls.Add(this.txtMultiplier);
            this.splitContainer1.Panel1.RightToLeft = System.Windows.Forms.RightToLeft.No;
            // 
            // splitContainer1.Panel2
            // 
            this.splitContainer1.Panel2.Controls.Add(this.txtLog);
            this.splitContainer1.Panel2.RightToLeft = System.Windows.Forms.RightToLeft.No;
            this.splitContainer1.Size = new System.Drawing.Size(542, 373);
            this.splitContainer1.SplitterDistance = 125;
            this.splitContainer1.TabIndex = 12;
            // 
            // chkLog
            // 
            this.chkLog.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.chkLog.AutoSize = true;
            this.chkLog.Location = new System.Drawing.Point(231, 94);
            this.chkLog.Name = "chkLog";
            this.chkLog.Size = new System.Drawing.Size(106, 17);
            this.chkLog.TabIndex = 7;
            this.chkLog.Text = "Verbose Logging";
            this.toolTipURL.SetToolTip(this.chkLog, "Verbose means log the crap out of everything.");
            this.chkLog.UseVisualStyleBackColor = true;
            // 
            // btnStopFeeders
            // 
            this.btnStopFeeders.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.btnStopFeeders.Location = new System.Drawing.Point(449, 90);
            this.btnStopFeeders.Name = "btnStopFeeders";
            this.btnStopFeeders.Size = new System.Drawing.Size(81, 23);
            this.btnStopFeeders.TabIndex = 6;
            this.btnStopFeeders.Text = "Stop Feeding!";
            this.toolTipURL.SetToolTip(this.btnStopFeeders, "Stops all active feeders.");
            this.btnStopFeeders.UseVisualStyleBackColor = true;
            this.btnStopFeeders.Click += new System.EventHandler(this.btnStopFeeders_Click);
            // 
            // btnFeed
            // 
            this.btnFeed.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.btnFeed.Location = new System.Drawing.Point(362, 90);
            this.btnFeed.Name = "btnFeed";
            this.btnFeed.Size = new System.Drawing.Size(81, 23);
            this.btnFeed.TabIndex = 5;
            this.btnFeed.Text = "Feed!";
            this.toolTipURL.SetToolTip(this.btnFeed, "Starts one instance of a feeder with the config on screen. Can be called multiple" +
                    " times.");
            this.btnFeed.UseVisualStyleBackColor = true;
            this.btnFeed.Click += new System.EventHandler(this.btnFeed_Click);
            // 
            // txtFile
            // 
            this.txtFile.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.txtFile.Location = new System.Drawing.Point(99, 12);
            this.txtFile.Name = "txtFile";
            this.txtFile.Size = new System.Drawing.Size(257, 20);
            this.txtFile.TabIndex = 1;
            this.txtFile.Text = "c:\\iissample.txt";
            this.toolTipURL.SetToolTip(this.txtFile, "File path to IIS logs or application log file.");
            // 
            // lblCap
            // 
            this.lblCap.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.lblCap.AutoSize = true;
            this.lblCap.Location = new System.Drawing.Point(362, 19);
            this.lblCap.Name = "lblCap";
            this.lblCap.Size = new System.Drawing.Size(126, 13);
            this.lblCap.TabIndex = 39;
            this.lblCap.Text = "Seconds cap (sleepmax):";
            // 
            // txtUrl
            // 
            this.txtUrl.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.txtUrl.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.FileSystem;
            this.txtUrl.Location = new System.Drawing.Point(99, 50);
            this.txtUrl.Name = "txtUrl";
            this.txtUrl.Size = new System.Drawing.Size(257, 20);
            this.txtUrl.TabIndex = 3;
            this.txtUrl.Text = "http://10.124.172.68:4200";
            this.toolTipURL.SetToolTip(this.txtUrl, "Enter the base url, for example http://xblob:port\r\nThe rest will be appended.");
            // 
            // txtSecondsCap
            // 
            this.txtSecondsCap.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.txtSecondsCap.Location = new System.Drawing.Point(492, 14);
            this.txtSecondsCap.Name = "txtSecondsCap";
            this.txtSecondsCap.Size = new System.Drawing.Size(32, 20);
            this.txtSecondsCap.TabIndex = 2;
            this.txtSecondsCap.Text = "5";
            this.toolTipURL.SetToolTip(this.txtSecondsCap, "Maximum amount to wait between \"realtime\" events. For example if you have a logli" +
                    "ne 30 seconds after the other one, this will cap it to the specified max. ");
            // 
            // lblPath
            // 
            this.lblPath.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.lblPath.AutoSize = true;
            this.lblPath.Location = new System.Drawing.Point(25, 19);
            this.lblPath.Name = "lblPath";
            this.lblPath.Size = new System.Drawing.Size(68, 13);
            this.lblPath.TabIndex = 34;
            this.lblPath.Text = "Source path:";
            // 
            // lblSpeed
            // 
            this.lblSpeed.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.lblSpeed.AutoSize = true;
            this.lblSpeed.Location = new System.Drawing.Point(398, 57);
            this.lblSpeed.Name = "lblSpeed";
            this.lblSpeed.Size = new System.Drawing.Size(90, 13);
            this.lblSpeed.TabIndex = 37;
            this.lblSpeed.Text = "Speed (multiplier):";
            // 
            // lblUrl
            // 
            this.lblUrl.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.lblUrl.AutoSize = true;
            this.lblUrl.Location = new System.Drawing.Point(4, 57);
            this.lblUrl.Name = "lblUrl";
            this.lblUrl.Size = new System.Drawing.Size(92, 13);
            this.lblUrl.TabIndex = 35;
            this.lblUrl.Text = "Base Vortex URL:";
            // 
            // txtMultiplier
            // 
            this.txtMultiplier.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.txtMultiplier.Location = new System.Drawing.Point(491, 52);
            this.txtMultiplier.Name = "txtMultiplier";
            this.txtMultiplier.Size = new System.Drawing.Size(33, 20);
            this.txtMultiplier.TabIndex = 4;
            this.txtMultiplier.Text = "1";
            this.toolTipURL.SetToolTip(this.txtMultiplier, "TURBO BUTTON. Makes things happen faster. 1 is realtime, 0 is instant.");
            // 
            // txtLog
            // 
            this.txtLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.txtLog.Location = new System.Drawing.Point(0, 0);
            this.txtLog.Multiline = true;
            this.txtLog.Name = "txtLog";
            this.txtLog.ReadOnly = true;
            this.txtLog.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.txtLog.Size = new System.Drawing.Size(542, 244);
            this.txtLog.TabIndex = 0;
            // 
            // FeederForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(542, 373);
            this.Controls.Add(this.splitContainer1);
            this.Name = "FeederForm";
            this.Text = "Vortex Log Feeder";
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.Feeder_FormClosed);
            this.splitContainer1.Panel1.ResumeLayout(false);
            this.splitContainer1.Panel1.PerformLayout();
            this.splitContainer1.Panel2.ResumeLayout(false);
            this.splitContainer1.Panel2.PerformLayout();
            this.splitContainer1.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.SplitContainer splitContainer1;
        private System.Windows.Forms.Button btnFeed;
        private System.Windows.Forms.TextBox txtFile;
        private System.Windows.Forms.Label lblCap;
        private System.Windows.Forms.TextBox txtUrl;
        private System.Windows.Forms.TextBox txtSecondsCap;
        private System.Windows.Forms.Label lblPath;
        private System.Windows.Forms.Label lblSpeed;
        private System.Windows.Forms.Label lblUrl;
        private System.Windows.Forms.TextBox txtMultiplier;
        private System.Windows.Forms.TextBox txtLog;
        private System.Windows.Forms.Button btnStopFeeders;
        private System.Windows.Forms.CheckBox chkLog;
        private System.Windows.Forms.ToolTip toolTipURL;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VortexLogFeeder\Feeders.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.IO;

namespace VortexLogFeeder
{
    public delegate void ScreenLog(string x, int level);

    public abstract class BaseFeeder
    {
        #region Static
        static List<Thread> threadTracker = new List<Thread>();
        public static void KillThreads()
        {
            foreach (Thread t in threadTracker)
            {
                try
                {
                    if (t.IsAlive)
                        t.Abort();
                }
                catch (Exception)
                {
                    //The hell with it.
                }
            }
            threadTracker.Clear();
        }
        #endregion Static

        protected ScreenLog log;
        protected int multiplier;
        protected string urlBase;

        public void StartFeeding()
        {
            ThreadStart ts = new ThreadStart(DoFeedingWork);
            Thread t = new Thread(ts);
            threadTracker.Add(t);
            t.Start();
        }

        protected BaseFeeder(string urlBase, int multiplier, ScreenLog log)
        {
            this.multiplier = multiplier;
            this.urlBase = urlBase;
            this.log = log;
        }

        protected virtual void DoFeedingWork()
        {
            throw new NotImplementedException("Virtual method needs implementation, stat!");
        }
    }

    public class LogstringFeeder : BaseFeeder
    {
        List<KeyValuePair<string, int>> logLines;

        public LogstringFeeder(string urlBase, string path, int multiplier, int maxSeconds, ScreenLog log)
            : base(urlBase + "/vortex/logstring.ashx", multiplier, log)
        {
            LoadLStrings(path, maxSeconds);
        }

        public void LoadLStrings(string path, int maxSeconds)
        {
            List<KeyValuePair<string, int>> lsList = new List<KeyValuePair<string, int>>();
            StreamReader r = new StreamReader(File.Open(path, FileMode.Open, FileAccess.Read));
            DateTime lastTime = DateTime.MinValue;
            int secondsInBetween = 0;

            try
            {
                while (r.Peek() != -1)
                {
                    try
                    {
                        string str = r.ReadLine();

                        DateTime currentTime = DateTime.Parse(str.Split('|')[0]);
                        if (lastTime != DateTime.MinValue)
                            secondsInBetween = (int)(currentTime - lastTime).TotalSeconds;

                        Byte[] bytes = BitConverter.GetBytes((ushort)str.Length);
                        str = (char)bytes[0] + str;
                        str = (char)bytes[1] + str;

                        if (str.IndexOf('|') != -1)
                            str = str.Substring(str.IndexOf('|')+1);

                        lsList.Add(new KeyValuePair<string, int>(str, (secondsInBetween > maxSeconds) ? maxSeconds : secondsInBetween));
                        str = r.ReadLine();                        

                        lastTime = currentTime;
                    }
                    catch (Exception) { } //Don't kill it because of 1 line
                }
            }
            finally
            {
                r.Close();
            }

            if (lsList.Count > 0)
                this.log(String.Format("Loaded {0} logstring loglines into a feeder from {1}.", lsList.Count, path), 0);
            this.logLines = lsList;
        }

        protected override void DoFeedingWork()
        {
            int failures = 0;
            if (logLines.Count > 0)
            {
                while (true) //Until we get owned by a thread abort.
                {
                    try
                    {
                        foreach (KeyValuePair<string, int> ll in logLines)
                        {
                            log(String.Format("Sending Request: {0} with content {1}", urlBase, ll.Key), 1);
                            Util.PostRequest(urlBase, "POST", ll.Key, false);
                            if (multiplier > 0)
                                Thread.Sleep((ll.Value * 1000) / multiplier);
                        }
                    }
                    catch (Exception ex)
                    {
                        log(ex.Message, 1);
                        failures++;
                        if (failures > 50)
                        {
                            log("Stopping feeder because it had over 50 exceptions.", 0);
                            return;
                        }
                    }

                }
            }
        }
    }

    public class Logstring2Feeder : BaseFeeder
    {
        List<KeyValuePair<string, int>> queryStrings;

        public Logstring2Feeder(string urlBase, string path, int multiplier, int maxSeconds, ScreenLog log)
            : base(urlBase + "/vortex/logstring2.ashx", multiplier, log)
        {
            LoadQStrings(path, maxSeconds);
        }

        public void LoadQStrings(string path, int maxSeconds)
        {
            string str = File.ReadAllText(path); //Read file
            List<KeyValuePair<string, int>> qsList = new List<KeyValuePair<string, int>>();            
            DateTime lastTime = DateTime.MinValue;            
            Regex regex = new Regex(".*(\\d\\d:\\d\\d:\\d\\d).*logstring2.ashx ([^\\s]*&[^\\s]*|\\w+=\\w*)");
            MatchCollection qsMatches = regex.Matches(str);            

            if (qsMatches.Count > 0)
                lastTime = DateTime.Parse(qsMatches[0].Groups[1].Value);

            foreach (Match m in qsMatches)
            {
                try
                {
                    DateTime currentTime = DateTime.Parse(m.Groups[1].Value);
                    int secondsInBetween = (int)(currentTime - lastTime).TotalSeconds;
                    
                    qsList.Add(new KeyValuePair<string, int>(m.Groups[2].Value, (secondsInBetween > maxSeconds) ? maxSeconds : secondsInBetween));

                    lastTime = currentTime;
                }
                catch (Exception) { } //Don't kill it because of 1 line

            }
            if (qsList.Count > 0)
                this.log(String.Format("Loaded {0} logstring2 querystrings into a feeder from {1}.", qsList.Count, path), 0);
            queryStrings = qsList;
        }

        protected override void DoFeedingWork()
        {
            if (queryStrings.Count > 0)
            {
                int failures = 0;
                while (true) //Until we get owned by a thread abort.
                {
                    try
                    {
                        foreach (KeyValuePair<string, int> qs in queryStrings)
                        {
                            string url = String.Format("{0}?{1}", urlBase, qs.Key);
                            log(String.Format("Sending Request: {0}", url), 1);
                            Util.PostRequest(url, "GET", null, false);
                            if (multiplier > 0)
                                Thread.Sleep((qs.Value * 1000) / multiplier);
                        }
                    }                    
                    catch (Exception ex)
                    {
                        log(ex.Message, 1);
                        failures++;
                        if (failures > 50)
                        {
                            log("Stopping feeder because it had over 50 exceptions.", 0);
                            return;
                        }
                    }
                }
            }
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VortexLogFeeder\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("VortexLogFeeder")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("VortexLogFeeder")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ff3441c6-70e1-469f-a3cb-3a53b50ae75b")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VortexLogFeeder\Util.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Cache;
using System.Text;
using System.IO;

namespace VortexLogFeeder
{
    public class Util
    {
        /// <summary>
        /// Posts an HTTP request to a given endpoint.
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="content"></param>
        /// <param name="fKeepAlive"></param>
        /// <returns></returns>
        public static string PostRequest(string url, string method, string content, bool fKeepAlive)
        {
            HttpWebRequest webreq = (HttpWebRequest)WebRequest.Create(url);

            webreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
            webreq.UserAgent = "VortexDVT/0.1";

            webreq.KeepAlive = fKeepAlive;
            webreq.Method = method;
            webreq.ContentType = "text/xml"; // @@@?
            webreq.ContentLength = content == null ? 0 : content.Length;

            // @@@ Floken header?
            webreq.Headers.Add("X-Floken", "0");

            // Set all headers prior to this!
            if (!String.IsNullOrEmpty(content))
            {
                // This initiates the send, btw
                StreamWriter sw = new StreamWriter(webreq.GetRequestStream(), System.Text.Encoding.ASCII);
                sw.Write(content);
                sw.Close();
            }

            // Finish and get response
            HttpWebResponse webresp = (HttpWebResponse)webreq.GetResponse();

            // Read body
            StreamReader sr = new StreamReader(webresp.GetResponseStream());
            string contentResponse = sr.ReadToEnd();

            webresp.Close();
            sr.Close();

            return contentResponse;
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VortexLogFeeder\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace VortexLogFeeder.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("VortexLogFeeder.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VortexLogFeeder\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace VortexLogFeeder.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxClient\App.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Windows;

namespace VxVisualizer
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxClient\ConfigureStreamInsight.cs ===
using System;
using System.Collections.Generic;
using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Linq;
using Microsoft.ComplexEventProcessing.Diagnostics;
using Microsoft.ComplexEventProcessing.ManagementService;

using xonline.server.vortex;

namespace xonline.server.vortex
{
    public class MeasurementEvent
    {
        public string Name { get; set; }
        public double Value { get; set; }
    }

    public class SkeletonFrameCumulative
    {
        public string Id;
        public uint TotalNumFrames;
        public uint NumFramesWithOneTrackedSkeleton;
        public uint NumFramesWithTwoTrackedSkeletons;
        public uint NumJointsWithConfidenceNone;
        public uint NumJointsWithConfidenceLow;
        public uint NumJointsWithConfidenceHigh;
        public uint NumFramesAnyClippedSides;
        public uint NumFramesAnyClippedTop;
        public uint NumFramesAnyClippedBottom;
        public uint NumFramesAnyTooClose;
        public uint NumFramesAnyTooFar;
        public uint NumFramesWithFloor;
    }

    public class InputStreamConfig
    {
        public string InputStreamName { get; set; }
        public string InputName { get; set; }  // either InputAdapter or Query name
        public double TimeAdvanceFrequencyInSeconds { get; set; }
        public double TimeAdvanceSlackInSeconds { get; set; }
        public string EventShape { get; set; }
        public int MaxEventQueueSize { get; set; }
        public List<string> InputFieldOrders { get; set; }
        public string EventType { get; set; }
    }

    public class OutputStreamConfig
    {
        public string OutputStreamName { get; set; }
        public string OutputAdapterName { get; set; }
        public string StreamEventOrder { get; set; }
        public string EventShape { get; set; }
        public string XomLogArea { get; set; }
        public string XomLogAreaDefaultSettings { get; set; }
        public LogLevel XomLogLevel { get; set; }
        public bool WriteToTrace { get; set; }
        public List<string> OutputFieldOrders { get; set; }
    }

    public enum LogLevel : sbyte
    {
        L_ON = 0, L_LOW = 0,
        L_INFO = 1, L_NORMAL = 1,
        L_WARNING = 2, L_HIGH = 2,
        L_ERROR = 3,
        L_MUTED = 4, L_OFF = 4,
    };
}

namespace VxClient
{
    public class ConfigureStreamInsight
    {
        public static void CreateSpecialTestQuery(Microsoft.ComplexEventProcessing.Application app)
        {

            var atgs = new AdvanceTimeGenerationSettings(
                TimeSpan.FromSeconds(1),
                TimeSpan.FromSeconds(-1),
                true);
            var ats = new AdvanceTimeSettings(atgs, null, AdvanceTimePolicy.Adjust);

            var inputConfig = new InputStreamConfig()
            {
                MaxEventQueueSize = 1000,
                EventType = "SkeletonFrameCumulative"
            };

            var outputConfig = new OutputStreamConfig()
            {
                WriteToTrace = true,
                OutputFieldOrders = new List<string>() 
            {
                "Name", "Value"
            }
            };

            // Create the input stream
            var inStream = CepStream<SkeletonFrameCumulative>.Create("SpecialTestQueryStreamName");

            // Build the query template on top of that stream
            var q1 = from evt in inStream
                     select new MeasurementEvent
                     {
                         Name = evt.Id + "/NumFramesWithOneTrackedSkeleton/Pct",
                         Value = (double)evt.NumFramesWithOneTrackedSkeleton / evt.TotalNumFrames
                     };
            var q2 = from evt in inStream
                     select new MeasurementEvent
                     {
                         Name = evt.Id + "/NumFramesWithTwoTrackedSkeletons/Pct",
                         Value = (double)evt.NumFramesWithTwoTrackedSkeletons / evt.TotalNumFrames
                     };
            var q3 = from evt in inStream
                     select new MeasurementEvent
                     {
                         Name = evt.Id + "/NumJointsWithConfidenceNone/Pct",
                         Value = (double)evt.NumJointsWithConfidenceNone / (20 * evt.NumFramesWithOneTrackedSkeleton + 40 * evt.NumFramesWithTwoTrackedSkeletons)
                     };
            // ughhhh
            var q = q1.Union(q2).Union(q3);

            var queryTemplate = app.CreateQueryTemplate("SpecialTestQuery", "My description", q);
            QueryBinder queryBinder = new QueryBinder(queryTemplate);

            queryBinder.BindProducer(
                "SpecialTestQueryStreamName",
                app.InputAdapters["VxTypedInputAdapter"],
                inputConfig,
                EventShape.Point,
                ats);

            queryBinder.AddConsumer(
                "ArbitraryConsumerStreamName",
                app.OutputAdapters["VxOutputAdapter"],
                outputConfig,
                EventShape.Point,
                StreamEventOrder.ChainOrdered);

            var myQuery = app.CreateQuery("SpecialTestQueryInstance", "My description", queryBinder);

            // Create xmgmt area if necessary, otherwise no affect
            //             string areaName = "Vx" + myQuery.ShortName;
            //             string areaSettings = "target=remote;enable=yes";
            //             xonline.common.mgmt.XomLoggingControl.RegisterNewArea(areaName, areaSettings);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxClient\MainWindow.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Threading;

using xonline.server.vortex;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Linq;
using Microsoft.ComplexEventProcessing.Diagnostics;
using Microsoft.ComplexEventProcessing.ManagementService;

namespace VxClient
{
    /// <summary>
    /// Interaction logic for Window1.xaml
    /// </summary>
    public partial class Window1 : Window
    {
        public Window1()
        {
            InitializeComponent();
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
        }

        void Output(string msg)
        {
            Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Normal,
                (Action)(() =>
                {
                    txtMessages.Text += System.Environment.NewLine + msg;
                }));
        }

        private void Window_Closed(object sender, EventArgs e)
        {
        }

        Microsoft.ComplexEventProcessing.Application _application = null;

        private void ConnectToVortex()
        {
            if (_application != null)
                return;

            Output("Connecting...");
            var endpoint = new System.ServiceModel.EndpointAddress(txtMgmtUrl.Text);
            Server server = Server.Connect(endpoint);
            Output("Connected!");

            if (!server.Applications.TryGetValue("Vortex", out _application))
            {
                Output("No Vortex application found");
                return;
            }
            
            tabItemEvents.DataContext = _application;
            //ccEventDetails.DataContext = 
            //lblArgh.DataContext = listBoxEvents.Items;
        }

        private void btnPopulate_Click(object sender, RoutedEventArgs e)
        {
            ConnectToVortex();

            
            //listBoxEvents.ItemsSource = _application.EventTypes;
            //listBoxQueryTemplates.ItemsSource = _application.QueryTemplates;
            //listBoxQueries.ItemsSource = _application.Queries;
            //ccEventDetails.Content = _application.EventTypes;

            Output("EventTypes:");
            foreach (var kvp in _application.EventTypes)
            {
                //listBoxEvents.Items.Add(kvp.Value);
                //listBoxEvents.DisplayMemberPath = "ShortName";

                Output(kvp.Key + ":");
                Output("\tName: " + kvp.Value.Name.ToString());
                Output("\tShortName: " + kvp.Value.ShortName.ToString());
                Output("\tClrType: " + (kvp.Value.ClrType != null
                    ? kvp.Value.ClrType.ToString()
                    : "<null>"));
                foreach (var fkvp in kvp.Value.Fields)
                {
                    Output("\tField: " + fkvp.Key + ", " + fkvp.Value.Type.Name + ", " + fkvp.Value.Type.ClrType + ", " + fkvp.Value.Ordinal + ", " + fkvp.Value.MaxSize + " bytes");
                }
            }
            Output("");

            Output("QueryTemplates:");
            foreach (var kvp in _application.QueryTemplates)
            {
                Output(kvp.Key + ":");
                Output("\tName: " + kvp.Value.Name.ToString());
                Output("\tShortName: " + kvp.Value.ShortName.ToString());
                Output("\tDescription: " + kvp.Value.Description.ToString());
                foreach (var kvp2 in kvp.Value.QueryTemplateInputs)
                {
                    Output("\tQueryTemplateInput: " + kvp2.Key + ", " + kvp2.Value.EventTypeName + ", " + kvp2.Value.StreamName);
                }
            }
            Output("");

        }


        private void btnGoQueryTemplateConfig_Click(object sender, RoutedEventArgs e)
        {
            ConnectToVortex();
            CreateQueryTemplateConfigTest();
        
        }

        private void CreateQueryTemplateConfigTest()
        {
            const string queryTemplateName = "QueryTemplateConfigTest";
            const string queryTemplateDescription = "Testing query template config stuff";
            const string inputStreamName1 = "SkeletonFrameCumulative";

            QueryTemplate queryTemplate;
            if (_application.QueryTemplates.TryGetValue(queryTemplateName, out queryTemplate))
            {
                Output("Found existing query template: " + queryTemplateName);

                foreach (Query query in _application.Queries.Values)
                {
                    if (query.QueryTemplateName == queryTemplate.Name)
                    {
                        Output("Stopping and deleting query: " + query.ShortName);
                        query.Stop();
                        query.Delete();
                    }
                }
                
                queryTemplate.Delete();
            }

            // Create the input stream
            var inStream = CepStream<SkeletonFrameCumulative>.Create(inputStreamName1);

            // Build the query template on top of that stream
            var q1 = from evt in inStream
                     select new MeasurementEvent
                     {
                         Name = evt.Id + "/NumFramesWithOneTrackedSkeleton/Pct",
                         Value = (double)evt.NumFramesWithOneTrackedSkeleton / evt.TotalNumFrames
                     };
            var q2 = from evt in inStream
                     select new MeasurementEvent
                     {
                         Name = evt.Id + "/NumFramesWithTwoTrackedSkeletons/Pct",
                         Value = (double)evt.NumFramesWithTwoTrackedSkeletons / evt.TotalNumFrames
                     };
            var q3 = from evt in inStream
                     select new MeasurementEvent
                     {
                         Name = evt.Id + "/NumJointsWithConfidenceNone/Pct",
                         Value = (double)evt.NumJointsWithConfidenceNone / (20 * evt.NumFramesWithOneTrackedSkeleton + 40 * evt.NumFramesWithTwoTrackedSkeletons)
                     };
            // ughhhh
            var q = q1.Union(q2).Union(q3);

            queryTemplate = _application.CreateQueryTemplate(queryTemplateName, queryTemplateDescription, q);
        }






        // What does this config class mean?
        // - we can bind input to either the CAKE input adapter or other queries.
        // - we can bind output to the CAKE output adapter or a named stream.
        // - we support point events only
        // - we cannot bind input to an arbitrary input adapter.
        // - we cannot bind output to an arbitrary output adapter.
        // - we do not support interval or edge events. though, this depends on input,
        //   so maybe CAKE can help with this.
        //

        class QueryConfig
        {
            public string QueryName;
            public string QueryDescription;
            public int    Version;
            public string QueryTemplateShortName;

            // One per query template input stream
            public InputBindingConfig[] InputBindings;

            // Only one output
            public OutputBindingConfig OutputBinding;
        }

        class InputBindingConfig
        {
            // Required
            public string BindToQueryTemplateStreamName;

            // Optional-ish. If null, assumes CAKE input adapter. If not null, binds to
            // an existing query's output. If can't find that, tries a published stream 
            // name (?).
            public string InputQueryName { get; set; }

            // Optional. Good defaults provided otherwise.
            public double? TimeAdvanceFrequencyInSeconds { get; set; }
            public double? TimeAdvanceSlackInSeconds { get; set; }
            public string EventShape { get; set; }
        }

        class OutputBindingConfig
        {
            // Optional. If null, constructs a meaningful default name and sends output
            // to CAKE output adapter. If not null, publishes to a name but doesn't
            // hook up to an output adapter. The published name will look like:
            //     cep:/Server/Application/MyApp/PublishedStream/<OutputQueryName>
            public string OutputPublishedStreamName { get; set; }

            // Optional. Good defaults provided otherwise.
            public double? TimeAdvanceFrequencyInSeconds { get; set; }
            public double? TimeAdvanceSlackInSeconds { get; set; }
            public string EventShape { get; set; }
        }

        private void btnGoQueryConfig_Click(object sender, RoutedEventArgs e)
        {
            ConnectToVortex();

            //
            // Minimal config object
            //

            var configInfo = new QueryConfig
            {
                QueryName = "ShortTest",
                QueryDescription = "Test of minimal configuration",
                Version = 0,
                QueryTemplateShortName = "QueryTemplateConfigTest",
                InputBindings = new InputBindingConfig[] {
                    new InputBindingConfig {
                        BindToQueryTemplateStreamName = "SkeletonFrameCumulative",
                    }
                },
                OutputBinding = new OutputBindingConfig {
                },
            };


            // Do it!
            InstantiateQuery(_application, configInfo);
        }

        private Query InstantiateQuery(Microsoft.ComplexEventProcessing.Application app, QueryConfig configInfo)
        {
            // Query housekeeping
            Query queryOld;
            if (_application.Queries.TryGetValue(configInfo.QueryName, out queryOld))
            {
                // enforce version, somehow
                // Extract version. Appended on the end like "... @@version ##".
                int idx = -1;
                int version = -1;
                const string token = "@@version ";
                idx = queryOld.Description.IndexOf(token, StringComparison.OrdinalIgnoreCase);
                if (idx > -1)
                {
                    // Take remaining string
                    string versionString = queryOld.Description.Substring(idx + token.Length);
                    int.TryParse(versionString, out version);
                }

                if (version != configInfo.Version)
                {
                    queryOld.Stop();
                    queryOld.Delete();
                }
            }

            QueryTemplate queryTemplate = _application.QueryTemplates[configInfo.QueryTemplateShortName];
            QueryBinder queryBinder = new QueryBinder(queryTemplate);

            foreach (var ib in configInfo.InputBindings)
            {
                // Provide good defaults for time generation
                var atgs = new AdvanceTimeGenerationSettings(
                    TimeSpan.FromSeconds(ib.TimeAdvanceFrequencyInSeconds ?? 1),
                    TimeSpan.FromSeconds(ib.TimeAdvanceSlackInSeconds ?? 0),
                    true);
                var ats = new AdvanceTimeSettings(atgs, null, AdvanceTimePolicy.Adjust);

                if (ib.InputQueryName == null)
                {
                    // Hard-coded to CAKE input adapter
                    // @@@ Does CAKE input adapter need config? yes. remove later.

                    var adapterConfig = new InputStreamConfig()
                    {
                        MaxEventQueueSize = 1000,
                        TimeAdvanceFrequencyInSeconds = 1,
                        TimeAdvanceSlackInSeconds = 0
                    };

                    InputAdapter inputAdapter = _application.InputAdapters["VxInputAdapter"];
                    try
                    {
                        queryBinder.BindProducer(
                            ib.BindToQueryTemplateStreamName,
                            inputAdapter,
                            adapterConfig,
                            EventShape.Point,
                            ats);
                    }
                    catch (InvalidOperationException e)
                    {
                        if (e.Message.Contains("doesn't have an input stream"))
                        {
                            string inputs = "";
                            queryTemplate.QueryTemplateInputs.Values.ToList().ForEach(i => inputs += i.StreamName.ToString() + " ");
                            string message = String.Format(
                                "Error binding input stream {0} of query {1} to query template {2}. Available input streams: {3}.",
                                ib.BindToQueryTemplateStreamName,
                                configInfo.QueryName,
                                configInfo.QueryTemplateShortName,
                                inputs);
                            throw new InvalidOperationException(message, e);
                        }
                        else
                        {
                            throw;
                        }                        
                    }
                }
                else
                {
                    // Hook up to the output of another query
                    Query inputQuery;
                    inputQuery = _application.Queries[ib.InputQueryName];

                    queryBinder.BindProducer(
                        ib.BindToQueryTemplateStreamName,
                        inputQuery,
                        ats);
                }
            }
            if (configInfo.OutputBinding.OutputPublishedStreamName == null)
            {
                // Hard-coded to CAKE output adapter
                // @@@ Does CAKE output adapter need config? yes. remove later.

                var adapterConfig = new OutputStreamConfig()
                {
                    WriteToTrace = true,
                    XomLogLevel = LogLevel.L_ON
                };

                OutputAdapter outputAdapter = _application.OutputAdapters["VxOutputAdapter"];
                queryBinder.AddConsumer(
                    configInfo.QueryName + "Consumer",
                    outputAdapter,
                    adapterConfig,
                    EventShape.Point,
                    StreamEventOrder.ChainOrdered);
           
            }
            else
            {
                // Publish to a stream name
                // @@@ which override to use??
                queryBinder.BindOutputToPublishedStream(
                    EventShape.Point,
                    StreamEventOrder.ChainOrdered);
            }

            string descWithVersion = String.Format("{0} @@version {1}", configInfo.QueryDescription, configInfo.Version);
            Query query = _application.CreateQuery(
                configInfo.QueryName,
                descWithVersion,
                queryBinder);

            // Start it?
            query.Start();
            
            return query;
        }




    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxClient\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace VxVisualizer.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxClient\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace VxVisualizer.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("VxVisualizer.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxConfig\NamedArgParser.cs ===
using System;
using System.IO;
using System.Collections;
using System.Globalization;
using System.Collections.Specialized;
using System.Diagnostics;

// TODO: move to \private\common\core\utilities\

namespace xonline.server.vortex.vxconfig
{


/// <remarks>
///     Generic class for parsing out command line arguments, in the
///     form of:
///
///     <example>
///         myprogram.exe /a:argument1 /b arg2 /novaluearg
///     </example>
///
///     Parsing takes place by calling the Parse() function.   the resulting
///     tag/value pairs can be access via the [] accessor (or Item() property).
/// </remarks>
public class NamedArgParser : StringDictionary
{
    private static char[] _defaultDelims = { '/', '-' };

    private bool _ignoreCase = true;
    private string _invalidArgText = "";

    private char[] _delims;
    private string[] _tags;



    /// <summary>
    ///     default constructor.  initalizes with default delimeters ('/' or '-')
    ///     and no specific tags.
    /// </summary>
    public NamedArgParser()             : this(null, _defaultDelims) { }
    /// <summary>
    ///     Initalize, limiting valid arguments to the given list of <paramref name='tags'>tags</paramref>.
    ///     initalizes with default delimeters ('/' or '-').
    ///     <param name='tags'>
    ///         tags to be used
    ///     </param>
    /// </summary>
    public NamedArgParser(string[] tags)    : this(tags, _defaultDelims) { }
    /// <summary>
    ///     Initalize, limiting valid arguments to the given list of <paramref name='tags'>tags</paramref>,
    ///     and using the given <paramref name='delimeters'>delimeters</paramref> for denoting tags.
    ///     <param name='tags'>
    ///         tags to be used
    ///     </param>
    ///     <param name='delimeters'>
    ///         argument delimeters to look for
    ///     </param>
    /// </summary>
    public NamedArgParser(string[] tags, char[] delimeters)
    {
        _tags = tags;
        _delims = delimeters;

#if DEBUG
        // tags cannot contain delimeters or ':' or '@'
        if (_tags != null) {
            for (int n=0; n < _tags.Length; n++) {
                Debug.Assert(_tags[n].IndexOf(":") == -1);
                Debug.Assert(_tags[n].IndexOf("@") == -1);
                for (int j=0; j < _delims.Length; j++) {
                    Debug.Assert(_tags[n].IndexOf(_delims[j]) == -1);
                }
            }
        }
#endif

    }

    /// <summary>
    ///     list of valid delimiter characters.  defaults to '/' and '-'
    /// </summary>
    public char[] Delimiters
    {
        set { _delims = value; }
        get { return _delims; }
    }

    /// <summary>
    ///     list of valid tags.  if not specified, all tags are allowed.
    ///     if it is specified, Parse() will fail if it encouters tags that
    ///     aren't listed in this array.
    /// </summary>
    public string[] Tags
    {
        set { _tags = value; }
        get { return _tags; }
    }

    /// <summary>
    ///     set to false if tags should be verified in a case-sensitive
    ///     way.  Defaults to true.
    /// </summary>
    public bool IgnoreCase
    {
        set { _ignoreCase = value; }
        get { return _ignoreCase; }
    }

    /// <summary>
    ///     returns an argument as an uint, or 0 if it can't be parsed.
    /// </summary>
    public uint ParseHexUInt(string tag) { bool b; return ParseHexUInt(tag, out b); }
    public uint ParseHexUInt(string tag, out bool success)
    {
        return (uint)ParseInt(tag, NumberStyles.HexNumber, out success);
    }



    /// <summary>
    ///     returns an argument as an uint, or 0 if it can't be parsed.
    /// </summary>
    public uint ParseUInt(string tag) { bool b; return ParseUInt(tag, out b); }
    public uint ParseUInt(string tag, out bool b) { return ParseUInt(tag, NumberStyles.Integer, out b); }
    public uint ParseUInt(string tag, NumberStyles defaultStyle, out bool success)
    {
        NumberStyles style = defaultStyle;
        string valstr;
        uint val = 0;

        success = true;

        try
        {
            valstr = this[tag];
            if (valstr == "" || valstr == null)
            {
                success = false;
                return val;
            }

            // check for hex indicator
            if (valstr.StartsWith("0x"))
            {
                style = NumberStyles.HexNumber;
                valstr = valstr.Substring(2);
            }

            val = UInt32.Parse(valstr, style);
        }
        catch (Exception)
        {
            success = false;
        }

        return val;
    }

    /// <summary>
    ///     returns an argument as an int, or 0 if it can't be parsed.
    /// </summary>
    public int ParseInt(string tag) { bool b; return ParseInt(tag, out b); }
    public int ParseInt(string tag, out bool b) { return ParseInt(tag, NumberStyles.Integer, out b); }
    public int ParseInt(string tag, NumberStyles defaultStyle, out bool success)
    {
        NumberStyles style = defaultStyle;
        string valstr;
        int val = 0;

        success = true;

        try
        {
            valstr = this[tag];
            if (valstr == "" || valstr == null)
            {
                success = false;
                return val;
            }

            // check for hex indicator
            if (valstr.StartsWith("0x"))
            {
                style = NumberStyles.HexNumber;
                valstr = valstr.Substring(2);
            }

            val = Int32.Parse(valstr, style);
        }
        catch (Exception)
        {
            success = false;
        }


        return val;
    }

    /// <summary>
    ///     returns an argument as an uLong, or 0 if it can't be parsed.
    /// </summary>
    public ulong ParseULong(string tag) { bool b; return ParseULong(tag, out b); }
    public ulong ParseULong(string tag, out bool success)
    {
        return (ulong)ParseLong(tag, out success);
    }

    /// <summary>
    ///     returns an argument as an uLong, or 0 if it can't be parsed.
    /// </summary>
    public ulong ParseHexULong(string tag) { bool b; return ParseULong(tag, out b); }
    public ulong ParseHexULong(string tag, out bool success)
    {
        return (ulong)ParseLong(tag, NumberStyles.HexNumber, out success);
    }

    /// <summary>
    ///     returns an argument as an Long, or 0 if it can't be parsed.
    /// </summary>
    public long ParseLong(string tag) { bool b; return ParseLong(tag, out b); }
    public long ParseLong(string tag, out bool success)  { return ParseLong(tag, NumberStyles.Integer, out success); }
    public long ParseLong(string tag, NumberStyles defaultStyle, out bool success)
    {
        NumberStyles style = defaultStyle;
        string valstr;
        long val = 0;

        success = true;

        try
        {
            valstr = this[tag];
            if (valstr == "" || valstr == null)
            {
                success = false;
                return val;
            }

            // check for hex indicator
            if (valstr.StartsWith("0x"))
            {
                style = NumberStyles.HexNumber;
                valstr = valstr.Substring(2);
            }

            val = Int64.Parse(valstr, style);
        }
        catch (Exception)
        {
            success = false;
        }


        return val;
    }


    /// <summary>
    ///     If a call to Parse() returns false, contains the
    ///     text of the argument that cased the failure.
    /// </summary>
    public string InvalidArgText
    {
        get { return _invalidArgText; }
    }

    /// <summary>
    ///     parses the list of arguments and populates the Args[] mapping.
    ///
    ///     <param name='args'>
    ///         the list of arguments, typically the arg list passed into Main()
    ///     </param>
    /// </summary>
    public bool Parse(string[] args)
    {
        int n;
        string arg;
        string tag;
        string value;
        int valueIndex;

        bool success = true;

        // The calling function is trying to parse args
        // but an empty string array have been passed.
        if( args.Length == 0 ){
            _invalidArgText = "Trying to parse an empty arg string.";
            success = false;
        }

        for (n = 0; n < args.Length; n++) {

            arg = args[n];

            if (arg[0] == '@')
            {
                // it's a response file.
                success = ParseResponseFile(arg.Substring(1));
                if (!success) break;

                continue;
            }


            // get the tag
            tag = GetTag(arg);
            if (tag == "") {
                // no tag found, bad args
                _invalidArgText = arg;
                success = false;
                break;
            }

            // get the value associated with the tag (if any)
            value = "";
            valueIndex = arg.IndexOf(':');
            if (valueIndex > 0) {

                // the arg contains the value
                value = arg.Substring(valueIndex + 1);
            }

            // add the tag/value pair to the dictionary
            if (_ignoreCase == true) {
                tag = tag.ToLower();
            }

            base.Add(tag, value);

        }

        return success;
    }

    /// <summary>
    ///     Gets the tag name from the given <paramref name='arg'>argument</paramref> string.
    ///
    ///     <param name='arg'>the argument to parse</param>
    /// </summary>
    private string GetTag(string arg)
    {
        int n;
        string tag;

        for (n = 0; n < _delims.Length; n++) {
            if (arg[0] == _delims[n]) break;
        }

        if (n == _delims.Length) {
            // delimeter not found, must not be a tag
            return "";
        }

        // remove the delimeter
        arg = arg.Substring(1);

        n = arg.IndexOf(':');
        if (n > 0) {
            tag = arg.Substring(0, n);
        }
        else {
            tag = arg;
        }

        // if a set of tags have been specified, verify the list
        // against this potential tag.
        if (_tags != null) {
            for (n = 0; n < _tags.Length; n++) {
                if ((_ignoreCase == true && _tags[n].ToLower() == tag.ToLower()) ||
                    (_ignoreCase == false && _tags[n] == tag))  break;
            }

            if (n == _tags.Length) {
                // tag not found
                return "";
            }
        }

        return tag;

    }

    /// <summary>
    ///     Parses a file containing additional arguments.
    /// </summary>
    private bool ParseResponseFile(string filename)
    {
        StreamReader reader;
        StringCollection argList = new StringCollection();
        string[] args;
        string arg;

        try
        {
            reader = File.OpenText(filename);
            arg = reader.ReadLine();

            while (arg != null)
            {
                arg = arg.Trim();
                if (arg != "")
                    argList.Add(arg.Trim());

                arg = reader.ReadLine();
            }

            reader.Close();

            args = new string[argList.Count];
            argList.CopyTo(args, 0);

            return Parse(args);
        }
        catch(Exception e)
        {
            _invalidArgText = e.Message;
            return false;
        }
    }


}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxConfig\Program.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

//using xonline.common.tools.console;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Linq;

namespace xonline.server.vortex.vxconfig
{
    class VxConfig
    {
        static void Main(string[] rawargs)
        {
            NamedArgParser args = new NamedArgParser(c_ArgNames);
            if (!args.Parse(rawargs))
            {
                Console.WriteLine("Invalid arguments.");
                PrintHelp();
            }

            string argMgmtUri = args["mgmt"];
            string argApplication = args["app"] ?? "Vortex";
            string queryTemplateName = args["qt"];

            if (args.ContainsKey("?") ||
                args.ContainsKey("h") ||
                args.ContainsKey("help"))
            {
                PrintHelp();
            }

            if (String.IsNullOrEmpty(argMgmtUri))
            {
                // connect to localhost, but by ip
                Console.WriteLine("The -mgmt parameter is required");
                PrintHelp();
            }

            int n = args.ContainsKey("list") ? 1 : 0;
            n += args.ContainsKey("create") ? 1 : 0;
            n += args.ContainsKey("update") ? 1 : 0;
            n += args.ContainsKey("delete") ? 1 : 0;
            if (n != 1)
            {
                Console.WriteLine("Exactly one of -list, -create, -update, or -delete are required");
                PrintHelp();
            }

            using (QueryTemplateMonster qtConfigurator = new QueryTemplateMonster())
            {
                qtConfigurator.DiagnosticOutput += new OutputFunc(ConsoleWriteLine);
                qtConfigurator.ConnectToStreamInsight(argMgmtUri, argApplication);

                if (args.ContainsKey("list"))
                {
                    qtConfigurator.List(queryTemplateName);
                }
                else if (args.ContainsKey("create"))
                {
                    qtConfigurator.Create(queryTemplateName);
                    qtConfigurator.List(queryTemplateName);
                }
                else if (args.ContainsKey("update"))
                {
                    qtConfigurator.Update(queryTemplateName);
                    qtConfigurator.List(queryTemplateName);
                }
                else if (args.ContainsKey("delete"))
                {
                    qtConfigurator.Delete(queryTemplateName);
                    qtConfigurator.List(queryTemplateName);
                }
            }
        }

        static void ConsoleWriteLine(string fmt, params object[] args)
        {
            Console.WriteLine(fmt, args);
        }

        static string[] c_ArgNames = new string[] {
            "mgmt",
            "app",
            "list",
            "create",
            "update",
            "delete",
            "qt"
        };

        static void PrintHelp()
        {
            string helpText = @"
VxConfig configures the StreamInsight query templates in Vortex.

Common parameters:
VxConfig.exe [-mgmt:url] [-app:app] actions...

Actions:
VxConfig.exe -list [-qt:queryTemplate]
VxConfig.exe -create [-qt:queryTemplate]
VxConfig.exe -update [-qt:queryTemplate]
VxConfig.exe -delete [-qt:queryTemplate]

  -mgmt : Uri to the StreamInsight management service. Default is the local 
          Vortex service. Typically an IP address is required, not a hostname.
          Example: http://10.124.133.57:10240/StreamInsight/Default

  -app : Name of the StreamInsight application to connect to. Default is 
         Vortex.

  -list : List currently configured query templates. Optionally, with -qt, list 
          details for a single query template.

  -create : Enumerate all query templates in this assembly and create them in 
            the remote StreamInsight service. Will not change or delete 
            existing query templates. Optionally, with -qt, create only a 
            single query template from the assembly.

  -update : Enumerate all query templates in this assembly and create them in 
            the remote StreamInsight service. This will delete any existing 
            query template(s) as well as all queries using them. Optionally, 
            with -qt, create only a single query template from the assembly.
            THIS SHOULD ONLY BE USED WITH GREAT CAUTION.

  -delete : Delete all query templates in the remote StreamInsight service. 
            This will also stop and delete any instantiated queries using the
            query template. Optionally, with -qt, delete only a single query
            template.
            THIS SHOULD ONLY BE USED WITH GREAT CAUTION.

Examples:

  VxConfig -list -mgmt:http://10.124.133.57:10240/StreamInsight/Default -app:Vortex
  VxConfig -create -mgmt:http://10.124.133.57:10240/StreamInsight/Default
  VxConfig -create -qt:Passthrough -mgmt:http://10.124.133.57:10240/StreamInsight/Default
  VxConfig -update -mgmt:http://10.124.133.57:10240/StreamInsight/Default

";
            Console.WriteLine(helpText);
            System.Environment.Exit(-1);
        }
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxConfig\QT_EventCount.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Linq;

#pragma warning disable 169  // The field '...' is never used
#pragma warning disable 649  // Field '...' is never assigned to

namespace xonline.server.vortex.vxconfig
{
    class EventCountEvent
    {
        public string Id;
    }

    class EventCountAggregate
    {
        public int TimeSpanInSeconds;
        public long Count;
        public string EventId;
    }

    class QT_EventCount : BaseQueryTemplateConfigurator
    {
        override public string QueryTemplateName
        {
            get { return "EventCount"; }
        }

        override public string Description
        {
            get { return "Provides counts of unique events over a tumbling time window"; }
        }

        override public void CreateQueryTemplate(Application streamInsightApp)
        {
            var masterEventStream = CepStream<EventCountEvent>.Create("EventCountEvent");

            TimeSpan windowSpan = TimeSpan.FromSeconds(60);
            var linq = 
                from e in masterEventStream
                group e by new { EventId = e.Id } into grouping
                from window in grouping.TumblingWindow(windowSpan, WindowOutputPolicy.ClipToWindowEnd)
                select new EventCountAggregate
                {
                    TimeSpanInSeconds = (int)windowSpan.TotalSeconds,
                    Count = window.Count(),
                    EventId = grouping.Key.EventId,
                };

            var qt = streamInsightApp.CreateQueryTemplate(QueryTemplateName, Description, linq);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxVisualizer\App.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Windows;

namespace VxVisualizer
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxConfig\QT_LSMeasurement.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Linq;

#pragma warning disable 169  // The field '...' is never used
#pragma warning disable 649  // Field '...' is never assigned to

namespace xonline.server.vortex.vxconfig
{
    class LSMeasurementEvent
    {
        public string Id;
        public int Value;
        public int Threshold;
        //public string Payload;
    }

    class LSMeasurementOutputEvent
    {
        public string Id;
        public int Value;
        //public string Payload;
    }

    class QT_LSMeasurement : BaseQueryTemplateConfigurator
    {
        override public string QueryTemplateName
        {
            get { return "LSMeasurement"; }
        }

        override public string Description
        {
            get { return "Mimics the \"measurement\" log type in StringSvr. Increments a perf counter when a per-event-type threshold is exceeded."; }
        }

        override public void CreateQueryTemplate(Application streamInsightApp)
        {
            var masterEventStream = CepStream<LSMeasurementEvent>.Create("LSMeasurementEvent");

            var linq = 
                from e in masterEventStream
                where UserFuncs.IncrementLSMeasurementPerfCtr(e.Id, e.Value, e.Threshold)
                select e;

            var qt = streamInsightApp.CreateQueryTemplate(QueryTemplateName, Description, linq);
        }

    }

    public static class UserFuncs
    {
        public static bool IncrementLSMeasurementPerfCtr(string eventId, int value, int threshold)
        {
            if (value > threshold)
            {
                // increment perf counter
                int a = value + threshold;
            }
            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxDataServiceLib\Histogram.cs ===
using System;
using System.Collections.Generic;
using System.Linq;

using System.Windows.Forms.DataVisualization.Charting;

namespace xonline.server.vortex.dataservice
{

public class HistogramList<T>
{
    public int Count;
    public T BucketMin;
    public T BucketMax;
};

public static class HistogramExtensions
{
    //
    // Extension methods
    //

    public static void ShowHistogramChart(
        this IEnumerable<HistogramList<decimal>> source
        )
    {
        VxChart vxchart = new VxChart(VxChartType.Column, "Histogram", "Bucket Ranges", "Counts")
        {
            XAxisMinimum = (double)source.First().BucketMin,
            XAxisMaximum = (double)source.Last().BucketMax,
        };

        source.ShowChart(vxchart, e => e.BucketMin, e => e.Count);
    }


    // Handles decimal inputs. Good enough for now, but if you want other types you'll 
    // have to add more extension methods here.

    public static List<HistogramList<decimal>> Histogram<TSource>(
        this IEnumerable<TSource> source,
        Func<TSource, decimal> selector,
        int numBuckets
        )
    {
        return Histogram(source, selector, numBuckets, source.Min(selector), source.Max(selector));
    }


    public static List<HistogramList<decimal>> Histogram<TSource>(
        this IEnumerable<TSource> source,
        Func<TSource, decimal> selector,
        int numBuckets,
        decimal minBucketValue,
        decimal maxBucketValue
        )
    {
        var values = source.Select(selector);		
        var bucketRange = (maxBucketValue - minBucketValue) / numBuckets;
        var histoList = new List<HistogramList<decimal>>(numBuckets);

        var minValue = minBucketValue;
        var maxValue = minValue + bucketRange;
        // First bucket has no min
        histoList.Add(new HistogramList<decimal>() {
                      Count = values.Count(v => v < maxValue),
                      BucketMin = Math.Min(values.Min(), minBucketValue),
                      BucketMax = maxValue
                      });

        for (int i = 1; i < numBuckets - 1; i++)
        {
            minValue = maxValue;
            maxValue = minValue + bucketRange;
            histoList.Add(new HistogramList<decimal>() {
                          Count = values.Count(v => v >= minValue && v < maxValue),
                          BucketMin = minValue,
                          BucketMax = maxValue
                          });
        }
        // Last bucket has no max
        histoList.Add(new HistogramList<decimal>() {
                      Count = values.Count(v => v >= maxValue),
                      BucketMin =  maxValue,
                      BucketMax = Math.Max(values.Max(), maxBucketValue)
                      });


        return histoList;
    }


}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxConfig\QT_Passthrough.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Linq;

#pragma warning disable 169  // The field '...' is never used
#pragma warning disable 649  // Field '...' is never assigned to

namespace xonline.server.vortex.vxconfig
{
    class PassthroughEvent
    {
        public string Id;
        public string PayloadWithId;
    }

    class QT_PassThrough : BaseQueryTemplateConfigurator
    {
        // This should be a unique, descriptive name
        override public string QueryTemplateName 
        { 
            get { return "Passthrough"; }
        }

        override public string Description
        {
            get { return "Simple event passthrough"; }
        }

        override public void CreateQueryTemplate(Application streamInsightApp)
        {
            var masterEventStream = CepStream<PassthroughEvent>.Create("PassthroughEvent");

            var linq = from e in masterEventStream
                       select e;

            var qt = streamInsightApp.CreateQueryTemplate(QueryTemplateName, Description, linq);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxVisualizer\Properties\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace VxVisualizer.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("VxVisualizer.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxVisualizer\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace VxVisualizer.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxDataServiceLib\ChartMs.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Forms;
using System.IO;
using System.Reflection;

using System.Windows.Forms.DataVisualization.Charting;

namespace xonline.server.vortex.dataservice
{

// Same as SeriesChartType. Will have to revisit for Visifire integration. Maybe trim.
public enum VxChartType
{
    Point = 0,
    FastPoint = 1,
    Bubble = 2,
    Line = 3,
    Spline = 4,
    StepLine = 5,
    FastLine = 6,
    Bar = 7,
    StackedBar = 8,
    StackedBar100 = 9,
    Column = 10,
    StackedColumn = 11,
    StackedColumn100 = 12,
    Area = 13,
    SplineArea = 14,
    StackedArea = 15,
    StackedArea100 = 16,
    Pie = 17,
    Doughnut = 18,
    Stock = 19,
    Candlestick = 20,
    Range = 21,
    SplineRange = 22,
    RangeBar = 23,
    RangeColumn = 24,
    Radar = 25,
    Polar = 26,
    ErrorBar = 27,
    BoxPlot = 28,
    Renko = 29,
    ThreeLineBreak = 30,
    Kagi = 31,
    PointAndFigure = 32,
    Funnel = 33,
    Pyramid = 34,
};

public class VxChart
{
    // Include external assemblies in ours, to allow for a single-file distribution
    //   System.Windows.Forms.DataVisualization.dll
    #region Assembly Packing Glue

    static VxChart()
    {
        AppDomain.CurrentDomain.AssemblyResolve += FindAssem;
    }

    static Dictionary <string, Assembly> libs = new Dictionary<string, Assembly>();
    
    // To include a file as an embedded resource, see
    // http://support.microsoft.com/kb/319292.
    // Basically, just put this line in an ItemGroup node in your .csproj file:
    //   <EmbeddedResource Include="lib\System.Windows.Forms.DataVisualization.dll" />

    static Assembly FindAssem(object sender, ResolveEventArgs args)
    {
        string shortName = new AssemblyName(args.Name).Name;
        if (libs.ContainsKey(shortName)) return libs[shortName];

        using (Stream s = Assembly.GetExecutingAssembly().
               GetManifestResourceStream("lib." + shortName + ".dll"))
        {
            byte[] data = new BinaryReader(s).ReadBytes((int)s.Length);
            Assembly a = Assembly.Load(data);
            libs[shortName] = a;
            return a;
        }
    }

    #endregion

    public string Title = null;
    public VxChartType ChartType = VxChartType.Line;
    public string YAxisLabel = null;
    public string XAxisLabel = null;

    public bool ShowLegend = false;
    public bool IsValueShownAsLabel = false;
    public bool XAxisMajorGridEnabled = true;
    public bool YAxisMajorGridEnabled = true;

    public double? XAxisMinimum = null;
    public double? XAxisMaximum = null;
    public double? YAxisMinimum = null;
    public double? YAxisMaximum = null;

    public IEnumerable XValues = null;
    public IEnumerable YValues = null;

    public VxChart()
        : this(VxChartType.Line, null, null, null)
    {
    }

    public VxChart(VxChartType chartType)
        : this(chartType, null, null, null)
    {
    }

    public VxChart(VxChartType chartType, string title, string xAxisLabel, string yAxisLabel)
    {
        ChartType = chartType;
        Title = title;
        XAxisLabel = xAxisLabel;
        YAxisLabel = yAxisLabel;

        switch (ChartType)
        {
            case VxChartType.Line:
                YAxisMajorGridEnabled = true;
                break;
            case VxChartType.Column:
                YAxisMajorGridEnabled = false;
                break;
            case VxChartType.Point:
                YAxisMajorGridEnabled = false;
                XAxisMajorGridEnabled = false;
                IsValueShownAsLabel = false;
                break;
        }
    }

    public Chart MakeChart()
    {
        // Init chart
        var chart = new Chart();

        // Appearance
        chart.AntiAliasing = AntiAliasingStyles.All;
        chart.TextAntiAliasingQuality = TextAntiAliasingQuality.High;
        chart.BorderSkin.SkinStyle = BorderSkinStyle.FrameThin6;

        chart.ChartAreas.Add("mainChartArea");
        chart.Series.Add("mainSeries");
        if (ShowLegend)
            chart.Legends.Add("mainLegend");
        if (Title != null)
            chart.Titles.Add(Title);

        chart.Series[0].ChartType = GetChartType(ChartType);
        chart.Series[0].IsValueShownAsLabel = IsValueShownAsLabel;
        chart.Series[0].BorderWidth = 3;

        if (XAxisLabel != null)
            chart.ChartAreas[0].AxisX.Title = XAxisLabel;
        if (YAxisLabel != null)
            chart.ChartAreas[0].AxisY.Title = YAxisLabel;

        // From the samples

        // Enable range selection and zooming end user interface
        chart.ChartAreas[0].CursorX.IsUserEnabled = true;
        chart.ChartAreas[0].CursorX.IsUserSelectionEnabled = true;
        chart.ChartAreas[0].CursorY.IsUserEnabled = true;
        chart.ChartAreas[0].CursorY.IsUserSelectionEnabled = true;
        chart.ChartAreas[0].AxisX.ScaleView.Zoomable = true;
        chart.ChartAreas[0].AxisX.ScrollBar.IsPositionedInside = true;
        chart.ChartAreas[0].AxisY.ScaleView.Zoomable = true;
        chart.ChartAreas[0].AxisY.ScrollBar.IsPositionedInside = true;

        // Make it pretty
        chart.BackColor = System.Drawing.Color.FromArgb(240, 255, 255);
        chart.BackGradientStyle = GradientStyle.TopBottom;
        chart.BackSecondaryColor = System.Drawing.Color.White;
        chart.BorderlineColor = System.Drawing.Color.FromArgb(32, 64, 128);
        chart.BorderlineDashStyle = ChartDashStyle.Solid;
        chart.BorderlineWidth = 1;
        chart.BorderSkin.SkinStyle = BorderSkinStyle.Emboss;
        //chart.Legends[0].BackColor = System.Drawing.Color.Transparent;
        chart.ChartAreas[0].BackColor = System.Drawing.Color.FromArgb(210, 210, 210);
        chart.ChartAreas[0].BackGradientStyle = GradientStyle.TopBottom;
        chart.ChartAreas[0].BackSecondaryColor = System.Drawing.Color.White;
        chart.ChartAreas[0].BorderColor = System.Drawing.Color.FromArgb(128, 128, 128, 128);
        chart.ChartAreas[0].BorderDashStyle = ChartDashStyle.Solid;
        chart.ChartAreas[0].ShadowColor = System.Drawing.Color.Transparent;

        // Tooltips
        chart.Series[0].ToolTip = "#VAL";

        //chart.ChartAreas[0].AxisY.IsInterlaced = true;
        //chart.ChartAreas[0].AxisY.InterlacedColor = System.Drawing.Color.FromArgb(10, 255, 0, 0);


        // Do data
        if (YValues != null && XValues != null)
        {
            chart.Series[0].Points.DataBindXY(XValues, YValues);
        }
        else if (YValues != null)
        {
            chart.Series[0].Points.DataBindY(YValues);
        }

        return chart;
    }

    public void Show()
    {
        Chart chart = MakeChart();
        WindowHelper.Show(chart);
    }

       
    private SeriesChartType GetChartType(VxChartType t)
    {
        return (SeriesChartType)Enum.Parse(typeof(SeriesChartType), t.ToString());
    }

}

public static class VxChartExtensions
{

    public static void ShowLineChart(
        this IEnumerable<decimal> source
        )
    {
        source.ShowChart(new VxChart(VxChartType.Line));
    }

    public static void ShowLineChart<TSource>(
        this IEnumerable<TSource> source,
        Func<TSource, decimal> yvalues
        )
    {
        ShowChart(source, new VxChart(VxChartType.Line), yvalues);
    }


    public static void ShowColumnChart(
        this IEnumerable<decimal> source
        )
    {
        source.ShowChart(new VxChart(VxChartType.Column));
    }

    public static void ShowColumnChart<TSource>(
        this IEnumerable<TSource> source,
        Func<TSource, decimal> yvalues
        )
    {
        ShowChart(source, new VxChart(VxChartType.Column), yvalues);
    }


    public static void ShowScatterChart<TSource>(
        this IEnumerable<TSource> source,
        Func<TSource, decimal> xvalues,
        Func<TSource, decimal> yvalues
        )
    {
        ShowChart(source, new VxChart(VxChartType.Point), xvalues, yvalues, null, null);
    }

    public static void ShowScatterChart<TSource>(
        this IEnumerable<TSource> source,
        Func<TSource, decimal> xvalues,
        Func<TSource, decimal> yvalues,
        Func<TSource, string> labels,
        Func<TSource, double> weights
        )
    {
        ShowChart(source, new VxChart(VxChartType.Point), xvalues, yvalues, labels, weights);
    }


    //
    // Lots of overrides for the basic ShowChart, where you have to provide a VxChart.
    //

//     public static void ShowChart<TSource>(
//         this IEnumerable<double> source,
//         VxChart vxchart
//         )
//     {
//         ShowChart(source, vxchart, null, e => (decimal)e, null, null);
//     }

    public static void ShowChart(
        this IEnumerable<decimal> source,
        VxChart vxchart
        )
    {
        ShowChart(source, vxchart, null, e => e, null, null);
    }

    public static void ShowChart<TSource>(
        this IEnumerable<TSource> source,
        VxChart vxchart,
        Func<TSource, decimal> yvalues
        )
    {
        ShowChart(source, vxchart, null, yvalues, null, null);
    }


    public static void ShowChart<TSource>(
        this IEnumerable<TSource> source,
        VxChart vxchart,
        Func<TSource, decimal> xvalues,
        Func<TSource, decimal> yvalues
        )
    {
        ShowChart(source, vxchart, xvalues, yvalues, null, null);
    }

    public static void ShowChart<TSource>(
        this IEnumerable<TSource> source,
        VxChart vxchart,
        Func<TSource, decimal> xvalues,
        Func<TSource, decimal> yvalues,
        Func<TSource, string> labels
        )
    {
        ShowChart(source, vxchart, xvalues, yvalues, labels, null);
    }

    public static void ShowChart<TSource>(
        this IEnumerable<TSource> source,
        VxChart vxchart,
        Func<TSource, decimal> xvalues,
        Func<TSource, decimal> yvalues,
        Func<TSource, string> labels,
        Func<TSource, double> weights
        )
    {
        Chart chart = vxchart.MakeChart();
        int i = 0;
        foreach (var item in source)
        {
            double xval = xvalues != null ? (double)xvalues(item) : i;
            double yval = (double)yvalues(item);
            DataPoint dp = new DataPoint(xval, yval);
            if (labels != null)
                dp.Label = labels(item);
            if (weights != null)
                dp.MarkerSize = (int)(5 + weights(item));
            if (vxchart.ChartType == VxChartType.Point)
                dp.MarkerStyle = MarkerStyle.Circle;
            chart.Series[0].Points.Add(dp);
            i++;
        }
        WindowHelper.Show(chart);
    }


}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxDataServiceLib\WindowHelper.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Forms;
using System.IO;
using System.Reflection;

using System.Windows.Forms.DataVisualization.Charting;

namespace xonline.server.vortex.dataservice
{

public static class WindowHelper
{
    public static void Show(Chart chart)
    {
        // Create basic form
        var w = new System.Windows.Forms.Form();
        w.Text = "LINQPad VxDataServiceLib Window";
        w.Width = 600;
        w.Height = 500;

        // Could do a menu, or toolstrip, or buttons. Meh.
        // Menus would be like so:
        //  var fileMenu = new MenuItem("File");
        //  fileMenu.MenuItems.Add("Save As...");
        //  ...
        //  var mainMenu = new MainMenu();
        //  mainMenu.MenuItems.Add(fileMenu);
        //  myForm.MainMenu = mainMenu;

        Button btnSaveAs = new Button();
        btnSaveAs.Top = 0;
        btnSaveAs.Left = 0;
        btnSaveAs.Text = "Save As...";
        btnSaveAs.Tag = chart;
        btnSaveAs.Click += new EventHandler(btnSaveAs_Click);

        chart.Tag = w;
        chart.Name = "mainChart";
        chart.Top = btnSaveAs.Height + 1;
        chart.Width = w.Width - 15;
        chart.Height = w.Height - 75;

        if (chart.Titles.Count > 0)
            w.Text += " - " + chart.Titles[0].Text;

        // Register event handlers
        w.Resize += new EventHandler(w_Resize);
        chart.KeyDown += new System.Windows.Forms.KeyEventHandler(w_KeyDown);
        chart.MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(w_MouseDoubleClick);

        // Glue it all together and GO
        w.Controls.Add(chart);
        w.Controls.Add(btnSaveAs);
        w.ShowInTaskbar = true;
        w.ShowDialog();
    }

    private static void CloseWindow(object sender)
    {
        Form w = null;
        if (sender is Chart)
        {
            w = (Form)((Chart)sender).Tag;
        }
        else if (sender is Form)
        {
            w = (Form)sender;
        }
        if (w != null)
            w.Close();
    }

    static void w_MouseDoubleClick(object sender, System.Windows.Forms.MouseEventArgs e)
    {
        CloseWindow(sender);
    }

    static void w_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
    {
        CloseWindow(sender);
    }        

    static void w_Resize(object sender, EventArgs e)
    {
        System.Windows.Forms.Form w = (System.Windows.Forms.Form)sender;
        Chart c = w.Controls["mainChart"] as Chart;
        if (c != null)
        {
            c.Width = w.Width - 15;
            c.Height = w.Height - 75;
        }
    }

    static void btnSaveAs_Click(object sender, EventArgs e)
    {
        Button btnSaveAs = (Button)sender;
        Chart chart = (Chart)btnSaveAs.Tag;

        string filter = "";
        filter += "JPEG (*.jpg)|*.jpg|";
        filter += "PNG (*.png)|*.png|";
        filter += "BMP (*.bmp)|*.bmp|";
        filter += "TIFF (*.tif)|*.tif|";
        filter += "GIF (*.gif)|*.gif|";
        filter += "EMF (*.emf)|*.emf";
        //EmfDual = 6,
        //EmfPlus = 7,

        SaveFileDialog fileDialog = new SaveFileDialog();
        fileDialog.Filter = filter;
        fileDialog.RestoreDirectory = true;
        if (fileDialog.ShowDialog() == DialogResult.OK)
        {
            ChartImageFormat imageFormat;
            string imageFileName;

            imageFileName = fileDialog.FileName;
            string fileExt = Path.GetExtension(imageFileName).ToUpper();
            switch (fileExt)
            {
                case ".JPG":
                    imageFormat = ChartImageFormat.Jpeg;
                    break;
                case ".PNG":
                    imageFormat = ChartImageFormat.Png;
                    break;
                case ".BMP":
                    imageFormat = ChartImageFormat.Bmp;
                    break;
                case ".TIF":
                    imageFormat = ChartImageFormat.Tiff;
                    break;
                case ".GIF":
                    imageFormat = ChartImageFormat.Gif;
                    break;
                case ".EMF":
                    imageFormat = ChartImageFormat.Emf;
                    break;
                default:
                    return;
            }
            chart.SaveImage(imageFileName, (ChartImageFormat)imageFormat);
        }
    }


}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxConfig\QueryTemplateMonster.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;

using Microsoft.ComplexEventProcessing;
using Microsoft.ComplexEventProcessing.Linq;
using Microsoft.ComplexEventProcessing.ManagementService;

using xonline.common.config;

namespace xonline.server.vortex.vxconfig
{
    interface IQueryTemplateConfigurator
    {
        // This should be a unique, descriptive name.
        string QueryTemplateName { get; }

        // This should be good description of what this query does.
        string Description { get; }

        bool Equals(IQueryTemplateConfigurator other);

        // Should call streamInsightApp.CreateQueryTemplate() at the end.
        void CreateQueryTemplate(Application streamInsightApp);
    }

    abstract class BaseQueryTemplateConfigurator : IQueryTemplateConfigurator
    {
        abstract public string QueryTemplateName { get; }
        abstract public string Description { get; }
        abstract public void CreateQueryTemplate(Application streamInsightApp);

        public bool Equals(IQueryTemplateConfigurator other)
        {
            IQueryTemplateConfigurator me = this;
            return other.QueryTemplateName == me.QueryTemplateName &&
                   other.Description == me.Description;
        }
    }


    delegate void OutputFunc(string fmt, params object[] args);

    class QueryTemplateMonster : IDisposable
    {
        private Application _application;
        public event OutputFunc DiagnosticOutput;

        public QueryTemplateMonster()
        {
        }

        public void Dispose()
        {
            if (_application != null)
            {
                _application.Server.Dispose();
            }
        }

        public void ConnectToStreamInsight(string streamInsightMgmtUri, string applicationName)
        {
            var endpoint = new System.ServiceModel.EndpointAddress(streamInsightMgmtUri);
            Server server = Server.Connect(endpoint);
            DiagnosticOutput("Connected to {0}", streamInsightMgmtUri);

            if (!server.Applications.TryGetValue(applicationName, out _application))
            {
                throw new InvalidOperationException(String.Format(
                        "No {0} application found at {1}",
                        applicationName,
                        streamInsightMgmtUri));
            }
            DiagnosticOutput("Using application {0}", applicationName);
        }

        public void List(string queryTemplateName)
        {
            if (String.IsNullOrEmpty(queryTemplateName))
            {
                // Dump them all
                ListQueryTemplates(queryTemplateName);
            }
            else
            {
                // Details on one. Same for now.
                ListQueryTemplates(queryTemplateName);
            }
        }

        public void Delete(string queryTemplateName)
        {
            // wow, this is dangerous. protect it, please.

            if (String.IsNullOrEmpty(queryTemplateName))
            {
                var queryTemplates = GetLocalQueryTemplates();
                foreach (var localQt in queryTemplates)
                {
                    if (!String.IsNullOrEmpty(localQt.QueryTemplateName))
                    {
                        Delete(localQt.QueryTemplateName);
                    }
                }
            }
            else
            {
                DiagnosticOutput("Deleting query template \"{0}\"...", queryTemplateName);

                QueryTemplate qt;
                if (_application.QueryTemplates.TryGetValue(queryTemplateName, out qt))
                {
                    // Need to stop and delete all queries
                    var queries = _application.Queries.Values.Where(q => q.QueryTemplateName == qt.Name);
                    foreach (var q in queries)
                    {
                        DiagnosticOutput("  Stopping query \"{0}\"", q.ShortName);
                        q.Stop();
                        DiagnosticOutput("  Deleting query \"{0}\"", q.ShortName);
                        q.Delete();
                    }
                    DiagnosticOutput("  Deleting query template");
                    qt.Delete();
                }
            }
        }

        public void Update(string queryTemplateName)
        {
            CreateOrUpdate(queryTemplateName, true);
        }

        public void Create(string queryTemplateName)
        {
            CreateOrUpdate(queryTemplateName, false);
        }

        private void CreateOrUpdate(string queryTemplateName, bool isDeleteOk)
        {
            var queryTemplates = GetLocalQueryTemplates();
            if (!String.IsNullOrEmpty(queryTemplateName))
            {
                // Limit to just one
                queryTemplates = queryTemplates.Where(q => q.QueryTemplateName.Equals(queryTemplateName, StringComparison.OrdinalIgnoreCase));
                if (queryTemplates.Count() == 0)
                {
                    DiagnosticOutput("No query templates found matching \"{0}\"", queryTemplateName);
                    return;
                }
            }

            foreach (var qt in queryTemplates)
            {
                if (_application.QueryTemplates.ContainsKey(qt.QueryTemplateName))
                {
                    // Have to delete QueryTemplate to change it
                    // But has it changed????????
                    //throw new NotSupportedException("Unable to change/delete existing query template " + qt.QueryTemplateName);
                    DiagnosticOutput("Query template \"{0}\" already exists", qt.QueryTemplateName);
                    if (isDeleteOk)
                    {
                        Delete(qt.QueryTemplateName);
                    }
                    else
                    {
                        DiagnosticOutput("  Unable to create query template. Please use -update command.");
                        continue;
                    }
                }

                DiagnosticOutput("Creating query template \"{0}\"...", qt.QueryTemplateName);
                qt.CreateQueryTemplate(_application);

                // @@@ TODO: need to re-create and restart queries that got deleted, 
                // if we changed an existing template
            }
        }

        public IEnumerable<IQueryTemplateConfigurator> GetLocalQueryTemplates()
        {
            var qtTypes = from type in Assembly.GetExecutingAssembly().GetTypes()
                          where type.GetInterfaces().Contains(typeof(IQueryTemplateConfigurator))
                          select type;                          

            var queryTemplates = from type in qtTypes
                                 let e = type.GetConstructor(Type.EmptyTypes)
                                 where e != null
                                 select (IQueryTemplateConfigurator)e.Invoke(Type.EmptyTypes);
         
            return queryTemplates;
        }

        private void ListQueryTemplates(string queryTemplateName)
        {
            DiagnosticOutput("Query templates in application \"{0}\":", _application.ShortName);
            foreach (var qt in _application.QueryTemplates.Values)
            {
                DiagnosticOutput("  {0,-30}: {1}", qt.ShortName, qt.Description);
                var queries = _application.Queries.Values.Where(q => q.QueryTemplateName == qt.Name);
                var queryList = queries.ToList();
                if (queryList.Count() > 0)
                {
                    queryList.ForEach(q => DiagnosticOutput("    - {0, -30}: {1}", q.ShortName, q.Description));
                }
                else
                {
                    DiagnosticOutput("    - <No queries>");
                }
            }
            DiagnosticOutput("");
        }

    }

    class Utils
    {
        public static IEnumerable<IPAddress> GetLocalIps()
        {
            var ips = from nic in NetworkInterface.GetAllNetworkInterfaces()
                      where
                          nic.NetworkInterfaceType != NetworkInterfaceType.Loopback && // No 127.0.0.1
                          nic.NetworkInterfaceType != NetworkInterfaceType.Tunnel &&      // we don't use tunnel connections
                          nic.OperationalStatus == OperationalStatus.Up &&                // Needs to be online
                          (nic.GetIPProperties().GetIPv4Properties() != null) &&          // Don't care about IPv6 only
                          !nic.GetIPProperties().GetIPv4Properties().IsAutomaticPrivateAddressingActive // No 169.254.X.X
                      from ipInfo in nic.GetIPProperties().UnicastAddresses
                      where 
                          ipInfo.Address.AddressFamily == AddressFamily.InterNetwork
                      select ipInfo.Address;
            return ips;
        }

        public static IEnumerable<IPEndPoint> GetVortexIps()
        {
            var ii = Config.GetInterface(Interface.vortex);

            return new List<IPEndPoint>() { new IPEndPoint(ii.IPAddress, ii.Port) };
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\CommunityUtil.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Net;
using System.Web.Caching;
using System.Threading;
using System.Security.Principal;
using System.IO;
using System.Security.Cryptography;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;

namespace xonline.server.webcache.common 
{

    public struct ReadFileInfo
    {
        public bool         FileNotModified;
        public uint         TitleID;
        public uint         TitleVersion;
        public string       GamerTag;
        public byte         UserCountryID;
        public uint         FileSize;
        public DateTime CreationDate;
        public byte []      FileData;
        public FileContentTypeEnum FileContentType;
    }


    public enum XUSER_DATA_TYPE
    {
        INT32 = 1,
        INT64 = 2,
        DOUBLE = 3,
        UNICODE = 4,
        FLOAT = 5,
        BINARY = 6,
        DATETIME = 7,
    }

    public class UserSetting 
    {
        public ulong ulUserId = 0;
        public uint uiSettingId = 0;
        public object value = null;
        public ReadProfileStatus status = ReadProfileStatus.SUCCESS_DEFAULT;
    }

    public enum ReadProfileStatus : uint
    {
                SUCCESS_TITLE       = XOn.XSOURCE_TITLE, // 2 
                SUCCESS_DEFAULT     = XOn.XSOURCE_DEFAULT, // 1 
                WARNING_NO_VALUE    = XOn.XSOURCE_NO_VALUE,// 0 
                ERROR_NO_PERMISSION = XOn.XSOURCE_PERMISSION_DENIED,  //3
                ERROR_PUID_INVALID  = 4 //May need to be added to Xon definition if you want consistency
    }
    
    public class CommunityUtil {
        private static Utilities utils = Utilities.Instance;

        private static object DefaultValueForType(uint type)
        {
            switch (type)
            {
                case (int)XUSER_DATA_TYPE.INT32: return (int)0;
                case (int)XUSER_DATA_TYPE.INT64: return (Int64)0;
                case (int)XUSER_DATA_TYPE.DOUBLE: return (double)0;
                case (int)XUSER_DATA_TYPE.UNICODE: return "";
                case (int)XUSER_DATA_TYPE.FLOAT: return (float)0;
                case (int)XUSER_DATA_TYPE.BINARY: return new byte[0];
                case (int)XUSER_DATA_TYPE.DATETIME: return DateTime.FromFileTimeUtc(0);
            }
            return null;
        }

        public static int WriteProfile(ulong userPuid, uint titleID, xonline.common.protocol.UserSetting[] settings) {
            if (settings.Length > XOn.XONLINE_MAX_SETTING_COUNT) 
            {
                throw new XboxWebClientException(1, "Setting length exceeded. Cannot get more than " + XOn.XONLINE_MAX_SETTING_COUNT + "settings");
            }
            try
            {
                SyncSettingsRequest req = new SyncSettingsRequest();
                req.TitleId = titleID;
                req.UserId = userPuid;
                req.Version = DateTime.Now.AddDays(7);
                req.StartinIndex = 0;
                req.SettingsLen = (ushort)settings.Length;
                req.Settings = settings;
                IVirtualInterfaceInfo vii = Config.GetVirtualInterface(VirtualInterface.profilefd_int, xonline.common.config.Site.same);
                string url = string.Format("http://{0}:{1}{2}", vii.IPAddressString, vii.Port, req.GetXRL());

                byte[] response = Utilities.Instance.StatsFrontDoorRequest(XOService.Profile, url, userPuid, req.TitleId, req.GetBytes());
                return 0;
            }
            catch (XboxWebClientException)
            {
                throw;
            }
            // we dont need to worry about data sent back
        }

        public static UserSetting[] ReadProfile(ulong userPuid, uint titleID, /*ushort localeID, */ulong[] friendPuids, uint[] settingIDs) {
            if (settingIDs.Length > XOn.XONLINE_MAX_SETTING_COUNT) 
            {
                throw new XboxWebClientException(1, "Setting length exceeded. Cannot get more than " + XOn.XONLINE_MAX_SETTING_COUNT + "settings");
            }
            if (friendPuids.Length == 0 || settingIDs.Length == 0)
            {
                return new UserSetting[] { };
            }
            string[] gamerTags = utils.LookupGamerTags(friendPuids);
            int count = 0, count2 = 0;

            for (int i = 0; i < gamerTags.Length; i++)
                if (gamerTags[i] != Utilities.InvalidGamertag) count++;
            ulong[] validPuids = new ulong[count];
            ulong[] badPuids = new ulong[friendPuids.Length - count];
            count = 0;
            for (int i = 0; i < gamerTags.Length; i++)
                if (gamerTags[i] != Utilities.InvalidGamertag) validPuids[count++] = friendPuids[i];
                else badPuids[count2++] = friendPuids[i];

            ReadSettingsRequest req = new ReadSettingsRequest();
            req.TitleId = titleID;
            req.UserId = userPuid;
            req.SettingIdsLen = (ushort) settingIDs.Length;
            req.SettingIds = settingIDs;
            IVirtualInterfaceInfo vii = Config.GetVirtualInterface(VirtualInterface.profilefd_int, xonline.common.config.Site.same);
            string url = string.Format("http://{0}:{1}{2}", vii.IPAddressString, vii.Port, req.GetXRL());

            List<UserSetting> res = new List<UserSetting>();
            for (int k = 0; k < validPuids.Length; k += XOn.XONLINE_MAX_SETTING_USERS)
            {
                req.ForUserIdsLen = (ushort)Math.Min(XOn.XONLINE_MAX_SETTING_USERS, validPuids.Length - k);
                req.ForUserIds = new ulong[req.ForUserIdsLen];
                Array.Copy(validPuids, k, req.ForUserIds, 0, req.ForUserIdsLen);
                try
                {
                    byte[] response = Utilities.Instance.StatsFrontDoorRequest(XOService.Profile, url, userPuid, req.TitleId, req.GetBytes());
                    ReadSettingsResponse resp = new ReadSettingsResponse();
                    resp.SetBytes(response);

                    for (int i = 0; i < resp.SettingsLen; i++)
                    {
                        UserSetting us = new UserSetting();
                        us.ulUserId = resp.Settings[i].UserId;
                        us.uiSettingId = resp.Settings[i].SettingId;
                        us.status = (ReadProfileStatus)resp.Settings[i].Source;

                        //parse value
                        MemoryStream ms = new MemoryStream(resp.Settings[i].Value);
                        BinaryReaderEndianSwap br = new BinaryReaderEndianSwap(ms);
                        uint type = us.uiSettingId >> 28;
                        object value = null;
                        if (us.status == ReadProfileStatus.WARNING_NO_VALUE
                            || us.status == ReadProfileStatus.ERROR_NO_PERMISSION) // Tienn to confirm if this is correct
                        {
                            value = DefaultValueForType(type);
                        }
                        else
                        {
                            switch (type)
                            {
                                case (int)XUSER_DATA_TYPE.INT32: value = br.ReadInt32();
                                    break;
                                case (int)XUSER_DATA_TYPE.INT64: value = br.ReadInt64();
                                    break;
                                case (int)XUSER_DATA_TYPE.DOUBLE: value = br.ReadDouble();
                                    break;
                                case (int)XUSER_DATA_TYPE.UNICODE: value = br.ReadUnicode();
                                    break;
                                case (int)XUSER_DATA_TYPE.FLOAT: value = br.ReadSingle();
                                    break;
                                case (int)XUSER_DATA_TYPE.BINARY: value = resp.Settings[i].Value;
                                    break;
                                case (int)XUSER_DATA_TYPE.DATETIME: value = br.ReadDateTime();
                                    break;
                            }
                        }
                        us.value = value;
                        res.Add(us);
                    }
                }
                catch (XboxWebException)
                {
                    throw; // front door request failed
                }
            }
            foreach (ulong badPuid in badPuids)
            {
                for (int i = 0; i < settingIDs.Length; i++)
                {
                    UserSetting us = new UserSetting();
                    us.ulUserId = badPuid;
                    us.uiSettingId = settingIDs[i];
                    uint type = us.uiSettingId >> 28;
                    us.value = DefaultValueForType(type);
                    us.status = ReadProfileStatus.ERROR_PUID_INVALID;
                    res.Add(us);
                }
            }
            return res.ToArray();
        }
    }

    public class BinaryReaderEndianSwap : BinaryReader
    {
        private byte[] conversionBuffer;    // temp space for writing primitives to.

        // Hide this cause it's not useful
        private BinaryReaderEndianSwap()
            : base(Stream.Null, System.Text.Encoding.BigEndianUnicode)
        {
        }

        public BinaryReaderEndianSwap(Stream input)
            : base(input, System.Text.Encoding.BigEndianUnicode)
        {
        }

        public override bool ReadBoolean()
        {
            FillConversionBuffer(1);

            return (conversionBuffer[0] != 0);
        }

        public override byte ReadByte()
        {
            FillConversionBuffer(1);

            return (conversionBuffer[0]);
        }

        public override sbyte ReadSByte()
        {
            FillConversionBuffer(1);

            return ((sbyte)conversionBuffer[0]);
        }

        public override short ReadInt16()
        {
            FillConversionBuffer(2);

            return (short)(conversionBuffer[1] | conversionBuffer[0] << 8);
        }

        public override ushort ReadUInt16()
        {
            FillConversionBuffer(2);

            return (ushort)(conversionBuffer[1] | conversionBuffer[0] << 8);
        }

        public override int ReadInt32()
        {
            FillConversionBuffer(4);

            return (int)(conversionBuffer[3] | conversionBuffer[2] << 8 | conversionBuffer[1] << 16 | conversionBuffer[0] << 24);
        }

        public override uint ReadUInt32()
        {
            FillConversionBuffer(4);

            return (uint)(conversionBuffer[3] | conversionBuffer[2] << 8 | conversionBuffer[1] << 16 | conversionBuffer[0] << 24);
        }

        public override long ReadInt64()
        {
            FillConversionBuffer(8);

            uint lo = (uint)(conversionBuffer[7] | conversionBuffer[6] << 8 |
                             conversionBuffer[5] << 16 | conversionBuffer[4] << 24);

            uint hi = (uint)(conversionBuffer[3] | conversionBuffer[2] << 8 |
                             conversionBuffer[1] << 16 | conversionBuffer[0] << 24);

            return (long)((ulong)hi) << 32 | lo;
        }

        public override ulong ReadUInt64()
        {
            FillConversionBuffer(8);

            uint lo = (uint)(conversionBuffer[7] | conversionBuffer[6] << 8 |
                conversionBuffer[5] << 16 | conversionBuffer[4] << 24);

            uint hi = (uint)(conversionBuffer[3] | conversionBuffer[2] << 8 |
                conversionBuffer[1] << 16 | conversionBuffer[0] << 24);

            return ((ulong)hi) << 32 | lo;
        }

        public override float ReadSingle()
        {
            FillConversionBuffer(4);

            Array.Reverse(conversionBuffer, 0, 4);

            return BitConverter.ToSingle(conversionBuffer, 0);
        }

        public override double ReadDouble()
        {
            FillConversionBuffer(8);

            Array.Reverse(conversionBuffer, 0, 8);

            return BitConverter.ToDouble(conversionBuffer, 0);
        }

        public string ReadUnicode()
        {
            long length = this.BaseStream.Length;
            char[] c = new char[length / 2];
            for (int i = 0; i < length / 2; i++)
                c[i] = (char)ReadInt16();
            return new string(c);
        }

        public override decimal ReadDecimal()
        {
            // Advance stream pointer, even if we don't do the conversion
            FillConversionBuffer(16);

            Debug.Assert(false, "BinaryReaderEndianSwap.ReadDecimal not supported.");

            return 0;
        }

        public DateTime ReadDateTime()
        {

            long time = ReadInt64();

            return DateTime.FromFileTimeUtc(time);
        }

        private void FillConversionBuffer(int bytes)
        {
            conversionBuffer = base.ReadBytes(bytes);

            if (conversionBuffer.Length < bytes)
                throw new EndOfStreamException();
        }
    }   // class BinaryReaderEndianSwap

    public class BinaryWriterEndianSwap : BinaryWriter
    {
        private byte[] conversionBuffer;    // temp space for writing primitives to.

        // Hide this cause it's not useful
        private BinaryWriterEndianSwap()
            : base(Stream.Null, System.Text.Encoding.BigEndianUnicode)
        {
        }

        public BinaryWriterEndianSwap(Stream output)
            : base(output, System.Text.Encoding.BigEndianUnicode)
        {
            // Temp buffer for conversions
            conversionBuffer = new byte[16];
        }


        // Writes a double to this stream. The current position of the stream is
        // advanced by eight.
        //
        public override void Write(double value)
        {
            conversionBuffer = BitConverter.GetBytes(value);
            Array.Reverse(conversionBuffer);

            base.Write(conversionBuffer, 0, 8);
        }

        // Writes a unicode string to this stream. 
        //
        public override void Write(string unicodeValue)
        {
            foreach (char c in unicodeValue)
            {
                Write((short)c);
            }
        }

        // Writes a date to this stream. 
        //
        public void Write(DateTime dt)
        {
            long date = dt.ToBinary();
            Write(date);
        }

        public override void Write(decimal value)
        {
            Debug.Assert(false, "BinaryWriterEndianSwap.Write(decimal) not supported.");

            //            Decimal.GetBytes(value,conversionBuffer);
            //            base.Write(conversionBuffer, 0, 16);
        }


        // Writes a two-byte signed integer to this stream. The current position of
        // the stream is advanced by two.
        //
        public override void Write(short value)
        {
            conversionBuffer[1] = (byte)value;
            conversionBuffer[0] = (byte)(value >> 8);
            base.Write(conversionBuffer, 0, 2);
        }

        // Writes a two-byte unsigned integer to this stream. The current position
        // of the stream is advanced by two.
        //
        public override void Write(ushort value)
        {
            conversionBuffer[1] = (byte)value;
            conversionBuffer[0] = (byte)(value >> 8);
            base.Write(conversionBuffer, 0, 2);
        }

        // Writes a four-byte signed integer to this stream. The current position
        // of the stream is advanced by four.
        //
        public override void Write(int value)
        {
            conversionBuffer[3] = (byte)value;
            conversionBuffer[2] = (byte)(value >> 8);
            conversionBuffer[1] = (byte)(value >> 16);
            conversionBuffer[0] = (byte)(value >> 24);
            base.Write(conversionBuffer, 0, 4);
        }

        // Writes a four-byte unsigned integer to this stream. The current position
        // of the stream is advanced by four.
        //
        public override void Write(uint value)
        {
            conversionBuffer[3] = (byte)value;
            conversionBuffer[2] = (byte)(value >> 8);
            conversionBuffer[1] = (byte)(value >> 16);
            conversionBuffer[0] = (byte)(value >> 24);
            base.Write(conversionBuffer, 0, 4);
        }

        // Writes an eight-byte signed integer to this stream. The current position
        // of the stream is advanced by eight.
        //
        public override void Write(long value)
        {
            conversionBuffer[7] = (byte)value;
            conversionBuffer[6] = (byte)(value >> 8);
            conversionBuffer[5] = (byte)(value >> 16);
            conversionBuffer[4] = (byte)(value >> 24);
            conversionBuffer[3] = (byte)(value >> 32);
            conversionBuffer[2] = (byte)(value >> 40);
            conversionBuffer[1] = (byte)(value >> 48);
            conversionBuffer[0] = (byte)(value >> 56);
            base.Write(conversionBuffer, 0, 8);
        }

        // Writes an eight-byte unsigned integer to this stream. The current
        // position of the stream is advanced by eight.
        //
        public override void Write(ulong value)
        {
            conversionBuffer[7] = (byte)value;
            conversionBuffer[6] = (byte)(value >> 8);
            conversionBuffer[5] = (byte)(value >> 16);
            conversionBuffer[4] = (byte)(value >> 24);
            conversionBuffer[3] = (byte)(value >> 32);
            conversionBuffer[2] = (byte)(value >> 40);
            conversionBuffer[1] = (byte)(value >> 48);
            conversionBuffer[0] = (byte)(value >> 56);
            base.Write(conversionBuffer, 0, 8);
        }


        // Writes a float to this stream. The current position of the stream is
        // advanced by four.
        //
        public override void Write(float value)
        {
            conversionBuffer = BitConverter.GetBytes(value);
            Array.Reverse(conversionBuffer);
            base.Write(conversionBuffer, 0, 4);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxVisualizer\DataGrapher.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Threading;

namespace VxVisualizer
{
    /// <summary>
    /// Interaction logic for DataGrapher.xaml
    /// </summary>
    public partial class DataGrapher : UserControl
    {
        private class DataCategory
        {
            private Canvas _Parent;
            private string _Name;
            private List<double> _Samples;
            private PointCollection _PointsLeft;
            private PointCollection _PointsRight;
            private List<Polyline> _Lines;
            private object _Lock;

            private int _CurrentSampleIndex;
            private int _MaxSamples;
            private Color _Color;
            private double _StrokeThickness;
            private Label _Label;
            private double _MaxValue;
            private double _MinValue;

            private double _Width;
            private double _Height;
            private double _ScaleX;
            private double _ScaleY;

            private static readonly Color[] c_Colors = new Color[] {
                Color.FromRgb(128, 32, 32),
                Color.FromRgb(32, 128, 32),
                Color.FromRgb(32, 32, 128)
            };
            private static int s_ColorsIndex = 0;

            public DataCategory(Canvas parent, string name, int maxSamples, int width, int height)
            {
                _Parent = parent;
                _Name = name;
                _Samples = new List<double>(maxSamples);
                _PointsLeft = new PointCollection(maxSamples);
                _PointsRight = new PointCollection(maxSamples);
                _Lines = new List<Polyline>();
                _Lock = new object();

                _CurrentSampleIndex = 0;
                _MaxSamples = maxSamples;
                _Color = c_Colors[(s_ColorsIndex++) % c_Colors.Length];
                _StrokeThickness = 2;

                _Label = new Label();
                _Label.Visibility = Visibility.Hidden;
                _Label.Content = name;
                _Label.Background = Brushes.Yellow;
                _Label.BorderBrush = Brushes.DarkGray;
                _Label.BorderThickness = new Thickness(0.5);
                _Label.RenderTransform = new ScaleTransform(1, -1);
                _Label.RenderTransformOrigin = new Point(0.5, 0.5);
                _Label.Margin = new Thickness(0, 0, 0, 0);

                _Width = width;
                _Height = height;
                _ScaleX = 1;
                _ScaleY = 1;

                _Samples.Clear();
                _PointsLeft.Clear();
                _PointsRight.Clear();
                _MaxValue = double.MinValue;
                _MinValue = 0;

                // Pre-populate all points at 0. Also add dummy point.
                _PointsRight.Add(new Point(0, 0));
                for (int i = 0; i < _MaxSamples; i++)
                {
                    _Samples.Add(0);
                    _PointsRight.Add(new Point(i, 0));
                }

                // Set up the lines
                _Lines.Add(new Polyline());
                _Lines.Add(new Polyline());

                _Lines[0].Stroke = new SolidColorBrush(_Color);
                _Lines[0].StrokeThickness = _StrokeThickness;
                _Lines[0].Points = _PointsLeft;
                _Lines[0].MouseDown += new MouseButtonEventHandler(DataCategory_MouseDown);
                _Lines[0].MouseEnter += new MouseEventHandler(DataCategory_MouseEnter);
                _Lines[0].MouseLeave += new MouseEventHandler(DataCategory_MouseLeave);
                _Lines[0].Tag = this;

                _Lines[1].Stroke = new SolidColorBrush(_Color);
                _Lines[1].Stroke = new SolidColorBrush(Color.FromRgb(
                    (byte)(_Color.R * 1.5),
                    (byte)(_Color.G * 1.5),
                    (byte)(_Color.B * 1.5)));
                _Lines[1].StrokeThickness = _StrokeThickness;
                _Lines[1].Points = _PointsRight;
                _Lines[1].MouseDown += new MouseButtonEventHandler(DataCategory_MouseDown);
                _Lines[1].MouseEnter += new MouseEventHandler(DataCategory_MouseEnter);
                _Lines[1].MouseLeave += new MouseEventHandler(DataCategory_MouseLeave);
                _Lines[1].Tag = this;

                // Set default scaling
                ApplyScale(0, 100);

            }

            void DataCategory_MouseLeave(object sender, MouseEventArgs e)
            {
                DataCategory dc = (sender as Polyline).Tag as DataCategory;
                if (dc.Label.Visibility == Visibility.Hidden)
                {
                    return;
                }
                dc.Label.Visibility = Visibility.Hidden;
            }

            void DataCategory_MouseEnter(object sender, MouseEventArgs e)
            {
                DataCategory dc = (sender as Polyline).Tag as DataCategory;
                if (dc.Label.Visibility == Visibility.Visible)
                {
                    return;
                }
                System.Windows.Point position = e.GetPosition(_Parent);
                Thickness margin = new Thickness(position.X, position.Y, 0, 0);
                dc.Label.Margin = margin;
                dc.Label.Visibility = Visibility.Visible;
            }

            void DataCategory_MouseDown(object sender, MouseButtonEventArgs e)
            {
            }

            public bool Highlight
            {
                set
                {
                    //double scale = value ? 2 : 0.5;
                    //_Lines.ForEach(l => l.StrokeThickness *= scale);
                    Color c;
                    if (value)
                        c = Color.FromRgb(200, 200, 0);
                    else
                        c = _Color;
                    _Lines.ForEach(l => { l.Stroke = new SolidColorBrush(c); });
                }
            }

            public Label Label
            {
                get
                {
                    return _Label;
                }
                set
                {
                    _Label = value;
                }
            }

            public double LastValue
            {
                get { return _Samples[_CurrentSampleIndex]; }
            }

            public List<Polyline> Lines
            {
                get { return _Lines; }
            }

            public void SetDimensions(int width, int height)
            {
                if (width < 1)
                    width = 1;
                if (height < 1)
                    height = 1;

                _Width = width;
                _Height = height;

                ApplyScale(_MinValue, _MaxValue);
            }

            public override string ToString()
            {
                return _Name + " (Last value: " + LastValue.ToString() + ")";
            }

            public void IncrementSample(int currentSample, double value)
            {
                lock (_Lock)
                {
                    SetValue(currentSample, oldVal => { return oldVal + value; });
                }
            }

            public void SetSample(int currentSample, double value)
            {
                lock (_Lock)
                {
                    SetValue(currentSample, oldVal => { return value; });
                }
            }

            public void AdvanceTime(int currentSample)
            {
                lock (_Lock)
                {
                    AdvanceTimeHelper(currentSample);
                }
            }

            //private void SetValue(int currentSample, double value)
            private void SetValue(int currentSample, Func<double, double> valueAction)
            {
                // Save old value for later
                double removedValue = _Samples[currentSample];

                // Update oldest sample to be our value
                _Samples[currentSample] = valueAction(_Samples[currentSample]);

                // Update min/max bounds, if necessary
                bool fApplyScale = false;
                if (removedValue == _MaxValue)
                {
                    // have to re-scan and update bounds again
                    _MaxValue = double.MinValue;
                    //_MinValue = double.MaxValue;
                    for (int i = 0; i < _Samples.Count; i++)
                    {
                        if (_Samples[i] > _MaxValue)
                        {
                            _MaxValue = _Samples[i];
                            fApplyScale = true;
                        }
                        //if (_Samples[i] < _MinValue)
                        //{
                        //    _MinValue = _Samples[i];
                        //    fApplyScale = true;
                        //}
                    }
                }
                else
                {
                    if (_Samples[currentSample] > _MaxValue)
                    {
                        _MaxValue = _Samples[currentSample];
                        fApplyScale = true;
                    }
                    //if (value < _MinValue)
                    //{
                    //    _MinValue = value;
                    //    fApplyScale = true;
                    //}
                }

                if (fApplyScale)
                {
                    ApplyScale(_MinValue, _MaxValue);
                }
            }

            private void AdvanceTimeHelper(int currentSample)
            {
                _CurrentSampleIndex = currentSample;

                // Update point. Move from right side to left side.
                if (_PointsRight.Count == 1)
                {
                    for (int j = 0; j < _PointsLeft.Count; j++)
                    {
                        _PointsRight.Add(_PointsLeft[j]);
                    }
                    _PointsLeft.Clear();
                }

                // Grab point from right, set on left, remove on right. Play catch up if necessary
                while (_PointsLeft.Count <= currentSample)
                {
                    Point p = _PointsRight[1];
                    double oldY = p.Y;
                    p.Y = _Samples[currentSample] * _ScaleY;
                    _PointsLeft.Add(p);
                    _PointsRight.RemoveAt(1);

                    // Update dummy point
                    Point p2 = _PointsRight[0];
                    p2.Y = oldY;
                    p2.X = p.X;
                    _PointsRight[0] = p2;
                }

            }

            private void ApplyScale(double minValue, double maxValue)
            {
                if (minValue < 0)
                {
                    minValue = 0;
                }

                if (maxValue < 10)
                {
                    maxValue = 10;
                }

                double scaleX = _Width / (_MaxSamples - 1);
                double maxYBoundary = Math.Pow(10, Math.Ceiling(Math.Log10(maxValue)));
                double scaleY = _Height / maxYBoundary;

                if (scaleX != _ScaleX ||
                    scaleY != _ScaleY)
                {
                    double oldScaleX = _ScaleX;
                    double oldScaleY = _ScaleY;

                    _ScaleX = scaleX;
                    _ScaleY = scaleY;

                    double deltaScaleX = _ScaleX / oldScaleX;
                    double deltaScaleY = _ScaleY / oldScaleY;

                    for (int i = 0; i < _PointsLeft.Count; i++)
                    {
                        Point p = _PointsLeft[i];
                        p.X *= deltaScaleX;
                        p.Y *= deltaScaleY;
                        _PointsLeft[i] = p;
                    }

                    for (int i = 0; i < _PointsRight.Count; i++)
                    {
                        Point p = _PointsRight[i];
                        p.X *= deltaScaleX;
                        p.Y *= deltaScaleY;
                        _PointsRight[i] = p;
                    }
                }
            }

        }

        private Dictionary<string, DataCategory> _DataCategories;
        private object _DataCategoriesLock = new object();
        private int _MaxSamples;
        private int _CurrentStartSample;
        private Line _VerticalSeparator;

        public DataGrapher()
        {
            InitializeComponent();

            Reset();
        }

        public void Reset()
        {
            lock (_DataCategoriesLock)
            {
                _DataCategories = new Dictionary<string, DataCategory>();
                _MaxSamples = 100;
                _CurrentStartSample = 0;
                listBoxDataCategories.ItemsSource = _DataCategories.Values;
            }

            _VerticalSeparator = new Line();

            UpdateUI();
            canvas1.Children.Clear();
            canvas1.Children.Add(_VerticalSeparator);

        }

        public void AddSample(string categoryName, double sampleValue)
        {
            DataCategory datacat = GetDataCategory(categoryName);
            datacat.SetSample(_CurrentStartSample, sampleValue);
        }

        public void AddSample(string categoryName, string sampleName, double sampleValue)
        {
        }

        public void AdvanceTime()
        {
            lock (_DataCategoriesLock)
            {
                foreach (DataCategory datacat in _DataCategories.Values)
                {
                    datacat.AdvanceTime(_CurrentStartSample);
                }
            }
            UpdateUI();
            _CurrentStartSample = (_CurrentStartSample + 1) % _MaxSamples;
        }



        private DataCategory GetDataCategory(string categoryName)
        {
            DataCategory datacat;
            lock (_DataCategoriesLock)
            {
                if (!_DataCategories.TryGetValue(categoryName, out datacat))
                {
                    datacat = new DataCategory(canvas1, categoryName, _MaxSamples, (int)canvas1.ActualWidth, (int)canvas1.ActualHeight);
                    if (_CurrentStartSample > 0)
                        datacat.AdvanceTime(_CurrentStartSample - 1);
                    _DataCategories[categoryName] = datacat;

                    //listBoxDataCategories.Items.Add(datacat);

                    // We remove the vertical line, and add it back at the end, to ensure it
                    // is always on top. This may not be the best way.
                    canvas1.Children.Remove(_VerticalSeparator);
                    foreach (Polyline l in datacat.Lines)
                    {
                        canvas1.Children.Add(l);
                    }
                    canvas1.Children.Add(datacat.Label);
                    canvas1.Children.Add(_VerticalSeparator);
                }
            }
            return datacat;
        }

        private void UserControl_Loaded(object sender, RoutedEventArgs e)
        {
            AdvanceTime();
        }

        private void UpdateUI()
        {
            Line vs = _VerticalSeparator;
            // Draw vertical line
            double scaleX = canvas1.ActualWidth / (_MaxSamples - 1);
            //double midX = (_CurrentStartSample * scaleX) + (scaleX / 2.0);
            vs.X1 = (_CurrentStartSample * scaleX);
            vs.Y1 = 0;
            vs.X2 = (_CurrentStartSample * scaleX);
            vs.Y2 = canvas1.ActualHeight;
            vs.Stroke = Brushes.LightGray;
            vs.StrokeThickness = 1;

            listBoxDataCategories.Items.Refresh();
            //listBoxDataCategories.UpdateLayout();
        }

        private void canvas1_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            lock (_DataCategoriesLock)
            {
                foreach (DataCategory datacat in _DataCategories.Values)
                {
                    datacat.SetDimensions((int)e.NewSize.Width, (int)e.NewSize.Height);
                    UpdateUI();
                }
            }
        }

        private void listBoxDataCategories_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (e.AddedItems.Count > 0)
            {
                foreach (object o in e.AddedItems)
                {
                    DataCategory datacat = o as DataCategory;
                    datacat.Highlight = true;
                }
            }
            if (e.RemovedItems.Count > 0)
            {
                foreach (object o in e.RemovedItems)
                {
                    DataCategory datacat = o as DataCategory;
                    datacat.Highlight = false;
                }
            }
        }

        private void btnReset_Click(object sender, RoutedEventArgs e)
        {
            Reset();
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxVisualizer\MainWindow.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Threading;

using Visifire.Charts;
using Visifire.Commons;

using xonline.common.config;

namespace VxVisualizer
{
    /// <summary>
    /// Interaction logic for Window1.xaml
    /// </summary>
    public partial class Window1 : Window
    {
        XomManagement _XomConnection;
        Dictionary<string,bool> _AreaFilters;

        public Window1()
        {
            InitializeComponent();
            
            _AreaFilters = new Dictionary<string, bool>();
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // Do xmgmt stuff on another thread, so we don't hang the UI
            ThreadPool.QueueUserWorkItem(new WaitCallback(InitRemoteTargets));
        }

        private void InitRemoteTargets(object state)
        {
            // @@@ Need to remove all these Dispatcher.Invoke calls and come up with a 
            // better model for thread/ui interaction.
            Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Normal,
                (Action)(() =>
                {
                    lblNpdbServer.Content = Config.NpdbServer;
                }));

            _XomConnection = new XomManagement(Interface.vortex, "vortexsvc");
            foreach (XomArea area in _XomConnection.GetAreas("vortexsvc"))
            {
                if (area.AreaName.ToLower().StartsWith("vx"))
                {
                    area.Listen(OnReceive);
                    Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Normal,
                        (Action)(() =>
                        {
                            CheckBox cb = new CheckBox();
                            cb.Content = area.AreaName;
                            cb.IsChecked = true;
                            cb.Checked += HandleAreaFilterChange;
                            cb.Unchecked += HandleAreaFilterChange;
                            comboAreaFilters.Items.Add(cb);

                            _AreaFilters[area.AreaName] = true;
                        }));
                }                    
            }
        }

        private void HandleAreaFilterChange(object sender, RoutedEventArgs e)
        {
            CheckBox cb = sender as CheckBox;
            string name = cb.Content as string;

            // @@@ This only turns off the local processing of messages. Better would be to 
            // disable the remote listener, that is remove our remote target from the area.
            _AreaFilters[name] = cb.IsChecked ?? false;
        }

        void OnReceive(XomRemoteMessage msg)
        {
            if (!_AreaFilters[msg.Area.ToLower()])
            {
                return;
            }
            Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Normal,
                (Action)(() =>
                {
                    int i = lblMsgRecvSec.Content as int? ?? 0;
                    lblMsgRecvSec.Content = ++i;
                    txtMessages.Text += System.Environment.NewLine + "[" + msg.Area + "]" + msg.Message;
                }));
            
            ProcessMessage(msg.Message);
        }

        private void ProcessMessage(string message)
        {
            try
            {
                string[] fields = message.Split(new char[] { '|' });

                if (fields[1] == "VxCount")
                {
                    // 0: timestamp
                    // 1: id, "VxCount"
                    // 2: window span in seconds
                    // 3: count
                    // 4: key1 (apparea)
                    // 5: key2 (pagename)
                    // 6: key3 (events)

                    if (fields.Length < 5)
                    {
                        System.Diagnostics.Debug.WriteLine("Invalid message: " + message);
                        return;
                    }

                    string eventType = fields[6];
                    if (fields[6] == "event6")
                        fields[6] = "impression";
                    else if (fields[6] == "event9")
                        fields[6] = "click";

                    string category = fields[4];
                    // Add other keys into category name
                    for (int i = 5; i < fields.Length; i++)
                    {
                        category += "/" + fields[i];
                    }
                    DateTime sampleTime = DateTime.Parse(fields[0]);
                    string sampleName = fields[0]; // datetime string
                    int sampleValue = int.Parse(fields[3]);

                    Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Normal,
                    (Action)(() =>
                    {
                        DataSeries dataSeries = chartMain.Series.FirstOrDefault(e => e.LegendText == category);
                        if (dataSeries == null)
                        {
                            dataSeries = new DataSeries();
                            dataSeries.RenderAs = RenderAs.Line;
                            dataSeries.MarkerType = MarkerTypes.Circle;
                            dataSeries.SelectionEnabled = true;
                            dataSeries.LineThickness = 2;
                            dataSeries.LegendText = category;
                            dataSeries.XValueType = ChartValueTypes.DateTime;
                            chartMain.Series.Add(dataSeries);
                        }
                        DataPoint dataPoint = dataSeries.DataPoints.FirstOrDefault(e => (string)e.AxisXLabel == sampleName);
                        if (dataPoint == null)
                        {
                            dataPoint = new DataPoint() { AxisXLabel = sampleName, XValue=sampleTime, YValue = 0 };
                        }
                        dataPoint.YValue += sampleValue;
                        dataSeries.DataPoints.Add(dataPoint);

                        //DateTime minTime = sampleTime.Subtract(TimeSpan.FromSeconds(120));
                        //chartMain.AxesX[0].AxisMinimum = minTime;
                        //chartMain.AxesX[0].AxisMaximum = sampleTime;

                    }));

                    //int spanInMs = int.Parse(fields[2]) * 1000;
                    //if (updateTimer.Interval != spanInMs)
                    //{
                    //    updateTimer.Interval = spanInMs;
                    //    lblRefreshInterval.Text = (spanInMs / 1000).ToString();
                    //}
                }
            }
            catch (Exception e)
            {
                System.Diagnostics.Debug.WriteLine("Error: + " + e.ToString());
            }
        }

        private void Window_Closed(object sender, EventArgs e)
        {
            _XomConnection.Dispose();
        }

        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\vortex\tool\VxVisualizer\XomManagement.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

using xonline.common.config;

// Description:
//
// This is an easy-to-use class for all things XOM, aka XMGMT. This specifically 
// focuses on putting a data model around XomLogging -- things like components, 
// areas, and targets. It also makes it easy to hook up a remote target so you
// can listen in to an area's output. This class isn't 100% complete, but exposes
// its classes in nice IEnumerable methods so you can accomplish a lot with a 
// little.
//
// The "auto" listener will be removed upon graceful shutdown, or upon next startup
// for "crash" shutdowns.
//
// The class hierarchy is something like:
//
// - XomManagement (entry point)
//   - XomServer
//     - XomComponent
//       - XomTarget
//       - XomArea
//         - XomTarget (reference back to target)
// - XomRemoteListener (private)
//   - XomRemoteMessage (provided to Listen() callback)
// 
// Example:
//
//      void Init()
//      {
//          _XomConnection = new XomManagement(Interface.vortex, "vortexsvc");
//          foreach (XomArea area in _XomConnection.GetAreas("vortexsvc"))
//          {
//              if (area.AreaName.ToLower().StartsWith("vx"))
//              {
//                  area.Listen(OnReceive);
//              }                    
//          }
//      }
//  
//      void OnReceive(XomRemoteMessage msg)
//      {
//          ProcessMessage(msg.Message);
//      }
//
// kgoodier 2/2010


namespace VxVisualizer
{
    public class XomManagement : IDisposable
    {
        public Dictionary<string, XomServer> Servers;

        public XomManagement(string interfaceName)
            : this(interfaceName, interfaceName)
        {
        }

        public XomManagement(string interfaceName, string xmgmtComponentName)
        {
            Servers = new Dictionary<string, XomServer>();
            PopulateServers(interfaceName, xmgmtComponentName);
        }

        public IEnumerable<XomComponent> GetComponents()
        {
            return GetComponents(null);
        }

        public IEnumerable<XomComponent> GetComponents(string componentName)
        {
            foreach (XomServer server in Servers.Values)
            {
                foreach (XomComponent component in server.Components)
                {
                    if (String.IsNullOrEmpty(componentName) ||
                        componentName.Equals(component.ComponentName, StringComparison.OrdinalIgnoreCase))
                    {
                        yield return component;
                    }
                }
            }
        }

        public IEnumerable<XomArea> GetAreas()
        {
            return GetAreas(null);
        }

        public IEnumerable<XomArea> GetAreas(string componentName)
        {
            foreach (XomComponent component in GetComponents(componentName))
            {
                foreach (XomArea area in component.Areas)
                {
                    yield return area;
                }
            }
        }

        public IEnumerable<XomTarget> GetTargets()
        {
            return GetTargets(null);
        }

        public IEnumerable<XomTarget> GetTargets(string componentName)
        {
            foreach (XomComponent component in GetComponents(componentName))
            {
                foreach (XomTarget target in component.Targets)
                {
                    yield return target;
                }
            }
        }

        private void PopulateServers(string interfaceName, string xmgmtComponentName)
        {
            string[] servers = Config.GetServerListByInterface(interfaceName);
            foreach (string s in servers)
            {
                if (!Servers.ContainsKey(s))
                {
                    XomServer xom = new XomServer(s, xmgmtComponentName);
                    Servers.Add(s, xom);
                }
            }
        }

        public void Dispose()
        {
            foreach (XomServer server in Servers.Values)
            {
                server.Dispose();
            }
        }
    }

    public class XomServer : IDisposable
    {
        public string ServerName { get; set; }
        public List<XomComponent> Components { get; set; }

        public IPEndPoint LocalEndPoint
        {
            get
            {
                return _Client.Client.LocalEndPoint as IPEndPoint;
            }
        }

        private TcpClient _Client;
        private int _SendTimeoutInMs = 5 * 1000;
        private int _ReceiveTimeoutInMs = 30 * 1000;
        private static readonly Regex s_regexSize = new Regex(@"Size=(?<size>[^/n]*)");
        private static readonly Regex s_regexResult = new Regex(@"Result=(?<size>[^/n]*)");

        public XomServer(string serverName, string componentName)
        {
            IInterfaceInfo ii = Config.GetInterface(serverName, Interface.xmgmtsrv);
            IPEndPoint remoteEP = new IPEndPoint(ii.IPAddress, ii.Port);

            _Client = new TcpClient();
            _Client.SendTimeout = _SendTimeoutInMs;
            _Client.ReceiveTimeout = _ReceiveTimeoutInMs;
            _Client.Connect(remoteEP);
            ServerName = serverName;
            Components = GetComponents(componentName);
        }

        private List<XomComponent> GetComponents(string componentName)
        {
            List<XomComponent> componentList = new List<XomComponent>();
            string[] lines;

            Execute("list " + componentName, out lines);
            foreach (string l in lines)
            {
                componentList.Add(new XomComponent(this, l));
            }

            return componentList;
        }

        public uint Execute(string command, out string[] output)
        {
            uint hr = 0x8015190d;
            List<string> outputLines = new List<string>();
            command = command + "\n";

            NetworkStream stream = _Client.GetStream();

            try
            {
                TextReader reader = new StreamReader(stream);

                byte[] sendBytes = Encoding.ASCII.GetBytes(command);
                stream.Write(sendBytes, 0, sendBytes.Length);

                // 2 ways out, a result line or a line without a proper beginning
                while (true)
                {
                    string t = reader.ReadLine();
                    Match sizeMatch = s_regexSize.Match(t);
                    Match resultMatch = s_regexResult.Match(t);

                    if (resultMatch.Length > 0)
                    {
                        hr = Convert.ToUInt32(resultMatch.Groups[1].Value);
                        goto lbDone;
                    }

                    if (sizeMatch.Length == 0)
                    {
                        // Size line not parsed, this must be an error
                        goto lbDone;
                    }

                    int dataLength = Convert.ToInt32(sizeMatch.Groups[1].Value);
                    char[] buffer = new char[dataLength];
                    int totalRead = 0;

                    //read the data in
                    System.DateTime readStartTime = System.DateTime.UtcNow;
                    while (totalRead < dataLength)
                    {
                        int timeoutInMS = _ReceiveTimeoutInMs - (int)(System.DateTime.UtcNow - readStartTime).TotalMilliseconds;
                        if (timeoutInMS <= 0)
                        {
                            throw new TimeoutException("Timed out waiting for expected data from the stream.");
                        }
                        stream.ReadTimeout = timeoutInMS;

                        totalRead += reader.Read(buffer, totalRead, dataLength - totalRead);
                    }

                    string bufString = new string(buffer);
                    string[] lines = bufString.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                    outputLines.AddRange(lines);
                }

            lbDone:
                output = outputLines.ToArray();
                return hr;
            }
            finally
            {
                // This seems to actually close the TCP connection as well
                //stream.Close();
            }
        }

        public override string ToString()
        {
            return String.Format("{0}: {1} components",
                ServerName, Components != null ? Components.Count : 0);
        }

        //~XomServer()
        //{
        //    Dispose();
        //}

        public void Dispose()
        {
            Components.ForEach(c => c.Targets.ForEach(t => t.Dispose()));
        }
    }

    public class XomComponent
    {
        public XomServer ParentServer { get; set; }
        public string ProcessName { get; set; }
        public string ProcessId { get; set; }
        public string ComponentName { get; set; }
        public List<XomArea> Areas { get; set; }
        public List<XomTarget> Targets { get; set; }

        private Dictionary<string, XomRemoteListener> _Listeners;

        public XomComponent(XomServer parent, string xmgmtComponentLine)
        {
            _Listeners = new Dictionary<string, XomRemoteListener>();
            ParentServer = parent;

            // Example:
            // VortexSvc(3912) VortexSvc

            // regex would be better
            int firstParen = xmgmtComponentLine.IndexOf("(");
            if (firstParen > -1)
            {
                int secondParen = xmgmtComponentLine.IndexOf(")");
                if (secondParen > -1)
                {
                    ProcessName = xmgmtComponentLine.Substring(0, firstParen);
                    ProcessId = xmgmtComponentLine.Substring(firstParen + 1, secondParen - firstParen - 1);
                    ComponentName = xmgmtComponentLine.Substring(secondParen + 1).Trim();

                    Targets = GetTargets(String.Empty);
                    Areas = GetAreas(String.Empty);
                }
            }
        }

        private List<XomArea> GetAreas(string areaName)
        {
            List<XomArea> areaList = new List<XomArea>();
            string[] lines;

            string cmd = String.Format("e {0}:{1} la {2}", ProcessId, ComponentName, areaName);
            ParentServer.Execute(cmd, out lines);
            foreach (string l in lines)
            {
                areaList.Add(new XomArea(this, l, Targets));
            }

            return areaList;
        }

        private List<XomTarget> GetTargets(string targetName)
        {
            List<XomTarget> targetList = new List<XomTarget>();
            string[] lines;

            string cmd = String.Format("e {0}:{1} lt {2}", ProcessId, ComponentName, targetName);
            ParentServer.Execute(cmd, out lines);
            foreach (string l in lines)
            {
                targetList.Add(new XomTarget(this, l));
            }

            return targetList;
        }

        public void Listen(XomArea area, XomMessageReceivedCallback callback)
        {
            string remoteListenerKey;
            XomRemoteListener remoteListener;
            string remoteTargetName;
            XomTarget target;
            string localIP = (ParentServer.LocalEndPoint as IPEndPoint).Address.ToString();
            string localPort;

            // Look for and create local UDP listener
            remoteListenerKey = "VxVisualizer_" + localIP;
            if (!_Listeners.TryGetValue(remoteListenerKey, out remoteListener))
            {
                remoteListener = new XomRemoteListener(0);
                _Listeners.Add(remoteListenerKey, remoteListener);
            }
            remoteListener.AddCallback(callback);
            localPort = remoteListener.LocalEndPoint.Port.ToString();

            // Look for our remote target
            // @@@ probably don't want to include port, makes it hard to clean up stale entries
            //remoteTargetName = remoteListenerKey + ":" + localPort;
            remoteTargetName = remoteListenerKey;
            target = Targets.Find(e => e.TargetName.Equals(remoteTargetName, StringComparison.OrdinalIgnoreCase));
            if (target != null &&
                !target.ParamsString.Contains(localPort))
            {
                // Wrong target
                target.Delete();
                target = null;
            }

            // Create remote target
            if (target == null)
            {
                // managed only! native is "type=Remote;Address={0}:{1}"
                string targetParams = String.Format("type=Remote;Address={0};Port={1}", 
                    localIP, 
                    localPort);
                target = CreateTarget(remoteTargetName, targetParams);
            }

            // Associate target with our area
            area.AddTarget(target);
            if (area.Level != "0")
            {
                area.SetLevel("0");
            }
        }

        public XomTarget CreateTarget(string targetName, string targetParams)
        {
            string[] lines;
            string cmd = String.Format("e {0}:{1} nt {2} {3}", 
                ProcessId, 
                ComponentName, 
                targetName, 
                targetParams);
            ParentServer.Execute(cmd, out lines);
            foreach (string l in lines)
            {
                System.Diagnostics.Debug.WriteLine(l);
            }

            XomTarget target = new XomTarget(this, targetName, targetParams);
            target.RemoveOnDispose = true;
            Targets.Add(target);

            return target;
        }

        public override string ToString()
        {
            return String.Format("[{0}\\{1}] {2}({3}):{4} {5} areas {6} targets",
                ParentServer.ServerName,
                ComponentName,
                ProcessName,
                ProcessId,
                ComponentName,
                Areas != null ? Areas.Count : 0,
                Targets != null ? Targets.Count : 0);
        }
    }

    public class XomArea
    {
        public XomComponent ParentComponent { get; set; }
        public string AreaName { get; set; }
        public string Level { get; set; }
        public List<XomTarget> Targets { get; set; }

        public XomArea(XomComponent parent, string xmgmtAreaLine, List<XomTarget> targets)
        {
            ParentComponent = parent;

            // Example: 
            // Area: xcacheproxy            Lvl: -1 Targets: debugoutput remote

            // regex would be better
            string[] fields = xmgmtAreaLine.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (fields[0] != "Area:" ||
                fields[2] != "Lvl:" ||
                fields[4] != "Targets:")
            {
                throw new ArgumentException("Bad input: " + xmgmtAreaLine);
            }
            AreaName = fields[1];
            Level = fields[3];
            Targets = new List<XomTarget>();

            if (targets != null)
            {
                for (int i = 5; i < fields.Length; i++)
                {
                    XomTarget target = targets.Find(e => fields[i].Equals(e.TargetName, StringComparison.OrdinalIgnoreCase));
                    if (target != null)
                    {
                        Targets.Add(target);
                    }
                }
            }
        }

        public void Listen(XomMessageReceivedCallback callback)
        {
            ParentComponent.Listen(this, callback);
        }

        public void AddTarget(XomTarget target)
        {
            string[] lines;
            string cmd = String.Format("e {0}:{1} at {2} {3}",
                ParentComponent.ProcessId,
                ParentComponent.ComponentName,
                target.TargetName,
                AreaName);
            ParentComponent.ParentServer.Execute(cmd, out lines);
            foreach (string l in lines)
            {
                System.Diagnostics.Debug.WriteLine(l);
            }

            Targets.Add(target);
        }

        public void SetLevel(string level)
        {
            string[] lines;
            string cmd = String.Format("e {0}:{1} cal {2} {3}",
                ParentComponent.ProcessId,
                ParentComponent.ComponentName,
                AreaName,
                level);
            ParentComponent.ParentServer.Execute(cmd, out lines);
            foreach (string l in lines)
            {
                System.Diagnostics.Debug.WriteLine(l);
            }

            Level = level;
        }

        public override string ToString()
        {
            string targets = "";
            if (Targets != null)
            {
                Targets.ForEach(e => targets = targets + e.TargetName + " ");
            }
            return String.Format("[{0}\\{1}] Area: {2} Lvl: {3} Targets: {4}",
                ParentComponent.ParentServer.ServerName,
                ParentComponent.ComponentName,
                AreaName,
                Level,
                targets);
        }
    }

    public class XomTarget : IDisposable
    {
        public enum TargetType
        {
            Console,
            DebugOutput,
            File,
            NtLog,
            Remote,
            Report
        };

        public XomComponent ParentComponent { get; set; }
        public string TargetName { get; set; }
        public string ParamsString { get; set; }
        //public TargetType Type { get; set; }

        public bool RemoveOnDispose { get; set; }

        public XomTarget(XomComponent parent, string xmgmtTargetLine)
        {
            ParentComponent = parent;
            RemoveOnDispose = false;

            // Example:
            // Target: remote               Params: type=remote;address=127.0.0.1;

            // regex would be better
            string[] fields = xmgmtTargetLine.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (fields[0] != "Target:" ||
                fields[2] != "Params:")
            {
                throw new ArgumentException("Bad input: " + xmgmtTargetLine);
            }
            TargetName = fields[1];
            ParamsString = fields[3];

            // @@@ parse params
        }

        public XomTarget(XomComponent parent, string targetName, string targetParams)
        {
            ParentComponent = parent;
            TargetName = targetName;
            ParamsString = targetParams;
        }

        public void Delete()
        {
            string[] lines;
            string cmd = String.Format("e {0}:{1} dt {2}",
                ParentComponent.ProcessId,
                ParentComponent.ComponentName,
                TargetName);
            ParentComponent.ParentServer.Execute(cmd, out lines);
            foreach (string l in lines)
            {
                System.Diagnostics.Debug.WriteLine(l);
            }

            ParentComponent.Targets.Remove(this);
            ParentComponent.Areas.ForEach(a => a.Targets.Remove(this));
        }

        public override string ToString()
        {
            return String.Format("[{0}\\{1}] Target: {2} Params: {3}",
                ParentComponent.ParentServer.ServerName,
                ParentComponent.ComponentName,
                TargetName,
                ParamsString);
        }

        public void Dispose()
        {
            if (RemoveOnDispose)
            {
                Delete();
            }
        }
    }

    internal class XomRemoteListener
    {
        const int c_XomRemoteDefaultPort = 4101;
        private readonly string[] c_Separators = new string[] { ";", "::" };

        private UdpClient _UdpClient;
        private ASCIIEncoding _AsciiEnc = new ASCIIEncoding();
        private List<XomMessageReceivedCallback> _Callbacks;

        //public event XomMessageReceivedCallback OnReceive;

        public XomRemoteListener()
            : this(c_XomRemoteDefaultPort)
        {
        }

        public XomRemoteListener(int port)
        {
            _UdpClient = new UdpClient(port);
            _Callbacks = new List<XomMessageReceivedCallback>();
            BeginNextRequest();
        }

        public IPEndPoint LocalEndPoint
        {
            get { return (_UdpClient.Client.LocalEndPoint as IPEndPoint); }
        }

        internal void AddCallback(XomMessageReceivedCallback callback)
        {
            if (!_Callbacks.Contains(callback))
            {
                _Callbacks.Add(callback);
            }
        }
        
        private void BeginNextRequest()
        {
            IAsyncResult result = _UdpClient.BeginReceive(new AsyncCallback(ListenerCallback), null);
        }

        private void ListenerCallback(IAsyncResult result)
        {
            BeginNextRequest();

            //CallbackData cd = (CallbackData)result.AsyncState;
            IPEndPoint remoteEP = null;
            byte[] recvBuffer;

            recvBuffer = _UdpClient.EndReceive(result, ref remoteEP);

            if (recvBuffer != null && recvBuffer.Length > 0)
            {
                //szProcessName + ";" +
                //szCurrentDomain + ";" +
                //szAssemblyPath + ";" +
                //szThreadHashCode + ";" +
                //area + ";" + szLevel + ";" + msgId + "::" + message );

                string messageString = _AsciiEnc.GetString(recvBuffer);
                string[] fields = messageString.Split(c_Separators, StringSplitOptions.None);
                if (fields.Length < 7)
                {
                    return;
                }

                int doubleColon = messageString.IndexOf("::");
                string payload = "";
                if (doubleColon > -1)
                {
                    payload = messageString.Substring(doubleColon + 2);
                }

                XomRemoteMessage message = new XomRemoteMessage()
                {
                    ProcessName = fields[0],
                    Domain = fields[1],
                    Path = fields[2],
                    ThreadId = fields[3],
                    Area = fields[4],
                    Level = fields[5],
                    MessageId = fields[6],
                    FlowToken = fields.Length > 7 ? fields[7] : null,
                    Message = payload
                };

                _Callbacks.ForEach(func => func(message));
            }
        }

    }

    public delegate void XomMessageReceivedCallback(XomRemoteMessage msg);

    public class XomRemoteMessage
    {
        public string ProcessName;
        public string Domain;
        public string Path;
        public string ThreadId;
        public string Area;
        public string Level;
        public string MessageId;
        public string FlowToken;

        public string Message;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\SysEventId.cs ===
using System;

namespace xonline.server.webcache.common
{
    public class SysEventID
    {
        public class Flags
        {
            /// <summary>
            /// Use this flag if the http response status code is 500
            /// </summary>
            public const uint Error = 0xC0000000;

            /// <summary>
            /// Use this flag if user will see an error message
            /// </summary>
            public const uint Warning = 0x80000000;

            /// <summary>
            /// Use this flag if the failure is completely expected
            /// </summary>
            public const uint Info = 0x40000000;
        }



        /// <summary>
        /// live.xbox.com - 30XXX
        /// </summary>
        public enum LIVE : uint
        {
            /// <summary>
            /// Dev Cause: ?
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            ConsoleReg_MiscFailure              = Flags.Error | 30000,

            /// <summary>
            /// Dev Cause: XML returned from CSS RegDB is invalid
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            ConsoleReg_InvalidOperation         = Flags.Error | 30001,
            
            /// <summary>
            /// Dev Cause: ?
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            ConsoleReg_ApplicationException     = Flags.Error | 30002,

            /// <summary>
            /// Dev Cause: The value supplied is not a valid enum member of Consoles.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            OptionalProfile_InvalidConsoleGet   = Flags.Error | 30003,
            
            /// <summary>
            /// Dev Cause: The value supplied is not a valid enum member of Consoles.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            OptionalProfile_InvalidConsoleSet   = Flags.Error | 30004,
            
            /// <summary>
            /// Dev Cause: The value supplied is not a valid enum member of FavoriteGenreFlag.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            OptionalProfile_InvalidGenreGet     = Flags.Error | 30005,
            
            /// <summary>
            /// Dev Cause: The value supplied is not a valid enum member of FavoriteGenreFlag.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            OptionalProfile_InvalidGenreSet     = Flags.Error | 30006,

            /// <summary>
            /// Dev Cause: failed to generate gamercard feed.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            PublicGamercard_ProcessRequest      = Flags.Error | 30007,



            
        }

        /// <summary>
        /// feeds.xbox.com - 31XXX
        /// </summary>
        public enum FEED : uint
        {
            /// <summary>
            /// Dev Cause: Error when processing rich presence feed request.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            RichPresence                = Flags.Warning | 31000,
        }


        /// <summary>
        /// auth.xbox.com - 32XXX
        /// </summary>
        public enum AUTH : uint
        {
            /// <summary>
            /// Dev Cause: Could not update the footer.
            /// Dev Action: See details in exception.
            /// Ops Action:
            /// </summary>
            //Footer_Update               = Flags.Warning | 32002,

            /// <summary>
            /// Dev Cause: An exception was caught when trying to reset t_exception_registry.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            Exceptions_ErrorReset       = Flags.Error | 32003,

            /// <summary>
            /// Dev Cause: An exception was caught when trying to list exceptions
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            Exceptions_ErrorList        = Flags.Error | 32004,

            /// <summary>
            /// Dev Cause: User's domain account is not allowed to reset the list of exceptions.
            /// Dev Action: 
            /// Ops Action: Determine if the user should be given access to clear the exception list.
            /// </summary>
            Exceptions_ResetDenied      = Flags.Error | 32005,

            /// <summary>
            /// Dev Cause: User's domain account is not allowed to view the list of exceptions.
            /// Dev Action: 
            /// Ops Action: Determine if the user should be given access to see the exception list.
            /// </summary>
            Exceptions_ListDenied       = Flags.Error | 32006,

            /// <summary>
            /// Dev Cause: An exception was caught when trying to reset t_exception_registry.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            Exceptions_ResetOK          = Flags.Info | 32007,

        }


        /// <summary>
        /// www.xbox.com - 33XXX
        /// </summary>
        public enum WWW : uint
        {
            /// <summary>
            /// Dev Cause: No "SiteMode" appSetting specified in web.config. Defaulting to EndUser mode.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            WebConfig_SiteMode          = Flags.Warning | 33000,
            
            /// <summary>
            /// Dev Cause: Value of appSetting "SiteMode" in web.config is not set to a valid value (should be Authoring or EndUser).
            /// Dev Action: 
            /// Ops Action: Bug it.
            /// </summary>
            WebConfig_SiteModeDefault   = Flags.Error | 33001,
            
            /// <summary>
            /// Dev Cause: Exception thrown when loading the search page.
            /// Dev Action: See details in the exception.
            /// Ops Action:
            /// </summary>
            Search_Load                 = Flags.Warning | 33002,
            
            /// <summary>
            /// Dev Cause: Exception thrown when loading page fragment
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            FlexContentServer_Fetch     = Flags.Warning | 33003,

            /// <summary>
            /// Dev Cause: Exception thrown when asking passport for date of birth.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            AgeGate_PassportDOB         = Flags.Warning | 33003,
        }


        /// <summary>
        /// forums.xbox.com - 34XXX
        /// </summary>
        public enum Forums : uint
        {
            /// <summary>
            /// Dev Cause: A new forums administrator has been added through admin/addme.aspx. Intended for initial configuration.
            /// Dev Action: 
            /// Ops Action: This should not happen in production. It's a security alert.
            /// </summary>
            InitForumsAdmin             = Flags.Error | 34000,

            /// <summary>
            /// Dev Cause: The community server user ID in WebTicket is not valid.
            /// Dev Action: 
            /// Ops Action: This should not happen in production. It's a security alert.
            /// </summary>
            InvalidCSUserID             = Flags.Error | 34001,

            /// <summary>
            /// Dev Cause: Creating a new user account in forums database.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            CreateUser                  = Flags.Info | 34002,

            /// <summary>
            /// Dev Cause: Rename user name in forums database, because gamertag has changed.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            RenameUser                  = Flags.Info | 34003,

            /// <summary>
            /// Dev Cause: Delete a user account from forums database, because his passport is no longer linked to a gamertag.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            DeleteUser                  = Flags.Info | 34004,

            /// <summary>
            /// Dev Cause: Two users both claim to have the same gamertag. This should never happen.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            GamertagDispute             = Flags.Error | 34005,
            
            /// <summary>
            /// Dev Cause: A user has subscribed to a thread multiple times.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            DuplicateEmails             = Flags.Error | 34006,

            /// <summary>
            /// Dev Cause: A user has subscribed to a thread multiple times.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            LinkedProfile_Init          = Flags.Error | 34007,
        }

        //
        // reserved - 35XXX, 36XXX, 37XXX, 38XXX, 39XXX
        //


        /// <summary>
        /// lib.dll, not including presentation (LIBP) - 40000 to 41799
        /// </summary>
        public enum LIB : uint
        {
            App_LoggingStarted              = Flags.Info | 40001,
            App_Started                     = Flags.Info | 40002,
            App_Ended                       = Flags.Info | 40003,

            /// <summary>
            /// Dev Cause: This event is logged whenever the global error handler catches
            ///            an exception that doesn't have an event ID associated.
            /// Dev Action:
            /// Ops Action: Try to lookup the signature. Escalate if there's no existing recommendation for the signature.
            /// </summary>
            App_UnassignedException         = Flags.Error | 40005,

            /// <summary>
            /// Dev Cause: An exception occured in the global exception handler while trying to log.
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            App_ExceptionInHandler          = Flags.Error | 40006,
            
            /// <summary>
            /// Dev Cause: HttpContext.Current is not availble in global exception handler.
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            App_NoHttpContext               = Flags.Error | 40007,

            /// <summary>
            /// Dev Cause: Logging being called recursively. Most likely we hit an exception when trying to
            ///            write a previous log entry.
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            Logging_ReEntry                 = Flags.Error | 40020,

            /// <summary>
            /// Dev Cause: Exception while saving to exception registry table.
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            ExceptionReg_CheckPoint         = Flags.Error | 40030,

            /// <summary>
            /// Dev Cause: Exception trying to restart timer
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            ExceptionReg_TimerRestart       = Flags.Error | 40031,

            /// <summary>
            /// Dev Cause: Failed looking up gamertag for given puid from xcache
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            XCache_LookupGamertag           = Flags.Error | 40040,

            /// <summary>
            /// Dev Cause: Failed looking up puid for given gamertag from xcache
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            XCache_LookupPuid               = Flags.Error | 40041,

            /// <summary>
            /// Dev Cause: Thread abort when looking up gamertag for given puid from xcache
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            XCache_LookupGamertagAbort      = Flags.Error | 40042,

            /// <summary>
            /// Dev Cause: Thread abort when looking up puid for given gamertag from xcache
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            XCache_LookupPuidAbort          = Flags.Error | 40043,

            /// <summary>
            /// Dev Cause: The name of the interface in t_livecache_apis table is unknown.
            /// Dev Action: Check if xonline.common.xboxcom.dll is up-to-date.
            /// Ops Action: Check if the entry is correctly spelled in t_livecache_apis table.
            /// </summary>
            LivecacheAPI_InvalidInterface   = Flags.Error | 40050,

            /// <summary>
            /// Dev Cause: Failed when loading livecache service entries from t_livecache_apis table.
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            LivecacheAPI_Load               = Flags.Error | 40051,

            /// <summary>
            /// Dev Cause: Matching EventID not found for the livecache API.
            /// Dev Action: Add missing mapping to GetEventIdMappingTable().
            /// Ops Action:
            /// </summary>
            LivecacheAPI_EventMap           = Flags.Error | 40052,

            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            SqlDep_Loop                     = Flags.Error | 40060,
            
            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            SqlDep_RenewTimer               = Flags.Error | 40061,
            
            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            SqlDep_CheckInterface           = Flags.Error | 40062,

            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            FileScav_Stopped                = Flags.Warning | 40071,
            
            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            FileScav_Execute                = Flags.Warning | 40072,
            
            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            FileScav_ResumeTimer            = Flags.Warning | 40073,

            /// <summary>
            /// Dev Cause: Failed to generate friendly page not found page
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            PageError_NoFriendly404         = Flags.Error | 40081,
            
            /// <summary>
            /// Dev Cause: Response.ClearHeaders throws. This is because we tried to change the response status code after it has already been sent.
            /// Dev Action: If this gets too frequent, try to find out the page and try to buffer response, or detect error conditions early.
            /// Ops Action: Ignore these unless they get more frequent than twice a minute on a single box.
            /// </summary>
            PageError_ClearHeaders          = Flags.Error | 40082,
            
            /// <summary>
            /// Dev Cause: Failed to generate friendly unavailable page
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            PageError_NoFriendly500         = Flags.Error | 40083,

            /// <summary>
            /// Dev Cause: Clearing web ticket. This happens frequently in test environments.
            ///            In production it's unlikely someone would have an old webticket
            ///            when his passport cookies are cleared.
            /// Dev Action:
            /// Ops Action:
            /// </summary>
            SigninMgr_ResetWebTicket        = Flags.Info | 40091,

            /// <summary>
            /// Dev Cause: WebTicket and passport cookies doesn't match. They should have the same passport puid.
            /// Dev Action:
            /// Ops Action: watch for possible attempt to spoof identity
            /// </summary>
            WebTicketMismatch               = Flags.Error | 40094,

            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            SettingBase_Flushed             = Flags.Info | 40100,

            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            PCat_CacheFlushed               = Flags.Info | 40110,

            /// <summary>
            /// Dev Cause: Could not load title information
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            PCat_TitleInfoNotFound          = Flags.Warning | 40111,
            
            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            PCat_DashTitleInfoNotFound      = Flags.Warning | 40112,
            
            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            LookupTitleName                 = Flags.Error | 40120,
            
            /// <summary>
            /// Dev Cause: Error loading tile from storage. May need to create separate event id for throttled hresult.
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            TileImage_Default               = Flags.Error | 40121,
            
            /// <summary>
            /// Dev Cause: The query string of the tile request wasn't properly signed
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            FetchMissingTile_BadSignature   = Flags.Error | 40122,
            
            /// <summary>
            /// Dev Cause: Error reading default tile from /xweb/lib/images
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            FallbackTiles_ReadFile          = Flags.Error | 40123,

            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            FavoriteGenres_GenraNameNotFound = Flags.Error | 40130,

            /// <summary>
            /// Dev Cause: Failed to initialize the performance counter categories in this
            ///            application. This is the initial attempt and will be ignored. 
            ///            However, problems may occur when the counters get used. 
            /// Dev Action: 
            /// Ops Action: Attached to this event should be the reason why it failed.
            ///             If you cannot figure it out, write down the description and 
            ///             contact dev. After correcting the problem, recycling the service 
            ///             is probably a good idea
            /// </summary>
            PerfCounter_InitInstance        = Flags.Error | 40140,

            /// <summary>
            /// Dev Cause: Failed to create performance counter wrapper. The counters
            ///            may have not been installed correctly.
            /// Dev Action: Run InstallUtil.exe on this assembly to reinstall the counters. 
            ///            If that fails, verify if the user account used by the service 
            ///            has enough permissions.
            /// Ops Action:
            /// </summary>
            PerfCounter_InitCategory        = Flags.Error | 40141,

            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            PerfCounter_InitStatic          = Flags.Error | 40142,

            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            MCE_UnknownVersion              = Flags.Error | 40150,
            
        }

        /// <summary>
        /// lib/presentation - 418XX, 419XX
        /// </summary>
        public enum LIBP : uint
        {
            /// <summary>
            /// Dev Cause: Error retrieving athored page fragment for friendly 404 page.
            /// Dev Action: 
            /// Ops Action: Page not authored in that culture?
            /// </summary>
            Friendly404_Load                = Flags.Error | 41801,
            
            /// <summary>
            /// Dev Cause: Error retrieving athored page fragment for friendly 500 page.
            /// Dev Action: 
            /// Ops Action: Page not authored in that culture?
            /// </summary>
            Friendly500_Load                = Flags.Error | 41802,
            
            /// <summary>
            /// Dev Cause: Error retrieving athored page fragment 
            /// Dev Action: 
            /// Ops Action: Page not authored in that culture?
            /// </summary>
            SingleSource_Get                = Flags.Error | 41803,

            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            ShellGamerCard_GetData          = Flags.Error | 41804,
            
            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            ShellGamerCard_Render           = Flags.Error | 41805,
            
            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            ShellGamerCard_WebAlive         = Flags.Error | 41806,
            
            /// <summary>
            /// Dev Cause: 
            /// Dev Action: 
            /// Ops Action:
            /// </summary>
            EnumItemListHelper_Resolve      = Flags.Error | 41807,
        }

        /// <summary>
        /// livecache request: 42XXX
        /// </summary>
        public enum LCR : uint
        {
            Unknown                 = Flags.Error | 42000,
            AcceptFriendRequest     = Flags.Error | 42001,
            AchievementEnum         = Flags.Error | 42002,
            AddFriend               = Flags.Error | 42003,
            CreateXboxComAccount    = Flags.Error | 42004,
            DeleteFriend            = Flags.Error | 42005,
            DeleteMessage           = Flags.Error | 42006,
            EnumerateMessages       = Flags.Error | 42007,
            EnumerateSystemMessages = Flags.Error | 42008,
            EnumTitles              = Flags.Error | 42009,
            GetAccountInfo          = Flags.Error | 42010,
            GetFriends              = Flags.Error | 42011,
            GetLinkedGamertag       = Flags.Error | 42012,
            GetMessageDetails       = Flags.Error | 42013,
            GetMessageSummary       = Flags.Error | 42014,
            GetPresenceInfo         = Flags.Error | 42015,
            GetPublicPresenceInfo   = Flags.Error | 42016,
            GetSystemMessageDetails = Flags.Error | 42017,
            GetUserType             = Flags.Error | 42018,
            GetUserWebInfo          = Flags.Error | 42019,
            LinkWebAccount          = Flags.Error | 42020,
            LivecacheResponse       = Flags.Error | 42021,
            PublicEnumTitles        = Flags.Error | 42022,
            PublicReadSettings      = Flags.Error | 42023,
            QueryAffiliates         = Flags.Error | 42024,
            ReadSettings            = Flags.Error | 42025,
            RejectFriendRequest     = Flags.Error | 42026,
            ReserveName             = Flags.Error | 42027,
            SendMessage             = Flags.Error | 42028,
            SetAccountInfo          = Flags.Error | 42029,
            SetMessageFlags         = Flags.Error | 42030,
            StorageRead             = Flags.Error | 42031,
            StorageRemove           = Flags.Error | 42032,
            StorageWrite            = Flags.Error | 42033,
            StringLookup            = Flags.Error | 42034,
            SyncSettings            = Flags.Error | 42035,
            UpdateXboxComActivity   = Flags.Error | 42036,
            UpsGetProfile           = Flags.Error | 42037,
            UpsUpdateProfile        = Flags.Error | 42038,
            VetString               = Flags.Error | 42039,
            WebAlive                = Flags.Error | 42040,
        }

        //
        // reserved: 43000 to 49999
        //
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\DBHelper.cs ===
using Microsoft.Webstore.WstClient;

using System;
using System.IO;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Net;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

[assembly: XomAreaDefinition(XomAreaName.Reporting_v2)]

namespace xonline.server.webcache.common
{
    public class DBHelper
    {
        public static Hashtable GetTitleInfo()
        {
            // Sql request objects

            SqlConnection sqlCnt = null;
            SqlCommand sqlCmd = null;
            SqlDataReader sqlReader = null;
            Hashtable titles = new Hashtable(64);

            // retrieve the titles
            try
            {
                // Open connection
                sqlCnt = new SqlConnection(ConfigUtil.WebdbConnectionString);
                sqlCnt.Open();

                // Execute stored procedure
                sqlCmd = new SqlCommand("p_wbca_get_title_info", sqlCnt);
                sqlCmd.CommandType = CommandType.StoredProcedure;
                sqlReader = sqlCmd.ExecuteReader();

                // Process result set. Add results into hash table.
                while(sqlReader.Read())
                {
                    TitleInfo title = new TitleInfo();
                    title.TitleID = (uint)sqlReader.GetInt32(0);
                    title.Rating = (ESRBRating)sqlReader.GetByte(1);
                    title.ClusterID = (uint)sqlReader.GetInt32(2);
                    title.DefaultLocale = sqlReader.GetString(3);
                    title.LocalizedName = null;

                    string szLog = "LDTITLE|"
                                + title.TitleID.ToString("X") + "|"
                                + title.Rating + "|"
                                + title.ClusterID + "|"
                                + title.DefaultLocale;

                    Xom.Log(XomAreaName.wcutilitieslog, szLog );
                    Xom.Log(XomAreaName.Reporting_v2, szLog );

                    titles.Add(title.TitleID,title);
                }
            }
            catch(Exception e)
            {
                if(sqlCnt != null)
                {
                    sqlCnt.Close();
                    sqlCnt = null;
                }

                IInterfaceInfo webdbInfo = Config.GetSingleInterface(Interface.webdb);
                throw new WebDBAccessException("p_wbca_get_title_info", webdbInfo.IPAddressString, webdbInfo.DBName, e);
            }
            finally
            {
                // Release Sql objects
                if(sqlReader != null)
                {
                    sqlReader.Close();
                    sqlReader = null;
                }
            }

            // retrieve the localized title names
            try
            {
                uint currentTitleID;

                // temporary results array
                ArrayList nameList = new ArrayList(64);

                // Execute stored procedure
                sqlCmd = new SqlCommand("p_wbca_get_title_name_info", sqlCnt);
                sqlCmd.CommandType = CommandType.StoredProcedure;
                sqlReader = sqlCmd.ExecuteReader();

                // Process result set. Store results in array. Assume rows are sorted by title ID
                currentTitleID = 0;
                while(sqlReader.Read())
                {
                    LocalizedDisplayName titleName;
                    if (currentTitleID != (uint)sqlReader.GetInt32(0))
                    {
                        if (currentTitleID != 0)
                        {
                            (titles[currentTitleID] as TitleInfo).LocalizedName = (LocalizedDisplayName[]) nameList.ToArray(typeof(LocalizedDisplayName));
                        }
                        nameList.Clear();
                        currentTitleID = (uint)sqlReader.GetInt32(0);
                        if (titles[currentTitleID] == null)
                        {
                            throw new Exception(string.Format("Title {0} in t_title_name_info not found in t_title_info",currentTitleID.ToString("X8")));
                        }
                    }
                    titleName.Locale = sqlReader.GetString(1);
                    titleName.DisplayName = sqlReader.GetString(2);

                    nameList.Add(titleName);
                }
                if (currentTitleID != 0)
                {
                    (titles[currentTitleID] as TitleInfo).LocalizedName = (LocalizedDisplayName[]) nameList.ToArray(typeof(LocalizedDisplayName));
                }
            }
            catch(Exception e)
            {
                IInterfaceInfo webdbInfo = Config.GetSingleInterface(Interface.webdb);
                throw new WebDBAccessException("p_wbca_get_title_name_info", webdbInfo.IPAddressString, webdbInfo.DBName, e);
            }
            finally
            {
                // Release Sql objects

                if(sqlReader != null)
                {
                    sqlReader.Close();
                    sqlReader = null;
                }

                if(sqlCnt != null)
                {
                    sqlCnt.Close();
                    sqlCnt = null;
                }
            }

            return titles;
        }

        public static Hashtable GetPartnerInfo()
        {
            // Sql request objects

            SqlConnection sqlCnt = null;
            SqlCommand sqlCmd = null;
            SqlDataReader sqlReader = null;
            Hashtable partners = new Hashtable(32);

            // retrieve the partners
            try
            {
                // Open connection
                sqlCnt = new SqlConnection(ConfigUtil.WebdbConnectionString);
                sqlCnt.Open();

                // Execute stored procedure
                sqlCmd = new SqlCommand("p_wbca_get_partner_info", sqlCnt);
                sqlCmd.CommandType = CommandType.StoredProcedure;
                sqlReader = sqlCmd.ExecuteReader();

                // Process result set. Add results into hash table.
                while(sqlReader.Read())
                {
                    PartnerInfo partner = new PartnerInfo();
                    partner.PartnerID = (uint)sqlReader.GetInt32(0);
                    partner.PartnerGroupID = (uint)sqlReader.GetInt32(1);
                    partner.SubjectName = sqlReader.GetString(2);
                    partner.CredentialType = (uint)sqlReader.GetInt32(3);
                    partner.Description = sqlReader.GetString(4);
                    partner.AllowedAPIs = new string[0];
                    partner.TitlePrivileges = new PartnerTitlePrivilegeInfo[0];
                    partner.ValidIPs = new PartnerIPInfo[0];

                    string szLog = "LDPARTNER|"
                                + partner.PartnerID.ToString("X") + "|"
                                + partner.PartnerGroupID.ToString("X") + "|"
                                + partner.SubjectName + "|"
                                + partner.CredentialType;

                    Xom.Log(XomAreaName.wcutilitieslog, szLog );
                    Xom.Log(XomAreaName.Reporting_v2, szLog );

                    partners.Add(partner.PartnerID,partner);
                }
            }
            catch(Exception e)
            {
                if(sqlCnt != null)
                {
                    sqlCnt.Close();
                    sqlCnt = null;
                }

                IInterfaceInfo webdbInfo = Config.GetSingleInterface(Interface.webdb);
                throw new WebDBAccessException("p_wbca_get_partner_info", webdbInfo.IPAddressString, webdbInfo.DBName, e);
            }
            finally
            {
                // Release Sql objects
                if(sqlReader != null)
                {
                    sqlReader.Close();
                    sqlReader = null;
                }
            }

            // retrieve the partner allowed titles
            try
            {
                uint currentPartnerID;

                // temporary results array
                ArrayList tempList = new ArrayList(64);

                // Execute stored procedure
                sqlCmd = new SqlCommand("p_wbca_get_partner_allowed_titles", sqlCnt);
                sqlCmd.CommandType = CommandType.StoredProcedure;
                sqlReader = sqlCmd.ExecuteReader();

                // Process result set. Store results in array. Assume rows are sorted by title ID
                currentPartnerID = 0;
                while(sqlReader.Read())
                {
                    PartnerTitlePrivilegeInfo titlePrivilege;
                    if (currentPartnerID != (uint)sqlReader.GetInt32(0))
                    {
                        if (currentPartnerID != 0)
                        {
                            (partners[currentPartnerID] as PartnerInfo).TitlePrivileges = (PartnerTitlePrivilegeInfo[]) tempList.ToArray(typeof(PartnerTitlePrivilegeInfo));
                        }
                        tempList.Clear();
                        currentPartnerID = (uint)sqlReader.GetInt32(0);
                        if (partners[currentPartnerID] == null)
                        {
                            throw new Exception(string.Format("Partner {0} in t_partner_allowed_titles not found in t_partners",currentPartnerID.ToString("X8")));
                        }
                    }
                    titlePrivilege.TitleID = (uint)sqlReader.GetInt32(1);
                    titlePrivilege.Privileges = (TitlePrivilege)sqlReader.GetInt32(2);

                    tempList.Add(titlePrivilege);
                }
                if (currentPartnerID != 0)
                {
                    (partners[currentPartnerID] as PartnerInfo).TitlePrivileges = (PartnerTitlePrivilegeInfo[]) tempList.ToArray(typeof(PartnerTitlePrivilegeInfo));
                }
            }
            catch(Exception e)
            {
                if(sqlCnt != null)
                {
                    sqlCnt.Close();
                    sqlCnt = null;
                }

                IInterfaceInfo webdbInfo = Config.GetSingleInterface(Interface.webdb);
                throw new WebDBAccessException("p_wbca_get_partner_allowed_titles", webdbInfo.IPAddressString, webdbInfo.DBName, e);
            }
            finally
            {
                // Release Sql objects

                if(sqlReader != null)
                {
                    sqlReader.Close();
                    sqlReader = null;
                }
            }

            // retrieve the partner allowed apis
            try
            {
                uint currentPartnerID;

                // temporary results array
                ArrayList tempList = new ArrayList(64);

                // Execute stored procedure
                sqlCmd = new SqlCommand("p_wbca_get_partner_allowed_apis", sqlCnt);
                sqlCmd.CommandType = CommandType.StoredProcedure;
                sqlReader = sqlCmd.ExecuteReader();

                // Process result set. Store results in array. Assume rows are sorted by title ID
                currentPartnerID = 0;
                while(sqlReader.Read())
                {
                    if (currentPartnerID != (uint)sqlReader.GetInt32(0))
                    {
                        if (currentPartnerID != 0)
                        {
                            (partners[currentPartnerID] as PartnerInfo).AllowedAPIs = (string[]) tempList.ToArray(typeof(string));
                        }
                        tempList.Clear();
                        currentPartnerID = (uint)sqlReader.GetInt32(0);
                        if (partners[currentPartnerID] == null)
                        {
                            throw new Exception(string.Format("Partner {0} in t_partner_allowed_apis not found in t_partners",currentPartnerID.ToString("X8")));
                        }
                    }

                    tempList.Add(sqlReader.GetString(1));
                }
                if (currentPartnerID != 0)
                {
                    (partners[currentPartnerID] as PartnerInfo).AllowedAPIs = (string[]) tempList.ToArray(typeof(string));
                }
            }
            catch(Exception e)
            {
                if(sqlCnt != null)
                {
                    sqlCnt.Close();
                    sqlCnt = null;
                }

                IInterfaceInfo webdbInfo = Config.GetSingleInterface(Interface.webdb);
                throw new WebDBAccessException("p_wbca_get_partner_allowed_apis", webdbInfo.IPAddressString, webdbInfo.DBName, e);
            }
            finally
            {
                // Release Sql objects

                if(sqlReader != null)
                {
                    sqlReader.Close();
                    sqlReader = null;
                }
            }

            // retrieve the partner allowed ips
            try
            {
                uint currentPartnerID;

                // temporary results array
                ArrayList tempList = new ArrayList(64);

                // Execute stored procedure
                sqlCmd = new SqlCommand("p_wbca_get_partner_ips", sqlCnt);
                sqlCmd.CommandType = CommandType.StoredProcedure;
                sqlReader = sqlCmd.ExecuteReader();

                // Process result set. Store results in array. Assume rows are sorted by title ID
                currentPartnerID = 0;
                while(sqlReader.Read())
                {
                    PartnerIPInfo ipInfo;
                    if (currentPartnerID != (uint)sqlReader.GetInt32(0))
                    {
                        if (currentPartnerID != 0)
                        {
                            (partners[currentPartnerID] as PartnerInfo).ValidIPs = (PartnerIPInfo[]) tempList.ToArray(typeof(PartnerIPInfo));
                        }
                        tempList.Clear();
                        currentPartnerID = (uint)sqlReader.GetInt32(0);
                        if (partners[currentPartnerID] == null)
                        {
                            throw new Exception(string.Format("Partner {0} in t_partner_ips not found in t_partners",currentPartnerID.ToString("X8")));
                        }
                    }
                    ipInfo.IP = (uint)sqlReader.GetInt32(1);
                    ipInfo.Mask = (uint)sqlReader.GetInt32(2);

                    tempList.Add(ipInfo);
                }
                if (currentPartnerID != 0)
                {
                    (partners[currentPartnerID] as PartnerInfo).ValidIPs = (PartnerIPInfo[]) tempList.ToArray(typeof(PartnerIPInfo));
                }
            }
            catch(Exception e)
            {
                IInterfaceInfo webdbInfo = Config.GetSingleInterface(Interface.webdb);
                throw new WebDBAccessException("p_wbca_get_partner_ips", webdbInfo.IPAddressString, webdbInfo.DBName, e);
            }
            finally
            {
                // Release Sql objects

                if(sqlReader != null)
                {
                    sqlReader.Close();
                    sqlReader = null;
                }

                if(sqlCnt != null)
                {
                    sqlCnt.Close();
                    sqlCnt = null;
                }
            }

            return partners;
        }

        public static bool SetInfoSharing( ulong PUID, bool acceptMSInfo, bool acceptPartnerInfo )
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            int dbResult = 0;
            bool result = false;
            IVirtualInterfaceInfo uodbInfo = Config.GetVirtualInterface(VirtualInterface.uodb, 1);

            try
            {
                // Open a connection
                conn = new WstConnection(uodbInfo.WebstoreApp);
                conn.Open();

                // Create a command to call the stored procedure
                cmd = conn.CreateCommand();
                cmd.CommandTimeout = uodbInfo.Timeout;
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_wbca_modify_user_infosharing";

                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WSClient.GetHashPartition( PUID, uodbInfo.WebstoreApp );

                cmd.Parameters.Add(new SqlParameter( "?", SqlDbType.Int, 4, ParameterDirection.ReturnValue,
                                    true, 0, 0, "?", DataRowVersion.Current, 0 ) );

                // add the params
                cmd.Parameters.Add("@bi_user_puid", SqlDbType.BigInt).Value = PUID;
                cmd.Parameters.Add("@f_ms_opt_in", SqlDbType.TinyInt).Value = acceptMSInfo;
                cmd.Parameters.Add("@f_partner_opt_in", SqlDbType.TinyInt).Value = acceptPartnerInfo;

                // Execute stored procedure
                cmd.ExecuteNonQuery();

                // read the params ... find the result.
                dbResult = (int)(cmd.Parameters["?"].Value);

                // we should have only modified one row.
                if ( dbResult == 0 )
                {
                    result = true;
                }

            }
            catch( Exception e )
            {
                throw new ProfileAccessException("p_wbca_modify_user_infosharing", e);
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }
            }

            return result;
        }


        public static bool GetInfoSharing( ulong PUID, ref bool acceptMSInfo, ref bool acceptPartnerInfo )
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader wstReader = null;
            bool result = false;
            IVirtualInterfaceInfo uodbInfo = Config.GetVirtualInterface(VirtualInterface.uodb, 1);

            try
            {
                // Open a connection
                conn = new WstConnection(uodbInfo.WebstoreApp);
                conn.Open();

                // Create a command to call the stored procedure
                cmd = conn.CreateCommand();
                cmd.CommandTimeout = uodbInfo.Timeout;
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_wbca_get_user_infosharing";

                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WSClient.GetHashPartition( PUID, uodbInfo.WebstoreApp );

                // add the params
                cmd.Parameters.Add("@bi_user_puid", SqlDbType.BigInt).Value = PUID;

                // Execute stored procedure
                wstReader = cmd.ExecuteReader();

                // read the first row only.
                if ( wstReader.Read() )
                {
                    acceptMSInfo = wstReader.GetByte(0) != 0;
                    acceptPartnerInfo = wstReader.GetByte(1) != 0;
                    result = true;
                }

            }
            catch( Exception e )
            {
                throw new ProfileAccessException("p_wbca_get_user_infosharing", e);
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;

                }
                if ( wstReader != null )
                {
                    wstReader.Close();
                    wstReader = null;
                }
            }

            return result;
        }


        public static bool GetAccountStatus( ulong PUID, ref int flags, ref bool accountSuspended, ref DateTime resume_date, ref bool voiceBanned, ref DateTime voiceban_date, ref bool name_change_required )
        {
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader wstReader = null;
            bool result = false;
            IVirtualInterfaceInfo uodbInfo = Config.GetVirtualInterface(VirtualInterface.uodb, 1);

            try
            {
                // Open a connection
                conn = new WstConnection(uodbInfo.WebstoreApp);
                conn.Open();

                // Create a command to call the stored procedure
                cmd = conn.CreateCommand();
                cmd.CommandTimeout = uodbInfo.Timeout;
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_wbca_get_account_status";

                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WSClient.GetHashPartition( PUID, uodbInfo.WebstoreApp );

                // add the params
                cmd.Parameters.Add("@bi_user_puid", SqlDbType.BigInt).Value = PUID;

                // Execute stored procedure
                wstReader = cmd.ExecuteReader();

                // read the first row only.
                if ( wstReader.Read() )
                {
                    // read the row.
                    flags = (int)(wstReader.GetInt16( 0 ));
                    accountSuspended = (bool)( wstReader.GetInt32( 1 ) != 0 );
                    resume_date = wstReader.GetDateTime( 2 );
                    voiceBanned = (bool)( wstReader.GetInt32( 3 ) != 0 );
                    voiceban_date = wstReader.GetDateTime( 4 );
                    name_change_required = (bool)( wstReader.GetByte( 5 ) != (byte)0 );
                    result = true;
                }


            }
            catch( Exception e )
            {
                throw new UODBAccessException("p_wbca_get_account_status", e);
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }
                if ( wstReader != null )
                {
                    wstReader.Close();
                    wstReader = null;
                }
            }

            return result;
        }

        public static HResult GetUserAuthorization( ulong userPuid, uint titleId, out bool acceptedTermsOfService, out bool isVoiceBanned, out bool isSuspended, out bool[] privileges, out uint[] services )
        {
            // some fanciness to deal with changes in the KDC  sprocs
            // really get user authorization needs to move  to  XUser

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@i_title_id", titleId);
                ws.StoredProc = "dbo.p_signin_get_user_authorization_autodiscover";
                ws.AddParameter("@i_platform_type", XOn.XPLT_XBOX360);

                privileges = new bool[256];
                ArrayList serviceList = new ArrayList();

                using (WstDataReader rdr = ws.Execute())
                {
                    if (rdr.Read() == false)
                    {
                        throw new XboxWebExceptionNoEvent(ws.StoredProc + " failed to return userdata rowset for user: 0x" + userPuid.ToString("x"));
                    }

                    acceptedTermsOfService = (rdr.GetInt32(rdr.GetOrdinal("i_accepted_tos")) != 0);
                    isVoiceBanned = (rdr.GetInt32(rdr.GetOrdinal("i_voice_banned")) != 0);
                    isSuspended = (rdr.GetInt32(rdr.GetOrdinal("i_acct_suspened")) != 0);

                    if (rdr.NextResult() == false)
                    {
                        throw new XboxWebExceptionNoEvent(ws.StoredProc + " failed to return privileges rowset for user: 0x" + userPuid.ToString("x"));
                    }

                    // the second result set contains services.  if we are  in
                    // backward compatibility mode it also contains privileges
                    
                    while (rdr.Read())
                    {
                        int subscriptionStatusId = rdr.GetInt32(1);
                        if (subscriptionStatusId != 1) continue;

                        int serviceId = rdr.GetInt32(0);

                        if (serviceId >= 0 && serviceId <= 255)
                            privileges[serviceId] = true;
                        else {
                            serviceList.Add((uint) serviceId);
                        }
                    }

                    // there is an extra result set with just  privileges in it
                    if (rdr.NextResult()) 
                    {
                        while (rdr.Read()) 
                        {
                            byte privilegeId = rdr.GetByte(0);
                            privileges[privilegeId] = true;
                        }
                    }

                    services = (uint[])serviceList.ToArray(typeof(uint));
                    rdr.Close();
                }
            }

            return HResult.S_OK;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\Utilities.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Net;
using System.Web.Caching;
using System.Threading;
using System.Security.Principal;
using System.IO;
using System.Security.Cryptography;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.wcutilitiestrace)]
[assembly: XomAreaDefinition(XomAreaName.wcutilitieslog)]

namespace xonline.server.webcache.common
{
    public enum CredentialType { Passport = 1 }

    public enum TitlePrivilege: byte { None = 0, ReadOnly = 1, ReadWrite = 3, FullControl = 7 };

    public enum ESRBRating : byte { ALL = 0, ADULT, MATURE, TEEN, EVERYONE, KIDS_TO_ADULTS, EARLY_CHILDHOOD, UNSPECIFIED };

    public enum FileContentTypeEnum
    {
        Package,
        Blob
    }

    public struct LocalizedDisplayName
    {
        public string Locale;
        public string DisplayName;
    }

    public class TitleInfo
    {
        public uint TitleID;
        public ESRBRating Rating;
        public uint ClusterID;
        public string DefaultLocale;
        public LocalizedDisplayName[] LocalizedName;
    }

    public struct TitlePrivilegeInfo
    {
        public uint TitleID;
        public TitlePrivilege Privileges;
        public ESRBRating Rating;
        public string DefaultLocale;
        public LocalizedDisplayName[] LocalizedName;
    }

    public struct PartnerTitlePrivilegeInfo
    {
        public uint TitleID;
        public TitlePrivilege Privileges;
    }

    public struct PartnerIPInfo
    {
        public uint IP;
        public uint Mask;
    }

    public class PartnerInfo
    {
        public string SubjectName;
        public uint PartnerID;
        public uint PartnerGroupID;
        public uint CredentialType;
        public string Description;
        public string[] AllowedAPIs;
        public PartnerTitlePrivilegeInfo[] TitlePrivileges;
        public PartnerIPInfo[] ValidIPs;
    }

    //
    // Internal exceptions
    //

    internal class WebDBAccessException : XboxWebInternalException
    {
        public WebDBAccessException(string proc, string server, string db, Exception e)
            : base(XEvent.Id.WEBCACHE_COMM_0,
                   String.Format(  "Request ({0}) to WebDB failed. "
                                 + "Server={1}; Db={2}", proc, server, db),
                   e)
        {
        }
    }

    internal class UODBAccessException : XboxWebInternalException
    {
        public UODBAccessException(string proc, Exception e)
            : base(XEvent.Id.WEBCACHE_COMM_1,
                   String.Format("Request ({0}) to UODB failed. ", proc), e)
        {
        }
    }

    internal class ProfileAccessException : XboxWebInternalException
    {
        public ProfileAccessException(string proc, Exception e)
            : base(XEvent.Id.WEBCACHE_COMM_2,
                   String.Format("Xprofile Request ({0}) to UODB failed. ", proc), e)
        {
        }
    }

   internal class ToolsDBAccessException : XboxWebInternalException
    {
        public ToolsDBAccessException(string proc, string connectionString, Exception e)
            : base(XEvent.Id.WEBCACHE_COMM_3,
            String.Format(  "Request ({0}) to ToolsDB failed. Connection string={1}", proc, connectionString),
            e)
        {
        }
    }

    internal class WebSGErrorException : XboxWebInternalException
    {
        public WebSGErrorException(string message) : base(XEvent.Id.WEBCACHE_WEBSG_ERROR, message)
        {
        }
    }

    internal class FrontDoorException : XboxWebInternalException, ExceptionWithHResult
    {
        string _url;

        public FrontDoorException(string url, HResult hresult) : base(XEvent.Id.WEBCACHE_FRONT_DOOR_ERROR, "Front door URL " + url)
        {
            _url = url;
            HResult = hresult;
        }

        public FrontDoorException(string url, HResult hresult, Exception innerException) : base(XEvent.Id.WEBCACHE_FRONT_DOOR_ERROR_1, "Front door URL " + url, innerException)
        {
            _url = url;
            HResult = hresult;
        }

        public FrontDoorException(string url, HResult hresult, byte[] postData) : base(XEvent.Id.WEBCACHE_FRONT_DOOR_ERROR_2, "Front door URL " + url + " returned hr = " + hresult.ToString() + " Post data:" + ByteConvert.ToString(postData))
        {
            _url = url;
            HResult = hresult;
        }

        public FrontDoorException(string url, HResult hresult, byte[] postData, Exception innerException) : base(XEvent.Id.WEBCACHE_FRONT_DOOR_ERROR_3, "Front door URL " + url + " returned hr = " + hresult.ToString() + " Post data:" + ByteConvert.ToString(postData), innerException)
        {
            _url = url;
            HResult = hresult;
        }

        public string URL
        {
            get { return _url; }
        }

        new public HResult HResult
        {
            get { return (HResult) (uint) base.HResult; }
            set { base.HResult = (int) (uint) value; }
        }
    }

    internal class FrontDoorInternalException : XboxWebInternalException, ExceptionWithHResult
    {
        string  _url;

        public FrontDoorInternalException(string url, HResult hresult) : base(XEvent.Id.WEBCACHE_FRONT_DOOR_INTERNAL_ERROR, "Front door URL " + url + " returned HTTP 500 hr = " + hresult.ToString())
        {
            _url = url;
            HResult = hresult;
        }

        public FrontDoorInternalException(string url, HResult hresult, Exception innerException) : base(XEvent.Id.WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_1, "Front door URL " + url + " returned HTTP 500 hr = " + hresult.ToString(), innerException)
        {
            _url = url;
            HResult = hresult;
        }

        public FrontDoorInternalException(string url, HResult hresult, byte[] postData) : base(XEvent.Id.WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_2, "Front door URL " + url + " returned HTTP 500 hr = " + hresult.ToString() + " Post data:" + ByteConvert.ToString(postData))
        {
            _url = url;
            HResult = hresult;
        }

        public FrontDoorInternalException(string url, HResult hresult, byte[] postData, Exception innerException) : base(XEvent.Id.WEBCACHE_FRONT_DOOR_INTERNAL_ERROR_3, "Front door URL " + url + " returned HTTP 500 HR:" + hresult.ToString() + " Post data:" + ByteConvert.ToString(postData), innerException)
        {
            _url = url;
            HResult = hresult;
        }

        public string URL
        {
            get { return _url; }
        }

        new public HResult HResult
        {
            get { return (HResult) (uint) base.HResult; }
            set { base.HResult = (int) (uint) value; }
        }
    }

    internal class FrontDoorNonFatalException : Exception, ExceptionWithHResult, ExceptionWithoutEvent
    {
        public FrontDoorNonFatalException(HResult hresult)
        {
            HResult = hresult;
        }

        new public HResult HResult
        {
            get { return (HResult) (uint) base.HResult; }
            set { base.HResult = (int) (uint) value; }
        }
    }

    //
    // External exceptions
    //

    internal class PartnerBadRequestException : XboxWebException
    {
        public PartnerBadRequestException(string message) : base(XEvent.Id.WEBCACHE_BAD_REQUEST_FROM_PARTNER, message)
        {
        }
    }

    internal class PartnerNotFoundException : XboxWebException
    {
        public PartnerNotFoundException(string subjectName) : base(XEvent.Id.WEBCACHE_PARTNER_NOT_FOUND_ERROR, "Partner not found: "+subjectName)
        {
        }

        public PartnerNotFoundException(string subjectName, Exception innerException) : base(XEvent.Id.WEBCACHE_PARTNER_NOT_FOUND_ERROR_1, "Partner not found: "+subjectName, innerException)
        {
        }
    }

    internal class APINotAllowedException : XboxWebException
    {
        public APINotAllowedException(string subjectName, string api) : base(XEvent.Id.WEBCACHE_API_NOT_ALLOWED_ERROR, "Partner:"+subjectName+" not allowed to call API:"+api)
        {
        }

        public APINotAllowedException(string subjectName, string api, Exception innerException) : base(XEvent.Id.WEBCACHE_API_NOT_ALLOWED_ERROR_1, "Partner:"+subjectName+" not allowed to call API:"+api, innerException)
        {
        }
    }

    internal class TitleNotAllowedException : XboxWebExceptionNoEvent
    {
        public TitleNotAllowedException(string subjectName, uint titleID) : base("Partner:"+subjectName+" not allowed to access TitleID:" + titleID.ToString("X8"))
        {
        }

        public TitleNotAllowedException(string subjectName, uint titleID, Exception innerException) : base("Partner:"+subjectName+" not allowed to access TitleID:" + titleID.ToString("X8"), innerException)
        {
        }
    }

    internal class InvalidIPException : XboxWebException
    {
        public InvalidIPException(string subjectName, string ip) : base(XEvent.Id.WEBCACHE_INVALID_IP_ERROR, "Partner:"+subjectName+" called from invalid IP: "+ip)
        {
        }

        public InvalidIPException(string subjectName, string ip, Exception innerException) : base(XEvent.Id.WEBCACHE_INVALID_IP_ERROR_1, "Partner:"+subjectName+" called from invalid IP: "+ip, innerException)
        {
        }
    }

    internal class ServiceNotReadyException : XboxWebExceptionNoEvent
    {
        public ServiceNotReadyException() : base("Web Service not ready yet. Please try again later.")
        {
        }
    }

    public struct CredTypeAndWebID
    {
        public CredTypeAndWebID(uint CredType, byte[] WebID)
        {
            _CredType = CredType;
            if (_CredType == (uint)CredentialType.Passport)
            {
                if (null == WebID)
                {
                    throw new PartnerBadRequestException("Bad Passport web ID, null not allowed");
                }
                else if (WebID.Length != 8)
                {
                    throw new PartnerBadRequestException("Bad Passport web ID, length is "+WebID.Length);
                }
                BinaryReader r = new BinaryReader(new MemoryStream(WebID));
                _PUID = r.ReadUInt64();
                _WebID = null;
            }
            else
            {
                _PUID = 0;
                _WebID = WebID;
            }
        }

        public bool IsPassport
        {
            get { return _CredType == (uint)CredentialType.Passport; }
        }

        public uint CredType
        {
            get { return _CredType; }
        }

        public ulong PUID
        {
            get { return _PUID; }
        }

        public byte[] WebID
        {
            get { return _WebID; }
        }

        public override int GetHashCode()
        {
            ulong hashCode;
            if (IsPassport)
            {
                hashCode = ((_PUID * 1718205583) + _CredType);
            }
            else
            {
                hashCode = (ulong) _CredType;
                for(int i = 0; i < _WebID.Length; i++)
                {
                    // 1718205583 is prime
                    hashCode = hashCode * 1718205583 + _WebID[i];
                }
            }
            return ((int)(hashCode)) ^ ((int)(hashCode >> 32));
        }

        uint _CredType;
        ulong _PUID;
        byte[] _WebID;
    }

    public struct CredTypeAndPUID
    {
        public CredTypeAndPUID(uint CredType, ulong PUID)
        {
            _CredType = CredType;
            _PUID = PUID;
        }

        public uint CredType
        {
            get { return _CredType; }
        }

        public ulong PUID
        {
            get { return _PUID; }
        }

        public override int GetHashCode()
        {
            ulong val = ((_PUID * 1718205583) + _CredType);
            return ((int)(val)) ^ ((int)(val >> 32));
        }

        uint _CredType;
        ulong _PUID;
    }

    public struct WebIDs
    {
        public WebIDs(byte[] _OwnerWebID, byte[] _GamerWebID)
        {
            OwnerWebID = _OwnerWebID;
            GamerWebID = _GamerWebID;
        }

        public bool Equals(byte[] owner, byte[] gamer)
        {
            return WebIDs.IDEquals(OwnerWebID, owner) && WebIDs.IDEquals(GamerWebID, gamer);
        }

        public static bool IDEquals(byte[] id1, byte[] id2)
        {
            if ((object)id1 == (object)id2)         // references are identical
                return true;
            else if (id1 == null || id2 == null)    // one is null, but the other isn't
                return false;
            else
                return ByteArray.Equals(id1, id2);  // neither is null, compare the bytes
        }

        public byte[] OwnerWebID;
        public byte[] GamerWebID;
    }

    public class Utilities
    {
        //
        // Construction
        //
#if DEBUG
        public Utilities()
#else
        private Utilities()
#endif
        {
            Initialize();
        }

        public static Utilities Instance
        {
            get
            {
                if ( !_fInitialized )
                {
                    lock(_lockInit)
                    {
                        if ( !_fInitialized )
                        {
                            instance = new Utilities();
                            _fInitialized = true;
                        }
                    }
                }
                return instance;
            }
        }

        private static Utilities instance = null;
        private static volatile bool _fInitialized = false;
        private static object _lockInit = new object();

        public WindowsIdentity ImpersonationId
        {
            get
            {
                return windowsIdentity;
            }
        }

        WindowsIdentity windowsIdentity = null;
        Mgmt            mgmt            = null;

        // All known titles keyed by titleID uint
        Hashtable titles = null;

        // All known partners keyed by partnerID uint
        Hashtable partnersByID = null;
        // All known partners keyed by subjectName string
        Hashtable partnersBySubjectName = null;

        void Initialize()
        {
            mgmt = new Mgmt(this, "Web Cache Utilities");
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(Utilities.OnControlRequest);

            windowsIdentity = WindowsIdentity.GetCurrent();

            try
            {
                LoadTitles();

                LoadPartners();
            }
            catch (XboxWebException)
            {
                // Something is wrong with the DB at this point. Events have already been fired.
                // Do nothing for now and let future calls retry the DB request to fix the problem.
            }
        }

        private void LoadTitles()
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            titles = DBHelper.GetTitleInfo();
            ctx.Undo();


        }

        private void LoadPartners()
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            Hashtable tempPartnersByID = DBHelper.GetPartnerInfo();
            if (tempPartnersByID != null)
            {
                Hashtable tempPartnersBySubjectName = new Hashtable(tempPartnersByID.Count * 2);

                IDictionaryEnumerator myEnumerator = tempPartnersByID.GetEnumerator();
                while ( myEnumerator.MoveNext() )
                {
                    PartnerInfo partner = (PartnerInfo) myEnumerator.Value;
                    tempPartnersBySubjectName.Add(partner.SubjectName,partner);
                }

                partnersByID = tempPartnersByID;
                partnersBySubjectName = tempPartnersBySubjectName;
            }

            ctx.Undo();
        }

        // key used to access performance counters to be incremented on errors
        const string REQUEST_INFO = "RequestInfo";

        public static RequestInfo GetRequestInfo()
        {
            if (HttpContext.Current == null || HttpContext.Current.Items == null)
                return null;
            else
                return (RequestInfo)HttpContext.Current.Items[REQUEST_INFO];
        }

        public class RequestInfo
        {
            public RequestInfo(string API)
            {
                SubjectName = HttpContext.Current.Request.Headers[XHttpHdr.SUBJECTNAME];
                if (SubjectName == null)
                {
                    Xom.Trace(XomAreaName.wcutilitiestrace, LogLevel.L_ERROR, "InternalException: SubjectName missing in HTTP Header from Web SG");
#if DEBUG
                    SubjectName = "DebugPartner";
#else
                    throw new WebSGErrorException("SubjectName missing in HTTP Header from Web SG");
#endif
                }
                ClientIPPort = HttpContext.Current.Request.Headers[XHttpHdr.CLIENTIPPORT];
                if (ClientIPPort == null)
                {
                    Xom.Trace(XomAreaName.wcutilitiestrace, LogLevel.L_ERROR, "InternalException: ClientIPPort missing in HTTP Header from Web SG");
#if DEBUG
                    ClientIPPort = "1.1.1.1:1000";
#else
                    throw new WebSGErrorException("ClientIPPort missing in HTTP Header from Web SG");
#endif
                }
                RequestID = HttpContext.Current.Request.Headers[XHttpHdr.REQUESTID];
                if (RequestID == null)
                {
                    Xom.Trace(XomAreaName.wcutilitiestrace, LogLevel.L_ERROR, "InternalException: RequestID missing in HTTP Header from Web SG");
#if DEBUG
                    RequestID = "CAFEBABEDEADBEEF";
#else
                    throw new WebSGErrorException("RequestID missing in HTTP Header from Web SG");
#endif
                }

                try
                {
                    int indexOfColon = ClientIPPort.IndexOf(':');
                    if (indexOfColon > 0)
                    {
                        byte[] addr = IPAddress.Parse(ClientIPPort.Substring(0,indexOfColon)).GetAddressBytes();
                        ClientIP = ((uint)addr[0]) + ((uint)addr[1] << 8) + ((uint)addr[2] << 16) + ((uint)addr[3] << 24);
                        ClientPort = UInt16.Parse(ClientIPPort.Substring(indexOfColon+1));
                    }
                    else
                    {
                        throw new Exception();
                    }
                }
                catch
                {
                    throw new WebSGErrorException("Client-IP-Port in HTTP Header malformed: "+ClientIPPort);
                }

                try
                {
                    qwRequestID = Convert.ToUInt64(RequestID,16);
                }
                catch
                {
                    throw new WebSGErrorException("RequestID in HTTP Header malformed for hexadecimal UInt64: "+RequestID);
                }

                APIName = API;
                Title = null;
                PrivilegeRequired = 0;
            }
            public PartnerInfo Partner;
            public string APIName;
            public TitleInfo Title;
            public TitlePrivilege PrivilegeRequired;
            public string RequestID;
            public string ClientIPPort;
            public string SubjectName;
            public ulong qwRequestID;
            public uint ClientIP;
            public ushort ClientPort;
        }

        // Uses HTTPContext to retrieve header info about SubjectName
        public void CheckAPI(string APIName)
        {
            if (titles == null)
            {
                LoadTitles();
            }

            if (partnersBySubjectName == null)
            {
                LoadPartners();
            }

            RequestInfo requestInfo = new RequestInfo(APIName);

            requestInfo.Partner = LookupPartner(requestInfo.SubjectName);
            if (requestInfo.Partner == null)
            {
                Xom.Trace(XomAreaName.wcutilitiestrace, LogLevel.L_ERROR, "PartnerNotFoundException for SubjectName: " + requestInfo.SubjectName);
                throw new PartnerNotFoundException(requestInfo.SubjectName);
            }

            int i;
            for (i = 0; i<requestInfo.Partner.AllowedAPIs.Length; ++i)
            {
                if (APIName.Equals(requestInfo.Partner.AllowedAPIs[i]))
                {
                    break;
                }
            }
            if (i == requestInfo.Partner.AllowedAPIs.Length)
            {
                throw new APINotAllowedException( requestInfo.SubjectName, APIName );
            }

            for (i = 0; i<requestInfo.Partner.ValidIPs.Length; ++i)
            {
                // Xom.Trace(XomAreaName.wcutilitiestrace, LogLevel.L_LOW, "IP check for: " + requestInfo.ClientIPPort.ToString() + " ClientIP:" + requestInfo.ClientIP.ToString("X") + " IP:" + requestInfo.Partner.ValidIPs[i].IP.ToString("X") + " Mask:" + requestInfo.Partner.ValidIPs[i].Mask.ToString("X"));
                if (((requestInfo.ClientIP) & requestInfo.Partner.ValidIPs[i].Mask) == (requestInfo.Partner.ValidIPs[i].IP & requestInfo.Partner.ValidIPs[i].Mask))
                {
                    break;
                }
            }
            if (i == requestInfo.Partner.ValidIPs.Length)
            {
                Xom.Trace(XomAreaName.wcutilitiestrace, LogLevel.L_ERROR, "InvalidIPException for: " + requestInfo.ClientIPPort.ToString());
                throw new InvalidIPException( requestInfo.SubjectName, requestInfo.ClientIPPort );
            }

            HttpContext.Current.Items[REQUEST_INFO] = requestInfo;
        }

        // Uses HTTPContext to retrieve header info about SubjectName
        public void CheckAPIAndTitle(string APIName, uint TitleID, TitlePrivilege privilegeRequired)
        {
            CheckAPI(APIName);
            RequestInfo requestInfo = GetRequestInfo();
            requestInfo.PrivilegeRequired = privilegeRequired;
            requestInfo.Title = (TitleInfo)titles[TitleID];
            if (requestInfo.Title == null)
            {
                Xom.Trace(XomAreaName.wcutilitiestrace, LogLevel.L_ERROR, "TitleNotAllowedException for title: " + TitleID.ToString());
                throw new TitleNotAllowedException( requestInfo.SubjectName, TitleID );
            }

            int i;
            for (i = 0; i<requestInfo.Partner.TitlePrivileges.Length; ++i)
            {
                if (TitleID == requestInfo.Partner.TitlePrivileges[i].TitleID)
                {
                    if ((requestInfo.Partner.TitlePrivileges[i].Privileges & privilegeRequired) == privilegeRequired)
                    {
                        break;
                    }
                    else
                    {
                        i = requestInfo.Partner.TitlePrivileges.Length;
                        break;
                    }
                }
            }
            if (i == requestInfo.Partner.TitlePrivileges.Length)
            {
                Xom.Trace(XomAreaName.wcutilitiestrace, LogLevel.L_ERROR, "TitleNotAllowedException for title: " + TitleID.ToString());
                throw new TitleNotAllowedException( requestInfo.SubjectName, TitleID );
            }
        }

        PartnerInfo LookupPartner(string subjectName)
        {
            return (PartnerInfo)partnersBySubjectName[subjectName];
        }

        public static bool IsAdminPartner()
        {
            bool            fAdmin = false;
            RequestInfo     ri = GetRequestInfo();

            // Admin Partners use credential type 2
            if (ri.Partner.CredentialType == 2)
            {
                fAdmin = true;
            }

            return fAdmin;
        }

        public static string GetRequestID()
        {
            RequestInfo ri = GetRequestInfo();
            return (ri == null) ? null : ri.RequestID;
        }

        public static string GetClientIPPort()
        {
            RequestInfo ri = GetRequestInfo();
            return (ri == null) ? null : ri.ClientIPPort;
        }

        public static string GetSubjectName()
        {
            RequestInfo ri = GetRequestInfo();
            return (ri == null) ? null : ri.SubjectName;
        }


        public ulong LookupXuidByPuid(ulong puid)
        {
            return LookupXuidsByPuids(puid)[0];
        }

        public ulong[] LookupXuidsByPuids(params ulong[] puids)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            ulong[] xuids = XCache.LookupPUIDs(puids);
            ctx.Undo();

            return xuids;
        }

        public ulong LookupXuidByGamertag(string gamertag)
        {
            return LookupXuidsByGamertags(gamertag)[0];
        }

        public ulong[] LookupXuidsByGamertags(params string[] gamertags)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            ulong[] xuids = XCache.LookupPUIDs(gamertags);
            ctx.Undo();

            return xuids;
        }


        public ulong LookupPuidByXuid(ulong xuid)
        {
            return LookupPuidsByXuids(xuid)[0];
        }

        public ulong[] LookupPuidsByXuids(params ulong[] xuids)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();

            XCacheUserResponseData[] userResponseData = XCache.LookupUsersByXUID(xuids);
            ulong[] puids = new ulong[userResponseData.Length];

            for (int i = 0; i < userResponseData.Length; i++) {
                puids[i] = userResponseData[i].qwPassportPUID;
            }

            ctx.Undo();
            return puids;
        }

        public ulong LookupPuidByGamertag(string gamertag)
        {
            return LookupPuidsByGamertags(gamertag)[0];
        }

        public ulong[] LookupPuidsByGamertags(params string[] gamertags)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();

            XCacheUserResponseData[] userResponseData = XCache.LookupUsersByGamertag(gamertags);
            ulong[] puids = new ulong[userResponseData.Length];

            for (int i = 0; i < userResponseData.Length; i++) {
                puids[i] = userResponseData[i].qwPassportPUID;
            }

            ctx.Undo();
            return puids;
        }

        public static readonly string InvalidGamertag = XCache.InvalidGamertag;

        public static bool IsInvalidGamertag(string gamertag)
        {
            return XCache.IsInvalidGamertag(gamertag);
        }

        public string LookupGamerTag(ulong puid)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            string gamerTag = XCache.LookupGamerTag(puid);
            ctx.Undo();

            return gamerTag;
        }

        public string[] LookupGamerTags(ulong[] puids)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            string[] gamerTags = XCache.LookupGamerTags(puids);
            ctx.Undo();

            return gamerTags;
        }

        public string LookupTeamName(uint titleId, ulong puidTeam)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            string teamName = XCache.LookupTeamName(titleId, puidTeam);
            ctx.Undo();

            return teamName;
        }

        public ulong LookupTeamPUID(uint titleId, string teamName)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            ulong puid = XCache.LookupTeamPUID(titleId, teamName);
            ctx.Undo();

            return puid;
        }

        public string[] LookupTeamNames(uint titleId, ulong[] puidTeams)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            string[] teamNames = XCache.LookupTeamNames(titleId, puidTeams);
            ctx.Undo();

            return teamNames;

        }

        public ulong[] LookupTeamPUIDs(uint titleId, string[] teamNames)
        {
            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            ulong[] teamPuids = XCache.LookupTeamPUIDs(titleId, teamNames);
            ctx.Undo();

            return teamPuids;
        }

        public PUIDAndOwner[] LookupWebID(byte[] webID)
        {
            uint credType = 0;
            RequestInfo requestInfo = GetRequestInfo();
#if DEBUG
            if (null != requestInfo)
#endif
            {
                credType = requestInfo.Partner.CredentialType;
            }

            // verify webId
            CredTypeAndWebID o = new CredTypeAndWebID(credType, webID);

            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            PUIDAndOwner[] puids = XCache.LookupWebID(webID, credType);
            ctx.Undo();

            return puids;
        }

        public PUIDAndOwner LookupWebID(byte[] webID, string GamerTag)
        {
            uint credType = 0;
            RequestInfo requestInfo = GetRequestInfo();
#if DEBUG
            if (null != requestInfo)
#endif
            {
                credType = requestInfo.Partner.CredentialType;
            }

            // handle null gamerTag
            if (GamerTag == null)
            {
                throw new XboxWebExceptionNoEvent( "Bad GamerTag provided, null not allowed" );
            }

            // verify webId (handles null webid internally)
            CredTypeAndWebID o = new CredTypeAndWebID(credType, webID);

            PUIDAndOwner puid;

            WindowsImpersonationContext ctx = windowsIdentity.Impersonate();
            puid = XCache.LookupWebID(webID, GamerTag, credType);
            ctx.Undo();

            if ( 0 == puid.PUID )
            {
                throw new XboxWebExceptionNoEvent( "(webID,GamerTag) pair ("+ByteConvert.ToReverseString(webID)+","+GamerTag+") is not linked in our system" );
            }
            return puid;
        }

        // Uses HTTPContext to retrieve header info about SubjectName
        public TitlePrivilegeInfo[] GetPartnerSpecificTitleInfo()
        {
            RequestInfo requestInfo = GetRequestInfo();

            Hashtable currentTitles = titles;

            int i = 0;
            TitlePrivilegeInfo[] resultTitles = new TitlePrivilegeInfo[currentTitles.Count];

            IDictionaryEnumerator myEnumerator = currentTitles.GetEnumerator();
            while ( myEnumerator.MoveNext() )
            {
                TitleInfo title = (TitleInfo) myEnumerator.Value;
                resultTitles[i].TitleID = title.TitleID;
                resultTitles[i].Privileges = TitlePrivilege.None;
                for (int j=0; j<requestInfo.Partner.TitlePrivileges.Length; ++j)
                {
                    if (requestInfo.Partner.TitlePrivileges[j].TitleID == title.TitleID)
                    {
                        resultTitles[i].Privileges = requestInfo.Partner.TitlePrivileges[j].Privileges;
                        break;
                    }
                }
                resultTitles[i].Rating = title.Rating;
                resultTitles[i].DefaultLocale = title.DefaultLocale;
                resultTitles[i].LocalizedName = title.LocalizedName;
                i++;
            }
            Debug.Assert( i == currentTitles.Count );

            return resultTitles;
        }

        string BuildCacheKeyString( CacheType type, byte[] key )
        {
            int i;
            StringBuilder keyString = new StringBuilder(1 + key.Length);
            keyString.Length = 1 + key.Length;
            keyString[0] = (char) (int) type;
            for (i=0; i<key.Length; ++i)
            {
                keyString[i+1] = (char) key[i];
            }

            return keyString.ToString();
        }

        public void CacheInsert( CacheType type, byte[] key, byte[] value, uint expireInSeconds, CacheItemRemovedCallback onRemove)
        {
        // TODO LRUCache insert
            HttpContext.Current.Cache.Add(BuildCacheKeyString(type,key), value, null, DateTime.Now.AddSeconds(expireInSeconds), TimeSpan.Zero, CacheItemPriority.Normal, onRemove );
        }

        public byte[] CacheLookup( CacheType type, byte[] key )
        {
        // TODO LRU cache update
            return (byte[]) HttpContext.Current.Cache.Get(BuildCacheKeyString(type,key));
        }

        // Provides connection pooling and adds AuthData to HTTP Header
        // Implemented using System.Net.WebClient
        public byte[] StatsFrontDoorRequest(XOService serviceID, string Url, ulong requestingUserPUID, uint titleID, byte[] postData)
        {
            byte[] addr = IPAddress.Parse(HttpContext.Current.Request.UserHostAddress.ToString()).GetAddressBytes();
            uint clientIP = ((uint)addr[0]) + ((uint)addr[1] << 8) + ((uint)addr[2] << 16) + ((uint)addr[3] << 24);

            HTTPAuthData auth = new HTTPAuthData(0, clientIP, 0, requestingUserPUID, titleID, (uint)serviceID, 0);

            xonline.core.user.UserPrivileges userPriv = new xonline.core.user.UserPrivileges(requestingUserPUID);
            if (userPriv[XOn.XPRIVILEGE_PROFILE_VIEWING])
            {
                auth.SetPrivilege((byte)XOn.XPRIVILEGE_PROFILE_VIEWING);
            }
            else if (userPriv[XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY])
            {
                auth.SetPrivilege((byte)XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
            }

            return FrontDoorRequest(Url, auth, (uint) serviceID, 0, postData);
        }

        // Provides connection pooling and adds AuthData to HTTP Header
        // Implemented using System.Net.WebClient
        public byte[] FrontDoorRequest( String Url, ulong RequestingUserPUID, uint titleID, uint serviceId1, uint serviceId2, byte[] postData  )
        {
            RequestInfo requestInfo = GetRequestInfo();
            HTTPAuthData authData = new HTTPAuthData(requestInfo.ClientPort, requestInfo.ClientIP, requestInfo.qwRequestID, RequestingUserPUID, titleID, serviceId1, serviceId2);

            return FrontDoorRequest( Url, authData, serviceId1, serviceId2, postData);
        }

        // Provides connection pooling and adds AuthData to HTTP Header
        // Implemented using System.Net.WebClient
        public byte[] FrontDoorRequest( String Url, HTTPAuthData authData, uint serviceId1, uint serviceId2, byte[] postData  )
        {
            WebClient myWebClient = new WebClient();
            myWebClient.Headers.Add(XHttpHdr.HTTPAUTHDATA,authData.GetBase64EncodedString());
            myWebClient.Headers.Add("Content-Type", "xon/"+serviceId1);
            myWebClient.Headers.Add("User-Agent", serviceId1.ToString("x")+"/1.00.65535");

            byte[] responseArray;
            try
            {
                responseArray = myWebClient.UploadData(Url,"POST",postData);
            }
            catch (WebException e)
            {
                HResult hr = HResult.S_OK;
                string xEvent = null;

                // if we have a response that contains an error and/or  an
                // event header, then get that info to make some decisions

                if ((e.Response != null) && (e.Response.Headers != null))
                {
                    string xErr = e.Response.Headers["X-Err"];
                    xEvent = e.Response.Headers["X-Event"];

                    if (! string.IsNullOrEmpty(xErr))
                    {
                        hr = HResult.Parse(xErr);
                    }

                    // if we have HttpContext and we get back  an  X-Event
                    // header,  then propagate the value  between  servers

                    if (HttpContext.Current != null)
                    {
                        HttpContext context = HttpContext.Current;
                        if (! string.IsNullOrEmpty(xEvent)) context.Items["X-Event"] = xEvent;
                    }
                }

                switch (hr)
                {
                    // Non-fatal errors from front door. Callers must handle these exceptions. Does not log an event.
                    case HResult.XONLINE_E_STAT_USER_NOT_FOUND:
                    case HResult.XONLINE_E_USER_NOT_PRESENT:
                    case HResult.XONLINE_E_ACCOUNTS_PERMISSION_DENIED:
                    case HResult.XONLINE_E_ACCOUNTS_INVALID_USER:
                    case HResult.XONLINE_E_ACCOUNTS_OPERATION_BLOCKED:
                    case HResult.XONLINE_E_STAT_PERMISSION_DENIED:

                        throw new FrontDoorNonFatalException(hr);

                    default:

                        // and if the front door already logged an event then
                        // there is no reason that we need to  log  it  again

                        if (! string.IsNullOrEmpty(xEvent))
                        {
                            throw new FrontDoorNonFatalException(hr);
                        }

                        // Everything else we consider  fatal.  Most  callers
                        // will not catch these and will let IIS handle / log

                        HttpWebResponse httpResponse = (e.Response as HttpWebResponse);
                        if (httpResponse != null && httpResponse.StatusCode == HttpStatusCode.InternalServerError)
                        {
                            throw new FrontDoorInternalException(Url, hr, postData, e);
                        }
                        else
                        {
                            throw new FrontDoorException( Url, hr, postData, e );
                        }
                }
            }

            return responseArray;
        }

        public uint PostXrlRequest(
            string         virtualInterface,
            XOService      service,
            string         path,
            ulong          xboxId,
            XRLObject2     requestObject,
            ref XRLObject2 responseObject
        ) {
            RequestInfo requestInfo = GetRequestInfo();

            // this stuff is coming off the web, we don't have a machine id
            // or a user id, so we like about it.  pass zeroes for all that

            HTTPAuthData authData = new HTTPAuthData(
                requestInfo.ClientPort, requestInfo.ClientIP,
                requestInfo.qwRequestID, xboxId, 0, 0, (uint) service, 0
            );

            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";

            try {
                return XRLUtil.PostXrlRequest(
                    virtualInterface, path, authData.GetBase64EncodedString(),
                    requestObject, headers, ref responseObject
                );
            } catch (XRLException e) {
                return e.HResult;
            }
        }
        
        public uint PostXrlRequest(
            string         virtualInterface,
            XOService      service,
            string         path,
            ulong          xboxId,
            ulong          PUID,
            uint           titleId,
            XRLObject2     requestObject,
            ref XRLObject2 responseObject
        ) {
            RequestInfo requestInfo = GetRequestInfo();

            // this stuff is coming off the web, we don't have a machine id
            // or a user id, so we like about it.  pass zeroes for all that

            HTTPAuthData authData = new HTTPAuthData(
                requestInfo.ClientPort, requestInfo.ClientIP,
                requestInfo.qwRequestID, xboxId, PUID, titleId, (uint)service, (uint)service
            );

            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";

            try {
                return XRLUtil.PostXrlRequest(
                    virtualInterface, path, authData.GetBase64EncodedString(),
                    requestObject, headers, ref responseObject
                );
            } catch (XRLException e) {
                return e.HResult;
            }
        }


        public uint PostXrlRequest2(
            string virtualInterface,
            XOService service,
            string path,
            ulong PUID,
            XRLObject2 requestObject,
            ref XRLObject2 responseObject
        )
        {
            RequestInfo requestInfo = GetRequestInfo();

            // this stuff is coming off the web, we don't have a machine id
            // or a user id, so we like about it.  pass zeroes for all that

            HTTPAuthData authData = new HTTPAuthData(
                requestInfo.ClientPort, requestInfo.ClientIP,
                requestInfo.qwRequestID, PUID, 0, (uint)service, 0
            );

            WebHeaderCollection headers = new WebHeaderCollection();
            headers[XHttpHdr.WEBCACHEREQUEST] = "TRUE";

            try
            {
                return XRLUtil.PostXrlRequest(
                    virtualInterface, path, authData.GetBase64EncodedString(),
                    requestObject, headers, ref responseObject
                );
            }
            catch (XRLException e)
            {
                return e.HResult;
            }
        }



        static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                Instance.mgmt.ControlRequest(args);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_MANAGEMENT_COMMAND_ERROR, e);
            }
        }

        public static ulong GetRequestorMachinePUID()
        {
            SHA1CryptoServiceProvider sha1 = null;
            MemoryStream ms = null;
            BinaryWriter bw = null;
            RequestInfo ri = GetRequestInfo();

            // check for requestinfo
            if ( ri == null )
            {
                throw new XboxWebException( XEvent.Id.LIVEPROXY_INVALID_MSGFORMAT,
                    "Request is invalid.",
                    "Utilities::GetRequestorMachinePUID:  No request info can be found with this request.  This could be a hacker.  Please investigate." );
            }

            // create a crypto service provider.
            sha1 = new SHA1CryptoServiceProvider();
            ms = new MemoryStream();
            bw = new BinaryWriter( ms );

            // compute the name hash.
            byte[] hashSubjectName = sha1.ComputeHash( System.Text.ASCIIEncoding.ASCII.GetBytes( ri.SubjectName ) );

            // the other 7 bytes are the SHA1 hash of the subject name.
            bw.Write( hashSubjectName, 0, 7 );

            // first byte is 0xFD
            bw.Write( (byte)(0xFD) );

            bw.Close();

            return System.BitConverter.ToUInt64( ms.ToArray(), 0 );
        }

        public static ulong GetRequestorUserPUID()
        {
            SHA1CryptoServiceProvider sha1 = null;
            MemoryStream ms = null;
            BinaryWriter bw = null;
            RequestInfo ri = GetRequestInfo();

            // check for requestinfo
            if ( ri == null )
            {
                throw new XboxWebException( XEvent.Id.LIVEPROXY_INVALID_MSGFORMAT_1,
                    "Request is invalid.",
                    "Utilities::GetRequestorUserPUID:  No request info can be found with this request.  This could be a hacker.  Please investigate." );
            }

            // create a crypto service provider.
            sha1 = new SHA1CryptoServiceProvider();
            ms = new MemoryStream();
            bw = new BinaryWriter( ms );

            // compute the name hash.
            byte[] hashSubjectName = sha1.ComputeHash( System.Text.ASCIIEncoding.ASCII.GetBytes( ri.SubjectName ) );

            // the other 7 bytes are the SHA1 hash of the subject name.
            bw.Write( hashSubjectName, 0, 7 );

            // first byte is 0xFC
            bw.Write( (byte)(0xFC) );

            bw.Close();

            return System.BitConverter.ToUInt64( ms.ToArray(), 0 );
        }

        [MgmtHandler("ReloadTitles", "Reloads all title information from WebDB")]
        public string ProcessReloadTitles(string[] args)
        {
            LoadTitles();
            return "Title reload complete. We now have " + Instance.titles.Count + " titles loaded\r\n";
        }

        [MgmtHandler("ReloadPartners", "Reloads all partner information from WebDB")]
        public string ProcessReloadPartners(string[] args)
        {
            LoadPartners();
            return "Partner reload complete. We now have " + Instance.partnersBySubjectName.Count + " partners loaded\r\n";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__base_4_none_12.4.56.0_none_e550c85a2903e2d1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_base_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb.manifest
XP_MANIFEST_PATH=manifests\x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb.cat
XP_CATALOG_PATH=manifests\x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb.cat
XP_PAYLOAD_PATH=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_base_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\XMgmt.cs ===
using System;
using System.Collections;
using System.Reflection;
using System.Text;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.server.webcache.common 
{
    class Mgmt
    {
        public Mgmt(object handler, string component)
        {
            this.handler   = handler;
            this.component = component;
            
            Type      type = handler.GetType();
            ArrayList cmds = new ArrayList();
            int       len  = 0;
            cmdTable       = new Hashtable();

            foreach (MethodInfo method in type.GetMethods())
            {
                foreach (Attribute attr in method.GetCustomAttributes(false))
                {
                    MgmtHandlerAttribute ma = attr as MgmtHandlerAttribute;
                    
                    if (ma == null)
                        continue;

                    MgmtHandler mh = new MgmtHandler(handler, ma, method);

                    cmdTable.Add(ma.Command.ToLower(), mh);
                    cmds.Add(mh);
                    len = Math.Max(len, 
                                   ma.Command.Length + ((ma.Arguments.Length == 0) ? 0 : (ma.Arguments.Length + 1)));
                }
            }

            cmdList    = (MgmtHandler[])cmds.ToArray(typeof(MgmtHandler));
            helpFormat = String.Format("  {{0,-{0}}}-- {{1}}\r\n", len + 1);

        }        

        public void ControlRequest(ControlRequestEventArgs args)
        {
            string result = ControlRequest(args.Command, args.CommandArgs);

            if (result != null)
            {
                XomControlConnection.SendMessage(result, args.RequestId);
                args.Handled = true;
            }
        }

        protected string ControlRequest(string cmd, string[] args)
        {
            if (cmd.ToLower() == "help")
            {
                StringBuilder help = new StringBuilder(component);
                help.Append(" help:\r\n");

                foreach (MgmtHandler mh in cmdList)
                    help.Append(String.Format(helpFormat, mh.Command + " " + mh.Arguments, mh.HelpText));

                help.Append("\r\n");

                return help.ToString();
            }
            else
            {
                MgmtHandler mh = (MgmtHandler)cmdTable[cmd.ToLower()];

                if (mh != null)
                    return mh.Invoke(args);
            }

            return null;
        }

        private object        handler;
        private string        component;
        private Hashtable     cmdTable;
        private MgmtHandler[] cmdList;
        private string        helpFormat;
    }

    class MgmtHandler
    {
        private object     o;
        private string     command;
        private string     arguments;
        private string     helpText;
        private MethodInfo method;
        
        public MgmtHandler (object o, MgmtHandlerAttribute ma, MethodInfo method)
        {
            this.o         = o;
            this.command   = ma.Command;
            this.arguments = ma.Arguments;
            this.helpText  = ma.HelpText;
            this.method    = method;
        }

        public string Invoke(string[] args)
        {
            object[] miArgs = new object[]{args};
            object   result = method.Invoke(o, miArgs);
            return result as string;
        }
        
        public string Command   { get { return command; } }
        public string Arguments { get { return arguments; } }
        public string HelpText  { get { return helpText; } }
    }

    class MgmtHandlerAttribute : Attribute
    {
        private string command;
        private string arguments;
        private string helpText;

        public MgmtHandlerAttribute(string command, string helpText)
        {
            this.command   = command;
            this.arguments = "";
            this.helpText  = helpText;
        }

        public string Command   { get { return command; } }
        public string HelpText  { get { return helpText; } }
        public string Arguments { get { return arguments; }
                                  set { arguments = value; } }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\XboxWebException.cs ===
//
// XboxWebException.cs
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Text;
using System.Web;
using System.Xml;
using System.Web.Services.Protocols;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.server.webcache.common 
{
    //Note that this exception will be thrown to the public when it is a client fault (e.g. invalid argument passed in)
    public class XboxWebClientException : SoapException
    {
        public XboxWebClientException(HResult hr, string szMessage)
            :
            base(szMessage , SoapException.ClientFaultCode, HttpContext.Current.Request.Url.AbsoluteUri, CreateDetailsHResult(hr))
        {
        }
        public static XmlNode CreateDetailsHResult(HResult hr)
        {
            // Build the detail element of the SOAP fault.
            XmlDocument doc = new XmlDocument();
            XmlNode node = doc.CreateNode(XmlNodeType.Element,
                SoapException.DetailElementName.Name,
                SoapException.DetailElementName.Namespace);

            // Create the HR
            XmlNode nodeHr = doc.CreateTextNode(hr.ToString());
            node.AppendChild(nodeHr);

            return node;
        }
    }
    
//
// Exceptions we throw to the client. All exceptions that escape a widget must
// be of type XboxWebException.
//
public class XboxWebException : Exception
{
    public XboxWebException(XEvent.Id eventId, string message) : base(message)
    {
        if (eventId == 0 && (this is XboxWebExceptionNoEvent))
            return;
        
        LogEvent(eventId, new StringBuilder(message));
    }

    public XboxWebException(XEvent.Id eventId, string message, string eventText) : base(message)
    {
        StringBuilder sb = new StringBuilder(message);
        sb.Append("\r\n----------\r\n");
        sb.Append(eventText);
        
        LogEvent(eventId, sb);
    }

    public XboxWebException(XEvent.Id eventId, string message, Exception e) : base(message)
    {
        LogEvent(eventId, message, null, e);
    }

    public XboxWebException(XEvent.Id eventId, string message, string internalMessage, Exception e) : base(message)
    {
        LogEvent(eventId, message, internalMessage, e);
    }

    private void LogEvent(XEvent.Id eventId, string message, string internalMessage, Exception e)
    {
        System.Text.StringBuilder eventText = new System.Text.StringBuilder(message);

        eventText.Append(internalMessage);
        eventText.Append("\r\n----------\r\n");

        while( e != null ) 
        {
            eventText.Append(e.GetType().ToString() + ": " + e.Message + "\r\n");
            eventText.Append(e.StackTrace);
            eventText.Append("\r\n----------\r\n");
        
            e = e.InnerException;
        }

        LogEvent(eventId, eventText);        
    }

    private void LogEvent(XEvent.Id eventId, StringBuilder eventText)
    {
        HttpContext ctx        = HttpContext.Current;        
        byte[]      postBuffer = null;

        eventText.Append("\r\n----------\r\n");

        if (ctx == null)
        {
            eventText.Append("\r\nNo HTTP Context found.\r\n");
        }
        else
        {
            try
            {
                byte[] pb = new byte[ctx.Request.InputStream.Length];
                ctx.Request.InputStream.Seek(0, System.IO.SeekOrigin.Begin);
                ctx.Request.InputStream.Read(pb, 0, pb.Length);

                eventText.Append("\r\nEvent data contains POST buffer.\r\n");
                postBuffer = pb;
            }
            catch(Exception e)
            {
                eventText.Append("\r\nCouldn't read post stream:\r\n");
                eventText.Append(e.ToString());
            }
        }

        eventText.Insert(0, "\r\n");
        eventText.Insert(0, GetType());

        Xom.NtDataDynEvent( eventId, postBuffer, eventText.ToString() );
    }
}

//
// Exceptions for errors that weren't caused by the client should be thrown
// as XboxWebInternalException.
//

public class XboxWebInternalException : XboxWebException
{
    public XboxWebInternalException(XEvent.Id eventId) 
        : base(eventId, "The web service encountered an internal error.")
    {
    }

    public XboxWebInternalException(XEvent.Id eventId, Exception e) 
        : base(eventId, "The web service encountered an internal error.", e)
    {
    }

    public XboxWebInternalException(XEvent.Id eventId, string eventText) 
        : base(eventId, "The web service encountered an internal error.", eventText)
    {
    }

    public XboxWebInternalException(XEvent.Id eventId, string eventText, Exception e) 
        : base(eventId, "The web service encountered an internal error.", eventText, e)
    {
    }
}

//
// Exceptions thrown to the client that should not be written to the event log
// must be of type XboxWebExceptionNoEvent.
//

public class XboxWebExceptionNoEvent : XboxWebException
{
    public XboxWebExceptionNoEvent(string message)
        : base (0, message)
    {
    }

    public XboxWebExceptionNoEvent(string message, Exception e)
        : base (0, message, e)
    {
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__base_4_none_12.4.56.0_none_e550c85a2903e2d1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_base_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb.manifest
XP_MANIFEST_PATH=manifests\x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb.cat
XP_CATALOG_PATH=manifests\x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb.cat
XP_PAYLOAD_PATH=x86__base_4_no-public-key_12.4.56.0_x-ww_8317cddb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_base_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\Unit\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\base\XboxcomApi.cs ===
using System;
using System.Text;
using System.Collections;
using System.Reflection;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Xml;
using System.Web;
using System.IO;
using System.Net;
using System.Web.Services.Protocols;
using System.Security.Cryptography;

//using xonline.common.tools.stutilcore;
using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;
using xonline.common.protocol;
using xonline.server.webcache.common;

namespace xonline.server.webcache.common
{
    public enum LiveCacheDependencyBitFlags
    {
        UserAccount = 1,
        PassportAccount = 2,
        Messages = 4,
        Friends = 8,
        Stats = 16,
    }

    public enum LcserviceId
    {
        Unknown = 0,

        //
        // presence and notification: 10XX
        //
        GetFriends = 1001,
        GetPresenceInfo = 1003,
        AddFriend = 1004,
        DeleteFriend = 1005,
        AcceptFriendRequest = 1006,
        RejectFriendRequest = 1007,
        QueryAffiliates = 1008,
        GetPublicPresenceInfo = 1009,
        WebAlive = 1010,

        //
        // stringsvr: 12XX
        //
        VetString = 1201,
        StringLookup = 1202,

        //
        // user account: 2XXX
        //
        LinkWebAccount = 2001,
        CreateXboxComAccount = 2002,
        UpsGetProfile = 2004,
        UpsUpdateProfile = 2005,
        ReserveName = 2007,
        UpdateXboxComActivity = 2008,
        GetUserWebInfo = 2009,
        GetLinkedGamertag = 2010,
        GetUserType = 2011,
        GetAccountInfo = 2012,
        SetAccountInfo = 2013,

        //
        // stats: 3XXX
        //
        SyncSettings = 3001,
        ReadSettings = 3002,
        EnumTitles = 3003,
        AchievementEnum = 3004,
        PublicReadSettings = 3005,
        PublicEnumTitles = 3006,

        //
        // billing & offering: 4XXX
        //

        //
        // storage: 5XXX
        //
        StorageWrite = 5001,
        StorageRemove = 5002,
        StorageRead = 5003,

        //
        // messaging: 6XXX
        //
        EnumerateMessages = 6001,
        GetMessageSummary = 6002,
        GetMessageDetails = 6003,
        DeleteMessage = 6004,
        SetMessageFlags = 6005,
        SendMessage = 6006,
        EnumerateSystemMessages = 6007,
        GetSystemMessageDetails = 6008,

        //
        // internal API = 99XX
        //
        CacheInvalidate = 9901
    }

    public enum GamerTiers : int
    {
        Unknown = -1,
        None = 0,
        Silver = 3,
        Gold = 6
    }


    public class LivecacheResponseException : Exception
    {
        public LivecacheResponseException(LivecacheRequest l)
        {
        }
    }

    public class LivecacheDependency
    {
        public ulong Puid;
        public uint DataSets; // currently one data set only, may expand in future
        public static LivePuidDependency UserAccount(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.UserAccount, livePuid);
        }
        public static LivecacheDependency PassportAccount(ulong passportPuid)
        {
            return new PassportPuidDependency(LiveCacheDependencyBitFlags.PassportAccount, passportPuid);
        }
        public static LivePuidDependency Friends(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.Friends, livePuid);
        }
        public static LivePuidDependency Messages(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.Messages, livePuid);
        }
        public static LivePuidDependency Stats(ulong livePuid)
        {
            return new LivePuidDependency(LiveCacheDependencyBitFlags.Stats, livePuid);
        }
        protected enum LiveCacheDependencyName
        {
            UserAccount = 'u',
            PassportAccount = 'p',
            Messages = 'm',
            Friends = 'f',
            Stats = 's',
        }
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            // the names (f,m,p,s,u) must be unique
            AppendDependency(sb, LiveCacheDependencyBitFlags.UserAccount,
                                 LiveCacheDependencyName.UserAccount);
            AppendDependency(sb, LiveCacheDependencyBitFlags.PassportAccount,
                                 LiveCacheDependencyName.PassportAccount);
            AppendDependency(sb, LiveCacheDependencyBitFlags.Messages,
                                 LiveCacheDependencyName.Messages);
            AppendDependency(sb, LiveCacheDependencyBitFlags.Friends,
                                 LiveCacheDependencyName.Friends);
            AppendDependency(sb, LiveCacheDependencyBitFlags.Stats,
                                 LiveCacheDependencyName.Stats);

            return sb.ToString();
        }
        protected void AppendDependency(StringBuilder sb, LiveCacheDependencyBitFlags bit, LiveCacheDependencyName name)
        {
            if ((DataSets & (uint)bit) != 0)
            {
                if (sb.Length > 0)
                {
                    sb.Append(',');
                }

                sb.Append(Puid.ToString("x"));
                sb.Append('.');
                sb.Append((char)name);
            }
        }
    }

    public class LivePuidDependency : LivecacheDependency
    {
        public LivePuidDependency(LiveCacheDependencyBitFlags category, ulong users)
        {
            DataSets = (uint)category;
            Puid = users;
        }

        public LivePuidDependency AddUserAccount()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.UserAccount;
            return this;
        }

        public LivePuidDependency AddFriends()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.Friends;
            return this;
        }

        public LivePuidDependency AddMessages()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.Messages;
            return this;
        }

        public LivePuidDependency AddStats()
        {
            DataSets |= (uint)LiveCacheDependencyBitFlags.Stats;
            return this;
        }
    }

    public class PassportPuidDependency : LivecacheDependency
    {
        public PassportPuidDependency(LiveCacheDependencyBitFlags category, ulong users)
        {
            DataSets = (uint)category;
            Puid = users;
        }
    }

    public class XboxComCodeErrorException : Exception
    {
        public XboxComCodeErrorException(string message)
            : base(message)
        {
        }

        public XboxComCodeErrorException(string message, Exception inner)
            : base(message, inner)
        {
        }
    }

    public class BadConfigException : Exception
    {
        public string ConfigPath;

        public BadConfigException(string configpath, string errmsg)
            : base(errmsg)
        {
            ConfigPath = configpath;
        }
    }

    public struct LivecacheDependencyRequired
    {
        public byte Flags;

        public bool Check(LivecacheDependency dep)
        {
            if (Flags != 0)
            {
                if (dep == null)
                {
                    return false;
                }
                else if ((Flags & ~dep.DataSets) != 0)
                {
                    return false;
                }
            }

            return true;
        }
    }

    public class LivecacheRequest : XrlRequest
    {
        public LivecacheRequest(
                ulong requestingUserId,
                LcserviceId lcserviceId,
                XRLObject2 request2
                )
            : this(requestingUserId,
                lcserviceId,
                request2,
                null,
                null)
        {
        }

        public LivecacheRequest(
            ulong requestingUserId,
            LcserviceId lcserviceId,
            XRLObject2 request2,
            LivecacheDependency dependency,
            LivecacheDependency invalidation
            )
            : this(requestingUserId,
                lcserviceId,
                request2.GetBytes(),
                0,  // xboxID
                XOn.WEB_TITLE_ID,
                dependency,
                invalidation,
                request2)
        {
        }

        public LivecacheRequest(
                ulong requestingUserId,
                LcserviceId lcserviceId,
                byte[] postData,
                LivecacheDependency dependency,
                LivecacheDependency invalidation,
                object requestObjectForDbg
                )
            : this(requestingUserId,
                lcserviceId,
                postData,
                0,  // xboxID
                XOn.WEB_TITLE_ID,
                dependency,
                invalidation,
                requestObjectForDbg)
        {
        }


        public LivecacheRequest(
                ulong requestingUserId,
                LcserviceId lcserviceId,
                byte[] postData,
                ulong xboxID,
                uint titleID,
                LivecacheDependency dependency,
                LivecacheDependency invalidation,
                object requestObjectForDbg
                )
            : this(requestingUserId,
                lcserviceId,
                postData,
                CreateHTTPAuthData(requestingUserId, lcserviceId, xboxID, titleID),
                dependency,
                invalidation,
                requestObjectForDbg)
        {
        }

        public LivecacheRequest(
                ulong requestingUserId,
                LcserviceId lcserviceId,
                byte[] postData,
                HTTPAuthData httpAuthData,
                LivecacheDependency dependency,
                LivecacheDependency invalidation,
                object requestObjectForDbg
                )
            : base()
        {
            LcserviceInfo si = LcserviceInfo.Lookup(lcserviceId);
            _eventId = si.EventId;

            if (!si.ExpectedDependency.Check(dependency))
            {
                throw new XboxComCodeErrorException("required dependency for this SPI was not supplied");
            }

            if (!si.ExpectedInvalidation.Check(invalidation))
            {
                throw new XboxComCodeErrorException("required invalidation for this SPI was not supplied");
            }

            Debug.Assert(Config.GetBoolSetting(Setting.livecache_serviceEnabled), "check LivecacheServiceEnabled first");

            if (_interfaceBucketChangeEventHandler == null)
            {
                _interfaceBucketChangeEventHandler = new InterfaceBucketChangeEventHandler(OnInterfaceBucketChange);
                Config.InterfaceBucketChange += _interfaceBucketChangeEventHandler;
            }

            LivecacheKey key = new LivecacheKey((int)lcserviceId, requestingUserId, postData);

            ulong partitionHash;
            if (dependency != null)
            {
                // consider: we could partition on both Puid and DataSet for more even distribution. However,
                // if we ever support multiple data sets, that makes it harder to invalidate.
                partitionHash = dependency.Puid;
            }
            else if (invalidation != null)
            {
                partitionHash = invalidation.Puid;
            }
            else
            {
                partitionHash = (ulong)key.GetHashCode();
            }

            uint partition = Config.GetBucketNum(Interface.livecache, partitionHash);
            IBucketServer bucket = Config.GetBucketServer(Interface.livecache, partition);

            base.TargetInterfaceInfo = bucket.CurrentServer;
            base.Path = LivecacheConst.TargetXrl;
            base.AuthData = httpAuthData.GetBase64EncodedString();
            base.PostData = postData;
            base.RequestHeaders.Add(LivecacheConst.LcserviceIdHeader, ((int)lcserviceId).ToString());

            if (dependency != null)
            {
                base.RequestHeaders.Add(LivecacheConst.LcDependHeader, dependency.ToString());
            }

            if (invalidation != null)
            {
                base.RequestHeaders.Add(LivecacheConst.LcUpdateHeader, invalidation.ToString());
            }

            _requestObjectForDbg = requestObjectForDbg;

        }

        public static HTTPAuthData CreateHTTPAuthData(
                ulong requestingUserId,
                LcserviceId lcserviceId,
                ulong xboxID,
                uint titleID)
        {
            return CreateHTTPAuthData(
                requestingUserId,
                lcserviceId,
                xboxID,
                titleID,
                0
                );
        }

        public static HTTPAuthData CreateHTTPAuthData(
                ulong requestingUserId,
                LcserviceId lcserviceId,
                ulong xboxID,
                uint titleID,
                byte tier)
        {
            LcserviceInfo si = LcserviceInfo.Lookup(lcserviceId);

            // get current language and country
            // when is CurrentLocaleHandler not set, default everything to zero.
            // also default to zero if the SPI is not locale sensitive (eg. does not return a string)
            uint langID = 0;
            uint countryID = 0;

            if (si.CultureSensitive && CurrentLocaleHandler != null)
            {
                CurrentLocaleHandler(out langID, out countryID);
            }

            // set user flags
            uint userFlags = 0;
            XUIDAndTrust.SetUserFlagCountry(ref userFlags, countryID);
            XUIDAndTrust.SetUserFlagLanguage(ref userFlags, langID);
            XUIDAndTrust.SetUserFlagTier(ref userFlags, tier);

            // build a XUIDAndTrust structure with userID and userFlags
            XUIDAndTrust[] userTrusts = new XUIDAndTrust[1];
            userTrusts[0] = new XUIDAndTrust(requestingUserId, userFlags, 0.0F);

            HTTPAuthData authData = new HTTPAuthData(
                0,  // port
                0,  // ip
                0,  // request ID
                xboxID,
                userTrusts,
                titleID,
                si.LiveServiceId,
                0);  // 2nd service ID

            authData.OverrideAuthDataFlags |= SGInfo.XONLINE_AUTHDATA_FLAGS_ISXENON_MASK;
            authData.OverrideLanguageID = (ushort)langID;
            return authData;
        }

        public DateTime ResponseExpiry
        {
            get
            {
                string expiry = (base.ResponseHeaders == null) ? null : base.ResponseHeaders["expires"];
                return (expiry == null) ? DateTime.Now : DateTime.Parse(expiry);
            }
        }

        public string ToDiagString()
        {
            StringBuilder sb = new StringBuilder();

            if (base.Hr == HResult.S_OK)
            {
                sb.Append("Livecache Request OK");
            }
            else
            {
                sb.Append("Livecache Request failed");
                // XRLException.Message already adds the hresult
                //sb.Append(", hr = ");
                //sb.Append((HResult) base.Hr);
            }

            sb.Append("\n\nRequest: ");
            if (_requestObjectForDbg != null)
            {
                sb.Append(_requestObjectForDbg.ToString());
            }
            else if (base.PostData != null)
            {
                sb.Append(DB400(base.PostData));
            }
            else
            {
                sb.Append("null");
            }

            sb.Append("\n\nResponse: ");
            if (base.ResponseOb != null)
            {
                sb.Append(base.ResponseOb.ToString());
            }
            else if (base.ResponseData != null)
            {
                sb.Append(DB400(base.ResponseData));
            }
            else
            {
                sb.Append("null");
            }
            sb.Append("\n\n");

            return sb.ToString();
        }
        private object _requestObjectForDbg;

        public uint GetEventID()
        {
            return _eventId;
        }
        private uint _eventId;

        // dump first 400 bytes to string
        protected string DB400(byte[] raw)
        {
            int len = Math.Min(400, raw.Length);
            return BitConverter.ToString(raw, 0, len);
        }

        public static LivecacheLocaleHandler CurrentLocaleHandler;

        private static void OnInterfaceBucketChange(object sender, InterfaceBucketChangeEventArgs e)
        {
            // need no action
        }

        private static InterfaceBucketChangeEventHandler _interfaceBucketChangeEventHandler = null;
    }

    public class LivecacheConst
    {
        public const string TargetXrl = "/Livecache/lcreq.ashx";
        public const string LcserviceIdHeader = "LC-ServiceId";
        public const string LcDependHeader = "LC-Depends";
        public const string LcUpdateHeader = "LC-Updates";

        public const int SN_CacheInvalidate = 9901;
        public const int SN_GetUserWebInfo = 2009;
    }

    public class LivecacheKey
    {
        public string Value
        {
            get
            {
                return _keyString;
            }
        }
        private string _keyString;

        public override int GetHashCode()
        {
            return _keyString.GetHashCode();
        }

        //
        // generate cache key from request arguments.
        //
        // currently, requests are considered same if they have the same userId,
        // livecache service id, and post data (request object).
        //
        // postData is base64 encoded for easy diagnosing
        //
        public LivecacheKey(
            int lcserviceId,
            ulong userId,
            byte[] postData
            )
        {
            _keyString = string.Format("{0:d}|{1:x}|{2}",
                lcserviceId,
                userId,
                Convert.ToBase64String(postData));
        }

        public static int QueryServiceId(string keyString)
        {
            return int.Parse(keyString.Split('|')[0]);
        }
    }

    public class LcserviceInfo
    {
        private static Hashtable _serviceMappingTbl = null;

        public uint LiveServiceId;
        public LivecacheDependencyRequired ExpectedDependency;
        public LivecacheDependencyRequired ExpectedInvalidation;
        public bool CultureSensitive;
        public uint EventId;

        public static LcserviceInfo Lookup(LcserviceId lcserviceId)
        {
            if (_serviceMappingTbl == null)
            {
                _serviceMappingTbl = LoadLivecacheServiceMapping();
            }

            LcserviceInfo si = (LcserviceInfo)(_serviceMappingTbl[(int)lcserviceId]);

            if (si == null)
            {
                throw new BadConfigException("npdb..t_livecache_apis", string.Format("Request made for unknown Livecache API {0}({1}). Check npdb..t_livecache_apis.", lcserviceId, (int)lcserviceId));
            }

            return si;
        }

        public static Hashtable LoadLivecacheServiceMapping()
        {
            Hashtable services = new Hashtable();
            Hashtable eventIDs = GetEventIdMappingTable();

            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "p_livecache_get_forward_service_list";
                SqlDataReader reader = cmd.Execute();

                while (reader.Read())
                {

                    int lcserviceId = (int)reader["i_lcservice_id"];
                    string viName = (string)reader["vc_virtual_interface"];

                    try
                    {
                        IVirtualInterfaceInfo interfaceInfo;
                        try
                        {
                            interfaceInfo = Config.GetVirtualInterface(viName, Site.main);
                        }
                        catch (ArgumentException)
                        {
                            continue;
                        }

                        LcserviceInfo si = new LcserviceInfo();
                        si.ExpectedDependency.Flags = (byte)reader["tn_required_dependency"];
                        si.ExpectedInvalidation.Flags = (byte)reader["tn_required_invalidation"];
                        si.CultureSensitive = (bool)reader["b_culture_sensitive"];
                        si.LiveServiceId = (uint)interfaceInfo.ServiceId;

                        try
                        {
                            si.EventId = (uint)eventIDs[lcserviceId];
                        }
                        catch (Exception)
                        {
                            si.EventId = (uint)SysEventID.LCR.Unknown;
                        }

                        services.Add(lcserviceId, si);
                    }
                    catch (Exception)
                    {
                        //
                        // log an error event but continue load the rest of the table.
                        // if we abort, we'll be called again on next request. before
                        // human intervention, we'll hit this error repeatedly while
                        // failing all requests. having some tolerance to the error
                        // seems the better choice.
                        //

                    }
                }
            }

            return services;
        }

        protected static Hashtable GetEventIdMappingTable()
        {
            Hashtable mapping = new Hashtable();

            mapping[(int)LcserviceId.GetFriends] = SysEventID.LCR.GetFriends;
            mapping[(int)LcserviceId.GetPresenceInfo] = SysEventID.LCR.GetPresenceInfo;
            mapping[(int)LcserviceId.AddFriend] = SysEventID.LCR.AddFriend;
            mapping[(int)LcserviceId.DeleteFriend] = SysEventID.LCR.DeleteFriend;
            mapping[(int)LcserviceId.AcceptFriendRequest] = SysEventID.LCR.AcceptFriendRequest;
            mapping[(int)LcserviceId.RejectFriendRequest] = SysEventID.LCR.RejectFriendRequest;
            mapping[(int)LcserviceId.QueryAffiliates] = SysEventID.LCR.QueryAffiliates;
            mapping[(int)LcserviceId.GetPublicPresenceInfo] = SysEventID.LCR.GetPublicPresenceInfo;
            mapping[(int)LcserviceId.WebAlive] = SysEventID.LCR.WebAlive;

            mapping[(int)LcserviceId.VetString] = SysEventID.LCR.VetString;
            mapping[(int)LcserviceId.StringLookup] = SysEventID.LCR.StringLookup;

            mapping[(int)LcserviceId.LinkWebAccount] = SysEventID.LCR.LinkWebAccount;
            mapping[(int)LcserviceId.CreateXboxComAccount] = SysEventID.LCR.CreateXboxComAccount;
            mapping[(int)LcserviceId.UpsGetProfile] = SysEventID.LCR.UpsGetProfile;
            mapping[(int)LcserviceId.UpsUpdateProfile] = SysEventID.LCR.UpsUpdateProfile;
            mapping[(int)LcserviceId.ReserveName] = SysEventID.LCR.ReserveName;
            mapping[(int)LcserviceId.UpdateXboxComActivity] = SysEventID.LCR.UpdateXboxComActivity;
            mapping[(int)LcserviceId.GetUserWebInfo] = SysEventID.LCR.GetUserWebInfo;
            mapping[(int)LcserviceId.GetLinkedGamertag] = SysEventID.LCR.GetLinkedGamertag;
            mapping[(int)LcserviceId.GetUserType] = SysEventID.LCR.GetUserType;
            mapping[(int)LcserviceId.GetAccountInfo] = SysEventID.LCR.GetAccountInfo;
            mapping[(int)LcserviceId.SetAccountInfo] = SysEventID.LCR.SetAccountInfo;

            mapping[(int)LcserviceId.SyncSettings] = SysEventID.LCR.SyncSettings;
            mapping[(int)LcserviceId.ReadSettings] = SysEventID.LCR.ReadSettings;
            mapping[(int)LcserviceId.EnumTitles] = SysEventID.LCR.EnumTitles;
            mapping[(int)LcserviceId.AchievementEnum] = SysEventID.LCR.AchievementEnum;
            mapping[(int)LcserviceId.PublicReadSettings] = SysEventID.LCR.PublicReadSettings;
            mapping[(int)LcserviceId.PublicEnumTitles] = SysEventID.LCR.PublicEnumTitles;

            mapping[(int)LcserviceId.StorageWrite] = SysEventID.LCR.StorageWrite;
            mapping[(int)LcserviceId.StorageRemove] = SysEventID.LCR.StorageRemove;
            mapping[(int)LcserviceId.StorageRead] = SysEventID.LCR.StorageRead;

            mapping[(int)LcserviceId.EnumerateMessages] = SysEventID.LCR.EnumerateMessages;
            mapping[(int)LcserviceId.GetMessageSummary] = SysEventID.LCR.GetMessageSummary;
            mapping[(int)LcserviceId.GetMessageDetails] = SysEventID.LCR.GetMessageDetails;
            mapping[(int)LcserviceId.DeleteMessage] = SysEventID.LCR.DeleteMessage;
            mapping[(int)LcserviceId.SetMessageFlags] = SysEventID.LCR.SetMessageFlags;
            mapping[(int)LcserviceId.SendMessage] = SysEventID.LCR.SendMessage;
            mapping[(int)LcserviceId.EnumerateSystemMessages] = SysEventID.LCR.EnumerateSystemMessages;
            mapping[(int)LcserviceId.GetSystemMessageDetails] = SysEventID.LCR.GetSystemMessageDetails;

            return mapping;
        }
    }

    public delegate void LivecacheLocaleHandler(out uint language, out uint country);

    public class LivecacheManager
    {

        private ulong _livePuid = 0;
        private uint _tier = 0;
        private uint[] _privileges = null;

        public static LivecacheManager Current = new LivecacheManager();

		public ulong LivePuid 
		{
			get 
			{
				return _livePuid;
			}
			set 
			{
				_livePuid = value;
			}
		}

		public uint Tier 
		{
			get 
			{
				return _tier;
			}
			set 
			{
				_tier = value;
			}
		}

        public uint[] Privileges
        {
            get
            {
                return _privileges;
            }
            set
            {
                _privileges = value;
            }
        }

        public static void LookupWebInfo(
            ulong livePuid,
            out uint tier,
            out uint[] privileges,
            out DateTime lastWebActivity,
            out byte parentalControlGroup)
        {
            XeGetUserWebInfoRequest req = new XeGetUserWebInfoRequest();
            req.userPuid = livePuid;

            LivecacheDependency dep = LivecacheDependency.UserAccount(livePuid);

            LivecacheRequest lcReq = new LivecacheRequest(livePuid, LcserviceId.GetUserWebInfo, req, dep, null);
            HResult hr = lcReq.Send();

            if (hr != HResult.S_OK)
            {
                throw new XRLException(hr, (XEvent.Id) XOn.XeventCommFailedError, "LookupWebInfo failed");
            }

            XeGetUserWebInfoResponse reply = new XeGetUserWebInfoResponse();
            reply.SetBytes(lcReq.ResponseData);

            tier = reply.tier;
            lastWebActivity = reply.lastWebActivity;
            privileges = reply.userPrivileges;
            parentalControlGroup = (byte)reply.parentalControlGroupId;
        }

        public LivecacheRequest CreateLivecacheRequest(LcserviceId lcserviceId,
                                                        XRLObject2 request2,
                                                        LivecacheDependency dependency,
                                                        LivecacheDependency invalidation)
        {
            return CreateLivecacheRequest(
                lcserviceId,
                request2.GetBytes(),
                0,
                XOn.WEB_TITLE_ID,
                dependency,
                invalidation,
                request2);
        }
        public LivecacheRequest CreateLivecacheRequest(
            LcserviceId lcserviceId,
            byte[] postData,
            ulong xboxID,
            uint titleID,
            LivecacheDependency dependency,
            LivecacheDependency invalidation,
            object requestObjectForDbg)
        {
            HTTPAuthData authData = LivecacheRequest.CreateHTTPAuthData(
                _livePuid, lcserviceId, xboxID, titleID, (byte)_tier);

            authData.OverridePrivileges = _privileges;

            return CreateLivecacheRequest(
                    lcserviceId,
                    postData,
                    authData,
                    dependency,
                    invalidation,
                    requestObjectForDbg);
        }

        public LivecacheRequest CreateLivecacheRequest(
            LcserviceId lcserviceId,
            byte[] postData,
            HTTPAuthData authData,
            LivecacheDependency dependency,
            LivecacheDependency invalidation,
            object requestObjectForDbg)
        {
            authData.OverridePrivileges = _privileges;

            return new LivecacheRequest(
                _livePuid, lcserviceId, postData, authData, dependency, invalidation, requestObjectForDbg);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\Unit\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__unit_2_none_12.4.56.0_none_4cd157f7eb531b04
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_unit_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c.manifest
XP_MANIFEST_PATH=manifests\x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c.cat
XP_CATALOG_PATH=manifests\x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c.cat
XP_PAYLOAD_PATH=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_unit_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\Unit\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__unit_2_none_12.4.56.0_none_4cd157f7eb531b04
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_unit_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c.manifest
XP_MANIFEST_PATH=manifests\x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c.cat
XP_CATALOG_PATH=manifests\x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c.cat
XP_PAYLOAD_PATH=x86__unit_2_no-public-key_12.4.56.0_x-ww_99b7c12c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_unit_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\GeneralInfo\Dll\GeneralInfo.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Web;
using System.Web.Services;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.webcache.common ;
using xonline.server.mgmt.soap;
using xonline.common.config;
using xonline.common.installer;

[assembly: XomIisInstallerAttribute( Interface.wcgeneral )]
[assembly: ConfigAttribute(xonline.common.config.Component.wcgeneral)]

[assembly: XomAreaDefinition(XomAreaName.wcgenerallog)]

namespace xonline.server.webcache.generalinfo.dll 
{
    [WebService(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
    public class GeneralInfo : System.Web.Services.WebService
    {
        public GeneralInfo()
        {
            try
            {
                utils = Utilities.Instance;
                    
                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();
                
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_9, e);
            }
        }

        #region Component Designer generated code
        
        //Required by the Web Services Designer 
        private IContainer components = null;
                
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);        
        }
        
        #endregion

        // Returns array of partner-filtered title info structs
        // Definition of TitlePrivilegeInfo comes from Utilities.cs
        [WebMethod]
        public TitlePrivilegeInfo[] GetTitleList(
            out uint ValidSeconds
            )
        {
            try
            {
                utils.CheckAPI("GeneralInfo.GetTitleList");
                
                WebCacheGeneralInfoCounter.Counters.GetTitleListRequestsPerSecond.Increment();
                WebCacheGeneralInfoCounter.Counters.GetTitleListRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCacheGeneralInfoCounter.Counters.GetTitleListFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheGeneralInfoCounter.Counters.GetTitleListFailedRequestsTotal);

                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheGeneralInfoCounter.Counters[partnerName].GetTitleListRequestsPerSecond.Increment();
                    WebCacheGeneralInfoCounter.Counters[partnerName].GetTitleListRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheGeneralInfoCounter.Counters[partnerName].GetTitleListFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheGeneralInfoCounter.Counters[partnerName].GetTitleListFailedRequestsTotal);
                }
                    
                string strTitleListValidSeconds = Config.GetSetting( Setting.wcgeneral_titleListValidSeconds );
                if ( strTitleListValidSeconds == null )
                {
                    ValidSeconds = 3600;
                }
                else
                {                    
                    ValidSeconds = UInt32.Parse( strTitleListValidSeconds );
                }

                TitlePrivilegeInfo[] titleInfo = utils.GetPartnerSpecificTitleInfo();

                string szLog = "GTL|"
                                + Utilities.GetSubjectName() + "|"
                                + Utilities.GetRequestID() + "|"
                                + Utilities.GetClientIPPort() + "|" 
                                + ValidSeconds.ToString() + "|"
                                + titleInfo.Length.ToString();

                Xom.Log(XomAreaName.wcgenerallog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                return titleInfo;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_10, e);
            }
        }

        public struct LinkInfo
        {
            public string GamerTag;
            public bool Owner;
        };

        [WebMethod]
        public LinkInfo[] LinkedGamerTags(
            byte[] WebID
            )
        {
            try
            {
                utils.CheckAPI("GeneralInfo.LinkedGamerTags");

                WebCacheGeneralInfoCounter.Counters.LinkedGamerTagsRequestsPerSecond.Increment();
                WebCacheGeneralInfoCounter.Counters.LinkedGamerTagsRequestsTotal.Increment();

                SoapFrontEndApp.AddErrorPerfCounter(WebCacheGeneralInfoCounter.Counters.LinkedGamerTagsFailedRequestsPerSecond);
                SoapFrontEndApp.AddErrorPerfCounter(WebCacheGeneralInfoCounter.Counters.LinkedGamerTagsFailedRequestsTotal);
                    
                string partnerName = Utilities.GetSubjectName();
                if (partnerName != null)
                {
                    WebCacheGeneralInfoCounter.Counters[partnerName].LinkedGamerTagsRequestsPerSecond.Increment();
                    WebCacheGeneralInfoCounter.Counters[partnerName].LinkedGamerTagsRequestsTotal.Increment();

                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheGeneralInfoCounter.Counters[partnerName].LinkedGamerTagsFailedRequestsPerSecond);
                    SoapFrontEndApp.AddErrorPerfCounter(WebCacheGeneralInfoCounter.Counters[partnerName].LinkedGamerTagsFailedRequestsTotal);
                }
                    
                PUIDAndOwner[] puids = utils.LookupWebID(WebID);

                LinkInfo[] linkInfo = new LinkInfo[puids.Length];
                int i;
                for(i=0; i<puids.Length; ++i)
                {
                    linkInfo[i].GamerTag = utils.LookupGamerTag(puids[i].PUID);
                    linkInfo[i].Owner = puids[i].Owner;
                }

                string szLog = "LNKD|"
                                + Utilities.GetSubjectName() + "|"
                                + Utilities.GetRequestID() + "|"
                                + Utilities.GetClientIPPort() + "|" 
                                + ByteConvert.ToReverseString(WebID) + "|"
                                + puids.Length;

                Xom.Log(XomAreaName.wcgenerallog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                return( linkInfo );
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_11, e);
            }
        }


        Utilities utils;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\GeneralInfo\Dll\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.generalinfo.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: GeneralInfo", "Xbox Live: Web Cache GeneralInfo performance counters" )]
    public class WebCacheGeneralInfoCounter : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "GetTitleList requests per second", 
             "Number of GetTitleList requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetTitleListRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetTitleList requests total", 
             "Total GetTitleList requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetTitleListRequestsTotal;

        [XomPerformanceCounterAttr(
             "GetTitleList failed requests per second", 
             "Number of failed GetTitleList requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetTitleListFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GetTitleList failed requests total", 
             "Total failed GetTitleList requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetTitleListFailedRequestsTotal;

        [XomPerformanceCounterAttr(
             "LinkedGamerTags requests per second", 
             "Number of LinkedGamerTags requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter LinkedGamerTagsRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "LinkedGamerTags requests total", 
             "Total LinkedGamerTags requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter LinkedGamerTagsRequestsTotal;

        [XomPerformanceCounterAttr(
             "LinkedGamerTags failed requests per second", 
             "Number of failed LinkedGamerTags requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter LinkedGamerTagsFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "LinkedGamerTags failed requests total", 
             "Total failed LinkedGamerTags requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter LinkedGamerTagsFailedRequestsTotal;


        public virtual WebCacheGeneralInfoCounter this[string partnerName]
        {
            get
            {
                return (WebCacheGeneralInfoCounter) GetInstance(partnerName);
            }
        }

        static public WebCacheGeneralInfoCounter Counters = new WebCacheGeneralInfoCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\Unit\unittest.cs ===
//
// UnitTest.cs
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//

using System;
using System.Diagnostics;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Text;

class WebSvcUnitTest
{
    [STAThread]
    static void Main(string[] args)
    {
        bool      suspend  = false;
        ArrayList testList = new ArrayList();
        bool      selective;

        foreach (string arg in args)
        {
            if (arg == "-suspend")
                suspend = true;
            else
                testList.Add(arg.ToLower());
        }

        selective = testList.Count > 0;
                
        Console.WriteLine("Web Services Unit Test\n");

        TimeDiff td = new TimeDiff();

        foreach (Type type in Assembly.GetExecutingAssembly().GetTypes())
        {
            foreach (Attribute attr in type.GetCustomAttributes(true))
            {
                if (!(attr is TestFixtureAttribute))
                    continue;

                if (selective && !testList.Contains(type.Name.ToLower()))
                    continue;
                
                Console.WriteLine(type.Name);
                
                foreach (MethodInfo method in type.GetMethods())
                {
                    foreach (Attribute mAttr in method.GetCustomAttributes(true))
                    {
                        if (!(mAttr is TestMethodAttribute))
                            continue;

                        Console.Write("\t{0,-35} ", method.Name);
                        
                        try
                        {
                            object o        = Activator.CreateInstance(type);
                            TimeDiff tdMeth = new TimeDiff();
                            
                            method.Invoke(o, null);
                            
                            Console.WriteLine("[OK] {0}", tdMeth);
                        }
                        catch (TargetInvocationException tie)
                        {
                            StringBuilder sb = new StringBuilder("TestMethod threw an exception:\n");
                            Exception     e  = tie.InnerException;

                            while (true)
                            {
                                sb.Append(e.GetType().ToString());
                                sb.Append(": ");
                                sb.Append(e.ToString());
                                e = e.InnerException;
                                if (e == null)
                                    break;

                                sb.Append("  ---->  ");
                            }

                            sb.Append("\n**** End ****");

                            Debug.Assert(false, sb.ToString());
                        }

                    }
                }
            }
        }

        GC.Collect();
        GC.WaitForPendingFinalizers();
            
        Console.WriteLine("\nTest completed. Execution time {0}.", td);

        if (suspend)
        {
            Console.WriteLine("Execution suspended. ^C to exit.");

            while (true)
            {
                System.Threading.Thread.Sleep(10000);
                GC.Collect();
                GC.WaitForPendingFinalizers();
            }
        }
    }

}

class TestFixtureAttribute : Attribute
{
    public TestFixtureAttribute() {}
}

class TestMethodAttribute : Attribute
{
    public TestMethodAttribute() {}
}


class TimeDiff
{
    public override string ToString()
    {
        return (DateTime.Now - start).ToString();
    }

    private DateTime start = DateTime.Now;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\GeneralInfo\Test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\common\Stubs\WebSvcTestHelpStub.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="WebSvcTestHelpSoap", Namespace="http://websvc.xboxlive.com/WebSvcTestHelp/")]
public class WebSvcTestHelp : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public WebSvcTestHelp() {
        this.Url = "http://192.168.86.135:8094/WebSvcTestHelp/WebSvcTestHelp.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/WebSvcTestHelp/ReadLeaderboardInfo", RequestNamespace="http://websvc.xboxlive.com/WebSvcTestHelp/", ResponseNamespace="http://websvc.xboxlive.com/WebSvcTestHelp/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public WebDBLeaderBoardInfo[] ReadLeaderboardInfo() {
        object[] results = this.Invoke("ReadLeaderboardInfo", new object[0]);
        return ((WebDBLeaderBoardInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReadLeaderboardInfo(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReadLeaderboardInfo", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public WebDBLeaderBoardInfo[] EndReadLeaderboardInfo(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((WebDBLeaderBoardInfo[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/WebSvcTestHelp/ReadLeaderBoardNames", RequestNamespace="http://websvc.xboxlive.com/WebSvcTestHelp/", ResponseNamespace="http://websvc.xboxlive.com/WebSvcTestHelp/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public string[] ReadLeaderBoardNames() {
        object[] results = this.Invoke("ReadLeaderBoardNames", new object[0]);
        return ((string[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReadLeaderBoardNames(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReadLeaderBoardNames", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public string[] EndReadLeaderBoardNames(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((string[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/WebSvcTestHelp/SetLeaderboardInfo", RequestNamespace="http://websvc.xboxlive.com/WebSvcTestHelp/", ResponseNamespace="http://websvc.xboxlive.com/WebSvcTestHelp/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void SetLeaderboardInfo(WebDBLeaderBoardInfo lb) {
        this.Invoke("SetLeaderboardInfo", new object[] {
                    lb});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSetLeaderboardInfo(WebDBLeaderBoardInfo lb, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SetLeaderboardInfo", new object[] {
                    lb}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSetLeaderboardInfo(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/WebSvcTestHelp/NukeTitleId", RequestNamespace="http://websvc.xboxlive.com/WebSvcTestHelp/", ResponseNamespace="http://websvc.xboxlive.com/WebSvcTestHelp/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void NukeTitleId(int titleID) {
        this.Invoke("NukeTitleId", new object[] {
                    titleID});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginNukeTitleId(int titleID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("NukeTitleId", new object[] {
                    titleID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndNukeTitleId(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/WebSvcTestHelp/")]
public class WebDBLeaderBoardInfo {
    
    /// <remarks/>
    public int titleID;
    
    /// <remarks/>
    public int lbid;
    
    /// <remarks/>
    public System.Byte resetType;
    
    /// <remarks/>
    public int pageSize;
    
    /// <remarks/>
    public int expireSeconds;
    
    /// <remarks/>
    public System.DateTime lastChange;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\GeneralInfo\Test\dvt\main.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Globalization;
using System.Security.Cryptography.X509Certificates;
using xonline.common.mgmt;
using xonline.common.service;

class WebSvcTest
{
    /// <summary>
    /// The main entry point for the application.
    /// </summary>
    [STAThread]
    static void Main(string[] args)
    {
        if (args.Length == 0 || args[0].CompareTo("/?") == 0 )
        {
            Console.Write("Usage:\n\tWebSvcTest.exe WebServiceMachine [<DER type Client Certificate to use with testnet web services>]\n");
            return;
        }

        GeneralInfo g;
        
        if (args.Length >= 2 && (args[1].EndsWith(".CER") || args[1].EndsWith(".cer")))
        {
            g = new GeneralInfo("https://"+args[0]+"/generalinfo/generalinfo.asmx");
            
            X509Certificate x509 = X509Certificate.CreateFromCertFile(@args[1]);
            g.ClientCertificates.Add(x509); 
            Console.WriteLine("Certificate:\"" + x509.Subject + "\" is being used\n"); 
        }
        else
        {
            g = new GeneralInfo("http://"+args[0]+"/generalinfo/generalinfo.asmx");
        }

        int loopCount = 5;
        if (args.Length >= 3)
        {
            loopCount = Int32.Parse(args[2]);
        }
        
        int i,j;
        uint validSeconds = 0;
        TitlePrivilegeInfo[] result = null;
        LinkInfo[] result2 = null;
        byte[] webID1;
        string PUID1 = "2814749767106558";

        {
            MemoryStream memStream = new MemoryStream(8);
            BinaryWriter writer = new BinaryWriter(memStream);
            writer.Write( UInt64.Parse(PUID1,NumberStyles.HexNumber) );
            webID1 = memStream.ToArray();
        }
                
        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
        for (i=0; i<loopCount; ++i)
        {
            result = g.GetTitleList(out validSeconds);
        }
        
        Console.WriteLine("\nLoop of {0} calls to GetTitleList took {1} ms\n", loopCount, timeElapsed.MillisecondsElapsed);

        for (i=0; i<result.Length; ++i)
        {
            Console.WriteLine("Title:{0} {1} {2} {3}", result[i].TitleID.ToString("X8"), result[i].Privileges, result[i].Rating, result[i].DefaultLocale);
            if (result[i].LocalizedName != null)
            {
                for (j=0; j<result[i].LocalizedName.Length; ++j)
                {
                    Console.WriteLine("  Locale:{0} DisplayName:{1}", result[i].LocalizedName[j].Locale, result[i].LocalizedName[j].DisplayName);
                }
            }
        }
            
        Console.WriteLine("GetTitleList validSeconds:{0} [OK]", validSeconds);

        timeElapsed = new XomRequestTimeElapsed();
        for (i=0; i<loopCount; ++i)
        {
            result2 = g.LinkedGamerTags(webID1);
        }
        Console.WriteLine("\nLoop of {0} calls to LinkedGamerTags 1 took {1} ms\n", loopCount, timeElapsed.MillisecondsElapsed);
        Console.WriteLine("LinkedGamerTags ["+((result2.Length == 0) ? "OK" : (result2.Length.ToString() + " " + result2[0].GamerTag + " " + result2[0].Owner.ToString()))+"]");

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\dll\readsitekeys.cs ===
//-------------------------------------------------
//  readsitekeys.cs :  Reads sitekeys from UODB.
//  Author: lohab
//  Date:  Nov.03/03
//-------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using Microsoft.Webstore.WstClient;
    
using xonline.common.config;
using xonline.common.crypto;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.webcache.common;

[assembly: XomAreaDefinition(XomAreaName.readsitekeys)]

namespace xonline.server.webcache.liveproxy.dll 
{
    /// <summary>
    /// ReadSiteKeys:  Reads all site keys from the UODB.
    /// </summary>
    internal class ReadSiteKeys 
    {
        // constructor
        public ReadSiteKeys( int sitekeytype, int masterkeyversion )
        {
            _sitekeytype = sitekeytype;
            _masterkeyversion = masterkeyversion;
            _keysData = new Hashtable();

            // create the instance of the main crypto wrapper class.
            if ( _cryptoWrp != null )
            {
                Marshal.ReleaseComObject( _cryptoWrp );
                _cryptoWrp = null;
            }
            _cryptoWrp = new XoCryptoWrapperClass();
                

            GetSiteKeysFromDB();
        }
        
        /// <summary>
        /// Gets the desired site key from our tables.
        /// </summary>
        /// <param name="siteid">Site id of the key in demand.</param>
        /// <param name="nKeyVersion">The key version for this key. </param>
        /// <returns>The desired site key in a byte array.</returns>
        public byte[] GetSiteKey( int siteid, int nKeyVersion )
        {
            byte[] result = null;
            Hashtable keysDataRef = null;

            keysDataRef = _keysData;
         
            if ( keysDataRef.Contains( (object)siteid ) )
            {
                if ( ((Hashtable)(keysDataRef[siteid])).Contains( (object)nKeyVersion ) )
                {
                    result = (byte[])(((Hashtable)(keysDataRef[siteid]))[nKeyVersion]);
                }
            }
            return result;
        }

        public Hashtable GetSiteKeys( uint siteid )
        {
            Hashtable result = null;
            Hashtable keysDataRef = null;

            keysDataRef = _keysData;
            
            if ( keysDataRef.Contains( (object)siteid ) )
            {
                result = (Hashtable)(keysDataRef[siteid]);
            }
            else
            {
                result = new Hashtable();
            }
            
            return result;
        }

        /// <summary>
        /// Gets the site keys from the UODB.
        /// Uses Webstore 3.0 managed code.
        /// </summary>
        public void GetSiteKeysFromDB()
        {
            Hashtable newkeysData = new Hashtable();            
            SqlConnection conn = null;

            try
            {
                conn = new SqlConnection( Config.NpdbConnectionString );
                            
                // Open a connection                
                conn.Open();
                       
                // Create a command to call the stored procedure
                using (SqlCommand command = conn.CreateCommand())
                {
                    command.CommandTimeout = Config.NpdbConnectionTimeout;
                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = "dbo.p_lpxy_get_site_keys";
                            
                    // add the key type and master key version.
                    command.Parameters.Add("@i_keyType", SqlDbType.Int).Value = _sitekeytype;

                    // Execute stored procedure
                    using ( SqlDataReader dReader = command.ExecuteReader() )
                    {
                        while ( dReader.Read() )
                        {
                            // read the key information from the result set.
                            int     nKeyVersion = 0 ;
                            uint    keysize = 0;
                            uint    nSiteId = 0;
                            int     nMasterKeyVersion = 0;
                            byte[]  encryptedKey = null;
                            
                            // retrieve the information.
                            nKeyVersion = dReader.GetInt32( 0 );
                            nMasterKeyVersion = dReader.GetInt32( 2 );
                            nSiteId = (uint)dReader.GetInt32( 3 );

                            // get the bytes out of the result set...
                            keysize = (uint)dReader.GetBytes(1,0,null,0,512);
                            encryptedKey = new byte[keysize];
                            dReader.GetBytes(1,0,encryptedKey,0,(int)keysize);

                            // decrypt the key and store the result.
                            if ( ! newkeysData.ContainsKey( nSiteId ) )
                            {
                                newkeysData[nSiteId] = new Hashtable();
                                ((Hashtable)(newkeysData[nSiteId]))[nKeyVersion] = _cryptoWrp.DecryptWithMasterKeyWrp( (uint)nMasterKeyVersion, keysize, encryptedKey );
                                Xom.Trace(XomAreaName.readsitekeys, LogLevel.L_LOW, "LiveProxy has loaded site key: " + nSiteId + " version: " + nKeyVersion );
                            }
                            else
                            {
                                ((Hashtable)(newkeysData[nSiteId]))[nKeyVersion] = _cryptoWrp.DecryptWithMasterKeyWrp( (uint)nMasterKeyVersion, keysize, encryptedKey );
                                Xom.Trace(XomAreaName.readsitekeys, LogLevel.L_LOW, "LiveProxy has loaded site key: " + nSiteId + " version: " + nKeyVersion );
                            }

                            string szLog = "GSK|" 
                                + nSiteId.ToString("X")    + "|"
                                + nMasterKeyVersion      + "|"
                                + nKeyVersion   + "|1";

                            Xom.Log(XomAreaName.livepxylog, szLog );
                            Xom.Log(XomAreaName.Reporting_v2, szLog );
                        }
                    }
                }
                
                // replace old data with the new stuff.
                _keysData = newkeysData;
            }
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.readsitekeys, LogLevel.L_ERROR, e.ToString() );
                throw new UODBAccessException("p_lpxy_get_site_keys", e);
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn.Dispose();
                    conn = null;
                }                
            }

        }        

        static protected XoCryptoWrapperClass _cryptoWrp = null;
        static protected Hashtable _keysData;
        static protected int _sitekeytype;
        static protected int _masterkeyversion;
    }
}   // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\dll\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.webcache.liveproxy.dll 
{

    [XomPerformanceCounterCategoryAttr( "WebCache: LiveProxy", "Xbox Live: Xbox Live Proxy Widget" )]
    public class WebCacheLiveProxy : XomPerformanceCounterCategory
    {
        // Requests.
        [XomPerformanceCounterAttr(
             "Requests per second", 
             "Number of requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter LiveProxyRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Requests total", 
             "Total requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter LiveProxyRequestsTotal;

        [XomPerformanceCounterAttr(
             "Requests failures per second", 
             "Number of failed requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter LiveProxyFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Requests failures total", 
             "Total failed requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter LiveProxyFailedRequestsTotal;

        // Forward requests.
        [XomPerformanceCounterAttr(
             "Forward requests per second", 
             "Number of forward requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ForwardRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Forward requests total", 
             "Total forward requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter ForwardRequestsTotal;

        [XomPerformanceCounterAttr(
             "Forward request failures per second", 
             "Number of failed forward requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailedForwardRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Forward request failures total", 
             "Total failed forward requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailedForwardRequestsTotal;

        // SiteInfo
        [XomPerformanceCounterAttr(
             "SiteInfo Requests per second", 
             "Number of site information requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SiteInfoRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "SiteInfo Requests total", 
             "Total site informaiton requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SiteInfoRequestsTotal;

        [XomPerformanceCounterAttr(
             "SiteInfo Request failures per second", 
             "Number of failed site information requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SiteInfoFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "SiteInfo Request failures total", 
             "Total failed site information requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SiteInfoFailedRequestsTotal;

        // LookupPUID
        [XomPerformanceCounterAttr(
             "PUID Lookup Requests per second", 
             "Number of PUID lookup requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PUIDLookupRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "PUID Lookup Requests total", 
             "Total PUID lookup requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PUIDLookupRequestsTotal;

        [XomPerformanceCounterAttr(
             "PUID Lookup Request failure per second", 
             "Number of failed PUID lookup requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PUIDLookupFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "PUID Lookup Request failures total", 
             "Total failed PUID lookup requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter PUIDLookupFailedRequestsTotal;

        // LookupGamerTag
        [XomPerformanceCounterAttr(
             "GamerTag Lookup Requests per second", 
             "Number of GamerTag lookup requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GTLookupRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GamerTag Lookup Requests total", 
             "Total GamerTag lookup requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GTLookupRequestsTotal;

        [XomPerformanceCounterAttr(
             "GamerTag Lookup Request failure per second", 
             "Number of failed GamerTag lookup requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GTLookupFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "GamerTag Lookup Request failures total", 
             "Total failed GamerTag lookup requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GTLookupFailedRequestsTotal;

        // GetSitePUIDs
        [XomPerformanceCounterAttr(
             "Get Site PUID Requests per second", 
             "Number of get site PUID requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetSitePUIDRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Get Site PUID Requests total", 
             "Total get site PUID requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetSitePUIDRequestsTotal;

        [XomPerformanceCounterAttr(
             "Get Site PUID Request failure per second", 
             "Number of failed get site PUID requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetSitePUIDFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "Get Site PUID Request failures total", 
             "Total failed get site PUID requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetSitePUIDFailedRequestsTotal;

        // LspAdvertise
        [XomPerformanceCounterAttr(
             "LspAdvertise calls/sec", 
             "LspAdvertise calls/sec", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter LspAdvertiseRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "LspAdvertise calls total", 
             "LspAdvertise calls total", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter LspAdvertiseRequestsTotal;

        [XomPerformanceCounterAttr(
             "LspAdvertise failures/sec", 
             "LspAdvertise failures/sec", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter LspAdvertiseFailedRequestsPerSecond;

        [XomPerformanceCounterAttr(
             "LspAdvertise failures total", 
             "LspAdvertise failures total", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter LspAdvertiseFailedRequestsTotal;

        public virtual WebCacheLiveProxy this[string partnerName]
        {
            get
            {
                return (WebCacheLiveProxy) GetInstance(partnerName);
            }
        }

        static public WebCacheLiveProxy Counters = new WebCacheLiveProxy();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\dll\liveproxy.cs ===
//-------------------------------------------------
//  LiveProxy.cs :  Proxy widget to forward requests.
//  Author: lohab
//  Date:  Nov.03/03
//-------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Net;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using System.Text;
using System.Collections;
using System.Collections.Specialized;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security.Principal;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.config;
using xonline.common.service;
using xonline.server.webcache.common;
using xonline.common.installer;

[assembly: XomIisInstallerAttribute( Interface.livepxy )]
[assembly: ConfigAttribute(Component.livepxy)]

[assembly: XomAreaDefinition(XomAreaName.livepxy)]
[assembly: XomAreaDefinition(XomAreaName.livepxylog)]

namespace xonline.server.webcache.liveproxy.dll 
{
    public class LiveProxy : IHttpHandler
    {        
        /// <summary>
        ///  ProcessRequest:  Process the HTTP request.
        /// </summary>
        /// <param name="ctx"></param>
        public void ProcessRequest(HttpContext ctx)
        {
            try 
            {
                Initialize();
                HttpRequest request = ctx.Request;
                string action = (request.Url.Segments[request.Url.Segments.Length-1]).ToLower();

                WebCacheLiveProxy.Counters.LiveProxyRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.LiveProxyRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_LOW, "LiveProxy::ProcessRequest: Action = " + action );

                switch(action)
                {
                    case "forwardrequest.aspx":
                    {
                        ForwardRequest(ctx);
                    }
                        break;
                    case "getsiteinfo.aspx":
                    {
                        TransmitSiteKeys( ctx );
                    }
                        break;
                    case "lookuppuid.aspx":
                    {
                        LookupPUIDs( ctx );
                    }
                        break;
                    case "lookupgamertag.aspx":
                    {
                        LookupGamertags( ctx );
                    }
                        break;
                    case "getsitepuids.aspx":
                    {
                        ReturnSitePUIDs( ctx );
                    }
                        break;
                    case "lspadvertise.aspx":
                    {
                        LspAdvertise( ctx );
                    }
                        break;
                    default:
                        throw new XboxWebInternalException( XEvent.Id.LIVEPROXY_INVALID_MSGFORMAT_2, "LiveProxy:  Unexpected request.  Please monitor offender." );
                }

            }
            catch (XboxWebException xwe)
            {
                // increment failure counters.
                WebCacheLiveProxy.Counters.LiveProxyFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.LiveProxyFailedRequestsTotal.Increment();

                ctx.Response.StatusCode = 500;
                ctx.Response.ContentType = "text/html";
                ctx.Response.Write( "<html>" + xwe.Message + "</html>");

                throw;
            }
            catch (Exception e)
            {
                // increment failure counters.
                WebCacheLiveProxy.Counters.LiveProxyFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.LiveProxyFailedRequestsTotal.Increment();

                ctx.Response.StatusCode = 500;
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_12, e);
            }
            finally 
            {
                ctx.Response.End();
                ctx.Response.Close();
            }

        } // end ProcessRequest

        /// <summary>
        /// Initialize - initial components of this object.
        /// </summary>
        protected void Initialize()
        {
            string[] fwdHdrArray = null;

            // check to see if this has already been initialized.
            if( _initialize == 1 && Interlocked.CompareExchange(ref _initialize,0,1)== 1)
            {
                // get a utils instance.
                _utils = Utilities.Instance;

                _mgmt = new Mgmt(this, "Live Proxy (LSP Widget)");

                _serviceTable = new Hashtable();

                //get the forward headers
                fwdHdrArray = GetSettingWithDefault(Setting.livepxy_forwardHeaders, "content-type, user-agent").Split(',');
                _fwdHeaderSet = new HybridDictionary( fwdHdrArray.Length );
                foreach ( string fwdHdr in fwdHdrArray )
                {
                    // put it in the hybriddictionary.  Depending on how many entries we have, the hybrid dictionary
                    // will use either the hashtable or ListDictionary implementation to make our lookups faster.
                    _fwdHeaderSet.Add( fwdHdr.Trim().ToLower(), 1 );
                }

                LoadForwardingServiceTable();
                Xom.Trace(XomAreaName.livepxy, LogLevel.L_NORMAL, "LiveProxy::LiveProxy: Config loaded:  Number of services = " + _serviceTable.Count );

                // add livee proxy mgmt commands
                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(LiveProxy.OnControlRequest);

                try
                {
                    _sitekeys = new ReadSiteKeys( 
                        Int32.Parse( GetSettingWithDefault(Setting.livepxy_SiteKeyType, "6") ),
                        Int32.Parse( GetSettingWithDefault(Setting.livepxy_MasterKeyVersion, "1") )
                        );
                }
                catch (Exception)
                {
                    // no site keys... we'll have to initialize again.
                    _initialize = 0;
                    throw;
                }
            }
        }

        /// <summary>
        /// TransmitSiteKeys:  Transmits site keys for a desired site.
        /// </summary>
        protected void TransmitSiteKeys( HttpContext ctx )
        {
            Hashtable keytable = null;
            SiteInfoReply siReply = null;
            byte[] reply = null;
            uint siteid = 0;

            try
            {
                WebCacheLiveProxy.Counters.SiteInfoRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.SiteInfoRequestsTotal.Increment();

                if ( _sitekeys == null )
                {
                    _sitekeys = new ReadSiteKeys( 
                        Int32.Parse( GetSettingWithDefault(Setting.livepxy_SiteKeyType, "6") ),
                        Int32.Parse( GetSettingWithDefault(Setting.livepxy_MasterKeyVersion, "1") )
                        );
                }

                // ensure the given content type is valid.
                if ( ctx.Request.ContentType.ToLower() != "xon/0" )
                {
                    // invalid content type.
                    throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_4, 
                        "Content-Type is invalid.",
                        "LiveProxy::TransmitSiteKeys: Incoming message has an invalid content-type.  Expected Content-Type xon/0, but got Content-Type " + ctx.Request.ContentType );
                }

                // read the request data.
                byte[] requestData = new byte[ ctx.Request.InputStream.Length ];
                ctx.Request.InputStream.Read( requestData, 0, requestData.Length );

                // ensure that the POST buffer isn't too big or small.  4 is the size of 1 DWORD
                if ( requestData.Length != c_INT32_SIZE )
                {
                    throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_5, 
                        "Request is invalid.",
                        "LiveProxy::TransmitSiteKeys: Incoming message has a Entity body of size " + ctx.Request.InputStream.Length + ";  The body size should be " + c_INT32_SIZE + ".  Please monitor this sender.");
                }

                // determine which site this is for.               
                MemoryStream ms = new MemoryStream( requestData );
                BinaryReader br = new BinaryReader( ms );

                siteid = br.ReadUInt32();
                br.Close();

                // check API...  
                // @@@ also need to make sure the client has access to this site
                _utils.CheckAPIAndTitle( "LiveProxy.GetSiteInfo", siteid, TitlePrivilege.ReadOnly  );

                // get the hashtable with keys for this site.
                keytable = _sitekeys.GetSiteKeys( siteid );

                siReply = new SiteInfoReply( keytable.Count );

                // copy all the keys into the reply.
                foreach ( int version in keytable.Keys ) 
                {                
                    siReply.AddKey( (uint)version, (byte[])(keytable[version]) );
                }
    
                siReply.SetCurrentTime();
                reply = siReply.GetBinary();
    
                ctx.Response.ContentType = "xon/0";
                ctx.Response.BinaryWrite( reply );

                string szLog = "TSI|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + siteid + "|" + keytable.Count + "|1";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

            }
            catch( XboxWebException xwe )
            {
                WebCacheLiveProxy.Counters.SiteInfoFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.SiteInfoFailedRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, xwe.ToString() + "\n\n"
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + siteid );

                string szLog = "TSI|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + siteid +"|0|0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                throw;
            }
            catch( Exception e )
            {
                WebCacheLiveProxy.Counters.SiteInfoFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.SiteInfoFailedRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, e.ToString() + "\n\n"
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + siteid );

                string szLog = "TSI|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + siteid +"|0|0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_13, e);
            }

        }
        
        /// <summary>
        /// ForwardRequest:
        /// </summary>
        /// <param name="ctx">The Http context for this request.</param>
        protected void ForwardRequest( HttpContext ctx )
        {
            int contentLength = ctx.Request.ContentLength;
            string desiredservice = "";
            string stringTitleId = "";
            bool successful = false;
            uint titleId = 0;
            
            try
            {
                WebCacheLiveProxy.Counters.ForwardRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.ForwardRequestsTotal.Increment();

                // get the desired service from the URL
                desiredservice = ctx.Request.Headers.Get(c_ForwardRequestHeader);

                if ( desiredservice == null )
                {
                    // log the request... throw an error.
                    throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_6,
                        "Request is invalid.",
                        "LiveProxy:  No XRL was specified in the request header (\"xrl\" header).  This could be a hacker.  Please monitor." );
                }

                // look up the services host name.
                if ( _serviceTable == null )
                {
                    // log the request... throw an error.
                    throw new XboxWebException( XEvent.Id.WEBCACHE_CONFIG_0,
                        "LiveProxy is currently not available.",
                        "LiveProxy:  No service table exists.  LiveProxy should have services for request forwarding." );
                }

                // check in we know about the desired service.
                if ( ! _serviceTable.Contains( desiredservice.ToLower() ) )
                {
                    // log the request... throw an error.
                    throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_7,
                        "Request is invalid.",
                        "LiveProxy:  The desired service " + desiredservice.ToLower().ToString() + " is unknown to LiveProxy.  Possible hacker, please investigate." );
                }

                // extract the title id if possible.
                stringTitleId = ctx.Request.Headers.Get( c_TitleIdHeader );
                if ( stringTitleId == null )
                {
                    titleId = 0;
                }
                else
                {
                    // get the hex value.
                    titleId = UInt32.Parse( stringTitleId, System.Globalization.NumberStyles.HexNumber );
                }

                // check if this requestor has permission.
                _utils.CheckAPIAndTitle( desiredservice.ToLower(), titleId, TitlePrivilege.FullControl );

                // create a stream to the desired service.
                ServiceNode sn = (ServiceNode)_serviceTable[desiredservice.ToLower()];

                // ensure we have content to forward.
                if ( contentLength <= 0 )
                {
                    // no content.  No forward.
                    throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_8,
                        "Request is invalid.",
                        "LiveProxy:  No data exists in the forward request.  Possible hacker, please investigate." );                    
                }

                // get the virtual interface
                IVirtualInterfaceInfo serviceVInterface = Config.GetVirtualInterface( sn._viface, sn._siteid );
                                                         
                // fwdhttprequest will send the important details and translate the response.
                successful = FwdHttpRequest( "http://" + serviceVInterface.IPAddressString + ":" + serviceVInterface.Port.ToString() + desiredservice,
                    (uint)(serviceVInterface.ServiceId),
                    titleId,
                    ctx.Request.BinaryRead( contentLength ),
                    ctx );

                string szLog = "FRQ|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + desiredservice                + "|"
                    + (successful?"1":"0");

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            catch( XboxWebException xwe)
            {
                WebCacheLiveProxy.Counters.FailedForwardRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.FailedForwardRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, xwe.ToString() + "\n\n"
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + desiredservice
                    );

                string szLog = "FRQ|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + desiredservice + "|0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                ctx.Response.StatusCode = 500;
                
                BinaryWriter bw = new BinaryWriter(ctx.Response.OutputStream);
                bw.Write(Encoding.ASCII.GetBytes(xwe.Message));

                throw;
            }
            catch( Exception e )
            {
                WebCacheLiveProxy.Counters.FailedForwardRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.FailedForwardRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, e.ToString() + "\n\n"
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + desiredservice
                    );

                string szLog = "FRQ|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + desiredservice + "|0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_14, e);
            }
        }

        // Provides connection pooling and adds AuthData to HTTP Header
        // Implemented using System.Net.WebClient
        protected bool FwdHttpRequest( 
            String Url,
            uint serviceId,
            uint titleId,
            byte[] postData, 
            HttpContext ctx )
        {
            WebClient myWebClient = new WebClient();
            byte[] responseArray = null;
            HTTPAuthData authData = null;
            bool successful = false;

            Utilities.RequestInfo requestInfo = Utilities.GetRequestInfo();
            
            // add the header to the forward request.
            foreach ( string hdr in ctx.Request.Headers )
            {
                if ( _fwdHeaderSet.Contains( hdr.ToLower() ) )
                {
                    myWebClient.Headers.Add( hdr, ctx.Request.Headers[hdr] );
                }
            }
            
            // create authdata for this entry.
            XUIDAndTrust[] userList = new XUIDAndTrust[1];
            userList[0].qwUserID = Utilities.GetRequestorUserPUID();
            
            authData = new HTTPAuthData(
                requestInfo.ClientPort, 
                requestInfo.ClientIP, 
                requestInfo.qwRequestID, 
                Utilities.GetRequestorMachinePUID(),
                userList, 
                titleId, 
                serviceId, 
                0);
             
                
            // add the authdata header
            myWebClient.Headers.Add(XHttpHdr.HTTPAUTHDATA,authData.GetBase64EncodedString());
            try
            {
                // get the request.
                responseArray = myWebClient.UploadData(Url, "POST", postData);
                ctx.Response.StatusCode = 200;
                // put all the returned headers into the reply.
                foreach( string headerKey in myWebClient.ResponseHeaders )
                {
                    if ( headerKey.ToLower() == "server" || headerKey.ToLower() == "date")
                    {
                        continue;
                    }
                    ctx.Response.AddHeader( headerKey , myWebClient.ResponseHeaders[headerKey] );
                }

                successful = true;
            }
            catch (WebException e)
            {
                // look for a response.
                if ( e.Response != null )
                {   
                    // copy over the status code.
                    ctx.Response.StatusCode = (int)((HttpWebResponse)e.Response).StatusCode;

                    // copy the response headers if available.
                    if ( e.Response.Headers != null )
                    {
                        foreach( string headerKey in e.Response.Headers )
                        {
                            if ( headerKey.ToLower() == "server" || headerKey.ToLower() == "date")
                            {
                                continue;
                            }
                            ctx.Response.AddHeader( headerKey , e.Response.Headers[headerKey] );
                        }
                    }
                    
                    // collect the response body if exists.                
                    if ( e.Response.ContentLength > 0 )
                    {
                        responseArray = new byte[ e.Response.ContentLength ];
                        e.Response.GetResponseStream().Read( responseArray, 0, responseArray.Length );
                        e.Response.Close();
                    }
                    else                    
                    {
                        MemoryStream ms = new MemoryStream();
                        BinaryWriter bw = new BinaryWriter( ms );
                        Stream responseStream = e.Response.GetResponseStream();
                        byte[] streamData = new byte[256];
                        int dataRead = 0;
                        // no content-length header.  Let's try to get the information we need from the stream.

                        // read what you can from the stream... 256 bytes at a time.
                        dataRead = responseStream.Read( streamData, 0, 256 );
                        while ( dataRead > 0 )
                        {
                            // write what we have to the response stream array.
                            bw.Write( streamData, 0, dataRead );
                            // read some more....
                            dataRead = responseStream.Read( streamData, 0, 256 );                            
                        }

                        bw.Close();

                        // collect our array.
                        responseArray = ms.ToArray();
                    }
                }
                else
                {
                    ctx.Response.StatusCode = 500;
                    responseArray = new byte[0];
                    Xom.NtEvent( XEvent.Id.WEBCACHE_UNKNOWN_ERROR_15, e, "LiveProxy:  Forward Request failed with unexpected error.  Please check system configuration.");
                }
                
            }
            
            // only perform the binary write if we have data to write.
            if ( responseArray != null && responseArray.Length > 0 )
            {
                ctx.Response.BinaryWrite( responseArray );
            }

            return successful;
        }

        protected void LookupPUIDs( HttpContext ctx )
        {
            PUIDInfo puidReader = new PUIDInfo();
            GamerTagInfo gtWriter = null;
            
            try
            {
                WebCacheLiveProxy.Counters.PUIDLookupRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.PUIDLookupRequestsTotal.Increment();

                VerifyContentTypeAndLength( ctx, "LookupPUIDs" );

                // check API...  
                _utils.CheckAPI( "LiveProxy.LookupPUIDs" );

                // read PUID data out of POST body.
                puidReader.ReadBinary( ctx.Request.BinaryRead( ctx.Request.ContentLength ) );
                if ( puidReader.Count > Int32.Parse( GetSettingWithDefault(Setting.livepxy_maxPUIDLookupsPerRequest, "50") ) )
                {
                    throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_9, 
                                                "Request is invalid.",
                                                "LiveProxy::LookupPUIDs: Incoming message has requested " + 
                                                    puidReader.Count + 
                                                    " PUID lookups.  We allow only " + 
                                                    Int32.Parse( GetSettingWithDefault(Setting.livepxy_maxPUIDLookupsPerRequest, "50") ) + 
                                                    " lookups at a time.  Please monitor this sender.");
                }

                gtWriter = new GamerTagInfo( puidReader.Count );

                // for each PUID given... return a gamertag.
                foreach ( ulong PUID in puidReader.PUIDs )
                {
                    string gamertag = _utils.LookupGamerTag( PUID );
                    if ( Utilities.IsInvalidGamertag(gamertag) )
                    {
                        gamertag = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
                    }
                    gtWriter.AddGamerTag( gamertag );
                }

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_LOW, "LiveProxy::LookupPUIDs: Given PUIDs: " + puidReader.ToString() + ", Attained GamerTags:  " + gtWriter.ToString() );

                // write response back to stream.
                ctx.Response.ContentType = "xon/0";
                ctx.Response.BinaryWrite( gtWriter.GetBinary() );

                string szLog = "LPD|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + "1";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            catch ( XboxWebException xwe)
            {
                WebCacheLiveProxy.Counters.PUIDLookupFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.PUIDLookupFailedRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, xwe.ToString() + "\n\n" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()
                    );

                string szLog = "LPD|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + "0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                throw;
            }
            catch( Exception e )
            {
                WebCacheLiveProxy.Counters.PUIDLookupFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.PUIDLookupFailedRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, e.ToString() + "\n\n" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()
                    );

                string szLog = "LPD|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + "0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_16, e);
            }

        }

        protected void LookupGamertags( HttpContext ctx )
        {
            GamerTagInfo gtReader = new GamerTagInfo();
            PUIDInfo puidWriter = null;

            try
            {
                WebCacheLiveProxy.Counters.GTLookupRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.GTLookupRequestsTotal.Increment();

                VerifyContentTypeAndLength( ctx, "LookupGamertags" );
                
                // check API...  
                _utils.CheckAPI( "LiveProxy.LookupGamerTags" );
                
                // read all gamertags
                gtReader.ReadBinary( ctx.Request.BinaryRead( ctx.Request.ContentLength ) );
                puidWriter = new PUIDInfo( gtReader.Count );

                // for each gamertag... look up corresponding PUID.
                foreach ( string gamertag in gtReader.Gamertags )
                {
                    ulong associatedPUID = _utils.LookupXuidByGamertag( gamertag );
                    Xom.Trace(XomAreaName.livepxy, LogLevel.L_LOW, "LiveProxy::LookupGamertags: PUID: " + associatedPUID.ToString() );
                    puidWriter.AddPUID( associatedPUID );
                }

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_LOW, "LiveProxy::LookupGamertags: Given Gamertags: " + gtReader.ToString() + ", Attained PUIDs:  " + puidWriter.ToString() );

                // write response back to stream.
                ctx.Response.ContentType = "xon/0";
                ctx.Response.BinaryWrite( puidWriter.GetBinary() );

                string szLog = "LGT|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + "1";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            catch (XboxWebException xwe)
            {
                WebCacheLiveProxy.Counters.GTLookupFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.GTLookupFailedRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, xwe.ToString() + "\n\n"
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()
                    );

                string szLog = "LGT|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + "0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
                throw;
            }
            catch( Exception e )
            {
                WebCacheLiveProxy.Counters.GTLookupFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.GTLookupFailedRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, e.ToString() + "\n\n"
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()
                    );

                string szLog = "LGT|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + "0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_17, e);
            }

        }

        protected void ReturnSitePUIDs( HttpContext ctx )
        {
            ulong machinePUID = 0;
            ulong userPUID = 0;
            
            try
            {
                WebCacheLiveProxy.Counters.GetSitePUIDRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.GetSitePUIDRequestsTotal.Increment();

                // ensure the given content type is valid.
                if ( ctx.Request.ContentType.ToLower() != "xon/0" )
                {
                    // invalid content type.
                    throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_10, 
                        "Content-Type is invalid.",
                        "LiveProxy::ReturnSitePUIDs: Incoming message has an invalid content-type.  Content-Type = " + ctx.Request.ContentType );
                }

                // check API...  
                _utils.CheckAPI( "LiveProxy.GetSitePUIDs" );
                
                // get the machine and user puids from utilities.
                machinePUID = Utilities.GetRequestorMachinePUID();
                userPUID    = Utilities.GetRequestorUserPUID();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_LOW, "LiveProxy::ReturnSitePUIDs:  For SubjectName: " 
                    + Utilities.GetSubjectName() 
                    + " --> Machine PUID: " 
                    + machinePUID.ToString("X")  
                    + ", User PUID: " 
                    + userPUID.ToString("X")
                    );

                // write response back to stream.
                ctx.Response.ContentType = "xon/0";
                ctx.Response.BinaryWrite( System.BitConverter.GetBytes(machinePUID) );
                ctx.Response.BinaryWrite( System.BitConverter.GetBytes(userPUID) );

                string szLog = "GSP|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + machinePUID.ToString("X")     + "|" 
                    + userPUID.ToString("X")        + "|1";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );
            }
            catch ( XboxWebException xwe )
            {
                WebCacheLiveProxy.Counters.GetSitePUIDFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.GetSitePUIDFailedRequestsTotal.Increment();
                
                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, xwe.ToString() + "\n\n"
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + machinePUID.ToString("X")
                    );

                string szLog = "GSP|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + machinePUID.ToString("X")     + "|" 
                    + userPUID.ToString("X")        + "|0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                throw;
            }
            catch( Exception e )
            {
                WebCacheLiveProxy.Counters.GetSitePUIDFailedRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.GetSitePUIDFailedRequestsTotal.Increment();

                Xom.Trace(XomAreaName.livepxy, LogLevel.L_ERROR, e.ToString() + "\n\n"
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + machinePUID.ToString("X")
                    );

                string szLog = "GSP|" 
                    + Utilities.GetSubjectName()    + "|"
                    + Utilities.GetRequestID()      + "|"
                    + Utilities.GetClientIPPort()   + "|"
                    + machinePUID.ToString("X")     + "|" 
                    + userPUID.ToString("X")        + "|0";

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog );

                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_18, e);
            }
        }

        protected void LspAdvertise( HttpContext ctx )
        {
            LspAdvertiseRequest request = null;
            bool ok = false;

            try
            {
                WebCacheLiveProxy.Counters.LspAdvertiseRequestsPerSecond.Increment();
                WebCacheLiveProxy.Counters.LspAdvertiseRequestsTotal.Increment();

                // ensure the given content type is valid.
                if ( ctx.Request.ContentType.ToLower() != "xon/0" )
                {
                    // invalid content type.
                    throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_11, 
                        "Content-Type is invalid.",
                        "LiveProxy::LspAdvertise: Incoming message has an invalid content-type.  Content-Type = " + ctx.Request.ContentType );
                }
                
                //
                // read request
                //
                
                byte[] requestBytes = new byte[ctx.Request.InputStream.Length];
                ctx.Request.InputStream.Read(requestBytes, 0, requestBytes.Length);

                //
                // verify that the site has access to this API
                //
                request = new LspAdvertiseRequest();
                request.ReadStream(new MemoryStream(requestBytes));

                _utils.CheckAPIAndTitle("LiveProxy.LspAdvertise", request.titleId, 
                                        TitlePrivilege.FullControl);

                // 
                // forward request
                //

                IVirtualInterfaceInfo queryVi = Config.GetVirtualInterface(
                    VirtualInterface.xqry_int, Site.main);

                string url = string.Format("http://{0}:{1}{2}",
                                           queryVi.IPAddressString,
                                           queryVi.Port.ToString(),
                                           request.Xrl);

                ok = FwdHttpRequest(url, (uint)XOService.Query, request.titleId, 
                                    requestBytes, ctx);
            }
            catch (XboxWebException e)
            {
                ctx.Response.StatusCode = 500;
                
                BinaryWriter bw = new BinaryWriter(ctx.Response.OutputStream);
                bw.Write(Encoding.ASCII.GetBytes(e.Message));

                throw;
            }
            finally
            {
                if(!ok)
                {
                    WebCacheLiveProxy.Counters.LspAdvertiseFailedRequestsPerSecond.Increment();
                    WebCacheLiveProxy.Counters.LspAdvertiseFailedRequestsTotal.Increment();
                }

                string szLog = string.Join("|", new string[] { 
                    "LspAdvertise",
                    request != null ? "0x"+request.titleId.ToString("X8") : "0",
                    ok ? "0" : "1" });

                Xom.Log(XomAreaName.livepxylog, szLog );
                Xom.Log(XomAreaName.Reporting_v2, szLog);
            }
        }

        // ----------------------------------------------------
        //  Mgmt Commands

        static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                _mgmt.ControlRequest(args);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_CONTROL_REQUEST_ERROR, e);
            }
        }

        
        [MgmtHandler("ReloadKeys", "Reloads all site key information from the UODB.")]
        public string ProcessReloadKeys(string[] args)
        {
            string result = "";
            WindowsImpersonationContext ctx = null;

            // If this extra catch looks odd to you, then maybe you haven't read http://msdn.microsoft.com/en-us/ms182322.aspx.
            // Mind you, there's a comment at the bottom that indicates you don't need to do this anymore, but I trust our
            // current version of FxCop more than I trust some comment on MSDN.
            try
            {
                try
                {
                    ctx = Utilities.Instance.ImpersonationId.Impersonate();

                    if ( _sitekeys == null )
                    {
                        _sitekeys = new ReadSiteKeys( 
                            Int32.Parse( GetSettingWithDefault(Setting.livepxy_SiteKeyType, "6") ),
                            Int32.Parse( GetSettingWithDefault(Setting.livepxy_MasterKeyVersion, "1") )
                            );
                    }

                    _sitekeys.GetSiteKeysFromDB();

                    result = "Success.  See log for which keys were loaded.";
                }
                finally
                {
                    if (ctx != null)
                    {
                        ctx.Undo();
                    }
                }
            }
            catch (Exception e)
            {
                result = "Error: " + e.Message.ToString();
            }

            return "Reload Keys Complete.  Result: " + result;
        }

        // ----------------------------------------------------
        //  Tools

        public string GetSettingWithDefault( string setting, string strDefault )
        {
            string result = "";

            result = Config.GetSetting( setting );
            if ( result == null )
            {
                Xom.NtEvent( XEvent.Id.WEBCACHE_CONFIG_1, "Missing setting for " + setting.ToString() + ".  Using default value in it's place. Default: " + strDefault );
                result = strDefault;
            }
            
            return result;
        }

        public bool IsReusable
        {
            get { return true; }
        }

        protected void VerifyContentTypeAndLength( HttpContext ctx, string callingProc )
        {
            // ensure the given content type is valid.
            if ( ctx.Request.ContentType.ToLower() != "xon/0" )
            {
                // invalid content type.
                throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_12, 
                    "Content-Type is invalid.",
                    "LiveProxy::" + callingProc + ": Incoming message has an invalid content-type.  Content-Type = " + ctx.Request.ContentType );
            }

            // ensure we have content to handle.
            if ( ctx.Request.ContentLength <= 0 )
            {
                // no content.  No forward.
                throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_13,
                    "No Content.  Request is invalid." );                    
            }
        }

        protected void LoadForwardingServiceTable()
        {
            using(SqlConnection npdbCnt = new SqlConnection(Config.NpdbConnectionString))
            {
                npdbCnt.Open();
                SqlCommand cmd = new SqlCommand("p_livepxy_get_forward_service_list", npdbCnt);
                cmd.CommandType = CommandType.StoredProcedure;
                                
                SqlDataReader reader = cmd.ExecuteReader();
                
                while ( reader.Read() )
                {
                    string xrl = "";
                    
                    ServiceNode newService = new ServiceNode();

                    xrl = reader.GetString(0);

                    // convert the string to an enum value
                    string strVirtualInterface = reader.GetString(1);
                    try
                    {
                        newService._viface= strVirtualInterface;
                    }
                    catch (ArgumentException e)
                    {
                        throw new Exception(
                            "Virtual Interface element "
                            + reader.GetString(1)
                            +"' is not a valid virtual interface name.",
                            e);
                    }

                    newService._siteid = reader.GetInt32(2);
                    _serviceTable[ xrl ] = newService;


                    Xom.Trace(XomAreaName.livepxy, LogLevel.L_NORMAL, "LiveProxy::LiveProxy: Config loaded:  SiteID: " 
                        + newService._siteid
                        + ", XRL: " 
                        + xrl
                        + ", Virtual Interface: "
                        + strVirtualInterface
                        );
                }
                
                npdbCnt.Close();
            }

        }
        
        // constant values.
        public    const  string c_ForwardRequestHeader  = "xrl";
        public    const  string c_SiteIdHeader          = "siteid";
        public    const  string c_TitleIdHeader         = "title-id";
        public    const  int    c_INT32_SIZE            = 4;
        public    const  int    c_INT64_SIZE            = 8;

        // static members
        static public    Utilities                      _utils;        
        static protected Hashtable                      _serviceTable;
        static private   ReadSiteKeys                   _sitekeys;
        static protected int                            _numOfServices;
        static protected int                            _initialize = 1;
        static protected HybridDictionary               _fwdHeaderSet;

        static private   Mgmt                           _mgmt = null;

    }    // end LiveProxy 

    /// <summary>
    /// ServerNode:  
    /// </summary>
    class ServiceNode: object
    {
        public string           _viface;
        public int              _siteid;
    }

    /// <summary>
    /// Key data values.
    /// </summary>
    struct KeyData
    {
        public uint     _keyVersion;
        public byte[]   _key;
    }

    /// <summary>
    /// SiteInfoReply:  Response to site info request.
    /// </summary>
    class SiteInfoReply
    {
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="_maxNumberOfKeys">Number of values expected in the array.</param>
        public SiteInfoReply( int _maxNumberOfKeys )
        {
            _numberOfKeys = 0;
            _curFileTime = 0;
            
            // create the array of keys
            _keys = new KeyData[_maxNumberOfKeys];

        }

        /// <summary>
        /// Sets the time value.
        /// </summary>
        public void SetCurrentTime()
        {
            // get the current time in UTC.  Convert to FILETIME.
            _curFileTime = (ulong)DateTime.Now.ToFileTime();
        }

        /// <summary>
        /// Adds a key to the response.
        /// </summary>
        /// <param name="version">Version of this key</param>
        /// <param name="key">The key itself.</param>
        public void AddKey( uint version, byte[] key )
        {
            KeyData kd = new KeyData();
            kd._keyVersion = version;
            kd._key = key;

            _keys.SetValue( kd, (int)_numberOfKeys );
            _numberOfKeys++;
        }

        /// <summary>
        /// Constructs the binary form to be returned.
        /// </summary>
        /// <returns>byte array representation of this class.</returns>
        public byte[] GetBinary()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );

            bw.Write( _curFileTime );
            bw.Write( _numberOfKeys );

            for ( int x = 0; x < _numberOfKeys; x++ )
            {
                bw.Write( _keys[x]._keyVersion );
                bw.Write( _keys[x]._key, 0, _keys[x]._key.Length );
            }

            bw.Close();

            return ms.ToArray();
        }

        ulong       _curFileTime;
        uint        _numberOfKeys;
        KeyData[]   _keys;
    }

    /// <summary>
    /// PUIDInfo:  structure to read and reply to PUID data.
    /// </summary>
    class PUIDInfo
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public PUIDInfo( uint expectedNumberOfPUIDs )
        {
            _numberOfPUIDs = 0;
            _PUIDs = new ulong[expectedNumberOfPUIDs];
        }

        public PUIDInfo( )
        {
            _numberOfPUIDs = 0;
            _PUIDs = null;
        }

        /// <summary>
        /// ReadBinary:  Reads binary data and puts it into the puid list.
        /// </summary>
        /// <param name="data">binary data to stream.</param>
        public void ReadBinary( byte[] data )
        {
            MemoryStream ms = new MemoryStream( data );
            BinaryReader br = new BinaryReader( ms );

            // make sure we have enough data in the buffer for this action.
            // ensure we have content to handle.
            if ( data.Length < LiveProxy.c_INT32_SIZE )
            {
                // no content.  No forward.
                throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_14,
                    "Request is invalid.  You have not provided enough POST data for this request.",
                    "LiveProxy: PUIDInfo::ReadBinary():  No data exists in the lookup request.  Possible hacker, please investigate." );                    
            }

            // get the expected number of PUIDs
            _numberOfPUIDs = br.ReadUInt32();

            //  Ensure the given buffer is at least large enough for us to read from.
            if ( _numberOfPUIDs * LiveProxy.c_INT64_SIZE != data.Length - LiveProxy.c_INT32_SIZE )
            {
                throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_15,
                                            "Request is invalid.  The given buffer is not the correct size to lookup by " + _numberOfPUIDs + " PUIDs.  Expected size: " + ( LiveProxy.c_INT32_SIZE + (_numberOfPUIDs * LiveProxy.c_INT64_SIZE)) + " bytes.  Received size: " + data.Length + ".",
                                            "LiveProxy: PUIDInfo::ReadBinary(): Request is invalid.  The given buffer is not the correct size to look up " + _numberOfPUIDs + " PUIDs.  Expected size: " + ( LiveProxy.c_INT32_SIZE + (_numberOfPUIDs * LiveProxy.c_INT64_SIZE)) + " bytes.  Received size: " + data.Length + "." );
            }

            // check if we have a null array
            if ( _PUIDs == null )
            {
                _PUIDs = new ulong[_numberOfPUIDs];
            }

            // ensure out array is big enough
            if ( _PUIDs.Length < _numberOfPUIDs )
            {
                throw new XboxWebInternalException( XEvent.Id.WEBCACHE_HACK_16,
                    "LiveProxy: PUIDInfo::ReadBinary():  Invalid usage of class.  Array size isn't big enough for incoming data.");
            }

            // add all the PUIDs to a list.
            for ( int x = 0; x < _numberOfPUIDs; x++ )
            {
                _PUIDs[x] = br.ReadUInt64();
            }

            br.Close();
        }

        /// <summary>
        /// Add a PUID the the PUID list.  Should only be used if class created with expectedNumberOfPUIDs
        ///   and not read from binary.
        /// </summary>
        /// <param name="PUID">PUID to add</param>
        public void AddPUID( ulong PUID )
        {
            if ( _PUIDs == null )
            {
                throw new XboxWebInternalException( XEvent.Id.WEBCACHE_HACK_17, 
                                            "LiveProxy: PUIDInfo::AddPUID():  Invalid usage of class.  You must specify a size before adding new PUIDs");
            }

            Xom.Trace(XomAreaName.livepxy, LogLevel.L_LOW, "LiveProxy::AddPUID: Adding GamerTag: " + PUID.ToString() + ", index: " + _numberOfPUIDs );

            _PUIDs[_numberOfPUIDs] = PUID;
            _numberOfPUIDs++;
        }

        /// <summary>
        /// Constructs the binary form to be returned.
        /// </summary>
        /// <returns>byte array representation of this class.</returns>
        public byte[] GetBinary()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );

            bw.Write( _numberOfPUIDs );

            for ( int x = 0; x < _numberOfPUIDs; x++ )
            {
                bw.Write( _PUIDs[x] );
            }
            
            bw.Close();   

            return ms.ToArray();
        }

        public override string ToString()
        {
            string result = "";
            for ( int x = 0; x < _numberOfPUIDs; x++ )
            {
                if ( result.Length > 0 )
                {
                    result += "|" + _PUIDs[x].ToString();
                }
                else
                {
                    result = _PUIDs[x].ToString();
                }
            }

            return result;
        }

        /// <summary>
        /// PUIDs:  Enumerator access to the PUID list.
        /// </summary>
        public ulong[] PUIDs
        {
            get 
            {
                return _PUIDs; 
            }
        }
       
        /// <summary>
        /// Count:  number of puids in list.
        /// </summary>
        public uint Count
        {
            get 
            {
                return _numberOfPUIDs; 
            }
        }

        protected uint        _numberOfPUIDs;
        protected ulong[]     _PUIDs;
    }

    /// <summary>
    /// GamerTagInfo:  structure to read and reply to gamertag data.
    /// </summary>
    class GamerTagInfo
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public GamerTagInfo( uint expectedNumberOfGTs )
        {
            _numberOfGTs = 0;
            _GamerTags = new string[expectedNumberOfGTs];
        }

        public GamerTagInfo( )
        {
            _numberOfGTs = 0;
            _GamerTags = null;
        }

        /// <summary>
        /// ReadBinary:  Reads binary data and puts it into the gamertag list.
        /// </summary>
        /// <param name="data">binary data to stream.</param>
        public void ReadBinary( byte[] data )
        {
            MemoryStream ms = new MemoryStream( data );
            BinaryReader br = new BinaryReader( ms );

            // make sure we have enough data in the buffer for this action.
            // ensure we have content to handle.
            if ( data.Length < LiveProxy.c_INT32_SIZE )
            {
                // no content.  No forward.
                throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_18,
                    "Request is invalid.  You have not provided enough POST data for this request.",
                    "LiveProxy: GamerTagInfo::ReadBinary():  No data exists in the lookup request.  Possible hacker, please investigate." );                    
            }

            // get the expected number of PUIDs
            _numberOfGTs = br.ReadUInt32();

            //  Ensure the given buffer the correct size.
            if ( _numberOfGTs * (c_GAMERTAG_SIZE) != data.Length - LiveProxy.c_INT32_SIZE )
            {
                throw new XboxWebException( XEvent.Id.WEBCACHE_HACK_19,
                    "Request is invalid.  The given buffer is not the correct size to lookup by " + _numberOfGTs + " GamerTags.  Expected size: " + (LiveProxy.c_INT32_SIZE + (_numberOfGTs * c_GAMERTAG_SIZE)) + " bytes.  Received size: " + data.Length + ".",
                    "LiveProxy:GamerTagInfo::ReadBinary(): Request is invalid.  The given buffer is not the correct size to look up " + _numberOfGTs + " GamerTags.  Expected size: " + (LiveProxy.c_INT32_SIZE + (_numberOfGTs * c_GAMERTAG_SIZE)) + " bytes.  Received size: " + data.Length + "." );
            }

            // check if we have a null array
            if ( _GamerTags == null )
            {
                _GamerTags = new string[_numberOfGTs];
            }

            // ensure out array is big enough
            if ( _GamerTags.Length < _numberOfGTs )
            {
                throw new XboxWebInternalException( XEvent.Id.WEBCACHE_HACK_20, 
                            "LiveProxy: GamerTagInfo::ReadBinary() Invalid usage of class.  Array size isn't big enough for incoming data.");
            }

            // add all the PUIDs to a list.
            for ( int x = 0; x < _numberOfGTs; x++ )
            {
                // read data...  (note... UNICODE characters are 2 bytes.)
                byte[] newgamertag = br.ReadBytes( (int)c_GAMERTAG_SIZE );

                string stringgamertag = System.Text.UnicodeEncoding.Unicode.GetString( newgamertag, 0, newgamertag.Length ).Trim('\0');
                try 
                {
                    System.Text.UTF8Encoding.UTF8.GetBytes( stringgamertag );
                    _GamerTags[x] = stringgamertag;
                    Xom.Trace(XomAreaName.livepxy, LogLevel.L_LOW, "LiveProxy::ReadBinary: Adding GamerTag: " + stringgamertag + ", index: " + x );
                }
                catch ( Exception e )
                {
                    throw new XboxWebInternalException(XEvent.Id.LIVEPROXY_INVALID_CHARACTER_SUBMISSION, "LiveProxy: GamerTagInfo::ReadBinary() The given gamertag contains invalid UTF-8 characters.", e);
                }
            }

            br.Close();
        }

        /// <summary>
        /// Add a gamertag to the gamertag list.  Should only be used if class created with expectedNumberOfGts
        ///   and not read from binary.
        /// </summary>
        /// <param name="gamertag">gamertag to add</param>
        public void AddGamerTag( string gamertag )
        {
            if ( _GamerTags == null )
            {
                throw new XboxWebInternalException( XEvent.Id.WEBCACHE_HACK_22, 
                    "LiveProxy: GamerTagInfo::AddGamerTag() Invalid usage of class.  You must specify a size before adding new PUIDs");
            }

            Xom.Trace(XomAreaName.livepxy, LogLevel.L_LOW, "LiveProxy::AddGamerTag: Adding GamerTag: " + gamertag + ", index: " + _numberOfGTs );

            _GamerTags[_numberOfGTs] = gamertag;
            _numberOfGTs++;
        }

        /// <summary>
        /// Constructs the binary form to be returned.
        /// </summary>
        /// <returns>byte array representation of this class.</returns>
        public byte[] GetBinary()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );

            bw.Write( _numberOfGTs );

            // go through all gamertags.
            for ( int x = 0; x < _numberOfGTs; x++ )
            {
                byte[] binaryGT = System.Text.UnicodeEncoding.Unicode.GetBytes( _GamerTags[x].PadRight( (int)c_GAMERTAG_LENGTH, (char)0 ) );
                bw.Write( binaryGT, 0, binaryGT.Length );
            }

            bw.Close();

            return ms.ToArray();
        }
        
        public override string ToString()
        {
            string result = "";
            for ( int x = 0; x < _numberOfGTs; x++ )
            {
                if ( result.Length > 0 )
                {
                    result += "|" + _GamerTags[x];
                }
                else
                {
                    result = _GamerTags[x];
                }
            }

            return result;
        }

        /// <summary>
        /// Gamertags:  Enumerator access to the gamertag list.
        /// </summary>
        public string[] Gamertags
        {
            get 
            {
                return _GamerTags; 
            }
        }

        /// <summary>
        /// Count:  number of puids in list.
        /// </summary>
        public uint Count
        {
            get 
            {
                return _numberOfGTs; 
            }
        }


        public const uint c_GAMERTAG_SIZE   = 32;
        public const uint c_GAMERTAG_LENGTH = 16;
       
        protected uint        _numberOfGTs;
        protected string[]    _GamerTags;
    }

}   // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\FuncGetSitePUID.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace LSPWidget
{
	/// <summary>
	/// Summary description for FuncLSPGetSitePUID.
	/// </summary>
    [TestGroup, Owner("johnmcp"), TestFrequency("Daily")]
	public class FuncGetSitePUID : TestNode
	{
		public static string httpServer = Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();

		// Get Site Info
		// Site exists
        [TestCase, Description("LSP_GetSitePUID"), TestCasePriority(1)]
		class LSP_GetSitePUID : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestGetSitePUIDs thisTest = new TestGetSitePUIDs(httpServer);
                    thisTest.SubjectName = "t2client2";

					thisTest.Run();

					string result = thisTest.ToString();

					if((result.IndexOf("MachinePUID:") != -1) &&
						(result.IndexOf("UserPUID:") != -1) &&
						(result.IndexOf("Content-Type = xon/0") != -1)
						)
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}

        [TestCase, TestCasePriority(2)]
        [CompoundCase("Empty", "")]
        [CompoundCase("Foo", "Foo")]
        [CompoundCase("test.xbltest.rdo.002", "test.xbltest.rdo.002")]
		class N_LSP_GetSitePUID : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				TestGetSitePUIDs thisTest = new TestGetSitePUIDs(httpServer);
				thisTest.SubjectName = (string) MyValues[0];

				try
				{
					thisTest.Run();
					ResultCode = TEST_RESULTS.FAILED;
				}
				catch(Exception e)
				{
					if(!(e.ToString().IndexOf("(500) Internal Server Error") > 0))
					{
						Global.RO.Error("Exception without Internal Server Error:\r\n{1}", e);
						ResultCode = TEST_RESULTS.FAILED;
					}
				}
			}
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\FuncLSPLookupGamerTag.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace LSPWidget
{
	/// <summary>
	/// Summary description for FuncLSPSiteInfo.
	/// </summary>
    [TestGroup, Owner("johnmcp"), TestFrequency("Daily")]
	public class FuncLSPLookupGamerTag : TestNode
	{
		public static string httpServer = Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();

		// Get Gamer Tag
        [TestCase, Description("LSP_LookupGamerTag_Basic"), TestCasePriority(1)]
		class LSP_LookupGamerTag_Basic : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestLookupGamerTag thisTest = new TestLookupGamerTag(httpServer, 1);

					thisTest.AddGamerTag("webuser1");
					thisTest.Run();

					string result = thisTest.ToString();

					int PUIDStart = result.LastIndexOf('\n');
					string sPUID = result.Substring(PUIDStart+1);
					if((sPUID != "0") &&
						(result.IndexOf("Content-Type = xon/0") != -1))
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}

		// Get Gamer Tag
		// Multiple Gamer Tags
        [TestCase, Description("Basic_LSP_LookupGamerTag_Multiple"), TestCasePriority(1)]
		class LSP_LookupGamerTag_Multiple : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.PASSED;
					char[] seperators = new char[1]{'|'};
					string[] PUIDArray = new string[3];

					TestLookupGamerTag thisTest = new TestLookupGamerTag(httpServer, 3);

					thisTest.AddGamerTag("webuser1");
					thisTest.AddGamerTag("webuser334");
					thisTest.AddGamerTag("webuser2");
					thisTest.Run();

					string result = thisTest.ToString();

					int PUIDStart = result.LastIndexOf('\n');
					string sPUIDs = result.Substring(PUIDStart+1);
					PUIDArray = sPUIDs.Split(seperators,PUIDArray.Length);
					foreach(string s in PUIDArray)
					{
						// If any of the PUIDs are 0, we fail
						if(s.Equals("0"))
							ResultCode = TEST_RESULTS.FAILED;
					}
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}

		// Get Gamer Tag
		// Same Gamer Tags
        [TestCase, Description("LSP_LookupGamerTag_Same"), TestCasePriority(2)]
		class LSP_LookupGamerTag_Same : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.PASSED;
					char[] seperators = new char[1]{'|'};
					string[] PUIDArray = new string[3];

					TestLookupGamerTag thisTest = new TestLookupGamerTag(httpServer, 3);

					thisTest.AddGamerTag("webuser3");
					thisTest.AddGamerTag("webuser3");
					thisTest.AddGamerTag("webuser3");
					thisTest.Run();

					string result = thisTest.ToString();

					int PUIDStart = result.LastIndexOf('\n');
					string sPUIDs = result.Substring(PUIDStart+1);
					PUIDArray = sPUIDs.Split(seperators,PUIDArray.Length);
					string previousString = PUIDArray[0];
					foreach(string s in PUIDArray)
					{
						// If any of the PUIDs are 0, we fail
						if(!s.Equals(previousString))
							ResultCode = TEST_RESULTS.FAILED;

						previousString = s;
					}
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}

		// Get Gamer Tag
		// Mix of valid and invalid gamer tags
        [TestCase, Description("LSP_LookupGamerTag_Mix"), TestCasePriority(2)]
		class LSP_LookupGamerTag_Mix : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.PASSED;
					char[] seperators = new char[1]{'|'};
					string[] PUIDArray = new string[3];

					TestLookupGamerTag thisTest = new TestLookupGamerTag(httpServer, 3);

					thisTest.AddGamerTag("webuser3");
					thisTest.AddGamerTag("webuserFoo");
					thisTest.AddGamerTag("webuser4");
					thisTest.Run();

					string result = thisTest.ToString();

					int PUIDStart = result.LastIndexOf('\n');
					string sPUIDs = result.Substring(PUIDStart+1);
					PUIDArray = sPUIDs.Split(seperators,PUIDArray.Length);
					string previousString = PUIDArray[0];

					// If the second gamer tag is not 0 we bail
					if(!PUIDArray[1].Equals("0"))
						ResultCode = TEST_RESULTS.FAILED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}

		// Get Gamer Tag
		// Tag doesn't exist
        [TestCase, Description("LSP_LookupGamerTag_NA"), TestCasePriority(2)]
		class LSP_LookupGamerTag_NA : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestLookupGamerTag thisTest = new TestLookupGamerTag(httpServer, 1);

					thisTest.AddGamerTag("somedumbguy");
					thisTest.Run();

					string result = thisTest.ToString();

					int PUIDStart = result.LastIndexOf('\n');
					string sPUID = result.Substring(PUIDStart+1);
					if(sPUID == "0")
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}

		// Get Gamer Tag
		// Bad Tag characters
        [TestCase, Description("LSP_LookupGamerTag_Bad"), TestCasePriority(3)]
		class LSP_LookupGamerTag_Bad : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.PASSED;
					string[] PUIDArray = new string[4];
					char[] seperators = new char[1]{'|'};
					TestLookupGamerTag thisTest = new TestLookupGamerTag(httpServer, (uint)PUIDArray.Length);

					thisTest.AddGamerTag("  webuser5");
					thisTest.AddGamerTag("  webuser5  ");
					thisTest.AddGamerTag("webuser5 ");
					thisTest.AddGamerTag("webuser5 \\ ");
					thisTest.Run();

					string result = thisTest.ToString();

					int PUIDStart = result.LastIndexOf('\n');
					string sPUID = result.Substring(PUIDStart+1);
					PUIDArray = sPUID.Split(seperators,PUIDArray.Length);
					foreach(string s in PUIDArray)
					{
						// If any of the PUIDs are not 0, we bail
						if(!s.Equals("0"))
							ResultCode = TEST_RESULTS.FAILED;
					}
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\FuncLSPPUIDLookup.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace LSPWidget
{
    [TestGroup, Owner("johnmcp"), TestFrequency("Daily")]
	public class FuncLSPPUIDLookup : TestNode
	{
		public static string httpServer = Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();

		// PUID Lookup
		// PUID exists
        [TestCase, Description("LSP_PUIDLookup"), TestCasePriority(1)]
		class LSP_PUIDLookup : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					// Look up the PUID for a gamer tag
					TestLookupGamerTag tLookUpGT = new TestLookupGamerTag(httpServer, 1);

					tLookUpGT.AddGamerTag("webuser77");
					tLookUpGT.Run();

					string result = tLookUpGT.ToString();
					int PUIDStart = result.LastIndexOf('\n');
					string sPUID = result.Substring(PUIDStart+1);
					ulong PUIDtoLookup = (ulong)System.Convert.ToInt64(sPUID,10);

					// Now lets look up the PUID and see if we get the right gamer tag
					TestLookupPUID thisTest = new TestLookupPUID(httpServer, 1);

					thisTest.AddPUID(PUIDtoLookup);

					thisTest.Run();

					result = thisTest.ToString();

					if((result.IndexOf("webuser77") != -1) &&
						(result.IndexOf("Content-Type = xon/0") != -1))
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}


		// Multiple PUID Lookup
		// Some PUIDs exists
        [TestCase, Description("LSP_PUIDLookup_SomeExist"), TestCasePriority(1)]
		class LSP_PUIDLookup_SomeExist : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					// Look up the PUID for a gamer tag
					TestLookupGamerTag tLookUpGT = new TestLookupGamerTag(httpServer, 1);

					tLookUpGT.AddGamerTag("webuser77");
					tLookUpGT.Run();

					string result = tLookUpGT.ToString();
					int PUIDStart = result.LastIndexOf('\n');
					string sPUID = result.Substring(PUIDStart+1);
					ulong PUIDtoLookup = (ulong)System.Convert.ToInt64(sPUID,10);

					// now look it up with an array of 100 of them
					TestLookupPUID thisTest = new TestLookupPUID(httpServer, 100);

					thisTest.AddPUID(PUIDtoLookup);
					thisTest.AddPUID(42);			// This puid doesn't exist
					thisTest.AddPUID(PUIDtoLookup);
					thisTest.AddPUID(6622);			// This puid doesn't exist

					thisTest.Run();

					result = thisTest.ToString();

					if((result.IndexOf("webuser77") != -1) &&
						(result.IndexOf("Content-Type = xon/0") != -1))
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}


		// Multiple PUID Lookup
		// No PUIDs exists
        [TestCase, Description("LSP_PUIDLookup_NoneExist"), TestCasePriority(1)]
		class LSP_PUIDLookup_NoneExist : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					// now look it up with an array of 100 of them
					TestLookupPUID thisTest = new TestLookupPUID(httpServer, 100);

					thisTest.AddPUID(42);			// This puid doesn't exist
					thisTest.AddPUID(6622);			// This puid doesn't exist

					thisTest.Run();

					string result = thisTest.ToString();

					if((result.IndexOf("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0|\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0") != -1) &&
						(result.IndexOf("Content-Type = xon/0") != -1))
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}


		// Bad request
		// Content Length is 0
        [TestCase, Description("LSP_PUIDLookup_0_Content_Length"), TestCasePriority(2)]
		class LSP_PUIDLookup_0_Content_Length : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					// now look it up with an array of 100 of them
					TestLookupPUID thisTest = new TestLookupPUID(httpServer, 100);

					thisTest.RunNull();
					ResultCode = TEST_RESULTS.FAILED;
				}
				catch(Exception e)
				{
					if( e.ToString().IndexOf("(500) Internal Server Error") > 0 )
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}


		// PUID Lookup
		// Max request size / All PUIDS exist
        [TestCase, Description("LSP_PUIDLookup_MaxReq"), TestCasePriority(1)]
		class LSP_PUIDLookup_MaxReq : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					// Look up the PUID for a gamer tag
					TestLookupGamerTag tLookUpGT = new TestLookupGamerTag(httpServer, 1);

					tLookUpGT.AddGamerTag("webuser77");
					tLookUpGT.Run();

					string result = tLookUpGT.ToString();
					int PUIDStart = result.LastIndexOf('\n');
					string sPUID = result.Substring(PUIDStart+1);
					ulong PUIDtoLookup = (ulong)System.Convert.ToInt64(sPUID,10);

					// now look it up with an array of 100 of them
					TestLookupPUID thisTest = new TestLookupPUID(httpServer, 100);

					for(uint i = 0; i < 100; i++)
					{
						thisTest.AddPUID(PUIDtoLookup);
					}

					thisTest.Run();

					result = thisTest.ToString();

					int iPipeCount =0;
					foreach(char ch in result)
					{
						if(ch == '|')
							iPipeCount++;
					}

					if(iPipeCount == 99)
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}


		// PUID Lookup
		// Oversized request size
        [TestCase, Description("LSP_PUIDLookup_OversizedReq"), TestCasePriority(2)]
		class LSP_PUIDLookup_OversizedReq : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					// Look up the PUID for a gamer tag
					TestLookupGamerTag tLookUpGT = new TestLookupGamerTag(httpServer, 1);

					tLookUpGT.AddGamerTag("webuser77");
					tLookUpGT.Run();

					string result = tLookUpGT.ToString();
					int PUIDStart = result.LastIndexOf('\n');
					string sPUID = result.Substring(PUIDStart+1);
					ulong PUIDtoLookup = (ulong)System.Convert.ToInt64(sPUID,10);

					//  Make an array of 101 of them, 1 too large
					TestLookupPUID thisTest = new TestLookupPUID(httpServer, 101);

					for(uint i = 0; i < 101; i++)
					{
						thisTest.AddPUID(PUIDtoLookup);
					}

					thisTest.Run();
				}
				catch(Exception e)
				{
					string result = e.ToString();
					if(result.StartsWith("System.Net.WebException: The remote server returned an error: (500) Internal Server Error."))
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}


		// PUID Lookup
		// Min / PUID doesn't exist
        [TestCase, Description("LSP_PUIDLookup_Min"), TestCasePriority(2)]
		class LSP_PUIDLookup_Min : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestLookupPUID thisTest = new TestLookupPUID(httpServer, 4);

					thisTest.AddPUID(0);

					thisTest.Run();

					string result = thisTest.ToString();

					if((result.IndexOf("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0") != -1) &&
						(result.IndexOf("Content-Type = xon/0") != -1))
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}


		// PUID Lookup
		// Max / PUID doesn't exist
        [TestCase, Description("LSP_PUIDLookup_Max"), TestCasePriority(2)]
		class LSP_PUIDLookup_Max : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestLookupPUID thisTest = new TestLookupPUID(httpServer, 4);

					thisTest.AddPUID(0xFFFFFFFFFFFFFFFF);

					thisTest.Run();

					string result = thisTest.ToString();

					if((result.IndexOf("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0") != -1) &&
						(result.IndexOf("Content-Type = xon/0") != -1))
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\GeneralInfo\Test\dvt\GeneralInfo.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="GeneralInfoSoap", Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class GeneralInfo : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public GeneralInfo(string url) {
        this.Url = url;
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/GeneralInfo/GetTitleList", RequestNamespace="http://websvc.xboxlive.com/GeneralInfo/", ResponseNamespace="http://websvc.xboxlive.com/GeneralInfo/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public TitlePrivilegeInfo[] GetTitleList(out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetTitleList", new object[0]);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((TitlePrivilegeInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTitleList(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTitleList", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public TitlePrivilegeInfo[] EndGetTitleList(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((TitlePrivilegeInfo[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/GeneralInfo/LinkedGamerTags", RequestNamespace="http://websvc.xboxlive.com/GeneralInfo/", ResponseNamespace="http://websvc.xboxlive.com/GeneralInfo/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LinkInfo[] LinkedGamerTags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID) {
        object[] results = this.Invoke("LinkedGamerTags", new object[] {
                    WebID});
        return ((LinkInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginLinkedGamerTags(System.Byte[] WebID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("LinkedGamerTags", new object[] {
                    WebID}, callback, asyncState);
    }
    
    /// <remarks/>
    public LinkInfo[] EndLinkedGamerTags(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((LinkInfo[])(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class TitlePrivilegeInfo {
    
    /// <remarks/>
    public System.UInt32 TitleID;
    
    /// <remarks/>
    public TitlePrivilege Privileges;
    
    /// <remarks/>
    public ESRBRating Rating;
    
    /// <remarks/>
    public string DefaultLocale;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LocalizedDisplayName[] LocalizedName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public enum TitlePrivilege {
    
    /// <remarks/>
    None,
    
    /// <remarks/>
    ReadOnly,
    
    /// <remarks/>
    ReadWrite,
    
    /// <remarks/>
    FullControl,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public enum ESRBRating {
    
    /// <remarks/>
    ALL,
    
    /// <remarks/>
    ADULT,
    
    /// <remarks/>
    MATURE,
    
    /// <remarks/>
    TEEN,
    
    /// <remarks/>
    EVERYONE,
    
    /// <remarks/>
    KIDS_TO_ADULTS,
    
    /// <remarks/>
    EARLY_CHILDHOOD,
    
    /// <remarks/>
    UNSPECIFIED,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class LocalizedDisplayName {
    
    /// <remarks/>
    public string Locale;
    
    /// <remarks/>
    public string DisplayName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class LinkInfo {
    
    /// <remarks/>
    public string GamerTag;
    
    /// <remarks/>
    public bool Owner;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\FuncLSPForward.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace LSPWidget
{
	/// <summary>
	/// Summary description for FuncLSPSiteInfo.
	/// </summary>
    [TestGroup, Owner("johnmcp"), TestFrequency("Daily")]
	public class FuncLSPForward : TestNode
	{
		public static string httpServer = Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();
        public const string ReflectorXRL = "/testfd/Reflect.ashx";

		// Forward Request
		// Reflection
        [TestCase, Description("LSP_ForwardReq_Reflect"), TestCasePriority(1)]
		class LSP_ForwardReq_Reflect : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestForwardRequest thisTest = new TestForwardRequest(httpServer);
                    thisTest.XRL = ReflectorXRL;
					thisTest.Body = "Foo";
					thisTest.titleID ="FFFFAB22";

					thisTest.Run();

					string result = thisTest.ToString();

					if(result.IndexOf("Foo") != -1)
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch(Exception e)
				{
					Console.WriteLine( e.ToString() );
				}
			}
		}

		// Forward Request bad TitleID
		// Reflection
        [TestCase, Description("LSP_ForwardReq_Reflect_badTitleID"), TestCasePriority(2)]
		class LSP_ForwardReq_Reflect_badTitleID : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestForwardRequest thisTest = new TestForwardRequest(httpServer);
                    thisTest.XRL = ReflectorXRL;
					thisTest.Body = "Foo";
					thisTest.titleID ="FFFFAB23";

					thisTest.Run();

					string result = thisTest.ToString();
					ResultCode = TEST_RESULTS.FAILED;
				}
				catch(Exception e)
				{
					if( e.ToString().IndexOf("(500) Internal Server Error") > 0 )
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		// Forward Request No TitleID
		// Reflection
        [TestCase, Description("LSP_ForwardReq_Reflect_No_TitleID"), TestCasePriority(2)]
		class LSP_ForwardReq_Reflect_No_TitleID : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestForwardRequest thisTest = new TestForwardRequest(httpServer);
                    thisTest.XRL = ReflectorXRL;
					thisTest.Body = "Foo";

					thisTest.Run();

					string result = thisTest.ToString();
					ResultCode = TEST_RESULTS.FAILED;
				}
				catch(Exception e)
				{
					if( e.ToString().IndexOf("(500) Internal Server Error") > 0 )
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		// Forward Request
		// Reflection
        [TestCase, Description("LSP_ForwardReq_Reflect_Empty"), TestCasePriority(2)]
		class LSP_ForwardReq_Reflect_Empty : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestForwardRequest thisTest = new TestForwardRequest(httpServer);
                    thisTest.XRL = ReflectorXRL;
					thisTest.Body = "";

					thisTest.Run();
					ResultCode = TEST_RESULTS.FAILED;
				}
				catch(Exception e)
				{
					if( e.ToString().IndexOf("(500) Internal Server Error") > 0 )
						ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\MainClass.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;

[assembly: RootNode(typeof(LSPWidget.Suite))]

namespace LSPWidget
{
	/// <summary>
	/// Main class
	/// </summary>
	public class Suite : TestNode
	{
        public override void PreRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            Certificates.InstallCertificates();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\StressLSP.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using xonline.common.config;

namespace LSPWidget
{
	/// <summary>
	/// Summary description for StressLSP.
	/// </summary>
	[StressTest(Priority=1)]
    [StressInstantiate]
	public class StressLSP_SiteInfo : TestBase
	{
		public static string httpServer = Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();

		override protected void Execute()
		{
			try
			{
				ResultCode = TEST_RESULTS.FAILED;

                TestGetSiteInfo thisTest = new TestGetSiteInfo(httpServer);
                thisTest.SubjectName = "test.lsptest.rdo.001";
                thisTest.SiteId = (int)-65422;

				thisTest.Run();

				string result = thisTest.ToString();

				if((result.IndexOf("Number Of Keys: 1") != -1) &&
					(result.IndexOf("Content-Type = xon/0") != -1))
					ResultCode = TEST_RESULTS.PASSED;
			}
			catch(Exception e)
			{
				Console.WriteLine( e.ToString() );
			}
		}
	}


	/// <summary>
	/// Summary description for StressLSP.
	/// </summary>
	[StressTest(Priority=1)]
    [StressInstantiate]
	public class StressLSP_GetSitePUID : TestBase
	{
        public static string httpServer = Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();

		override protected void Execute()
		{
			try
			{
				ResultCode = TEST_RESULTS.FAILED;
				TestGetSitePUIDs thisTest = new TestGetSitePUIDs(httpServer);
				thisTest.SubjectName = "test.lsptest.rdo.001";
				thisTest.Run();

				string result = thisTest.ToString();

				if((result.IndexOf("MachinePUID:") != -1) &&
					(result.IndexOf("UserPUID:") != -1) &&
					(result.IndexOf("Content-Type = xon/0") != -1)
					)
					ResultCode = TEST_RESULTS.PASSED;
			}
			catch(Exception e)
			{
				Console.WriteLine( e.ToString() );
			}
		}
	}

	[StressTest(Priority=1)]
    [StressInstantiate]
	public class StressLSP_GamerTagLookup : TestBase
	{
        public static string httpServer = Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();

		override protected void Execute()
		{
			try
			{
				ResultCode = TEST_RESULTS.FAILED;

				TestLookupGamerTag thisTest = new TestLookupGamerTag(httpServer, 1);
				thisTest.AddGamerTag("webuser632");
				thisTest.Run();

				string result = thisTest.ToString();

				int PUIDStart = result.LastIndexOf('\n');
				string sPUID = result.Substring(PUIDStart+1);
				if(sPUID != "0")
					ResultCode = TEST_RESULTS.PASSED;
			}
			catch(Exception e)
			{
				Console.WriteLine( e.ToString() );
			}
		}
	}

	[StressTest(Priority=1)]
    [StressInstantiate]
	public class StressLSP_PUIDLookup : TestBase
	{
        public static string httpServer = Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();
		public static ulong PUIDtoLookup;

		override protected void Execute()
		{
			try
			{
				ResultCode = TEST_RESULTS.FAILED;
				TestLookupPUID thisTest = new TestLookupPUID(httpServer, 1);

				// Now lets look up the PUID and see if we get the right gamer tag
				// This PUID should always map to this user based on pre-populate scripts
				thisTest.AddPUID(0x9ffffffffffb1);
				thisTest.Run();

				string result = thisTest.ToString();

				if(result.IndexOf("webuser78") != -1)
					ResultCode = TEST_RESULTS.PASSED;
			}
			catch(Exception e)
			{
				Console.WriteLine( e.ToString() );
			}
		}
	}

	[StressTest(Priority=5)]
    [StressInstantiate]
	public class StressLSP_Forward : TestBase
	{
        public static string httpServer = Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();
		public static TestForwardRequest thisTest = new TestForwardRequest(httpServer);

		override protected void Execute()
		{
			try
			{
				ResultCode = TEST_RESULTS.FAILED;
				thisTest.XRL = "/testfd/Reflect.ashx";
				thisTest.Body = "Some garbage";
				thisTest.titleID ="FFFFAB22";
				thisTest.Run();

				string result = thisTest.ToString();

				if(result.IndexOf("Some garbage") != -1)
					ResultCode = TEST_RESULTS.PASSED;
			}
			catch(Exception e)
			{
				Console.WriteLine( e.ToString() );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\dvt\LivePxyTest.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Web;
using System.Xml;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections;


namespace xonline.server.webcache.liveproxy.test.dvt 
{
	/// <summary>
	/// Summary description for TestPxy.
	/// </summary>
	class TestPxy
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{

            try 
            {
                TestPxy tester = new TestPxy();

                // loads the xml file for this test suite.
                tester.LoadConfig( args[0] );

                // the tests were set up in the load config. Now run them.
                foreach ( TestCase test in tester._tests )
                {
                    try 
                    {
                        // run test
                        test.Run();
                    
                        // normally this would be more complex where I would wait async for responses...
                        // however I don't have to.... and I knwo the test is over when I commit the run.
                        // so we'll just print the result string right after.                    
                        Console.WriteLine( test.ToString() );
                    }
                    catch( WebException we )
                    {
                        Console.WriteLine( "Case failed.\n" + we.ToString() );
                    }
                }

            } 
            catch(Exception e) 
            {
                Console.WriteLine( e.ToString() );
            }

            Console.WriteLine("DONE");

		}

        private void LoadConfig( string xmlCfgFileName )
        {
            XmlDocument cfg = new XmlDocument();
            int nCount = 0;

            //Load the the document with the last book node.
            XmlTextReader reader = new XmlTextReader( xmlCfgFileName );
            reader.WhitespaceHandling = WhitespaceHandling.None;
            reader.MoveToContent();
            cfg.Load(reader);
            XmlElement docElement = cfg.DocumentElement;

            // this is the node which hold the http server we want to connect to.
            XmlNodeList nl = docElement.SelectNodes( "//LivePxyTest/server" );

            // Get the http server we want to talk to.
            _httpserver = (nl[0].Attributes.GetNamedItem("value")).Value;

            nl = docElement.SelectNodes( "//LivePxyTest/test/case" );
            
            // create the number of test cases we'll be using...
            _tests = new TestCase[nl.Count];
            foreach( XmlNode xn in nl )
            {
                TestCase newcase = null;
                switch( xn.Attributes.GetNamedItem("type").Value )
                {
                    case "1":
                    {
                        TestForwardRequest tfr = new TestForwardRequest( _httpserver );
                            
                        tfr.XRL = xn.Attributes.GetNamedItem("xrl").Value;
                        tfr.Body = xn.Attributes.GetNamedItem("body").Value;

                        newcase = (TestCase)tfr;
                    }
                        break;
                    case "2":
                    {
                        TestGetSiteInfo tgsi = new TestGetSiteInfo( _httpserver );
                            
                        tgsi.SiteId = Int32.Parse( xn.Attributes.GetNamedItem("siteid").Value );

                        newcase = (TestCase)tgsi;
                    }
                        break;
                    case "3":
                    {
                        TestLookupPUID tlp = new TestLookupPUID( _httpserver );

                        tlp.NumberOfPUIDs = Int32.Parse( xn.Attributes.GetNamedItem("numberofpuids").Value );

                        // look at all the child nodes.
                        foreach ( XmlNode xchild in xn.ChildNodes )
                        {
                            tlp.AddPUID( UInt64.Parse(xchild.Attributes.GetNamedItem("value").Value) );
                        }

                        newcase = (TestCase)tlp;
                    }
                        break;
                    case "4":
                    {
                        TestLookupGamerTag tlgt = new TestLookupGamerTag( _httpserver );

                        tlgt.NumberOfGamerTags = Int32.Parse( xn.Attributes.GetNamedItem("numberofgamertags").Value );

                        // look at all the child nodes.
                        foreach ( XmlNode xchild in xn.ChildNodes )
                        {
                            tlgt.AddGamerTag( xchild.Attributes.GetNamedItem("value").Value );
                        }

                        newcase = (TestCase)tlgt;
                    }
                        break;
                    case "5":
                    {
                        TestGetSitePUIDs tgsp = new TestGetSitePUIDs( _httpserver );
                            
                        tgsp.SubjectName = xn.Attributes.GetNamedItem("subjectname").Value;

                        newcase = (TestCase)tgsp;
                    }
                        break;
                    default:
                    {
                        throw new Exception("LivePxyTest:  XML file contains invalid test case type.");
                    }
                }

                _tests[nCount] = newcase;

                nCount++;
            }
        
        }

        protected TestCase[] _tests;
        protected string     _httpserver;

        private const string http_request_header = "POST /liveproxy/forwardrequest.aspx HTTP/1.0\r\nAccept: */*\r\nUser-Agent: httppost\r\nHost: UdpSender\r\nxrl: value\r\n\r\n";

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\dvt\LivePxyMsgTypes.cs ===
using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections;
using System.Threading;

namespace xonline.server.webcache.liveproxy.test.dvt 
{
    /// <summary>
    /// Key data values.
    /// </summary>
    struct KeyData
    {
        public uint     _keyVersion;
        public byte[]   _key;
    }

    /// <summary>
    /// SiteInfoReply:  Response to site info request.
    /// </summary>
    public class SiteInfoReply
    {
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="_maxNumberOfKeys">Number of values expected in the array.</param>
        public SiteInfoReply( )
        {
            _numberOfKeys = 0;
            _curFileTime = 0;
            
            // create the array of keys
            _keys = null;

        }

        /// <summary>
        /// Constructs the binary form to be returned.
        /// </summary>
        /// <returns>byte array representation of this class.</returns>
        public void ReadBinary( byte[] data )
        {
            MemoryStream ms = new MemoryStream( data );
            BinaryReader br = new BinaryReader( ms );

            // read the expected time and number of keys.
            _curFileTime = br.ReadUInt64( );
            _numberOfKeys = br.ReadUInt32( );

            // set the array size.
            _keys = new KeyData[_numberOfKeys];
            for ( int x = 0; x < _numberOfKeys; x++ )
            {
                _keys[x]._keyVersion = br.ReadUInt32( );
                // all key sizes are 16 bytes.
                _keys[x]._key = br.ReadBytes( 16 );
            }

            br.Close();
        }

        public override string ToString()
        {
            string result = "";
            
            result = "TIME: " + System.DateTime.FromFileTime((long)_curFileTime).ToString() + "\n";
            result += "Number Of Keys: " + _numberOfKeys + "\n";
            result += "Keys: \n";

            // got through the list and print out all the keys.
            for ( int x = 0; x < _numberOfKeys; x++ )
            {
                _keys[x]._key[0].ToString("X");
                result += "Version: " + _keys[x]._keyVersion + " Value: 0x";
                
                // print out each byte as a hex value.
                for (int y = 0; y < _keys[x]._key.Length; y++ )
                {
                    result += _keys[x]._key[y].ToString("X");
                }

                result += "\n";
            }

            return result;
        }

        ulong       _curFileTime;
        uint        _numberOfKeys;
        KeyData[]   _keys;
    }


    /// <summary>
    /// PUIDInfo:  structure to read and reply to PUID data.
    /// </summary>
    public class PUIDInfo
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public PUIDInfo( uint expectedNumberOfPUIDs )
        {
            _numberOfPUIDs = 0;
            _PUIDs = new ulong[expectedNumberOfPUIDs];
        }

        public PUIDInfo( )
        {
            _numberOfPUIDs = 0;
            _PUIDs = null;
        }

        /// <summary>
        /// ReadBinary:  Reads binary data and puts it into the puid list.
        /// </summary>
        /// <param name="data">binary data to stream.</param>
        public void ReadBinary( byte[] data )
        {
            MemoryStream ms = new MemoryStream( data );
            BinaryReader br = new BinaryReader( ms );

            // get the expected number of PUIDs
            _numberOfPUIDs = br.ReadUInt32();

            // check if we have a null array
            if ( _PUIDs == null )
            {
                _PUIDs = new ulong[_numberOfPUIDs];
            }

            // ensure out array is big enough
            if ( _PUIDs.Length < _numberOfPUIDs )
            {
                throw new Exception( "Invalid usage of class.  Array size isn't big enough for incoming data.");
            }

            // add all the PUIDs to a list.
            for ( int x = 0; x < _numberOfPUIDs; x++ )
            {
                _PUIDs[x] = br.ReadUInt64();
            }

            br.Close();
        }

        /// <summary>
        /// Add a PUID the the PUID list.  Should only be used if class created with expectedNumberOfPUIDs
        ///   and not read from binary.
        /// </summary>
        /// <param name="PUID">PUID to add</param>
        public void AddPUID( ulong PUID )
        {
            if ( _PUIDs == null )
            {
                throw new Exception( "Invalid usage of class.  You must specify a size before adding new PUIDs");
            }

            _PUIDs[_numberOfPUIDs] = PUID;
            _numberOfPUIDs++;
        }

        /// <summary>
        /// Constructs the binary form to be returned.
        /// </summary>
        /// <returns>byte array representation of this class.</returns>
        public byte[] GetBinary()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );

            bw.Write( _numberOfPUIDs );

            for ( int x = 0; x < _numberOfPUIDs; x++ )
            {
                bw.Write( _PUIDs[x] );
            }
            
            bw.Close();   

            return ms.GetBuffer();
        }

        public override string ToString()
        {
            string result = "";
            for ( int x = 0; x < _numberOfPUIDs; x++ )
            {
                if ( result.Length > 0 )
                {
                    result += "|" + _PUIDs[x].ToString();
                }
                else
                {
                    result = _PUIDs[x].ToString();
                }
            }

            return result;
        }

        /// <summary>
        /// PUIDs:  Enumerator access to the PUID list.
        /// </summary>
        public ulong[] PUIDs
        {
            get 
            {
                return _PUIDs; 
            }
        }
       
        /// <summary>
        /// Count:  number of puids in list.
        /// </summary>
        public uint Count
        {
            get 
            {
                return _numberOfPUIDs; 
            }
        }

        protected uint        _numberOfPUIDs;
        protected ulong[]     _PUIDs;
    }

    /// <summary>
    /// GamerTagInfo:  structure to read and reply to gamertag data.
    /// </summary>
    public class GamerTagInfo
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public GamerTagInfo( uint expectedNumberOfGTs )
        {
            _numberOfGTs = 0;
            _GamerTags = new string[expectedNumberOfGTs];
        }

        public GamerTagInfo( )
        {
            _numberOfGTs = 0;
            _GamerTags = null;
        }

        /// <summary>
        /// ReadBinary:  Reads binary data and puts it into the gamertag list.
        /// </summary>
        /// <param name="data">binary data to stream.</param>
        public void ReadBinary( byte[] data )
        {
            MemoryStream ms = new MemoryStream( data );
            BinaryReader br = new BinaryReader( ms );

            // get the expected number of PUIDs
            _numberOfGTs = br.ReadUInt32();

            // check if we have a null array
            if ( _GamerTags == null )
            {
                _GamerTags = new string[_numberOfGTs];
            }

            // ensure out array is big enough
            if ( _GamerTags.Length < _numberOfGTs )
            {
                throw new Exception( "Invalid usage of class.  Array size isn't big enough for incoming data.");
            }

            // add all the PUIDs to a list.
            for ( int x = 0; x < _numberOfGTs; x++ )
            {
                byte[] newgamertag = br.ReadBytes( (int)(c_GAMERTAG_SIZE * 2) );
                string stringgamertag = System.Text.UnicodeEncoding.Unicode.GetString( newgamertag, 0, newgamertag.Length );
                _GamerTags[x] = stringgamertag;

            }

            br.Close();
        }

        /// <summary>
        /// Add a gamertag to the gamertag list.  Should only be used if class created with expectedNumberOfGts
        ///   and not read from binary.
        /// </summary>
        /// <param name="gamertag">gamertag to add</param>
        public void AddGamerTag( string gamertag )
        {
            if ( _GamerTags == null )
            {
                throw new Exception( "Invalid usage of class.  You must specify a size before adding new PUIDs");
            }

            _GamerTags[_numberOfGTs] = gamertag;
            _numberOfGTs++;
        }

        /// <summary>
        /// Constructs the binary form to be returned.
        /// </summary>
        /// <returns>byte array representation of this class.</returns>
        public byte[] GetBinary()
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter( ms );

            bw.Write( _numberOfGTs );

            for ( int x = 0; x < _numberOfGTs; x++ )
            {
                byte[] binaryGT = System.Text.UnicodeEncoding.Unicode.GetBytes( _GamerTags[x].PadRight( (int)c_GAMERTAG_SIZE, (char)0 ) );
                bw.Write( binaryGT, 0, binaryGT.Length );
            }

            bw.Close();

            return ms.GetBuffer();
        }

        public override string ToString()
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();

            for ( int x = 0; x < _numberOfGTs; x++ )
            {
                // put these string together.
                if ( sb.Length > 0 )
                {
                    sb.Append( "|" + _GamerTags[x].ToString() );
                }
                else
                {
                    sb.Append( _GamerTags[x] );
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Gamertags:  Enumerator access to the gamertag list.
        /// </summary>
        public string[] Gamertags
        {
            get 
            {
                return _GamerTags; 
            }
        }

        /// <summary>
        /// Count:  number of puids in list.
        /// </summary>
        public uint Count
        {
            get 
            {
                return _numberOfGTs; 
            }
        }


        public const uint c_GAMERTAG_SIZE = 16;
       
        protected uint        _numberOfGTs;
        protected string[]    _GamerTags;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\FuncLSPSiteInfo.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace LSPWidget
{
	/// <summary>
	/// Summary description for FuncLSPSiteInfo.
	/// </summary>
    [TestGroup, Owner("johnmcp"), TestFrequency("Daily")]
	public class FuncLSPSiteInfo : TestNode
	{
		public static string httpServer =Global.XEnv.GetVirtualInterface(VirtualInterface.livepxy).ToString();

		// Get Site Info
		// Site exists
        [TestCase, Description("LSP_GetSiteInfo"), TestCasePriority(1)]
		class LSP_GetSiteInfo : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.FAILED;

				TestGetSiteInfo thisTest = new TestGetSiteInfo(httpServer);
                thisTest.SubjectName = "test.lsptest.rdo.001";
				thisTest.SiteId = (int)-65422;

				thisTest.Run();

				string result = thisTest.ToString();

                if (result.IndexOf("Number Of Keys: 1") == -1)
                {
                    Global.RO.Error("Number of keys received was not 1.  Response:\r\n{0}", result);
                    return;
                }

                if (result.IndexOf("Content-Type = xon/0") == -1)
                {
                    Global.RO.Error("Content-Type was not xon/0.  Response:\r\n{0}", result);
                    return;
                }

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		// Get Site Info
		// Site doesn't exists
        [TestCase, Description("LSP_GetSiteInfo_NA"), TestCasePriority(2)]
        [CompoundCase("9999", 9999)]
        [CompoundCase("-1", -1)]
        [CompoundCase("0", 0)]
        [CompoundCase("100", 100)]
        [CompoundCase("int.MinValue", int.MinValue)]
        [CompoundCase("int.MaxValue", int.MaxValue)]
		class LSP_GetSiteInfo_NA : TestBase
		{
			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				TestGetSiteInfo thisTest = new TestGetSiteInfo(httpServer);
				thisTest.SiteId = (int) MyValues[0];

				try
				{
					thisTest.Run();
					ResultCode = TEST_RESULTS.FAILED;
				}
				catch
				{
				}
			}
		}

		// Get Site Info
		// Site is illegal
        [TestCase, Description("LSP_GetSiteInfo_Sub100"), TestCasePriority(2)]
		class LSP_GetSiteInfo_Sub100 : TestBase
		{
			protected override void Execute()
			{
				try
				{
					ResultCode = TEST_RESULTS.FAILED;

					TestGetSiteInfo thisTest = new TestGetSiteInfo(httpServer);
					thisTest.SiteId = 2;

					thisTest.Run();
					ResultCode = TEST_RESULTS.FAILED;
				}
				catch(Exception e)
				{
					if( e.ToString().IndexOf("(500) Internal Server Error") > 0 )
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\webcache\LiveProxy\test\TestCase.cs ===
using System;
using System.Text;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Xml;

namespace LSPWidget
{
	/// <summary>
	/// Key data values.
	/// </summary>
	struct KeyData
	{
		public uint     _keyVersion;
		public byte[]   _key;
	}


	/// <summary>
	/// SiteInfoReply:  Response to site info request.
	/// </summary>
	public class SiteInfoReply
	{
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="_maxNumberOfKeys">Number of values expected in the array.</param>
		public SiteInfoReply( )
		{
			_numberOfKeys = 0;
			_curFileTime = 0;
            
			// create the array of keys
			_keys = null;

		}

		/// <summary>
		/// Constructs the binary form to be returned.
		/// </summary>
		/// <returns>byte array representation of this class.</returns>
		public void ReadBinary( byte[] data )
		{
			MemoryStream ms = new MemoryStream( data );
			BinaryReader br = new BinaryReader( ms );

			// read the expected time and number of keys.
			_curFileTime = br.ReadUInt64( );
			_numberOfKeys = br.ReadUInt32( );

			// set the array size.
			_keys = new KeyData[_numberOfKeys];
			for ( int x = 0; x < _numberOfKeys; x++ )
			{
				_keys[x]._keyVersion = br.ReadUInt32( );
				// all key sizes are 16 bytes.
				_keys[x]._key = br.ReadBytes( 16 );
			}

			br.Close();
		}

		public override string ToString()
		{
			string result = "";
            
			result = "TIME: " + System.DateTime.FromFileTime((long)_curFileTime).ToString() + "\n";
			result += "Number Of Keys: " + _numberOfKeys + "\n";
			result += "Keys: \n";

			// got through the list and print out all the keys.
			for ( int x = 0; x < _numberOfKeys; x++ )
			{
				_keys[x]._key[0].ToString("X");
				result += "Version: " + _keys[x]._keyVersion + " Value: 0x";
                
				// print out each byte as a hex value.
				for (int y = 0; y < _keys[x]._key.Length; y++ )
				{
					result += _keys[x]._key[y].ToString("X");
				}

				result += "\n";
			}

			return result;
		}

		ulong       _curFileTime;
		uint        _numberOfKeys;
		KeyData[]   _keys;
	}


	/// <summary>
	/// PUIDInfo:  structure to read and reply to PUID data.
	/// </summary>
	public class PUIDInfo
	{
		/// <summary>
		/// Constructor
		/// </summary>
		public PUIDInfo( uint expectedNumberOfPUIDs )
		{
			_numberOfPUIDs = 0;
			_PUIDs = new ulong[expectedNumberOfPUIDs];
		}

		public PUIDInfo( )
		{
			_numberOfPUIDs = 0;
			_PUIDs = null;
		}

		/// <summary>
		/// ReadBinary:  Reads binary data and puts it into the puid list.
		/// </summary>
		/// <param name="data">binary data to stream.</param>
		public void ReadBinary( byte[] data )
		{
			MemoryStream ms = new MemoryStream( data );
			BinaryReader br = new BinaryReader( ms );

			// get the expected number of PUIDs
			_numberOfPUIDs = br.ReadUInt32();

			// check if we have a null array
			if ( _PUIDs == null )
			{
				_PUIDs = new ulong[_numberOfPUIDs];
			}

			// ensure out array is big enough
			if ( _PUIDs.Length < _numberOfPUIDs )
			{
				throw new Exception( "Invalid usage of class.  Array size isn't big enough for incoming data.");
			}

			// add all the PUIDs to a list.
			for ( int x = 0; x < _numberOfPUIDs; x++ )
			{
				_PUIDs[x] = br.ReadUInt64();
			}

			br.Close();
		}

		/// <summary>
		/// Add a PUID the the PUID list.  Should only be used if class created with expectedNumberOfPUIDs
		///   and not read from binary.
		/// </summary>
		/// <param name="PUID">PUID to add</param>
		public void AddPUID( ulong PUID )
		{
			if ( _PUIDs == null )
			{
				throw new Exception( "Invalid usage of class.  You must specify a size before adding new PUIDs");
			}

			_PUIDs[_numberOfPUIDs] = PUID;
			_numberOfPUIDs++;
		}

		/// <summary>
		/// Constructs the binary form to be returned.
		/// </summary>
		/// <returns>byte array representation of this class.</returns>
		public byte[] GetBinary()
		{
			MemoryStream ms = new MemoryStream();
			BinaryWriter bw = new BinaryWriter( ms );

			bw.Write( _numberOfPUIDs );

			for ( int x = 0; x < _numberOfPUIDs; x++ )
			{
				bw.Write( _PUIDs[x] );
			}
            
			bw.Close();   

			return ms.ToArray();
		}

		public override string ToString()
		{
			string result = "";
			for ( int x = 0; x < _numberOfPUIDs; x++ )
			{
				if ( result.Length > 0 )
				{
					result += "|" + _PUIDs[x].ToString();
				}
				else
				{
					result = _PUIDs[x].ToString();
				}
			}

			return result;
		}

		/// <summary>
		/// PUIDs:  Enumerator access to the PUID list.
		/// </summary>
		public ulong[] PUIDs
		{
			get 
			{
				return _PUIDs; 
			}
		}
       
		/// <summary>
		/// Count:  number of puids in list.
		/// </summary>
		public uint Count
		{
			get 
			{
				return _numberOfPUIDs; 
			}
		}

		protected uint        _numberOfPUIDs;
		protected ulong[]     _PUIDs;
	}


	/// <summary>
	/// GamerTagInfo:  structure to read and reply to gamertag data.
	/// </summary>
	public class GamerTagInfo
	{
		/// <summary>
		/// Constructor
		/// </summary>
		public GamerTagInfo( uint expectedNumberOfGTs )
		{
			_numberOfGTs = 0;
			_GamerTags = new string[expectedNumberOfGTs];
		}

		public GamerTagInfo( )
		{
			_numberOfGTs = 0;
			_GamerTags = null;
		}

		/// <summary>
		/// ReadBinary:  Reads binary data and puts it into the gamertag list.
		/// </summary>
		/// <param name="data">binary data to stream.</param>
		public void ReadBinary( byte[] data )
		{
			MemoryStream ms = new MemoryStream( data );
			BinaryReader br = new BinaryReader( ms );

			// get the expected number of PUIDs
			_numberOfGTs = br.ReadUInt32();

			// check if we have a null array
			if ( _GamerTags == null )
			{
				_GamerTags = new string[_numberOfGTs];
			}

			// ensure out array is big enough
			if ( _GamerTags.Length < _numberOfGTs )
			{
				throw new Exception( "Invalid usage of class.  Array size isn't big enough for incoming data.");
			}

			// add all the PUIDs to a list.
			for ( int x = 0; x < _numberOfGTs; x++ )
			{
				byte[] newgamertag = br.ReadBytes( (int)(c_GAMERTAG_SIZE * 2) );
				string stringgamertag = System.Text.UnicodeEncoding.Unicode.GetString( newgamertag, 0, newgamertag.Length );
				_GamerTags[x] = stringgamertag;

			}

			br.Close();
		}

		/// <summary>
		/// Add a gamertag to the gamertag list.  Should only be used if class created with expectedNumberOfGts
		///   and not read from binary.
		/// </summary>
		/// <param name="gamertag">gamertag to add</param>
		public void AddGamerTag( string gamertag )
		{
			if ( _GamerTags == null )
			{
				throw new Exception( "Invalid usage of class.  You must specify a size before adding new PUIDs");
			}

			_GamerTags[_numberOfGTs] = gamertag;
			_numberOfGTs++;
		}

		/// <summary>
		/// Constructs the binary form to be returned.
		/// </summary>
		/// <returns>byte array representation of this class.</returns>
		public byte[] GetBinary()
		{
			MemoryStream ms = new MemoryStream();
			BinaryWriter bw = new BinaryWriter( ms );

			bw.Write( _numberOfGTs );

			for ( int x = 0; x < _numberOfGTs; x++ )
			{
				byte[] binaryGT = System.Text.UnicodeEncoding.Unicode.GetBytes( _GamerTags[x].PadRight( (int)c_GAMERTAG_SIZE, (char)0 ) );
				bw.Write( binaryGT, 0, binaryGT.Length );
			}

			bw.Close();

			return ms.ToArray();
		}

		public override string ToString()
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();

			for ( int x = 0; x < _numberOfGTs; x++ )
			{
				// put these string together.
				if ( sb.Length > 0 )
				{
					sb.Append( "|" + _GamerTags[x].ToString() );
				}
				else
				{
					sb.Append( _GamerTags[x] );
				}
			}

			return sb.ToString();
		}

		/// <summary>
		/// Gamertags:  Enumerator access to the gamertag list.
		/// </summary>
		public string[] Gamertags
		{
			get 
			{
				return _GamerTags; 
			}
		}

		/// <summary>
		/// Count:  number of puids in list.
		/// </summary>
		public uint Count
		{
			get 
			{
				return _numberOfGTs; 
			}
		}


		public const uint c_GAMERTAG_SIZE = 16;
       
		protected uint        _numberOfGTs;
		protected string[]    _GamerTags;
	}


	/// <summary>
	/// UdpsTestCase:  The base class for the test cases used by xdtool.
	/// </summary>
	public class TestCase : Object
	{
		// ----------------------------------
		//  Constants
		// ----------------------------------

		// ----------------------------------
		//  Type
		// ----------------------------------
		protected enum TEST_STATE
		{
			NONE                = 0,
			COMPLETE            = 1,
			WAITING_RESPONSE    = 2,
		};

		// ----------------------------------
		//  Methods
		// ----------------------------------
		public TestCase()
		{
			_resultstring = "Invalid";
			_wc = new WebClient();

			// Add the necessary headers
			_wc.Headers.Add("Content-Type", "xon/0");
			_wc.Headers.Add("User-Agent", "0/1.00.65535");
			_wc.Headers.Add("Subject-Name", "t2client2");
			_wc.Headers.Add("Client-IP-Port", "1.2.3.4:0");
			_wc.Headers.Add("RequestId", "CAFEBABEDEADBEEF");
		}

		/// <summary>
		/// Run:  executes the test case.  Should be overridden.
		/// </summary>
		public virtual void Run()
		{
			// override this method executing
			throw new Exception( "Method not supported." );
		}

		/// <summary>
		/// Process:  Takes a given packet returning true if it belongs to this case.
		/// </summary>
		public virtual bool Process( Object packet )
		{
			// override this method executing
			throw new Exception( "Method not supported." );
		}

		/// <summary>
		/// VerifyOwnership:  determines if a packet belongs to the test case.
		/// </summary>
		/// <param name="id">byte array of id to check</param>
		/// <returns>true if the id belongs to this test case.</returns>
		public virtual bool VerifyOwnership( byte[] id )
		{
			// override this method executing
			throw new Exception( "Method not supported." );
		}

		/// <summary>
		/// IsComplete:  (Should be overridden) True if test case complete.
		/// </summary>
		/// <returns>Whether operation is complete or not.</returns>
		public virtual bool IsComplete()
		{
			throw new Exception("Please implement this function.");
		}

		/// <summary>
		/// Result:  The final result of the test case...  set to false if not complete.
		/// </summary>
		public virtual int Result
		{
			get
			{
				return _result;
			}
		}

        /// <summary>
        /// SubjectName:  subjecty name to use.
        /// </summary>
        public string SubjectName
        {
            get
            {
                return _subjectName;
            }
            set
            {
                _wc.Headers["Subject-Name"] = value;
                _subjectName = value;
            }
        }

		/// <summary>
		/// ToString:  returns the result string for this entry.
		/// </summary>
		public override string ToString()
		{
			return _resultstring;
		}



		// ----------------------------------
		//  Members
		// ----------------------------------
		protected int       _result;
		protected string    _resultstring;
        protected WebClient _wc;
        protected string    _subjectName;
	}


	/// <summary>
	/// TestForwardRequest:  .
	/// </summary>
	public class TestForwardRequest: TestCase
	{
		// ----------------------------------
		//  Constant
		// ----------------------------------

		// ----------------------------------
		//  Methods
		// ----------------------------------
		public TestForwardRequest( string httpserver )
		{
			_url = "http://" + httpserver + "/LiveProxy/forwardrequest.aspx";

			_body = "";
			_xrl = "";
			_result = 0;
			_resultstring = "";
		}

		/// <summary>
		/// Run:  start, execute the test case.
		/// </summary>
		public override void Run()
		{
			byte[] data = System.Text.ASCIIEncoding.ASCII.GetBytes(_body);

			// add the necessary headers.
			_wc.Headers.Set( "xrl", _xrl );
			_wc.Headers.Set( "title-id", _titleID );

			byte[] resp = _wc.UploadData( _url, "POST", data );

			_resultstring = "Response received: \n";
                
			// print out the results.
			foreach ( string s in _wc.ResponseHeaders )
			{
				_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
			}
			_resultstring = System.Text.ASCIIEncoding.ASCII.GetString( resp );
			_state = TEST_STATE.COMPLETE;

		}

		/// <summary>
		/// Process:  Takes a given packet returning true if it belongs to this case.
		/// </summary>
		public override bool Process( Object data )
		{
			bool result = true;

			// if it does...  determine our state.
			switch( _state )
			{
				case TEST_STATE.COMPLETE:
				{
				}
					break;
				case TEST_STATE.NONE:
				case TEST_STATE.WAITING_RESPONSE:
				default:
				{
					throw new Exception( "Invalid state." );
				}
			}

			return result;
		}

		/// <summary>
		/// IsComplete:  True if test case complete.
		/// </summary>
		/// <returns>Whether operation is complete or not.</returns>
		public override bool IsComplete()
		{
			return ( _state == TEST_STATE.COMPLETE );
		}

		/// <summary>
		/// VerifyOwnership:  determines if a packet belongs to the test case.
		/// </summary>
		/// <param name="id">byte array of id to check</param>
		/// <returns>true if the id belongs to this test case.</returns>
		public override bool VerifyOwnership( byte[] id )
		{
			return true;
		}



		/// <summary>
		/// Result:  The final result of the test case...  set to false if not complete.
		///     0 -- failed.
		///     1 -- passed.
		/// </summary>
		public override int Result
		{
			get
			{
				if ( _state == TEST_STATE.COMPLETE )
				{
					return _result;
				}
				else
				{
					return 0;
				}
			}
		}

		public string XRL
		{
			get
			{
				return _xrl;
			}
			set
			{
				_xrl = value;
			}            
		}

		public string Body
		{
			get
			{
				return _body;
			}
			set
			{
				_body = value;
			}            
		}

		public string titleID
		{
			get
			{
				return _titleID;
			}
			set
			{
				_titleID = value;
			}            
		}

		// ----------------------------------
		//  Members
		// ----------------------------------
		protected TEST_STATE        _state;
		protected string            _url;
		protected string            _body;
		protected string            _xrl;
		protected string            _titleID;

	}


	/// <summary>
	/// TestGetSiteInfo:  Tests the site info call to the live proxy.
	/// </summary>
	public class TestGetSiteInfo: TestCase
	{
		// ----------------------------------
		//  Constant
		// ----------------------------------

		// ----------------------------------
		//  Methods
		// ----------------------------------
		public TestGetSiteInfo( string httpserver )
		{
			_url = "http://" + httpserver + "/LiveProxy/getsiteinfo.aspx";

			_siteId = 0;
			_result = 0;
			_resultstring = "";
		}

		/// <summary>
		/// Run:  start, execute the test case.
		/// </summary>
		public override void Run()
		{
			byte[] data = System.BitConverter.GetBytes( _siteId );
			
			byte[] resp = _wc.UploadData( _url, data );

			SiteInfoReply sir = new SiteInfoReply();
			sir.ReadBinary( resp );

			_resultstring = "Response received: \n";
                
			// print out the results.
			foreach ( string s in _wc.ResponseHeaders )
			{
				_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
			}

			_resultstring += sir.ToString();
			_state = TEST_STATE.COMPLETE;

		}

		/// <summary>
		/// Process:  Takes a given packet returning true if it belongs to this case.
		/// </summary>
		public override bool Process( Object data )
		{
			bool result = true;

			// if it does...  determine our state.
			switch( _state )
			{
				case TEST_STATE.COMPLETE:
				{
				}
					break;
				case TEST_STATE.NONE:
				case TEST_STATE.WAITING_RESPONSE:
				default:
				{
					throw new Exception( "Invalid state." );
				}
			}

			return result;
		}

		/// <summary>
		/// IsComplete:  True if test case complete.
		/// </summary>
		/// <returns>Whether operation is complete or not.</returns>
		public override bool IsComplete()
		{
			return ( _state == TEST_STATE.COMP