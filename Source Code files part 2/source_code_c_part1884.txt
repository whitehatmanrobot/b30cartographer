ferent
 *      types of data (string, HRESULT, etc.)  These are interpreted
 *      using dwFlags. It also takes the file and line associated with
 *      the point in the source where it was called.
 *      
 *      dwFlags - Packed values tell us how to generate the message.
 *      dwData1 - The first of two data parameters.
 *      dwData2 - The second of two data parameters.
 *      szFile  - File name we were called from.
 *      iLine   - Line number we were called from.
 *
 */
void TraceMsg(DWORD dwFlags, DWORD dwData1, DWORD dwData2,
    LPSTR szFile, int iLine)
{
    //The following three buffers are used to build our message.
    char szTemp[MAXDEBUGSTRLEN];
    char szTemp2[MAXDEBUGSTRLEN];
    char szDebugMsg[MAXDEBUGSTRLEN];
    char* pch;
    int cch;
    TrcFlags trcf; //Used to decode dwFlags
    DWORD pid;
    DWORD tid;
    DWORD dwError;
    int indent, tls;
    
    //Check to see if a Trace hook has been set. If it has, call
    //it with pointers to all our parameters (they can be modified
    //this way if desired).  If the hook returns false, return.
    //Otherwise, continue with our message output with the potentially
    //modified parameters.
    if (NULL != pfnTrace)
        if (!pfnTrace(&dwFlags, &dwData1, &dwData2, szFile, &iLine))
            return;

    trcf.dw = dwFlags;

    //Return if this is an informational message and they are disabled.
    if ((TRCSEVINFO == trcf.fields.uSeverity) && !fInfo)
        return;

     // Call GetLastError now in case we need it later.
    // This way api calls downstream won't disturb the value
    // we need.
    dwError = GetLastError();
    pid = GetCurrentProcessId();
    tid = GetCurrentThreadId();
    szTemp[0] = '\0';
    szTemp2[0] = '\0';
    szDebugMsg[0] = '\0';

    // Handle indentation (TLSindent is set by CTrace)
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    indent = (tls < 0 ? 0 : tls);
    memset(szDebugMsg, ' ', 2*indent*sizeof(char));
    szDebugMsg[2*indent] = '\0';

    // Handle severity (Warning, Error, etc.)
    if (TRCSEVNONE != trcf.fields.uSeverity)
    {
        sprintf(szTemp, "%s: ", TrcSeverity[trcf.fields.uSeverity]);
        strcat(szDebugMsg, szTemp);
    }
    
    // Interpret the first data value
    if (TRCDATANONE != trcf.fields.uData1)
    {
        if (TRCDATADEFAULT == trcf.fields.uData1)
            dwData1 = dwError;
        GetDataSz(trcf.fields.uData1, dwData1, szTemp2);
        lstrcpyA(szTemp, szDebugMsg);
        wsprintfA(szDebugMsg, "%s%s ", szTemp, szTemp2);
    }

    // Interpret the second data value.
    if (TRCDATANONE != trcf.fields.uData2)
    {
        if (TRCDATADEFAULT == trcf.fields.uData2)
            dwData2 = dwError;
        GetDataSz(trcf.fields.uData2, dwData2, szTemp2);
        lstrcpyA(szTemp, szDebugMsg);
        wsprintfA(szDebugMsg, "%s%s", szTemp, szTemp2);
    }

    if (fVerbose)
    {
        // Handle scope (Internal/External call)
        if (TRCSCOPENONE != trcf.fields.uScope)
        {
            sprintf(szTemp, "SCOPE: %s ", TrcScope[trcf.fields.uScope]);
            strcat(szDebugMsg, szTemp);
        }

        // Handle subsytem (TOM, ITextServices, etc.)
        if (TRCSUBSYSNONE != trcf.fields.uSubSystem)
        {
            sprintf(szTemp, "SUBSYSTEM: %s ", TrcSubsys[trcf.fields.uSubSystem]);
            strcat(szDebugMsg, szTemp);
        }

        // Handle process ID, thread ID, file and line.
        sprintf(szTemp, "PID: %u TID: %u ", pid, tid);
        strcat(szDebugMsg, szTemp);
    }

    // Up to now there is no real danger of overflowing our buffer since
    // we were dealing with strings of small size.  Now we will be running
    // in to paths and user strings.  We will use _snprintf to concatonate
    // new stuff to our message.  This is not the most effecient way since
    // it involves alot of copying, but it is a fairly simple way to keep
    // adding to our string without having to worry about how much room is
    // left in the buffer.  It will truncate if we go past the end.
    if (NULL != szFile)
    {
        lstrcpyA(szTemp, szDebugMsg);

        if (0 != iLine)
        {
            wsprintfA(szDebugMsg, "%sFILE: %s (%u) ",
                szTemp, szFile, iLine);
        }
        else
        {
            wsprintfA(szDebugMsg, "%sFILE: %s ",
                szTemp, szFile);
        }
    }

    // Append a CRLF to the end of the string (make sure we don't overflow)
    cch = strlen(szDebugMsg);
    pch = szDebugMsg;
    if (cch < (MAXDEBUGSTRLEN - 3))
        pch += cch;
    else
        pch += (MAXDEBUGSTRLEN - 3);

    lstrcpyA(pch, "\r\n");

    if (fLogging)
        LogDebugString(szDebugMsg);

    // Write to debug output.
    OutputDebugStringA(szDebugMsg);
}

/*
 *	Tracef
 *
 *	@mfunc:
 *      The given format string and parameters are used to render a
 *      string into a buffer. This string is passed to TraceMsg.
 *      The severity parameter determines the type of message.  The
 *      following values are valid: TRCSEVWARN, TRCSEVERR, TRCSEVINFO.
 *	
 *	Arguments:
 *      dwSev   Severity of message.
 *		szFmt	Format string for wvsprintf (qqv)
 */
void Tracef(DWORD dwSev, LPSTR szFmt, ...)
{
	va_list	valMarker;
    char rgchTraceTagBuffer[MAXDEBUGSTRLEN];

	//	format out a string
	va_start(valMarker, szFmt);
	wvsprintfA(rgchTraceTagBuffer, szFmt, valMarker);
	va_end(valMarker);

	if (dwSev == TRCSEVERR)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else if (dwSev == TRCSEVWARN)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
    else if (dwSev == TRCSEVINFO)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVINFO, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else if (dwSev == TRCSEVMEM)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVMEM, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVNONE, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
}

/*
 *	TraceError
 *
 *	@mfunc:
 *		This function is for compatibility with old debug functionality.
 *      An error message is generated and sent to TraceMsg.
 *	
 */
void TraceError(LPSTR sz, LONG sc)
{
	if (FAILED(sc))
	{
        char rgchTraceTagBuffer[MAXDEBUGSTRLEN];

		wsprintfA(rgchTraceTagBuffer,
				  "%s, error=%ld (%#08lx).", sz, sc, sc);
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	}
}

/*
 *  CheckTrace
 *	
 *  @mfunc
 *      This function checks to see if tracing should be performed
 *      in a function given the debug options set and the subsystem
 *      the function is in.
 *      ptrcf   - Pointer to TrcFlags structure passed to CTrace.
 *
 *  @rdesc
 *      True if tracing should be performed, false otherwise.
 *
 */
static BOOL CheckTrace(TrcFlags * ptrcf)
{
    DWORD dwOpt;

    //Set dwOpt to the correct value for the subsytem we are
    //in.
    switch (ptrcf->fields.uSubSystem)
    {
        case TRCSUBSYSDISP: dwOpt = OPTTRACEDISP;   break;
        case TRCSUBSYSWRAP: dwOpt = OPTTRACEWRAP;   break;
        case TRCSUBSYSEDIT: dwOpt = OPTTRACEEDIT;   break;
        case TRCSUBSYSTS:   dwOpt = OPTTRACETS;     break;
        case TRCSUBSYSTOM:  dwOpt = OPTTRACETOM;    break;
        case TRCSUBSYSOLE:  dwOpt = OPTTRACEOLE;    break;
        case TRCSUBSYSBACK: dwOpt = OPTTRACEBACK;   break;
        case TRCSUBSYSSEL:  dwOpt = OPTTRACESEL;    break;
        case TRCSUBSYSHOST: dwOpt = OPTTRACEHOST;   break;
        case TRCSUBSYSDTE:  dwOpt = OPTTRACEDTE;    break;
        case TRCSUBSYSUNDO: dwOpt = OPTTRACEUNDO;   break;
        case TRCSUBSYSRANG: dwOpt = OPTTRACERANG;   break;
        case TRCSUBSYSUTIL: dwOpt = OPTTRACEUTIL;   break;
        case TRCSUBSYSNOTM: dwOpt = OPTTRACENOTM;   break;
        case TRCSUBSYSRTFR: dwOpt = OPTTRACERTFR;   break;
        case TRCSUBSYSRTFW: dwOpt = OPTTRACERTFW;   break;
        case TRCSUBSYSPRT:  dwOpt = OPTTRACEPRT;    break;
        case TRCSUBSYSFE:   dwOpt = OPTTRACEFE;     break;
        case TRCSUBSYSFONT: dwOpt = OPTTRACEFONT;   break;
        default:
             return FALSE;
    }

    //If there is no tracing at any level enabled, return false.
    if (!ISOPTSET(dwOpt) && !fTrace
        && !(fTraceExt && (ptrcf->fields.uScope == TRCSCOPEEXTERN)))
        return FALSE;

    return TRUE;
}

/*
 *  CTrace::CTrace
 *	
 *  @mfunc
 *      This constructor is used to generate output about the function
 *      it is called from.  Creating an instance of this class on the
 *      stack at the beginning of a function, will cause a trace message
 *      to be sent to the debug output.  When the function returns, the
 *      destructor will be called automatically and another message
 *      will be sent to the debug output.
 *      This constructor takes several parameters to pass on to
 *      TraceMsg and it also stores certain data for use by the destructor.
 *      
 *      dwFlags - Packed values tell us how to generate the message.
 *      dw1     - The first of two data parameters.  This must be
 *                the name of the function we were called from.
 *      dw2     - The second of two data parameters.  This will be either
 *                unused or it will be a parameter to be interpreted by
 *                TraceMsg.
 *      szFile  - File name we were called from.
 *
 */
CTrace::CTrace(DWORD dwFlags, DWORD dw1, DWORD dw2, LPSTR szFile)
{
    char szFunc[80];
    int tls;

    trcf.dw = dwFlags;

    //Return if tracing is not enabled.
    if (!CheckTrace(&trcf))
        return;

    //Increment indentation level on entrance to function
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    tls++;
    TlsSetValue(TlsIndex, (LPVOID)(DWORD_PTR)tls);

    szFunc[0] = '\0';
    lstrcpyA(szFileName, szFile);
    lstrcpyA(szFuncName, (LPSTR)(DWORD_PTR)dw1);

    sprintf(szFunc, "IN : %s.", szFuncName);

    TraceMsg (trcf.dw, (DWORD)(DWORD_PTR)szFunc, dw2, szFileName, 0);
}


/*
 *  CTrace::~CTrace
 *	
 *  @mfunc
 *      This destructor is used to generate output about the function
 *      it is called from.  Creating an instance of this class on the
 *      stack at the beginning of a function, will cause a trace message
 *      to be sent to the debug output.  When the function returns, the
 *      destructor will be called automatically and another message
 *      will be sent to the debug output.
 *
 *
 */
CTrace::~CTrace()
{
    char szFunc[80];
    int tls;

    //Return if tracing is not enabled.
    if (!CheckTrace(&trcf))
        return;

    szFunc[0] = '\0';
    sprintf(szFunc, "OUT: %s.", szFuncName);

    trcf.fields.uData2 = TRCDATANONE;
    TraceMsg (trcf.dw, (DWORD)(DWORD_PTR)szFunc, 0, szFileName, 0);

    //Decrement indentation level on exit from function
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    tls--;
    TlsSetValue(TlsIndex, (LPVOID)(DWORD_PTR)tls);
}

#endif //!_RELEASE_ASSERTS_

#endif // NOFULLDEBUG

#endif // !!(DEBUG) && !! _RELEASE_ASSERTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\dcattrs.h ===
/*
 *
 *  Copyright (C) Microsoft Corporation, 1999-2000
 *
 *  File: dcattrs.h
 *
 *  List of standard attributes.
 *
 */


DEFINE_GUID(DCATTRID_OTHERS,                            0xb3c32af9,0x57d0,0x46a9,0xbc,0xa8,0xda,0xc2,0x38,0xa1,0x30,0x57);

DEFINE_GUID(DCATTRID_Font,                              0x573ea825,0x749b,0x4f8a,0x9c,0xfd,0x21,0xc3,0x60,0x5c,0xa8,0x28);
DEFINE_GUID(DCATTRID_Font_FaceName,                     0xb536aeb6,0x053b,0x4eb8,0xb6,0x5a,0x50,0xda,0x1e,0x81,0xe7,0x2e);
DEFINE_GUID(DCATTRID_Font_SizePts,                      0xc8493302,0xa5e9,0x456d,0xaf,0x04,0x80,0x05,0xe4,0x13,0x0f,0x03);
DEFINE_GUID(DCATTRID_Font_Style,                        0x68b2a77f,0x6b0e,0x4f28,0x81,0x77,0x57,0x1c,0x2f,0x3a,0x42,0xb1);
DEFINE_GUID(DCATTRID_Font_Style_Bold,                   0x48813a43,0x8a20,0x4940,0x8e,0x58,0x97,0x82,0x3f,0x7b,0x26,0x8a);
DEFINE_GUID(DCATTRID_Font_Style_Italic,                 0x8740682a,0xa765,0x48e1,0xac,0xfc,0xd2,0x22,0x22,0xb2,0xf8,0x10);
DEFINE_GUID(DCATTRID_Font_Style_SmallCaps,              0xfacb6bc6,0x9100,0x4cc6,0xb9,0x69,0x11,0xee,0xa4,0x5a,0x86,0xb4);
DEFINE_GUID(DCATTRID_Font_Style_Underline,              0xc3c9c9f3,0x7902,0x444b,0x9a,0x7b,0x48,0xe7,0x0f,0x4b,0x50,0xf7);
DEFINE_GUID(DCATTRID_Font_Style_Underline_Single,       0x1b6720e5,0x0f73,0x4951,0xa6,0xb3,0x6f,0x19,0xe4,0x3c,0x94,0x61);
DEFINE_GUID(DCATTRID_Font_Style_Strikethrough,          0x0c562193,0x2d08,0x4668,0x96,0x01,0xce,0xd4,0x13,0x09,0xd7,0xaf);
DEFINE_GUID(DCATTRID_Font_Style_Strikethrough_Single,   0x75d736b6,0x3c8f,0x4b97,0xab,0x78,0x18,0x77,0xcb,0x99,0x0d,0x31);
DEFINE_GUID(DCATTRID_Font_Style_Overline,               0xe3989f4a,0x992b,0x4301,0x8c,0xe1,0xa5,0xb7,0xc6,0xd1,0xf3,0xc8);
DEFINE_GUID(DCATTRID_Font_Style_Overline_Single,        0x8440d94c,0x51ce,0x47b2,0x8d,0x4c,0x15,0x75,0x1e,0x5f,0x72,0x1b);
DEFINE_GUID(DCATTRID_Font_Style_Subscript,              0x5774fb84,0x389b,0x43bc,0xa7,0x4b,0x15,0x68,0x34,0x7c,0xf0,0xf4);
DEFINE_GUID(DCATTRID_Font_Style_Superscript,            0x2ea4993c,0x563c,0x49aa,0x93,0x72,0x0b,0xef,0x09,0xa9,0x25,0x5b);
DEFINE_GUID(DCATTRID_Font_Style_Color,                  0x857a7a37,0xb8af,0x4e9a,0x81,0xb4,0xac,0xf7,0x00,0xc8,0x41,0x1b);

DEFINE_GUID(DCATTRID_Text_VerticalWriting,              0x6bba8195,0x046f,0x4ea9,0xb3,0x11,0x97,0xfd,0x66,0xc4,0x27,0x4b);
DEFINE_GUID(DCATTRID_Text_RightToLeft,                  0xca666e71,0x1b08,0x453d,0xbf,0xdd,0x28,0xe0,0x8c,0x8a,0xaf,0x7a);
DEFINE_GUID(DCATTRID_Text_Language,                     0xd8c04ef1,0x5753,0x4c25,0x88,0x87,0x85,0x44,0x3f,0xe5,0xf8,0x19);
DEFINE_GUID(DCATTRID_Text_ReadOnly,                     0x85836617,0xde32,0x4afd,0xa5,0x0f,0xa2,0xdb,0x11,0x0e,0x6e,0x4d);

DEFINE_GUID(DCATTRID_Text_Orientation,                  0x6bab707f,0x8785,0x4c39,0x8b,0x52,0x96,0xf8,0x78,0x30,0x3f,0xfb);

DEFINE_GUID(DCATTRID_App,                               0xa80f77df,0x4237,0x40e5,0x84,0x9c,0xb5,0xfa,0x51,0xc1,0x3a,0xc7);
DEFINE_GUID(DCATTRID_App_IncorrectSpelling,             0xf42de43c,0xef12,0x430d,0x94,0x4c,0x9a,0x08,0x97,0x0a,0x25,0xd2);
DEFINE_GUID(DCATTRID_App_IncorrectGrammar,              0xbd54e398,0xad03,0x4b74,0xb6,0xb3,0x5e,0xdb,0x19,0x99,0x63,0x88);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\dispprt.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	dispprt.cpp	-- Special logic for printer object |
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Jon Matousek
 */
#include "_common.h"
#include "_dispprt.h"
#include "_edit.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_select.h"

#define PARA_NUMBER_NOT_SET ((WORD) -1)

ASSERTDATA

/*
 *	CDisplayPrinter::CDisplayPrinter(ped, hdc, x, y, prtcon)
 *
 *	@mfunc
 *		Contructs a object that can be used to print a text control
 */
CDisplayPrinter::CDisplayPrinter(
	CTxtEdit* ped,		//@parm CTxtEdit
	HDC hdc, 			//@parm HDC for drawing
	RECT *prc, 			//@parm dimensions of current area to print to.
	SPrintControl prtcon//@parm Special controls for this print object
)	
	: CDisplayML(ped), _prtcon(prtcon)
{
	TRACEBEGIN(TRCSUBSYSPRT, TRCSCOPEINTERN, "CDisplayPrinter::CDisplayPrinter");
	Assert (hdc);

	_fNoUpdateView = TRUE;

	SetTflow(ped->_pdp->GetTflow());

	GetDupDvpFromRect(*prc, GetTflow(), _dulTarget, _dvlTarget);
	_wNumber = PARA_NUMBER_NOT_SET;
}

/*
 *	CDisplayPrinter::SetPrintDimensions(prc)
 *
 *	@mfunc
 *		Set area to print.
 */
void CDisplayPrinter::SetPrintDimensions(
	RECT *prc)			//@parm dimensions of current area to print to.
{
	GetDupDvpFromRect(*prc, GetTflow(), _dulTarget, _dvlTarget);
}

/*
 *	CDisplayPrinter::FormatRange(cpFirst, cpMost)
 *
 *	@mfunc
 *		Format a range of text into this display and used only for printing.
 *
 *	@rdesc
 *		actual end of range position (updated)	
 */
LONG CDisplayPrinter::FormatRange(
	LONG cpFirst, 		//@parm Start of text range
	LONG cpMost,		//@parm End of text range
	BOOL fWidowOrphanControl)	//@parm If TRUE, suppress widow/orphan
{
	TRACEBEGIN(TRCSUBSYSPRT, TRCSCOPEINTERN, "CDisplayPrinter::FormatRange");

	LONG		cch;
	WCHAR		ch;
	BOOL		fFirstInPara = TRUE;
	CLine		liTarget;
	CLine	*	pliNew = NULL;
	LONG		dvp;
	LONG		dvt;
	const CDevDesc *pddTarget = GetDdTarget() ? GetDdTarget() : this;

	// Set client height for zooming
	_dvpClient = LYtoDY(_dvlTarget);

	// Set maximum in terms of target DC.
	LONG	dvtMax = pddTarget->LYtoDY(_dvlTarget);

	if(cpMost < 0)
		cpMost = _ped->GetTextLength();

	CMeasurer me(this);
	
	cpFirst = me.SetCp(cpFirst);		// Validate cpFirst while setting me
	ch = me.GetChar();

	// TODO: COMPATIBILITY ISSUE:  Richedit 1.0 adjusted to before a
	// CRLF/CRCRLF boundary.  if_ped->fUseCRLF(), adjust accordingly

	_cpMin = cpFirst;
	_cpFirstVisible = cpFirst;
	
	dvt = 0;
	dvp = 0;
	if(me.GetCp())
		fFirstInPara = me._rpTX.IsAfterEOP();

	// Clear line CArray
	DeleteSubLayouts(0, -1);
	Clear(AF_DELETEMEM);

	// Assume that we will break on words
	UINT uiBreakAtWord = MEASURE_BREAKATWORD;

	if(_prtcon._fPrintFromDraw)
	{
		// This is from Draw so we want to take inset into account
		LONG dut = LYtoDY(_dulTarget);

		GetViewDim(dut, dvtMax);
		_dupView = dut;

		// Restore client height
		_dvpClient = this->LYtoDY(_dvlTarget);
	}
	else			// Message-based printing always does word wrap
		SetWordWrap(TRUE);

	// Set paragraph numbering. This is a fairly difficult problem
	// because printing can start anywhere and end anywhere. However,
	// most printing will involve a contiguous range of pages. Therefore,
	// we cache the paragraph number and the cp for that number and
	// only resort to looking in the line array if the cached information
	// has become invalid.
	if ((PARA_NUMBER_NOT_SET == _wNumber) || (cpFirst != _cpForNumber))
	{
		CLinePtr rp(_ped->_pdp);
		rp.SetCp(cpFirst, FALSE);
		_wNumber = rp.GetNumber();
		_cpForNumber = cpFirst;
	}
	
	me.SetNumber(_wNumber);
	
	while(me.GetCp() < cpMost)
	{
		// Add one new line
		pliNew = Add(1, NULL);
		if(!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto err;
		}

		// Store the current number of the paragraph. We do it
		// here because we have to measure and that potentially
		// updates the number of the paragraph in the measurer
		// for a line that might not be on the page.
		_wNumber = me.GetNumber();

		// Stuff some text into this new line
		if(!Measure(me, pliNew, Count() - 1, uiBreakAtWord | (fFirstInPara ? MEASURE_FIRSTINPARA : 0), &liTarget))
		{
			Assert(FALSE);
			goto err;
		}

		//FUTURE (keithcu) We break tables across pages on row boundaries which
		//isn't very granular--especially in the HTML world.

		// Note, we always put at least one line on a page. Otherwise, if the 
		// first line is too big, we would cause our client to infinite loop
		// because we would never advance the print cp.
		if(_cel > 1 && (dvt + liTarget.GetHeight() > dvtMax))
		{
			cch = -pliNew->_cch;		// Bump last line to next page
			_cel--;						// One less line

#if 0
			CLine *pli = pliNew - 1;	// Point at previous line

			// If this line and the previous one are in the same para and
			// either this one ends in an EOP or the previous one starts
			// a para, bump both to following page (widow/orphan)
			if(fWidowOrphanControl)
			{
				if(_cel > 1 && !fFirstInPara &&
				   (pli->_bFlags & fliFirstInPara || (pliNew->_bFlags & fliHasEOP)))
				{
					cch -= pli->_cch;
					_cel--;					// One less line
					pli--;					// Point to previous line
				}
				if(_cel > 1 && pli->_nHeading)
				{							// Don't end page with a heading
					cch -= pli->_cch;
					_cel--;					// One less line
				}
			}
#endif
			me.Move(cch);			// Move back over lines discarded
			delete pliNew->GetPlo(); //Delete the CLayout which didn't get added to the CLineArray
			break;
		}

		fFirstInPara = (pliNew->_fHasEOP);

		dvt += liTarget.GetHeight();
		dvp += pliNew->GetHeight();
		if (me.GetPrevChar() == FF)
			break;
	}

	// If there was no text, then add a single blank line
	if(!pliNew)
	{
		pliNew = Add(1, NULL);
		if(!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto err;
		}
		me.NewLine(fFirstInPara);
		*pliNew = me._li;
	}

	// Update display height
	_dvp = dvp;

	// Update display width
	_dupLineMax = CalcDisplayDup();

	cpMost = me.GetCp();
	_cpCalcMax = cpMost;
	_vpCalcMax = _dvp;

	// Update paragraph caching information.
	_cpForNumber = cpMost;

	return cpMost;

err:
	DeleteSubLayouts(0, -1);
	Clear(AF_DELETEMEM);
	_dupLineMax = 0;
	_dvp = 0;
	return -1;
}

/*
 *	CDisplayPrinter::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height for TXTNS_FITTOCONTENT.
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 *
 *	@devnote
 *		This assumes that FormatRange was called just prior to this.
 */
HRESULT	CDisplayPrinter::GetNaturalSize(
	HDC hdcDraw,		//@parm DC for drawing
	HDC hicTarget,		//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Width in device units to use for fitting 
	LONG *pheight)		//@parm Height in device units to use for fitting
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayPrinter::GetNaturalSize");

	*pwidth = _dupLineMax;
	*pheight = _dvp;
	return S_OK;
}

/*
 *	CDisplayPrinter::IsPrinter()
 *
 *	@mfunc
 *		Returns whether this is a printer
 *
 *	@rdesc
 *		TRUE - is a display to a printer
 *		FALSE - is not a display to a printer
 */
BOOL CDisplayPrinter::IsPrinter() const
{
	AssertSz(_hdc, "CDisplayPrinter::IsPrinter no hdc set");
	
	return GetDeviceCaps(_hdc, TECHNOLOGY) == DT_RASPRINTER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\dispsl.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	DISPSL.CPP -- CDisplaySL class |
 *
 *		This is the Single-line display engine.  See disp.c for the base class
 *		methods and dispml.c for the Multi-line display engine.
 *	
 *	Owner:<nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_dispsl.h"
#include "_measure.h"
#include "_select.h"
#include "_render.h"
#include "_font.h"
#include "_dfreeze.h"

ASSERTDATA

const LONG CALC_XSCROLL_FROM_FIRST_VISIBLE = -2;

/*
 *	CDisplaySL::CDisplaySL
 *
 *	Purpose	
 *		Constructor
 */
CDisplaySL::CDisplaySL ( CTxtEdit* ped )
  : CDisplay( ped )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CDisplaySL");

	Assert(!_fMultiLine);
}

/*
 *	CDisplaySL::Init()
 *
 *	@mfunc	
 *		Init this display for the screen
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplaySL::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::Init");

	// Initialize our base class
	if(!CDisplay::Init())
		return FALSE;

    SetWordWrap(FALSE);
    return TRUE;
}

/*
 *	CDisplaySL::InitVars()
 *
 */
void CDisplaySL::InitVars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InitVars");

    _upScroll = 0;
	SetCpFirstVisible(0);
}

/*
 *	CDisplaySL::RecalcView(fUpdateScrollBars, prc)
 *
 *	@mfunc
 *		Recalc all lines breaks and update first visible line
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::RecalcView(
	BOOL	fUpdateScrollBars,	//@param TRUE - update scroll bars
	RECTUV* prc)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::RecalcView");
	LONG dupOld = _dup;

    if(!RecalcLine())
        return FALSE;

    if(_fViewChanged)
    {
		if(IsActive() || _dup <= GetDupView())
		{
			_upScroll = 0;
			SetCpFirstVisible(0);
		}
		else if(CALC_XSCROLL_FROM_FIRST_VISIBLE == _upScroll)
		{
			// In this case we want to set our upScroll by a visible. The
			// only way to get here is if the active view has been cloned
			// for displaying an inactive view.
 			_upScroll = 0;				// Assume that first visible is 0
			if(GetFirstVisibleCp())		// Check first visible
			{
				CMeasurer me(this);		// Start at cp 0
				me.NewLine(*this);		// Measure from there to where we are
		
				// Scroll is length to character
				_upScroll = CLine::UpFromCch(me, GetFirstVisibleCp(), TA_TOP);
			}
		}
		if(fUpdateScrollBars)
       		UpdateScrollBar(SB_HORZ, TRUE);

		_fViewChanged = FALSE;
    }

	// We only resize if width of single line control has changed.
	if(_dup != dupOld)
	{
		if (FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();

		else if (prc && _ped->_fInOurHost) /*bug fix# 5830, forms3 relies on old behavior*/
			_ped->TxGetClientRect(prc);
	}
    return TRUE;
}

/*
 *	CDisplaySL::RecalcLine()
 *
 *	@mfunc
 *		Recalculate a line
 *
 *	@rdesc
 *		TRUE if success <nl>
 *		FALSE if failure <nl>
 */
BOOL CDisplaySL::RecalcLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::RecalcLine");

    Assert( _ped );

	// Create a measurer starting at cp = 0
	CMeasurer me(this);

	LONG dupOld = _dup;
	BOOL fMeasured = CLine::Measure(me, MEASURE_FIRSTINPARA);

	if(!fMeasured)
	{
		Assert(FALSE);						// Should succeed
	    InitVars();
	    return FALSE;
	}

	_fNeedRecalc = FALSE;
	_fRecalcDone = TRUE;

	if(dupOld != _dup)
		_fViewChanged = TRUE;

	_fLineRecalcErr = FALSE;
	return fMeasured;
}

/*
 *	CDisplaySL::Render(rcView, rcRender)
 *
 *	@mfunc	
 *		Renders this line
 */
void CDisplaySL::Render(
	const RECTUV &rcView,	//@parm View RECT
	const RECTUV &rcRender)	//@parm RECT to render (must be contained in
							//		client rect)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::Render");
    POINTUV	pt;

	_fRectInvalid = FALSE;

	CRenderer re(this);

    if(!re.StartRender(rcView, rcRender))
        return;

    // Set renderer at top/left of view rect
    pt.u = rcView.left - _upScroll;
    pt.v = rcView.top;
    re.SetCurPoint(pt);
    // Renderer is set at cp = 0 at the moment
	CLine::Render(re, TRUE);
	re.EndRender(this, this, 0, pt);

	if(_fOffscreenOnce)
		_fUseOffscreenDC = _fOffscreenOnce = FALSE;

    // If line metrics are not yet up to date, get them from renderer
    if(_dup == -1)
    {
        _dup			= re._li._dup;
        _dvpHeight		= re._li._dvpHeight;
        _dvpDescent		= re._li._dvpDescent;
    }
}

/*
 *	CDisplaySL::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Wait until line array is recalculated up to line <p ili>
 *
 *	@rdesc
 *		Returns TRUE if lines were recalc'd up to ili (TRUE if ili == 0)
 */
BOOL CDisplaySL::WaitForRecalcIli (
	LONG ili)		//@parm Line index to recalculate line array up to
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::WaitForRecalcIli");

    return ili == 0;
}

/*
 *	CDisplaySL::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range for scrollbar <p nBar>
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplaySL::GetScrollRange(
	INT nBar) const		//@parm Scroll bar to interrogate (SB_VERT or SB_HORZ)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetScrollRange");

    Assert( IsMain() );

	LONG lRange = 0; 

    if(nBar != SB_VERT && _fUScrollEnabled)
    {
	    if(_ped->TxGetScrollBars() & WS_HSCROLL)
		{
			lRange = max(0, _dup + _ped->GetCaretWidth());
			lRange = min(lRange, _UI16_MAX);
		}
    }
	return lRange;
}

/*
 *	CDisplaySL::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update horizontal scroll bar
 *		Also figure whether the scroll bar should be visible or not
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplaySL::UpdateScrollBar (
	INT	 nBar,				//@parm Which scrollbar: SB_HORZ or SB_VERT
	BOOL fUpdateRange)		//@parm Should range be recomputed and updated
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::UpdateScrollBar");

	// Note: In the old days we didn't allow autosize & scroll bars, so to keep
	// forms working, we need this special logic with respect to autosize.
	if (!IsActive() || SB_VERT == nBar ||
		!_ped->fInOurHost() && _ped->TxGetAutoSize())
	{
		// Scroll bars are only updated on active views.
		return FALSE;
	}

	const DWORD dwScrollBars = _ped->TxGetScrollBars();
	const BOOL fHide = !(dwScrollBars & ES_DISABLENOSCROLL);
	BOOL fReturn = FALSE;
	BOOL fEnabled = TRUE;
	BOOL fEnabledOld = FALSE;
	LONG lScroll = 0;
	CTxtSelection *psel = _ped->GetSelNC();

	// Get scrolling position
	if(nBar == SB_HORZ)
	{
		if(!(dwScrollBars & WS_HSCROLL))
		{
			// even if we don't have scrollbars, we may allow horizontal
			// scrolling.

			if(!_fUScrollEnabled)
				_fUScrollEnabled = !!(dwScrollBars & ES_AUTOHSCROLL);
			return FALSE;
		}

		fEnabledOld = _fUScrollEnabled;
		lScroll = ConvertUPosToScrollPos(_upScroll);

        if(_dup <= _dupView)
            fEnabled = FALSE;
	}

	// !s beforehand because all true values aren't necessarily equal
	if(!fEnabled != !fEnabledOld)
	{
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			if (nBar == SB_HORZ)
				_fUScrollEnabled = fEnabled;
			else
				_fVScrollEnabled = fEnabled;
		}

		if(!_fDeferUpdateScrollBar)
		{
    		if(!fHide)					// Don't hide scrollbar, just disable
    			_ped->TxEnableScrollBar(nBar, fEnabled ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
    		else 
    		{
    			fReturn = TRUE;
    			// Make sure to hide caret before showing scrollbar
    			if(psel)
    				psel->ShowCaret(FALSE);

    			// Hide or show scroll bar
    			_ped->TxShowScrollBar(nBar, fEnabled);

    			if(psel)
    				psel->ShowCaret(TRUE);
            }
		}
	}
	
	// Set scrollbar range and thumb position
	if(fEnabled)
	{
        if(fUpdateRange)
        {
			if(!_fDeferUpdateScrollBar)
				_ped->TxSetScrollRange(nBar, 0, GetScrollRange(nBar), FALSE);
        }
        
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
			_ped->TxSetScrollPos(nBar, lScroll, TRUE);
	}
	else if (!_fDeferUpdateScrollBar)
	{
		// This turns off the scroll bar and only needs to happen when a change 
		// occurs so we can count on the change in state check above to set
		// _fUpdateScrollBarDeferred.
		if (!fEnabled && fEnabledOld)
			_ped->TxSetScrollRange(nBar, 0, 0, FALSE);
	}
	return fReturn;
}

BOOL CDisplaySL::IsMain() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::IsMain");

    return TRUE;
}

LONG CDisplaySL::GetDupLineMax() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetWidth");

    return CLine::_dup;
}

LONG CDisplaySL::GetHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetHeight");

    return CLine::_dvpHeight;
}

LONG CDisplaySL::GetResizeHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetResizeHeight");

    return CLine::_dvpHeight;
}

LONG CDisplaySL::LineCount() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::LineCount");

    return 1; 
}

/*
 *	CDisplaySL::GetCliVisible()
 *
 *	@mfunc
 *		Get count of visible lines and update GetCp()MostVisible for PageDown()
 *
 *	@rdesc
 *		count of visible lines
 */
LONG CDisplaySL::GetCliVisible (
	LONG* pcpMostVisible,				//@parm Returns cpMostVisible
	BOOL fLastCharOfLastVisible) const 	//@parm Want cp of last visible char
										// (ignored here).
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetCliVisible");

    if (pcpMostVisible)
        *pcpMostVisible = CLine::_cch;
    
    return 1;
}

LONG CDisplaySL::GetFirstVisibleLine() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetFirstVisibleLine");

    return 0;
}

/*
 *	CDisplaySL::GetLineText(ili, pchBuff, cchMost)
 *
 *	@mfunc
 *		Copy given line of this display into a character buffer
 *
 *	@rdesc
 *		number of character copied
 */
LONG CDisplaySL::GetLineText (
	LONG	ili,		//@parm Line to get text of
	TCHAR *	pchBuff,	//@parm Buffer to stuff text into
	LONG	cchMost)	//@parm Length of buffer
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetLineText");

    if(ili == 0)
    {
        cchMost = min(cchMost, _ped->GetTextLength());
        if(cchMost > 0)
        {
            CTxtPtr tp(_ped, 0);
            return tp.GetText( cchMost, pchBuff );
        }
    }
    return 0;
}

/*
 *	CDisplaySL::CpFromLine(ili, pdvp)
 *
 *	@mfunc
 *		Computes cp at start of given line 
 *		(and top of line position relative to this display)
 *
 *	@rdesc
 *		cp of given line; here always 0
 */
LONG CDisplaySL::CpFromLine (
	LONG ili,		//@parm Line we're interested in (if <lt> 0 means caret line)
	LONG *pdvp)		//@parm Returns top of line relative to display 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CpFromLine");
					//  	(NULL if don't want that info)
    Assert( ili == 0 );
    
    if(pdvp)
        *pdvp = 0;
    
    return 0;
}

/*
 *	CDisplaySL::LineFromCp(cp, fAtEnd)
 *
 *	@mfunc
 *		Computes line containing given cp.
 *
 *	@rdesc
 *		index of line found; here returns 0 always
 */
LONG CDisplaySL::LineFromCp(
	LONG cp,		//@parm cp to look for
	BOOL fAtEnd)	//@parm If true, return previous line for ambiguous cp
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::LineFromCp");

    return 0;
}

/*
 *	CDisplaySL::CpFromPoint(pt, prcClient, ptp, prp, fAllowEOL, pHit, pdispdim)
 *
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CDisplaySL::CpFromPoint(
	POINTUV		pt,			//@parm Point to compute cp at (client coords)
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const ptp,	//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual,	//@parm Out cp that pt is above
	CLine *		pliParent)	//@parm Parent pli for table row displays
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::CpFromPoint");

    RECTUV  rcView;
	LONG cp = 0;
	LONG cch = 0;

	HITTEST		hit = HT_Nothing;

    GetViewRect(rcView, prcClient);

	if (pt.v >= rcView.top && pt.v <= rcView.bottom)
	{

		// Create measurer at cp(0)
		CMeasurer me(this);

		// Get character in the line
		pt.u += _upScroll - rcView.left;		// Transform to galley coordinates
		pt.v -= rcView.top;
		cch = CLine::CchFromUp(me, pt, pdispdim, &hit, pcpActual);

		// Don't allow click at EOL to select EOL marker and take into account
		// single line edits as well
		if(!fAllowEOL && cch == CLine::_cch && CLine::_cchEOP)
			me._rpTX.BackupCRLF();

		cp = me.GetCp();
	}

	if (phit)
		*phit = hit;
    if(ptp)
        ptp->SetCp(cp);
    if(prp)
        prp->Set(0, cch);
 
 	return cp;   
}

/*
 *	CDisplaySL::PointFromTp(tp, fAtEnd, pt, prp, taMode, pdx)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CDisplaySL::PointFromTp(
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of previous line for ambiguous cp
	POINTUV &		pt,		//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::PointFromTp");

	LONG	 dy = 0;
    RECTUV	 rcView;
    CLinePtr rp(this);

    if(!rp.SetCp(rtp.GetCp(), fAtEnd))
        return -1;

    AssertSz(_ped->_fInPlaceActive || prcClient, 
		"CDisplaySL::PointFromTp() called with invalid client rect");

    GetViewRect(rcView, prcClient);

    pt.u = rcView.left - _upScroll;
    pt.v = rcView.top;

    CMeasurer me(this, rtp);
    me.Move(-rp.GetIch());		// Backup to start of line      
    me.NewLine(*rp);				// Measure from there to where we are

	pt.u += CLine::UpFromCch(me, rp.GetIch(), taMode, pdispdim, &dy);
	pt.v += dy;

    if(prp)
        *prp = rp;
    return rp;
}

/*
 *	CDisplaySL::UpdateView(&tpFirst, cchOld, cchNew)
 *
 *	@mfunc
 *		Update visible part of display (the "view" on the screen).
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::UpdateView(
	CRchTxtPtr &tpFirst,	//@parm Text ptr where change happened
	LONG cchOld,			//@parm Count of chars deleted
	LONG cchNew)			//@parm Count of chars inserted
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::UpdateView");

    BOOL fUpdateScrollBarHorz = FALSE;
    BOOL fReturn = TRUE;
    RECTUV rcView;
	CTxtSelection *psel = _ped->GetSelNC();
	LONG dupOld = _dup;
	BOOL fScrollChanged = FALSE;
	RECTUV rcClient;
	RECTUV rc;
	LONG dvpOld = _dvpHeight;
                                                              
    if (_fNoUpdateView)
        return fReturn;

	AssertSz(_ped->_fInPlaceActive, "CDisplaySL::UpdateView(...) called when inactive");

    _ped->TxGetClientRect(&rcClient);
    GetViewRect(rcView, &rcClient);
    
    if(psel && !psel->PuttingChar())
        psel->ClearCchPending();

    if(!RecalcLine())
    {
        // We're in deep crap now, the recalc failed. Let's try to get
		// out of this with our head still mostly attached
        fReturn = FALSE;
    }

	// An update has occurred. Go offscreen to be flicker-free.
	if(!_fUseOffscreenDC)
		_fUseOffscreenDC = _fOffscreenOnce = TRUE;

	//If we tried to go offscreen, but the edit changed the first
	//character, it might be the WM_SETTEXT case called when dialogs
	//are instantiated, and so it doesn't make sense to go offscreen there.
	if (_fOffscreenOnce && tpFirst.GetCp() == 0)
		_fOffscreenOnce = _fUseOffscreenDC = FALSE;

    if(_dup <= _dupView)
    {
        // x scroll range is smaller than the view width
        // force x scrolling position = 0
        _upScroll = 0;
		SetCpFirstVisible(0);
		_fViewChanged = TRUE;
        fUpdateScrollBarHorz = TRUE;
    }

	_fRectInvalid = TRUE;

	// Only resize a Single Line edit control if the width changes
	if(_dup != dupOld)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
	}

	// If view changed, update scroll bars
    if(_fViewChanged)
	{
		_fViewChanged = FALSE;
        fScrollChanged = UpdateScrollBar(SB_HORZ);
	}

	// Scroll bar state did not change so we need to update screen
	// Build an invalidation rectangle. 
	rc = rcClient;
	if(dvpOld == _dvpHeight)
	{
		// Height of control did not change so we can minimize the update 
		// rectangle to the height of the control.
		rc.bottom = rcView.top + _dvpHeight;
	}

	// Tell display to update when it gets a chance
	_ped->TxInvalidateRect(&rc);

    return fReturn;
}


/*
 *	CDisplaySL::ScrollView(upScroll, vpScroll, fTracking, fFractionalScroll)
 *
 *	@mfunc
 *		Scroll view to new x and y position
 *
 *	@devnote
 *		This method tries to adjust the y scroll pos before
 *		scrolling to display complete line at top. x scroll 
 *		pos is adjusted to avoid scrolling all text off the 
 *		view rectangle.
 *
 *		Must be able to handle vpScroll <gt> pdp->yHeight and vpScroll <lt> 0
 *
 *	@rdesc
 *		TRUE if actual scrolling occurred, 
 *		FALSE if no change
 */
BOOL CDisplaySL::ScrollView (
	LONG upScroll,		//@parm New x scroll position
	LONG vpScroll,		//@parm New y scroll position
	BOOL fTracking,		//@parm TRUE indicates we are tracking scrollbar thumb
	BOOL fFractionalScroll)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::ScrollView");
	LONG dupMax;
	LONG dx = 0;
    RECTUV rcClient, rcClip;
	CTxtSelection *psel = _ped->GetSelNC();
	COleObject *pipo;

    AssertSz(_ped->_fInPlaceActive, "CDisplaySL::ScrollView() called when not in-place");
	
	if(upScroll == -1)
		return FALSE;

 	//For scrolling purposes, we clip to rcView's top and bottom, but rcClient's left and right
   	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcClip, &rcClient);
	rcClip.left = rcClient.left;
	rcClip.right = rcClient.right;
	
	// Determine horizontal scrolling pos.
	dupMax = _dup;
	upScroll = min(upScroll, dupMax);
	upScroll = max(0, upScroll);

	dx = _upScroll - upScroll;
	if(dx)
    {
		_upScroll = upScroll;

		// Calculate new first visible
		CMeasurer me(this);				// Create measurer at cp(0)
		POINTUV pt = {upScroll, 0};
		CDispDim dispdim;
		HITTEST Hit;
		LONG	cpActual;
		CLine::CchFromUp(me, pt, &dispdim, &Hit, &cpActual);
		
		SetCpFirstVisible(cpActual);	// Save character position
    }

	AssertSz(IsMain(), "CDisplaySL::ScrollView non-main SL control");

	// Now perform the actual scrolling
	if(dx)
	{
		if(!_fRectInvalid)
		{
			// Scroll only if scrolling < view dimensions and we are in-place
			// Note that we only scroll the active view and we can be in-place
			// active and have multiple inactive views.
			if(IsActive() && !IsTransparent() && dx < _dupView)
			{
				if(psel)
					psel->ShowCaret(FALSE);

				RECT rcxyClip;
				RectFromRectuv(rcxyClip, rcClip);

				_ped->TxScrollWindowEx(dx, 0, NULL, &rcxyClip);

				if(psel)
					psel->ShowCaret(TRUE);
			}
			else
				_ped->TxInvalidateRect(&rcClip);
		}

		if(psel)
			psel->UpdateCaret(FALSE);

		if(!fTracking && dx)
		{		
			_ped->SendScrollEvent(EN_HSCROLL);
			UpdateScrollBar(SB_HORZ);
		}
				
		_ped->TxUpdateWindow();

		// FUTURE: since we're now repositioning in place active 
		// objects every time we draw, this call seems to be 
		// superfluous (AndreiB)

		// Tell object subsystem to reposition any in place objects
		if(_ped->GetObjectCount())
		{
			pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
			if(pipo)
				pipo->OnReposition();
		}
	}
	return dx;
}

/*
 *	CDisplaySL::InvertRange(cp, cch, selAction)
 *
 *	@mfunc
 *		Invert a given range on screen (for selection)
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplaySL::InvertRange (
	LONG	cp,					//@parm Active end of range to invert
	LONG	cch,				//@parm Signed length of range
	SELDISPLAYACTION selAction)	//@parm What we are doing to the selection
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InvertRange");

	if(cch < 0)						//make cch negative, make cp the minimum
		cch = -cch;
	else
		cp -= cch;

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	// If display is frozen, just update recalc region and move on.
	if(_padc)
	{
		AssertSz(cp >= 0, "CDisplayML::InvertRange: range (cp) goes below"
				"zero!!" );
		// Make sure these values are bounded.
		if(cp > _ped->GetTextLength())	// Don't bother updating region;
			return TRUE;				//  it's out of bounds

		if(cp + cch > _ped->GetTextLength())
			cch -= cp + cch - _ped->GetTextLength();

		_padc->UpdateRecalcRegion(cp, cch, cch);
		return TRUE;
	}

	// Ensure all visible lines are recalced
	if(!WaitForRecalcView())
		return FALSE;

	//REVIEW (keithcu) CDisplayML::InvertRange() has a different order WRT
	//frozen displays and OLE objects.
	
	// If an object is being inverted, and that is all that
	// is being inverted, delegate to the ObjectMgr.
	if (cch == 1 && _ped->GetObjectCount() &&
		(selAction == selSetNormal || selAction == selSetHiLite) )
	{
		CObjectMgr* pobjmgr = _ped->GetObjectMgr();
		CTxtPtr		tp(_ped, cp);

		if(tp.GetChar() == WCH_EMBEDDING && pobjmgr)
			pobjmgr->HandleSingleSelect(_ped, cp, selAction == selSetHiLite);
	}

	// Get view rectangle
    AssertSz(_ped->_fInPlaceActive, "CDisplaySL::InvertRange() called when not in-place active");

	_ped->TxInvalidate();
	return TRUE;
}

/*
 *	CDisplaySL::InitLinePtr (&lp)
 *
 *	@mfunc
 *		Initialize a CLinePtr properly
 */
void CDisplaySL::InitLinePtr (
	CLinePtr & lp )		//@parm Ptr to line to initialize
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::InitLinePtr");

    lp.Init(*this);
}

/*
 *	CDisplaySL::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT	CDisplaySL::GetNaturalSize(
	HDC	  hdcDraw,		//@parm DC for drawing
	HDC	  hicTarget,	//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Input/output width parm 
	LONG *pheight)		//@parm	Input/output height parm
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetNaturalSize");

	// Assume this won't work
	HRESULT hr = E_FAIL;

	// Set height temporarily so zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight(*pheight);

	// Adjust height and width by view inset
	LONG widthView  = *pwidth;
	LONG heightView = *pheight;
	GetViewDim(widthView, heightView);

	// Store adjustment so we can restore it to height & width
	LONG widthAdj  = *pwidth  - widthView;
	LONG heightAdj = *pheight - heightView;
	LONG uCaret = !_ped->fInOurHost() && !_ped->fInHost2() ? duCaret : 0;

	// Recalculate size needed
   	// Create a measurer starting at cp = 0
	CMeasurer me(this);
	CLine	  liNew;

	if(liNew.Measure(me, MEASURE_FIRSTINPARA))
	{
		*pwidth  = liNew._dup;
		if(dwMode == TXTNS_FITTOCONTENT2)
			*pwidth += liNew._upStart + me.GetRightIndent();
		*pheight = liNew._dvpHeight;
		hr = S_OK;
	}

	// Restore insets so output reflects true client rect needed
	*pwidth  += widthAdj + uCaret;
	*pheight += heightAdj;

	// Restore client height to match current cache
	SetClientHeight(yOrigHeightClient);
    return hr;
}

/*
 *	CDisplaySL::GetWordWrap()
 *
 *	@mfunc
 *		Gets the wrap flag  
 *
 *	@rdesc
 *		TRUE - Word wrap
 *		FALSE - No word Word wrap
 *
 *	@devnote
 *		Single line controls cannot word wrap.
 */
BOOL CDisplaySL::GetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplaySL::GetNoWrap");

	return FALSE;
}

/*
 *	CDisplaySL::Clone()
 *
 *	@mfunc
 *		Make a copy of this object
 *
 *	@rdesc
 *		NULL - failed
 *		CDisplay *
 */
CDisplay *CDisplaySL::Clone() const
{
	CDisplaySL *pdp = new CDisplaySL(_ped);
	if(pdp)
	{
		// Initialize our base class
		if(pdp->CDisplay::Init())
		{
			pdp->InitFromDisplay(this);

			// Setting scroll to 0 means use the first visible character
			pdp->_upScroll = CALC_XSCROLL_FROM_FIRST_VISIBLE;
			pdp->_fVScrollEnabled = _fVScrollEnabled;
			pdp->_fWordWrap = _fWordWrap;
			pdp->ResetDrawInfo(this);
			pdp->SetCpFirstVisible(GetFirstVisibleCp());

			// This can't be active view since it is a clone of some view
			pdp->SetActiveFlag(FALSE);
		}
	}
	return pdp;
}

/*
 *	CDisplaySL::GetMaxUScroll()
 *
 *	@mfunc
 *		Get the maximum u scroll value
 *
 *	@rdesc
 *		Maximum u scroll value
 *
 */
LONG CDisplaySL::GetMaxUScroll() const
{
	LONG uCaret = !_ped->fInOurHost() && !_ped->fInHost2() ? duCaret : 0;
	return _dup + uCaret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\dispml.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	DISPML.CPP -- CDisplayML class |
 *
 *		This is the Multi-line display engine.  See disp.c for the base class
 *		methods and dispsl.c for the single-line display engine.
 *	
 *	Owner:<nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *		Rick Sailor (for most of RE 2.0)
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_dispml.h"
#include "_edit.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_select.h"
#include "_dfreeze.h"

/*
#include "icecap.h"

class CCapProfile
{
public:
	CCapProfile() { StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID); }
	~CCapProfile() { StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID); }
};
*/
ASSERTDATA

//
//	Invariant support
//
#define DEBUG_CLASSNAME	CDisplayML
#include "_invar.h"

// Timer tick counts for background task
#define cmsecBgndInterval 	300
#define cmsecBgndBusy 		100

// Lines ahead
const LONG cExtraBeforeLazy = 60;

// cursor.  NB!  6144 is not a measured number; 4096 was the former number,
// and it wasn't measured either; it just seemed like a good one.  We bumped
// the number to 6144 as a safe-fix to a problem which caused cursor-flashing
// for the eBook reader.  The eBook reader's idle process pumps up to
// 5120 characters into RichEdit between ReCalc attempts.  However, each
// recalc can still work on more that 5120 characters; if the
// insertion started at the middle of a line, then recalc starts
// at the beginning of the line, picking up a few extra characters.
#define NUMCHARFORWAITCURSOR	6144

#ifndef DEBUG
#define CheckView()
#define	CheckLineArray()
#endif
	

// ===========================  CDisplayML  =====================================================

#ifdef DEBUG
/*
 *	CDisplayML::Invariant
 *
 *	@mfunc	Make sure the display is in a valid state
 *
 *	@rdesc	TRUE if the tests succeeded, FALSE otherwise
 */
BOOL CDisplayML::Invariant(void) const
{
	CDisplay::Invariant();

	return TRUE;
}
#endif // DEBUG

/*
 *	CDisplayML::CalcScrollHeight()
 *
 *	@mfunc	
 *		Calculate the maximum Y scroll position.
 *
 *	@rdesc
 *		Maximum possible scrolling position
 *
 *	@devnote
 *		This routine exists because plain text controls do not have
 *		the auto-EOP and so the scroll height is different than
 *		the height of the control if the text ends in an EOP type
 *		character.
 */
LONG CDisplayML::CalcScrollHeight(LONG dvp) const
{
	// The max scroll height for plain text controls is calculated
	// differently because they don't have an automatic EOP character.
	if(!_ped->IsRich() && Count())
	{
		// If last character is an EOP, bump scroll height
		CLine *pli = Elem(Count() - 1);	// Get last line in array
		if(pli->_cchEOP)
			dvp += pli->GetHeight();
	}
	return dvp;
}

/*
 *	CDisplayML::GetMaxVpScroll()
 *
 *	@mfunc	
 *		Calculate the maximum Y scroll position.
 *
 *	@rdesc
 *		Maximum possible scrolling position
 *
 *	@devnote
 *		This routine exists because we may have to come back and modify this 
 *		calculation for 1.0 compatibility. If we do, this routine only needs
 *		to be changed in one place rather than the three at which it is used.
 *
 */
inline LONG CDisplayML::GetMaxVpScroll() const
{
	// The following code is turn off because we don't want to support 
	// 1.0 mode unless someone complained about it.  
#if 0		
 	if (_ped->Get10Mode())
	{
		// Ensure last line is always visible
		// (use dy as temp to calculate max scroll)
		vpScroll = Elem(max(0, Count() - 1))->_dvp;

		if(vpScroll > _dvpView)
			vpScroll = _dvpView;

		vpScroll = _dvp - vpScroll;
	}
#endif //0

	return CalcScrollHeight(_dvp);
}

/*
 *	CDisplayML::ConvertScrollToVPos(vPos)
 *
 *	@mfunc	
 *		Calculate the real scroll position from the scroll position
 *
 *	@rdesc
 *		Y position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the V position
 *		gets greater than that.
 */
LONG CDisplayML::ConvertScrollToVPos(
	LONG vPos)		//@parm Scroll position 
{
	// Get maximum scroll range
	LONG vpRange = GetMaxVpScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(vpRange >= _UI16_MAX)
	{
		// Yes - Extrapolate to "real" vPos		
		vPos = MulDiv(vPos, vpRange, _UI16_MAX);
	}
	return vPos;
}

/*
 *	CDisplayML::ConvertVPosToScrollPos()
 *
 *	@mfunc	
 *		Calculate the scroll position from the V position in the document.
 *
 *	@rdesc
 *		Scroll position from V position
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the V position
 *		gets greater than that.
 *
 */
inline LONG CDisplayML::ConvertVPosToScrollPos(
	LONG vPos)		//@parm V position in document
{
	// Get maximum scroll range
	LONG vRange = GetMaxVpScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(vRange >= _UI16_MAX)
	{
		// Yes - Extrapolate to "real" vPos		
		vPos = MulDiv(vPos, _UI16_MAX, vRange);
	}
	return vPos;
}

CDisplayML::CDisplayML (CTxtEdit* ped)
  : CDisplay (ped), _pddTarget(NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CDisplayML");

	Assert(!_dulTarget && !_dvlTarget);

	_fMultiLine = TRUE;
}

CDisplayML::~CDisplayML()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::~CDisplayML");

	delete _pddTarget;
}

/*
 *	CDisplayML::Init()
 *
 *	@mfunc	
 *		Init this display for the screen
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplayML::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Init");

	// Initialize our base class
	if(!CDisplay::Init())
		return FALSE;

	AssertSz(_ped, "CDisplayML::Init(): _ped not initialized in display");
	// Verify allocation zeroed memory out
	Assert(!_vpCalcMax && !_dupLineMax && !_dvp && !_cpMin);
	Assert(!_fBgndRecalc && !_fVScrollEnabled && !_fUScrollEnabled);

	// The printer view is not main, therefore we do this to make
	// sure scroll bars are not created for print views.
	DWORD dwScrollBars = _ped->TxGetScrollBars();

	if(IsMain() && (dwScrollBars & ES_DISABLENOSCROLL))
	{
		if(dwScrollBars & WS_VSCROLL)
		{
			// This causes wlm to assert on the mac. something about 
			// scrollbar being disabled
			_ped->TxSetScrollRange (SB_VERT, 0, 1, TRUE);
			_ped->TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
		}

		// Set horizontal scroll range and pos
		if(dwScrollBars & WS_HSCROLL) 
		{
			_ped->TxSetScrollRange (SB_HORZ, 0, 1, TRUE);
			_ped->TxEnableScrollBar(SB_HORZ, ESB_DISABLE_BOTH);
		}
	}

	SetWordWrap(_ped->TxGetWordWrap());
	_cpFirstVisible = _cpMin;
	
	Assert(!_upScroll && !_vpScroll && !_iliFirstVisible &&
		   !_cpFirstVisible && !_dvpFirstVisible);

    _TEST_INVARIANT_

	return TRUE;
}


//================================  Device drivers  ===================================
/*
 *	CDisplayML::SetMainTargetDC(hdc, dulTarget)
 *
 *	@mfunc
 *		Sets a target device for this display and updates view 
 *
 *	@devnote
 *		Target device can't be a metafile (can't get char width out of a 
 *		metafile)
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::SetMainTargetDC (
	HDC hdc,			//@parm Target DC, NULL for same as rendering device
	LONG dulTarget)		//@parm Max line width (not used for screen)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::SetMainTargetDC");

	if(SetTargetDC(hdc))
	{
		// This is here because this is what RE 1.0 did. 
		SetWordWrap(hdc || !dulTarget);

		// If dulTarget is greater than zero, then the caller is
		// trying to set the maximum width of the window (for measuring,
		// line breaking, etc.)  However,in order to make our measuring
		// algorithms more reasonable, we force the max size to be
		// *at least* as wide as the width of a character.
		// Note that dulTarget = 0 means use the view rect width
		_dulTarget = (dulTarget <= 0) ? 0 : max(DXtoLX(GetDupSystemFont()), dulTarget);
		// Need to do a full recalc. If it fails, it fails, the lines are
		// left in a reasonable state. No need to call WaitForRecalc()
		// because UpdateView() starts at position zero and we're always
		// calc'd up to there
		CDisplay::UpdateView();

		// Caret/selection has most likely moved
		CTxtSelection *psel = _ped->GetSelNC();
		if(psel) 
			psel->UpdateCaret(FALSE);
		return TRUE;
	}
	return FALSE;
}

// Useful for both main and printing devices. jonmat 6/08/1995
BOOL CDisplayML::SetTargetDC( HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::SetTargetDC");

	CDevDesc *pddTarget = NULL;

	// Don't allow metafiles to be set as the target device
	if(hdc && GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)
		return FALSE;

	if(hdc)
	{
		// Allocate device first to see if we can. We don't want to change
		// our state if this is going to fail.
		pddTarget = new CDevDesc(_ped);
		if(!pddTarget)
			return FALSE;				// We couldn't so we are done
	}

	// Remove any cached information for the old target device
	if(_pddTarget)
	{
		delete _pddTarget;
		_pddTarget = NULL;
	}
	if(hdc)
	{
		_pddTarget = pddTarget;			// Update device because we have one
		_pddTarget->SetDC(hdc, dxpInch, dypInch);
	}
	return TRUE;
}

//=================================  Line recalc  ==============================
/*
 *	CDisplayML::RecalcScrollBars()
 *
 *	@mfunc
 *		Recalculate the scroll bars if the view has changed.
 *
 *
 *	@devnote	There is a possibility of recursion here, so we
 *				need to protect ourselves.
 *
 *	To visualize this, consider two types of characters, 'a' characters 
 *	which are small in height and 'A' 's which are really tall, but the same 
 *	width as an 'a'. So if I have
 *
 *	a a A						<nl>
 *	A							<nl>
 *
 *	I'll get a calced size that's basically 2 * heightof(A).
 *	With a scrollbar, this could wordwrap to 
 *
 *	a a							<nl>
 *	A A							<nl>
 *
 *	which is of calced size heightof(A) + heightof(a); this is
 *	obviously less than the height in the first case.
 */
void CDisplayML::RecalcScrollBars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcScrollBars");

	if(_fViewChanged)
	{
  		_fViewChanged = FALSE;
		UpdateScrollBar(SB_VERT, TRUE);
    	UpdateScrollBar(SB_HORZ, TRUE);
    }
}

/*
 *	CDisplayML::RecalcLines(rtp, fWait)
 *
 *	@mfunc
 *		Recalc all line breaks. 
 *		This method does a lazy calc after the last visible line
 *		except for a bottomless control
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::RecalcLines (
	CRchTxtPtr &rtp,	//@parm Where change happened
	BOOL	    fWait)	//@parm Recalc lines down to _cpWait/_vpWait; then be lazy
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcLines");

	LONG		cliWait = cExtraBeforeLazy;	// Extra lines before being lazy
	BOOL		fDone = TRUE;
	BOOL		fFirstInPara = TRUE;
	CLine *		pliNew = NULL;
	LONG		dupLineMax;
	LONG		dvp = 0;
    LONG        cchText = _ped->GetTextLength();
	BOOL		fWaitingForFirstVisible = TRUE;
	LONG		dvpView = _dvpView;
	LONG		dvpScrollOld = GetMaxVpScroll();
	LONG		dvpScrollNew;

	DeleteSubLayouts(0, -1);
	Remove(0, -1);							// Remove all old lines from *this
	_vpCalcMax = 0;							// Set both maxes to start of text
	_cpCalcMax = 0;

	// Don't stop at bottom of view if we're bottomless and active.
	if(!_ped->TxGetAutoSize() && IsActive())
	{
		// Be lazy - don't bother going past visible portion
		_cpWait = -1;
		_vpWait = -1;
		fWait = TRUE;
	}

	CMeasurer me(this, rtp);
	me.SetCp(0);
	me.SetNumber(0);

	// The following loop generates new lines
	while(me.GetCp() < cchText)
	{
		// Add one new line
		pliNew = Add(1, NULL);
		if (!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			TRACEWARNSZ("Out of memory Recalc'ing lines");
			goto err;
		}

		// Stuff text into new line
		UINT uiFlags = MEASURE_BREAKATWORD | 
						(fFirstInPara ? MEASURE_FIRSTINPARA : 0);

    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		if(!Measure(me, pliNew, Count() - 1, uiFlags))
		{
			Assert(FALSE);
			goto err;
		}

		fFirstInPara = pliNew->_fHasEOP;
		dvp += pliNew->GetHeight();
		_cpCalcMax = me.GetCp();
		AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");

		if(fWait)
		{
			// Do we want to do a background recalc? - the answer is yes if
			// three things are true: (1) We have recalc'd beyond the old first
			// visible character, (2) We have recalc'd beyond the visible 
			// portion of the screen and (3) we have gone beyond the next
			// cExtraBeforeLazy lines to make page down go faster.

			if(fWaitingForFirstVisible)
			{
				if(me.GetCp() > _cpFirstVisible)
				{
					_vpWait = dvp + dvpView;
					fWaitingForFirstVisible = FALSE;
				}
			}
			else if(dvp > _vpWait && cliWait-- <= 0 && me._rgpobjWrap.Count() == 0)
			{
				fDone = FALSE;
				break;
			}
		}
	}

	//Create 1 line for empty controls
	if(!Count())
		CreateEmptyLine();

    Paginate(0);

	_vpCalcMax = dvp;
	_fRecalcDone = fDone;
    _fNeedRecalc = FALSE;
	dvpScrollNew = CalcScrollHeight(dvp);

	if(fDone && (dvp != _dvp || dvpScrollNew != dvpScrollOld)
		|| dvpScrollNew > dvpScrollOld)
	{
		_fViewChanged = TRUE;
	}

	_dvp = dvp;
	dupLineMax = CalcDisplayDup();
    if(fDone && dupLineMax != _dupLineMax || dupLineMax > _dupLineMax)
    {
        _dupLineMax = dupLineMax;
		_fViewChanged = TRUE;
    }    

	Tracef(TRCSEVINFO, "CDisplayML::RecalcLine() - Done. Recalced down to line #%d", Count());

	if(!fDone)						// if not done, do rest in background
		fDone = StartBackgroundRecalc();

	if(fDone)
	{
		_vpWait = -1;
		_cpWait = -1;
		CheckLineArray();
		_fLineRecalcErr = FALSE;
	}

#if defined(DEBUG) && !defined(NOFULLDEBUG)
	if( 1 )
    {
		_TEST_INVARIANT_
	}
	//Array memory allocation tracking
	{
	void **pv = (void**)((char*)this + sizeof(CDisplay) + sizeof(void*));
	PvSet(*pv);
	}
#endif

	return TRUE;

err:
	TRACEERRORSZ("CDisplayML::RecalcLines() failed");

	if(!_fLineRecalcErr)
	{
		_cpCalcMax = me.GetCp();
		AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");
		_vpCalcMax = dvp;
		_fLineRecalcErr = TRUE;
		_ped->GetCallMgr()->SetOutOfMemory();
		_fLineRecalcErr = FALSE;			//  fix up CArray & bail
	}
	return FALSE;
}

/*
 *	CDisplayML::RecalcLines(rtp, cchOld, cchNew, fBackground, fWait, pled)
 *
 *	@mfunc
 *		Recompute line breaks after text modification
 *
 *	@rdesc
 *		TRUE if success
 *
 *	@devnote
 *		Most people call this the trickiest piece of code in RichEdit...
 */						     
BOOL CDisplayML::RecalcLines (
	CRchTxtPtr &rtp,		//@parm Where change happened
	LONG cchOld,			//@parm Count of chars deleted
	LONG cchNew,			//@parm Count of chars added
	BOOL fBackground,		//@parm This method called as background process
	BOOL fWait,				//@parm Recalc lines down to _cpWait/_vpWait; then be lazy
	CLed *pled)				//@parm Returns edit impact on lines (can be NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcLines");

	LONG		cchEdit;
	LONG		cchSkip;
	LONG		cliBackedUp = 0;
	LONG		cliWait = cExtraBeforeLazy;	
	BOOL		fDone = TRUE;
	BOOL		fFirstInPara = TRUE;
	LONG		ili;
	CLed		led;
	LONG		lT = 0;							// long Temporary
	LONG		iliMain;
	CLine *		pliMain;
	CLine *		pliNew;
	CLinePtr	rpOld(this);
	LONG		dupLineMax;
	LONG		dvp;
	LONG		dvpPrev = 0;
    LONG        cchText = _ped->GetTextLength();
    UINT        uiFlags;
	BOOL 		fReplaceResult;
	LONG		dvpExtraLine = 0;
	LONG		dvpScrollOld = GetMaxVpScroll();
	LONG		dvpScrollNew;
	WORD		wNumber = 0;
	CLineArray  rgliNew;
	DWORD		dwBgndTickMax = fBackground ? GetTickCount() + cmsecBgndBusy : 0;

	if(!pled)
		pled = &led;

#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	LONG cp = rtp.GetCp();

	if(cp > _cpCalcMax)
		Tracef(TRCSEVERR, "rtp %ld, _cpCalcMax %ld", cp, _cpCalcMax);

	AssertSz(cp <= _cpCalcMax, "CDisplayML::RecalcLines Caller didn't setup RecalcLines()");
	AssertSz(!(fWait && fBackground), "CDisplayML::RecalcLines wait and background both true");
	AssertSz(!(fWait && (-1 == _cpWait) && (-1 == _vpWait)),
		"CDisplayML::RecalcLines background recalc parms invalid");
#endif

	// We will not use background recalc if this is already a background recalc,
	// or if the control is not active or if this is an auto sized control.
	if(!IsActive() || _ped->TxGetAutoSize())
		fWait = FALSE;

	// Init line pointer on old CLayout and backup to start of line
	rpOld.SetCp(rtp.GetCp(), FALSE);
	cchSkip = rpOld.GetIch();
	rpOld.Move(-cchSkip);					// Point rp at 1st char in line

	ili = rpOld;							// Save line # at change for
	if(!Elem(ili)->IsNestedLayout())		//  numbering
	{
		if(ili && (IsInOutlineView() ||		// Back up if not first number
			rtp.GetPF()->IsListNumbered()))	//  in list or if in OutlineView
		{									//  (Outline symbol may change)
			ili--;						 
		}

		// Back up at least one line in case we can now fit more on it
		// If on a line border, e.g., just inserted an EOP, backup 2; else 1
		lT = !cchSkip + 1;

		while(rpOld > 0 &&
			  ((lT-- && (!rpOld[-1]._cchEOP || ili < rpOld)) || 
			  (rpOld[-1]._cObjectWrapLeft || rpOld[-1]._cObjectWrapRight)))
		{
			cliBackedUp++;
			rpOld--;
			cchSkip += rpOld->_cch;
		}
	}

	// Init measurer at rtp
	CMeasurer me(this, rtp);

	me.Move(-cchSkip);						// Point at start of text to measure
	cchEdit = cchNew + cchSkip;				// Number of chars affected by edit
	me.SetNumber(rpOld.GetNumber());		// Initialize list number
	
	// Determine whether we're on first line of paragraph
	if(rpOld > 0)
	{
		fFirstInPara = rpOld[-1]._fHasEOP;
		me.SetIhyphPrev(rpOld[-1]._ihyph);
	}

	dvp = VposFromLine(this, rpOld);

	// Update first-affected and pre-edit-match lines in pled
	pled->_iliFirst = rpOld;
	pled->_cpFirst	= pled->_cpMatchOld	= me.GetCp();
	pled->_vpFirst	= pled->_vpMatchOld	= dvp;
	AssertSz(pled->_vpFirst >= 0, "CDisplayML::RecalcLines _vpFirst < 0");
	
	Tracef(TRCSEVINFO, "Start recalcing from line #%d, cp=%d", pled->_iliFirst, pled->_cpFirst);

	// In case of error, set both maxes to where we are now
	_vpCalcMax = dvp;
	_cpCalcMax = me.GetCp();
	AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");

	// If we are past the requested area to recalc and background recalc is
	// allowed, then just go directly to background recalc. If there is no
	// height, we just go ahead and calculate some lines anyway. This
	// prevents any weird background recalcs from occuring when it is
	// unnecessary to go into background recalc.
	if(fWait && _vpWait > 0 && dvp > _vpWait && me.GetCp() > _cpWait)
	{
		_dvp = dvp;
		DeleteSubLayouts((LONG)rpOld, -1);
		rpOld.Remove(-1);				// Remove all old lines from here on
		StartBackgroundRecalc();		// Start up the background recalc		
		pled->SetMax(this);
		return TRUE;
	}

	pliMain = NULL;
	iliMain = rpOld.GetLineIndex();
	if (iliMain)
	{
		iliMain--;
		pliMain = rpOld.GetLine() - 1;
	}
    pliNew = NULL;

	// The following loop generates new lines for each line we backed
	// up over and for lines directly affected by edit
	while(cchEdit > 0)
	{
		pliNew = rgliNew.Add(1, NULL);		// Add one new line
		if (!pliNew)
		{
			TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLine in CLineArray");
			goto errspace;
		}

		uiFlags = MEASURE_BREAKATWORD | (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

		// Stuff text into new line
    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		dvpExtraLine = 0;
		if(!Measure(me, pliNew, rgliNew.Count() - 1, uiFlags, 0, iliMain, pliMain, &dvpExtraLine))
		{
			Assert(FALSE);
			goto err;
		}

		Assert(pliNew->_cch);

		fFirstInPara = pliNew->_fHasEOP;
		dvpPrev	 = dvp;
		dvp		+= pliNew->GetHeight();
		cchEdit	-= pliNew->_cch;
		AssertSz(cchEdit + me.GetCp() <= cchText, "CDisplayML::RecalcLines: want to measure beyond EOD");

		// Calculate on what line the edit started. We do this because
		// we want to render the first edited line off screen so if
		// the line is being edited via the keyboard we don't clip
		// any characters.
		if(cchSkip > 0)
		{
			// Check whether we backed up and the line we are examining
			// changed at all. Even if it didn't change in outline view
			// have to redraw in case outline symbol changes
			if (cliBackedUp && cchSkip >= pliNew->_cch && 
				pliNew->IsEqual(*(CLine *)(rpOld.GetLine())) && !IsInOutlineView()
				&& !pliNew->_cObjectWrapLeft && !pliNew->_cObjectWrapRight)
			{
				// Perfect match, this line was not the first edited.
               	Tracef(TRCSEVINFO, "New line matched old line #%d", (LONG)rpOld);

				cchSkip -= rpOld->_cch;

				// Update first affected line and match in pled
				pled->_iliFirst++;
				pled->_cpFirst	  += rpOld->_cch;
				pled->_cpMatchOld += rpOld->_cch;
				pled->_vpFirst	  += rpOld->GetHeight();
				AssertSz(pled->_vpFirst >= 0, "CDisplayML::RecalcLines _vpFirst < 0");
				pled->_vpMatchOld  += rpOld->GetHeight();
				cliBackedUp--;
			
				rgliNew.Clear(AF_KEEPMEM);		// Discard new line
				if(!(rpOld++))					// Next line
					cchSkip = 0;
			}
			else								// No match in the line, so 
				cchSkip = 0;					//  this line is the first to
		}										//  be edited

		if(fBackground && GetTickCount() >= dwBgndTickMax)
		{
			fDone = FALSE;						// took too long, stop for now
			goto no_match;
		}

		if (fWait && dvp > _vpWait && me.GetCp() > _cpWait && cliWait-- <= 0)
		{
			// Not really done, just past region we're waiting for
			// so let background recalc take it from here
			fDone = FALSE;
			goto no_match;
		}
	}											// while(cchEdit > 0) { }

   	Tracef(TRCSEVINFO, "Done recalcing edited text. Created %d new lines", rgliNew.Count());

	// Edit lines have been exhausted.  Continue breaking lines,
	// but try to match new & old breaks

	wNumber = me._wNumber;

	while(me.GetCp() < cchText)
	{
		// We are trying for a match so assume that there
		// is a match after all
		BOOL frpOldValid = TRUE;

		// Look for match in old line break CArray
		lT = me.GetCp() - cchNew + cchOld;
		while (rpOld.IsValid() && pled->_cpMatchOld < lT)
		{
			pled->_vpMatchOld  += rpOld->GetHeight();
			pled->_cpMatchOld += rpOld->_cch;

			if(!rpOld.NextRun())
			{
				// No more line array entries so we can give up on
				// trying to match for good.
				frpOldValid = FALSE;
				break;
			}
		} 

		// If perfect match, stop.
		if (frpOldValid && rpOld.IsValid() && pled->_cpMatchOld == lT && 
			rpOld->_cch && me._wNumber == rpOld->_bNumber)
		{
           	Tracef(TRCSEVINFO, "Found match with old line #%d", rpOld.GetLineIndex());

			// Update fliFirstInPara flag in 1st old line that matches.  Note
			// that if the new array doesn't have any lines, we have to look
			// into the line array preceding the current change.
			rpOld->_fFirstInPara = TRUE;
			if(rgliNew.Count() > 0) 
			{
				if(!(rgliNew.Elem(rgliNew.Count() - 1)->_fHasEOP))
					rpOld->_fFirstInPara = FALSE;
			}
			else if(rpOld >= pled->_iliFirst && pled->_iliFirst)
			{
				if(!(rpOld[pled->_iliFirst - rpOld - 1]._fHasEOP))
					rpOld->_fFirstInPara = FALSE;
			}

			pled->_iliMatchOld = rpOld;

			// Replace old lines by new ones
			lT = rpOld - pled->_iliFirst;
			rpOld = pled->_iliFirst;
			DeleteSubLayouts(pled->_iliFirst, lT);
			if(!rpOld.Replace (lT, &rgliNew))
			{
				TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLines in rpOld");
				goto errspace;
			}
			frpOldValid = rpOld.ChgRun(rgliNew.Count());
			rgliNew.Clear(AF_KEEPMEM);	 		// Clear aux array

			// Remember information about match after editing
			Assert((cp = rpOld.CalculateCp()) == me.GetCp());
			pled->_vpMatchOld  += dvpExtraLine;
			pled->_vpMatchNew	= dvp + dvpExtraLine;
			pled->_vpMatchNewTop = dvpPrev;
			pled->_iliMatchNew	= rpOld;
			pled->_cpMatchNew	= me.GetCp();

			// Compute height and cp after all matches
			_cpCalcMax = me.GetCp();
			AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");

			if(frpOldValid && rpOld.IsValid())
			{
				do
				{
					dvp	   += rpOld->GetHeight();
					_cpCalcMax += rpOld->_cch;
				}
				while( rpOld.NextRun() );
#ifdef DEBUG
				CTxtPtr tp(_ped, _cpCalcMax);
				AssertSz(!IN_RANGE(STARTFIELD, tp.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");
#endif
			}

			// Make sure _cpCalcMax is sane after the above update
			AssertSz(_cpCalcMax <= cchText, "CDisplayML::RecalcLines match extends beyond EOF");

			// We stop calculating here.Note that if _cpCalcMax < size 
			// of text, this means a background recalc is in progress.
			// We will let that background recalc get the arrays
			// fully in sync.  

			AssertSz(_cpCalcMax == cchText || _fBgndRecalc,
					"CDisplayML::Match less but no background recalc");

			if(_cpCalcMax != cchText)
			{
				// This is going to be finished by the background recalc
				// so set the done flag appropriately.
				fDone = FALSE;
			}
			goto match;
		}

		// Add a new line
		pliNew = rgliNew.Add(1, NULL);
		if(!pliNew)
		{
			TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLine in CLineArray");
			goto errspace;
		}

    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		// Stuff some text into new line
		wNumber = me._wNumber;
		if(!Measure(me, pliNew, rgliNew.Count() - 1, 
					MEASURE_BREAKATWORD | (fFirstInPara ? MEASURE_FIRSTINPARA : 0), 0,
					iliMain, pliMain))
		{
			Assert(FALSE);
			goto err;
		}
		
		fFirstInPara = pliNew->_fHasEOP;
		dvp += pliNew->GetHeight();

		if(fBackground && GetTickCount() >= (DWORD)dwBgndTickMax)
		{
			fDone = FALSE;			// Took too long, stop for now
			break;
		}

		if(fWait && dvp > _vpWait && me.GetCp() > _cpWait
			&& cliWait-- <= 0 && me._rgpobjWrap.Count() == 0)
		{							// Not really done, just past region we're
			fDone = FALSE;			//  waiting for so let background recalc
			break;					//  take it from here
		}
	}								// while(me < cchText) ...

no_match:
	// Didn't find match: whole line array from _iliFirst needs to be changed
	pled->_iliMatchOld	= Count(); 
	pled->_cpMatchOld	= cchText;
	pled->_vpMatchNew	= dvp;
	pled->_vpMatchNewTop = dvpPrev;
	pled->_vpMatchOld	= _dvp;
	_cpCalcMax			= me.GetCp();
	AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");

	// Replace old lines by new ones
	rpOld = pled->_iliFirst;

	// We store the result from the replace because although it can fail the 
	// fields used for first visible must be set to something sensible whether 
	// the replace fails or not. Further, the setting up of the first visible 
	// fields must happen after the Replace because the lines could have 
	// changed in length which in turns means that the first visible position
	// has failed.

	DeleteSubLayouts(rpOld, -1);
	fReplaceResult = rpOld.Replace(-1, &rgliNew);

	// _iliMatchNew & _cpMatchNew are used for first visible constants so we
	// need to set them to something reasonable. In particular the rendering
	// logic expects _cpMatchNew to be set to the first character of the first
	// visible line. rpOld is used because it is convenient.

	// Note we can't use RpBindToCp at this point because the first visible
	// information is screwed up because we may have changed the line that
	// the first visible cp is on. 
	rpOld.BindToCp(me.GetCp(), cchText);
	pled->_iliMatchNew = rpOld.GetLineIndex();
	pled->_cpMatchNew = me.GetCp() - rpOld.GetIch();

	if (!fReplaceResult)
	{
		TRACEERRORSZ("CDisplayML::RecalcLines rpOld.Replace() failed");
		goto errspace;
	}

    // Adjust first affected line if this line is gone
    // after replacing by new lines
    if(pled->_iliFirst >= Count() && Count() > 0)
    {
        Assert(pled->_iliFirst == Count());
        pled->_iliFirst = Count() - 1;
		pliNew = Elem(pled->_iliFirst);
        pled->_vpFirst -= pliNew->GetHeight();
		AssertSz(pled->_vpFirst >= 0, "CDisplayML::RecalcLines _vpFirst < 0");
        pled->_cpFirst -= pliNew->_cch;
    }
    
#ifdef DEBUG
	if (_ped->GetTextLength())
		Assert(Count());
#endif

	//Create 1 line for empty controls
	if(!Count())
		CreateEmptyLine();

match:
	_fRecalcDone = fDone;
    _fNeedRecalc = FALSE;
	_vpCalcMax = dvp;

	Tracef(TRCSEVINFO, "CDisplayML::RecalcLine(rtp, ...) - Done. Recalced down to line #%d", Count() - 1);

	// Clear wait fields since we want caller's to set them up.
	_vpWait = -1;
	_cpWait = -1;

	if(fDone && fBackground)
	{
		TRACEINFOSZ("Background line recalc done");
		_ped->TxKillTimer(RETID_BGND_RECALC);
		_fBgndRecalc = FALSE;
		_fRecalcDone = TRUE;
	}

	// Determine display height and update scrollbar
	dvpScrollNew = CalcScrollHeight(dvp);

	if (_fViewChanged || fDone && (dvp != _dvp || dvpScrollNew != dvpScrollOld)
		|| dvpScrollNew > dvpScrollOld) 
	{
	    //!NOTE:
	    // UpdateScrollBar can cause a resize of the window by hiding or showing
	    // scrollbars.  As a consequence of resizing the lines may get recalculated
	    // therefore updating _dvp to a new value, something != to dvp.
		_dvp = dvp;
   		UpdateScrollBar(SB_VERT, TRUE);
	}
	else
		_dvp = dvp;				// Guarantee heights agree

	// Determine display width and update scrollbar
	dupLineMax = CalcDisplayDup();
    if(_fViewChanged || (fDone && dupLineMax != _dupLineMax) || dupLineMax > _dupLineMax)
    {
        _dupLineMax = dupLineMax;
   		UpdateScrollBar(SB_HORZ, TRUE);
    }    

    _fViewChanged = FALSE;

	// If not done, do the rest in background
	if(!fDone && !fBackground)
		fDone = StartBackgroundRecalc();

	if(fDone)
	{
		CheckLineArray();
		_fLineRecalcErr = FALSE;
	}

#ifdef DEBUG
	if( 1 )
    {
		_TEST_INVARIANT_
	}
#endif // DEBUG

	Paginate(pled->_iliFirst);
	return TRUE;

errspace:
	_ped->GetCallMgr()->SetOutOfMemory();
	_fNeedRecalc = TRUE;
	_cpCalcMax = _vpCalcMax = 0;
	_fLineRecalcErr = TRUE;

err:
	if(!_fLineRecalcErr)
	{
		_cpCalcMax = me.GetCp();
		AssertSz(!IN_RANGE(STARTFIELD, me.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");
		_vpCalcMax = dvp;
	}

	TRACEERRORSZ("CDisplayML::RecalcLines() failed");

	if(!_fLineRecalcErr)
	{
		_fLineRecalcErr = TRUE;
		_ped->GetCallMgr()->SetOutOfMemory();
		_fLineRecalcErr = FALSE;			//  fix up CArray & bail
	}
	pled->SetMax(this);

	return FALSE;
}

/*
 *	CDisplayML::CalcDisplayDup()
 *
 *	@mfunc
 *		Calculates width of this display by walking line CArray and
 *		returning widest line.  Used for horizontal scrollbar routines.
 *
 *	@rdesc
 *		Widest line width in display
 */
LONG CDisplayML::CalcDisplayDup()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CalcDisplayDup");

	LONG	 dupLineMax = 0;

	if (_ped->fInOurHost() && (_ped->GetHost())->TxGetHorzExtent(&dupLineMax) == S_OK)
	{
		return dupLineMax;
	}

	LONG	 ili = Count();
	CLine 	*pli;

	if(ili)
	{
		LONG dupLine;
		pli = Elem(0);
		
		for(dupLineMax = 0; ili--; pli++)
		{
			dupLine = pli->_upStart + pli->_dup;
			dupLineMax = max(dupLineMax, dupLine);
		}
	}
    return dupLineMax;
}

/*
 *	CDisplayML::StartBackgroundRecalc()
 *
 *	@mfunc
 *		Starts background line recalc (at _cpCalcMax position)
 *
 *	@rdesc
 *		TRUE if done with background recalc
 */
BOOL CDisplayML::StartBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::StartBackgroundRecalc");

	if(_fBgndRecalc)
		return FALSE;					// Already in background recalc

	AssertSz(_cpCalcMax <= _ped->GetTextLength(), "_cpCalcMax > text length");

	if(_cpCalcMax == _ped->GetTextLength())
		return TRUE;					// Enough chars are recalc'd

	if(!_ped->TxSetTimer(RETID_BGND_RECALC, cmsecBgndInterval))
	{
		// Could not instantiate a timer so wait for recalculation
		WaitForRecalc(_ped->GetTextLength(), -1);
		return TRUE;
	}

	_fRecalcDone = FALSE;
	_fBgndRecalc = TRUE;
	return FALSE;
}

/*
 *	CDisplayML::StepBackgroundRecalc()
 *
 *	@mfunc
 *		Steps background line recalc (at _cpCalcMax position)
 *		Called by timer proc and also when going inactive.
 */
void CDisplayML::StepBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::StepBackgroundRecalc");

    _TEST_INVARIANT_
	
	if(!_fBgndRecalc)					// Not in background recalc,
		return;							//  so don't do anything

	LONG cch = _ped->GetTextLength() - _cpCalcMax;

	// Don't try recalc when processing OOM or had an error doing recalc or
	// if we are asserting.
#ifdef DEBUG
	if(_fInBkgndRecalc || _fLineRecalcErr)
	{
		if(_fInBkgndRecalc)
			TRACEINFOSZ("avoiding reentrant background recalc");
		else
			TRACEINFOSZ("OOM: not stepping recalc");
		return;
	}
#else
	if(_fInBkgndRecalc || _fLineRecalcErr)
		return;
#endif

	_fInBkgndRecalc = TRUE;
	if(!IsActive())
	{
		// Background recalc is over if we are no longer active	because
		// we can no longer get the information we need for recalculating.
		// But, if we are half recalc'd we need to set ourselves up to 
		// recalc again when we go active.
		InvalidateRecalc();
		cch = 0;
	}

	// Background recalc is over if no more chars or no longer active
	if(cch <= 0)
	{
		TRACEINFOSZ("Background line recalc done");
		_ped->TxKillTimer(RETID_BGND_RECALC);
		_fBgndRecalc = FALSE;
		_fRecalcDone = TRUE;
		_fInBkgndRecalc = FALSE;
		CheckLineArray();
		return;
	}

	CRchTxtPtr rtp(_ped, _cpCalcMax);
	AssertSz(!IN_RANGE(STARTFIELD, rtp.GetPrevChar(), ENDFIELD), "Illegal cpCalcMax");
	RecalcLines(rtp, cch, cch, TRUE, FALSE, NULL);

	_fInBkgndRecalc = FALSE;
}

/*
 *	CDisplayML::WaitForRecalc(cpMax, vpMax)
 *
 *	@mfunc
 *		Ensures that lines are recalced until a specific character
 *		position or vPos.
 *
 *	@rdesc
 *		success
 */
BOOL CDisplayML::WaitForRecalc(
	LONG cpMax,		//@parm Position recalc up to (-1 to ignore)
	LONG vpMax)		//@parm vPos to recalc up to (-1 to ignore)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalc");

    _TEST_INVARIANT_

	if(IsFrozen())
		return TRUE;

	BOOL fReturn = TRUE;
	LONG cch;

	if((vpMax < 0 || vpMax >= _vpCalcMax) &&
	   (cpMax < 0 || cpMax >= _cpCalcMax))
    {
    	cch = _ped->GetTextLength() - _cpCalcMax;
    	if(cch > 0 || Count() == 0)
    	{
    		HCURSOR hcur = NULL;

    		_cpWait = cpMax;
    		_vpWait = vpMax;
		
			if(cch > NUMCHARFORWAITCURSOR)
    			hcur = _ped->TxSetCursor(LoadCursor(0, IDC_WAIT));
    		TRACEINFOSZ("Lazy recalc");
		
			CRchTxtPtr rtp(_ped, _cpCalcMax);
    		if(!_cpCalcMax || _fNeedRecalc)
			{
    			fReturn = RecalcLines(rtp, TRUE);
				RebindFirstVisible();
				if(!fReturn)
					InitVars();
			}
    		else
    			fReturn = RecalcLines(rtp, cch, cch, FALSE, TRUE, NULL);

			if(hcur)
    			 _ped->TxSetCursor(hcur);
    	}
		else if(!cch)
		{
			// If there was nothing else to calc, make sure that we think
			// recalc is done.
#ifdef DEBUG
			if( !_fRecalcDone )
			{
				TRACEWARNSZ("For some reason we didn't think background "
					"recalc was done, but it was!!");
			}
#endif // DEBUG
			_fRecalcDone = TRUE;
		}
    }

	// If view rect changed, make sure to update scrollbars
	RecalcScrollBars();

	return fReturn;
}

/*
 *	CDisplayML::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Wait until line array is recalculated up to line <p ili>
 *
 *	@rdesc
 *		Returns TRUE if lines were recalc'd up to ili
 */
//REVIEW (keithcu) This recalcs up to the end! I'm not certain how great
//our background recalc, etc. stuff is. It seems not to work all that well for
//the complexity it adds to our codebase. I think we should either throw it
//away or redo it.
BOOL CDisplayML::WaitForRecalcIli (
	LONG ili)		//@parm Line index to recalculate line array up to
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalcIli");

	LONG cchGuess;

	while(!_fRecalcDone && ili >= Count())
	{
		// just go ahead and recalc everything.
		cchGuess = _ped->GetTextLength();
		if(IsFrozen() || !WaitForRecalc(cchGuess, -1))
			return FALSE;
	}
	return ili < Count();
}

/*
 *	CDisplayML::WaitForRecalcView()
 *
 *	@mfunc
 *		Ensure visible lines are completly recalced
 *
 *	@rdesc TRUE iff successful
 */
BOOL CDisplayML::WaitForRecalcView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalcView");

	return WaitForRecalc(-1, _vpScroll + _dvpView);
}

/*
 *	CDisplayML::InitLinePtr ( CLinePtr & plp )
 *
 *	@mfunc
 *		Initialize a CLinePtr properly
 */
void CDisplayML::InitLinePtr (
	CLinePtr & plp )		//@parm Ptr to line to initialize
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InitLinePtr");

    plp.Init( *this );
}

/*
 *	CDisplayML::GetLineText(ili, pchBuff, cchMost)
 *
 *	@mfunc
 *		Copy given line of this display into a character buffer
 *
 *	@rdesc
 *		number of character copied
 */
LONG CDisplayML::GetLineText(
	LONG ili,			//@parm Line to get text of
	TCHAR *pchBuff,		//@parm Buffer to stuff text into
	LONG cchMost)		//@parm Length of buffer
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetLineText");
    
	_TEST_INVARIANT_

	CTxtPtr tp (_ped, 0);

	if(ili >= 0 && (ili < Count() || WaitForRecalcIli(ili)))
	{
		cchMost = min(cchMost, Elem(ili)->_cch);
		if(cchMost > 0)
		{
			tp.SetCp(CpFromLine(ili, NULL));
			return tp.GetText(cchMost, pchBuff);
		}
	}
	*pchBuff = TEXT('\0');
	return 0;
}

/*
 *	CDisplayML::LineCount
 *
 *	@mfunc	returns the number of lines in this control.  Note that for plain
 *			text mode, we will add on an extra line of the last character is
 *			a CR.  This is for compatibility with MLE
 *
 *	@rdesc	LONG
 */
LONG CDisplayML::LineCount() const
{
	LONG cLine = Count();

	if (!_ped->IsRich() && (!cLine || 	   // If plain text with no lines
		 Elem(cLine - 1)->_cchEOP))		   //  or last line ending with a CR,
	{									   //  then inc line count
		cLine++;
	}
	return cLine;
}

// ================================  Line info retrieval  ====================================


/*
 *	CDisplayML::CpFromLine(ili, pdvp)
 *
 *	@mfunc
 *		Computes cp at start of given line 
 *		(and top of line position relative to this display)
 *
 *	@rdesc
 *		cp of given line
 */
LONG CDisplayML::CpFromLine (
	LONG ili,		//@parm Line we're interested in (if <lt> 0 means caret line)
	LONG *pdvp)		//@parm Returns top of line relative to display 
					//  	(NULL if don't want that info)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CpFromLine");

    _TEST_INVARIANT_
						
	LONG cli;
	LONG vp = _vpScroll + _dvpFirstVisible;
	LONG cp = _cpFirstVisible;
	CLine  *pli;
	LONG iStart = _iliFirstVisible;

	cli = ili - _iliFirstVisible;
	if(cli < 0 && -cli >= ili)
	{
		// Closer to first line than to first visible line,
		// so start at the first line
		cli = ili;
		vp = 0;
		cp = 0;
		iStart = 0;
	}
	else if( cli <= 0 )
	{
		CheckView();
		for(ili = _iliFirstVisible-1; cli < 0; cli++, ili--)
		{
			pli = Elem(ili);
			vp -= pli->GetHeight();
			cp -= pli->_cch;
		}
		goto end;
	}

	for(ili = iStart; cli > 0; cli--, ili++)
	{
		pli = Elem(ili);
		if(!IsMain() || !WaitForRecalcIli(ili))
			break;
		vp += pli->GetHeight();
		cp += pli->_cch;
	}

end:
	if(pdvp)
		*pdvp = vp;

	return cp;
}



/*
 *	CDisplayML::LineFromCp(cp, fAtEnd)
 *
 *	@mfunc
 *		Computes line containing given cp.
 *
 *	@rdesc
 *		index of line found, -1 if no line at that cp.
 */
LONG CDisplayML::LineFromCp(
	LONG cp,		//@parm cp to look for
	BOOL fAtEnd)	//@parm If true, return previous line for ambiguous cp
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineFromCp");
    
	_TEST_INVARIANT_

	CLinePtr rp(this);
	
	if(!WaitForRecalc(cp, -1) || !rp.SetCp(cp, fAtEnd))
		return -1;

	return (LONG)rp;
}

/*
 *	CDisplayML::CpFromPoint(pt, prcClient, prtp, prp, fAllowEOL, phit,
 *							pdispdim, pcpActual)
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CDisplayML::CpFromPoint(
	POINTUV		pt,			//@parm Point to compute cp at (client coords)
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const prtp,//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual,	//@parm Out cp that pt is above
	CLine *		pliParent)	//@parm Parent pli for table row displays
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CpFromPoint");
	CMeasurer me(this);

	return CLayout::CpFromPoint(me, pt, prcClient, prtp, prp, fAllowEOL, phit, pdispdim, pcpActual);
}

/*
 *	CDisplayML::PointFromTp(rtp, prcClient, fAtEnd, pt, prp, taMode, pdispdim)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CDisplayML::PointFromTp(
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of prev line for ambiguous cp
	POINTUV &		pt,		//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::PointFromTp");
	CMeasurer me(this, rtp);
	return CLayout::PointFromTp(me, rtp, prcClient, fAtEnd, pt, prp, taMode, pdispdim);
}

/*
 *	Render(rcView, rcRender)
 *
 *	@mfunc	
 *		Renders text.
 */
void CDisplayML::Render(
	const RECTUV &rcView,	//@parm View RECT
	const RECTUV &rcRender)	//@parm RECT to render (must be container in client rect)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Render");

    _TEST_INVARIANT_
								
    LONG	cp;
	LONG	ili;
	LONG	lCount = Count();
	CTxtSelection *psel = _ped->GetSelNC();
	POINTUV	pt;
    LONG	vpLine;

    if(psel)
		psel->ClearCchPending();

	// Calculate line and cp to start display at
	if(IsInPageView())
	{
		cp = _cpFirstVisible;
		ili = _iliFirstVisible;
		vpLine = _vpScroll;
	}
	else
		ili	= LineFromVpos(this, rcRender.top + _vpScroll - rcView.top, &vpLine, &cp);

	CLine *pli = Elem(ili);
	CLine *pliFirst = pli;
	LONG	dvpBottom = BottomOfRender(rcView, rcRender);
	LONG	vpLi = pli->GetHeight();

	// Calculate point where text will start being displayed
   	pt.u = rcView.left - _upScroll;
   	pt.v = rcView.top  - _vpScroll + vpLine;

	// Create and prepare renderer
	CRenderer re(this);

	if(!re.StartRender(rcView, rcRender))
		return;
	
	// Init renderer at start of first line to render
	re.SetCurPoint(pt);
	POINTUV ptFirst = pt;
   	LONG cpFirst = cp = re.SetCp(cp);
    vpLi = pt.v;

	// Render each line in update rectangle
	for (;; pli++, ili++)
	{
		BOOL fLastLine = ili == lCount - 1 ||
			re.GetCurPoint().v + pli->GetHeight() >= dvpBottom ||
			IsInPageView() && ili + 1 < lCount && (pli + 1)->_fFirstOnPage;

		//Support khyphChangeAfter
		if (ili > 0)
			re.SetIhyphPrev((pli - 1)->_ihyph);

		//Don't draw the line if it doesn't intersect the rendering area,
		//but draw at least 1 line so that we erase the control
		if (pt.v + pli->GetHeight() < rcRender.top && !fLastLine)
		{
			pt.v += pli->GetHeight();
			re.SetCurPoint(pt);
			re.Move(pli->_cch);
		}
		else if (!CLayout::Render(re, pli, &rcView, fLastLine, ili, lCount))
			break;

		if (fLastLine)
			break;

#ifdef DEBUG
		cp  += pli->_cch;
		vpLi += pli->GetHeight();

		// Rich controls with password characters stop at EOPs, 
		// so re.GetCp() may be less than cp.
		AssertSz(_ped->IsRich() && _ped->fUsePassword() || re.GetCp() == cp, "cp out of sync with line table");
#endif
		pt = re.GetCurPoint();
		AssertSz(pt.v == vpLi, "CDisplayML::RenderView() - y out of sync with line table");

	}

	re.EndRender(pliFirst, pli, cpFirst, ptFirst);
}


//===================================  View Updating  ===================================
/*
 *	CDisplayML::RecalcView(fUpdateScrollBars)
 *
 *	@mfunc
 *		Recalc all lines breaks and update first visible line
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::RecalcView(
	BOOL fUpdateScrollBars, RECTUV* prc)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcView");

	BOOL fRet = TRUE;
	LONG dvpOld = _dvp;
	LONG vpScrollHeightOld = GetMaxVpScroll();
	LONG dupOld = _dupLineMax;
	LONG vpScrollHeightNew;

	// Full recalc lines
    CRchTxtPtr rtp(_ped, 0);
	if(!RecalcLines(rtp, FALSE))
	{
		// We're in deep crap now, the recalc failed. Let's try to get out
		// of this with our head still mostly attached
		InitVars();
		fRet = FALSE;
        goto Done;
	}

    // Force _upScroll = 0 if x scroll range is smaller than the view width
    if(_dupLineMax <= _dupView)
        _upScroll = 0;

	vpScrollHeightNew = GetMaxVpScroll();
	RebindFirstVisible(vpScrollHeightNew <= _dvpView);

	CheckView();

	// We only need to resize if the size needed to display the object has 
	// changed.
	if (dvpOld != _dvp || vpScrollHeightOld != vpScrollHeightNew ||
		dupOld  != _dupLineMax)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		else if (prc && _ped->_fInOurHost)/*bug fix# 5830, forms3 relies on old behavior*/
			_ped->TxGetClientRect(prc);
	}

Done:

    // Now update scrollbars
	if(fUpdateScrollBars)
		RecalcScrollBars();

    return fRet;
}

/*
 *	CDisplayML::UpdateView(&rtp, cchOld, cchNew)
 *
 *	@mfunc
 *		Recalc lines and update the visible part of the display 
 *		(the "view") on the screen.
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::UpdateView(
	CRchTxtPtr &rtp,	//@parm Text ptr where change happened
	LONG cchOld,		//@parm Count of chars deleted
	LONG cchNew)		//@parm Count of chars inserted
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::UpdateView");

	BOOL fReturn = TRUE;
	BOOL fRecalcVisible = TRUE;
	RECTUV rcClient;
    RECTUV rcView;
	CLed led;
	CTxtSelection *psel = _ped->GetSelNC();
	LONG cpStartOfUpdate = rtp.GetCp();
	BOOL fNeedViewChange = FALSE;
	LONG dvpOld = _dvp;
	LONG vpScrollHeightOld = GetMaxVpScroll();
	LONG dupOld = _dupLineMax;
	LONG vpScrollOld = _vpScroll;
	LONG cpNewFirstVisible;

	if(_fNoUpdateView)
		return fReturn;

	AssertSz(_ped->_fInPlaceActive, "CDisplayML::UpdateView called when inactive");

	if(rtp.GetCp() > _cpCalcMax || _fNeedRecalc)
	{
		// We haven't even calc'ed this far, so don't bother with updating
		// here.  Background recalc will eventually catch up to us.
		if(!rtp.GetCp())				
		{								// Changes started at start of doc
			_cpCalcMax = 0;				//  so previous calc'd state is
			_vpCalcMax = 0;				//  completely invalid
		}
		return TRUE;
	}

	AssertSz(rtp.GetCp() <= _cpCalcMax, "CDisplayML::UpdateView: rtp > _cpCalcMax");

	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcView, &rcClient);

	if(psel && !psel->PuttingChar())
		psel->ClearCchPending();

	DeferUpdateScrollBar();

	// In general, background recalc should not start until both the scroll 
	// position is beyond the visible view and the cp is beyond the first visible 
	// character. However, for the recalc we will only wait on the height. 
	// Later calls to WaitForRecalc will wait on cpFirstVisible if that is 
	// necessary.
	_vpWait = _vpScroll + _dvpView;
	_cpWait = -1;

	if(!RecalcLines(rtp, cchOld, cchNew, FALSE, TRUE, &led))
	{
		// We're in deep crap now, the recalc failed. Let's try to get
		// out of this with our head still mostly attached
		InitVars();
		fRecalcVisible = TRUE;
		fReturn = FALSE;
		_ped->TxInvalidate();
		fNeedViewChange = TRUE;
		goto Exit;
	}

	if(_dupLineMax <= _dupView)
    {
		// x scroll range is smaller than the view width, force x scrolling position = 0
		// we have to redraw all when this means scrolling back to home.
		// Problem lines are lines with trailing spaces crossing _dupView. UpdateCaret forces redraw
		// only when such lines are growing, misses shrinking.
		if (_upScroll != 0)
			_ped->TxInvalidate();	//REVIEW: find a smaller rectangle?
			
		_upScroll = 0;
    }

	if(led._vpFirst >= _vpScroll + _dvpView)
	{
		// Update is after view: don't do anything
		fRecalcVisible = FALSE;
		AssertNr(VerifyFirstVisible());
		goto finish;
	}
	else if(led._vpMatchNew <= _vpScroll + _dvpFirstVisible &&
			led._vpMatchOld <= _vpScroll + _dvpFirstVisible &&
			_vpScroll < _dvp)
	{
		if (_dvp != 0)
		{
			// Update is entirely before view: just update scroll position
			// but don't touch the screen
			_vpScroll += led._vpMatchNew - led._vpMatchOld;
			_iliFirstVisible += led._iliMatchNew - led._iliMatchOld;
			_iliFirstVisible = max(_iliFirstVisible, 0);

			_cpFirstVisible += led._cpMatchNew - led._cpMatchOld;
			_cpFirstVisible = min(_ped->GetTextLength(), _cpFirstVisible);
			_cpFirstVisible = max(0, _cpFirstVisible);
			fRecalcVisible = FALSE;
			Sync_yScroll();
		}
		else
		{
			// Odd outline case. Height of control can be recalc'd to zero due 
			// when outline mode collapses all lines to 0. Example of how to 
			// do this is tell outline to collapse to heading 1 and there is none.
			_vpScroll = 0;
			_iliFirstVisible = 0;
			_cpFirstVisible = 0;
			_sPage = 0;
		}

		AssertNr(VerifyFirstVisible());
	}
	else
	{
		// Update overlaps visible view
		RECTUV rc = rcClient;

		// Do we need to resync the first visible?  Note that this if check
		// is mostly an optmization; we could decide to _always_ recompute
		// this _iliFirstVisible if we wanted to unless rtp is inside a table,
		// in which case _cpFirstVisible won't change and the following may
		// mess up _dvpFirstVisible.
		const CParaFormat *pPF = rtp.GetPF();

		if((!pPF->_bTableLevel || rtp._rpTX.IsAtTRD(0)) &&
		   (cpStartOfUpdate  <= _cpFirstVisible  || 
			led._iliMatchOld <= _iliFirstVisible ||
			led._iliMatchNew <= _iliFirstVisible ||
			led._iliFirst    <= _iliFirstVisible ))
		{
			// Edit overlaps the first visible. We try to maintain
			// approximately the same place in the file visible.
			cpNewFirstVisible = _cpFirstVisible;

			if(_iliFirstVisible - 1 == led._iliFirst)
			{
				// Edit occurred on line before visible view. Most likely
				// this means that the first character got pulled back to
				// the previous line so we want that line to be visible.
				cpNewFirstVisible = led._cpFirst;
			}

			// Change first visible entries because CLinePtr::SetCp() and
			// VposFromLine() use them, but they're not valid
			_dvpFirstVisible = 0;
			_cpFirstVisible = 0;
			_iliFirstVisible = 0;
			_vpScroll = 0;

			// With certain formatting changes, it's possible for 
			// cpNewFirstVisible to be less that what's been calculated so far 
			// in RecalcLines above. Wait for things to catch up.

			WaitForRecalc(cpNewFirstVisible, -1);
			Set_yScroll(cpNewFirstVisible);
		}
		AssertNr(VerifyFirstVisible());

		// Is there a match in the display area? - this can only happen if the
		// old match is on the screen and the new match will be on the screen
		if (led._vpMatchOld < vpScrollOld + _dvpView &&
			led._vpMatchNew < _vpScroll + _dvpView)
		{
			// We have a match inside visible view
			// Scroll the part that is below the old y pos of the match
			// or invalidate if the new y of the match is now below the view
			rc.top = rcView.top + (led._vpMatchOld - vpScrollOld);
			if(rc.top < rc.bottom)
			{
				// Calculate difference between new and old screen positions
				const INT dvp = (led._vpMatchNew - _vpScroll) - (led._vpMatchOld - vpScrollOld);

				if(dvp)
				{
					if(!IsTransparent() && _ped->GetBackgroundType() == -1)
					{
						LONG dxp, dyp;
						GetDxpDypFromDupDvp(0, dvp, GetTflow(), dxp, dyp);

						RECTUV rcClip = {rcClient.left, rcView.top, rcClient.right, rcView.bottom };
						RECT rcxyClip, rcxy;
						RectFromRectuv(rcxyClip, rcClip);
						RectFromRectuv(rcxy, rc);

    					_ped->TxScrollWindowEx(dxp, dyp, &rcxy, &rcxyClip);
						fNeedViewChange = TRUE;

    					if(dvp < 0)
	    				{
		    				rc.top = rc.bottom + dvp;

			    			_ped->TxInvalidateRect(&rc);
							fNeedViewChange = TRUE;
				    	}
    				}
                    else
                    {
						// Just invalidate cuz we don't scroll in transparent
						// mode
						RECTUV	rcInvalidate = rc;
   						rcInvalidate.top += dvp;

                        _ped->TxInvalidateRect(&rcInvalidate);
						fNeedViewChange = TRUE;
                    }
				}
			}
			else
			{
				rc.top = rcView.top + led._vpMatchNew - _vpScroll;
				_ped->TxInvalidateRect(&rc);
				fNeedViewChange = TRUE;
			}

			// Since we found that the new match falls on the screen, we can
			// safely set the bottom to the new match since this is the most
			// that can have changed.
			rc.bottom = rcView.top + max(led._vpMatchNew, led._vpMatchOld) - _vpScroll;
		}

		rc.top = rcView.top + led._vpFirst - _vpScroll;

		// Set first line edited to be rendered using off-screen bitmap
		if (led._iliFirst < Count() && !IsTransparent() && !Elem(led._iliFirst)->_fUseOffscreenDC)
			Elem(led._iliFirst)->_fOffscreenOnce = Elem(led._iliFirst)->_fUseOffscreenDC = TRUE;
		
		// Invalidate part of update that is above match (if any)
		_ped->TxInvalidateRect (&rc);
		fNeedViewChange = TRUE;
	}

finish:
	if(fRecalcVisible)
	{
		fReturn = WaitForRecalcView();
		if(!fReturn) 
			return FALSE;
	}
	if(fNeedViewChange)
		_ped->GetHost()->TxViewChange(FALSE);

	CheckView();

	// We only need to resize if size needed to display object has changed
	if (dvpOld != _dvp || vpScrollHeightOld != GetMaxVpScroll() ||
		dupOld  != _dupLineMax)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
	}
	if(DoDeferredUpdateScrollBar())
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		DoDeferredUpdateScrollBar();
	}

Exit:
	return fReturn;
}

/*
 *	CDisplayML::RecalcLine(cp)
 *
 *	@mfunc
 *		Show line
 */
void CDisplayML::RecalcLine(
	LONG cp)			//@parm cp line to recalc
{
	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();
	if(pnm)
		pnm->NotifyPostReplaceRange(NULL, cp, 0, 0, cp, cp);
}

void CDisplayML::InitVars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InitVars");

	_vpScroll = _upScroll = 0;
	_iliFirstVisible = 0;
	_cpFirstVisible = _cpMin = 0;
	_dvpFirstVisible = 0;
	_sPage = 0;
}


/*
 *	CDisplayML::GetCliVisible(pcpMostVisible)
 *
 *	@mfunc	
 *		Get count of visible lines and update _cpMostVisible for PageDown()
 *
 *	@rdesc
 *		count of visible lines
 */
LONG CDisplayML::GetCliVisible(
	LONG* pcpMostVisible, 				//@parm Returns cpMostVisible
	BOOL fLastCharOfLastVisible) const 	//@parm Want cp of last visible char
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetCliVisible");

	LONG cli	 = 0;							// Initialize count
	LONG ili	 = _iliFirstVisible;			// Start with 1st visible line
	LONG dvp = _dvpFirstVisible;
    LONG cp;
	const CLine *pli = Elem(ili);

	for(cp = _cpFirstVisible;
		dvp < _dvpView && ili < Count();
		cli++, ili++, pli++)
	{
		dvp	+= pli->GetHeight();

		//Note: I removed the support to give the last visible non-white character.
		//Does anyone want that? It never worked in LS displays.
		if (fLastCharOfLastVisible && dvp > _dvpView)
			break;

		if(IsInPageView() && cli && pli->_fFirstOnPage)
			break;

		cp += pli->_cch;
	}

    if(pcpMostVisible)
        *pcpMostVisible = cp;

	return cli;
}

//==================================  Inversion (selection)  ============================

/*
 *	CDisplayML::InvertRange(cp, cch)
 *
 *	@mfunc
 *		Invert a given range on screen (for selection)
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::InvertRange (
	LONG cp,					//@parm Active end of range to invert
	LONG cch,					//@parm Signed length of range
	SELDISPLAYACTION selAction)	//@parm Describes what we are doing to the selection
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InvertRange");

	LONG	 cpMost;
	RECTUV	 rc, rcClient, rcView;
	CLinePtr rp(this);
	CRchTxtPtr  rtp(_ped);
	LONG	 y;
	LONG	 cpActive = _ped->GetSel()->GetCp();

    AssertSz(_ped->_fInPlaceActive,	"CDisplayML::InvertRange() called when not in-place active");

	if(cch < 0)						// Define cpMost, set cp = cpMin,
	{								//  and cch = |cch|
		cpMost = cp - cch;
		cch = -cch;
	}
	else
	{
		cpMost = cp;
		cp -= cch;
	}

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	// If an object is being inverted, and nothing else is being inverted,
	// delegate to the ObjectMgr.  If fIgnoreObj is TRUE we highlight normally
	if (cch == 1 && _ped->GetObjectCount() &&
		(selAction == selSetNormal || selAction == selSetHiLite))
	{
		CObjectMgr* pobjmgr = _ped->GetObjectMgr();

		rtp.SetCp(cp);
		if(rtp.GetChar() == WCH_EMBEDDING)
		{
			if(pobjmgr)
				pobjmgr->HandleSingleSelect(_ped, cp, selAction == selSetHiLite);
			return TRUE;
		}
	}

	// If display is frozen, just update recalc region and move on.
	if(_padc)
	{
		AssertSz(cp >= 0, "CDisplayML::InvertRange: range (cp) goes below"
				"zero!!" );
		// Make sure these values are bounded.
		if(cp > _ped->GetTextLength())	// Don't bother updating region;
			return TRUE;				//  it's out of bounds

		if(cp + cch > _ped->GetTextLength())
			cch -= cp + cch - _ped->GetTextLength();

		_padc->UpdateRecalcRegion(cp, cch, cch);
		return TRUE;
	}

	if(!WaitForRecalcView())			// Ensure all visible lines are
		return FALSE;					//  recalc'd

	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcView, &rcClient);
	
	// Compute first line to invert and where to start on it
	if(cp >= _cpFirstVisible)
	{
		POINTUV pt;
		rtp.SetCp(cp);
		if(PointFromTp(rtp, NULL, FALSE, pt, NULL, TA_TOP) < 0)
			return FALSE;

		//We don't use the rp returned from PointFromTp because
		//we need the outermost rp for best results. In the future
		//we could consider writing code which doesn't invalidate so much.
		rp.SetCp(cp, FALSE, 0);
		rc.top = pt.v;
	}
	else
	{
		cp = _cpFirstVisible;
		rp = _iliFirstVisible;
		rc.top = rcView.top + _dvpFirstVisible;
	}				

	// Loop on all lines of range
	while (cp < cpMost && rc.top < rcView.bottom && rp.IsValid())
	{
		// Calculate rc.bottom first because rc.top takes into account
		// the dy of the first visible on the first loop.
		y = rc.top;
		y += rp->GetHeight();
		rc.bottom = min(y, rcView.bottom);
        rc.top = max(rc.top, rcView.top);

		//If we are inverting the active end of the selection, draw it offscreen
		//to minimize flicker.
		if (IN_RANGE(cp - rp.GetIch(), cpActive, cp - rp.GetIch() + rp->_cch) && 
			!IsTransparent() && !rp->_fUseOffscreenDC)
		{	
			rp->_fOffscreenOnce = rp->_fUseOffscreenDC = TRUE;
		}

		cp += rp->_cch - rp.GetIch();

		rc.left = rcClient.left;
        rc.right = rcClient.right;

	    _ped->TxInvalidateRect(&rc);
		rc.top = rc.bottom;
		if(!rp.NextRun())
			break;
	}
	_ped->TxUpdateWindow();				// Make sure window gets repainted
	return TRUE;
}


//===================================  Scrolling  =============================

/*
 *	CDisplay::VScroll(wCode, vPos)
 *
 *	@mfunc
 *		Scroll the view vertically in response to a scrollbar event
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		LRESULT formatted for WM_VSCROLL message		
 */
LRESULT CDisplayML::VScroll(
	WORD wCode,		//@parm Scrollbar event code
	LONG vPos)		//@parm Thumb position (vPos <lt> 0 for EM_SCROLL behavior)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::VScroll");

	LONG		cliVisible;
	LONG		dy = 0;
	BOOL		fTracking = FALSE;
	LONG		i;
	const LONG	iliSave = _iliFirstVisible;
	CLine *	pli = NULL;
	INT			dvpSys = GetDvpSystemFont();
	LONG		vpScroll = _vpScroll;
    
    AssertSz(_ped->_fInPlaceActive, "CDisplay::VScroll() called when not in-place");

	if(vPos)
	{
		// Convert this from 16-bit to 32-bit if necessary.
		vPos = ConvertScrollToVPos(vPos);
	}

	vPos = min(vPos, _dvp);

	if(IsInPageView())
	{
		BOOL	 fForward;
		BOOL	 fFoundNewPage = FALSE;
		LONG	 ili = _iliFirstVisible;
		LONG	 nLine = Count();
		CLine *pli = Elem(_iliFirstVisible);

		AssertSz(Elem(_iliFirstVisible)->_fFirstOnPage,
			"CDisplayML::VScroll: _iliFirstVisible not top of page");

		if(wCode <= SB_PAGEDOWN)
		{
			fForward = (wCode & 1);
			ili += fForward;
			while(ili && ili < nLine)
			{
				if(fForward > 0)
				{
					vpScroll += pli->GetHeight();

					if(ili == nLine - 1)
						break;
					pli++;
					ili++;
				}
				else
				{
					pli--;
					ili--;
					vpScroll -= pli->GetHeight();
				}
				if(pli->_fFirstOnPage)
				{
					fFoundNewPage = TRUE;
					break;
				}
			}
		}
		else if(wCode == SB_THUMBTRACK || wCode == SB_THUMBPOSITION)
		{
			if (vPos + _dvpView >= _dvp)	// At last page?
					vPos = _dvp;

			if(vPos > vpScroll)
			{
				LONG iliFirst = ili;
				LONG vpScrollPage = vpScroll;

				if(ili < nLine)
				{
					while(vpScroll < vPos)
					{
						vpScroll += pli->GetHeight();	// Advance to vPos

						if(ili == nLine - 1)
							break;

						pli++;
						ili++;

						if(pli->_fFirstOnPage)
						{
							fFoundNewPage = TRUE;
							vpScrollPage = vpScroll;
							iliFirst = ili;
						}
					}
				}
				vpScroll = vpScrollPage;			// Move to top of page
				ili = iliFirst;
			}
			else if(vPos < vpScroll)
			{								 	// Go back to vPos
				if(!ili)
				{
					vpScroll = 0;
					fFoundNewPage = TRUE;
				}
				while(vpScroll > vPos && ili)
				{
					pli--;
					ili--;
					vpScroll -= pli->GetHeight();
					if(pli->_fFirstOnPage)
						fFoundNewPage = TRUE;
				}
				while(!pli->_fFirstOnPage && ili)
				{
					pli--;
					ili--;
					vpScroll -= pli->GetHeight();
				}
			}
			AssertSz(Elem(ili)->_fFirstOnPage,
				"CDisplayML::VScroll: ili not top of page");
		}
		if(!fFoundNewPage)			// Nothing to scroll, early exit
			return MAKELRESULT(0, TRUE);
	}
	else
	{
		switch(wCode)
		{
		case SB_BOTTOM:
			if(vPos < 0)
				return FALSE;
			WaitForRecalc(_ped->GetTextLength(), -1);
			vpScroll = _dvp;
			break;

		case SB_LINEDOWN:
			cliVisible = GetCliVisible();
			if(_iliFirstVisible + cliVisible < Count()
				&& 0 == _dvpFirstVisible)
			{
				i = _iliFirstVisible + cliVisible;
				pli = Elem(i);
				if(IsInOutlineView())
				{	// Scan for uncollapsed line
					for(; pli->_fCollapsed && i < Count();
						pli++, i++);
				}
				if(i < Count())
					dy = pli->GetHeight();
			}
			else if(cliVisible > 1)
			{
				pli = Elem(_iliFirstVisible);
				dy = _dvpFirstVisible;
				// TODO: scan until find uncollapsed line
				dy += pli->GetHeight();
			}
			else
				dy = _dvp - _vpScroll;

			if(dy >= _dvpView)
				dy = dvpSys;

			// Nothing to scroll, early exit
			if ( !dy )
				return MAKELRESULT(0, TRUE); 

			vpScroll += dy;
			break;

		case SB_LINEUP:
			if(_iliFirstVisible > 0)
			{
				pli = Elem(_iliFirstVisible - 1);
				// TODO: scan until find uncollapsed line
				dy = pli->GetHeight();
			}
			else if(vpScroll > 0)
				dy = min(vpScroll, dvpSys);

			if(dy > _dvpView)
				dy = dvpSys;
			vpScroll -= dy;
			break;

		case SB_PAGEDOWN:
			cliVisible = GetCliVisible();
			vpScroll += _dvpView;
			if(vpScroll < _dvp && cliVisible > 0)
			{
				// TODO: Scan until find uncollapsed line
				dy = Elem(_iliFirstVisible + cliVisible - 1)->GetHeight();
				if(dy >= _dvpView)
					dy = dvpSys;

				else if(dy > _dvpView - dy)
				{
					// Go at least a line if line is very big
					dy = _dvpView - dy;
				}
				vpScroll -= dy;
			}
			break;

		case SB_PAGEUP:
			cliVisible = GetCliVisible();
			vpScroll -= _dvpView;

			if (vpScroll < 0)
			{
				// Scroll position can't be negative and we don't
				// need to back up to be sure we display a full line.
				vpScroll = 0;
			}
			else if(cliVisible > 0)
			{
				// TODO: Scan until find uncollapsed line
				dy = Elem(_iliFirstVisible)->GetHeight();
				if(dy >= _dvpView)
					dy = dvpSys;

				else if(dy > _dvpView - dy)
				{
					// Go at least a line if line is very big
					dy = _dvpView - dy;
				}

				vpScroll += dy;
			}
			break;

		case SB_THUMBTRACK:
		case SB_THUMBPOSITION:
			if(vPos < 0)
				return FALSE;

			vpScroll = vPos;
			fTracking = TRUE;
			break;

		case SB_TOP:
			if(vPos < 0)
				return FALSE;
			vpScroll = 0;
			break;

		case SB_ENDSCROLL:
			UpdateScrollBar(SB_VERT);
			return MAKELRESULT(0, TRUE);

		default:
			return FALSE;
		}
	}
    
	BOOL fFractional = wCode != SB_PAGEDOWN && wCode != SB_PAGEUP;
	LONG vpLimit = _dvp;

	if(!IsInPageView() && fFractional)
		vpLimit = max(_dvp - _dvpView, 0);

	vpScroll = min(vpScroll, vpLimit);

	ScrollView(_upScroll, vpScroll, fTracking, fFractional);

	// Force position update if we just finished a track
	if(wCode == SB_THUMBPOSITION)
		UpdateScrollBar(SB_VERT);

	// Return how many lines we scrolled
	return MAKELRESULT((WORD) (_iliFirstVisible - iliSave), TRUE);
}

/*
 *	CDisplay::LineScroll(cli, cch)
 *
 *	@mfunc
 *		Scroll view vertically in response to a scrollbar event
 */
void CDisplayML::LineScroll(
	LONG cli,		//@parm Count of lines to scroll vertically
	LONG cch)		//@parm Count of characters to scroll horizontally
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineScroll");
	
	//Make sure the line to scroll to is valid
	if (cli + _iliFirstVisible >= Count())
	{
        // change line count enough to display the last line
		cli = Count() - _iliFirstVisible;
	}

    // Get the absolute vpScroll position by adding the difference of the line
    // we want to go to and the current _vpScroll position
	LONG dvpScroll = CalcVLineScrollDelta(cli, FALSE);
	if(dvpScroll < 0 || _dvp - (_vpScroll + dvpScroll) > _dvpView - dvpScroll)
		ScrollView(_upScroll, _vpScroll + dvpScroll, FALSE, FALSE);
}

/*
 *	CDisplayML::FractionalScrollView (vDelta)
 *
 *	@mfunc
 *		Allow view to be scrolled by fractional lines.
 */
void CDisplayML::FractionalScrollView ( LONG vDelta )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::FractionalScrollView");

	if ( vDelta)
		ScrollView(_upScroll, min(vDelta + _vpScroll, max(_dvp - _dvpView, 0)), FALSE, TRUE);
}

/*
 *	CDisplayML::ScrollToLineStart(iDirection)
 *
 *	@mfunc
 *		If the view is scrolled so that only a partial line is at the
 *		top, then scroll the view so that the entire view is at the top.
 */
void CDisplayML::ScrollToLineStart(
	LONG iDirection)	//@parm the direction in which to scroll (negative
						// means down the screen
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::ScrollToLineStart");

	// This code originally lined things up on a line. However, it doesn't work
	// very well with big objects especially at the end of the document. I am
	// leaving the call here in case we discover problems later. (a-rsail).

#if 0
	// If _dvpFirstVisible is zero, then we're aligned on a line, so
	// nothing more to do.

	if(_dvpFirstVisible)
	{
		LONG vpScroll = _vpScroll + _dvpFirstVisible;

		if(iDirection <= 0) 
		{
			vpScroll += Elem(_iliFirstVisible)->_dvp;
		}

		ScrollView(_upScroll, vpScroll, FALSE, TRUE);
	}
#endif // 0
}

/*
 *	CDisplayML::CalcVLineScrollDelta (cli, fFractionalFirst)
 *
 *	@mfunc
 *		Given a count of lines, positive or negative, calc the number
 *		of vertical units necessary to scroll the view to the start of
 *		the current line + the given count of lines.
 */
LONG CDisplayML::CalcVLineScrollDelta (
	LONG cli,
	BOOL fFractionalFirst )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CalcVLineScrollDelta");

	LONG vpScroll = 0;

	if(fFractionalFirst && _dvpFirstVisible)	// Scroll partial for 1st.
	{
		Assert(_dvpFirstVisible <= 0);		// get jonmat
		if(cli < 0)
		{
			cli++;
			vpScroll = _dvpFirstVisible;
		}
		else
		{
			cli--;
			vpScroll = Elem(_iliFirstVisible)->GetHeight() + _dvpFirstVisible;
		}
	}

	if(cli > 0)
	{
		// Scrolling down
		cli = min(cli, Count() - _iliFirstVisible - 1);

		if (!fFractionalFirst && (0 == cli))
		{
			// If we are scrolling down and on the last line but we haven't scrolled to
			// the very bottom, then do so now.
			AssertSz(0 == vpScroll, 
				"CDisplayML::CalcVLineScrollDelta last line & scroll");
			vpScroll = _dvp - _vpScroll;

			// Limit scroll length to approximately 3 lines.
			vpScroll = min(vpScroll, 3 * GetDvpSystemFont());
		}
	}
	else if(cli < 0)
	{
		// Scrolling up
		cli = max(cli, -_iliFirstVisible);

		// At the top.
		if (!fFractionalFirst && (0 == cli))
		{
			// Make sure that we scroll back so first visible is 0.
			vpScroll = _dvpFirstVisible;

			// Limit scroll length to approximately 3 lines.
			vpScroll = max(vpScroll, -3 * GetDvpSystemFont());
		}
	}

	if(cli)
		vpScroll += VposFromLine(this, _iliFirstVisible + cli) - VposFromLine(this, _iliFirstVisible);
	return vpScroll;
}

/*
 *	CDisplayML::ScrollView(upScroll, vpScroll, fTracking, fFractionalScroll)
 *
 *	@mfunc
 *		Scroll view to new x and y position
 *
 *	@devnote 
 *		This method tries to adjust the y scroll pos before
 *		scrolling to display complete line at top. x scroll 
 *		pos is adjusted to avoid scrolling all text off the 
 *		view rectangle.
 *
 *		Must be able to handle vpScroll <gt> pdp->dvp and vpScroll <lt> 0
 *
 *	@rdesc
 *		TRUE if actual scrolling occurred, 
 *		FALSE if no change
 */
BOOL CDisplayML::ScrollView (
	LONG upScroll,		//@parm New x scroll position
	LONG vpScroll,		//@parm New y scroll position
	BOOL fTracking,		//@parm TRUE indicates we are tracking scrollbar thumb
	BOOL fFractionalScroll)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::ScrollView");
	BOOL fTryAgain = TRUE;
	LONG dupMax;
	LONG dup = 0;
	LONG dvp = 0;
    RECTUV rcClient, rcClip;
	CTxtSelection *psel = _ped->GetSelNC();
	COleObject *pipo;
	BOOL fRestoreCaret = FALSE;
	LONG iliFirstVisible = _iliFirstVisible;

    AssertSz(_ped->_fInPlaceActive, "CDisplayML::ScrollView() called when not in-place");

	//For scrolling purposes, we clip to rcView's top and bottom, but rcClient's left and right
   	_ped->TxGetClientRect(&rcClient);
	GetViewRect(rcClip, &rcClient);
	rcClip.left = rcClient.left;
	rcClip.right = rcClient.right;
    
	if(upScroll == -1)
        upScroll = _upScroll;
	if(vpScroll == -1)
        vpScroll = _vpScroll;
	
	// Determine vertical scrolling pos
	while(1)
	{
		BOOL fNothingBig = TRUE;
		LONG vFirst;
		LONG dvFirst;
		LONG cpFirst;
		LONG iliFirst;
		LONG vpHeight;
		LONG iliT;

		vpScroll = min(vpScroll, GetMaxVpScroll());
		vpScroll = max(0, vpScroll);
		dvp = 0;

		// Ensure all visible lines are recalced
		if(!WaitForRecalcView())
			return FALSE;

		// Compute new first visible line
		iliFirst = LineFromVpos(this, vpScroll, &vFirst, &cpFirst);
		if(IsInPageView())
		{
			//REVIEW (keithcu) EBOOKS bug 424. Does this need to be here, or 
			//should the logic be somewhere else? Also, would it be better to round
			//rather than to always round down?
			CLine *pli = Elem(iliFirst);
			for(; !pli->_fFirstOnPage && iliFirst; iliFirst--)
			{
				pli--;						// Back up to previous line
				vFirst  -= pli->GetHeight();
				vpScroll -= pli->GetHeight();
				cpFirst -= pli->_cch;
			}
		}

		if( cpFirst < 0 )
		{
			// FUTURE (alexgo) this is pretty bogus, we should try to do
			// better in the next rel.

			TRACEERRORSZ("Display calc hosed, trying again");
			InitVars();
			_fNeedRecalc = TRUE;
			return FALSE;
		}

		if(iliFirst < 0)
		{
			// No line at _vpScroll, use last line instead
			iliFirst = max(0, Count() - 1);
			cpFirst = _ped->GetTextLength() - Elem(iliFirst)->_cch;
			vpScroll = _dvp - Elem(iliFirst)->GetHeight();
			vFirst = _vpScroll;
		}
		if(IsInPageView())
		{
			AssertSz(Elem(iliFirst)->_fFirstOnPage,
				"CDisplayML::ScrollView: _iliFirstVisible not top of page");
			if(vpScroll > vFirst)			// Tried to scroll beyond start
				vpScroll = vFirst;			//  of last line
			goto scrollit;
		}

		dvFirst = vFirst - vpScroll;
		
		// Figure whether there is a big line
		// (more that a third of the view rect)
		for(iliT = iliFirst, vpHeight = dvFirst;
			vpHeight < _dvpView && iliT < Count();
			iliT++)
		{
			const CLine *pli = Elem(iliT);
			if(pli->GetHeight() >= _dvpView / 3)
				fNothingBig = FALSE;
			vpHeight += pli->GetHeight();
		}

		// If no big line and first pass, try to adjust 
		// scrolling pos to show complete line at top
		if(!fFractionalScroll && fTryAgain && fNothingBig && dvFirst != 0)
		{
			fTryAgain = FALSE;		// prevent any infinite loop

			Assert(dvFirst < 0);

			Tracef(TRCSEVINFO, "adjusting scroll for partial line at %d", dvFirst);
			// partial line visible at top, try to get a complete line showing
			vpScroll += dvFirst;

			LONG dvpLine = Elem(iliFirst)->GetHeight();

			// Adjust the height of the scroll by the height of the first 
			// visible line if we are scrolling down or if we are using the 
			// thumb (tracking) and we are on the last page of the view.
			if ((fTracking && vpScroll + _dvpView + dvpLine > _dvp)
				|| (!fTracking && _vpScroll <= vpScroll))
			{
				// Scrolling down so move down a little more
				vpScroll += dvpLine;
			}
		}
		else
		{
			dvp = 0;
			if(vpScroll != _vpScroll)
			{
				_dvpFirstVisible = dvFirst;
scrollit:
				_iliFirstVisible = iliFirst;
				_cpFirstVisible = cpFirst;
				dvp = _vpScroll - vpScroll;
				_vpScroll = vpScroll;

				AssertSz(_vpScroll >= 0, "CDisplayML::ScrollView _vpScroll < 0");
				AssertNr(VerifyFirstVisible());
				if(!WaitForRecalcView())
			        return FALSE;
			}
			break;
		}
	}
	CheckView();

	// Determine horizontal scrolling pos.
	
	dupMax = _dupLineMax;

	// REVIEW (Victork) Restricting the range of the scroll is not really needed and could even be bad (bug 6104)
	
	upScroll = min(upScroll, dupMax);
	upScroll = max(0, upScroll);

	dup = _upScroll - upScroll;
	if(dup)
		_upScroll = upScroll;

	// Now perform the actual scrolling
	if(IsMain() && (dvp || dup))
	{
		// Scroll only if scrolling < view dimensions and we are in-place
		if(IsActive() && !IsTransparent() && 
		    dvp < _dvpView && dup < _dupView && !IsInPageView())
		{
			// FUTURE: (ricksa/alexgo): we may be able to get rid of 
			// some of these ShowCaret calls; they look bogus.
			if (psel && psel->IsCaretShown())
			{
				_ped->TxShowCaret(FALSE);
				fRestoreCaret = TRUE;
			}

			LONG dxp, dyp;
			GetDxpDypFromDupDvp(dup, dvp, GetTflow(), dxp, dyp);

			RECT rcxyClip;
			RectFromRectuv(rcxyClip, rcClip);
			_ped->TxScrollWindowEx(dxp, dyp, NULL, &rcxyClip);

			if(fRestoreCaret)
				_ped->TxShowCaret(FALSE);
		}
		else
			_ped->TxInvalidateRect(&rcClip);

		if(psel)
			psel->UpdateCaret(FALSE);

		if(!fTracking && dvp)
		{
			UpdateScrollBar(SB_VERT);
			_ped->SendScrollEvent(EN_VSCROLL);
		}
		if(!fTracking && dup)
		{
			UpdateScrollBar(SB_HORZ);
			_ped->SendScrollEvent(EN_HSCROLL);
		}
						
		// FUTURE: since we're now repositioning in place active 
		// objects every time we draw, this call seems to be 
		// superfluous (AndreiB)

		// Tell object subsystem to reposition any in place objects
		if(_ped->GetObjectCount())
		{
			pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
			if(pipo)
				pipo->OnReposition();
		}
	}
	bool fNotifyPageChange(false);
	if(IsInPageView() && iliFirstVisible != _iliFirstVisible)
	{
		CalculatePage(iliFirstVisible);
		fNotifyPageChange = true;
	}

	// Update the View after state has been updated
	if(IsMain() && (dvp || dup))
		_ped->TxUpdateWindow();

    if(fNotifyPageChange)
        GetPed()->TxNotify(EN_PAGECHANGE, NULL);

	return dvp || dup;
}

/*
 *	CDisplayML::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range for scrollbar <p nBar>
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplayML::GetScrollRange(
	INT nBar) const		//@parm Scroll bar to interrogate (SB_VERT or SB_HORZ)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetScrollRange");

    Assert( IsMain() );

	LONG lRange = 0;
    
    if(nBar == SB_VERT && _fVScrollEnabled)
    {
	    if(_ped->TxGetScrollBars() & WS_VSCROLL)
			lRange = GetMaxVpScroll();
    }
	else if((_ped->TxGetScrollBars() & WS_HSCROLL) && _fUScrollEnabled)
	{
		// Scroll range is maximum width.
		lRange = max(0, _dupLineMax + _ped->GetCaretWidth());
    }
	// Since thumb messages are limited to 16-bit, limit range to 16-bit
	lRange = min(lRange, _UI16_MAX);
	return lRange;
}

/*
 *	CDisplayML::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update either the horizontal or the vertical scrollbar and
 *		figure whether the scrollbar should be visible or not.
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplayML::UpdateScrollBar(
	INT nBar,				//@parm Which scroll bar : SB_HORZ, SB_VERT
	BOOL fUpdateRange)		//@parm Should the range be recomputed and updated
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::UpdateScrollBar");

	// Note: In the old days we didn't allow autosize & scroll bars, so to keep
	// forms working, we need this special logic with respect to autosize.
	if (!IsActive() || _fInRecalcScrollBars ||
		!_ped->fInOurHost() && _ped->TxGetAutoSize())
	{
		// No scroll bars unless we are inplace active and we are not in the
		// process of updating scroll bars already.
		return TRUE;
	}

	const DWORD dwScrollBars = _ped->TxGetScrollBars();
	const BOOL fHide = !(dwScrollBars & ES_DISABLENOSCROLL);
	BOOL fReturn = FALSE;
	BOOL fEnabled = TRUE;
	BOOL fEnabledOld;
	LONG lScroll;
	CTxtSelection *psel = _ped->GetSelNC();
	BOOL fShowCaret = FALSE;

	// Get scrolling position
	if(nBar == SB_VERT)
	{
		if(!(dwScrollBars & WS_VSCROLL))
			return FALSE;

		fEnabledOld = _fVScrollEnabled;
        if(GetMaxVpScroll() <= _dvpView)
            fEnabled = FALSE;
    }
	else
	{
		if(!(dwScrollBars & WS_HSCROLL))
		{
			// Even if we don't have scrollbars, we may allow horizontal
			// scrolling.
			if(!_fUScrollEnabled && _dupLineMax > _dupView)
				_fUScrollEnabled = !!(dwScrollBars & ES_AUTOHSCROLL);

			return FALSE;
		}

		fEnabledOld = _fUScrollEnabled;
        if(_dupLineMax <= _dupView)
            fEnabled = FALSE;
	}

	// Don't allow ourselves to be re-entered.
	// Be sure to turn this to FALSE on exit
	_fInRecalcScrollBars = TRUE;

	// !s beforehand because all true values aren't necessarily equal
	if(!fEnabled != !fEnabledOld)
	{
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			if (nBar == SB_HORZ)
				_fUScrollEnabled = fEnabled;
			else
				_fVScrollEnabled = fEnabled;
		}

		if(!_fDeferUpdateScrollBar)
		{
    		if(!fHide)
			{
				// Don't hide scrollbar, just disable
    			_ped->TxEnableScrollBar(nBar, fEnabled ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);

				if (!fEnabled)
				{
					// The scroll bar is disabled. Therefore, all the text fits
					// on the screen so make sure the drawing reflects this.
					_vpScroll = 0;
					_dvpFirstVisible = 0;
					_cpFirstVisible = 0;
					_iliFirstVisible = 0;
					_sPage = 0;
					_ped->TxInvalidate();
				}
			}
    		else 
    		{
    			fReturn = TRUE;
    			// Make sure to hide caret before showing scrollbar
    			if(psel)
    				fShowCaret = psel->ShowCaret(FALSE);

    			// Hide or show scroll bar
    			_ped->TxShowScrollBar(nBar, fEnabled);
				// The scroll bar affects the window which in turn affects the 
				// display. Therefore, if word wrap, repaint
				_ped->TxInvalidate();
				// Needed for bug fix #5521
				_ped->TxUpdateWindow();

    			if(fShowCaret)
    				psel->ShowCaret(TRUE);
            }
		}
	}
	
	// Set scrollbar range and thumb position
	if(fEnabled)
	{
        if(fUpdateRange && !_fDeferUpdateScrollBar)
			_ped->TxSetScrollRange(nBar, 0, GetScrollRange(nBar), FALSE);
        
		if(_fDeferUpdateScrollBar)
			_fUpdateScrollBarDeferred = TRUE;
		else
		{
			lScroll = (nBar == SB_VERT)
				? ConvertVPosToScrollPos(_vpScroll)
				: ConvertUPosToScrollPos(_upScroll);

			_ped->TxSetScrollPos(nBar, lScroll, TRUE);
		}
	}
	_fInRecalcScrollBars = FALSE;
	return fReturn;
}

/*
 *	CDisplayML::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height for TXTNS_FITTOCONTENT[2].
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT	CDisplayML::GetNaturalSize(
	HDC hdcDraw,		//@parm DC for drawing
	HDC hicTarget,		//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Width in device units to use for fitting 
	LONG *pheight)		//@parm Height in device units to use for fitting
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetNaturalSize");

	HRESULT hr = S_OK;

	// Set the height temporarily so the zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight(*pheight);

	// Adjust height and width by view inset
	LONG widthView  = *pwidth;
	LONG heightView = *pheight;
	GetViewDim(widthView, heightView);

	// Store adjustment so we can restore it to height & width
	LONG widthAdj  = *pwidth  - widthView;
	LONG heightAdj = *pheight - heightView;
 	
	// Init measurer at cp = 0
	CMeasurer me(this);
	CLine liNew;
	LONG xWidth = 0, lineWidth;
	LONG dvp = 0;
   	LONG cchText = _ped->GetTextLength();
	BOOL fFirstInPara = TRUE;

	LONG dulMax = GetWordWrap() ? DXtoLX(widthView) : duMax;

	// The following loop generates new lines
	do 
	{	// Stuff text into new line
		UINT uiFlags = 0;

		// If word wrap is turned on, then we want to break on
		// words, otherwise, measure white space, etc.		
		if(GetWordWrap())
			uiFlags =  MEASURE_BREAKATWORD;

		if(fFirstInPara)
			uiFlags |= MEASURE_FIRSTINPARA;
	
		me.SetDulLayout(dulMax);
		if(!Measure(me, &liNew, 0, uiFlags))
		{
			hr = E_FAIL;
			goto exit;
		}
		fFirstInPara = liNew._fHasEOP;

		// Keep track of width of widest line
		lineWidth = liNew._dup;
		if(dwMode == TXTNS_FITTOCONTENT2)
			lineWidth += liNew._upStart + me.GetRightIndent();
		xWidth = max(xWidth, lineWidth);
		dvp += liNew.GetHeight();		// Bump height

	} while (me.GetCp() < cchText);

	// Add caret size to width to guarantee that text fits. We don't
	// want to word break because the caret won't fit when the caller
	// tries a window this size.
	xWidth += _ped->GetCaretWidth();

	*pwidth = xWidth;
	*pheight = dvp;

	// Restore insets so output reflects true client rect needed
	*pwidth += widthAdj;
	*pheight += heightAdj;
		
exit:
	SetClientHeight(yOrigHeightClient);
	return hr;
}

/*
 *	CDisplayML::Clone()
 *
 *	@mfunc
 *		Make a copy of this object
 *
 *	@rdesc
 *		NULL - failed
 *		CDisplay *
 *
 *	@devnote
 *		Caller of this routine is the owner of the new display object.
 */
CDisplay *CDisplayML::Clone() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Clone");

	CDisplayML *pdp = new CDisplayML(_ped);

	if(pdp)
	{
		// Initialize our base class
		if(pdp->CDisplay::Init())
		{
			pdp->InitFromDisplay(this);
			pdp->_upScroll = _upScroll;
			pdp->_fVScrollEnabled = _fVScrollEnabled;
			pdp->_fUScrollEnabled = _fUScrollEnabled;
			pdp->_fWordWrap = _fWordWrap;
			pdp->_cpFirstVisible = _cpFirstVisible;
			pdp->_iliFirstVisible = _iliFirstVisible;
			pdp->_vpScroll = _vpScroll;
			pdp->ResetDrawInfo(this);

			if(_pddTarget)
			{
				// Create a duplicate target device for this object
				pdp->SetMainTargetDC(_pddTarget->GetDC(), _dulTarget);
			}

			// This can't be the active view since it is a clone
			// of some view.
			pdp->SetActiveFlag(FALSE);
		}
	}
	return pdp;
}

void CDisplayML::DeferUpdateScrollBar()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DeferUpdateScrollBar");

	_fDeferUpdateScrollBar = TRUE;
	_fUpdateScrollBarDeferred = FALSE;
}

BOOL CDisplayML::DoDeferredUpdateScrollBar()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DoDeferredUpdateScrollBar");

	_fDeferUpdateScrollBar = FALSE;
	if(!_fUpdateScrollBarDeferred)
		return FALSE;

	_fUpdateScrollBarDeferred = FALSE;
	BOOL fHorizontalUpdated = UpdateScrollBar(SB_HORZ, TRUE);
    
	return UpdateScrollBar(SB_VERT, TRUE) || fHorizontalUpdated;
}

/*
 *	CDisplayML::GetMaxUScroll()
 *
 *	@mfunc
 *		Get the maximum x scroll value
 *
 *	@rdesc
 *		Maximum x scroll value
 *
 */
LONG CDisplayML::GetMaxUScroll() const
{
	return _dupLineMax + _ped->GetCaretWidth();
}

/*
 *	CDisplayML::CreateEmptyLine()
 *
 *	@mfunc
 *		Create an empty line
 *
 *	@rdesc
 *		TRUE - iff successful
 */
BOOL CDisplayML::CreateEmptyLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CreateEmptyLine");

	// Make sure that this is being called appropriately
	AssertSz(_ped->GetTextLength() == 0,
		"CDisplayML::CreateEmptyLine called inappropriately");

	CMeasurer me(this);					// Create a measurer
	CLine * pliNew = Add(1, NULL);	// Add one new line

	if(!pliNew)
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		TRACEWARNSZ("CDisplayML::CreateEmptyLine unable to add CLine to CLineArray");
		return FALSE;
	}

	// Measure the empty line
	me.SetDulLayout(1);
	if(!pliNew->Measure(me, MEASURE_BREAKATWORD | MEASURE_FIRSTINPARA))
	{
		Assert(FALSE);
		return FALSE;
	}
	return TRUE;
}

/*
 *	CDisplayML::AdjustToDisplayLastLine()
 *
 *	@mfunc
 *		Calculate the vpScroll necessary to get the last line to display
 *
 *	@rdesc
 *		Updated vpScroll
 *
 */
LONG CDisplayML::AdjustToDisplayLastLine(
	LONG yBase,			//@parm actual vpScroll to display
	LONG vpScroll)		//@parm proposed amount to scroll
{
	LONG iliFirst;
	LONG vFirst;

	if(yBase >= _dvp)
	{
		// Want last line to be entirely displayed.
		// Compute new first visible line
		iliFirst = LineFromVpos(this, vpScroll, &vFirst, NULL);

		// Is top line partial?
		if(vpScroll != vFirst)
		{
			// Yes - bump scroll to the next line so the ScrollView
			// won't bump the scroll back to display the entire 
			// partial line since we want the bottom to display.
			vpScroll = VposFromLine(this, iliFirst + 1);
		}
	}
	return vpScroll;
}

/*
 *	CDisplayML::GetResizeHeight()
 *
 *	@mfunc
 *		Calculates height to return for a request resize
 *
 *	@rdesc
 *		Updated vpScroll
 */
LONG CDisplayML::GetResizeHeight() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetResizeHeight");

    return CalcScrollHeight(_dvp);
}

/*
 *	CDisplayML::RebindFirstVisible(fResetCp)
 *
 *	@mfunc
 *		rebind the first visible line
 *
 */
void CDisplayML::RebindFirstVisible(
	BOOL fResetCp)		//@parm If TRUE, reset cp to 0 
{
	LONG cp = fResetCp ? 0 : _cpFirstVisible;

	// Change first visible entries because CLinePtr::SetCp() and
	// YPosFromLine() use them, but they're not valid
	_dvpFirstVisible = 0;
	_cpFirstVisible = 0;
	_iliFirstVisible = 0;
	_vpScroll = 0;

	// Recompute scrolling position and first visible values after edit
	Set_yScroll(cp);
}

/*
 *	CDisplayML::Set_yScroll(cp)
 *
 *	@mfunc
 *		Set _yScroll corresponding to cp, making sure that in PageView
 *		the display starts at the top of a page
 */						     
void CDisplayML::Set_yScroll(
	LONG cp)		//@parm cp at which to set valid _yScroll
{
	// Recompute scrolling position and first visible values after edit
	CLinePtr rp(this);

   	if(!rp.SetCp(cp, FALSE))			// Couldn't get to cp, so find out
		cp = rp.CalculateCp();			//  cp we got to

   	_vpScroll = VposFromLine(this, rp);
   	_cpFirstVisible = cp - rp.GetIch();
   	_iliFirstVisible = rp;
	Sync_yScroll();						// Make sure _yScroll, _sPage, etc.,
}										//  are valid in PageView

/*
 *	CDisplayML::Sync_yScroll()
 *
 *	@mfunc
 *		Make sure that in PageView the display starts at the top of a page.
 *		Notify client if page number changes
 */						     
void CDisplayML::Sync_yScroll()
{
	if(IsInPageView())					// _yScroll must be to line at
	{									//  top of page
		CLine *pli = Elem(_iliFirstVisible);
		for(; !pli->_fFirstOnPage && _iliFirstVisible; _iliFirstVisible--)
		{
			pli--;						// Back up to previous line
			_vpScroll -= pli->GetHeight();
			_cpFirstVisible -= pli->_cch;
		}
		LONG sPage = _sPage;
		if(sPage != CalculatePage(0))
		{
			_ped->TxInvalidate();
			_ped->TxNotify(EN_PAGECHANGE, NULL);
		}
	}
}

/*
 *	CDisplayML::Paginate(ili, fRebindFirstVisible)
 *
 *	@mfunc
 *		Recompute page breaks from ili on
 *
 *	@rdesc
 *		TRUE if success
 */						     
BOOL CDisplayML::Paginate (
	LONG ili,					//@parm Line to redo pagination from
	BOOL fRebindFirstVisible)	//@parm If TRUE, call RebindFirstVisible()
{
	LONG cLine = Count();

	if(!IsInPageView() || ili >= cLine || ili < 0)
		return FALSE;

	LONG	iliSave = ili;
	CLine *	pli = Elem(ili);

	// Synchronize to top of current page
	for(; ili && !pli->_fFirstOnPage; pli--, ili--)
		;
	// Guard against widow-orphan changes by backing up an extra page
	if(ili && iliSave - ili < 2)
	{
		for(pli--, ili--; ili && !pli->_fFirstOnPage; pli--, ili--)
			;
	}

	LONG cLinePage = 1;					// One line on new page
	LONG dvpHeight = pli->GetHeight();	// Height on new page

	pli->_fFirstOnPage = TRUE;			// First line on page
	ili++;								// One less line to consider
	pli++;								// Advance to next line

	for(; ili < cLine; ili++, pli++)	// Process all lines from ili to EOD
	{
		dvpHeight += pli->GetHeight();	// Add in current line height
		cLinePage++;					// One more line on page (maybe)
		pli->_fFirstOnPage = FALSE;	

		CLine *pliPrev = pli - 1;		// Point at previous line

		if(dvpHeight > _dvpView || pliPrev->_fHasFF || pli->_fPageBreakBefore)
		{
			cLinePage--;
			if(cLinePage > 1 && !pliPrev->_fHasFF) // && fWidowOrphanControl)
			{
				if(pli->_fHasFF && pli->_cch == 1)	// FF line height causing
					continue;						// eject, so leave it on current page

				//If we are in the middle of a wrapped object, bump it to next page
				//We do not do widow/orphan if it could divide wrapped objects between pages
			if (_ped->IsRich())
			{
				if (pli->_cObjectWrapLeft || pli->_cObjectWrapRight)
				{
					CLine *pliOrig = pli;
					if (pli->_cObjectWrapLeft && !pli->_fFirstWrapLeft)
					{
						while (!pli->_fFirstWrapLeft)
							pli--;
					}
					int cLineBack = pliOrig - pli;
					pli = pliOrig;

					if (pli->_cObjectWrapRight && !pli->_fFirstWrapRight)
					{
						while (!pli->_fFirstWrapRight)
							pli--;
					}
					cLineBack = max(cLineBack, (int)(pliOrig - pli));
					pli = pliOrig;

					if (cLineBack < cLinePage) //Don't do this if object is larger than page
					{
						cLinePage -= cLineBack;
						pliPrev -= cLineBack;
						pli -= cLineBack;
						ili -= cLineBack;
					}
				}

 				// If this line and the previous one are in the same para,
 				// we might need widow/orphan logic
 				if (!pli->_fFirstInPara && !pliPrev->_cObjectWrapLeft &&
					!pliPrev->_cObjectWrapRight && (cLinePage > 1) )
				{
 					// If this line ends in an EOP bump both to following page
					// (widow/orphan), but only if either the line is short, or
					// we absolutely know that there will only be one line on
 					// the page. Do the same if prev line ends in a hyphenated
 					// word, and the preceding line does not
 					if (pli->_cchEOP && (pli->_dup < _dupView/2 || ili >= cLine - 1) ||   // Do we need -2 instead of -1?
						pliPrev->_ihyph && ili > 1 && !pliPrev->_fFirstOnPage && !pliPrev[-1]._ihyph)
 					{
 						cLinePage--;		// Point to previous line
 						pliPrev--;			
 						pli--;
 						ili--;
					}
				}
 	
				// Don't end a page with a heading.
				if(cLinePage > 1 && pliPrev->_nHeading &&
				   !pliPrev->_cObjectWrapLeft && !pliPrev->_cObjectWrapRight)
				{
					cLinePage--;
					pliPrev--;			
					pli--;
					ili--;
				}
			}
			}
			pli->_fFirstOnPage = TRUE;		// Define first line on page
			cLinePage = 1;					// One line on new page
			dvpHeight = pli->GetHeight();	// Current height of new page
		}
	}
	if(fRebindFirstVisible)
		RebindFirstVisible();
	return TRUE;
}

/*
 *	CDisplayML::CalculatePage(iliFirst)
 *
 *	@mfunc
 *		Compute page number for _iliFirstVisible starting with iliFirst
 *
 *	@rdesc
 *		Page number calculated
 */						     
LONG CDisplayML::CalculatePage (
	LONG iliFirst)
{
	if(Count() < 2 || !IsInPageView())
	{
		_sPage = 0;
		return 0;
	}

	if(iliFirst < 1)
		_sPage = 0;

	Assert(iliFirst >= 0 && iliFirst < Count());

	LONG	 iDir = 1;
	LONG	 n	 = _iliFirstVisible - iliFirst;
	CLine *pli  = Elem(iliFirst);		// Point at next/previous line

	if(n < 0)
	{
		n = -n;
		iDir = -1;
	}
	else
		pli++;

	for(; n--; pli += iDir)
		if(pli->_fFirstOnPage)
		{
			_sPage += iDir;
			if(_sPage < 0)
				_sPage = 0;
		}

	AssertSz(Elem(_iliFirstVisible)->_fFirstOnPage,
		"CDisplayML::CalculatePage: _iliFirstVisible not top of page");

	return _sPage;
}

/*
 *	CDisplayML::GetPage(piPage, dwFlags, pcrg)
 *
 *	@mfunc
 *		Get page number for _iliFirstVisible
 *
 *	@rdesc
 *		HRESULT = !piPage ? E_INVALIDARG :
 *				  IsInPageView() ? NOERROR : E_FAIL
 */						     
HRESULT CDisplayML::GetPage(
	LONG *piPage,		//@parm Out parm for page number
	DWORD dwFlags, 		//@parm Flags for which page to use
	CHARRANGE *pcrg)	//@parm Out parm for CHARRANGE for page
{
	if(!piPage)
		return E_INVALIDARG;

	*piPage = 0;

	if(dwFlags)							// No flags defined yet
		return E_INVALIDARG;

	if(!IsInPageView())
		return E_FAIL;

#ifdef DEBUG
	if(_sPage < 20)
	{
		LONG sPage = _sPage;
		CalculatePage(0);
		AssertSz(sPage == _sPage, "CDisplayML::GetPage: invalid cached page number");
	}
#endif

	*piPage = _sPage;
	if(pcrg)
	{
		pcrg->cpMin = _cpFirstVisible;
		GetCliVisible(&pcrg->cpMost, TRUE);
	}
	return NOERROR;
}

/*
 *	CDisplayML::SetPage(iPage)
 *
 *	@mfunc
 *		Go to page iPage
 *
 *	@rdesc
 *		HRESULT
 */						     
HRESULT CDisplayML::SetPage (
	LONG iPage)
{
	if(!IsInPageView())
		return E_FAIL;

	LONG nLine = Count();
				
	if(iPage < 0 || !nLine)
		return E_INVALIDARG;

	CLine *pli = Elem(0);					// Scroll from page 0
	LONG	 vpScroll = 0;
	LONG	 vpScrollLast = 0;

	nLine--;	// Decrement nLine so pli++ below will always be valid
	for(LONG ili = 0; ili < nLine && iPage; ili++)
	{
		vpScroll += pli->GetHeight();

		pli++;
		if(pli->_fFirstOnPage)				// Start of new page
		{
			vpScrollLast = vpScroll;
			iPage--;						// One less to go
		}
	}
	if(!_iliFirstVisible)					// This shouldn't be necessary...
		_vpScroll = 0;

	ScrollView(_upScroll, vpScrollLast, FALSE, FALSE);
	return NOERROR;
}
						   
/*
 *	CDisplayML::GetCurrentPageHeight()
 *
 *	@mfunc
 *		Return page height of current page in PageView mode
 *
 *	@rdesc
 *		page height of current page in PageView mode; else 0;
 */
LONG CDisplayML::GetCurrentPageHeight() const
{
	if(!IsInPageView())
		return 0;

	LONG	cLine = Count();
	LONG	dvp = 0;
	LONG	i = _iliFirstVisible;
	CLine *	pli = Elem(i);

	do
	{
		dvp += pli->GetHeight();		// Add in first line's height in any
		pli++;							//  case
		i++;
	}
	while(i < cLine && !pli->_fFirstOnPage);

	return dvp;
}

		
// ================================  DEBUG methods  ============================================

#ifdef DEBUG
/*
 *	CDisplayML::CheckLineArray()
 *
 *	@mfunc	
 *		DEBUG routine that Asserts unless:
 *			1) sum of all line counts equals count of characters in story
 *			2) sum of all line heights equals height of display galley
 */
void CDisplayML::CheckLineArray() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CheckLineArray");

	LONG ili = Count();

	// If we are marked as needing a recalc or if we are in the process of a
	// background recalc, we cannot verify the line array 
	if(!_fRecalcDone || _fNeedRecalc || !ili)
		return;

	LONG cchText = _ped->GetTextLength();

	if (!cchText)
		return;

	LONG cp = 0;
	BOOL fFirstInPara;
	BOOL fPrevLineEOP = TRUE;
	LONG dvp = 0;
	CLine const *pli = Elem(0);
	CTxtPtr tp(_ped, 0);

	while(ili--)
	{
		fFirstInPara = pli->_fFirstInPara;
		if(fPrevLineEOP	^ fFirstInPara)
		{
			tp.SetCp(cp);
			AssertSz(fFirstInPara && IsASCIIEOP(tp.GetPrevChar()),
				"CDisplayML::CheckLineArray: Invalid first/prev flags");
		}
		AssertSz(pli->_cch,	"CDisplayML::CheckLineArray: cch == 0");

		dvp += pli->GetHeight();
		cp		+= pli->_cch;
		fPrevLineEOP = pli->_fHasEOP;
		pli++;
	}

	if((cp != cchText) && (cp != _cpCalcMax))
	{
		Tracef(TRCSEVINFO, "sigma (*this)[]._cch = %ld, cchText = %ld", cp, cchText);
		AssertSz(FALSE,
			"CDisplayML::CheckLineArray: sigma(*this)[]._cch != cchText");
	}

	if(dvp != _dvp)
	{
		Tracef(TRCSEVINFO, "sigma (*this)[]._dvp = %ld, _dvp = %ld", dvp, _dvp);
		AssertSz(FALSE,
			"CDisplayML::CheckLineArray: sigma(*this)[]._dvp != _dvp");
	}
}

void CDisplayML::DumpLines(
	LONG iliFirst,
	LONG cli)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::DumpLines");

	LONG cch;
	LONG ili;
	TCHAR rgch[512];

	if(Count() == 1)
		wcscpy(rgch, TEXT("1 line"));
	else
		wsprintf(rgch, TEXT("%d lines"), Count());
	
#ifdef UNICODE
    // TraceTag needs to take UNICODE...
#else
	TRACEINFOSZ(TRCSEVINFO, rgch);
#endif

	if(cli < 0)
		cli = Count();
	else
		cli = min(cli, Count());
	if(iliFirst < 0)
		iliFirst = Count() - cli;
	else
		cli = min(cli, Count() - iliFirst);

	for(ili = iliFirst; cli > 0; ili++, cli--)
	{
		const CLine * const pli = Elem(ili);

		wsprintf(rgch, TEXT("Line %d (%ldc%ldw%ldh): \""), ili, pli->_cch, 
			pli->_dup, pli->GetHeight());
		cch = wcslen(rgch);
		cch += GetLineText(ili, rgch + cch, CchOfCb(sizeof(rgch)) - cch - 4);
		rgch[cch++] = TEXT('\"');
		rgch[cch] = TEXT('\0');
#ifdef UNICODE
        // TraceTag needs to take UNICODE...
#else
    	TRACEINFOSZ(TRCSEVINFO, rgch);
#endif
	}
}

/*
 *	CDisplayML::CheckView()
 *
 *	@mfunc	
 *		DEBUG routine that checks coherence between _iliFirstVisible,
 *		_cpFirstVisible, and _dvpFirstVisible
 */
void CDisplayML::CheckView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CheckView");

	LONG dvp;
	VerifyFirstVisible(&dvp);

	if(dvp != _vpScroll + _dvpFirstVisible && !IsInPageView())
	{
		Tracef(TRCSEVINFO, "sigma CLine._dvp = %ld, CDisplay.vFirstLine = %ld", dvp, _vpScroll + _dvpFirstVisible);
		AssertSz(FALSE, "CLine._dvp != VIEW.vFirstLine");
	}
}

/*
 *	CDisplayML::VerifyFirstVisible(pHeight)
 *
 *	@mfunc
 *		DEBUG routine that checks coherence between _iliFirstVisible
 *		and _cpFirstVisible
 *
 *	@rdesc	TRUE if things are hunky dory; FALSE otherwise
 */
BOOL CDisplayML::VerifyFirstVisible(
	LONG *pHeight)
{
	LONG	cchSum;
	LONG	ili = _iliFirstVisible;
	CLine const *pli = Elem(0);
	LONG	dvp;

	for(cchSum = dvp = 0; ili--; pli++)
	{
		cchSum  += pli->_cch;
		dvp += pli->GetHeight();
	}

	if(pHeight)
		*pHeight = dvp;

	if(cchSum != _cpFirstVisible)
	{
		Tracef(TRCSEVINFO, "sigma CLine._cch = %ld, CDisplay.cpFirstVisible = %ld", cchSum, _cpMin);
		AssertSz(FALSE, "sigma CLine._cch != VIEW.cpMin");

		return FALSE;
	}
	return TRUE;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\disp.cpp ===
/*
 *	DISP.CPP
 *	
 *	Purpose:
 *		CDisplay class
 *	
 *	Owner:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *		Jon Matousek - smooth scrolling.
 *		Keith Curtis - cleanup metafile handling, generalized textflow support,
 *		changed our clipping model to work better with italics.
 *
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_disp.h"
#include "_edit.h"
#include "_select.h"
#include "_font.h"
#include "_measure.h"
#include "_osdc.h"
#include "_dfreeze.h"

ASSERTDATA

// Decimal point precision of smooth scrolling calculations.
#define SMOOTH_PRECISION (100000L)


// ===========================  Invariant stuff  ======================================================

#define DEBUG_CLASSNAME CDisplay
#include "_invar.h"

#ifdef DEBUG
BOOL
CDisplay::Invariant( void ) const
{
	AssertSz(_dvpView >= 0, "CDisplay::Invariant invalid _dvpView");
	AssertSz(_dvpClient	>= 0, 
		"CDisplay::Invariant invalid _dvpClient");

	return TRUE;
}
#endif


// Auto scroll constants
#define dwAutoScrollUp		1
#define dwAutoScrollDown	2
#define dwAutoScrollLeft	3
#define dwAutoScrollRight	4


//Text flow utility functions

void GetDupDvpFromRect(const RECT &rc, TFLOW tflow, LONG &dup, LONG &dvp)
{
	LONG dxp = rc.right - rc.left;
	LONG dyp = rc.bottom - rc.top;
	if (!IsUVerticalTflow(tflow)) //Normal case
	{
		dup = dxp;
		dvp = dyp;
	}
	else
	{
		dup = dyp;
		dvp = dxp;
	}
}

void GetDxpDypFromDupDvp(LONG dup, LONG dvp, TFLOW tflow, LONG &dxp, LONG &dyp)
{
	switch(tflow)
	{
	case tflowES:
		dxp = dup;
		dyp = dvp;
		break;
	case tflowSW:
		dxp = -dvp;
		dyp = dup;
		break;
	case tflowWN:
		dyp = -dvp;
		dxp = -dup;
		break;
	case tflowNE:
		dyp = -dup;
		dxp = dvp;
		break;
	default:
		Assert(0);
	}
}

void GetDxpDypFromRectuv(const RECTUV &rc, TFLOW tflow, LONG &dxp, LONG &dyp)
{
	LONG dup = rc.right - rc.left;
	LONG dvp = rc.bottom - rc.top;
	if (!IsUVerticalTflow(tflow)) //Normal case
	{
		dxp = dup;
		dyp = dvp;
	}
	else
	{
		dxp = dvp;
		dyp = dup;
	}
}

// ===========================  CLed  =====================================================


void CLed::SetMax(const CDisplay * const pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLed::SetMax");

	_cpMatchNew	 = _cpMatchOld	= pdp->_ped->GetTextLength();
	_iliMatchNew = _iliMatchOld = max(0, pdp->LineCount() - 1);
	_vpMatchNew	 = _vpMatchOld	= pdp->GetHeight();
}


// ===========================  CDisplay  =====================================================


DWORD 	CDisplay::_dwTimeScrollNext;	// time for next scroll step
DWORD 	CDisplay::_dwScrollLast;		// last scroll action

/*
 *	CDisplay::ConvertScrollToUPos(uPos)
 *
 *	@mfunc	
 *		Calculate real scroll position from scroll position
 *
 *	@rdesc
 *		X position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 */
LONG CDisplay::ConvertScrollToUPos(
	LONG uPos)		//@parm Scroll position 
{
	LONG uMax = GetMaxUScroll();

	// Has maximum scroll range exceeded 16-bits?
	if (uMax >= _UI16_MAX)
	{
		// Yes - Extrapolate to the "real" x Positioin
		uPos = MulDiv(uPos, uMax, _UI16_MAX);
	}
	return uPos;
}

/*
 *	CDisplay::ConvertUPosToScrollPos(uPos)
 *
 *	@mfunc	
 *		Calculate scroll position from X position in document.
 *
 *	@rdesc
 *		Scroll position from X position
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 *
 */
LONG CDisplay::ConvertUPosToScrollPos(
	LONG uPos)		//@parm Y position in document
{
	LONG uMax = GetMaxUScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(uMax >= _UI16_MAX)
	{
		// Yes - Extrapolate to the scroll bar position		
		uPos = MulDiv(uPos, _UI16_MAX, uMax);
	}
	return uPos;
}

/*
 *	CDisplay::ConvertVPosToMax(vPos)
 *
 *	@mfunc	
 *		Calculate the real scroll position from the scroll position
 *
 *	@rdesc
 *		V position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the V position
 *		gets greater than that.
 */
LONG CDisplay::ConvertVPosToScrollPos(
	LONG vPos)		//@parm Scroll position 
{
	// Default is single line edit control which cannot have Y-Scroll bars
	return 0;
}

CDisplay::CDisplay (CTxtEdit* ped) :
	CDevDesc (ped)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::CDisplay");

	_TEST_INVARIANT_
	_fRecalcDone = TRUE;
}

CDisplay::~CDisplay()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::~CDisplay");
				 
	_TEST_INVARIANT_
	
	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Remove(this);

	CheckRemoveSmoothVScroll();

	if (_padc)
		delete _padc;

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif
}

/*
 *	CDisplay::InitFromDisplay(pdp)
 *
 *	@mfunc initialize this display from another display instance.
 *
 *	@comment
 *			copy *only* the members that will remain constant
 *		   	between two different display instances.  Currently, that
 *			is only the view variables and device descriptor info.
 */
void CDisplay::InitFromDisplay(
	const CDisplay *pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::InitFromDisplay");

	_dupView	= pdp->_dupView;
	_dvpView	= pdp->_dvpView;
	_dvpClient	= pdp->_dvpClient;

	// Don't save DC; just coordinate information.
	_dxpInch		= pdp->_dxpInch;
	_dypInch		= pdp->_dypInch;

	SetTflow(pdp->GetTflow());
	// If display we are copying from is active display,
	// then this new display is the active display.
	_fActive		= pdp->_fActive;
}

/*
 *	CDisplay::Init()
 *
 *	@mfunc Initializes CDisplay
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplay::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::Init");

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Add(this);

	return TRUE;
}

/*
 *	CDisplay::GetSelBarInPixels()
 *
 *	@mfunc
 *		Helper that returns size of selection bar in device units.
 *
 *	@rdesc
 *		Size of selection bar (is 0 if none).
 */
LONG CDisplay::GetSelBarInPixels() const
{
	return HimetricUtoDU(_ped->TxGetSelectionBarWidth());
}


//================================  Device drivers  ===================================
/*
 *	CDisplay::SetMainTargetDC(hdc, dulTarget)
 *
 *	@mfunc
 *		Sets a target device for this display and updates view 
 *
 *  Note:
 *      No support for targetDC in the base CDisplay class.
 *
 *	Note:
 *		Target device can't be a metafile (can get char width out of a 
 *		metafile)
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::SetMainTargetDC(
	HDC	 hdc,			//@parm Target DC, NULL for same as rendering device
	LONG dulTarget)		//@parm Max width of lines (not used if target device is screen)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetMainTargetDC");

	_TEST_INVARIANT_

	return TRUE;
}

BOOL CDisplay::SetTargetDC(
	HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetTargetDC");

	_TEST_INVARIANT_

	return TRUE;
}

/* 
 *	CDisplay::SetDrawInfo(pdi, dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev)
 *
 *	@mfunc
 *		Sets the drawing information into the display
 *
 *	@rdesc	
 *		void - this cannot fail
 *
 *	@devnote
 *		The key point to this routine is that the caller of this routine
 *		is the owner of the memory for the drawing information. It is the
 *		callers responsiblity to call ReleaseDrawInfo to tell the display
 *		that it is done with the drawing information.
 */
void CDisplay::SetDrawInfo(
	CDrawInfo *pdi,		//@parm memory for draw info if there is not one already
	DWORD dwDrawAspect,	//@parm draw aspect
	LONG  lindex,		//@parm currently unused
	void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,//@parm information on target device								
	HDC hicTargetDev)	//@parm	target information context
{
	HDC hicTargetToUse = hicTargetDev;
	const CDevDesc *pdd;

	// Set up the target device if we need to use the default
	if ((NULL == hicTargetToUse))
	{
		pdd = GetDdTarget();
		if(pdd)
			hicTargetToUse = pdd->GetDC();	
	}

	if (NULL == _pdi)
	{
		// Draw structure not yet allocated so use the one
		// passed in
		_pdi = pdi;
	}

	// Reset the parameters
	_pdi->Init(
		dwDrawAspect,
		lindex,
		pvAspect,
		ptd,
		hicTargetToUse);
}

/* 
 *	CDisplay::ReleaseDrawInfo ()
 *
 *	@mfunc
 *		Releases drawing information from display
 *
 *	@rdesc	
 *		void - this cannot fail
 *
 *	@devnote
 *		Since the display does not own the memory for the drawing information,
 *		this only NULLs out the pointer in the drawing information pointer. It
 *		is the responsiblity of the caller to free the memory for the drawing
 *		information.
 */
void CDisplay::ReleaseDrawInfo()
{
	if(_pdi && !_pdi->Release())
	{
		// This object is no longer referenced so we toss our reference.
		_pdi = NULL;
	}
}

/* 
 *	CDisplay::GetTargetDev ()
 *
 *	@mfunc
 *		Get the target device if one is available
 *
 *	@rdesc	
 *		Pointer to device description object or NULL if none is available.
 *
 *	@devnote
 *		This uses the draw info if it is available and then the main target DC
 *		if it is available.
 */
const CDevDesc*CDisplay::GetTargetDev() const
{
	const CDevDesc *pdd = NULL;

	if(_pdi && _pdi->GetTargetDD())
		pdd = _pdi->GetTargetDD();

	return pdd ? pdd : GetDdTarget();
}


//================================  Background Recalc  ===================================
/*
 *	CDisplay::StepBackgroundRecalc()
 *
 *	@mfunc
 *		Steps background line recalc (at GetCp()CalcMax position)
 *		Called by timer proc. No effect for base class
 *
 *	??? CF - Should use an idle thread
 */
void CDisplay::StepBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::StepBackgroundRecalc");

	_TEST_INVARIANT_
}

/*
 *	CDisplay::WaitForRecalc(cpMax, vpMax)
 *
 *	@mfunc
 *		Ensures that lines are recalced until a specific character
 *		position or vPos. Always TRUE for base CDisplay class.
 *						
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::WaitForRecalc(
	LONG cpMax,		//@parm Position recalc up to (-1 to ignore)
	LONG vpMax)		//@parm vPos to recalc up to (-1 to ignore)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalc");

	_TEST_INVARIANT_

	return TRUE;
}

/*
 *	CDisplay::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Returns TRUE if lines were recalc'd up to ili
 *      Always the case for base CDisplay class.
 */
BOOL CDisplay::WaitForRecalcIli(
	LONG ili)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalcIli");

	_TEST_INVARIANT_

    return TRUE;
}

/*
 *	CDisplay::WaitForRecalcView()
 *
 *	Purpose
 *		Ensure visible lines are completly recalced
 *      Always the case for base CDisplay class
 */
BOOL CDisplay::WaitForRecalcView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalcView");

	_TEST_INVARIANT_

	return TRUE;
}


//====================================  Rendering  =======================================
/*
 * 	CDisplay::Draw(hdcDraw, hicTargetDev, prcClient, prcWBounds,
 *				   prcUpdate, pfnContinue, dwContinue)
 *	@mfunc
 *		General drawing method called by IViewObject::Draw() or in
 *		response to WM_PAINT
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT	CDisplay::Draw(
	HDC		hdcDraw,			//@parm	Rendering device context
	HDC		hicTargetDev,		//@parm	Target information context
	LPCRECT	prcClient,			//@parm	Bounding (client) rectangle
	LPCRECT	prcWBounds,			//@parm Clipping rect for metafiles
    LPCRECT prcUpdate,			//@parm	Dirty rect inside prcClient
	BOOL (CALLBACK *pfnContinue)(DWORD),//@parm Callback for interrupting
								//	long display (currently unused)
	DWORD	dwContinue)			//@parm	Param to pass to pfnContinue
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::Draw");

	_TEST_INVARIANT_

	HRESULT hr = S_OK;

	// Store current depth in drawing locally so we can tell
	// whether we need to actually render.
	DWORD dwDepthThisDraw = _pdi->GetDrawDepth();

    RECTUV rcView, rcClient, rcRender;
	CTxtSelection *psel = _ped->GetSelNC();

	if(!prcWBounds)		// No metafile, so just set rendering DC
	{
		if(!SetDC(hdcDraw))
		{
			hr = E_FAIL;
			goto Cleanup;
		}
	}
	else				// Rendering to a metafile
	{
		//Forms^3 draws using screen resolution, while OLE specifies HIMETRIC
		long dxpInch = GetPed()->fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
		long dypInch = GetPed()->fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

		SetWindowOrgEx(hdcDraw, prcWBounds->left, prcWBounds->top, NULL);
		SetWindowExtEx(hdcDraw, prcWBounds->right, prcWBounds->bottom, NULL);

		SetMetafileDC(hdcDraw, dxpInch, dypInch);
	}

    // Get client rect
    if(prcClient)
		RectuvFromRect(rcClient, *prcClient);
    else
    {
        AssertSz(_ped->_fInPlaceActive, 
        	"CDisplay::GetViewRect() - Not in-place and !prcClient");
        _ped->TxGetClientRect(&rcClient);
    }

	// Compute view rectangle (rcView) from client rectangle (account for
	// inset and selection bar width)
  	GetViewRect(rcView, &rcClient);

	// If this view is not active and it is not to be recalc'd then
	// we only decide to use it if the size matches and return S_FALSE
	// if it doesn't so the caller can create a new display to use for
	// drawing.
	if(!IsActive() && !_fNeedRecalc)
	{
		if (rcView.right - rcView.left != GetDupView() ||
			rcView.bottom - rcView.top != GetDvpView())
		{
			hr = S_FALSE;
			goto Cleanup;
		}
	}

	// Make sure our client rectangle is set correctly.
	_dvpClient = rcClient.bottom - rcClient.top;

    // Recalc view 
    // bug fix #5521
    // RecalcView can potentially call RequestResize which would
    // change the client rect.  Send rect down to update the client rect
    if(!RecalcView(rcView, &rcClient))
		goto Cleanup;

	if(dwDepthThisDraw != _pdi->GetDrawDepth())
	{
		// A draw happened recursively to this draw. Therefore,
		// the screen has already been rendered so we don't need
		// to do anything more here.
		goto Cleanup;
	}

    // Compute rect to render
    if(!prcUpdate)						// Update full view
        rcRender = rcClient;			
	else								// Clip rendering to client rect 
	{
		RECTUV rcUpdate;
		RectuvFromRect(rcUpdate, *prcUpdate);
        if(!IntersectRect(&rcRender, &rcClient, &rcUpdate))
            goto Cleanup;
    }
    
    if(psel)
        psel->ClearCchPending();

    if(IsMain())
        _ped->TxNotify(EN_UPDATE, NULL);

    // Now render
    Render(rcView, rcRender);

	// Update cursor if we need to
	if(_fUpdateCaret)
	{
		// The caret only belongs in an active view with
		// a selection on a control that has the focus
		if (IsActive() && psel && _ped->_fFocus)
		{
			// Update the caret if there is a selection object.
			// Note: we only scroll the caret into view, if
			// it was previously in the view. This avoids having
			// window pop to caret if it is resized and the
			// caret is not in the view.
			psel->UpdateCaret(psel->IsCaretInView());
		}
		_fUpdateCaret = FALSE;
	}

Cleanup:

   	// Reset DC in device descriptor
 	ResetDC();

	return hr;
}	


//====================================  View Recalc  ===================================
/*
 *	CDisplay::UpdateViewRectState(prcClient)
 *
 *	@mfunc	Compares new view to cached and updates the view as well as the
 *	what type of view recalculation needs to occur.
 */
void CDisplay::UpdateViewRectState(
	const RECTUV *prcClient)	//@parm New client rectangle
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateViewRectState");

	LONG dupView = prcClient->right - prcClient->left;
	LONG dvpView = prcClient->bottom -  prcClient->top;

    // Check whether the view rect has changed since last rendering
    // If width has changed, need complete line recalc.
    // If height has changed, recalc all visible and update scrollbars
    if(dupView != _dupView)
    {
		_dupView = dupView;

        _fViewChanged = TRUE;            
        _fNeedRecalc = TRUE;    // need full recalc
    }

    if(dvpView != _dvpView) 
    {
        _dvpView = dvpView;

		// The height can go negative when there is an inset and
		// the client rect is very small. We just set it to 0 because
		// that is the smallest the view can actually get.
		if (_dvpView < 0)
			_dvpView = 0;

        _fViewChanged = TRUE;
    } 
}

/*
 *	CDisplay::RecalcView(rcView)
 *
 *	@mfunc
 *		RecalcView after the view rect changed
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::RecalcView (
	const RECTUV &rcView, RECTUV* prcClient)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::RecalcView");

	_TEST_INVARIANT_

	// Update the x and y coordinates of the view based on the client rect
	UpdateViewRectState(&rcView);

	// Ensure lines are recalced
	if(_fNeedRecalc)
	{
		// Display got recalculated so the caret needs to be repositioned.
		_fUpdateCaret = TRUE;
    	return RecalcView(TRUE, prcClient);
	}
	if(_fViewChanged)
	{
		// The scroll bars are up to date so we can turn off the notification.
		_fViewChanged = FALSE;

		// A height change was noticed in UpdateViewRectState so make sure
		// the horizontal scroll bar (if any is correct).
		UpdateScrollBar(SB_VERT);
	}
    return WaitForRecalcView();
}


//====================================  View Update  ===================================

/*
 *	CDisplay::UpdateView()
 *
 *	@mfunc
 *		Fully recalc all lines and update the visible part of the display 
 *		(the "view") on the screen.
 *
 *	Returns:
 *		TRUE if success
 */
BOOL CDisplay::UpdateView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateView");

	_TEST_INVARIANT_

	if(_fNoUpdateView)
		return TRUE;

	if(!_ped->_fInPlaceActive)
    {
        // If not active, just invalidate everything
        InvalidateRecalc();
        _ped->TxInvalidate();
		_ped->TxUpdateWindow();
        return TRUE;
    }

	if(_ped->_pdp->IsFrozen())
	{
		_ped->_pdp->SetNeedRedisplayOnThaw(TRUE);
		return TRUE;
	}

	// If we get here, we are updating some general characteristic of the
	// display and so we want the cursor updated as well as the general
	// change; otherwise the cursor will land up in the wrong place.
	_fUpdateCaret = TRUE;

	RECTUV rcView;

	// Get view rectangle
  	GetViewRect(rcView);

	// Update size of view, which could have changed
	UpdateViewRectState(&rcView);

	if(!CDevDesc::IsValid())
	{
		// Make our device valid
		SetDC(NULL);
	}

    // Recalc everything
    RecalcView(TRUE);

	// Invalidate entire view
	_ped->TxInvalidate();
	
	return TRUE;
}

/*
 *	CDisplay::RoundToLine(hdc, width, pheight)
 *
 *	@mfunc
 *		Calculate number of default lines to fit in input height
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT CDisplay::RoundToLine(
	HDC hdc, 	//@parm DC for the window
	LONG dup,	//@parm in - width of window; out max width
	LONG *pdvp)	//@parm in - proposed height; out - actual
{
	CLock lock;					// Uses global (shared) FontCache
	SetDC(hdc);					// Set DC

	// Set height temporarily so zoom factor will work out
	LONG dvpOrigHeightClient = SetClientHeight(*pdvp);

	// Use this to adjust for inset height
	LONG dvpAdjForInset = *pdvp;

	// Get rectangle adjusted for insets
	GetViewDim(dup, *pdvp);

	// Save proposed height
	LONG dvpProposed = *pdvp;

	// Calc inset adjusted height
	dvpAdjForInset -= dvpProposed;

	// Get font
	const CCharFormat *pCF = _ped->GetCharFormat(-1);
	Assert(pCF);

	// Get font cache object
	LONG dvpInch = GetDeviceCaps(hdc, LOGPIXELSY);
	dvpInch = Zoom(dvpInch);

	CCcs *pccs = _ped->GetCcs(pCF, dvpInch);
	LONG dvpAdjustFE = pccs->AdjustFEHeight(!_ped->fUseUIFont() && IsMultiLine());
	
	// Get height of font
	LONG dvpFont = pccs->_yHeight + (dvpAdjustFE << 1);

	pccs->Release();

	// Figure out how many lines fit into the input height
	LONG cLines = dvpProposed / dvpFont;

	// See if we need to round up
	if(dvpProposed % dvpFont|| !cLines)
		cLines++;

	// Set height to new value
	*pdvp = dvpFont * cLines + dvpAdjForInset;

	// Set client height back to what it was
	SetClientHeight(dvpOrigHeightClient);

	// Reset the DC
	ResetDC();

	return NOERROR;
}


/*
 * 	CDisplay::RequestResize()
 *
 *	@mfunc
 *		Forces the control to resize vertically so that all text fit into it
 *
 *	@rdesc
 *		HRESULT = (autosize) ? TxNotify(EN_REQUESTRESIZE, &resize) : S_OK
 */
HRESULT CDisplay::RequestResize()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::RequestResize");

	_TEST_INVARIANT_

	CTxtEdit *	ped = GetPed();

	if (IsActive())
		ped->TxShowCaret(FALSE);

	if(ped->TxGetAutoSize())
	{
		REQRESIZE resize;
		LONG dup, dvp;

		// If word wrapping is on, then the width is the normal
		// client width.  Otherwise, it's the width of the longest
		// line.
		dup = GetWordWrap() ? _dupView : GetDupLineMax() + ped->GetCaretWidth();

		// Get view inset for adjusting width
	 	RECTUV rcInset;
		ped->TxGetViewInset(&rcInset, this);
		
		resize.nmhdr.hwndFrom = NULL;
		resize.nmhdr.idFrom = NULL;
		resize.nmhdr.code = EN_REQUESTRESIZE;

		resize.rc.top = resize.rc.left = 0;
		dvp = GetResizeHeight();

		// 1.0 COMPATABILITY
        // 1.0 included the borders when requesting resize
        if (ped->Get10Mode())
        {
            AssertSz(ped->fInplaceActive(), "In 1.0 mode but not inplace active!!");
            HWND hwnd = NULL;
            ped->TxGetWindow(&hwnd);
            if (hwnd)
            {
                RECT rcClient, rcWindow;
                ped->TxGetClientRect(&rcClient);                
                GetWindowRect(hwnd, &rcWindow);
                dvp += max(rcWindow.bottom - rcWindow.top - rcClient.bottom, 0);
				dvp += rcInset.bottom + rcInset.top;
                dup = rcWindow.right - rcWindow.left;
            }
        }
		else
		{
			// Adjust width by inset and selection bar 
			dup += rcInset.left + rcInset.right	+ GetSelBarInPixels();
		}

		if (IsUVerticalTflow(GetTflow()))
		{
			resize.rc.right = dvp;
			resize.rc.bottom = dup;
		}
		else
		{
			resize.rc.right = dup;
			resize.rc.bottom = dvp;
		}
  
  		return ped->TxNotify(EN_REQUESTRESIZE, &resize);
	}
	return S_OK;
}
/*
 *	CDisplay::GetViewRect(RECTUV &rcView, LPCRECT prcClient)
 *
 *	@mfunc
 *		Compute and return the view rectangle in window's client 
 *      area coordinates.
 *
 *	@comm
 *      prcClient is client rect (in window's client coords), which can be
 *		NULL if we are in-place.
 */
void CDisplay::GetViewRect(
	RECTUV &rcView,		//@parm Reference to rect to return
	const RECTUV *prcClient)	//@parm Client rect (in window's client coords)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetViewRect");

	_TEST_INVARIANT_

	RECTUV rcInset;
    
    // If client rect wasn't passed in, get it from host
    if(prcClient)
        rcView = *prcClient;
    else
    {
        AssertSz(_ped->_fInPlaceActive,	"CDisplay::GetViewRect() - Not in-place and !prcClient");
        _ped->TxGetClientRect(&rcView);
    }

	//REVIEW (keithcu) GetViewRect has side affects?!
	_dvpClient = rcView.bottom - rcView.top;
    
    _ped->TxGetViewInset(&rcInset, this);
    
    rcView.left	  += rcInset.left;			// Add in inset offsets
    rcView.top	  += rcInset.top;			// rcView is in device coords
    rcView.right  -= rcInset.right;
    rcView.bottom -= rcInset.bottom;

	// Add in selection bar space
	long dupSelBar = GetSelBarInPixels();
	if (_ped->IsSelectionBarRight())
		rcView.right -= dupSelBar;
	else
		rcView.left += dupSelBar;
}


//===============================  Scrolling  ==============================

/*
 *	CDisplay::VScroll(wCode, vPos)
 *
 *	@mfunc
 *		Scroll the view vertically in response to a scrollbar event
 *      >>> Should be called when in-place active only <<<
 *
 *  Note:
 *      No support for vertical scroll in base CDisplay. No action.
 *
 *	@rdesc
 *		LRESULT formatted for WM_VSCROLL message		
 */
LRESULT CDisplay::VScroll(
	WORD wCode,	   //@parm Scrollbar event code
	LONG vPos)	   //@parm Thumb position (vPos < 0 for EM_SCROLL behavior)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::VScroll");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::UScroll(wCode, uPos)
 *
 *	@mfunc
 *		Scroll uPos in response to a scrollbar event
 *      >>> Should be called when in-place active only <<<
 */
void CDisplay::UScroll(
	WORD wCode,	   //@parm Scrollbar event code
	LONG uPos)	   //@parm Thumb position 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UScroll");

	_TEST_INVARIANT_

	BOOL fTracking = FALSE;
	LONG upScroll = _upScroll;

	if (uPos != 0)
	{
		// Convert x position from scroll bar to offset horizontally
		// in the document.
		uPos = ConvertScrollToUPos(uPos);
	}
    
    AssertSz(_ped->_fInPlaceActive, "CDisplay::UScroll() called when not in place");

	switch(wCode)
	{
	case SB_BOTTOM:
		upScroll = GetDupLineMax();
		break;

	case SB_LINEDOWN:
		// Future: Make this depend on a the current first visible character
		upScroll += GetDupSystemFont();
		break;

	case SB_LINEUP:
		// Future: Make this depend on a the current first visible character
		upScroll -= GetDupSystemFont();
		break;

	case SB_PAGEDOWN:
		upScroll += _dupView;
		break;

	case SB_PAGEUP:
		upScroll -= _dupView;
		break;

	case SB_THUMBTRACK:
	case SB_THUMBPOSITION:
		if(uPos < 0)
			return;
		upScroll = uPos;
		fTracking = TRUE;
		break;

	case SB_TOP:
		upScroll = 0;
		break;

	case SB_ENDSCROLL:
		UpdateScrollBar(SB_HORZ);
		return;

	default:
		return;
	}

	if (upScroll < 0)
	{
		// upScroll is the new proposed scrolling position and
		// therefore cannot be less than 0.
		upScroll = 0;
	}

	ScrollView(upScroll, -1, fTracking, FALSE);

	// force position update if we just finished a track
	if(wCode == SB_THUMBPOSITION)
		UpdateScrollBar(SB_HORZ);
}


/*
 *	CDisplayML::SmoothVScroll ( int direction, WORD cLines,
 *								int speedNum, int speedDenom, BOOL fAdditive )
 *
 *	@mfunc
 *		Setup to handle fractional scrolls, at a particular speed. This was
 *		probably initiated via a Magellan mouse roller movement, or a MButton
 *		down message.
 */
void CDisplay::SmoothVScroll ( int direction, WORD cLines, int speedNum, int speedDenom, BOOL fMouseRoller )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::SmoothVScroll");

	int vDelta;
	int cLinesAndDir;

	int	smoothVDelta;

	Assert ( speedDenom );

	if ( IsVScrollEnabled() )						// Can scroll vertically?
	{
		_fFinishSmoothVScroll = FALSE;				// We're smoothing again.

													// Get total pixels.
		if ( CheckInstallSmoothVScroll() )			// Install periodic update
		{
			_totalSmoothVScroll		= 0;
			_nextSmoothVScroll		= 0;
		}
													// Pixels per epoch
		cLinesAndDir = (direction < 0) ? cLines : -cLines;

		if( cLines )
		{
			vDelta = CalcVLineScrollDelta ( cLinesAndDir, FALSE );
		}
		else
		{
			vDelta = (direction < 0 ) ? _dvpClient : -_dvpClient;
			cLines = 1;		// for the MulDiv calculation below.
		}

		if ( vDelta )								// If something to scroll.
		{
			smoothVDelta = MulDiv( SMOOTH_PRECISION,// NB-Because no FLOAT type
								MulDiv(vDelta, speedNum, speedDenom), cLines);

			_smoothVDelta				= smoothVDelta;
			if ( fMouseRoller )						// roller event.
			{										//  -> additive.
				_totalSmoothVScroll		+= vDelta;
				_continuedsmoothVDelta	= 0;
				_continuedSmoothVScroll	= 0;
			}										// mButton event
			else
			{
				if ( 0 == _totalSmoothVScroll )
					_totalSmoothVScroll	= vDelta;

				_continuedsmoothVDelta	= smoothVDelta;
				_continuedSmoothVScroll	= vDelta;	
			}
		}
	}
}

/*
 *	CDisplay::SmoothVScrollUpdate()
 *
 *	@mfunc
 *		Supports SmoothVScroll. Scroll a small number of pixels.
 *		We are called via a periodic timing task.
 */
void CDisplay::SmoothVScrollUpdate()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::SmoothVScrollUpdate");

	LONG	vDelta;									//  Magellan mouse.
	BOOL	fImmediateUpdate = FALSE;
	
	_nextSmoothVScroll += _smoothVDelta;
													// Remove fractional amt.
	vDelta = _nextSmoothVScroll / SMOOTH_PRECISION;

													// Don't overshoot.
	if ( 0 == _continuedSmoothVScroll
		&& (	(_totalSmoothVScroll <= 0 && vDelta < _totalSmoothVScroll)
			||	(_totalSmoothVScroll >= 0 && vDelta > _totalSmoothVScroll)) )
	{
		vDelta = _totalSmoothVScroll;
	}
											 
	if ( vDelta )									// Scroll vDelta, the
	{												//  integral amount.
		_totalSmoothVScroll -= vDelta;
		_nextSmoothVScroll -= vDelta * SMOOTH_PRECISION;
		FractionalScrollView( vDelta );
	}
	else if ( 0 == _totalSmoothVScroll )			// Starting to wind down?
	{
		 _nextSmoothVScroll -= _smoothVDelta;
		 fImmediateUpdate = TRUE;
	}
													// Finished scrolling?
	if ( (vDelta <= 0 && _totalSmoothVScroll >= 0) || (vDelta >= 0 && _totalSmoothVScroll <= 0 ) )
	{
		LONG cLinesAndDir;

		if ( _continuedsmoothVDelta )				// mButton continuation.
		{
			_smoothVDelta = _continuedsmoothVDelta;
			_totalSmoothVScroll += _continuedSmoothVScroll;
		}
		else
		{
			if ( _continuedSmoothVScroll )
			{
				_fFinishSmoothVScroll	= TRUE;		// Winding down scroll.     
				_continuedSmoothVScroll = 0;		
													// Last line's remainder... 
				cLinesAndDir = _smoothVDelta < 0 ? -1 : 1;
				_totalSmoothVScroll = CalcVLineScrollDelta ( cLinesAndDir, TRUE );

													// check for line boundry.
				if ( _totalSmoothVScroll
					==	CalcVLineScrollDelta ( cLinesAndDir, FALSE ) )
				{
					_totalSmoothVScroll = 0;
				}

				if ( fImmediateUpdate )				// do 'this' epochs scroll.
					SmoothVScrollUpdate();
			}
			else
			{
				CheckRemoveSmoothVScroll();			// All done, remove timer.
			}
		}
	}
}

/*
 *	CDisplay::FinishSmoothVScroll
 *
 *	@mfunc
 *		Cause smooth scroll to finish off the last fractional lines worth of
 *		scrolling and then stop.
 */
VOID CDisplay::FinishSmoothVScroll( )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::FinishSmoothVScroll");

													// any non-zero value.

	if ( !_fFinishSmoothVScroll && _totalSmoothVScroll )
	{
		_fFinishSmoothVScroll	= TRUE;
		_continuedSmoothVScroll = 1;					
		_continuedsmoothVDelta	= 0;				// So smooth scroll stops.
		_totalSmoothVScroll		= 0;
	}
}

/*
 *	CTxtEdit::CheckInstallSmoothScroll()
 *
 *	@mfunc
 *		Install a new smooth scroll timer if not already scrolling.
 */
BOOL CDisplay::CheckInstallSmoothVScroll()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::CheckInstallSmoothVScroll");

	_TEST_INVARIANT_
	
	BOOL	fJustInstalled = FALSE;

	if(!_fSmoothVScroll && _ped->TxSetTimer(RETID_SMOOTHSCROLL, 25))
	{
		_fSmoothVScroll = TRUE;
		fJustInstalled = TRUE;
	}

	return fJustInstalled;
}

/*
 *	CTxtEdit::CheckRemoveSmoothVScroll ( )
 *
 *	@mfunc
 *		Finish smooth scroll. If not a forced stop, then check
 *		to see if smooth scrolling should continue, and if so, setup
 *		to continue smooth scrolling.
 */
VOID CDisplay::CheckRemoveSmoothVScroll ( )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::CheckRemoveSmoothVScroll");

	_TEST_INVARIANT_

	if(	_fSmoothVScroll )
	{
		ScrollToLineStart( _continuedSmoothVScroll );	// Ensure stopped on a line.

		_ped->TxKillTimer(RETID_SMOOTHSCROLL);
		_fSmoothVScroll = FALSE;
	}
}

/*
 *	CDisplay::LineScroll(cli, cch)
 *
 *	@mfunc
 *		Scroll the view horizontally in response to a scrollbar event
 *
 *  Note:
 *      No support for vertical scroll in base CDisplay. No action.
 */
void CDisplay::LineScroll(
	LONG cli,	//@parm Count of lines to scroll vertically
	LONG cch)	//@parm Count of chars to scroll horizontally
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::LineScroll");

	_TEST_INVARIANT_

    return;
}

void CDisplay::FractionalScrollView (
	LONG vDelta )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::FractionalScrollView");

	_TEST_INVARIANT_

    return;
}

VOID CDisplay::ScrollToLineStart ( LONG iDirection )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::ScrollToLineStart");

	_TEST_INVARIANT_

    return;
}

LONG CDisplay::CalcVLineScrollDelta ( LONG cli, BOOL fFractionalFirst )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::CalcVLineScrollDelta");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::DragScroll(ppt)
 *
 *	@mfunc
 *		Auto scroll when dragging the mouse out of the visible view
 *
 *	Arguments:
 *		ppt 	mouse position (in client coordinates)
 */
BOOL CDisplay::DragScroll(const POINT * ppt)	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::DragScroll");

	_TEST_INVARIANT_

	const DWORD dwTime = GetTickCount();
	BOOL fScrolled = FALSE;
	DWORD dwScroll = 0;
	RECTUV rc;
    int nScrollInset;

    AssertSz(_ped->_fInPlaceActive, "CDisplay::DragScroll() called when not in-place");

    GetViewRect(rc);
    nScrollInset = (int)W32->GetScrollInset();
	InflateRect((RECT*)&rc, - nScrollInset, - nScrollInset);

	if(_fVScrollEnabled && (_ped->TxGetScrollBars() & ES_AUTOVSCROLL))
	{
    	const vpScroll = ConvertVPosToScrollPos(GetVpScroll());

		if(ppt->y <= rc.top)
		{
			dwScroll = dwAutoScrollUp;
		}
		else if(ppt->y > rc.bottom) 
		{
			LONG vpMax = GetScrollRange(SB_VERT);
			if(vpScroll < vpMax)
				dwScroll = dwAutoScrollDown;
		}
	}
	
	if(!dwScroll && _fUScrollEnabled && (_ped->TxGetScrollBars() & ES_AUTOHSCROLL))
	{
    	const upScroll = ConvertUPosToScrollPos(GetUpScroll());

		if((ppt->x <= rc.left) && (upScroll > 0))
		{
			dwScroll = dwAutoScrollLeft;
		}
		else if(ppt->x > rc.right) 
		{
			LONG xMax = GetScrollRange(SB_HORZ);
			if(upScroll < xMax)
    			dwScroll = dwAutoScrollRight;
		}
	}

	if(dwScroll)
	{
		if(_dwScrollLast != dwScroll)
		{
			// entered or moved to a different auto scroll area
			// reset delay counter
			TRACEINFOSZ("enter auto scroll area");
			_dwTimeScrollNext = dwTime + cmsecScrollDelay;
		}
		else if(dwTime >= _dwTimeScrollNext)
		{
			WORD wScrollCode = SB_LINEDOWN;

			switch(dwScroll)
			{
			case dwAutoScrollUp:
				wScrollCode = SB_LINEUP;
				// fall through to dwAutoScrollDown
			case dwAutoScrollDown:
				// OnVScroll() doesn't scroll enough for our desires
				VScroll(wScrollCode, 0);
				VScroll(wScrollCode, 0);
				break;

			case dwAutoScrollLeft:
				wScrollCode = SB_LINEUP;
				// fall through to dwAutoScrollRight
			case dwAutoScrollRight:
				// UScroll() doesn't scroll enough for our desires
				UScroll(wScrollCode, 0);
				UScroll(wScrollCode, 0);
				UScroll(wScrollCode, 0);
				UScroll(wScrollCode, 0);
				break;
#ifdef DEBUG
			default:
				Tracef(TRCSEVWARN, "Unexpected dwScroll %lx", dwScroll);
				TRACEERRSZSC("Unexpected dwScroll", E_INVALIDARG);
				break;
#endif
			}
			// reset interval counter
			_dwTimeScrollNext = dwTime + cmsecScrollInterval;
			fScrolled = TRUE;
		}
	}
#if !defined(NOFULLDEBUG) && defined(DEBUG)
	else if(_dwScrollLast)
		TRACEINFOSZ("moved out of auto scroll area");
#endif
	_dwScrollLast = dwScroll;

	return fScrolled;
}

/*
 *	CDisplay::AutoScroll(pt, upScrollInset, vpScrollInset)
 *
 *	@mfunc:
 *		Given the current point, determine whether we need to
 *		scroll the client area.
 *
 *	Requires:
 *		This function should only be called during a drag drop
 *		operation.
 *
 *	@rdesc
 *		True if we are in the drag scrolling hot zone, false otherwise.
 *
 */
#define ScrollUp	0x0001	//These eight macros indicate the areas
#define ScrollDown	0x0010	//of the drag scrolling hot zone that tell
#define ScrollLeft	0x0100	//which direction to scroll.
#define ScrollRight 0x1000	//The last four are ambiguous (the corners)
#define ScrollUL	0x0101	//and require a little extra work.
#define ScrollUR	0x1001
#define ScrollDL	0x0110
#define ScrollDR	0x1010

BOOL CDisplay::AutoScroll(
	POINTUV pt,				 //@parm Cursor location in client coordinates
	const WORD upScrollInset,
	const WORD vpScrollInset)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDisplay::AutoScroll");

	static DWORD hotticks = 0;			//Ticks when we entered hot zone.
	static DWORD lastscrollticks = 0;	//Ticks when we last scroll.
	static DWORD lastticks = 0;			//Ticks when last called.
	DWORD delta;						//Ticks since last called.
	DWORD ticks;						//GetTickCount ticks.
	RECT rcClient;						//Client rect of control.
	WORD wScrollDir = 0;				//Scroll direction.
	BOOL fScroll = FALSE;				//TRUE if we should try to scroll this time.
    BOOL fEnabled = FALSE;              //TRUE if scrolling is possible

	//Get the current ticks and calculate ticks since last called.
	//Note that if _drags does not have valid data this will be a
	//bogus value, but that is handled later.
	ticks = GetTickCount();
	delta = ticks - lastticks;
	lastticks = ticks;

	//Don't do anything if no ticks since last time we were called.
	if (delta)
	{
		// Get our client rect.
		_ped->TxGetClientRect(&rcClient);

		//Find out if we are in the hot zone.
		//Note that if we are in one of the corners
		//we will indicate two scrolling directions.
		//This ambiguity will be sorted out later.
		//For now we just want to know if we are in
		//the zone.
		if (pt.u <= (LONG)(rcClient.left + upScrollInset))
			wScrollDir |= (WORD)ScrollLeft;
		else if (pt.u >= (LONG)(rcClient.right - upScrollInset))
			wScrollDir |= (WORD)ScrollRight;

		if (pt.v <= (LONG)(rcClient.top + vpScrollInset))
			wScrollDir |= (WORD)ScrollUp;
		else if (pt.v >= (LONG)(rcClient.bottom - vpScrollInset))
			wScrollDir |= (WORD)ScrollDown;
			
		//If we are somewhere in the hot zone.
		if (wScrollDir)
		{
			//If we just entered hotzone remember the current ticks.
			if (!hotticks)
				hotticks = ticks;

			//If we have been in the hot zone long enough, and
			//the required interval since the last scroll has elapsed
			//allow another scroll. Note that if we haven't scrolled yet,
			//lastscrollticks will be zero so the delta is virtually
			//guaranteed to be greater than ScrollInterval.
			if ((ticks - hotticks) >= (DWORD)W32->GetScrollDelay() &&
			    (ticks - lastscrollticks) >= (DWORD)W32->GetScrollInterval())
				fScroll = TRUE;

    		//If we are in one of the corners, we scroll
    		//in the direction of the edge we are closest
    		//to.
    		switch (wScrollDir)
    		{
    			case ScrollUL:
    			{
    				if ((pt.v - rcClient.top) <= (pt.u - rcClient.left))
    					wScrollDir = ScrollUp;
    				else
    					wScrollDir = ScrollLeft;
    				break;
    			}
    			case ScrollUR:
    			{
    				if ((pt.v - rcClient.top) <= (rcClient.right - pt.u))
    					wScrollDir = ScrollUp;
    				else
    					wScrollDir = ScrollRight;
    				break;
    			}
    			case ScrollDL:
    			{
    				if ((rcClient.bottom - pt.v) <= (pt.u - rcClient.left))
    					wScrollDir = ScrollDown;
    				else
    					wScrollDir = ScrollLeft;
    				break;
    			}
    			case ScrollDR:
    			{
    				if ((rcClient.bottom - pt.v) <= (rcClient.right - pt.u))
    					wScrollDir = ScrollDown;
    				else
    					wScrollDir = ScrollRight;
    				break;
    			}
    		}
		}
		else
		{
			//We aren't in the hot zone so reset hotticks as a
			//flag so we know the first time we reenter it.
			hotticks = 0;
		}

        //Do processing for horizontal scrolling if necessary
		if (wScrollDir == ScrollLeft || wScrollDir == ScrollRight)
		{
            LONG xRange, upScroll, dx;

            upScroll = ConvertUPosToScrollPos(GetUpScroll());
            xRange = GetScrollRange(SB_HORZ);
			dx = W32->GetScrollHAmount();

            fEnabled = IsUScrollEnabled();
            if (wScrollDir == ScrollLeft)
            {
                fEnabled = fEnabled && (upScroll > 0);
               	upScroll -= dx;
                upScroll = max(upScroll, 0);
            }
            else
            {
                fEnabled = fEnabled && (upScroll < xRange);
				upScroll += dx;
                upScroll = min(upScroll, xRange);
            }

            //Do the actual scrolling if necessary.
			if (fEnabled && fScroll)
			{
                UScroll(SB_THUMBPOSITION, upScroll);
				lastscrollticks = ticks;
			}
		}
        //Do processing for Vertical scrolling if necessary
        else if (wScrollDir == ScrollUp || wScrollDir == ScrollDown)
		{
            LONG yRange, vpScroll, dy;

            vpScroll = ConvertVPosToScrollPos(GetVpScroll());
            yRange = GetScrollRange(SB_VERT);
    		dy = W32->GetScrollVAmount();
	
            fEnabled = IsVScrollEnabled();
            if (wScrollDir == ScrollUp)
            {
                fEnabled = fEnabled && (vpScroll > 0);
                vpScroll -= dy;
                vpScroll = max(vpScroll, 0);
            }
            else
            {
                fEnabled = fEnabled && (vpScroll < yRange);
    			vpScroll += dy;
                vpScroll = min(vpScroll, yRange);
            }

	        //Do the actual scrolling if necessary.
    		if (fEnabled && fScroll)
			{
				// We need to scroll fractionally because the scroll logic tries
				// to put a full line on the top and if the scroll amount is less
				// than a full line, the scrolling will get stuck on that line.
				ScrollView(_upScroll, vpScroll, FALSE, TRUE);
				lastscrollticks = ticks;
			}
		}
	}

	return fEnabled;
}

/*
 *	CDisplay::AdjustToDisplayLastLine(yBase, vpScroll)
 *
 *	@mfunc
 *		Calculate the yscroll necessary to get the last line to display
 *
 *	@rdesc
 *		Updated vpScroll
 *
 *	@devnote:
 *		This method is only really useful for ML displays. This method
 *		here is a placeholder which does nothing which is useful for
 *		all other displays.
 */
LONG CDisplay::AdjustToDisplayLastLine(
	LONG yBase,			//@parm Actual vpScroll to display
	LONG vpScroll)		//@parm Proposed amount to scroll
{
	return vpScroll;
}

/*
 *	CDisplay::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range
 *      No scrollbar support in the base class: returns 0.
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplay::GetScrollRange(
	INT nBar) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetScrollRange");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update either the horizontal or vertial scroll bar
 *		Also figure whether the scroll bar should be visible or not
 *      No scrollbar support in the base class: no action.
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplay::UpdateScrollBar(
	INT	 nBar,
	BOOL fUpdateRange)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateScrollBar");

	_TEST_INVARIANT_

	return TRUE;
}

/*
 *	CDisplay::GetZoomDenominator()
 *
 *	@mfunc
 *		Get zoom denominator  
 *
 *	@rdesc
 *		Returns zoom denominator
 *
 *	@devnote:
 *		FUTURE: (Ricksa) we should investigate how to cache this data since
 *				the display needs to keep a temporary zoom denominator anyway.
 */
LONG CDisplay::GetZoomDenominator() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetZoomDenominator");

	if(_ped->GetZoomDenominator())				// Simple EM_SETZOOM API
		return _ped->GetZoomDenominator();		//  supercedes complicated
												//  Forms^3 API
	// Default zoom to error case. The error case is a very low
	// probability event that we can do nothing to recover. So we 
	// just set the value to something reasonable and continue.
	LONG lZoomDenominator = _dvpClient;

	// Is temporary zoom denominator set?
	if(INVALID_ZOOM_DENOMINATOR == _lTempZoomDenominator)
	{
		// No - Get extent size from host
		SIZEL sizelExtent;
		if(SUCCEEDED(_ped->TxGetExtent(&sizelExtent)))
		{
			// Convert height to device units. Note that by definition, we
			// can ignore horizontal extents so we do. Use CDevDesc conversion
			// to avoid infinite recursion
			lZoomDenominator = CDevDesc::HimetricYtoDY(
				IsUVerticalTflow(GetTflow()) ? sizelExtent.cx : sizelExtent.cy);
		}
	}
	else	// Temporary zoom denominator is set: use it
		lZoomDenominator = CDevDesc::HimetricYtoDY(_lTempZoomDenominator);

	return lZoomDenominator > 0 ? lZoomDenominator : 1;
}

/*
 *	CDisplay::GetZoomNumerator()
 *
 *	@mfunc
 *		Get zoom numerator  
 *
 *	@rdesc
 *		Returns zoom numerator
 */
LONG CDisplay::GetZoomNumerator() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetZoomNumerator");

	if(_ped->GetZoomNumerator())				// Simple EM_SETZOOM API
		return _ped->GetZoomNumerator();		//  supercedes complicated
												//  Forms^3 API
	return _dvpClient > 0 ? _dvpClient : 1;
}

/*
 *	CDisplay::Zoom(x)
 *
 *	@mfunc
 *		Get zoomed x  
 *
 *	@rdesc
 *		Returns zoomed x
 */
// REVIEW (keithcu) Why does Zoom do anything when we are in print preview?
LONG CDisplay::Zoom(LONG x) const
{
	return MulDiv(x, GetZoomNumerator(), GetZoomDenominator());
}

/*
 *	CDisplay::UnZoom(x)
 *
 *	@mfunc
 *		Get unzoomed x  
 *
 *	@rdesc
 *		Returns unzoomed x
 */
LONG CDisplay::UnZoom(LONG x) const
{
	return MulDiv(x, GetZoomDenominator(), GetZoomNumerator());
}

/*
 *	CDisplay::HimetricUtoDU(u)
 *
 *	@mfunc
 *		Get device u coordinate corresponding to Himetric u coordinate  
 *
 *	@rdesc
 *		Returns device coordinate
 */
LONG CDisplay::HimetricUtoDU(
	LONG u) const
{
	u = Zoom(u);

	if (!IsUVerticalTflow(GetTflow()))
		return CDevDesc::HimetricXtoDX(u);
	else
		return CDevDesc::HimetricYtoDY(u);
}

/*
 *	CDisplay::HimetricVtoDV(v)
 *
 *	@mfunc
 *		Get device v coordinate corresponding to Himetric v coordinate  
 *
 *	@rdesc
 *		Returns device coordinate
 */
LONG CDisplay::HimetricVtoDV(
	LONG v) const
{
	v = Zoom(v);

	if (!IsUVerticalTflow(GetTflow()))
		return CDevDesc::HimetricYtoDY(v);
	else
		return CDevDesc::HimetricXtoDX(v);
}

/*
 *	CDisplay::DUtoHimetricU(du)
 *
 *	@mfunc
 *		Get Himetric u coordinate corresponding to device u coordinate  
 *
 *	@rdesc
 *		Returns Himetric coordinate
 */
LONG CDisplay::DUtoHimetricU(
	LONG du) const
{
	if (!IsUVerticalTflow(GetTflow()))
		du = CDevDesc::DXtoHimetricX(du);
	else
		du = CDevDesc::DYtoHimetricY(du);

	return UnZoom(du);
}

/*
 *	CDisplay::DVtoHimetricV(dv)
 *
 *	@mfunc
 *		Get Himetric v coordinate corresponding to device v coordinate  
 *
 *	@rdesc
 *		Returns Himetric coordinate
 */
LONG CDisplay::DVtoHimetricV(
	LONG dv) const
{
	if (!IsUVerticalTflow(GetTflow()))
		dv = CDevDesc::DYtoHimetricY(dv);
	else
		dv = CDevDesc::DXtoHimetricX(dv);

	return UnZoom(dv);
}

/*
 *	CDisplay::SetClientHeight(yNewClientHeight)
 *
 *	@mfunc
 *		Reset height of client rectangle
 *
 *	@rdesc
 *		Returns previous height of the client rectangle
 */
LONG CDisplay::SetClientHeight(
	LONG yNewClientHeight)	//@parm New height for the client rectangle.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetClientHeight");

	LONG yOldHeight = _dvpClient;
	_dvpClient = yNewClientHeight;
	return yOldHeight;
}

/*
 *	CDisplay::GetCachedSize(pdupClient, pdvpClient)
 *
 *	@mfunc		calculates the client size
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
 HRESULT CDisplay::GetCachedSize( 
 	LONG *pdupClient,  	//@parm	where to put the width
 	LONG *pdvpClient)	//@parm where to put the height
	const
 {
 	RECTUV rcInset;

	_ped->TxGetViewInset(&rcInset, this);

	*pdvpClient = _dvpClient;
	*pdupClient = _dupView + rcInset.left + rcInset.right + GetSelBarInPixels();

	return NOERROR;
}

/*
 *	CDisplay::TransparentHitTest(hdc, prcClient, pt, pHitResult)
 *
 *	@mfunc
 *		Determine if the hit is on a transparent control
 *
 *	@rdesc
 *		Returns HRESULT of call usually S_OK.
 *
 *	@devnote
 *		FUTURE: This code needs to be investigated for possible optimizations.
 *
 *		This code is assumes that all remeasuring needed has been done before 
 *		this routine is called.
 */

// How close hit needs to be to the text
const int HIT_CLOSE_RECT_INC = 5;

HRESULT CDisplay::TransparentHitTest(
	HDC		hdc,		//@parm DC for actual drawing
	LPCRECT	prcClient,	//@parm Client rectangle for rendering
	POINTUV pt,			//@parm Point to hittest against
	DWORD *	pHitResult)	//@parm	Result of the hit test see TXTHITRESULT 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::TransparentHitTest");

	COLORREF	 crBackground = _ped->TxGetBackColor();
	HDC			 hdcMem = NULL;
	HRESULT		 hr = E_FAIL;
	int			 uRow, vCol;
	COffscreenDC osdc;
	RECTUV		 rcClient, rcRender, rcView;
	RECT		 rcxyClient;

	rcxyClient.left = rcxyClient.top = 0;
	rcxyClient.right = prcClient->right  - prcClient->left;
	rcxyClient.bottom = prcClient->bottom - prcClient->top;
	
	// Render view to a memory DC
	// Compute zero based client rectangle
	RectuvFromRect(rcClient, rcxyClient);

	// Create a memory DC
	hdcMem = osdc.Init(hdc, rcxyClient.right - rcxyClient.left, rcxyClient.bottom - rcxyClient.top, crBackground);
	if(!hdcMem)
		goto Cleanup;

	// Initialize display
	osdc.FillBitmap(rcxyClient.bottom, rcxyClient.right);

	// Set the DC to the memory DC
	SetDC(hdcMem);

	// Get view rectangle that we need for rendering
  	GetViewRect(rcView, &rcClient);

	// Adjust point to be relative to the memory display
	pt.u -= prcClient->left;
	pt.v -= prcClient->top;

	// Initalize box around point. Note that we only really need to render
	// the data inside this box because this is the only area that we will
	// test.
	rcRender.top = pt.v - HIT_CLOSE_RECT_INC;
	if (rcRender.top < 0)
		rcRender.top = 0;

	rcRender.bottom = pt.v + HIT_CLOSE_RECT_INC;
	if (rcRender.bottom > rcClient.bottom)
		rcRender.bottom = rcClient.bottom;	

	rcRender.left = pt.u - HIT_CLOSE_RECT_INC;
	if (rcRender.left < 0)
		rcRender.left = 0;

	rcRender.right = pt.u + HIT_CLOSE_RECT_INC;
	if (rcRender.right > rcClient.right)
		rcRender.right = rcClient.right;

    // Now render
    Render(rcView, rcRender);

	// Hit test
	// Assume no hit
	*pHitResult = TXTHITRESULT_TRANSPARENT;

	// At this point we won't fail this
	hr = S_OK;

	// Is there an exact hit?
	POINT ptxy;
	PointFromPointuv(ptxy, pt);
	if (GetPixel(hdcMem, ptxy.x, ptxy.y) != crBackground)
	{
		*pHitResult = TXTHITRESULT_HIT;
		goto Cleanup;
	}

	// Is it close? We determine closeness by putting
	// a 10 x 10 pixel box around the hit point and 
	// seeing if there is a hit there.

	// Loop examining each bit in the box to see if it is on.
	for (uRow = rcRender.top; uRow <= rcRender.bottom; uRow++)
	{
		for (vCol = rcRender.left; vCol <= rcRender.right; vCol++)
		{
			pt.u = uRow;
			pt.v = vCol;
			PointFromPointuv(ptxy, pt);
			if (GetPixel(hdcMem, ptxy.x, ptxy.y) != crBackground)
			{
				*pHitResult = TXTHITRESULT_CLOSE;
				goto Cleanup;
			}
		}
	}

Cleanup:
	ResetDC(); //REVIEW (keithcu) shouldn't be needed!
	return hr;
}

//============================ ITxNotify Interface ==========================
/*
 *	CDisplay::OnPreReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		Preprocess a change in backing store
 *
 *	@devnote
 *		This display doesn't care about before changes
 */
void CDisplay::OnPreReplaceRange( 
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnPreReplaceRange");

	// Display doesn't care about before the fact
}

/*
 *	CDisplay::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		Process a change to the backing store as it applies to the display
 */
void CDisplay::OnPostReplaceRange( 
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnPostReplaceRange");

	// There is one NO-OP's for the display:
	// currently loading a file.
	//
	// We NO-OP the load case because loading an RTF file can consist
	// of potentially very many small actions as we peice together
	// the various bits of formatted text.  Once done, the load code
	// will go through and do an update-all to the display.
	Assert (cp != CONVERT_TO_PLAIN);			// Handled with PreReplace notifications

	// Figure out range needed to update
	LONG cpNew = min(cp, cpFormatMin);

	if(CP_INFINITE == cpNew)
	{
		// If both cp's are infinite we don't need to bother with
		// this operation.
		return;
	}

	if(!_ped->_fInPlaceActive)
    {
        // If not active, just invalidate everything
        InvalidateRecalc();
        _ped->TxInvalidate();
		_ped->TxUpdateWindow();
        return;
    }

	// Adjust cp for further calculations
	if(CP_INFINITE == cp)
		cp = 0;

	// find the new max end of the original region.
	LONG	cpForEnd = max( (cp + cchDel), cpFormatMax);

	// Number of deleted characters is the difference between the previous two
	LONG cchDelForDisplay = cpForEnd - cpNew;

	// The number deleted is simply number of new characters adjusted by
	// the change in the number of characters.
	LONG cchNewForDisplay = cchDelForDisplay + (cchNew - cchDel);

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	if(_padc)
	{
		// Display is frozen so accumulate the change instead of actually
		// displaying it on the screen.
		_padc->UpdateRecalcRegion(cpNew, cchDelForDisplay, cchNewForDisplay);
		return;
	}		

	// Tell display to update
	CRchTxtPtr rtp(_ped, cpNew);

	UpdateView(rtp, cchDelForDisplay, cchNewForDisplay);
}

/*
 *	CDisplay::SetWordWrap(fWordWrap)
 *
 *	@mfunc
 *		Sets the no wrap flag
 *
 *	@devnote
 *		We will always allow the property to be set but we will not
 *		necessarily pay attention. In other words, word wrap has no
 *		effect on a single line edit control.
 */
void CDisplay::SetWordWrap(
	BOOL fWordWrap)		//@param TRUE - turn on word wrap.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetWordWrap");

	AssertSz((fWordWrap == TRUE) ||	(fWordWrap == FALSE),
		"CDisplay::SetWordWrap bad input flag");

	// Set nowrap to whatever is coming in.
	_fWordWrap = fWordWrap;
}

/*
 *	CDisplay::GetWordWrap()
 *
 *	@mfunc
 *		Return state of word wrap property
 *
 *	@rdesc
 *		TRUE - word wrap is on
 *		FALSE - word wrap is is off.
 *
 *	@devnote
 *		Derived classes such as CDisplaySL override this.
 */
BOOL CDisplay::GetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetWordWrap");

	return _fWordWrap;
}

/*
 *	CDisplay::GetViewDim(dup, dvp)
 *
 *	@mfunc
 *		Return the height & width of view adjusted for view inset
 */
void CDisplay::GetViewDim(
	LONG& dup,		//@parm Where to return the width
	LONG& dvp)		//@parm Where to return the height
{
	// We build a client rectangle to take advantage of GetViewRect routine
	// which really does all the work for us.
	RECTUV rcClient;
	rcClient.left = 0;
	rcClient.top = 0;
	rcClient.right = dup;
	rcClient.bottom = dvp;

	// Take into account inset and selection bar. The parameters here are a bit
	// of a trick. The second parameter gets copied into the first and since
	// we don't need the original client rect we save a rect off the stack.
	GetViewRect(rcClient, &rcClient);
	dup = rcClient.right - rcClient.left;
	dvp = rcClient.bottom - rcClient.top;
}

/*
 *	CDisplay::SaveUpdateCaret (fScrollIntoView)
 *
 *	@mfunc	Save UpdateCaret parameter so update caret can be called
 *			after the display is thawed.
 *
 *	@rdesc	None.
 *
 *	@devnote
 *			This should only be called if IsFrozen is true.
 */
void CDisplay::SaveUpdateCaret(
	BOOL fScrollIntoView)
{
#ifdef DEBUG
	if (_padc == NULL)
	{
		TRACEERRORSZ("CDisplay::SaveUpdateCaret called on thawed display");
	}
#endif // DEBUG
	if(_padc)
		_padc->SaveUpdateCaret(fScrollIntoView);
}

/*
 *	CDisplay::SetNeedRedisplayOnThaw
 *
 *	@mfunc
 *		Automatically redisplay control on thaw
 */
void CDisplay::SetNeedRedisplayOnThaw(BOOL fNeedRedisplay)
{
	Assert (_padc);
	_padc->SetNeedRedisplayOnThaw(fNeedRedisplay);
}

/*
 *	CDisplay::Freeze
 *
 *	@mfunc
 *		Prevent any updates from occuring in the display
 */
void CDisplay::Freeze()
{
	if(NULL == _padc)
	{
		// Allocate object to keep track of changes
		_padc = new CAccumDisplayChanges();

		// We can now return because the accum object has a reference
		// or the memory allocation failed. If the memory allocation 
		// failed, This really isn't a catastrophe because all it means 
		// is that things will get displayed ugly temporarily, so we can 
		// pretend it didn't happen.
		return;
	}

	// Tell object that an additional freeze has occurred.
	_padc->AddRef();
}

/*
 *	CDisplay::Thaw()
 *
 *	@mfunc
 *		If this is the last thaw, then cause display to be updated.
 *
 */
void CDisplay::Thaw()
{
	BOOL fUpdateCaret, fScrollIntoView, fNeedRedisplay;
	LONG cp, cchNew, cchDel;
	CTxtSelection *psel;

	if(_padc)
	{
		// Release reference to accum object
		if(_padc->Release() == 0)
		{
			// Last thaw so we need to update display

			// Get the changes
			_padc->GetUpdateRegion(&cp, &cchDel, &cchNew, 
				&fUpdateCaret, &fScrollIntoView, &fNeedRedisplay);

			// Clear the object - note we do this before
			// the update just on the off chance that
			// a new freeze manages to get in during the 
			// update of the display.
			delete _padc;
			_padc = NULL;

			if(cp != CP_INFINITE)
			{
				// Display changed
				if(!_ped->fInplaceActive())
				{
					// Are not inplace active so we need to put this operation
					// off till a more appropriate time.

					InvalidateRecalc();
					_ped->TxInvalidate();
					_ped->TxUpdateWindow();
					return;
				}
				// Update display
				CRchTxtPtr rtp(_ped, cp);
				if(!UpdateView(rtp, cchDel, cchNew))
					return;							// Update failed
			}

			if (fNeedRedisplay)
				_ped->TxInvalidate();

			// Did selection request a caret update?
			if(fUpdateCaret && _ped->fInplaceActive())
			{
				psel = _ped->GetSel();
				psel->UpdateCaret(fScrollIntoView);
			}
		}
	}
}

/*
 *	CDisplay::IsPrinter
 *
 *	@mfunc
 *		Returns whether this is a printer
 *
 *	@rdesc
 *		TRUE - is a display to a printer
 *		FALSE - is not a display to a printer
 *
 *	@devnote
 *		No display except a display	CDisplayPrinter should
 *		ever have a chance to return TRUE to this function.
 */
BOOL CDisplay::IsPrinter() const
{
	return FALSE;
}

/*
 *	CDisplay::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDisplay::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CDisplay::Zombie");

}

/*
 *	CDisplay::IsUScrollEnabled ()
 *
 *	@mfunc
 *		Return whether horizontal scroll bar is enabled
 *
 *	@rdesc
 *		TRUE - yes
 *		FALSE - no
 *
 *	@devnote
 *		The reason for this routine is that _fUScrollEnabled means
 *		to scroll text and can be set even if there is no scroll
 *		bar. Therefore, we need to look at the host properties
 *		as well to tell use whether this means there are scroll
 *		bars.
 */
BOOL CDisplay::IsUScrollEnabled()	  
{
	return _fUScrollEnabled && ((_ped->TxGetScrollBars() & WS_HSCROLL) != 0);
}

/*
 *	CDisplayML::GetPage(piPage, dwFlags, pcrg)
 *
 *	@mfunc
 *		Get page number for first visible line
 *
 *	@rdesc
 *		HRESULT = E_FAIL
 */						     
HRESULT CDisplay::GetPage(
	LONG *piPage,		//@parm Out parm for page number
	DWORD dwFlags, 		//@parm Flags for which page to use
	CHARRANGE *pcrg)	//@parm Out parm for CHARRANGE for page
{
	return E_FAIL;
}

/*
 *	CDisplay::SetPage(iPage)
 *
 *	@mfunc
 *		Set page number for _iliFirstVisible
 */						     
HRESULT CDisplay::SetPage (
	LONG iPage)
{
	return E_FAIL;
}

/*
 *	CDisplay::Paginate(ili)
 *
 *	@mfunc
 *		Recompute page breaks from iLineFirst on
 *
 *	@rdesc
 *		TRUE if success
 */						     
BOOL CDisplay::Paginate (
	LONG ili,					//@parm Line to redo pagination from
	BOOL fRebindFirstVisible)	//@parm If TRUE, call RebindFirstVisible()
{
	return FALSE;		// Only ML displays can paginate
}

/*
 *	CDisplay::PointFromPointuv(pt, ptuv)
 *
 *	@mfunc
 *		convert a pointuv to a point.
 *		fExtTextOutBug is to work around a display bug in Windows. This might not happen
 *		on all platforms...
 *
 */						     
void CDisplay::PointFromPointuv(POINT &pt, const POINTUV &ptuv, BOOL fExtTextOut) const
{
	TFLOW tflow = GetTflow();
	if (tflow == tflowES)
	{
		memcpy(&pt, &ptuv, sizeof(pt));
		return;
	}

	long dupClient, dvpClient;
	GetCachedSize(&dupClient, &dvpClient);

	switch(tflow)
	{
	case tflowSW:
		pt.x = dvpClient - ptuv.v - 1;
		pt.y = ptuv.u;
		break;

	case tflowWN:
		pt.x = dupClient - ptuv.u - 1;
		pt.y = dvpClient - ptuv.v - 1;
		break;

	case tflowNE:
		pt.x = ptuv.v + fExtTextOut ? 1 : 0;
		pt.y = dupClient - ptuv.u - 1;
		break;
	}
}

/*
 *	CDisplay::PointuvFromPoint(ptuv, pt)
 *
 *	@mfunc
 *		convert a point to a pointuv.
 *
 */						     
void CDisplay::PointuvFromPoint(POINTUV &ptuv, const POINT &pt) const
{
	TFLOW tflow = GetTflow();
	if (tflow == tflowES)
	{
		memcpy(&ptuv, &pt, sizeof(pt));
		return;
	}

	long dupClient, dvpClient;
	GetCachedSize(&dupClient, &dvpClient);

	switch(tflow)
	{
	case tflowSW:
		ptuv.u = pt.y;
		ptuv.v = dvpClient - pt.x - 1;
		break;

	case tflowWN:
		ptuv.u = dupClient - pt.x - 1;
		ptuv.v = dvpClient - pt.y - 1;
		break;

	case tflowNE:
		ptuv.u = dupClient - pt.y - 1;
		ptuv.v = pt.x;
		break;
	}
}

/*
 *	CDisplay::RectFromRectuv(rc, rcuv)
 *
 *	@mfunc
 *		convert a RECT from a RECTUV.
 *
 */						     
void CDisplay::RectFromRectuv(RECT& rc, const RECTUV& rcuv) const
{
	TFLOW tflow = GetTflow();
	if (tflow == tflowES)
	{
		memcpy(&rc, &rcuv, sizeof(rcuv));
		return;
	}

	long dvp = rcuv.bottom - rcuv.top;
	long dup = rcuv.right - rcuv.left;

	long dupClient, dvpClient;
	GetCachedSize(&dupClient, &dvpClient);

	switch(tflow)
	{
	case tflowSW:
		rc.left = dvpClient - rcuv.bottom;
		rc.top = rcuv.left;
		rc.right = rc.left + dvp;
		rc.bottom = rc.top + dup;
		break;

	case tflowWN:
		rc.right = dupClient - rcuv.left;
		rc.bottom = dvpClient - rcuv.top;
		rc.left = rc.right - dup;
		rc.top = rc.bottom - dvp;
		break;

	case tflowNE:
		rc.left = rcuv.top;
		rc.top = dupClient - rcuv.right;
		rc.right = rc.left + dvp;
		rc.bottom = rc.top + dup;
		break;
	}
}

/*
 *	CDisplay::RectFromRectuv(rc, rcuv)
 *
 *	@mfunc
 *		convert a RECTUV from a RECT.
 *
 */						     
void CDisplay::RectuvFromRect(RECTUV &rcuv, const RECT& rc) const
{
	TFLOW tflow = GetTflow();
	if (tflow == tflowES)
	{
		memcpy(&rcuv, &rc, sizeof(rcuv));
		return;
	}

	long dyp = rc.bottom - rc.top;
	long dxp = rc.right - rc.left;

	long dupClient, dvpClient;
	GetCachedSize(&dupClient, &dvpClient);

 	switch(tflow)
	{
	case tflowSW:
		rcuv.left = rc.top;
		rcuv.top = dvpClient - rc.right;
		rcuv.right = rcuv.left + dyp;
		rcuv.bottom = rcuv.top + dxp;
		break;

	case tflowWN:
		rcuv.left = dupClient - rc.right;
		rcuv.top = dvpClient - rc.bottom;
		rcuv.right = rcuv.left + dxp;
		rcuv.bottom = rcuv.top + dyp;
		break;

	case tflowNE:
		rcuv.left = dupClient - rc.bottom;
		rcuv.top = rc.left;
		rcuv.right = rcuv.left + dyp;
		rcuv.bottom = rcuv.top + dxp;
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\doc.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module DOC.C	CTxtStory and CTxtArray implementation |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini	<nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		6/25/95	alexgo	Cleanup and reorganization
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_doc.h"
#include "_format.h"

ASSERTDATA

// ===========================  Invariant stuff  ======================

#define DEBUG_CLASSNAME CTxtArray
#include "_invar.h"

// ========================  CTxtArray class  =========================

#ifdef DEBUG

/*
 *	CTxtArray::Invariant
 *
 *	@mfunc	Tests CTxtArray's state
 *
 *	@rdesc	Returns TRUE always; failures are indicated by Asserts
 *			Actually in this routine, we return count of chars in blocks
 *			since we need this value for one check.
 */
BOOL CTxtArray::Invariant() const
{
	static LONG	numTests = 0;
	numTests++;				// How many times we've been called.

	LONG cch = 0;
	LONG iMax = Count();

	if(iMax > 0)
	{
		CTxtBlk *ptb = Elem(0);

		// ptb shouldn't be NULL since we're within Count elements
		Assert(ptb);

		for(LONG i = 0; i < iMax; i++, ptb++)
		{
			LONG cchCurr = ptb->_cch;
			cch += cchCurr;
			
			Assert ( cchCurr >= 0 );
			Assert ( cchCurr <= CchOfCb(ptb->_cbBlock) );

			// While we're here, check range of interblock gaps
			Assert (ptb->_ibGap >= 0);
			Assert (ptb->_ibGap <= ptb->_cbBlock);

			LONG cchGap = CchOfCb(ptb->_ibGap);
			Assert ( cchGap >= 0 );
			Assert ( cchGap <= cchCurr );
		}
	}
	return cch;
}

#endif	// DEBUG

/*
 *	CTxtArray::CTxtArray()
 *	
 *	@mfunc		Text array constructor
 */
CTxtArray::CTxtArray() : CArray<CTxtBlk> ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::CTxtArray()");

	AssertSz(CchOfCb(cbBlockMost) - cchGapInitial >= cchBlkInitmGapI * 2, 
		"cchBlockMax - cchGapInitial must be at least (cchBlockInitial - cchGapInitial) * 2");

	Assert(!_cchText && !_iCF && !_iPF);
	// Make sure we have no data to initialize
	Assert(sizeof(CTxtArray) == sizeof(CArray<CTxtBlk>) + sizeof(_cchText) + 2*sizeof(_iCF));
}

/*
 *	CTxtArray::~CTxtArray
 *	
 *	@mfunc		Text array destructor
 */
CTxtArray::~CTxtArray()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::~CTxtArray");

	for(LONG itb = Count(); itb--; )
	{
		CTxtBlk *ptb = Elem(itb);
		if(ptb)
			ptb->FreeBlock();
		else
			AssertSz(FALSE, "CTxtArray::~CTxtArray: NULL block ptr");
	}
}

/*
 *	CTxtArray::CalcTextLength()
 *	
 *	@mfunc		Computes and return length of text in this text array
 *
 *	@rdesc		Count of character in this text array
 *
 *	@devnote	This call may be computationally expensive; we have to
 *				sum up the character sizes of all of the text blocks in
 *				the array.
 */
LONG CTxtArray::CalcTextLength() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::GetCch");

	_TEST_INVARIANT_
		
	LONG	 itb = Count();
	CTxtBlk *ptb = Elem(0);

	if(!itb || !ptb)
		return 0;

	for(LONG cch = 0; itb--; ptb++) 
		cch += ptb->_cch;

	return cch;
}

/*
 *	CTxtArray::AddBlock(itbNew, cb)
 *	
 *	@mfunc		create new text block
 *	
 *	@rdesc
 *		FALSE if block could not be added
 *		non-FALSE otherwise
 *	
 *	@comm 
 *	Side Effects:  
 *		moves text block array
 */
BOOL CTxtArray::AddBlock(
	LONG	itbNew,		//@parm	index of the new block 
	LONG	cb)			//@parm size of new block; if <lt>= 0, default is used
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::AddBlock");

	_TEST_INVARIANT_

	if(cb <= 0)
		cb = cbBlockInitial;

	AssertSz(cb > 0, "CTxtArray::AddBlock() - adding block of size zero");
	AssertSz(cb <= cbBlockMost, "CTxtArray::AddBlock() - block too big");

	CTxtBlk *ptb = Insert(itbNew, 1);
	if(!ptb || !ptb->InitBlock(cb))
	{	
		TRACEERRSZSC("TXTARRAT::AddBlock() - unable to allocate new block", E_OUTOFMEMORY);
		return FALSE;
	}
	return TRUE;
}

/*
 *	CTxtArray::SplitBlock(itb, ichSplit, cchFirst, cchLast, fStreaming)
 *	
 *	@mfunc		split a text block into two
 *	
 *	@rdesc
 *		FALSE if the block could not be split <nl>
 *		non-FALSE otherwise
 *	
 *	@comm
 *	Side Effects: <nl>
 *		moves text block array
 */
BOOL CTxtArray::SplitBlock(
	LONG itb, 			//@parm	index of the block to split
	LONG ichSplit,	 	//@parm	character index within block at which to split
	LONG cchFirst, 		//@parm desired extra space in first block
	LONG cchLast, 		//@parm desired extra space in new block
	BOOL fStreaming)	//@parm TRUE if streaming in new text
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::SplitBlock");

	_TEST_INVARIANT_

	AssertSz(ichSplit > 0 || cchFirst > 0, 
		"CTxtArray::SplitBlock(): splitting at beginning, but not adding anything");
	AssertSz(itb >= 0, "CTxtArray::SplitBlock(): negative itb");

	// Compute size for first half
	AssertSz(cchFirst + ichSplit <= CchOfCb(cbBlockMost),
		"CTxtArray::SplitBlock(): first size too large");
	cchFirst += ichSplit + cchGapInitial;
	cchFirst = min(cchFirst, CchOfCb(cbBlockMost));

	// Compute size for second half
	CTxtBlk *ptb = Elem(itb);
	if(!ptb)
	{
		AssertSz(FALSE, "CTxtArray::SplitBlock: NULL block ptr");
		return FALSE;
	}
	AssertSz(cchLast + ptb->_cch - ichSplit <= CchOfCb(cbBlockMost),
		"CTxtArray::SplitBlock(): second size too large");
	cchLast += ptb->_cch - ichSplit + cchGapInitial;
	cchLast = min(cchLast, CchOfCb(cbBlockMost));

	// Allocate second block and move text to it
	
	// If streaming in, allocate a block that's as big as possible so that
	// subsequent additions of text are faster. We always fall back to
	// smaller allocations so this won't cause unnecessary errors. When
	// we're done streaming we compress blocks, so this won't leave	a
	// big empty gap.  NOTE: ***** moves rgtb *****
	if(fStreaming)
	{
		LONG cb = cbBlockMost;
		const LONG cbMin = CbOfCch(cchLast);

		while(cb >= cbMin && !AddBlock(itb + 1, cb))
			cb -= cbBlockCombine;
		if(cb >= cbMin)
			goto got_block;
	}
	if(!AddBlock(itb + 1, CbOfCch(cchLast)))
	{
		TRACEERRSZSC("CTxtArray::SplitBlock(): unabled to add new block", E_FAIL);
		return FALSE;
	}

got_block:
	LPBYTE	 pbSrc;
	LPBYTE	 pbDst;
	CTxtBlk *ptb1 = Elem(itb+1);

	ptb = Elem(itb);	// Recompute ptb and ptb1 after rgtb moves
	if(!ptb || !ptb1)
	{
		AssertSz(FALSE, "CTxtArray::SplitBlock: NULL block ptr");
		return FALSE;
	}
	ptb1->_cch = ptb->_cch - ichSplit;
	ptb1->_ibGap = 0;
	pbDst = (LPBYTE) (ptb1->_pch - ptb1->_cch) + ptb1->_cbBlock;
	ptb->MoveGap(ptb->_cch); // make sure pch points to a continuous block of all text in ptb.
	pbSrc = (LPBYTE) (ptb->_pch + ichSplit);
	CopyMemory(pbDst, pbSrc, CbOfCch(ptb1->_cch));
	ptb->_cch = ichSplit;
	ptb->_ibGap = CbOfCch(ichSplit);

	// Resize first block
	if(CbOfCch(cchFirst) != ptb->_cbBlock)
	{
//$ FUTURE: don't resize unless growing or shrinking considerably
		if(!ptb->ResizeBlock(CbOfCch(cchFirst)))
		{
			TRACEERRSZSC("TXTARRA::SplitBlock(): unabled to resize block", E_OUTOFMEMORY);
			return FALSE;
		}
	}
	return TRUE;
}

/*
 *	CTxtArray::ShrinkBlocks()
 *	
 *	@mfunc		Shrink all blocks to their minimal size
 */
void CTxtArray::ShrinkBlocks()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::ShrinkBlocks");

	_TEST_INVARIANT_

	for(LONG itb = Count(); itb--; )
	{
		CTxtBlk *ptb = Elem(itb);
		if(ptb)
			ptb->ResizeBlock(CbOfCch(ptb->_cch));
		else
			AssertSz(FALSE, "CTxtArray::ShrinkBlocks: NULL block ptr");
	}
}

/*
 *	CTxtArray::RemoveBlocks(itbFirst, ctbDel)
 *	
 *	@mfunc		remove a range of text blocks
 *	
 *	@comm Side Effects: <nl>
 *		moves text block array
 */
void CTxtArray::RemoveBlocks(
	LONG itbFirst, 		//@parm Index of first block to remove
	LONG ctbDel)		//@parm	Count of blocks to remove
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::RemoveBlocks");

	_TEST_INVARIANT_

	LONG itb = itbFirst;

	AssertSz(itb + ctbDel <= Count(), "CTxtArray::RemoveBlocks(): not enough blocks");

	for(LONG ctb = ctbDel; ctb--; itb++)
	{
		CTxtBlk *ptb = Elem(itb);
		if(ptb)
			ptb->FreeBlock();
		else
			AssertSz(FALSE, "CTxtArray::RemoveBlocks: NULL block ptr");
	}
	Remove(itbFirst, ctbDel);
}

/*
 *	CTxtArray::CombineBlocks(itb)
 *	
 *	@mfunc		combine adjacent text blocks
 *	
 *	@rdesc
 *		nothing
 *	
 *	@comm 
 *	Side Effects: <nl>
 *		moves text block array
 *	
 *	@devnote
 *		scans blocks from itb - 1 through itb + 1 trying to combine
 *		adjacent blocks
 */
void CTxtArray::CombineBlocks(
	LONG itb)		//@parm	index of the first block modified
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::CombineBlocks");

	_TEST_INVARIANT_

	LONG ctb;
	LONG cbT;
	CTxtBlk *ptb, *ptb1;

	if(itb > 0)
		itb--;

	ctb = min(3, Count() - itb);
	if(ctb <= 1)
		return;

	for(; ctb > 1; ctb--)
	{
		ptb  = Elem(itb);							// Can we combine current
		ptb1 = Elem(itb+1);							//  and next blocks ?
		cbT = CbOfCch(ptb->_cch + ptb1->_cch + cchGapInitial);
		if(cbT <= cbBlockInitial)
		{											// Yes
			if(cbT != ptb->_cbBlock && !ptb->ResizeBlock(cbT))
				continue;
			ptb ->MoveGap(ptb->_cch);				// Move gaps at ends of
			ptb1->MoveGap(ptb1->_cch);				//  both blocks
			CopyMemory(ptb->_pch + ptb->_cch,		// Copy next block text
				ptb1->_pch,	CbOfCch(ptb1->_cch));	//  into current block
			ptb->_cch += ptb1->_cch;
			ptb->_ibGap += CbOfCch(ptb1->_cch);
			RemoveBlocks(itb+1, 1);					// Remove next block
		}
		else
			itb++;
	}
}

/*
 *	CTxtArray::GetChunk(ppch, cch, pchChunk, cchCopy)
 *	
 *	@mfunc
 *		Get content of text chunk in this text array into a string	
 *	
 *	@rdesc
 *		remaining count of characters to get
 */
LONG CTxtArray::GetChunk(
	TCHAR **ppch, 			//@parm ptr to ptr to buffer to copy text chunk into
	LONG cch, 				//@parm length of pch buffer
	TCHAR *pchChunk, 		//@parm ptr to text chunk
	LONG cchCopy) const	//@parm count of characters in chunk
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::GetChunk");

	_TEST_INVARIANT_

	if(cch > 0 && cchCopy > 0)
	{
		if(cch < cchCopy)
			cchCopy = cch;						// Copy less than full chunk
		CopyMemory(*ppch, pchChunk, cchCopy*sizeof(TCHAR));
		*ppch	+= cchCopy;						// Adjust target buffer ptr
		cch		-= cchCopy;						// Fewer chars to copy
	}
	return cch;									// Remaining count to copy
}

const CCharFormat* CTxtArray::GetCharFormat(LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtArray::GetCharFormat");

	const CCharFormat *	pCF;
	
	if(iCF < 0)
		iCF = _iCF;
	Assert(iCF >= 0);

	if(FAILED(GetCharFormatCache()->Deref(iCF, &pCF)))
	{
		AssertSz(FALSE, "CTxtArray::GetCharFormat: couldn't deref iCF");
		pCF = NULL;
	}
	return pCF;
}

const CParaFormat* CTxtArray::GetParaFormat(LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtArray::GetParaFormat");

	const CParaFormat *	pPF;
	
	if(iPF < 0)
		iPF = _iPF;
	Assert(iPF >= 0);

	if(FAILED(GetParaFormatCache()->Deref(iPF, &pPF)))
	{
		AssertSz(FALSE, "CTxtArray::GetParaFormat: couldn't deref iPF");
		pPF = NULL;
	}
	return pPF;
}


// ========================  CTxtBlk class  =================================
/*
 *	CTxtBlk::InitBlock(cb)
 *	
 *	@mfunc
 *		Initialize this text block
 *
 *	@rdesc
 *		TRUE if success, FALSE if allocation failed
 */
BOOL CTxtBlk::InitBlock(
	LONG cb)			//@parm	initial size of the text block
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::InitBlock");

	_pch	= NULL;
	_cch	= 0;
	_ibGap	= 0;
	_cbBlock= cb;

	if(cb)
		_pch = (TCHAR*)PvAlloc(cb, GMEM_ZEROINIT);
	return _pch != 0;
}

/*
 *	CTxtBlk::FreeBlock()
 *	
 *	@mfunc
 *		Free this text block
 */
void CTxtBlk::FreeBlock()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::FreeBlock");

	FreePv(_pch);
	_pch	= NULL;
	_cch	= 0;
	_ibGap	= 0;
	_cbBlock= 0;
}

/*
 *	CTxtBlk::MoveGap(ichGap)
 *	
 *	@mfunc
 *		move gap in this text block
 */
void CTxtBlk::MoveGap(
	LONG ichGap)			//@parm	new position for the gap
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::MoveGap");

	LONG cbMove;
	LONG ibGapNew = CbOfCch(ichGap);
	LPBYTE pbFrom = (LPBYTE) _pch;
	LPBYTE pbTo;

	if(ibGapNew == _ibGap)
		return;

	if(ibGapNew < _ibGap)
	{
		cbMove = _ibGap - ibGapNew;
		pbFrom += ibGapNew;
		pbTo = pbFrom + _cbBlock - CbOfCch(_cch);
	}
	else
	{
		cbMove = ibGapNew - _ibGap;
		pbTo = pbFrom + _ibGap;
		pbFrom = pbTo + _cbBlock - CbOfCch(_cch);
	}

	MoveMemory(pbTo, pbFrom, cbMove);
	_ibGap = ibGapNew;
}


/*
 *	CTxtBlk::ResizeBlock(cbNew)
 *	
 *	@mfunc
 *		resize this text block
 *	
 *	@rdesc	
 *		FALSE if block could not be resized <nl>
 *		non-FALSE otherwise
 *	
 *	@comm
 * 	Side Effects: <nl>
 *		moves text block
 */
BOOL CTxtBlk::ResizeBlock(
	LONG cbNew)		//@parm	the new size
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::ResizeBlock");

	TCHAR *pch;
	LONG cbMove;

	AssertSz(cbNew > 0, "resizing block to size <= 0");
	AssertSz(cbNew <= cbBlockMost, "CTxtBlk::ResizeBlock() - block too big");

	if(cbNew < _cbBlock)
	{
		if(_ibGap != CbOfCch(_cch))
		{
			// move text after gap down so that it doesn't get dropped

			cbMove = CbOfCch(_cch) - _ibGap;
			pch = _pch + CchOfCb(_cbBlock - cbMove);
			MoveMemory(pch - CchOfCb(_cbBlock - cbNew), pch, cbMove);
		}
		_cbBlock = cbNew;
	}
	pch = (TCHAR*)PvReAlloc(_pch, cbNew);
	if(!pch)
		return _cbBlock == cbNew;	// FALSE if grow, TRUE if shrink

	_pch = pch;
	if(cbNew > _cbBlock)
	{
		if(_ibGap != CbOfCch(_cch))		// Move text after gap to end so that
		{								// we don't end up with two gaps
			cbMove = CbOfCch(_cch) - _ibGap;
			pch += CchOfCb(_cbBlock - cbMove);
			MoveMemory(pch + CchOfCb(cbNew - _cbBlock), pch, cbMove);
		}
		_cbBlock = cbNew;
	}
	return TRUE;
}


// ========================  CTxtStory class  ============================
/* 
 *	CTxtStory::CTxtStory
 *
 *	@mfunc	Constructor
 *
 *	@devnote	Automatically allocates a text array.  If we want to have a
 *	completely empty edit control, then don't allocate a story.  NB!
 *	
 */
CTxtStory::CTxtStory()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::CTxtStory");

	_pCFRuns = NULL;
	_pPFRuns = NULL;
}

/*
 *	CTxtStory::~CTxtStory
 *
 *	@mfunc	Destructor
 */
CTxtStory::~CTxtStory()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::~CTxtStory");

	// Remove formatting.
	DeleteFormatRuns();
}

/*
 *	DeleteRuns ()
 *
 *	@mfunc
 *		Helper function for DeleteFormatRuns() below.  Releases
 *		formats used by format run collection before deleting the
 *		collection
 */
void DeleteRuns(CFormatRuns *pRuns, IFormatCache *pf)
{
    if(pRuns)									// Format runs may exist
	{
		LONG n = pRuns->Count();
		if(n)
		{
			CFormatRun *pRun = pRuns->Elem(0);
			for( ; n--; pRun++)
				pf->Release(pRun->_iFormat);	// Free run's format
		}
        delete pRuns;
	}	
}

/*
 *	CTxtStory::DeleteFormatRuns ()
 *
 *	@mfunc	Convert to plain - remove format runs
 */
void CTxtStory::DeleteFormatRuns()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::ConvertToPlain");

	DeleteRuns(_pCFRuns, GetCharFormatCache());
	DeleteRuns(_pPFRuns, GetParaFormatCache());

	_pCFRuns = NULL;
	_pPFRuns = NULL;
}


#ifdef DEBUG
//This dumps the contents of the CTxtStory
//TxtBlk & FormatRun arrays to the debug output.
void CTxtStory::DbgDumpStory(void)
{
	CTxtBlk * pblk;
	CFormatRun * pcfr;
	CFormatRun * ppfr;
	LONG ctxtr = 0;
	LONG ccfr = 0;
	LONG cpfr = 0;
	LONG i;

	ctxtr = _TxtArray.Count();

	if (_pCFRuns)
		ccfr = _pCFRuns->Count();
	if (_pPFRuns)
		cpfr = _pPFRuns->Count();

	for(i = 0; i < ctxtr; i++)
	{
		pblk = (CTxtBlk*)_TxtArray.Elem(i);
		Tracef(TRCSEVNONE, "TxtBlk #%d: cch = %d.", (i + 1), pblk->_cch);
	}	

	for(i = 0; i < ccfr; i++)
	{
		pcfr = (CFormatRun*)_pCFRuns->Elem(i);
		Tracef(TRCSEVNONE, "CFR #%d: cch = %d, iFormat = %d.",(i + 1), pcfr->_cch, pcfr->_iFormat);
	}	

	for(i = 0; i < cpfr; i++)
	{
		ppfr = (CFormatRun*)_pPFRuns->Elem(i);
		Tracef(TRCSEVNONE, "PFR #%d: cch = %d, iFormat = %d.",(i + 1), ppfr->_cch, ppfr->_iFormat);
			
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\hash.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module HASH.C -- RTF control word cache |
 *		#ifdef'ed with RTF_HASHCACHE
 *		
 *	Owner: <nl>
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		8/15/95		jonmat first hash-cache for RTF using Brent's Method.
 */
#include "_common.h"

#ifdef RTF_HASHCACHE
					 
#include "hash.h"

ASSERTDATA

extern KEYWORD		rgKeyword[];			// All of the RTF control words.

#define MAX_INAME	3

typedef struct {
	const KEYWORD	*token;
	BOOL			passBit;
} HashEntry;

static HashEntry	*(hashtbl[HASHSIZE]);
static HashEntry	*storage;				// Dynamically alloc for cKeywords.

BOOL				_rtfHashInited = FALSE;

static INT			HashKeyword_Key( const CHAR *szKeyword );

/*
 *	HashKeyword_Insert()
 *	
 *	@func
 *		Insert a KEYWORD into the RTF hash table.
 *	@comm
 *		This function uses the the % for MOD
 *		in order to validate MOD257.
 */
VOID HashKeyword_Insert (
	const KEYWORD *token )//@parm pointer to KEYWORD token to insert.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Insert");

	INT			index, step, position,
				cost, source, sink, index1,
				step1, temp;
	
	BOOL		tmpPassBit;	
	
	static INT	totalKeys = 0;

	CHAR 		*szKeyword;
	
	HashEntry	*np;
	
	AssertSz ( _rtfHashInited, "forgot to call HashKeyword_Init()");
	AssertSz ( totalKeys <= HASHSIZE * 0.7, "prime not large enough to hold total keys");
	
	szKeyword = token->szKeyword;
	
	np = &storage[totalKeys++];
	np->token = token;

	index = HashKeyword_Key(szKeyword) % HASHSIZE;  // Get keys.
	step = 1 + (HashKeyword_Key(szKeyword) % (HASHSIZE-1));

	position = 1;
	cost = HASHSIZE;								// The max collisions for any.
	while(hashtbl[index]!=NULL)						// Find empty slot.
	{
		position++;									// How many collisions.

		// For the keyword stored here, calc # times before it is found.
		temp=1;
		step1= 1+(HashKeyword_Key(hashtbl[index]->token->szKeyword) % (HASHSIZE-1));
		index1= (index+step1)%HASHSIZE;
		while(hashtbl[index1] !=NULL)
		{
			index1=(index1+step1)%HASHSIZE;
			temp++;
		}
		
		// Incremental cost computation, minimizes average # of collisions
		//  for both keywords.
		if (cost>position+temp)
		{
			source=index;
			sink=index1;
			cost=position+temp;
		}
		
		// There will be something stored beyound here, set the passBit.
		hashtbl[index]->passBit=1;

		// Next index to search for empty slot.
		index=(index+step)%HASHSIZE;

	}
	
	if (position<=cost)
	{
		source=sink=index;
		cost=position;
	}
	hashtbl[sink] = hashtbl[source];
	hashtbl[source] = np;
	if (hashtbl[sink] && hashtbl[source])	// jOn hack, we didn't really
	{										//  want to swap pass bits.
		tmpPassBit = hashtbl[sink]->passBit;
		hashtbl[sink]->passBit = hashtbl[source]->passBit;
		hashtbl[source]->passBit = tmpPassBit;
	}

}

/*
 *	static HashKeyword_Key()
 *	
 *	@func
 *		Calculate the hash key.
 *	@comm
 *		Just add up the first few characters.
 *	@rdesc
 *		The hash Key for calculating the index and step.
 */
static INT HashKeyword_Key(
	const CHAR *szKeyword ) //@parm C string to create hash key for.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Key");

	INT i, tot = 0;
	
	/* Just add up first few characters. */
	for (i = 0; i < MAX_INAME && *szKeyword; szKeyword++, i++)
			tot += (UCHAR) *szKeyword;
	return tot;
}	

/*
 *	HashKeyword_Fetch()
 *	
 *	@func
 *		Look up a KEYWORD with the given szKeyword.
 *	@devnote
 *		We have a hash table of size 257. This allows for
 *		the use of very fast routines to calculate a MOD 257.
 *		This gives us a significant increase in performance
 *		over a binary search.
 *	@rdesc
 *		A pointer to the KEYWORD, or NULL if not found.
 */
const KEYWORD *HashKeyword_Fetch (
	const CHAR *szKeyword ) //@parm C string to search for.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Fetch");

	INT 		index, step;
	
	HashEntry *	hashTblPtr;

	BYTE *		pchCandidate;
	BYTE *		pchKeyword;
	
	INT			nComp;

	CHAR		firstChar;

	INT			hashKey;

	AssertSz( HASHSIZE == 257, "Remove custom MOD257.");
	
	firstChar = *szKeyword;
	hashKey = HashKeyword_Key(szKeyword);	// For calc'ing 'index' and 'step'
	
	//index = hashKey%HASHSIZE;				// First entry to search.
	index = MOD257(hashKey);				// This formula gives us 18% perf.

	hashTblPtr = hashtbl[index];			// Get first entry.
	if ( hashTblPtr != NULL )				// Something there?
	{
											// Compare 2 C strings.								
		pchCandidate = (BYTE *)hashTblPtr->token->szKeyword;
		if ( firstChar == *pchCandidate )
		{
			pchKeyword	 = (BYTE *)szKeyword;
			while (!(nComp = *pchKeyword - *pchCandidate)	// Be sure to match
				&& *pchKeyword)								//  terminating 0's
			{
				pchKeyword++;
				pchCandidate++;
			}
											// Matched?
			if ( 0 == nComp )
				return hashTblPtr->token;
		}
		
		if ( hashTblPtr->passBit==1 )		// passBit=>another entry to test
		{

			// step = 1+(hashKey%(HASHSIZE-1));// Calc 'step'
			step = 1 + MOD257_1(hashKey);

											// Get second entry to check.
			index += step;
			index = MOD257(index);
			hashTblPtr = hashtbl[index];

			while (hashTblPtr != NULL )		// While something there.
			{
											// Compare 2 C strings.								
				pchCandidate = (BYTE *)hashTblPtr->token->szKeyword;
				if ( firstChar == *pchCandidate )
				{
					pchKeyword	 = (BYTE *)szKeyword;
					while (!(nComp = *pchKeyword - *pchCandidate)
						&& *pchKeyword)
					{
						pchKeyword++;
						pchCandidate++;
					}
											// Matched?
					if ( 0 == nComp )
						return hashTblPtr->token;
				}

				if ( !hashTblPtr->passBit )// Done searching?
					break;
											// Get next entry.
				index += step;
				index = MOD257(index);
				hashTblPtr = hashtbl[index];
			}
		}
	}
	
	return NULL;
}

/*
 *	HashKeyword_Init()
 *	
 *	@func
 *		Load up and init the hash table with RTF control words.
 *	@devnote
 *		_rtfHashInited will be FALSE if anything here fails.
 */
VOID HashKeyword_Init( )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "HashKeyword_Init");

	extern SHORT cKeywords;			// How many RTF keywords we currently recognize.

	INT i;

	AssertSz( _rtfHashInited == FALSE, "Only need to init this once.");

									// Create enough storage for cKeywords
	storage = (HashEntry *) PvAlloc( sizeof(HashEntry) * cKeywords, fZeroFill );

									// Load in all of the RTF control words.
	if ( storage )
	{
		_rtfHashInited = TRUE;

		for (i = 0; i < cKeywords; i++ )
		{
			HashKeyword_Insert(&rgKeyword[i]);
		}
#ifdef DEBUG						// Make sure we can fetch all these keywords.
		for (i = 0; i < cKeywords; i++ )
		{
			AssertSz ( &rgKeyword[i] == HashKeyword_Fetch ( rgKeyword[i].szKeyword ),
				"Keyword Hash is not working.");
		}
#endif
	}
}

#endif	// RTF_HASHCACHE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\dxfrobj.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	- DXFROBJ.C |
 *
 *		implementation of a generic IDataObject data transfer object.
 *		This object is suitable for use in OLE clipboard and drag drop
 *		operations
 *
 *	Author: <nl>
 *		alexgo (4/25/95)
 *
 *	Revisions: <nl>
 *		murrays (7/13/95) auto-doc'd and added cf_RTF
 *
 *	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dxfrobj.h"
#include "_range.h"
#include "hash.h"

#define NUMOBJCOPIEDFORWAITCURSOR	1
#ifdef SLOWCPU
#define NUMCHARCOPIEDFORWAITCURSOR	4096
#else
#define NUMCHARCOPIEDFORWAITCURSOR	16384
#endif

//
//	Common Data types
//

// If you change g_rgFETC[], change g_rgDOI[] and enum FETCINDEX and CFETC in
// _dxfrobj.h accordingly, and register nonstandard clipboard formats in
// RegisterFETCs(). Order entries in order of most desirable to least, e.g.,
// RTF in front of plain text.

//REVIEW (keithcu) All but the first column is const--separate into 2 data structures?
FORMATETC g_rgFETC[] =
{
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// CF_RTFUTF8
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// cf_RTF
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with NCRs for nonASCII
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbObject
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbSource
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// ObjDesc
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// LnkSource
	{CF_METAFILEPICT,	NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT},
	{CF_DIB,			NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{CF_BITMAP,			NULL, DVASPECT_CONTENT, -1, TYMED_GDI},
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with no objs
	{CF_UNICODETEXT,	NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{CF_TEXT,			NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// Filename
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},	// CF_RTFASTEXT
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// Text with objs
	{0,					NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE} // Richedit
};

// Keep in sync with above and with FETCINDEX and CFETC
const DWORD g_rgDOI[] =
{
	DOI_CANPASTERICH,						// RTF in UTF8 encoding
	DOI_CANPASTERICH,						// RTF
	DOI_CANPASTERICH,						// RTF with NCRs for nonASCII
	DOI_CANPASTEOLE,						// Embedded Object
	DOI_CANPASTEOLE,						// Embed Source
	DOI_CANPASTEOLE,						// Object Descriptor
	DOI_CANPASTEOLE,						// Link Source
	DOI_CANPASTEOLE,						// Metafile
	DOI_CANPASTEOLE,						// DIB
	DOI_CANPASTEOLE,						// Bitmap
	DOI_CANPASTERICH,						// RTF with no objects
	DOI_CANPASTEPLAIN,						// Unicode plain text
	DOI_CANPASTEPLAIN,						// ANSI plain text
	DOI_CANPASTEOLE,						// Filename
	DOI_CANPASTEPLAIN,						// Pastes RTF as text
	DOI_CANPASTERICH,						// Richedit Text
	DOI_CANPASTERICH						// RichEdit Text w/formatting
};

/*
 *	RegisterFETCs()
 *
 *	@func
 *		Register nonstandard format ETCs.  Called when DLL is loaded
 */
void RegisterFETCs()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "RegisterFETCs");

#ifdef RTF_HASHCACHE
	HashKeyword_Init();			// Init rtf control keyword hash table.
#endif
	g_rgFETC[iRtfFETC].cfFormat	// Note: cfFormats are WORDs
			= (WORD)RegisterClipboardFormatA("Rich Text Format");

	g_rgFETC[iRtfUtf8].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF in UTF8");

	g_rgFETC[iRtfNCRforNonASCII].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF with NCRs for nonASCII");

	g_rgFETC[iRtfAsTextFETC].cfFormat
			= (WORD)RegisterClipboardFormatA("RTF As Text");

	g_rgFETC[iRichEdit].cfFormat
			= (WORD)RegisterClipboardFormatA("RICHEDIT");

	g_rgFETC[iObtDesc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_OBJECTDESCRIPTOR);

	g_rgFETC[iEmbObj].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_EMBEDDEDOBJECT);

	g_rgFETC[iEmbSrc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_EMBEDSOURCE);

	g_rgFETC[iLnkSrc].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_LINKSOURCE);

	g_rgFETC[iRtfNoObjs].cfFormat
			= (WORD)RegisterClipboardFormatA("Rich Text Format Without Objects");

	g_rgFETC[iTxtObj].cfFormat
			= (WORD)RegisterClipboardFormatA("RichEdit Text and Objects");

	g_rgFETC[iFilename].cfFormat
			= (WORD)RegisterClipboardFormatA(CF_FILENAME);
}


//
//	CDataTransferObj PUBLIC methods
//

/*
 *	CDataTransferObj::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		 QueryInterface for CDataTransferObj
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::QueryInterface (
	REFIID riid,			// @parm Reference to requested interface ID
	void ** ppv)			// @parm out parm for interface ptr
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::QueryInterface");

	if(!ppv)
		return E_INVALIDARG;

	*ppv = NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

    HRESULT		hresult = E_NOINTERFACE;

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IDataObject) ||
		IsEqualIID(riid, IID_IRichEditDO) )
	{
		*ppv = this;
		AddRef();
		hresult = NOERROR;
	}

	return hresult;
}

/*
 *	CDataTransferObj::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */
STDMETHODIMP_(ULONG) CDataTransferObj::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::AddRef");

	return ++_crefs;
}

/*
 *	CDataTransferObj::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */
STDMETHODIMP_(ULONG) CDataTransferObj::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		GlobalFree(_hPlainText);
		GlobalFree(_hRtfText);
		GlobalFree(_hRtfUtf8);
		GlobalFree(_hRtfNCRforNonASCII);
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDataTransferObj::DAdvise (pFormatetc, advf, pAdvSink, pdwConnection)
 *
 *	@mfunc
 *		establish an advisory connection
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::DAdvise(
	FORMATETC * pFormatetc,
	DWORD advf,
	IAdviseSink *pAdvSink,
	DWORD *pdwConnection)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::DAdvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::DUnadvise (dwConnection)
 *
 *	@mfunc
 *		destroy an advisory connection
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::DUnadvise(
	DWORD dwConnection)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::DUnadvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::EnumDAdvise (ppenumAdvise)
 *
 *	@mfunc
 *		enumerate advisory connections
 *
 *	@rdesc
 *		HRESULT = OLE_E_ADVISENOTSUPPORTED
 *
 *	@devnote
 *		this is a data transfer object, thus the data is a "snapshot" and
 *		cannot change -- no advises are supported.
 */
STDMETHODIMP CDataTransferObj::EnumDAdvise(
	IEnumSTATDATA ** ppenumAdvise)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::EnumDAdvise");

	return OLE_E_ADVISENOTSUPPORTED;
}

/*
 *	CDataTransferObj::EnumFormatEtc (dwDirection, ppenumFormatEtc)
 *
 *	@mfunc
 *		returns an enumerator which lists all of the available formats in
 *		this data transfer object
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		we have no 'set' formats for this object
 */
STDMETHODIMP CDataTransferObj::EnumFormatEtc(
	DWORD dwDirection,					// @parm DATADIR_GET/SET
	IEnumFORMATETC **ppenumFormatEtc)	// @parm out parm for enum FETC interface
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::EnumFormatEtc");

	if(!ppenumFormatEtc)
		return E_INVALIDARG;

	*ppenumFormatEtc = NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	HRESULT hr = NOERROR;


	#ifdef DEBUG
	if (dwDirection == DATADIR_SET && !_ped->Get10Mode())
	{
		Tracef(TRCSEVNONE, "RichEdit 2.0 EnumFormatEtc called with DATADIR_SET");
	}
	#endif

	//Need riched10 compatibility hack to ignore dwDirection
	if(dwDirection == DATADIR_GET || _ped->Get10Mode())
		hr = CEnumFormatEtc::Create(_prgFormats, _cTotal, ppenumFormatEtc);

	return hr;
}

/*
 *	CDataTransferObj::GetCanonicalFormatEtc( pformatetc, pformatetcOut)
 *
 *	@mfunc
 *		from the given formatetc, return a more standard (or canonical)
 *		format.
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL
 *
 *	@devnote
 *		(alexgo): we may need to write this routine if we ever do anything
 *		snazzy with printers
 */
STDMETHODIMP CDataTransferObj::GetCanonicalFormatEtc(
	FORMATETC *pformatetc,
	FORMATETC *pformatetcOut)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetCanonicalFormatEtc");

	return E_NOTIMPL;
}

/*
 *	CDataTransferObj::GetData (pformatetcIn, pmedium)
 *
 *	@mfunc
 *		retrieves data of the specified format
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::GetData(
	FORMATETC *pformatetcIn, 
	STGMEDIUM *pmedium )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetData");

	FillMemory(pmedium, '\0', sizeof(STGMEDIUM));
	pmedium->tymed	 = TYMED_NULL;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	CLIPFORMAT	cf = pformatetcIn->cfFormat;
	HRESULT		hr = E_OUTOFMEMORY;                     // Default not enuf RAM

	// now handle 'native' richedit formats.
	if( cf && pformatetcIn->tymed & TYMED_HGLOBAL )
	{
		if( cf == CF_UNICODETEXT )
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hPlainText, tPlain));

		else if(cf == CF_TEXT)
			pmedium->hGlobal = TextHGlobalWtoA(TextToHglobal(_hPlainText, tPlain));

		else if(cf == cf_RTF || cf == cf_RTFASTEXT || cf == cf_RTFNOOBJS)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfText, tRtf));

		else if(cf == cf_RTFUTF8)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfUtf8, tRtfUtf8));

		else if(cf == cf_RTFNCRFORNONASCII)
			pmedium->hGlobal = DuplicateHGlobal(TextToHglobal(_hRtfNCRforNonASCII, tRtfNCRforNonASCII));
			
		else
		    hr = DV_E_FORMATETC;
		
        if (hr == E_OUTOFMEMORY)
        {
    		if( pmedium->hGlobal )						// Succeeded
    		{
    			pmedium->tymed	 = TYMED_HGLOBAL;
    			hr = NOERROR;
    		}
    		return hr;
    	}
	}
	
	if ((cf == cf_EMBEDDEDOBJECT ||
		 cf == cf_EMBEDSOURCE) &&
		(pformatetcIn->tymed & TYMED_ISTORAGE))
	{
        _pObjStg = GetDataForEmbeddedObject( _pOleObj, pmedium->pstg );
		pmedium->tymed = TYMED_ISTORAGE;
		if (NULL == pmedium->pstg)
			pmedium->pstg = _pObjStg;
		hr = _pObjStg != NULL ? NOERROR : hr;
		return hr;
	} 

	// Go through richedit's formats and see if there are any matches
	if( cf == cf_OBJECTDESCRIPTOR &&
			 (pformatetcIn->tymed & TYMED_HGLOBAL) &&
			 _hObjDesc)
	{    
		pmedium->hGlobal = DuplicateHGlobal(_hObjDesc);
		pmedium->tymed = TYMED_HGLOBAL;
		return NOERROR;
	}

    // First propogate the message to the object and see if it handles the format
    if (_pOleObj)
    {
        // Include the formats supported by the object
        IDataObject * pdataobj = NULL;
        if (FAILED(_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
            _pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);
            
        if (pdataobj)
        {
            hr = pdataobj->GetData(pformatetcIn, pmedium);
            pdataobj->Release();

            if (SUCCEEDED(hr))
            {
                if ((cf == cf_EMBEDDEDOBJECT || cf == cf_EMBEDSOURCE) && _pOleObj)
                {
                    OleSaveSiteFlags(pmedium->pstg, _dwFlags, _dwUser, _dvaspect);
                }
                return S_OK;
            }
        }
    }          

	if( cf == CF_METAFILEPICT )
	{
		pmedium->hMetaFilePict = OleDuplicateData(_hMFPict, CF_METAFILEPICT, 0);
		pmedium->tymed = TYMED_MFPICT;
		return NOERROR;
	}

	if( cf == CF_DIB )
	{
		if( _ped->HasObjects() && _cch == 1 )
		{
			COleObject *pobj = _ped->_pobjmgr->GetObjectFromCp(_cpMin);
			if (pobj)
			{
				HGLOBAL hdib = pobj->GetHdata();
				if (hdib)
				{
					pmedium->hGlobal = DuplicateHGlobal(hdib);
					pmedium->tymed = TYMED_HGLOBAL;
				}
			}
		}
		return NOERROR;
	}

	return DV_E_FORMATETC;
}

/*
 *	CDataTransferObj::GetDataForEmbeddedObject (pformatetc, lpstgdest)
 *
 *	@mfunc
 *		retrieves data for embedded object
 *
 *	@rdesc
 *		LPSTORAGE
 *
 */
LPSTORAGE CDataTransferObj::GetDataForEmbeddedObject(
	LPOLEOBJECT	 pOleObj,
	LPSTORAGE	 lpstgdest)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataForEmbeddedObject");
	
	HRESULT			 hr, hr1;
	LPPERSISTSTORAGE pperstg;

	if (_pObjStg != NULL && lpstgdest != NULL)
	{
		// We saved the data previously. Copy it to destination.
		hr = _pObjStg->CopyTo(0, NULL, NULL, lpstgdest);
		if (hr == NOERROR)
		{
			lpstgdest->Commit(STGC_DEFAULT);
			return _pObjStg;
		}
		return NULL;
	}

	if (_pObjStg != NULL && lpstgdest == NULL)
	{
		// We saved the data previously.  Return a reference
		_pObjStg->AddRef();
		return _pObjStg;
	}

	// We don't have a saved copy.  Create One.
	hr = pOleObj->QueryInterface( IID_IPersistStorage, (void **) &pperstg );
	if (hr != NOERROR)
		return NULL;

	if (lpstgdest == NULL)
	{
		// It is null.  We have to create our own.
		LPLOCKBYTES lpLockBytes = NULL;
		hr = CreateILockBytesOnHGlobal(NULL, TRUE, // delete on release
									   (LPLOCKBYTES *)&lpLockBytes);
		if (hr != NOERROR)
		{
			pperstg->Release();
			return NULL;
		}
		hr = StgCreateDocfileOnILockBytes(
			lpLockBytes,
			STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			0,	// reserved
			&lpstgdest
		);
		lpLockBytes->Release();
		if (hr != NOERROR)
		{
			pperstg->Release();
			return NULL;
		}
		_pObjStg = lpstgdest;
	}
	else
	{
		// Force the data to be saved
		_pObjStg = GetDataForEmbeddedObject( _pOleObj, NULL );
		pperstg->Release();
		return GetDataForEmbeddedObject( _pOleObj, lpstgdest );
	}

    // OLE2NOTE: even if OleSave returns an error you should still call 
    // SaveCompleted.
    hr = OleSave( pperstg, lpstgdest, FALSE /* fSameAsLoad */ );
 	hr1 = pperstg->SaveCompleted(NULL);
	if (hr != NOERROR || hr1 != NOERROR)			// Should we use SUCCEED macros ????
		lpstgdest = NULL;

	pperstg->Release();
	return _pObjStg;
}

/*
 *	CDataTransferObj::GetDataorObjectDescriptor (pformatetc, pmedium)
 *
 *	@mfunc
 *		retrieves data for embedded object descriptor
 *
 *	@rdesc
 *		HRESULT
 */
HGLOBAL CDataTransferObj::GetDataForObjectDescriptor(
	LPOLEOBJECT	 pOleObj,
	DWORD		 dwAspect,
	SIZEUV*      psize)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataForObjectDescriptor");

	POINTL ptl = {0};
	SIZEUV size = {0};
	if (psize)
	{
	    size.du = psize->du;
	    size.dv = psize->dv;
	}

	if (_hObjDesc == NULL)
	{
		_hObjDesc = OleGetObjectDescriptorDataFromOleObject(
			pOleObj,
			dwAspect,
			ptl,
			(SIZEL *)&size
		);
	}
	return _hObjDesc;
}

/*
 *	CDataTransferObj::GetDataHere (pformatetc, pmedium)
 *
 *	@mfunc
 *		retrieves data of the specified format into the given medium
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL
 *
 *	@devnote (alexgo): technically, we're supposed to support transfers
 *		into hglobals, but I'd rather not at the moment.
 */
STDMETHODIMP CDataTransferObj::GetDataHere(
	FORMATETC *pformatetc, 
	STGMEDIUM *pmedium)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::GetDataHere");

	CLIPFORMAT	cf = pformatetc->cfFormat;
	HRESULT		hr = DV_E_FORMATETC;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;
	
	if( (cf == cf_EMBEDDEDOBJECT ||
		 cf == cf_EMBEDSOURCE) &&
		(pformatetc->tymed & TYMED_ISTORAGE))
	{
		// For some reason the NT4.0 and Win95 Shell
		//          ask for the EMBEDSOURCE format.
        _pObjStg = GetDataForEmbeddedObject( _pOleObj, pmedium->pstg );
		pmedium->tymed = TYMED_ISTORAGE;
		if (NULL == pmedium->pstg)
			pmedium->pstg = _pObjStg;
		hr = pmedium->pstg != NULL ? NOERROR : hr;
		return hr;
	}
	
	if( cf == cf_OBJECTDESCRIPTOR &&
			 (pformatetc->tymed & TYMED_HGLOBAL) &&
			 _hObjDesc)
	{
		pmedium->hGlobal = DuplicateHGlobal(_hObjDesc);
		pmedium->tymed = TYMED_HGLOBAL;
		return NOERROR;
	}

	// First propogate the message to the object and see if it handles the format
	if (_pOleObj)
	{
        // Include the formats supported by the object
        IDataObject * pdataobj = NULL;
        if (FAILED(_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
            _pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);
            
        if (pdataobj)
        {
            hr = pdataobj->GetData(pformatetc, pmedium);
            pdataobj->Release();
            if (hr == S_OK)
            {
                if ((cf == cf_EMBEDDEDOBJECT || cf == cf_EMBEDSOURCE) && _pOleObj)
                {
                    OleSaveSiteFlags(pmedium->pstg, _dwFlags, _dwUser, _dvaspect);
                }
                return S_OK;
            }            
        }        
	}
	return E_NOTIMPL;
}

/*
 *	CDataTransferObj::QueryGetData (pformatetc)
 *
 *	@mfunc
 *		Queries whether the given format is available in this data object
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDataTransferObj::QueryGetData(
	FORMATETC *pformatetc )		// @parm FETC to look for
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::QueryGetData");

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	DWORD	cFETC = _cTotal;

	while (cFETC--)				// Maybe faster to search from start
	{
		if( pformatetc->cfFormat == _prgFormats[cFETC].cfFormat && 
			(pformatetc->tymed & _prgFormats[cFETC].tymed) )
		{
			return NOERROR;
		}
	}

	return DV_E_FORMATETC;
}

/*
 *	CDataTransferObj::SetData (pformatetc, pmedium, fRelease)
 *
 *	@mfunc
 *		allows data to be set into this data object
 *
 *	@rdesc
 *		HRESULT = E_FAIL
 *
 *	@devnote
 *		as we are a data transfer object with a "snapshot" of data,
 *		we do not allow it to be replaced
 */
STDMETHODIMP CDataTransferObj::SetData(
	FORMATETC *pformatetc,
	STGMEDIUM *pmedium,
	BOOL fRelease)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::SetData");

	return E_FAIL;
}


/*
 *	CDataTransferObj::OnPreReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *										 cpFormatMax, pNotifyData)
 *
 *	@mfunc	implementation of ITxNotify::OnPreReplaceRange
 *			called before changes are made to the backing store
 */
void CDataTransferObj::OnPreReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::OnPreReplaceRange");

	if(CONVERT_TO_PLAIN != cp && CP_INFINITE != cp)
	{
		Assert(cpFormatMin <= cp && cpFormatMax >= cp + cchDel);
		if(cpFormatMin >= _cpMin + _cch)
			return;							// Change beyond our extent

		if(cpFormatMax <= _cpMin)
		{
			_cpMin += (cchNew - cchDel);	// Change before our extent
			return;
		}
	}

	// FUTURE (murrays): save only one master format (UTF8 RTF or better
	// CTxtStory) and generate individual ones in GetData and GetDataHere.
	_hPlainText = TextToHglobal(_hPlainText, tPlain);
	_hRtfText	= TextToHglobal(_hRtfText,	 tRtf);
	if(_ped->IsDocMoreThanLatin1Symbol())
		_hRtfUtf8 = TextToHglobal(_hRtfUtf8, tRtfUtf8);
}

/*
 *	CDataTransferObj::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin,
 *										 cpFormatMax, pNotifyData)
 *	@mfunc	implementation of ITxNotify::OnPostReplaceRange
 *			called after changes are made to the backing store
 *
 *	@comm	we use this method to keep our cp's up-to-date
 */
void CDataTransferObj::OnPostReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::OnPostReplaceRange");

	// Nothing to do
	return;
}

/*
 *	CDataTransferObj::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDataTransferObj::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CDataTransferObj::Zombie");

	_ped = NULL;
}

/*
 *	CDataTransferObj::Create(ped, prg, lStreamFormat)
 *
 *	@mfunc
 *		static function to create CDataTransferObj. Used to force users
 *		not to create this object on the stack, which would break OLE's
 *		liveness rules.
 *
 *	@rdesc
 *		new CDataTransferObj *
 */
CDataTransferObj *CDataTransferObj::Create(
	CTxtEdit *ped,			// @parm ped to which this DataObject belongs
	CTxtRange *prg,			// @parm range for the data object
	LONG lStreamFormat)		// @parm stream format to use in Rtf conversion
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::Create");

	Assert(CFETC == ARRAY_SIZE(g_rgFETC) && CFETC == ARRAY_SIZE(g_rgDOI));

	LONG			ch;
	CNotifyMgr *	pnm;
	CDataTransferObj *pdo = new CDataTransferObj(ped);

	if( !pdo )
	{
		ped->GetCallMgr()->SetOutOfMemory();
		return NULL;
	}

	LONG cpMin, cpMost;
	pdo->_cch = prg->GetRange(cpMin, cpMost);
	pdo->_cpMin = cpMin;

	pdo->_lStreamFormat = lStreamFormat;

	pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add( (ITxNotify *) pdo );

	//Set the object count.
	pdo->_cObjs = 0;
	if( ped->HasObjects() )
		pdo->_cObjs = ped->_pobjmgr->CountObjectsInRange(cpMin, cpMost);

	int cTotal = !ped->IsRich() ? 2 :
				 ped->IsDocMoreThanLatin1Symbol() ? 7 : 5;

   	int cExtraFmtEtc = 0;
	COleObject *pobj = NULL;
	FORMATETC rgfetc[255];
	BOOL bValidOleObj = FALSE;

	// We only support 2 formats in the play text case
    if ( !ped->IsRich() )
    {        
        pdo->_cTotal = cTotal;
        pdo->_prgFormats = new FORMATETC[cTotal];
        if (!pdo->_prgFormats)
            goto ErrorExit;
            
		// Plain-text case
		pdo->_prgFormats[0] = g_rgFETC[iAnsiFETC];
		pdo->_prgFormats[1] = g_rgFETC[iUnicodeFETC];
		return pdo;
	}

    // We need to count the number of supported formats
	if (ped->HasObjects() && pdo->_cch == 1 && prg->GetChar(&ch) == NOERROR && ch == WCH_EMBEDDING)
	{
	    pobj = ped->_pobjmgr->GetObjectFromCp(pdo->_cpMin);
	    pdo->_dwFlags = pobj->GetFlags();
        pdo->_dwUser = pobj->GetUser();
        pdo->_dvaspect =pobj->GetAspect();
	    IUnknown * punk = pobj->GetIUnknown();

	    //  We want to query IOleObject on which formats it supports.  And add that to the
	    // FORMATETC array.
	    if (punk &&	punk->QueryInterface(IID_IOleObject,(void **) &pdo->_pOleObj) == NOERROR)
	   	{
	   	    bValidOleObj = TRUE;
	   	    
	        // Include the formats supported by the object
			IDataObject * pdataobj = NULL;
	        if (FAILED(pdo->_pOleObj->GetClipboardData(0, &pdataobj)) || pdataobj == NULL)    	        	            
                pdo->_pOleObj->QueryInterface(IID_IDataObject, (void**) &pdataobj);

            if (pdataobj)
            {
	            IEnumFORMATETC *pifetc = NULL;

	            // 1.0 didn't check the return value of EnumFormatEtc.  This is important because ccMail 
	            // will return an OLE error although it actually succeeds in setting the formatetc
	            if ((SUCCEEDED(pdataobj->EnumFormatEtc( DATADIR_GET, &pifetc)) || ped->Get10Mode()) && pifetc)
	            {
	                AssertSz(pifetc, "IEnumFormatEtc is NULL");
	                
	                // Copy the formats which are supported by the object
	                while((pifetc->Next(1, &rgfetc[cExtraFmtEtc], NULL)) == S_OK && cExtraFmtEtc < 255)
	                    cExtraFmtEtc++;	                
	                pifetc->Release();
	            }
	            pdataobj->Release();
            }
	    }
	}

    pdo->_cTotal = cTotal + cExtraFmtEtc;
	pdo->_prgFormats = new FORMATETC[pdo->_cTotal];
	if (!pdo->_prgFormats) 
	    goto ErrorExit;

    if (pobj)
    {
    	// copy over formats supported by the object itself
    	if (cExtraFmtEtc)
    	    memcpy(pdo->_prgFormats, rgfetc, cExtraFmtEtc * sizeof(FORMATETC));

        // copy formats supported by Richedit as a container
    	// Have an OLE object: offer all OLE formats plus RTF
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iEmbObj];	// EmbeddedObject
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iObtDesc];	// ObjectDescriptor
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iMfPict];	// Metafile
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfFETC];	// RTF 
    	pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfNoObjs];	// RTF with no objects
	}
	else
	{
        // Regular rich-text case
    	pdo->_prgFormats[0] = g_rgFETC[iRtfFETC];		// RTF
    	pdo->_prgFormats[1] = g_rgFETC[iRtfNoObjs];		// RTF with no objects
    	pdo->_prgFormats[2] = g_rgFETC[iRtfAsTextFETC];	// RTF as Text
    	pdo->_prgFormats[3] = g_rgFETC[iAnsiFETC];		// ANSI plain text
    	pdo->_prgFormats[4] = g_rgFETC[iUnicodeFETC];	// Unicode plain text
    	cExtraFmtEtc = 5;
	}


	// We only offer up the six formats that we know how to handle in GetData.
	// The actual values differ somewhat from regular rich text and text
	// with embedded objects
    if (cTotal == 7)
    {
        pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfUtf8];	// RTF in UTF-8
        pdo->_prgFormats[cExtraFmtEtc++] = g_rgFETC[iRtfNCRforNonASCII];
    }

    // Get the embedded object formats now
    if (bValidOleObj)
    {
        SIZEUV size;
        pobj->GetSize(size);        
        pdo->_hObjDesc = pdo->GetDataForObjectDescriptor( pdo->_pOleObj, pobj->GetDvaspect(), &size);
		pdo->_pObjStg = pdo->GetDataForEmbeddedObject( pdo->_pOleObj, NULL );
		pdo->_hMFPict = (HMETAFILE) OleStdGetMetafilePictFromOleObject(	pdo->_pOleObj, 
		                                pobj->GetDvaspect(), NULL, NULL);
    }

    return pdo;

ErrorExit:	
    
	pdo->_cTotal = 0;
	pdo->Release();
	ped->GetCallMgr()->SetOutOfMemory();
	return NULL;
}

/*
 *	CDataTransferObj::TextToHglobal(hText, tKind)
 *
 *	@mfunc
 *		Instantiates text on demand for the data object.
 *
 *	@rdesc
 *		HGLOBAL
 */
HGLOBAL CDataTransferObj::TextToHglobal(
	HGLOBAL &hText,
	TEXTKIND tKind)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::PlainTextToHglobal");

	if (hText == NULL)
	{
		CTxtRange rg(_ped, _cpMin, -_cch);
		if (tKind == tPlain)
		{
			hText = _ped->GetDTE()->UnicodePlainTextFromRange(&rg);
		}
		else if(_ped->IsRich())
		{
			LONG lStreamFormat = _lStreamFormat;
			if(tKind == tRtfUtf8)
				lStreamFormat = LOWORD(lStreamFormat) | SF_USECODEPAGE | (CP_UTF8 << 16);

			else if(tKind == tRtfNCRforNonASCII)
				lStreamFormat |= SF_NCRFORNONASCII;

			hText = _ped->GetDTE()->RtfFromRange(&rg, lStreamFormat);
		}
	}
	return hText;	
}

//
//	CDataTransferObj PRIVATE methods
//

/*
 *	CDataTransferObj::CDataTransferObj()
 *
 *	@mfunc
 *		Private constructor
 */

CDataTransferObj::CDataTransferObj( CTxtEdit *ped )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::CDataTransferObj");

	_ped = ped;
	_crefs = 1;
	_cTotal = CFETC;
	_prgFormats = g_rgFETC;
	_cch = 0;
	_cObjs = 0;
}

/*
 *	CDataTransferObj::~CDataTransferObj
 *
 *	@mfunc
 *		Private destructor
 */
CDataTransferObj::~CDataTransferObj()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDataTransferObj::~CDataTransferObj");

	// No need to monitor notifications any more
	CNotifyMgr *pnm;

	if(_ped)
	{
		pnm = _ped->GetNotifyMgr();
		if(pnm)
			pnm->Remove( (ITxNotify *)this );
	}

	if( _prgFormats && _prgFormats != g_rgFETC)
		delete _prgFormats;

	if (_pOleObj)
		_pOleObj->Release();

	if (_pObjStg)
		_pObjStg->Release();

#ifndef NOMETAFILES
	if (_hMFPict)
		(void) DeleteMetaFile(_hMFPict);
#endif

	GlobalFree(_hObjDesc);
}		

//
//	CEnumFormatEtc PUBLIC methods
//

/*
 *	CEnumFormatEtc::QueryInterface (riid, ppvObj)
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface(
	REFIID riid,			// @parm Reference to requested interface ID
	void ** ppv)			// @parm out parm for interface ptr
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::QueryInterface");

    HRESULT		hresult = E_NOINTERFACE;

	*ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumFORMATETC) )
    {
        *ppv = this;
        AddRef();
        hresult = NOERROR;
    }
    return hresult;
}

/*
 *	CEnumFormatEtc::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef( )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::AddRef");

 	return ++_crefs;
}

/*
 *	CEnumFormatEtc::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release( )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CEnumFormatEtc::Next (celt, rgelt, pceltFetched)
 *
 *	@mfunc
 *		fetches the next [celt] elements in our formatetc collection
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Next( ULONG celt, FORMATETC *rgelt,
        ULONG *pceltFetched)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Next");

    HRESULT		hresult = NOERROR;
    ULONG		cFetched;

	if( pceltFetched == NULL && celt != 1 )
    {
        // the spec says that if pceltFetched == NULL, then
        // the count of elements to fetch must be 1
        return E_INVALIDARG;
    }

    // we can only grab as many elements as there are left

    if( celt > _cTotal - _iCurrent )
    {
        cFetched = _cTotal - _iCurrent;
        hresult = S_FALSE;
    }
    else
        cFetched = celt;

    // Only copy if we have elements to copy

    if( cFetched > 0 )
    {
        memcpy( rgelt, _prgFormats + _iCurrent,
            cFetched * sizeof(FORMATETC) );
    }

    _iCurrent += cFetched;

    if( pceltFetched )
        *pceltFetched = cFetched;

    return hresult;
}

/*
 *	CEnumFormatEtc::Skip
 *
 *	@mfunc
 *		skips the next [celt] formats
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Skip( ULONG celt )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Skip");

    HRESULT		hresult = NOERROR;

    _iCurrent += celt;

    if( _iCurrent > _cTotal )
    {
        // whoops, skipped too far ahead.  Set us to the max limit.
        _iCurrent = _cTotal;
        hresult = S_FALSE;
    }

    return hresult;
}

/*
 *	CEnumFormatEtc::Reset
 *
 *	@mfunc
 *		resets the seek pointer to zero
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Reset( void )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Reset");

    _iCurrent = 0;

    return NOERROR;
}

/*
 *	CEnumFormatEtc::Clone
 *
 *	@mfunc
 *		clones the enumerator
 *
 *	@rdesc
 *		HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Clone( IEnumFORMATETC **ppIEnum )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Clone");
	
    return CEnumFormatEtc::Create(_prgFormats, _cTotal, ppIEnum);
}

/*
 *	CEnumFormatEtc::Create (prgFormats, cTotal, hr)
 *
 *	@mfunc
 *		creates a new format enumerator
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		*copies* the formats passed in.  We do this as it simplifies
 *		memory management under OLE object liveness rules
 */

HRESULT CEnumFormatEtc::Create( FORMATETC *prgFormats, ULONG cTotal, 
	IEnumFORMATETC **ppenum )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::Create");

	CEnumFormatEtc *penum = new CEnumFormatEtc();

	if(penum)
	{
  		// _iCurrent, _crefs are set in the constructor

		if( cTotal > 0 )
		{
			penum->_prgFormats = new FORMATETC[cTotal];
			if( penum->_prgFormats )
			{
				penum->_cTotal = cTotal;
				memcpy(penum->_prgFormats, prgFormats, 
						cTotal * sizeof(FORMATETC));
				*ppenum = penum;
				return NOERROR;
			}	
		}

		delete penum;
	}
	return E_OUTOFMEMORY;
}

//
// CEnumFormatEtc PRIVATE methods
//

/*
 *	CEnumFormatEtc::CEnumFormatEtc()
 *
 *	@mfunc
 *		Private constructor
 */

CEnumFormatEtc::CEnumFormatEtc()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::CEnumFormatEtc");

	_cTotal = 0;
	_crefs	= 1;
	_prgFormats = NULL;
	_iCurrent = 0;
}

/*
 *	CEnumFormatEtc::~CEnumFormatEtc()
 *
 *	@mfunc
 *		Private destructor
 */

CEnumFormatEtc::~CEnumFormatEtc( void )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CEnumFormatEtc::~CEnumFormatEtc");

    if( _prgFormats )
        delete _prgFormats;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\hash.h ===
#ifndef _HASH_H
#define _HASH_H

#include "tokens.h"

#define		HASHSIZE 	257	// DO NOT CHANGE!
						// this prime has been chosen because
						// there is a fast MOD257
						// if you use the % operator the thing
						// slows down to just about what a binary search is.

#define			MOD257(k) ((k) - ((k) & ~255) - ((k) >> 8) )	// MOD 257
#define			MOD257_1(k) ((k) & 255)	// MOD (257 - 1)

extern BOOL		_rtfHashInited;
VOID			HashKeyword_Init( );

VOID			HashKeyword_Insert ( const KEYWORD *token );
const KEYWORD	*HashKeyword_Fetch ( const CHAR *szKeyword );

#endif	// _HASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\dynarray.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	DYNARRAY.H -- CDynamicArray class which is used to complement
 *      the CLstBxWndHost object.
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		12/15/97 - v-jerrki Created
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */
#include "_w32sys.h"

#ifndef __DYNARRAY_H__
#define __DYNARRAY_H__


#define DYNARRAY_ARRAY_SIZE		128
#define DYNARRAY_ARRAY_SLOT		256
template<class T>
class CDynamicArray
{
protected:
	T*			_rg[DYNARRAY_ARRAY_SLOT];	
	int 		_nMax;						//indicate maximum valid index

public:
	static T			_sDummy;					// dummy struct if invalid index is requested
	
public:
	CDynamicArray() : _nMax(0) { memset(_rg, 0, sizeof(T*) * DYNARRAY_ARRAY_SLOT); }

	~CDynamicArray() { Clear();	}

	//==========================================================================
	// Reinitializes the class to its construction state
	//==========================================================================	
	void Clear()
	{
		//	Start removing all items from the list
		//	Start removing items from the list
		for (int i = ((_nMax - 1) / DYNARRAY_ARRAY_SIZE); i >= 0; i--)
		{
			if (_rg[i])
				delete _rg[i];
		}
		
		_nMax = 0;
		memset(_rg, 0, sizeof(T*) * DYNARRAY_ARRAY_SLOT);
	}

	
	const T& Get(int i);
	
	T& operator[](int i);
};

//==========================================================================
//	The function returns the requested index. if the requested index is
//  invalid then return dummy variable
//==========================================================================
template <class T>
const T& CDynamicArray<T>::Get(int i)
{
		// If item is negative or equal to zero, for efficiency reasons,
		// then just return the item in the head of array
		Assert(i >= 0);
		Assert(i < DYNARRAY_ARRAY_SLOT * DYNARRAY_ARRAY_SIZE);

		// Get the number of links we have to travel
		int nSlot = i / DYNARRAY_ARRAY_SIZE;		
		int nIdx = i % DYNARRAY_ARRAY_SIZE;

		// That link doesn't exist so just pass dummy struct
		Assert(nSlot < DYNARRAY_ARRAY_SLOT);
		if (i >= _nMax || nSlot >= DYNARRAY_ARRAY_SLOT || _rg[nSlot] == NULL)
		{	
			_sDummy._fSelected = 0;
			_sDummy._lparamData = 0;
			_sDummy._uHeight = 0;
			return _sDummy;
		}
			
		//return value at requested index		
		return _rg[nSlot][nIdx];
}

//==========================================================================
//	The function will be called if a l-value is requested therefore
//	the index does not necessarily have to be valid
//==========================================================================
template <class T>
T& CDynamicArray<T>::operator[](int i)
{
	Assert(i >= 0);

	// Get the slot number and index
	int nSlot = i / DYNARRAY_ARRAY_SIZE;		
	int nIdx = i % DYNARRAY_ARRAY_SIZE;

	// Check if the slot exists
	Assert(nSlot < DYNARRAY_ARRAY_SLOT);
	if (nSlot >= DYNARRAY_ARRAY_SLOT)
		return _sDummy;
	
	if (_rg[nSlot] == NULL)
	{
		//Need to allocate memory for this
		T* prg = new T[DYNARRAY_ARRAY_SIZE];
		if (!prg)
		{	
			_sDummy._fSelected = 0;
			_sDummy._lparamData = 0;
			_sDummy._uHeight = 0;
			return _sDummy;
		}

		memset(prg, 0, sizeof(T) * DYNARRAY_ARRAY_SIZE);
		_rg[nSlot] = prg;

		if (nSlot >= _nMax / DYNARRAY_ARRAY_SIZE)
			_nMax = (nSlot + 1) * DYNARRAY_ARRAY_SIZE;
	}		
			
	//return value at requested index
	return _rg[nSlot][nIdx];
}

#endif //__DYNARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\dragdrp.cpp ===
/*
 *	DRAGDRP.C
 *
 *	Purpose:
 *		Implementation of Richedit's OLE drag drop objects (namely,
 *		the drop target and drop source objects)
 *
 *	Author:
 *		alexgo (4/24/95)
 *		KeithCu (12/11/99) Simplified by going to an XOR model for the caret
 *		(just like the regular caret) and made work with various textflows.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dragdrp.h"
#include "_disp.h"
#include "_select.h"
#include "_font.h"
#include "_measure.h"


ASSERTDATA

//
//	CDropSource PUBLIC methods
//

/*
 *	CDropSource::QueryInterface (riid, ppv)
 */

STDMETHODIMP CDropSource::QueryInterface(
	REFIID riid,
	void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
		*ppv = (IUnknown *)this;

	else if( IsEqualIID(riid, IID_IDropSource) )
		*ppv = (IDropSource *)this;

	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return NOERROR;
}

/*
 *	CDropSource::AddRef
 */
STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::AddRef");

	return ++_crefs;
}

/*
 *	CDropSource::Release
 *
 *	@devnote.  Do not even think about making an outgoing call here.
 *			   If you do, be sure make sure all callers use a 
 *			   SafeReleaseAndNULL (null the pointer before releasing)
 *			   technique to avoid re-entrancy problems.
 */
STDMETHODIMP_(ULONG) CDropSource::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDropSource::QueryContinueDrag (fEscapePressed, grfKeyState)
 *
 *	@mfunc
 *		determines whether or not to continue a drag drop operation
 *
 *	Algorithm:
 *		if the escape key has been pressed, cancel 
 *		if the left mouse button has been release, then attempt to 
 *			do a drop
 */
STDMETHODIMP CDropSource::QueryContinueDrag(
	BOOL fEscapePressed, 
	DWORD grfKeyState)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::QueryContinueDrag");

    if(fEscapePressed)
        return DRAGDROP_S_CANCEL;

    if(!(grfKeyState & (MK_LBUTTON | MK_RBUTTON)))
        return DRAGDROP_S_DROP;

	return NOERROR;
}

/*
 *	CDropSource::GiveFeedback (dwEffect)
 *
 *	@mfunc
 *		gives feedback during a drag drop operation
 *
 *	Notes:
 *		FUTURE (alexgo): maybe put in some neater feedback effects
 *		than the standard OLE stuff??
 */
STDMETHODIMP CDropSource::GiveFeedback(
	DWORD dwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::GiveFeedback");

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

/*
 *	CDropSource::CDropSource
 */
CDropSource::CDropSource()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::CDropSource");

	_crefs = 1;
}

//
//	CDropSource PRIVATE methods
//

/*
 *	CDropSource::~CDropSource
 */
CDropSource::~CDropSource()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::~CDropSource");

	;
}


//
//	CDropTarget PUBLIC methods
//

/*
 *	CDropTarget::QueryInterface (riid, ppv)
 */
STDMETHODIMP CDropTarget::QueryInterface (
	REFIID riid,
	void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
		*ppv = (IUnknown *)this;

	else if( IsEqualIID(riid, IID_IDropTarget) )
		*ppv = (IDropTarget *)this;

	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return NOERROR;
}

/*
 *	CDropTarget::AddRef
 */
STDMETHODIMP_(ULONG) CDropTarget::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::AddRef");

	return ++_crefs;
}

/*
 *	CDropTarget::Release()
 */
STDMETHODIMP_(ULONG) CDropTarget::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDropTarget::DragEnter (pdo, grfKeyState, pt, pdwEffect)
 *
 *	@mfunc 
 *		Called when OLE drag drop enters our "window"
 *
 *	@devnote
 *		First we check to see if the data object being transferred contains
 *		any data that we support.  Then we verify that the 'type' of drag
 *		is acceptable (i.e., currently, we do not accept links).
 *
 *	FUTURE: (alexgo): we may want to accept links as well.
 */
STDMETHODIMP CDropTarget::DragEnter(
	IDataObject *pdo, 
	DWORD		grfKeyState,
	POINTL		pt, 
	DWORD *		pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragEnter");

	// We don't have a position yet.
	_cpCur = -1;

	HRESULT hr = NOERROR;
	DWORD result;
	CTxtSelection *psel;

	// At drag enter time, we should have no cached info about what the data
	// object supports.  This flag should be cleared in DragLeave.  Note
	// that we slightly override _dwFlags, as it's possible for a data object
	// given during drag drop to also generate DOI_NONE.

	if( !_ped )
		return CO_E_RELEASED;
	 
	Assert(_pcallmgr == NULL);
	Assert(_dwFlags == 0);

	_pcallmgr = new CCallMgr(_ped);

	if( !_pcallmgr )
		return E_OUTOFMEMORY;

	// Find out if we can paste the object
	result = _ped->GetDTE()->CanPaste(pdo, 0, RECO_DROP);

	if( result )
	{
		if( result == DF_CLIENTCONTROL )
			_dwFlags |= DF_CLIENTCONTROL;

		// Create the object that implements the drag caret
		_pdrgcrt = new CDropCaret(_ped);

		if ((NULL == _pdrgcrt) || !_pdrgcrt->Init())
		{
			// Initialization failed so go without a caret
			delete _pdrgcrt;
			_pdrgcrt = NULL;
		}
				
		// cache the current selection so we can restore it on return
		psel = _ped->GetSel();
		Assert(psel);

		_cpSel	= psel->GetCp();
		_cchSel	= psel->GetCch();
		_dwFlags |= DF_CANDROP;

		// just call DragOver to handle our visual feedback
		hr = DragOver(grfKeyState, pt, pdwEffect);
	}
	else if (_ped->fInOurHost())
	{
		// Just tell the caller that we can't drop.
		*pdwEffect = DROPEFFECT_NONE;
	}
	else
	{
		// this is new behaviour for Win95 OLE; if we don't 
		// understand anything about the data object given to us,
		// we return S_FALSE to allow our parent to give the
		// drag drop a try.

		// In theory, only forms^3 uses this information and
		// this return exposes an error in NT OLE, therefore,
		// we only do this now when not in our own host.
		
		hr = S_FALSE;
	}

	if( hr != NOERROR )
	{
		delete _pcallmgr;
		_pcallmgr = NULL;
		_dwFlags = 0;
	}

	return hr;
}

/*
 *	CDropTarget::DragOver (grfKeyState, pt, pdwEffect)
 *
 *	@mfunc
 *		Handles the visual feedback for a drag drop operation zooming
 *		around over text
 *
 *	FUTURE (alexgo): maybe we should do some snazzy visuals here
 */
STDMETHODIMP CDropTarget::DragOver(
	DWORD	grfKeyState, 
	POINTL	pt, 
	DWORD *	pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragOver");

	LONG	cpCur = _cpCur;

	if( !_ped )
		return CO_E_RELEASED;
	Assert(_pcallmgr);

	// note if we're doing right mouse drag drop; note that we 
	// can't do this in UpdateEffect as it's called from Drop
	// as well (and the mouse button is up then!)
	_dwFlags &= ~DF_RIGHTMOUSEDRAG;
	if(grfKeyState & MK_RBUTTON)
		_dwFlags |= DF_RIGHTMOUSEDRAG;

	UpdateEffect(grfKeyState, pt, pdwEffect);

	// only draw if we've changed position	
	if( *pdwEffect != DROPEFFECT_NONE  &&
		(cpCur != _cpCur || _pdrgcrt && _pdrgcrt->NoCaret()))
	{
		DrawFeedback();
	}	
	return NOERROR;
}

/*
 *	CDropTarget::DragLeave
 *
 *	@mfunc
 *		Called when the mouse leaves our window during drag drop.  Here we clean
 *		up any temporary state setup for the drag operation.
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDropTarget::DragLeave()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragLeave");

	CTxtSelection *psel = _ped->GetSel();

	if( !_ped )
		return CO_E_RELEASED;

	Assert(_pcallmgr);

	_dwFlags = 0;

	// now restore the selection

	psel->SetSelection(_cpSel - _cchSel, _cpSel);
	psel->Update(FALSE);

	_cpSel = _cchSel = 0;

	delete _pcallmgr;
	_pcallmgr = NULL;

	delete _pdrgcrt;
	_pdrgcrt = NULL;

	return NOERROR;
}

/*
 *	CDropTarget::Drop (pdo, grfKeyState, pt, pdwEffect)
 *
 *	@mfunc
 *		Called when the mouse button is released.  We should attempt
 *		to 'paste' the data object into a selection corresponding to
 *		the mouse location
 *
 *	@devnote
 *		First we make sure that we can still do a paste (via UpdateEffect).
 *		If so, then set the selection to the current point and then insert
 *		the text.
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDropTarget::Drop(
	IDataObject *pdo,
	DWORD		 grfKeyState, 
	POINTL		 ptl,
	DWORD *		 pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Drop");

	HRESULT	hr = NOERROR;

	if( !_ped )
		return CO_E_RELEASED;

	Assert(_pcallmgr);
	CDropCleanup cleanup(this);

	// see if we can still drop
	UpdateEffect(grfKeyState, ptl, pdwEffect);

	// UpdateEffect will show a drop cursor but at this point we don't need one
	// so we hide the drop cursor here.
	if (_pdrgcrt)
		_pdrgcrt->ShowCaret(FALSE);

	if (_dwFlags & DF_OVERSOURCE)
	{
		*pdwEffect = DROPEFFECT_NONE;
		_dwFlags = 0;
		return NOERROR;
	}
	
	if(*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK))
	{
		IUndoBuilder *	publdr;
		CGenUndoBuilder undobldr( _ped, UB_AUTOCOMMIT, &publdr);
		// If this is a right mouse drag drop; handle that
		if(_dwFlags & DF_RIGHTMOUSEDRAG)
		{
			hr = HandleRightMouseDrop(pdo, ptl);

			// If S_FALSE is returned, treat drag drop normally
			if( hr != S_FALSE )
				goto Exit;
		}

		// Get an undo builder.  If we already have one cached, that means
		// we are dropping onto the same edit instance that started the drag
		// In this case, we want to use the cached undo builder so that 
		// a drag move can be undone as one "operation".

		if(_publdr)
			publdr = _publdr;

		CTxtSelection *psel = _ped->GetSel();
		psel->SetSelection(_cpCur, _cpCur);
		
		if( !_ped->IsProtectedRange(WM_PASTE, 0, 0, psel) )
		{
			hr = _ped->PasteDataObjectToRange(pdo, (CTxtRange *)psel, 
					0, NULL, publdr, PDOR_DROP);
		}

		// If we are dropping onto ourselves, the UI specifies
		// that we should select the entire range dragged.  We use
		// _publdr as an easy way to tell if the drop originated from
		// this instance

		if(SUCCEEDED(hr) && _pdrgcrt)
		{
			// If the drop worked, then we don't want to restore the area
			// where the drop caret used to be since this is not out of date.
			_pdrgcrt->CancelRestoreCaretArea();
		}		

		// Now set the selection anti-events. If the selection preceded the
		// paste poiont subtract its length from the redo position, since
		// the selection will get deleted if we are doing a DRAGMOVE within
		// this instance.
		LONG cpNext  = psel->GetCp();
		LONG cchNext = cpNext - _cpCur;
		if(_cpSel < _cpCur && _publdr && (*pdwEffect & DROPEFFECT_MOVE))
			cpNext -= abs(_cchSel);

		HandleSelectionAEInfo(_ped, publdr, _cpCur, 0, cpNext, cchNext,
							  SELAE_FORCEREPLACE);
		if(_publdr)
		{
			// If we are doing a drag move, then *don't* set the
			// selection directly on the screen--doing so will result in
			// unsightly UI--we'll set the selection to one spot, draw it
			// and then immediately move the selection somewhere else.

			// In this case, just change where the selection range exists.
			// Floating ranges and the drag-move code in ldte.c will take
			// care of the rest.

			if( *pdwEffect == DROPEFFECT_COPY )
				psel->SetSelection(_cpCur, psel->GetCp());
			else
				psel->Set(psel->GetCp(), cchNext);
		}
		else if(publdr)
		{
			// The drop call landed in us from outside, so we need
			// to fire the appropriate notifications.  First, however,
			// commit the undo builder.

			publdr->SetNameID(UID_DRAGDROP);
			publdr->Done();

			if(SUCCEEDED(hr))
			{
				// Make this window the foreground window after the drop. Note
				// that the host needs to support ITextHost2 to really get to
				// be the foreground window. If they don't this is a no-op.
				_ped->TxSetForegroundWindow();
			}
		}

		// If nothing changed on the drop && the effect is a move, then return
		// failure. This is an ugly hack to improve drag-move scenarios; if
		// nothing happened on the drop, then chances are, you don't want
		// to have the correspong "Cut" happen on the drag source side.
		//
		// Of course, this relies on the drag source responding gracefully to
		// E_FAIL w/o hitting too much trauma.
		if (*pdwEffect == DROPEFFECT_MOVE && 
			!_ped->GetCallMgr()->GetChangeEvent() )
		{
			hr = E_FAIL;
		}
	}

Exit:
	_dwFlags = 0;
	return hr;
}

/*
 *	CDropTarget::CDropTarget (ped)
 */
CDropTarget::CDropTarget(
	CTxtEdit *ped)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::CDropTarget");

	_ped 		= ped;
	_crefs 		= 1;
	_dwFlags 	= 0;
	_publdr 	= NULL;
	_cpMin		= -1;
	_cpMost		= -1;
	_pcallmgr	= NULL;
}

/*
 *	CDropTarget::SetDragInfo (publdr, cpMin, cpMost)
 *
 *	@mfunc
 *		Allows the data transfer engine to cache important information
 *		about a drag drop with this drop target.
 *
 *	@devnote
 *		Intra-instance drag drop operations can be treated as a single user
 *		action.  With cpMin and cpMost, we can disable dragging into the
 *		range that is being dragged. This method must be called again in
 *		order to clear the cached info. -1 for cpMin and cpMost will "clear"
 *		those values (as 0 is a valid cp)
 */
void CDropTarget::SetDragInfo(
	IUndoBuilder *publdr,	//@parm Undo builder to use
	LONG cpMin,				//@parm Minimim character position of range that being dragged
	LONG cpMost )			//@parm Maximum character position of range
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::SetDragInfo");

	_publdr = publdr;
	_cpMin 	= cpMin;
	_cpMost	= cpMost;
}

/*
 *	CDropTarget::Zombie
 *
 *	@mfunc	This method clears the state in this drop target object.  It is
 *			used to recover 'gracefully' from reference counting errors
 */
void CDropTarget::Zombie()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Zombie");

	_ped = NULL;
	if( _pcallmgr )
	{
		delete _pcallmgr;
		_pcallmgr = NULL;
	}
}

//
//	CDropTarget PRIVATE methods
//

/*
 *	CDropTarget::~CDropTarget
 */
CDropTarget::~CDropTarget()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::~CDropTarget");

	;
}

/*
 *	CDropTarget::ConvertScreenPtToClientPt (pptScreen, pptClient)
 *
 *	@mfunc
 *		OLE drag drop sends points in using screen coordinates.  However,
 *		all of our display code internally relies on client coordinates
 *		(i.e. the coordinates relative to the window that we are being
 *		drawn in).  This routine will convert between the two
 *
 *	@devnote
 *		The client coordinates use a POINT structure instead of POINTL.
 *		while nominally they are the same, OLE uses POINTL and the display
 *		engine uses POINT. 
 */
void CDropTarget::ConvertScreenPtToClientPt(
	POINTL *pptScreen, 
	POINT *pptClient )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::ConvertScreenPtToClientPt");

	POINT ptS;

	pptClient->x = ptS.x = pptScreen->x;
	pptClient->y = ptS.y = pptScreen->y;

	_ped->TxScreenToClient(pptClient);
}

/*
 *	CDropTarget::UpdateEffect (grfKeyState, ptl, pdwEffect)
 *
 *	@mfunc
 *		Given the keyboard state and point, and knowledge of what
 *		the data object being transferred can offer, calculate
 *		the correct drag drop feedback.
 *
 *	@devnote
 *		This function should only be called during a drag drop 
 *		operation; doing otherwise will simply result in a return
 *		of DROPEFFECT_NONE.
 */

void CDropTarget::UpdateEffect(
	DWORD	grfKeyState, 
	POINTL	ptl, 
	DWORD *	pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::UpdateEffect");

	BOOL fHot = FALSE;
	HRESULT hr;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();

	if (_ped->fInplaceActive())
	{
		POINTUV pt;
		POINT ptClient;
		WORD nScrollInset;

		// first, find out where we are
		ConvertScreenPtToClientPt(&ptl, &ptClient);

		_ped->_pdp->PointuvFromPoint(pt, ptClient);

		_cpCur = _ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE);

		// if we are on top of the range that is being
		// dragged, then remeber it for later
		_dwFlags &= ~DF_OVERSOURCE;
		if( _cpCur > _cpMin && _cpCur < _cpMost )
			_dwFlags |= DF_OVERSOURCE;

		// Scroll if we need to and remember if we are in the hot zone.
		nScrollInset = W32->GetScrollInset();

		if (_pdrgcrt != NULL)
			_pdrgcrt->ShowCaret(FALSE);

		fHot = _ped->_pdp->AutoScroll(pt, nScrollInset, nScrollInset);

		if (_pdrgcrt != NULL)
		{
			if(!(_dwFlags & DF_OVERSOURCE) && !fHot)
				_pdrgcrt->ShowCaret(TRUE);

			else
			{
				// The hide above restored the caret so we just
				// need to turn off the caret while we are over the
				// source.
				_pdrgcrt->CancelRestoreCaretArea();
			}
		}
	}
	// Let the client set the effect if it wants, but first, we need
	// to check for protection.

	if( _ped->IsRich() )
	{
		// We don't allow dropping onto protected text.  Note that
		// the _edges_ of a protected range may be dragged to; therefore,
		// we need to check for protection at _cpCur and _cpCur-1.
		// If both cp's are protected, then we are inside a protected
		// range.
		CTxtRange rg(_ped, _cpCur, 0);
		PROTECT iProt = rg.IsProtected(CHKPROT_EITHER);

		if (iProt == PROTECTED_YES ||
			iProt == PROTECTED_ASK &&
			 (!_ped->IsProtectionCheckingEnabled() || 
			 _ped->QueryUseProtection(&rg, WM_MOUSEMOVE,0, 0)))
		{ 
			*pdwEffect = DROPEFFECT_NONE;
			goto Exit;
		}
	}

	if( precall )
	{
		hr = precall->GetDragDropEffect(FALSE, grfKeyState, pdwEffect);
		// Note : RichEdit 1.0 does not check the return code of this call.
		// If callback specified a single effect, use it.
		// Otherwise pick one ourselves.

		// trick: (x & (x-1)) is non-zero if more than one bit is set.
		if (!(*pdwEffect & (*pdwEffect - 1) ))
			goto Exit;
	}
	
	// If we don't know anything about the data object or the control
	// is read-only, set the effect to none.
	// If the client is handling this, we don't worry about read-only.
	if (!(_dwFlags & DF_CLIENTCONTROL) &&
		(!(_dwFlags & DF_CANDROP) || _ped->TxGetReadOnly()))
	{
		*pdwEffect = DROPEFFECT_NONE;
		_cpCur = -1;
		// no need to do anything else
		return;
	}

	// if we are on top of the range that is being
	// dragged, then we can't drop there!
	if( _dwFlags & DF_OVERSOURCE )
	{
		*pdwEffect = DROPEFFECT_NONE;
		goto Exit;
	}

	// now check the keyboard state and the requested drop effects.
	if(_dwFlags & DF_CANDROP)
	{
		// if we can paste plain text, then see if a MOVE or COPY
		// operation was requested and set the right effect.  Note
		// that we prefer MOVEs over COPY's in accordance with OLE
		// UI guidelines.

		// we do not yet support linking
		if( (grfKeyState & MK_CONTROL) && (grfKeyState & MK_SHIFT) )
		{
			//COMPATIBILITY: Richedit 1.0 did not appear to support drag
			//linking correctly.
			*pdwEffect = DROPEFFECT_NONE;
		}
		else if( !(grfKeyState & MK_CONTROL) && 
			(*pdwEffect & DROPEFFECT_MOVE) )
		{
			// if the control key is *not* depressed, then assume a "move"
			// operation (note that shift and alt or no keys will also give
			// a move) iff the source supports move.

			*pdwEffect = DROPEFFECT_MOVE;
		}
		else if( (grfKeyState & MK_CONTROL) && !((grfKeyState & MK_ALT) &&
			(grfKeyState & MK_SHIFT)) && (*pdwEffect & DROPEFFECT_COPY) )
		{
			// if only the control key is down and we're allowed to do a copy,
			// then do a copy
			*pdwEffect = DROPEFFECT_COPY;
		}
		else if( !(grfKeyState & MK_CONTROL) && 
			(*pdwEffect & DROPEFFECT_COPY) )
		{
			// if the control key is *not* depressed, and we are *not* allowed
			// to do a move (note that this if comes below the second one), then
			// do a COPY operation (if available)
			*pdwEffect = DROPEFFECT_COPY;
		}
		else
			*pdwEffect = DROPEFFECT_NONE;	// not a combination that we support
	}
	else
		*pdwEffect = DROPEFFECT_NONE;

Exit:	

	//Add the scrolling effect if we are in the hot zone.
	if(fHot)
		*pdwEffect |= DROPEFFECT_SCROLL;
}

/*
 *	CDropTarget::DrawFeedback()
 *
 *	@mfunc
 *		draws any feeback necessary on the target side (specifically, setting the
 *		cursor
 *
 *	Notes:
 *		assumes _cpCur is correctly set.
 */

void CDropTarget::DrawFeedback()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DrawFeedback");

	if (_ped && _ped->fInplaceActive() && _pdrgcrt != NULL)
	{
		// We need to indicate a drop location because a drop is possible
		_pdrgcrt->DrawCaret(_cpCur);
	}
}

/*
 *	CDropTarget::HandleRightMouseDrop(pdo, ptl)
 *
 *	@mfunc	Handles calling back to the client to get a context menu 
 *			for a right-mouse drag drop.
 *
 *	@rdesc	HRESULT
 */
HRESULT CDropTarget::HandleRightMouseDrop(
	IDataObject *pdo,		//@parm Data object to drop
	POINTL ptl)				//@parm Location of the drop (screen coords)
{
	LPRICHEDITOLECALLBACK precall = NULL;
	CHARRANGE cr = {_cpCur, _cpCur};
	HMENU hmenu = NULL;
	HWND hwnd, hwndParent;

	precall = _ped->GetRECallback();

	if( !precall || _ped->Get10Mode() )
		return S_FALSE;

	// HACK ALERT! evil pointer casting going on here.
	precall->GetContextMenu( GCM_RIGHTMOUSEDROP, (IOleObject *)(void *)pdo, &cr, &hmenu);

	if( hmenu && _ped->TxGetWindow(&hwnd) == NOERROR )
	{
		hwndParent = GetParent(hwnd);
		if( !hwndParent )
			hwndParent = hwnd;

		TrackPopupMenu(hmenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
			ptl.x, ptl.y, 0, hwndParent, NULL);

		return NOERROR;
	}
	return S_FALSE;
}

/*
 *	CDropCaret::DrawCaret (ped)
 *
 *	@mfunc
 *		Draws a "caret" to indicate where the drop will occur.
 */

CDropCaret::CDropCaret(
	CTxtEdit *ped)			//@parm Edit control
{
	_ped = ped;
	_dvp = -1;
	_hdcWindow = NULL;
	_fCaretOn = FALSE;
}

/*
 *	CDropCaret::~CDropCaret
 *
 *	@mfunc
 *		Clean up caret object
 */

CDropCaret::~CDropCaret()
{
	if (_ped->_pdp && _hdcWindow != NULL)
	{
		// Restore the any updated window area
		ShowCaret(FALSE);

		// Free the DC we held on to
		_ped->_pdp->ReleaseDC(_hdcWindow);
	}
}

/*
 *	CDropCaret::Init ()
 *
 *	@mfunc
 *		Do initialization that can fail
 */

BOOL CDropCaret::Init()
{
	// Get the DC for the window
	_hdcWindow = _ped->_pdp->GetDC();

	if (NULL == _hdcWindow)
	{
		// Could not get a DC, we are toast.
		AssertSz(FALSE, "CDropCaret::Init could not get hdc"); 
		return FALSE;
	}

	return TRUE;
}

/*
 *	CDropCaret::DrawCaret (cpCur)
 *
 *	@mfunc
 *		Draws a "caret" to indicate where the drop will occur.
 */
void CDropCaret::DrawCaret(
	LONG cpCur)				//@parm current cp of where drop would occur
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropCaret::DrawCaret");

	CLock		lock;					// Uses global (shared) FontCache
	CDisplay *	pdp = _ped->_pdp;
	POINTUV		ptNew;
	RECTUV		rcClient;
	CLinePtr	rp(pdp);
	CRchTxtPtr	rtp(_ped, cpCur);

	//Hide caret if appropriate
	ShowCaret(FALSE);

	// We no longer have a caret to restore
	_dvp = -1;

	// Get new cp from point
	pdp->PointFromTp(rtp, NULL, FALSE, ptNew, &rp, TA_TOP | TA_LOGICAL);

	// Get client rectangle
	_ped->TxGetClientRect(&rcClient);
	
	// Figure out height of new caret
	const CCharFormat *pCF = rtp.GetCF();

	// Get zoomed height
	LONG dvpInch = MulDiv(GetDeviceCaps(_hdcWindow, LOGPIXELSY), pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
	CCcs *pccs = _ped->GetCcs(pCF, dvpInch);

	if (NULL == pccs)
		return;	// We can't do anything sensible so give up.

	// Save new height
	_dvp = pccs->_yHeight;

	LONG vpOffset, vpAdjust;
	pccs->GetOffset(pCF, dvpInch, &vpOffset, &vpAdjust);

	// Save new position
	ptNew.v += (rp->GetHeight() - rp->GetDescent() + pccs->_yDescent - _dvp - vpOffset - vpAdjust);

	// Release cache entry since we are done with it.
	pccs->Release();

	// Save new caret position
	_ptCaret.u = ptNew.u;
	_ptCaret.v = ptNew.v;

	// If new point is in client rectangle, show the caret
	if(PtInRect(&rcClient, ptNew))
		ShowCaret(TRUE);
}

/*
 *	CDropCaret::ShowCaret (fShow)
 *
 *	@mfunc
 *		Toggle
 */
void CDropCaret::ShowCaret(
	BOOL fShow)
{
	if (_dvp != -1 && _fCaretOn != fShow)
	{
		RECT rc;
		RECTUV rcuv;

		rcuv.left = _ptCaret.u;
		rcuv.top = _ptCaret.v;
		rcuv.right = rcuv.left + WIDTH_DROPCARET;
		rcuv.bottom = rcuv.top + _dvp;

		_ped->_pdp->RectFromRectuv(rc, rcuv);
		InvertRect(_hdcWindow, &rc);
		_fCaretOn = fShow;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\edit.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	EDIT.C - main part of CTxtEdit |
 *	
 *		See also textserv.cpp (ITextServices and SendMessage interfaces)
 *		and tomDoc.cpp (ITextDocument interface)
 *	
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini, Murray Sargent, Alex Gounares, Rick Sailor,
 *		Jon Matousek
 *	
 *	History: <nl>
 *		12/28/95 jonmat-Added support of Magellan mouse and smooth scrolling.
 *
 *	@devnote
 *		Be sure to set tabs at every four (4) columns.  In fact, don't even
 *		think of doing anything else!
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_rtext.h"
#include "_hyph.h"
#include "_uspi.h"
#include "_urlsup.h"

#ifndef NOLINESERVICES
#include "_ols.h"
#endif

#include "_txtbrk.h"
#include "_clasfyc.h"

#define CONTROL(_ch) (_ch - 'A' + 1)

ASSERTDATA

// This is not public because we don't really want folks using it.
// ITextServices is a private interface.
EXTERN_C const IID IID_ITextServices = { // 8d33f740-cf58-11ce-a89d-00aa006cadc5
	0x8d33f740,
	0xcf58,
	0x11ce,
	{0xa8, 0x9d, 0x00, 0xaa, 0x00, 0x6c, 0xad, 0xc5}
  };

// {13E670F4-1A5A-11cf-ABEB-00AA00B65EA1}
EXTERN_C const GUID IID_ITextHost = 
{ 0x13e670f4, 0x1a5a, 0x11cf, { 0xab, 0xeb, 0x0, 0xaa, 0x0, 0xb6, 0x5e, 0xa1 } };

// {13E670F5-1A5A-11cf-ABEB-00AA00B65EA1}
EXTERN_C const GUID IID_ITextHost2 = 
{ 0x13e670f5, 0x1a5a, 0x11cf, { 0xab, 0xeb, 0x0, 0xaa, 0x0, 0xb6, 0x5e, 0xa1 } };

// this is used internally do tell if a data object is one of our own.
EXTERN_C const GUID IID_IRichEditDO =
{ /* 21bc3b20-e5d5-11cf-93e1-00aa00b65ea1 */
    0x21bc3b20,
    0xe5d5,
    0x11cf,
    {0x93, 0xe1, 0x00, 0xaa, 0x00, 0xb6, 0x5e, 0xa1}
};

// Static data members
DWORD CTxtEdit::_dwTickDblClick;	// time of last double-click
POINT CTxtEdit::_ptDblClick;		// position of last double-click

//HCURSOR CTxtEdit::_hcurCross = 0;	// We don't implement outline drag move
HCURSOR CTxtEdit::_hcurArrow = 0;
HCURSOR CTxtEdit::_hcurHand = 0;
HCURSOR CTxtEdit::_hcurIBeam = 0;
HCURSOR CTxtEdit::_hcurItalic = 0;
HCURSOR CTxtEdit::_hcurSelBar = 0;
HCURSOR CTxtEdit::_hcurVIBeam = 0;
HCURSOR CTxtEdit::_hcurVItalic = 0;

const WCHAR szCRLF[]= TEXT("\r\n");
const WCHAR szCR[]	= TEXT("\r");

WORD	g_wFlags = 0;					// Keyboard controlled flags

/*
 *	GetKbdFlags(vkey, dwFlags)
 *
 *	@func
 *		return bit mask (RSHIFT, LSHIFT, RCTRL, LCTRL, RALT, or LALT)
 *		corresponding to vkey = VK_SHIFT, VK_CONTROL, or VK_MENU and
 *		dwFlags
 *
 *	@rdesc
 *		Bit mask corresponding to vkey and dwFlags
 */
DWORD GetKbdFlags(
	WORD	vkey,		//@parm Virtual key code
	DWORD	dwFlags)	//@parm lparam of WM_KEYDOWN msg
{		
	if(vkey == VK_SHIFT)
		return (LOBYTE(HIWORD(dwFlags)) == 0x36) ? RSHIFT : LSHIFT;

	if(vkey == VK_CONTROL)
		return (HIWORD(dwFlags) & KF_EXTENDED) ? RCTRL : LCTRL;

	Assert(vkey == VK_MENU);

	return (HIWORD(dwFlags) & KF_EXTENDED) ? RALT : LALT;
}

LONG TwipsToHalfPoints(
	LONG x)
{
	return x > 0 ? (x + 5)/10 : 0;		// Convert twips to half points
}

LONG TwipsToQuarterPoints(
	LONG x)
{
	return x > 0 ? (x + 3)/5 : 0;		// Convert twips to quarter points
}

LONG CheckTwips(
	LONG x)
{
	return x > 0 ? min(x, 255) : 0;
}


///////////////// CTxtEdit Creation, Initialization, Destruction ///////////////////////////////////////

/*
 *	CTxtEdit::CTxtEdit()
 *
 *	@mfunc
 *		constructor
 */
CTxtEdit::CTxtEdit(
	ITextHost2 *phost,
	IUnknown * punk)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CTxtEdit");

	_unk.Init();
	_punk = (punk) ? punk : &_unk;
	_ldte.Init(this);
	_phost	  = phost;
	_cpAccelerator = -1;					// Default to no accelerator

	// Initialize _iCF and _iPF to something bogus
	Set_iCF(-1);
	Set_iPF(-1);

	// Initialize local maximum text size to window default
	_cchTextMost = cInitTextMax;

	// This actually counts the number of active ped
	W32->AddRef();
}

/*
 *	CTxtEdit::~CTxtEdit()
 *
 *	@mfunc
 *		Destructor
 */
CTxtEdit::~CTxtEdit ()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::~CTxtEdit");

	Assert(!_fMButtonCapture);				// Need to properly transition
											//  Magellan mouse if asserts!
	_fSelfDestruct = TRUE;					// Tell the Call Mgr not to
											//  call this any more
	// Flush clipboard first
	_ldte.FlushClipboard();

	if(_pDocInfo)							// Do this before closing
	{										//  down internal structures
		CloseFile(TRUE);					// Close any open file
		delete _pDocInfo;					// Delete document info
		_pDocInfo = NULL;
	}

	if(_pdetecturl)
		delete _pdetecturl;

#ifndef NOCOMPLEXSCRIPTS
	if (_pbrk)
		delete _pbrk;
#endif

	if(_pobjmgr)
		delete _pobjmgr;

	// Release our reference to selection object
	if(_psel)
		_psel->Release();

	// Delete undo and redo managers
	if(_pundo)
		_pundo->Destroy();

#ifndef NOPRIVATEMESSAGE
	if (_pMsgNotify)
		delete _pMsgNotify;
#endif

	// Release message filter.
	// Note that the attached message filter must have released this document
	// Otherwise we will never get here.
	if (_pMsgFilter)
	{
		_pMsgFilter->Release();
		_pMsgFilter = 0;
	}

	if(_predo)
		_predo->Destroy();

	ReleaseFormats(Get_iCF(), Get_iPF());	// Release default formats

	delete _pdp;						// Delete displays
	_pdp = NULL;						// Break any further attempts to
										//  use display
	delete _pdpPrinter;

	if (_fHost2)
	{
		// We are in a windows host - need to deal with the shutdown
		// problem where the window can be destroyed before text
		// services is.
		if (!_fReleaseHost)
		{
			((ITextHost2*)_phost)->TxFreeTextServicesNotification();
		}
		else
		{
			// Had to keep host alive so tell it we are done with it.
			_phost->Release();
		}
	}
			
	W32->Release();
}

void CTxtEdit::TxInvalidateRect(const RECT *prc)
{
	_phost->TxInvalidateRect(prc, FALSE);
}

void CTxtEdit::TxInvalidateRect(const RECTUV *prcuv)
{
	CMeasurer me(_pdp);
	RECT rc;
	_pdp->RectFromRectuv(rc, *prcuv);
	_phost->TxInvalidateRect(&rc, FALSE);
}

/*
 *	CTxtEdit::Init (prcClient)
 *
 *	@mfunc
 *		Initializes this CTxtEdit. Called by CreateTextServices()
 *
 *	@rdesc
 *		Return TRUE if successful
 */

BOOL CTxtEdit::Init (
	const RECT *prcClient)		//@parm Client RECT
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::Init");

	CCharFormat 		CF;
	DWORD				dwBits = 0;
	DWORD				dwMask;
	LONG				iCF, iPF;
	CParaFormat 		PF;
	CCallMgr			callmgr(this);

	static BOOL fOnce = FALSE;
	if (!fOnce)
	{
		CLock lock;
		fOnce =	TRUE;
		_fnpPropChg[ 0] = &CTxtEdit::OnRichEditChange;			// TXTBIT_RICHTEXT			
		_fnpPropChg[ 1] = &CTxtEdit::OnTxMultiLineChange;		// TXTBIT_MULTILINE		
		_fnpPropChg[ 2] = &CTxtEdit::OnTxReadOnlyChange;		// TXTBIT_READONLY			
		_fnpPropChg[ 3] = &CTxtEdit::OnShowAccelerator;			// TXTBIT_SHOWACCELERATOR			
		_fnpPropChg[ 4] = &CTxtEdit::OnUsePassword;				// TXTBIT_USEPASSWORD			
		_fnpPropChg[ 5] = &CTxtEdit::OnTxHideSelectionChange;	// TXTBIT_HIDESELECTION			
		_fnpPropChg[ 6] = &CTxtEdit::OnSaveSelection;			// TXTBIT_SAVESELECTION			
		_fnpPropChg[ 7] = &CTxtEdit::OnAutoWordSel;				// TXTBIT_AUTOWORDSEL			
		_fnpPropChg[ 8] = &CTxtEdit::OnTxVerticalChange;		// TXTBIT_VERTICAL			
		_fnpPropChg[ 9] = &CTxtEdit::NeedViewUpdate;			// TXTBIT_SELECTIONBAR			
		_fnpPropChg[10] = &CTxtEdit::OnWordWrapChange;			// TXTBIT_WORDWRAP 			
		_fnpPropChg[11] = &CTxtEdit::OnAllowBeep;				// TXTBIT_ALLOWBEEP				
		_fnpPropChg[12] = &CTxtEdit::OnDisableDrag;    			// TXTBIT_DISABLEDRAG			
		_fnpPropChg[13] = &CTxtEdit::NeedViewUpdate;			// TXTBIT_VIEWINSETCHANGE			
		_fnpPropChg[14] = &CTxtEdit::OnTxBackStyleChange;		// TXTBIT_BACKSTYLECHANGE			
		_fnpPropChg[15] = &CTxtEdit::OnMaxLengthChange;			// TXTBIT_MAXLENGTHCHANGE			
		_fnpPropChg[16] = &CTxtEdit::OnScrollChange;			// TXTBIT_SCROLLBARCHANGE			
		_fnpPropChg[17] = &CTxtEdit::OnCharFormatChange;		// TXTBIT_CHARFORMATCHANGE 			
		_fnpPropChg[18] = &CTxtEdit::OnParaFormatChange;		// TXTBIT_PARAFORMATCHANGE		
		_fnpPropChg[19] = &CTxtEdit::NeedViewUpdate;			// TXTBIT_EXTENTCHANGE			
		_fnpPropChg[20] = &CTxtEdit::OnClientRectChange;		// TXTBIT_CLIENTRECTCHANGE			
	}

	// Set up default CCharFormat and CParaFormat
	if (TxGetDefaultCharFormat(&CF, dwMask) != NOERROR ||
		TxGetDefaultParaFormat(&PF)			!= NOERROR ||
		FAILED(GetCharFormatCache()->Cache(&CF, &iCF)) ||
		FAILED(GetParaFormatCache()->Cache(&PF, &iPF)))
	{
		return FALSE;
	}

	GetTabsCache()->Release(PF._iTabs);
	Set_iCF(iCF);								// Save format indices
	Set_iPF(iPF);

	// Load mouse cursors (but only for first instance)
	if(!_hcurArrow)
	{
		_hcurArrow = LoadCursor(0, IDC_ARROW);
		if(!_hcurHand)
		{
			if (W32->_dwMajorVersion < 5)
				_hcurHand	= LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_HAND));
			else
				_hcurHand	= LoadCursor(0, IDC_HAND);
		}
		if(!_hcurIBeam)							// Load cursor
			_hcurIBeam	= LoadCursor(0, IDC_IBEAM);
		if(!_hcurItalic)
			_hcurItalic	= LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_ITALIC));
		if(!_hcurSelBar)
			_hcurSelBar = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_SELBAR));
		if(!_hcurVItalic)
			_hcurVItalic = LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_VITALIC));
		if(!_hcurVIBeam)
			_hcurVIBeam	= LoadCursor(hinstRE, MAKEINTRESOURCE(CUR_VIBEAM));
	}

#ifdef DEBUG
	// The host is going to do some checking on richtext vs. plain text.
	_fRich = TRUE;
#endif // DEBUG

	if(_phost->TxGetPropertyBits (TXTBITS |		// Get host state flags
		TXTBIT_MULTILINE | TXTBIT_SHOWACCELERATOR,	//  that we cache or need
		&dwBits) != NOERROR)						//  for display setup
	{
		return FALSE;
	}												// Cache bits defined by
	_dwFlags = dwBits & TXTBITS;					//  TXTBITS mask

	if ((dwBits & TXTBIT_SHOWACCELERATOR) &&		// They want accelerator,
		FAILED(UpdateAccelerator()))				//  so let's get it
	{
		return FALSE;
	}		

	_fTransparent = TxGetBackStyle() == TXTBACK_TRANSPARENT;
	if(dwBits & TXTBIT_MULTILINE)					// Create and initialize
		_pdp = new CDisplayML(this);				//  display
	else
		_pdp = new CDisplaySL(this);
	Assert(_pdp);

	if(!_pdp || !_pdp->Init())
		return FALSE;

	_fUseUndo  = TRUE;
	_fAutoFont = TRUE;
	_fDualFont = TRUE;
	_f10DeferChangeNotify = 0;

	// Set whether we are in our host or not
	ITextHost2 *phost2;
	if(_phost->QueryInterface(IID_ITextHost2, (void **)&phost2)	== NOERROR)
	{
		// We assume that ITextHost2 means this is our host
		phost2->Release();
		_fHost2 = TRUE;
	}
	else								// Get maximum from our host
		_phost->TxGetMaxLength(&_cchTextMost);

	// Add EOP iff Rich Text
	if(IsRich())
	{
		// We should _not_ be in 10 compatibility mode yet.
		// If we transition into 1.0 mode, we'll add a CRLF
		// at the end of the document.
		SetRichDocEndEOP(0);
	}

#ifndef NOLINESERVICES
	// Allow for win.ini control over use of line services
	if (W32->fUseLs())
	{
		OnSetTypographyOptions(TO_ADVANCEDTYPOGRAPHY, TO_ADVANCEDTYPOGRAPHY);
	}

#ifndef NOCOMPLEXSCRIPTS
	if (W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
		OrCharFlags(FDIGITSHAPE);		// digit substitution presents

	// Initialize the BiDi property
	// It is set to true if OS is BiDi (the system default LCID is a BiDi language)
	// or if the current keyboard code page is a BiDi code page
	// or if system.ini says we should do it.
	if (W32->OnBiDiOS() ||
		IsBiDiCharRep(GetKeyboardCharRep(0xFFFFFFFF)) ||
		W32->fUseBiDi())
	{
		OrCharFlags(FRTL);
	}

	_fAutoKeyboard = IsBiDi() && IsBiDiKbdInstalled();	
#endif // NOCOMPLEXSCRIPTS

#endif

	return TRUE;
}


///////////////////////////// CTxtEdit IUnknown ////////////////////////////////

/*
 *	CTxtEdit::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_NOINTERFACE
 *
 *	@devnote
 *		This interface is aggregated. See textserv.cpp for discussion.
 */
HRESULT CTxtEdit::QueryInterface(
	REFIID riid,
	void **ppv)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::QueryInterface");

	return _punk->QueryInterface(riid, ppv);
}

/*
 *	CTxtEdit::AddRef()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - incremented reference count
 */
ULONG CTxtEdit::AddRef(void)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::AddRef");

	return _punk->AddRef();
}

/*
 *	CTxtEdit::Release()
 *
 *	@mfunc
 *		IUnknown method
 *
 *	@rdesc
 *		ULONG - decremented reference count
 */
ULONG CTxtEdit::Release(void)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::Release");

	return _punk->Release();
}

////////////////////////// Undo Management  //////////////////////////////

/*
 *	CTxtEdit::CreateUndoMgr (cUndoLim, flags)
 *
 *	@mfunc
 *		Creates an undo stack
 *
 *	@rdesc
 *		Ptr to new IUndoMgr 
 */
IUndoMgr *CTxtEdit::CreateUndoMgr(
	LONG	cUndoLim,			//@parm Size limit
	USFlags flags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CreateUndoMgr");

	if(!_fUseUndo)
		return NULL;

	IUndoMgr *pmgr = new CUndoStack(this, cUndoLim, flags);
	if(!pmgr)
		return NULL;

	if(!pmgr->GetUndoLimit())
	{
		// The undo stack failed to initialize properly (probably
		// lack of memory). Trash it and return NULL.
		pmgr->Destroy();
		return NULL;
	}
	// We may be asked to create a new undo/redo manager
	// before we are completely done with initialization.
	// We need to clean up memory we have already allocated.
	if(flags & US_REDO)
	{
		if(_predo)
			_predo->Destroy();
		_predo = pmgr;
	}
	else
	{
		if(_pundo)
			_pundo->Destroy();
		_pundo = pmgr;
	}
	return pmgr;
}

/*
 *	CTxtEdit::HandleUndoLimit (cUndoLim)
 *
 *	@mfunc
 *		Handles the EM_SETUNDOLIMIT message
 *
 *	@rdesc	
 *		Actual limit to which things were set.
 */
LRESULT CTxtEdit::HandleSetUndoLimit(
	LONG cUndoLim) 		//@parm	Requested limit size
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::HandleSetUndoLimit");

	if (cUndoLim == tomSuspend ||			// This option really just
		cUndoLim == tomResume)				//  suspends undo, i.e.,
	{										//  doesn't discard existing	
		_fUseUndo = (cUndoLim == tomResume);//  antievents	
		return _pundo ? _pundo->GetUndoLimit() : 0;							
	}

	if(cUndoLim < 0)
		cUndoLim = DEFAULT_UNDO_SIZE;

	if(!cUndoLim)
	{
		_fUseUndo = FALSE;
		if(_pundo)
		{
			_pundo->Destroy();
			_pundo = NULL;
		}
		if(_predo)
		{
			_predo->Destroy();
			_predo = NULL;
		}
	}
	else if(!_pundo)
	{
		_fUseUndo = TRUE;
		// Don't worry about return value; if it's NULL, we're
		// in the same boat as if the API wasn't called (so later
		// on, we might try to allocate the default).
		CreateUndoMgr(cUndoLim, US_UNDO);
	}
	else
	{
		cUndoLim = _pundo->SetUndoLimit(cUndoLim);

		// Setting the undo limit on the undo stack will return to
		// us the actual amount set.  Try to set the redo stack to 
		// the same size.  If it can't go that big, too bad.
		if(_predo)
			_predo->SetUndoLimit(cUndoLim);
	}
	return cUndoLim;
}

/*
 *	CTxtEdit::HandleSetTextMode(mode)
 *
 *	@mfunc	handles setting the text mode
 *
 *	@rdesc	LRESULT; 0 (NOERROR) on success, OLE failure code on failure.
 *
 *	@devnote	the text mode does not have to be fully specified; it
 *			is sufficient to merely specify the specific desired behavior.
 *
 *			Note that the edit control must be completely empty for this
 *			routine to work.
 */
LRESULT CTxtEdit::HandleSetTextMode(
	DWORD mode)			//@parm the desired mode
{
	LRESULT lres = 0;

	// First off, we must be completely empty
	if (GetAdjustedTextLength() || 
		_pundo && _pundo->CanUndo() ||
		_predo && _predo->CanUndo())
	{
		return E_UNEXPECTED;
	}

	// These bits are considered one at a time; thus the absence of
	// any bits does _NOT_ imply any change in behavior.

	// TM_RICHTEXT && TM_PLAINTEXT are mutually exclusive; they cannot
	// be both set.  Same goes for TM_SINGLELEVELUNDO / TM_MULTILEVELUNDO
	// and TM_SINGLECODEPAGE / TM_MULTICODEPAGE
	if((mode & (TM_RICHTEXT | TM_PLAINTEXT)) == (TM_RICHTEXT | TM_PLAINTEXT) ||
	   (mode & (TM_SINGLELEVELUNDO | TM_MULTILEVELUNDO)) ==
			(TM_SINGLELEVELUNDO | TM_MULTILEVELUNDO) ||
	   (mode & (TM_SINGLECODEPAGE | TM_MULTICODEPAGE)) ==
			(TM_SINGLECODEPAGE | TM_MULTICODEPAGE))
	{
		lres = E_INVALIDARG;
	}
	else if((mode & TM_PLAINTEXT) && IsRich())
		lres = OnRichEditChange(FALSE);

	else if((mode & TM_RICHTEXT) && !IsRich())
		lres = OnRichEditChange(TRUE);

	if(!lres)
	{
		if(mode & TM_SINGLELEVELUNDO)
		{
			if(!_pundo)
				CreateUndoMgr(1, US_UNDO);

			if(_pundo)
			{
				// We can 'Enable' single level mode as many times
				// as we want, so no need to check for it before hand.
				lres = ((CUndoStack *)_pundo)->EnableSingleLevelMode();
			}
			else
				lres = E_OUTOFMEMORY;
		}
		else if(mode & TM_MULTILEVELUNDO)
		{
			// If there's no undo stack, no need to do anything,
			// we're already in multi-level mode
			if(_pundo && ((CUndoStack *)_pundo)->GetSingleLevelMode())
				((CUndoStack *)_pundo)->DisableSingleLevelMode();
		}

		if(mode & TM_SINGLECODEPAGE)
			_fSingleCodePage = TRUE;

		else if(mode & TM_MULTICODEPAGE)
			_fSingleCodePage = FALSE;
	}

	// We don't want this marked modified after this operation to make us
	// work better in dialog boxes.
	_fModified = FALSE;

	return lres;
}

/*
 *	CTxtEdit::HandleSetTextFlow(mode)
 *
 *	@mfunc	handles setting the text flow
 *
 *	@rdesc	LRESULT; 0 (NOERROR) on success, 1 (S_FALSE) for invalide mode
 *
 */
LRESULT CTxtEdit::HandleSetTextFlow(
	DWORD mode)			//@parm the desired mode
{
	TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::HandleSetTextFlow");

	if (!IN_RANGE(0, mode, 3) || !_pdp)
		return S_FALSE;

	if (mode == _pdp->GetTflow())		// No change
		return NOERROR;

	// We pretend like something actually happened.
	GetCallMgr()->SetChangeEvent(CN_GENERIC);

	_pdp->SetTflow(mode);

	TxShowScrollBar(SB_HORZ, _pdp->IsUScrollEnabled());
	TxShowScrollBar(SB_VERT, _pdp->IsVScrollEnabled());

	NeedViewUpdate(TRUE);
	return NOERROR;
	
}

extern ICustomTextOut *g_pcto;
/*
 *	CTxtEdit::GetCcs()
 *
 *	@mfunc
 *		Fetches a CCcs for a specific CCharFormat
 *
 *	@rdesc
 *		Ptr to CCcs
 */
CCcs* CTxtEdit::GetCcs(
	const CCharFormat *const pCF, 
	const LONG	dvpInch, 
	DWORD		dwFlags, 
	HDC			hdc)
{
	//Note, don't do ClearType for metafiles or printing.
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetCcs");

	CCharFormat CF = *pCF;
	if (g_pcto && FUseCustomTextOut())
		CF._dwEffects |= CFE_CUSTOMTEXTOUT;

#ifndef NODRAFTMODE
	// Use draft mode font only for displays
	if (_fDraftMode && (!hdc || GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY))
	{
		SHORT iFont;
		SHORT yHeight;
		QWORD qwFontSig;
		COLORREF crColor;

		if (W32->GetDraftModeFontInfo(iFont, yHeight, qwFontSig, crColor))
		{
			// Only hammer the name if the charset is OK
			if (FontSigFromCharRep(CF._iCharRep) & qwFontSig)
				CF._iFont = iFont;
			// Hammer the size always
			CF._yHeight = yHeight;
		}
	}
#endif

	if (dwFlags == -1)
		dwFlags = _pdp->GetTflow();

	if (_fUseAtFont)
		dwFlags |= FGCCSUSEATFONT;

	return fc().GetCcs(&CF, dvpInch, dwFlags, hdc);
}


CHyphCache *g_phc;
/*
 *	CTxtEdit::GetHyphCache()
 *
 *	@mfunc
 *		returns a pointer to the CHyphCache class (creating it if necessary)
 *
 *	@rdesc
 *		Ptr to CHyphCache class
 */
CHyphCache* CTxtEdit::GetHyphCache(void)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetHyphCache");
	if (!g_phc)
		g_phc = new CHyphCache();

	return g_phc;
}

////////////////////////// Uniscribe Interface //////////////////////////////
#ifndef NOCOMPLEXSCRIPTS
/*
 *	GetUniscribe()
 *
 *	@mfunc
 *		returns a pointer to the Uniscribe interface object
 *
 *	@rdesc
 *		Ptr to Uniscribe interface
 */
extern BOOL g_fNoUniscribe;
CUniscribe* GetUniscribe()
{
	if (g_pusp)
		return g_pusp;

	if (g_fNoUniscribe)
		return NULL;

	//Attempt to create the Uniscribe object, but make sure the
	//OS is valid and that we can load the uniscribe DLL.
	int cScripts;
	//Find out if OS is valid, or if delay-load fails
	if (!IsSupportedOS() || FAILED(ScriptGetProperties(NULL, &cScripts)))
	{
		g_fNoUniscribe = TRUE;
		return NULL;
	}

	if (!g_pusp)
		g_pusp = new CUniscribe();

	AssertSz(g_pusp, "GetUniscribe(): Create Uniscribe object failed");
	return g_pusp;
}
#endif // NOCOMPLEXSCRIPTS

////////////////////////// Notification Manager //////////////////////////////

/*
 *	CTxtEdit::GetNotifyMgr()
 *
 *	@mfunc
 *		returns a pointer to the notification manager (creating it if necessary)
 *
 *	@rdesc
 *		Ptr to notification manager
 */
CNotifyMgr *CTxtEdit::GetNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetNotifyMgr");

	return &_nm;
}


////////////////////////// Object Manager ///////////////////////////////////

/*
 *	CTxtEdit::GetObjectMgr()
 *
 *	@mfunc
 *		returns a pointer to the object manager (creating if necessary)
 *
 *	@rdesc
 *		pointer to the object manager
 */
CObjectMgr *CTxtEdit::GetObjectMgr()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetObjectMgr");

	if(!_pobjmgr)
		_pobjmgr = new CObjectMgr();

	return _pobjmgr;
}


////////////////////////////// Properties - Selection ////////////////////////////////


LONG CTxtEdit::GetSelMin() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelMin");

	return _psel ? _psel->GetCpMin() : 0;
}

LONG CTxtEdit::GetSelMost() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelMost");

	return _psel ? _psel->GetCpMost() : 0;
}

		
////////////////////////////// Properties - Text //////////////////////////////////////

LONG CTxtEdit::GetTextRange(
	LONG	cpFirst,
	LONG	cch,
	WCHAR *	pch)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetTextRange");

#ifdef DEBUG
	const LONG cchAsk = cch;
#endif
	CTxtPtr	tp(this, cpFirst);
	LONG	cchAdj = GetAdjustedTextLength();

	if(--cch < 0 || cpFirst > cchAdj)
		return 0;

	cch = min(cch, cchAdj - cpFirst);
	if(cch > 0)
	{
		cch = tp.GetPlainText(cch, pch, cpFirst + cch, FALSE, FALSE);
		Assert(cch >= 0);
	}
	pch[cch] = TEXT('\0');

#ifdef DEBUG
	if(cch != cchAsk - 1)
		Tracef(TRCSEVINFO, "CTxtEdit::GetTextRange: only got %ld out of %ld", cch, cchAsk - 1);
#endif

	return cch;
}

/*
 *	CTxtEdit::GetTextEx (pgt, pch)
 *
 *	@mfunc
 *		Grabs text according to various params
 *
 *	@rdesc
 *		Count of bytes gotten
 */
LONG CTxtEdit::GetTextEx(
	GETTEXTEX *pgt,		//@parm Info on what to get
	WCHAR *	   pch)		//@parm Where to put the text
{
	LONG	cb;
	LONG	cch;
	LONG	cchGet = GetAdjustedTextLength();
	LONG	cpMin  = 0;
	LONG	cpMost = tomForward;
	WCHAR *	pchUse = pch;
	CTempWcharBuf twcb;

	if(pgt->flags & GT_SELECTION)			// Get selected text
	{
		cch = GetSel()->GetRange(cpMin, cpMost);
		cchGet = min(cch, cchGet - cpMin);	// Don't include final EOP
	}

	if(pgt->codepage == (unsigned)-1)	// Use default codepage
		pgt->codepage = GetDefaultCodePage(EM_GETTEXTEX);

	if(pgt->cb == (unsigned)-1)			// Client says its buffer is big enuf
	{									
		pgt->cb = cchGet + 1;
		if(W32->IsFECodePage(pgt->codepage) || pgt->codepage == 1200)
			pgt->cb += cchGet;
		else if(pgt->codepage == CP_UTF8 && (_qwCharFlags & ~FASCII))
			pgt->cb *= (_qwCharFlags & FABOVEX7FF) ? 3 : 2;
	}

	// Allocate a big buffer; make sure that we have
	// enough room for lots of CRLFs if necessary
	if(pgt->flags & GT_USECRLF)
		cchGet *= 2;

	if(pgt->codepage != 1200)
	{
		// If UNICODE, copy straight to client's buffer;
		// else, copy to temp buffer and translate cases first
		pchUse = twcb.GetBuf(cchGet + 1);
		if (pch)
			*((char *)pch) = '\0';		// In case something fails
	}
	else						// Be sure to leave room for NULL terminator
		cchGet = min(UINT(pgt->cb/2 - 1), (UINT)cchGet);

	// Now grab the text 
	if(pgt->flags & GT_NOHIDDENTEXT)
	{
		CRchTxtPtr rtp(this, cpMin);
		cch = rtp.GetPlainText(cchGet, pchUse, cpMost, FALSE, pgt->flags & GT_USECRLF);
	}
	else
	{
		CTxtPtr tp(this, cpMin);
		if(pgt->flags & GT_RAWTEXT)
			cch = tp.GetText(cchGet, pchUse);
		else
			cch = tp.GetPlainText(cchGet, pchUse, cpMost, FALSE, pgt->flags & GT_USECRLF);
	}
	pchUse[cch] = L'\0';

	// If we're just doing UNICODE, return number of chars written
	if(pgt->codepage == 1200)
		return cch;

	// Oops, gotta translate to ANSI
	cb = WideCharToMultiByte(pgt->codepage, 0, pchUse, cch + 1, (char *)pch, 
			pgt->cb, pgt->lpDefaultChar, pgt->lpUsedDefChar);

	// Don't count NULL terminator for compatibility with WM_GETTEXT
	return cb ? cb - 1 : 0;
}
			
/*
 *	CTxtEdit::GetTextLengthEx (pgtl)
 *
 *	@mfunc
 *		Calculates text length in various ways.
 *
 *	@rdesc
 *		Text length calculated in various ways
 *
 *	@comm
 *		This function returns an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
LONG CTxtEdit::GetTextLengthEx(
	GETTEXTLENGTHEX *pgtl)	//@parm Info describing how to calculate length
{
	LONG	cchUnicode = GetAdjustedTextLength();
	LONG	cEOP = 0;
	DWORD	dwFlags = pgtl->flags;
	GETTEXTEX gt;

	if(pgtl->codepage == (unsigned)-1)
		pgtl->codepage = GetDefaultCodePage(EM_GETTEXTLENGTHEX);

	// Make sure the flags are defined appropriately
	if ((dwFlags & GTL_CLOSE)    && (dwFlags & GTL_PRECISE) ||
		(dwFlags & GTL_NUMCHARS) && (dwFlags & GTL_NUMBYTES))
	{
		TRACEWARNSZ("Invalid flags for EM_GETTEXTLENGTHEX");
		return E_INVALIDARG;
	}

	// Note in the following if statement, the second part of the
	// and clause will always be TRUE. At some point in the future
	// fUseCRLF and Get10Mode may become independent, in which case
	// the code below will automatically work without change.
	// NEW with 4.0: 1.0 mode gets text as is, so don't add count for CRs.
	// (RichEdit 1.0 only inserts Enters as CRLFs; it doesn't "cleanse"
	// other text insertion strings)
	if((dwFlags & GTL_USECRLF) && !fUseCRLF() && !Get10Mode())
	{
		// Important facts for 1.0 mode (REMARK: this is out of date):
		//
		// (1) 1.0 mode implies that the text is stored with fUseCRLF true.
		// fUseCRLF means that the EOP mark can either be a CR or a
		// CRLF - see CTxtRange::CleanseAndReplaceRange for details. 
		//
		// (2) 1.0 mode has an invariant that the count of text returned 
		// by this call should be enough to hold all the text returned by
		// WM_GETTEXT.
		//
		// (3) The WM_GETEXT call for 1.0 mode will return a buffer in 
		// which all EOPs that consist of a CR are replaced by CRLF.
		//
		// Therefore, for 1.0 mode, we must count all EOPs that consist
		// of only a CR and add addition return character to count the
		// LF that will be added into any WM_GETEXT buffer.

		// For 2.0 mode, the code is much easier, just count up all
		// CRs and bump count of each one by 1.

		CTxtPtr tp(this, 0);
		LONG	Results;

		while(tp.FindEOP(tomForward, &Results))
		{
			// If EOP consists of 1 char, add 1 since is returned by a CRLF.
			// If it consists of 2 chars, add 0, since it's a CRLF and is
			// returned as such.
			if(tp.GetCp() > cchUnicode)		// Don't add correction for
				break;						//  final CR (if any)
			if (!(Results & FEOP_CELL) &&	// CELL gets xlated into TAB,
				tp.GetPrevChar() != FF)		//  and FF into FF,
			{								//  i.e., single chars
				Results &= 3;				// Get advance cch
				if(Results)
					cEOP += 2 - Results;	// Add in xtra if lone CR or LF	
			}
			AssertSz(IN_RANGE(1, Results & 3, 2) || !Results && tp.GetCp() == cchUnicode,
				"CTxtEdit::GetTextLengthEx: CRCRLF found in backing store");
		}
		cchUnicode += cEOP;
	}

	// If we're just looking for the number of characters or if it's an
	// 8-bit codepage in RE 1.0 mode, we've already got the count.
	if ((dwFlags & GTL_NUMCHARS) || !dwFlags ||
		Get10Mode() && Is8BitCodePage(pgtl->codepage))
	{
		return cchUnicode;
	}

	// Hmm, they're looking for number of bytes, but don't care about 
	// precision, just multiply by two.  If neither PRECISE or CLOSE is
	// specified, default to CLOSE. Note if the codepage is UNICODE and
	// asking for number of bytes, we also just multiply by 2.
	if((dwFlags & GTL_CLOSE) || !(dwFlags & GTL_PRECISE) ||
		pgtl->codepage == 1200)
	{
		return cchUnicode *2;
	}

	// In order to get a precise answer, we need to convert (which is slow!).
	gt.cb = 0;
	gt.flags = (pgtl->flags & GT_USECRLF);
	gt.codepage = pgtl->codepage;
	gt.lpDefaultChar = NULL;
	gt.lpUsedDefChar = NULL;

	return GetTextEx(&gt, NULL);
}

/*
 *	CTxtEdit::GetDefaultCodePage (msg)
 *
 *	@mfunc
 *		Return codepage to use for converting the text in RichEdit20A text
 *		messages.
 *
 *	@rdesc
 *		Codepage to use for converting the text in RichEdit20A text messages.
 */
LONG CTxtEdit::GetDefaultCodePage(
	UINT msg)
{
	LONG CodePage = GetACP();

	// FUTURE: For backward compatibility in Office97, We always use ACP for all these 
	// languages. Need review in the future when the world all moves to Unicode.
	if (W32->IsBiDiCodePage(CodePage) || CodePage == CP_THAI || CodePage == CP_VIETNAMESE || 
		W32->IsFECodePage(CodePage) || _fSingleCodePage || msg == EM_GETCHARFORMAT || 
		msg == EM_SETCHARFORMAT)
	{
		return CodePage;
	}
	
	if(Get10Mode())
		return CodePageFromCharRep(GetCharFormat(-1)->_iCharRep);

	return CodePageFromCharRep(GetKeyboardCharRep());
}

//////////////////////////////  Properties - Formats  //////////////////////////////////

/*
 *	CTxtEdit::HandleStyle (pCFTarget, pCF, dwMask, dwMask2)
 *
 *	@mfunc
 *		If pCF specifies a style choice, initialize pCFTarget with the
 *		appropriate style, apply pCF, and return NOERROR.  Else return
 *		S_FALSE or an error
 *
 *	@rdesc
 *		HRESULT = (pCF specifies a style choice) ? NOERROR : S_FALSE or error code
 */
HRESULT CTxtEdit::HandleStyle(
	CCharFormat *pCFTarget,		//@parm Target CF to receive CF style content
	const CCharFormat *pCF,		//@parm Source CF that may specify a style
	DWORD		 dwMask,		//@parm CHARFORMAT2 mask
	DWORD		 dwMask2)		//@parm Second mask
{
	if(pCF->fSetStyle(dwMask, dwMask2))
	{
		// FUTURE: generalize to use client style if specified
		*pCFTarget = *GetCharFormat(-1);
		pCFTarget->ApplyDefaultStyle(pCF->_sStyle);
		return pCFTarget->Apply(pCF, dwMask, dwMask2);
	}
	return S_FALSE;
}

/*
 *	CTxtEdit::HandleStyle (pPFTarget, pPF)
 *
 *	@mfunc
 *		If pPF specifies a style choice, initialize pPFTarget with the
 *		appropriate style, apply pPF, and return NOERROR.  Else return
 *		S_FALSE or an error
 *
 *	@rdesc
 *		HRESULT = (pPF specifies a style choice) ? NOERROR : S_FALSE or error code
 */
HRESULT CTxtEdit::HandleStyle(
	CParaFormat *pPFTarget,		//@parm Target PF to receive PF style content
	const CParaFormat *pPF,		//@parm Source PF that may specify a style
	DWORD		dwMask,			//@parm Mask to use in setting CParaFormat
	DWORD		dwMask2)		//@parm Mask for internal flags
{
	if(pPF->fSetStyle(dwMask, dwMask2))
	{
		// FUTURE: generalize to use client style if specified
		*pPFTarget = *GetParaFormat(-1);
		pPFTarget->ApplyDefaultStyle(pPF->_sStyle);
		return pPFTarget->Apply(pPF, dwMask, dwMask2);
	}
	return S_FALSE;
}

//////////////////////////// Mouse Commands /////////////////////////////////

HRESULT CTxtEdit::OnTxLButtonDblClk(
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonDblClk");

	BOOL			fEnterParaSelMode = FALSE;
	HITTEST			Hit;
	CTxtSelection *	psel = GetSel();
	const POINT		ptxy = {x, y};
	POINTUV			pt;

	AssertSz(psel, "CTxtEdit::OnTxLButtonDblClk() - No selection object !");

    if (StopMagellanScroll())
        return S_OK;
    
	_dwTickDblClick = GetTickCount();
	_ptDblClick.x = x;
	_ptDblClick.y = y;

	TxUpdateWindow();		// Repaint window to show any exposed portions

	if(!_fFocus)
	{
		TxSetFocus();					// Create and display caret
		return S_OK;
	}

	_pdp->PointuvFromPoint(pt, ptxy);

	// Find out what the cursor is pointing at
	_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit); 

	if(Hit == HT_Nothing)
		return S_OK;

	if(Hit == HT_OutlineSymbol)
	{
		CTxtRange rg(*psel);
		rg.ExpandOutline(0, FALSE);
		return S_OK;
	}

	if(Hit == HT_LeftOfText)
		fEnterParaSelMode = TRUE;

	_fWantDrag = FALSE;					// just to be safe

	// If we are over a link, let the client have a chance to process
	// the message
	if(Hit == HT_Link && HandleLinkNotification(WM_LBUTTONDBLCLK, (WPARAM)dwFlags, MAKELPARAM(x, y)))
		return S_OK;

	if(dwFlags & MK_CONTROL)
		return S_OK;

	// Mark mouse down
	_fMouseDown = TRUE;

	if(_pobjmgr && _pobjmgr->HandleDoubleClick(this, pt, dwFlags))
	{
		// The object subsystem handled everything
		_fMouseDown = FALSE;
		return S_OK;
	}

	// Update the selection
	if(fEnterParaSelMode)
		psel->SelectUnit(pt, tomParagraph);
	else
		psel->SelectWord(pt);

	return S_OK;
}

HRESULT CTxtEdit::OnTxLButtonDown(
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonDown");

	BOOL		fEnterLineSelMode = FALSE;
	BOOL		fShift = dwFlags & MK_SHIFT;
	HITTEST		Hit;
	POINTUV		pt;
	const POINT ptxy = {x, y};
	COleObject *pobj;
	BOOL		fMustThaw = FALSE;

	const BOOL fTripleClick = GetTickCount() < _dwTickDblClick + W32->GetDCT() &&
				abs(x - _ptDblClick.x) <= W32->GetCxDoubleClk() &&
				abs(y - _ptDblClick.y) <= W32->GetCyDoubleClk();

    if (StopMagellanScroll())
        return S_OK;

    _pdp->PointuvFromPoint(pt, ptxy);

	// If click isn't inside view, just activate, don't select
	if(!_fFocus)					// Sets focus if not already
	{
		// We may be removing an existing selection, so freeze
		// display to avoid flicker
		_pdp->Freeze();
		fMustThaw = TRUE;
		TxSetFocus();				// creates and displays caret
	}

	// Grab selection object
	CTxtSelection * const psel = GetSel();
	AssertSz(psel,"CTxtEdit::OnTxLButtonDown - No selection object !");

	// Find out what cursor is pointing at
	_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit); 

	if(Hit == HT_LeftOfText)
	{
		// Shift click in sel bar treated as normal click
		if(!fShift)
		{
			// Control selbar click and triple selbar click
			// are select all
			if((dwFlags & MK_CONTROL) || fTripleClick)
			{
				psel->SelectAll();
				goto cancel_modes;
			}
			fEnterLineSelMode = TRUE;
			if(!GetAdjustedTextLength() && !_pdp->IsMultiLine())
			{
				const CParaFormat *pPF = psel->GetPF();
				// Can't see selected para mark when flushed right, so
				// leave selection as an insertion point
				if(pPF->_bAlignment == PFA_RIGHT && !pPF->IsRtlPara())
					fEnterLineSelMode = FALSE;
			}
		}
	}
	else if(Hit == HT_Nothing)
		goto cancel_modes;

	else if(!fShift)
		psel->CancelModes();

	// Let client have a chance to handle this message if we are over a link
	if(Hit == HT_Link && HandleLinkNotification(WM_LBUTTONDOWN, (WPARAM)dwFlags, 
			MAKELPARAM(x, y)))
	{
		goto cancel_modes;
	}

	_fMouseDown = TRUE;						// Flag mouse down
	if(!fShift && _pobjmgr)
	{
		// Deactivate anybody active, etc.
		ClickStatus status = _pobjmgr->HandleClick(this, pt);
		if(status == CLICK_OBJSELECTED)
		{
			// The object subsystem will handle resizing.
			// if not a resize we will signal start of drag
			pobj = _pobjmgr->GetSingleSelect();

			// Because HandleClick returned true, pobj better be non-null.
			Assert(pobj);

            if (!pobj->HandleResize(ptxy))
				_fWantDrag = !_fDisableDrag;

			goto cancel_modes;
		}
		else if(status == CLICK_OBJDEACTIVATED)
			goto cancel_modes;
	}

	_fCapture = TRUE;						// Capture the mouse
	TxSetCapture(TRUE);

	// Check for start of drag and drop
	if(!fTripleClick && !fShift && psel->PointInSel(pt, NULL, Hit) && !_fDisableDrag)
	{	    
		// Assume we want a drag. If we don't CmdLeftUp() needs
		//  this to be set anyway to change the selection
		_fWantDrag = TRUE;
		goto cancel_modes;
	}

	if(fShift)								// Extend selection from current
	{										//  active end to click
		psel->InitClickForAutWordSel(pt);
		psel->ExtendSelection(pt);			
	}
	else if(fEnterLineSelMode)				// Line selection mode: select line
		psel->SelectUnit(pt, tomLine);
	else if(fTripleClick || Hit == HT_OutlineSymbol) // paragraph selection mode
		psel->SelectUnit(pt, tomParagraph);
	else
	{
	    if (Get10Mode())
	        _f10DeferChangeNotify = 1;
		psel->SetCaret(pt);
		_mousePt = ptxy;
	}
        
	if(fMustThaw)
		_pdp->Thaw();

	return S_OK;

cancel_modes:
	psel->CancelModes();

	if(_fWantDrag)
	{
		TxSetTimer(RETID_DRAGDROP, W32->GetDragDelay());
		_mousePt = ptxy;
		_bMouseFlags = (BYTE)dwFlags;
		_fDragged = FALSE;
	}

	if(fMustThaw)
		_pdp->Thaw();
		
	return S_OK;
}

HRESULT CTxtEdit::OnTxLButtonUp(
	INT		x,				//@parm Mouse x coordinate
	INT		y,				//@parm Mouse y coordinate
	DWORD	dwFlags,		//@parm Mouse message wparam
	int	    ffOptions)      //@parm Mouse options, see _edit.h for details
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxLButtonUp");
    
	CheckRemoveContinuousScroll();

	// Remove capture before test for mouse down since we wait till
	// we get the mouse button up message to release capture since Forms
	// wants it that way.
	if(_fCapture && (ffOptions & LB_RELEASECAPTURE))
	{
		TxSetCapture(FALSE);
		_fCapture = FALSE;
	}

	// We were delaying selection change.  So send it now...
    if (DelayChangeNotification() && (ffOptions & LB_FLUSHNOTIFY))
    {
        AssertSz(Get10Mode(), "Flag should only be set in 10 mode");
        _f10DeferChangeNotify = 0;
        GetCallMgr()->SetSelectionChanged();        
    }

	if(!_fMouseDown)
	{
		// We noticed the mouse was no longer down earlier so we don't
		// need to do anything.
		return S_OK;
	}

	const BOOL fSetSel = !!_fWantDrag;
	const POINT ptxy = {x, y};
	POINTUV	pt;
	_pdp->PointuvFromPoint(pt, ptxy);

	// Cancel Auto Word Sel if on
	CTxtSelection * const psel = GetSel();
	AssertSz(psel,"CTxtEdit::OnLeftUp() - No selection object !");

	psel->CancelModes(TRUE);

	// Reset flags
	_fMouseDown = FALSE;
	_fWantDrag = FALSE;
	_fDragged = FALSE;
	TxKillTimer(RETID_DRAGDROP);
	if(IsInOutlineView())
		psel->Update(FALSE);

	// Let the client handle this message if we are over a
	// link area
	if(HandleLinkNotification(WM_LBUTTONUP, (WPARAM)dwFlags, 
			MAKELPARAM(x, y)))
	{
		return NOERROR;
	}

	// If we were in drag & drop, put caret under mouse
	if(fSetSel)
	{
		CObjectMgr* pobjmgr = GetObjectMgr();

		// If we were on an object, don't deselect it by setting the caret
		if(pobjmgr && !pobjmgr->GetSingleSelect())
		{
			psel->SetCaret(pt, TRUE);
			if(!_fFocus)
				TxSetFocus();		// create and display caret
		}
	}
	return S_OK;
}

HRESULT CTxtEdit::OnTxRButtonUp(
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags,	//@parm Mouse message wparam
	int     ffOptions)  //@parm option flag
{
	const POINT ptxy = {x, y};
	POINTUV		pt;
	CTxtSelection * psel;
	SELCHANGE selchg;
	HMENU hmenu = NULL;
	IOleObject * poo = NULL;
	COleObject * pobj = NULL;
	IUnknown * pUnk = NULL;
	IRichEditOleCallback * precall = NULL;
	_pdp->PointuvFromPoint(pt, ptxy);

	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxRButtonUp");

	// Make sure we have the focus
	if(!_fFocus)
		TxSetFocus();

	if(_fWantDrag)
	{
		_fDragged = FALSE;
		_fWantDrag = FALSE;
		TxKillTimer(RETID_DRAGDROP);
	}
		
	// Grab selection object
	psel = GetSel();
	psel->SetSelectionInfo(&selchg);

	// We need a pointer to the first object, if any, in the selection.
	if(_pobjmgr)
	{
		//If the point is in the selection we need to find out if there
		//are any objects in the selection.  If the point is not in a
		//selection but it is on an object, we need to select the object.
		if(psel->PointInSel(pt) || (ffOptions & RB_FORCEINSEL))
		{
			pobj = _pobjmgr->GetFirstObjectInRange(selchg.chrg.cpMin,
				selchg.chrg.cpMost);
		}
		else
		{
			//Select the object
			if(_pobjmgr->HandleClick(this, pt) == CLICK_OBJSELECTED)
			{
				pobj = _pobjmgr->GetSingleSelect();
				// Because HandleClick returned true, pobj better be non-null.
				Assert(pobj!=NULL);
				//Refresh our information about the selection
				psel = GetSel();
				psel->SetSelectionInfo(&selchg);
			}
		}
		precall = _pobjmgr->GetRECallback();
	}

	if(pobj)
		pUnk = pobj->GetIUnknown();

	if(pUnk)
		pUnk->QueryInterface(IID_IOleObject, (void **)&poo);

	if(precall)
		precall->GetContextMenu(selchg.seltyp, poo, &selchg.chrg, &hmenu);

	if(hmenu)
	{
		HWND hwnd, hwndParent;
		POINT ptscr;

		if(TxGetWindow(&hwnd) == NOERROR)
		{
			if(!(ffOptions & RB_NOSELCHECK) && !psel->PointInSel(pt) && 
				!psel->GetCch() && !(ffOptions & RB_FORCEINSEL))
				psel->SetCaret(pt);
			ptscr.x = ptxy.x;
			ptscr.y = ptxy.y;
			ClientToScreen(hwnd, &ptscr);

			hwndParent = GetParent(hwnd);
			if(!hwndParent)
				hwndParent = hwnd;

			TrackPopupMenu(hmenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON,
				ptscr.x, ptscr.y, 0, hwndParent, NULL);
		}
		DestroyMenu(hmenu);
	}

	if(poo)
		poo->Release();
	
	return precall ? S_OK : S_FALSE;
}

HRESULT CTxtEdit::OnTxRButtonDown(
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxRButtonDown");

    if (StopMagellanScroll())
        return S_OK;
    
	CTxtSelection *	psel = GetSel();
	const POINT		ptxy = {x, y};
	POINTUV			pt;

	_pdp->PointuvFromPoint(pt, ptxy);
	psel->CancelModes();

	if(psel->PointInSel(pt) && !_fDisableDrag)
	{
		_fWantDrag = TRUE;

		TxSetTimer(RETID_DRAGDROP, W32->GetDragDelay());
		_mousePt = ptxy;
		_bMouseFlags = (BYTE)dwFlags;
		_fDragged = FALSE;
		return S_OK;
	}
	return S_FALSE;
}

HRESULT CTxtEdit::OnTxMouseMove(
	INT		x,				//@parm Mouse x coordinate
	INT		y,				//@parm Mouse y coordinate
	DWORD	dwFlags,		//@parm Mouse message wparam
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMouseMove");

	if(!_fFocus)
		return S_OK;

	RECT rcxy;
	TxGetClientRect(&rcxy);
	if(_fWantDrag || _fCapture)
	{
		LONG nDragMinDist = W32->GetDragMinDist() + 3;
		int  dx = _mousePt.x > x ? _mousePt.x - x : x - _mousePt.x;
		int  dy = _mousePt.y > y ? _mousePt.y - y : y - _mousePt.y;

		if(dx < nDragMinDist && dy < nDragMinDist)
		{
			if(!_fCapture || x > 0 && x < rcxy.right && y > 0 && y < rcxy.bottom)
			{
				_bMouseFlags = (BYTE)dwFlags;
				return S_OK;
			}
		}
		_fDragged = _fWantDrag;
	}
	_mousePt.x = x;									// Remember for scrolling
	_mousePt.y = y;									//  speed, and dir calc.

	// RichEdit 1.0 allows the client to process mouse moves itself if
	// we are over a link (but _not_ doing drag drop).
	if(HandleLinkNotification(WM_MOUSEMOVE, 0, MAKELPARAM(x, y)))
		return NOERROR;

	// If we think mouse is down and it really is, do special processing
	if (GetAsyncKeyState(VK_LBUTTON) < 0 ||
		GetAsyncKeyState(VK_RBUTTON) < 0)
	{
		CTxtSelection * const psel = GetSel();
		AssertSz(psel,"CTxtEdit::OnMouseMove: No selection object !");

		if(_fWantDrag && !_fUsePassword &&
		   !IsProtected(_fReadOnly ? WM_COPY : WM_CUT, dwFlags, MAKELONG(x,y)))
		{
			TxKillTimer(RETID_DRAGDROP);
			_ldte.StartDrag(psel, publdr);
			// The mouse button may still be down, but drag drop is over
			// so we need to _think_ of it as up.
			_fMouseDown = FALSE;

			// Similarly, OLE should have nuked the capture for us, but
			// just in case something failed, release the capture.
			TxSetCapture(FALSE);
			_fCapture = FALSE;
		}
		else if(_fMouseDown)						// We think mouse is down
		{											//  and it is
			POINTUV pt;
			POINT	ptxy = {x, y};
			if(x >= rcxy.right && x < rcxy.right + 5)
				ptxy.x += 5;
			_pdp->PointuvFromPoint(pt, ptxy);
			if(_ldte.fInDrag())						// Only drag scroll if a drag
				_pdp->DragScroll(&_mousePt);		//  operation is in progress
			psel->ExtendSelection(pt);				// Extend the selection
			CheckInstallContinuousScroll();			// Install srolling timer
		}
	}
#ifndef NOMAGELLAN
	else if (!(GetAsyncKeyState(VK_MBUTTON) < 0) && !mouse.IsAutoScrolling())
	{
		if(_fMButtonCapture)						// Ensure we aren't autoscrolling
			OnTxMButtonUp (x, y, dwFlags);			//  via intellimouse

		if(_fMouseDown)
		{
			// Although we thought the mouse was down, at this moment it
			// clearly is not. Therefore, we pretend we got a mouse up
			// message and clear our state to get ourselves back in sync 
			// with what is really happening.
			OnTxLButtonUp(x, y, dwFlags, LB_RELEASECAPTURE);
		}
	}
#endif

	// Either a drag was started or the mouse button was not down. In either
	// case, we want no longer to start a drag so we set the flag to false.
	_fWantDrag = FALSE;
	return S_OK;
}

/*
 *	OnTxMButtonDown (x, y, dwFlags)
 *
 *	@mfunc
 *		The user pressed the middle mouse button, setup to do
 *		continuous scrolls, which may in turn initiate a timer
 *		for smooth scrolling.
 *
 *	@rdesc
 *		HRESULT = S_OK
 */
HRESULT CTxtEdit::OnTxMButtonDown (
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMButtonDown");

#if !defined(NOMAGELLAN)
	POINT	pt = {x,y};

	if(!_fFocus)
		TxSetFocus();
		
	if(!StopMagellanScroll() && mouse.MagellanStartMButtonScroll(*this, pt))
	{
		TxSetCapture(TRUE);

		_fCapture			= TRUE;							// Capture the mouse
		_fMouseDown			= TRUE;
		_fMButtonCapture	= TRUE;
	}
#endif

	return S_OK;
}

/*
 *	CTxtEdit::OnTxMButtonUp (x, y, dwFlags)
 *
 *	@mfunc
 *		Remove timers and capture associated with a MButtonDown
 *		message.
 *
 *	@rdesc
 *		HRESULT = S_OK
 */
HRESULT CTxtEdit::OnTxMButtonUp (
	INT		x,			//@parm Mouse x coordinate
	INT		y,			//@parm Mouse y coordinate
	DWORD	dwFlags)	//@parm Mouse message wparam
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxMButtonUp");

#if !defined(NOMAGELLAN)
    if (mouse.ContinueMButtonScroll(this, x, y))
        return S_OK;

    StopMagellanScroll();
    
#else

	if(_fCapture)
		TxSetCapture(FALSE);

	_fCapture			= FALSE;
	_fMouseDown			= FALSE;
	_fMButtonCapture	= FALSE;
	
#endif

	return S_OK;
}


/*
 *	CTxtEdit::StopMagellanScroll()
 *
 *	@mfunc
 *		Stops the intellimouse autoscrolling and returns
 *      us back into a normal state
 *
 *  BOOL = TRUE if auto scrolling was turned off : FALSE
 *          Autoscrolling was never turned on
 */
 BOOL CTxtEdit::StopMagellanScroll ()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::StopMagellanScroll");

#if !defined(NOMAGELLAN)
    if (!mouse.IsAutoScrolling())
        return FALSE;
        
	mouse.MagellanEndMButtonScroll(*this);

	if(_fCapture)
		TxSetCapture(FALSE);

	_fCapture			= FALSE;
	_fMouseDown			= FALSE;
	_fMButtonCapture	= FALSE;
	return TRUE;
#else
    return FALSE;
#endif
}


/*
 *	CTxtEdit::CheckInstallContinuousScroll ()
 *
 *	@mfunc
 *		There are no events that inform the app on a regular
 *		basis that a mouse button is down. This timer notifies
 *		the app that the button is still down, so that scrolling can
 *		continue.
 */
void CTxtEdit::CheckInstallContinuousScroll ()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CheckInstallContinuousScroll");

	if(!_fContinuousScroll && TxSetTimer(RETID_AUTOSCROLL, cmsecScrollInterval))
		_fContinuousScroll = TRUE;
}

/*
 *	CTxtEdit::CheckRemoveContinuousScroll ()
 *
 *	@mfunc
 *		The middle mouse button, or drag button, is up
 *		remove the continuous scroll timer.
 */
void CTxtEdit::CheckRemoveContinuousScroll ()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CheckRemoveContinuousScroll");

	if(_fContinuousScroll)
	{
		TxKillTimer(RETID_AUTOSCROLL);
		_fContinuousScroll = FALSE;
	}
}

/*
 *	OnTxTimer(idTimer)
 *
 *	@mfunc
 *		Handle timers for doing background recalc and scrolling.
 *
 *	@rdesc
 *		HRESULT = (idTimer valid) ? S_OK : S_FALSE
 */
HRESULT CTxtEdit::OnTxTimer(
	UINT idTimer)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxTimer");

	switch (idTimer)
	{
		case RETID_BGND_RECALC:
			_pdp->StepBackgroundRecalc();
			break;

#if !defined(NOMAGELLAN)
		case RETID_MAGELLANTRACK:
			mouse.TrackUpdateMagellanMButtonDown(*this, _mousePt);
			break;
#endif
		case RETID_AUTOSCROLL:						// Continuous scrolling.
			OnTxMouseMove(_mousePt.x, _mousePt.y,	// Do a select drag scroll.
						  0, NULL);
			break;

#if !defined(NOMAGELLAN)
		case RETID_SMOOTHSCROLL:					// Smooth scrolling
			if(_fMButtonCapture)					// HACK, only 1 timer!
			{										// delivered on Win95
													// when things get busy.
				mouse.TrackUpdateMagellanMButtonDown(*this, _mousePt);	
			}
			if(_pdp->IsSmoothVScolling())			// Test only because of
				_pdp->SmoothVScrollUpdate();		//  above HACK!!
		break;
#endif
		case RETID_DRAGDROP:
			TxKillTimer(RETID_DRAGDROP);
			if (_fWantDrag && _fDragged && !_fUsePassword &&
				!IsProtected(_fReadOnly ? WM_COPY : WM_CUT,
				             _bMouseFlags, MAKELONG(_mousePt.x,_mousePt.y)))
			{
				IUndoBuilder *	publdr;
				CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);
				_ldte.StartDrag(GetSel(), publdr);
				_fWantDrag = FALSE;
				_fDragged = FALSE;
				TxSetCapture(FALSE);
				_fCapture = FALSE;
			}
			break;

		default:
			return S_FALSE;
	}
	return S_OK;
}


/////////////////////////// Keyboard Commands ////////////////////////////////

/*
 *	CTxtEdit::OnTxKeyDown(vkey, dwFlags, publdr)
 *
 *	@mfunc
 *		Handle WM_KEYDOWN message
 *
 *	@rdesc
 *		HRESULT with the following values:
 *
 *		S_OK				if key was understood and consumed
 *		S_MSG_KEY_IGNORED	if key was understood, but not consumed
 *		S_FALSE				if key was not understood or just looked at
 *									and in any event not consumed
 */
HRESULT CTxtEdit::OnTxKeyDown(
	WORD		  vkey,		//@parm Virtual key code
	DWORD		  dwFlags,	//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxKeyDown");

	if(IN_RANGE(VK_SHIFT, vkey, VK_MENU))
	{
		SetKeyboardFlag(GetKbdFlags(vkey, dwFlags));
		return S_FALSE;
	}

	BOOL  fAlt	 = GetKeyboardFlag(ALT, VK_MENU);
	BOOL  fCtrl  = GetKeyboardFlag(CTRL, VK_CONTROL);
	BOOL  fShift = GetKeyboardFlag(SHIFT, VK_SHIFT);

	BOOL  fRet	 = FALSE;			// Converted to HRESULT on return
	LONG  nDeadKey = 0;

	if(fCtrl & fShift)						// Signal NonCtrl/Shift keydown
		SetKeyboardFlag(LETAFTERSHIFT);		//  while Ctrl&Shift are down

	// Handle Hebrew caps and LRM/RLM
#ifndef NOCOMPLEXSCRIPTS
	if (IsBiDi())
	{
		if(IsBiDiCharRep(GetKeyboardCharRep(0xFFFFFFFF)))
		{
			_fHbrCaps = FALSE;
			if(IsRich() && W32->UsingHebrewKeyboard())
			{
				WORD wCapital = GetKeyState(VK_CAPITAL);
				_fHbrCaps = ((wCapital & 1) ^ fShift) &&
							!(wCapital & 0x0080) &&
					     	IN_RANGE('A', vkey, 'Z');
				if(_fHbrCaps)
					W32->ActivateKeyboard(ANSI_INDEX);
	        }
		}
		
		if(vkey == VK_BACK && fShift && W32->OnWin9x())
		{
			// Shift+Backspace generates a LRM | RLM on a BiDi keyboard.
			// Consequently, we must eat the Backspace lest it delete text.
			W32->_fLRMorRLM = 1;
			return S_OK;
		}
	}
#endif

	// If dragging or Alt key down, just look for ESCAPE. Note: if Alt key is
	// down, we should never come here (would generate WM_SYSKEYDOWN message).
	if(_fMouseDown)
	{	    
		if(vkey == VK_ESCAPE)
		{
		    // Turn-off autoscroll.
		    if (StopMagellanScroll())
		        return S_OK;
		    
			POINT pt;
			// Cancel drag select or drag & drop
			GetCursorPos(&pt);
			OnTxLButtonUp(pt.x, pt.y, 0, LB_RELEASECAPTURE | LB_FLUSHNOTIFY);
			return S_OK;
		}
		return OnTxSpecialKeyDown(vkey, dwFlags, publdr);
	}
	
	CTxtSelection * const psel = GetSel();
	AssertSz(psel,"CTxtEdit::OnKeyDown() - No selection object !");

	if(fCtrl)
	{
		if(OnTxSpecialKeyDown(vkey, dwFlags, publdr) == S_OK)
			return S_OK;

		if(fAlt)						// This following code doesn't handle
			return S_FALSE;				//  use Ctrl+Alt, which happens for
										//  AltGr codes (no WM_SYSKEYDOWN)

		// Shift must not be pressed for these.
		if(!fShift)
		{
			switch(vkey)
			{
			case 'E':
			case 'J':
			case 'R':
			case 'L':
			{
				if(!IsRich() || !IsntProtectedOrReadOnly(WM_KEYDOWN, vkey, dwFlags))
					return S_FALSE;

				CParaFormat PF;
				PF._bAlignment = PFA_LEFT;
				if (vkey == 'E')
					PF._bAlignment = PFA_CENTER;
				else if (vkey == 'J')
					PF._bAlignment = PFA_FULL_INTERWORD;
				else if (vkey == 'R')
					PF._bAlignment = PFA_RIGHT;
					
				psel->SetParaFormat(&PF, publdr, PFM_ALIGNMENT,	PFM2_PARAFORMAT);
				break;
			}
			case '1':
			case '2':
			case '5':
			{
				if(!IsRich() || !IsntProtectedOrReadOnly(WM_KEYDOWN, vkey, dwFlags))
					return S_FALSE;

				CParaFormat PF;
				PF._bLineSpacingRule = tomLineSpaceMultiple;
				PF._dyLineSpacing = (vkey - '0') * 20;
				if (vkey == '5')
					PF._dyLineSpacing = 30;

				psel->SetParaFormat(&PF, publdr, PFM_LINESPACING, 0);				
				break;
			}
			default:
				break;
			}
		}

		switch(vkey)
		{
		case VK_TAB:
			return OnTxChar(VK_TAB, dwFlags, publdr);

		case VK_CLEAR:
		case VK_NUMPAD5:
		case 'A':						// Ctrl-A => pselect all
			psel->SelectAll();
			break;

		//Toggle Subscript
		case 187: // = 
		{
			if(!IsRich())
				return S_FALSE;
			ITextFont *pfont;
			psel->GetFont(&pfont);
			if (pfont)
			{
				pfont->SetSubscript(tomToggle);
				pfont->Release();
			}
		}
		break;

		case 'C':						// Ctrl-C => copy
CtrlC:		CutOrCopySelection(WM_COPY, 0, 0, NULL);
			break;

		case 'V':						// Ctrl-V => paste
CtrlV:		if(IsntProtectedOrReadOnly(WM_PASTE, 0, 0))
			{
				PasteDataObjectToRange(NULL, (CTxtRange *)psel, 0, NULL, 
					publdr, PDOR_NONE);
			}
			break;

		case 'X':						// Ctrl-X => cut
CtrlX:		CutOrCopySelection(WM_CUT, 0, 0, publdr);
			break;

		case 'Z':						// Ctrl-Z => undo
			PopAndExecuteAntiEvent(_pundo, 0);
			break;

		case 'Y':						// Ctrl-Y => redo
			PopAndExecuteAntiEvent(_predo, 0);
			break;

#if defined(DEBUG) && !defined(NOFULLDEBUG)
			void RicheditDebugCentral(void);
		case 191:
			RicheditDebugCentral();
			break;
#endif

#if defined(DOGFOOD)
		case '1':						// Shift+Ctrl+1 => start Aimm
			// Activate AIMM by posting a message to RE (Shift+Ctrl+; for now)
			if (fShift && _fInOurHost)
			{
				HWND	hWnd;

				TxGetWindow( &hWnd );

				if (hWnd)
					PostMessage(hWnd, EM_SETEDITSTYLE, SES_USEAIMM, SES_USEAIMM);
			}
			break;
#endif

		case VK_CONTROL:
			goto cont;

// English keyboard defines
#define VK_APOSTROPHE	0xDE
#define VK_GRAVE		0xC0
#define VK_SEMICOLON	0xBA
#define VK_COMMA		0xBC
#define VK_HYPHEN		0xBD

		// REVIEW: restrict VK_HYPHEN to English keyboard?
		case VK_HYPHEN:
			return OnTxChar(fShift ? NBHYPHEN : SOFTHYPHEN, dwFlags, publdr);

		case VK_SPACE:
			if(!fShift)
				goto cont;
			return OnTxChar(NBSPACE, dwFlags, publdr);

		case VK_APOSTROPHE:
			if(fShift)
				g_wFlags ^= KF_SMARTQUOTES;
			else
				nDeadKey = ACCENT_ACUTE;
			break;

		case VK_GRAVE:
			nDeadKey = fShift ? ACCENT_TILDE : ACCENT_GRAVE;
			break;

		case VK_SEMICOLON:
			nDeadKey = ACCENT_UMLAUT;
			break;

		case '6':
			if(!fShift)
				goto cont;
			nDeadKey = ACCENT_CARET;
			break;

		case VK_COMMA:
			nDeadKey = ACCENT_CEDILLA;
			break;

		default:
			goto cont;
		}
		if(nDeadKey)
		{
			// Since deadkey choices vary a bit according to keyboard, we
			// only enable them for English. French, German, Italian, and
			// Spanish keyboards already have a fair amount of accent
			// capability.
			if(PRIMARYLANGID(GetKeyboardLayout(0)) == LANG_ENGLISH)
				SetDeadKey((WORD)nDeadKey);
			else goto cont;
		}
		return S_OK;
	}

cont:	
	switch(vkey)
	{
	case VK_BACK:
	case VK_F16:
		if(_fReadOnly)
		{	
			Beep();
			fRet = TRUE;
		}
		else if(IsntProtectedOrReadOnly(WM_KEYDOWN, VK_BACK, dwFlags))
		{
			fRet = psel->Backspace(fCtrl, publdr);
		} 
		break;

	case VK_INSERT:								// Ins
		if(fShift)								// Shift-Ins
			goto CtrlV;							// Alias for Ctrl-V
		if(fCtrl)								// Ctrl-Ins
			goto CtrlC;							// Alias for Ctrl-C

		if(!_fReadOnly)							// Ins
			_fOverstrike = !_fOverstrike;		// Toggle Ins/Ovr
		fRet = TRUE;
		break;

	case VK_LEFT:								// Left arrow
	case VK_RIGHT:								// Right arrow
		fRet = (vkey == VK_LEFT) ^ (psel->GetPF()->IsRtlPara() != 0)
			 ? psel->Left (fCtrl, fShift)
			 : psel->Right(fCtrl, fShift);
		break;

	case VK_UP:									// Up arrow
		fRet = psel->Up(fCtrl, fShift);
		break;

	case VK_DOWN:								// Down arrow
		fRet = psel->Down(fCtrl, fShift);
		break;

	case VK_HOME:								// Home
		fRet = psel->Home(fCtrl, fShift);
		break;

	case VK_END:								// End
		fRet = psel->End(fCtrl, fShift);
		break;

	case VK_PRIOR:								// PgUp
		// If SystemEditMode and control is single-line, do nothing
		if(!_fSystemEditMode || _pdp->IsMultiLine())
			fRet = psel->PageUp(fCtrl, fShift);
		break;

	case VK_NEXT:								// PgDn
		// If SystemEditMode and control is single-line, do nothing
		if(!_fSystemEditMode || _pdp->IsMultiLine())
			fRet = psel->PageDown(fCtrl, fShift);
		break;

	case VK_DELETE:								// Del
		if(fShift)								// Shift-Del
			goto CtrlX;							// Alias for Ctrl-X

		if(IsntProtectedOrReadOnly(WM_KEYDOWN, VK_DELETE, dwFlags))
			psel->Delete(fCtrl, publdr);
		fRet = TRUE;
		break;

	case CONTROL('J'):							// Ctrl-Return gives Ctrl-J
	case VK_RETURN:								//  (LF), treat it as return
		// If we are in 1.0 mode we need to handle <CR>'s on WM_CHAR
		if(!Get10Mode())
		{
			fRet = InsertEOP(dwFlags, fShift, publdr);
			if(!fRet)
				return S_FALSE;
		}
		break;

	default:
		return S_FALSE;
	}

	return fRet ? S_OK : S_MSG_KEY_IGNORED;
}

/*
 *	CTxtEdit::InsertEOP(dwFlags, fShift, publdr)
 *
 *	@mfunc
 *		Handle inserting EOPs with check for hyperlinks
 *
 *	@rdesc
 *		HRESULT
 */
BOOL CTxtEdit::InsertEOP(
	DWORD		  dwFlags,	//@parm lparam of WM_KEYDOWN msg
	BOOL		  fShift,	//@parm TRUE if Shift key depressed
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{ 
	if(!_pdp->IsMultiLine())
	{
		if (!_fSystemEditMode)
			Beep();
		return FALSE;
	}
	TxSetCursor(0, NULL);

	BOOL fInLink = FALSE;
	if(!fShift)
		HandleLinkNotification(WM_CHAR, 0, 0, &fInLink);

	if(!fInLink && IsntProtectedOrReadOnly(WM_CHAR, VK_RETURN, dwFlags))
		_psel->InsertEOP(publdr, (fShift && IsRich() ? VT : 0));

	return TRUE;
}

/*
 *	CTxtEdit::CutOrCopySelection(msg, wparam, lparam, publdr)
 *
 *	@mfunc
 *		Handle WM_COPY message and its keyboard hotkey aliases
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CTxtEdit::CutOrCopySelection(
	UINT   msg,				//@parm Message (WM_CUT or WM_COPY)
	WPARAM wparam,			//@parm Message wparam for protection check
	LPARAM lparam,			//@parm Message lparam for protection check
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	Assert(msg == WM_CUT || msg == WM_COPY);

	if(!_fUsePassword && IsntProtectedOrReadOnly(msg, wparam, lparam))
	{
		CTxtSelection *psel = GetSel();
		BOOL fCopy = msg == WM_COPY;
		LONG lStreamFormat = psel->CheckTableSelection(fCopy, TRUE, NULL, RR_NO_LP_CHECK)
						   ? SFF_WRITEXTRAPAR : 0;
		return fCopy
			? _ldte.CopyRangeToClipboard((CTxtRange *)psel, lStreamFormat)
			: _ldte.CutRangeToClipboard((CTxtRange *)psel, lStreamFormat, publdr);
	}
	return NOERROR;
}

#define ENGLISH_UK	 MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK)
#define ENGLISH_EIRE MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_EIRE)

/*
 *	CTxtEdit::OnTxSpecialKeyDown(vkey, dwFlags, publdr)
 *
 *	@mfunc
 *		Handle WM_KEYDOWN message for outline mode
 *
 *	@rdesc
 *		HRESULT with the following values:
 *
 *		S_OK				if key was understood and consumed
 *		S_MSG_KEY_IGNORED	if key was understood, but not consumed
 *		S_FALSE				if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxSpecialKeyDown(
	WORD		  vkey,				//@parm Virtual key code
	DWORD		  dwFlags,			//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)			//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxSpecialKeyDown");

	HRESULT	hr = S_FALSE;					// Key not understood yet
	DWORD	dwKbdFlags = GetKeyboardFlags();
	BOOL	fUpdateFormat = TRUE;

	if(!(dwKbdFlags & (CTRL | ALT)))		// All hot keys here have at
		return S_FALSE;						//  least Ctrl or Alt

	if(((dwKbdFlags & ALT) || vkey != 'C' && vkey != 'V' && vkey != 'X') &&
	   !IsntProtectedOrReadOnly(WM_KEYDOWN, VK_BACK, dwFlags, FALSE))
	{
		return S_FALSE;
	}

	CTxtSelection * const psel = GetSel();
	if(dwKbdFlags & ALT && dwKbdFlags & CTRL)
	{
		// AltGr generates LCTRL | RALT, so don't match hot keys with
		// that combination
		if(dwKbdFlags & LCTRL && dwKbdFlags & RALT)
			return S_FALSE;

		if(vkey == 'E')
		{
			LANGID lid = LANGIDFROMLCID(GetKeyboardLayout(0));
			static const LANGID rgLangID[] =
			{
				ENGLISH_UK, ENGLISH_EIRE, LANG_POLISH, LANG_PORTUGUESE,
				LANG_HUNGARIAN, LANG_VIETNAMESE
			};
			for(LONG i = ARRAY_SIZE(rgLangID); i--; )
			{
				// Don't insert Euro if lid matches any LIDs or PLIDs in rgLangID
				if(lid == rgLangID[i] || PRIMARYLANGID(lid) == rgLangID[i])
					return S_FALSE;
			}
			if(psel->PutChar(EURO, _fOverstrike, publdr))
			{
				SetKeyboardFlag(HOTEURO);	// Setup flag to eat the next WM_CHAR w/ EURO
                hr = S_OK;
			}
		}
		else if(dwKbdFlags & SHIFT)
			switch(vkey)
			{
#ifdef ENABLE_OUTLINEVIEW
			// FUTURE: OutlineView hot keys postponed (see below)
			case 'N':						// Alt-Ctrl-N => Normal View
				hr = SetViewKind(VM_NORMAL);
				break;	
			case 'O':						// Alt-Ctrl-O => Outline View
				hr = SetViewKind(VM_OUTLINE);
				break;
#endif
			case VK_F12:					// Shift-Alt-Ctrl-F12 (in case Alt-X taken)
				hr = psel->HexToUnicode(publdr);
				break;

	#if defined(DEBUG) && !defined(NOFULLDEBUG)
			case VK_F10:					// Shift-Alt-Ctrl-F10
				OnDumpPed();
				break;

			case VK_F11:					// Shift-Alt-Ctrl-F11
				if (W32->fDebugFont())
					psel->DebugFont();
				break;
	#endif
			}
		return hr;
	}

	AssertSz(psel, "CTxtEdit::OnTxSpecialKeyDown() - No selection object !");
	CTxtRange rg(*psel);

	if(!IsRich() || !_pdp->IsMultiLine() || !(dwKbdFlags & SHIFT))
		return S_FALSE;

	if(dwKbdFlags & ALT)							// Alt+Shift hot keys
	{
		// NB: Alt and Shift-Alt with _graphics_ characters generate a
		// WM_SYSCHAR, which see

#ifdef ENABLE_OUTLINEVIEW
		// FUTURE: These are Outline related hot keys.  We will postpone these features
		// since we have several bugs related to these hot keys
		// Bug 5687, 5689, & 5691		
		switch(vkey)
		{
		case VK_LEFT:								// Left arrow
		case VK_RIGHT:								// Right arrow
			hr = rg.Promote(vkey == VK_LEFT ? 1 : -1, publdr);
			psel->Update_iFormat(-1);
			psel->Update(FALSE);
			break;

		case VK_UP:									// Up arrow
		case VK_DOWN:								// Down arrow
			hr = MoveSelection(vkey == VK_UP ? -1 : 1, publdr);
			psel->Update(TRUE);
			break;
		}
#endif
		return hr;
	}

	Assert(dwKbdFlags & CTRL && dwKbdFlags & SHIFT);

	// Ctrl+Shift hot keys
	switch(vkey)
	{

#ifdef ENABLE_OUTLINEVIEW
	// FUTUTRE: These are Outline related hot keys.  We will postpone these features
	// since we have several bugs related to these hot keys
	// Bug 5687, 5689, & 5691	
	case 'N':						// Demote to Body
		hr = rg.Promote(0, publdr);
		break;
#endif

	//Toggle superscript
	case 187: // = 
	{
		ITextFont *pfont;
		psel->GetFont(&pfont);
		if (pfont)
		{
			pfont->SetSuperscript(tomToggle);
			pfont->Release();
			hr = S_OK;
			fUpdateFormat = FALSE;
		}
		break;
	}

	case 'A':
	{
		ITextFont *pfont;
		psel->GetFont(&pfont);
		if (pfont)
		{
			pfont->SetAllCaps(tomToggle);
			pfont->Release();
			hr = S_OK;
			fUpdateFormat = FALSE;
		}
		break;
	}

	case 'L':						// Cycle numbering style
	{
		CParaFormat PF;
		DWORD dwMask = PFM_NUMBERING | PFM_OFFSET;

		PF._wNumbering = psel->GetPF()->_wNumbering + 1;
		PF._wNumbering %= tomListNumberAsUCRoman + 1;
		PF._dxOffset = 0;
		if(PF._wNumbering)
		{
			dwMask |= PFM_NUMBERINGSTYLE | PFM_NUMBERINGSTART;
			PF._wNumberingStyle = PFNS_PERIOD;
			PF._wNumberingStart = 1;
			PF._dxOffset = 360;
		}
		hr = psel->SetParaFormat(&PF, publdr, dwMask, 0);
		break;
	}
#define VK_RANGLE	190
#define VK_LANGLE	188

	case VK_RANGLE:					// '>' on US keyboards
	case VK_LANGLE:					// '<' on US keyboards
		hr = OnSetFontSize(vkey == VK_RANGLE ? 1 : -1, 0, publdr)
		   ? S_OK : S_FALSE;
		fUpdateFormat = (hr == S_FALSE);
		break;
	}

	if(hr != S_FALSE)
	{
		if (fUpdateFormat)
			psel->Update_iFormat(-1);
		psel->Update(FALSE);
	}
	return hr;
}				

/*
 *	CTxtEdit::OnTxChar (vkey, dwFlags, publdr)
 *
 *	@mfunc
 *		Handle WM_CHAR message
 *
 *	@rdesc
 *		HRESULT with the following values:
 *
 *		S_OK				if key was understood and consumed
 *		S_MSG_KEY_IGNORED	if key was understood, but not consumed
 *		S_FALSE				if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxChar(
	DWORD		  vkey,		//@parm Translated key code
	DWORD		  dwFlags,	//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxChar");

	// Reset Alt key state if needed
	if (!(HIWORD(dwFlags) & KF_ALTDOWN))
		ResetKeyboardFlag(ALT);

	DWORD dwKbdFlags = GetKeyboardFlags();
	DWORD dwFlagsPutChar = _fOverstrike | KBD_CHAR;
	if(dwKbdFlags & ALTNUMPAD)
	{
		DWORD Number = GetKeyPadNumber();
		if(Number >= 256 || vkey >= 256)
			vkey = Number;
		ResetKeyboardFlag(ALTNUMPAD | ALT0);
		dwFlagsPutChar &= ~KBD_CHAR;		// Need font binding
	}

	if (_fMouseDown || vkey == VK_ESCAPE ||	// Ctrl-Backspace generates VK_F16
		vkey == VK_BACK || vkey==VK_F16)	// Eat it since we process it
	{										//  in WM_KEYDOWN
		return S_OK;
	}

	CTxtSelection * const psel = GetSel();
	AssertSz(psel,
		"CTxtEdit::OnChar() - No selection object !");

	if(_fReadOnly && vkey != 3)				// Don't allow input if read only,
	{										//  but allow copy (Ctrl-C)
		if(vkey >= ' ')
			Beep();
		return S_MSG_KEY_IGNORED;
	}

	if(vkey >= ' ' || vkey == VK_TAB)
	{
		TxSetCursor(0, NULL);
		if(IsntProtectedOrReadOnly(WM_CHAR, vkey, dwFlags))
		{
			LONG nDeadKey = GetDeadKey();
			if(nDeadKey)
			{
				DWORD ch	  = vkey | 0x20;		// Convert to lower case
				BOOL fShift	  = vkey != ch;			//  (if ASCII letter)
				//							   a   b	c	d	 e	 f  g  h    i	j
				const static WORD chOff[] = {0xDF, 0, 0xE7, 0, 0xE7, 0, 0, 0, 0xEB, 0,
				//						k  l  m    n     o   p  q  r  s  t    u
										0, 0, 0, 0xF1, 0xF1, 0, 0, 0, 0, 0, 0xF8};
				SetDeadKey(0);
				if(!IN_RANGE('a', ch, 'u'))			// Not relevant ASCII
					return S_OK;					//  letter
	
				vkey = chOff[ch - 'a'];				// Translate to base char
				if(!vkey)							// No accents available
					return S_OK;					//  in current approach

				if(ch == 'n')
				{
					if(nDeadKey != ACCENT_TILDE)
						return S_OK;
				}
				else if(nDeadKey == ACCENT_CEDILLA)
				{
					if(ch != 'c')
						return S_OK;
				}
				else								// aeiou
				{
					vkey += (WORD)nDeadKey;
					if (nDeadKey >= ACCENT_TILDE &&	// eiu with ~ or :
						(vkey == 0xF0 || vkey & 8))		
					{
						if(nDeadKey != ACCENT_UMLAUT)// Only have umlauts
							return S_OK;
						vkey--;
					}
				}
				if(fShift)							// Convert to upper case						
					vkey &= ~0x20;					
			}
			
			// If character is LRM | RLM character, then convert vkey
			if(W32->_fLRMorRLM && IsBiDi() && IN_RANGE(0xFD, vkey, 0xFE))
				vkey = LTRMARK + (vkey - 0xFD);				

			if(dwKbdFlags & CTRL)
				dwFlagsPutChar |= KBD_CTRL;		// Need for Ctrl+TAB in tables
			psel->PutChar(vkey, dwFlagsPutChar, publdr,
						  GetAdjustedTextLength() ? 0 : LOWORD(GetKeyboardLayout(0xFFFFFFFF)));
		}
	}
	else if(Get10Mode() && (vkey == VK_RETURN || vkey == CONTROL('J')))
		InsertEOP(dwFlags, FALSE, publdr);		// 1.0 handled <CR> on WM_CHAR

#ifndef NOCOMPLEXSCRIPTS	
	if(_fHbrCaps)
	{
		 W32->ActivateKeyboard(HEBREW_INDEX);
		 _fHbrCaps = FALSE;
	}
#endif
	return S_OK;
}

/*
 *	CTxtEdit::OnTxSysChar (vkey, dwFlags, publdr)
 *
 *	@mfunc
 *		Handle WM_SYSCHAR message
 *
 *	@rdesc
 *		HRESULT with the following values:
 *
 *		S_OK				if key was understood and consumed
 *		S_MSG_KEY_IGNORED	if key was understood, but not consumed
 *		S_FALSE				if key was not understood (and not consumed)
 */
HRESULT CTxtEdit::OnTxSysChar(
	WORD		  vkey,		//@parm Translated key code
	DWORD		  dwFlags,	//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{
	if(!(HIWORD(dwFlags) & KF_ALTDOWN) ||
	   !IsntProtectedOrReadOnly(WM_KEYDOWN, vkey, dwFlags, FALSE))
	{
		return S_FALSE;
	}

	BOOL	fWholeDoc = TRUE;
	HRESULT hr = S_FALSE;
	int		level = 0;
	CTxtSelection * const psel = GetSel();

	switch(vkey)
	{
	case VK_BACK:
		return S_OK;

	case 'x':
		hr = psel->HexToUnicode(publdr);
		break;

	case 'X':
		hr = psel->UnicodeToHex(publdr);
		break;

	case '+':
	case '-':
		level = vkey == VK_ADD ? 1 : -1;
		fWholeDoc = FALSE;
		/* Fall through */
	case 'A':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		{
			CTxtRange rg(*psel);
			if(!level)
				level = vkey == 'A' ? 9 : vkey - '0';
			return rg.ExpandOutline(level, fWholeDoc);
		}
	}
	return hr;
}

HRESULT CTxtEdit::OnTxSysKeyDown(
	WORD		  vkey,				//@parm Virtual key code
	DWORD		  dwFlags,			//@parm lparam of WM_KEYDOWN msg
	IUndoBuilder *publdr)			//@parm Undobuilder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnTxSysKeyDown");

        
	if(IN_RANGE(VK_SHIFT, vkey, VK_MENU))
	{
		SetKeyboardFlag(GetKbdFlags(vkey, dwFlags));
		SetKeyPadNumber(0);				// Init keypad number to 0
		return S_FALSE;
	}

	if (StopMagellanScroll())
	    return S_FALSE;

	HRESULT hr = OnTxSpecialKeyDown(vkey, dwFlags, publdr);
	if(hr != S_FALSE)
		return hr;

	if(vkey == VK_BACK && (HIWORD(dwFlags) & KF_ALTDOWN))
	{
		if(PopAndExecuteAntiEvent(_pundo, 0) != NOERROR)
			hr = S_MSG_KEY_IGNORED;
	}
	else if(vkey == VK_F10 &&					// F10
			!(HIWORD(dwFlags) & KF_REPEAT) &&	// Key previously up
			(GetKeyboardFlags() & SHIFT))		// Shift is down
	{
		HandleKbdContextMenu();
	}

	return hr;
}

/////////////////////////////// Other system events //////////////////////////////

HRESULT CTxtEdit::OnContextMenu(LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnContextMenu");

	POINT pt;

	pt.x = LOWORD(lparam);
	pt.y = HIWORD(lparam);

	if(TxScreenToClient(&pt))
		return OnTxRButtonUp(pt.x, pt.y, 0, RB_NOSELCHECK);

	return S_FALSE;
}

/*
 *	CTxtEdit::HandleKbdContextMenu ()
 *
 *	@mfunc	decides where to put the context menu on the basis of where the
 *			the selection is.  Useful for shift-F10 and VK_APPS, where
 *			we aren't given a location.
 */
void CTxtEdit::HandleKbdContextMenu()
{
	POINTUV pt;
	RECTUV	rc;
	const CTxtSelection * const psel = GetSel();
	int RbOption = RB_DEFAULT;

	// Figure out where selection ends and put context menu near it
	if(_pdp->PointFromTp(*psel, NULL, FALSE, pt, NULL, TA_TOP) < 0)
		return;

	// Due to various factors, the result of PointFromTp doesn't land
	// in the selection in PointInSel. Therefore, we send in an override
	// here if the selection is non-degenerate and to force the result
	// and thus have the correct context menu appear.

	LONG cpMin;
	LONG cpMost;
	psel->GetRange(cpMin, cpMost);

	if (cpMin != cpMost)
	{
		RbOption = RB_FORCEINSEL;
	}

	// Make sure point is still within bounds of edit control
	_pdp->GetViewRect(rc);
	
	 //REVIEW (keithcu) What is this +2/-2???
	if (pt.u < rc.left)
		pt.u = rc.left;
	if (pt.u > rc.right - 2)
		pt.u = rc.right - 2;
	if (pt.v < rc.top)
		pt.v = rc.top;
	if (pt.v > rc.bottom - 2)
		pt.v = rc.bottom - 2;

	POINT ptxy;
	_pdp->PointFromPointuv(ptxy, pt);

	OnTxRButtonUp(ptxy.x, ptxy.y, 0, RbOption);
}


/////////////////////////////// Format Range Commands //////////////////////////////

/*
 *	CTxtEdit::OnFormatRange (pfr, prtcon, hdcMeasure,
 *							 xMeasurePerInch, yMeasurePerInch)
 *	@mfunc
 *		Format the range given by pfr
 *
 *	@comm
 *		This function inputs API cp's that may differ from the
 *		corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnFormatRange(
	FORMATRANGE * pfr, 
	SPrintControl prtcon,
	BOOL		  fSetupDC)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnFormatRange");

	LONG cpMin  = 0;
	LONG cpMost = 0;

	if(pfr)
	{
		cpMin  = GetCpFromAcp(pfr->chrg.cpMin);
		cpMost = GetCpFromAcp(pfr->chrg.cpMost);
	}
	// Even if there is 0 text, we want to print the control so that it will
	// fill the control with background color.
	// Use Adjusted Text Length.  Embedded objects using RichEdit will get the empty
	// document they expect and will create a default size document.
	if(!pfr || cpMin >= GetAdjustedTextLength() &&
		!prtcon._fPrintFromDraw)
	{	// We're done formatting, get rid of our printer's display context.
		delete _pdpPrinter;
		_pdpPrinter = NULL;

		return GetAcpFromCp(GetAdjustedTextLength());
	}

	LONG cpReturn = -1;
	BOOL fSetDCWorked = FALSE;

	// Fix MFC Print preview in mirrored control
	//
	// MFC CPreviewView sends us a mirrored rendering DC. We need to disable
	// this mirroring effect so our internal state remains consistent with user
	// action. We also need to disable mirrored window mode in CPreviewView
	// window. [wchao - 4/9/1999]
	//
	HDC  hdcLocal = pfr->hdc;

#ifndef NOCOMPLEXSCRIPTS
	DWORD dwLayout = W32GetLayout(hdcLocal);

	if (dwLayout & LAYOUT_RTL)
	{
		HWND hwndView = WindowFromDC(hdcLocal);

		if (hwndView)
		{
			DWORD	dwExStyleView = GetWindowLong(hwndView, GWL_EXSTYLE);
			
			if (dwExStyleView & WS_EX_LAYOUTRTL)
				SetWindowLong(hwndView, GWL_EXSTYLE, dwExStyleView & ~WS_EX_LAYOUTRTL);
		}

		W32SetLayout(hdcLocal, 0);
	}
#endif

	// First time in with this printer, set up a new display context.
	// IMPORTANT: proper completion of the printing process is required
	// to dispose of this context and begin a new context.
	// This is implicitly done by printing the last character, or
	// sending an EM_FORMATRANGE message with pfr equal to NULL.
	if(!_pdpPrinter)	
	{
		_pdpPrinter = new CDisplayPrinter (this, hdcLocal, &pfr->rc, prtcon);
		_pdpPrinter->Init();

		_pdpPrinter->SetWordWrap(TRUE);
		// Future: (ricksa) This is a really yucky way to pass the draw info
		// to the printer but it was quick. We want to make this better.
		_pdpPrinter->ResetDrawInfo(_pdp);

		// Set temporary zoom factor (if there is one).
		_pdpPrinter->SetTempZoomDenominator(_pdp->GetTempZoomDenominator());
	}
	else
		_pdpPrinter->SetPrintDimensions(&pfr->rc);

	LONG dxpInch = 0, dypInch = 0;
	// We set the DC everytime because it could have changed.
	if(GetDeviceCaps(hdcLocal, TECHNOLOGY) != DT_METAFILE)
	{
		// This is not a metafile so do the normal thing
		fSetDCWorked = _pdpPrinter->SetDC(hdcLocal);
	}
	else
	{
		//Forms^3 draws using screen resolution, while OLE specifies HIMETRIC
		dxpInch = fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
		dypInch = fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

		if (!fSetupDC)
		{
			RECT rc;
			rc.left = MulDiv(pfr->rcPage.left, dxpInch, LX_PER_INCH);
			rc.right = MulDiv(pfr->rcPage.right, dxpInch, LX_PER_INCH);
			rc.top = MulDiv(pfr->rcPage.top, dypInch, LY_PER_INCH);
			rc.bottom = MulDiv(pfr->rcPage.bottom, dypInch, LY_PER_INCH);

			SetWindowOrgEx(hdcLocal, rc.left, rc.top, NULL);
			SetWindowExtEx(hdcLocal, rc.right, rc.bottom, NULL);
		}

		_pdpPrinter->SetMetafileDC(hdcLocal, dxpInch, dypInch);
		fSetDCWorked = TRUE;
	}

	if(fSetDCWorked)
	{
		//It is illogical to have the target device be the screen and the presentation
		//device be a HIMETRIC metafile.
		LONG dxpInchT = -1, dypInchT = -1;
		if (dxpInch && GetDeviceCaps(pfr->hdcTarget, TECHNOLOGY) == DT_RASDISPLAY)
		{
			dxpInchT = dxpInch;
			dypInchT = dypInch;
		}

        // We set this every time because it could have changed.
        if(_pdpPrinter->SetTargetDC(pfr->hdcTarget, dxpInchT, dypInchT))
		{
			// Format another, single page worth of text.
			cpReturn = _pdpPrinter->FormatRange(cpMin, cpMost, prtcon._fDoPrint);
			if(!prtcon._fPrintFromDraw)
			{
				// After formatting, we know where the bottom is. But we only 
				// want to set this if we are writing a page rather than
				// displaying a control on the printer.
				pfr->rc.bottom = pfr->rc.top + _pdpPrinter->DYtoLY(_pdpPrinter->GetHeight());
			}
//REVIEW (keithcu) What to do here?

			// Remember this in case the host wishes to do its own banding.
			_pdpPrinter->SetPrintView(pfr->rc);	// we need to save this for OnDisplayBand.
			_pdpPrinter->SetPrintPage(pfr->rcPage);

			// If we're asked to render, then render the entire page in one go.
			if(prtcon._fDoPrint && (cpReturn > 0 || prtcon._fPrintFromDraw))
			{
				OnDisplayBand(&pfr->rc, prtcon._fPrintFromDraw);

				// Note: we can no longer call OnDisplayBand without reformatting.
				_pdpPrinter->DeleteSubLayouts(0, -1);
				_pdpPrinter->Clear(AF_DELETEMEM);
			}
		}
	}

	return cpReturn > 0 ? GetAcpFromCp(cpReturn) : cpReturn;
}

BOOL CTxtEdit::OnDisplayBand(
	const RECT *prcView,
	BOOL		fPrintFromDraw)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDisplayBand");

	HDC		hdcPrinter;
	RECT	rcView, rcPrint;
	RECTUV	rcuvView, rcuvPrint;

	// Make sure OnFormatRange was called and that it actually rendered something.
	if(!_pdpPrinter || !_pdpPrinter->Count())
		return FALSE;

	// Proportionally map to printers extents.
	_pdpPrinter->LRtoDR(rcView, *prcView, _pdpPrinter->GetTflow());

	rcPrint	= _pdpPrinter->GetPrintView();
	_pdpPrinter->LRtoDR(rcPrint, rcPrint, _pdpPrinter->GetTflow());

	_pdpPrinter->RectuvFromRect(rcuvPrint, rcPrint);
	_pdpPrinter->RectuvFromRect(rcuvView, rcView);

	// Get printer DC because we use it below.
	hdcPrinter = _pdpPrinter->GetDC();

	if(fPrintFromDraw)
	{
		// We need to take view inset into account
		_pdpPrinter->GetViewRect(rcuvPrint, &rcuvPrint);
	}

	// Render this band (if there's something to render)
	if(rcuvView.top < rcuvView.bottom)
		_pdpPrinter->Render(rcuvPrint, rcuvView);

	return TRUE;
}

//////////////////////////////// Protected ranges //////////////////////////////////
/*
 *	CTxtEdit::IsProtected (msg, wparam, lparam)
 *
 *	@mfunc
 *		Find out if selection is protected
 *
 *	@rdesc
 *		TRUE iff 1) control is read-only or 2) selection is protected and
 *		parent query says to protect
 */
BOOL CTxtEdit::IsProtected(
	UINT	msg, 		//@parm	Message id
	WPARAM	wparam, 	//@parm WPARAM from window's message
	LPARAM	lparam)		//@parm LPARAM from window's message
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtected");
	
	CHECKPROTECT chkprot = CHKPROT_EITHER;
	CTxtSelection *psel = GetSel();

	if(!psel)
		return FALSE;

	// There are a few special cases to consider, namely backspacing
	// into a protected range, deleting into a protected range, and type
	// with overstrike into a protected range.
	if(msg == WM_KEYDOWN && (wparam == VK_BACK || wparam == VK_F16))
	{
		// Check for format behind selection, if we are trying to 
		// backspace an insertion point.
		chkprot = CHKPROT_BACKWARD;
	}
	else if(msg == WM_KEYDOWN && wparam == VK_DELETE || 
		_fOverstrike && msg == WM_CHAR)
	{
		chkprot = CHKPROT_FORWARD;
	}

	// HACK ALERT: we don't do fIsDBCS protection checking for EM_REPLACESEL,
	// EM_SETCHARFORMAT, or EM_SETPARAFORMAT.  Outlook uses these APIs
	// extensively and DBCS protection checking messes them up. N.B. the
	// following if statement assumes that IsProtected returns a tri-value.
	PROTECT iProt = psel->IsProtected(chkprot);
	if (iProt == PROTECTED_YES && msg != EM_REPLACESEL && 
		msg != EM_SETCHARFORMAT && msg != EM_SETPARAFORMAT ||
		iProt == PROTECTED_ASK && _dwEventMask & ENM_PROTECTED && 
		QueryUseProtection(psel, msg, wparam, lparam))
	{
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtEdit::IsntProtectedOrReadOnly (msg, wparam, lparam, BOOL)
 *
 *	@mfunc
 *		Find out if selection isn't protected or read only. If it is, 
 *		ring bell.  For msg = WM_COPY, only protection is checked.
 *
 *	@rdesc
 *		TRUE iff 1) control isn't read-only and 2) selection either isn't
 *		protected or parent query says not to protect
 *
 *	@devnote	This function is useful for UI operations (like typing).
 */
BOOL CTxtEdit::IsntProtectedOrReadOnly(
	UINT	msg,	//@parm Message
	WPARAM	wparam,	//@parm Corresponding wparam
	LPARAM	lparam,	//@parm Corresponding lparam
	BOOL	fBeep)	//@parm OK to beep
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtectedOrReadOnly");

	if (!IsProtected(msg, wparam, lparam) &&
		(msg == WM_COPY || !_fReadOnly))	// WM_COPY only cares about
	{										//  protection
		return TRUE;
	}
	if (fBeep)
		Beep();
	return FALSE;
}

/*
 *	CTxtEdit::IsProtectedRange (msg, wparam, lparam, prg)
 *
 *	@mfunc
 *		Find out if range prg is protected
 *
 *	@rdesc
 *		TRUE iff control is read-only or range is protected and parent
 *		query says to protect
 */
BOOL CTxtEdit::IsProtectedRange(
	UINT		msg, 		//@parm	Message id
	WPARAM		wparam, 	//@parm WPARAM from window's message
	LPARAM		lparam,		//@parm LPARAM from window's message
	CTxtRange *	prg)		//@parm Range to examine
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::IsProtectedRange");
	
	PROTECT iProt = prg->IsProtected(CHKPROT_EITHER);

	if (iProt == PROTECTED_YES ||
		(iProt == PROTECTED_ASK &&  
		 (_dwEventMask & ENM_PROTECTED) &&
		 QueryUseProtection(prg, msg, wparam, lparam)))
	// N.B.  the preceding if statement assumes that IsProtected returns a tri-value
	{
		return TRUE;
	}
	return FALSE;
}

/*
 *	RegisterTypeLibrary
 *
 *	@mfunc
 *		Auxiliary function to ensure the type library is registered if Idispatch is used.
 */
void RegisterTypeLibrary( void )
{
#ifndef NOREGISTERTYPELIB
	static BOOL fOnce = FALSE;

	if (!fOnce)
	{
		CLock Lock;

		fOnce =	TRUE;

		HRESULT  hRes = NOERROR;
		WCHAR    szModulePath[MAX_PATH];
		ITypeLib *pTypeLib = NULL;

		// Obtain the path to this module's executable file
		W32->GetModuleFileName( hinstRE, szModulePath, MAX_PATH );

		// Load and register the type library resource
		if (LoadRegTypeLib(LIBID_tom, 1, 0, LANG_NEUTRAL, &pTypeLib) != NOERROR)
		{
			hRes = W32->LoadTypeLibEx(szModulePath, REGKIND_REGISTER, &pTypeLib);
		}

		if(SUCCEEDED(hRes) && pTypeLib)
		{
			pTypeLib->Release();
		}
	}
#endif
}

/////////////////////////////// Private IUnknown //////////////////////////////

HRESULT __stdcall CTxtEdit::CUnknown::QueryInterface(
	REFIID riid, 
	void **ppvObj)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::QueryInterface");

	CTxtEdit *ped = (CTxtEdit *)GETPPARENT(this, CTxtEdit, _unk);
	*ppvObj = NULL;

	if(IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITextServices)) 
		*ppvObj = (ITextServices *)ped;

	else if(IsEqualIID(riid, IID_IDispatch))
	{
		*ppvObj = (IDispatch *)ped;
		RegisterTypeLibrary();
	}

	else if(IsEqualIID(riid, IID_ITextDocument))
	{
		*ppvObj = (ITextDocument *)ped;
		// No need to do this.  It was put in for Alpha thunking.
		// A better thing to do is to force clients who need this
		// to QI for IDispatch before QI for ITextDocument
		// RegisterTypeLibrary();
	}

	else if(IsEqualIID(riid, IID_ITextDocument2))
		*ppvObj = (ITextDocument2 *)ped;

	else if(IsEqualIID(riid, IID_IRichEditOle))
		*ppvObj = (IRichEditOle *)ped;

	else if(IsEqualIID(riid, IID_IRichEditOleCallback))
	{
		// NB!! Returning this pointer in our QI is 
		// phenomenally bogus; it breaks fundamental COM
		// identity rules (granted, not many understand them!).
		// Anyway, RichEdit 1.0 did this, so we better.
		TRACEWARNSZ("Returning IRichEditOleCallback interface, COM "
			"identity rules broken!");

		*ppvObj = ped->GetRECallback();
	}

	if(*ppvObj)
	{
		((IUnknown *) *ppvObj)->AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

ULONG __stdcall	CTxtEdit::CUnknown::AddRef()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::AddRef");

	return ++_cRefs;
}

ULONG __stdcall CTxtEdit::CUnknown::Release()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::CUnknown::Release");

	// the call manager will take care of deleting our instance if appropriate.
	CTxtEdit *ped = GETPPARENT(this, CTxtEdit, _unk);
	CCallMgr callmgr(ped);

	ULONG culRefs =	--_cRefs;

	if(culRefs == 0)
	{
		// Even though we don't delete ourselves now, dump the callback
		// if we have it.  This make implementation a bit easier on clients.

		if(ped->_pobjmgr)
			ped->_pobjmgr->SetRECallback(NULL);

		// Make sure our timers are gone
		ped->TxKillTimer(RETID_AUTOSCROLL);
		ped->TxKillTimer(RETID_DRAGDROP);
		ped->TxKillTimer(RETID_BGND_RECALC);
		ped->TxKillTimer(RETID_SMOOTHSCROLL);
		ped->TxKillTimer(RETID_MAGELLANTRACK);
	}
	return culRefs;
}

/*
 *  ValidateTextRange(pstrg)
 *
 *  @func
 *	  Makes sure that an input text range structure makes sense.
 *
 *  @rdesc
 *	  Size of the buffer required to accept copy of data or -1 if all the
 *	  data in the control is requested. 
 *
 *  @comm
 *	  This is used both in this file and in the RichEditANSIWndProc
 */
LONG ValidateTextRange(
	TEXTRANGE *pstrg)		//@parm pointer to a text range structure
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "ValidateTextRange");

	// Validate that the input structure makes sense. In the first
	// place it must be big enough. Secondly, the values must sense.
	// Remember that if the cpMost field is -1 and the cpMin field
	// is 0 this means that the call wants the entire buffer. 
	if (IsBadReadPtr(pstrg, sizeof(TEXTRANGE))	||
		((pstrg->chrg.cpMost < 1 || pstrg->chrg.cpMin < 0 ||
		  pstrg->chrg.cpMost <= pstrg->chrg.cpMin) &&
		 !(pstrg->chrg.cpMost == -1 && !pstrg->chrg.cpMin)))
	{
		// This isn't valid so tell the caller we didn't copy any data
		return 0;
	}
	// Calculate size of buffer that we need on return
	return pstrg->chrg.cpMost - pstrg->chrg.cpMin;
}


////////////////////////////////////  Selection  /////////////////////////////////////

CTxtSelection * CTxtEdit::GetSel()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSel");

	if(!_psel && _pdp)
	{
		// There is no selection object available so create it.
		_psel = new CTxtSelection(_pdp);
		if(_psel)
			_psel->AddRef();					// Set reference count = 1
	}

	// It is caller's responsiblity to notice that an error occurred
	// in allocation of selection object.
	return _psel;
}

void CTxtEdit::DiscardSelection()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::DiscardSelection");

	if(_psel)
	{
		_psel->Release();
		if(_psel)
		{
			// The text services reference is not the last reference to the 
			// selection. We could keep track of the fact that text services
			// has released its reference and when text services gets a 
			// reference again, do the AddRef there so that if the last 
			// reference went away while we were still inactive, the selection
			// object would go away. However, it is seriously doubtful that 
			// such a case will be very common. Therefore, just do the simplest
			// thing and put our reference back.
			_psel->AddRef();
		}
	}
}

void CTxtEdit::GetSelRangeForRender(
	LONG *pcpSelMin,
	LONG *pcpSelMost)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetSelRangeForRender");

	// If we have no selection or we are not active and the selection
	// has been requested to be hidden, there is no selection so we
	// just return 0's.
	if(!_psel || (!_fInPlaceActive && _fHideSelection))
	{
		*pcpSelMin = 0;
		*pcpSelMost = 0;
		return;
	}

	// Otherwise return the state of the current selection.
	*pcpSelMin  = _psel->GetScrSelMin();
	*pcpSelMost = _psel->GetScrSelMost();
}

LRESULT CTxtEdit::OnGetSelText(
	WCHAR *psz)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetSelText");

	LONG cpMin  = GetSelMin();					// length + 1 for the null
	LONG cpMost = GetSelMost();
	return GetTextRange(cpMin, cpMost - cpMin + 1, psz);
}

/*
 *	CTxtEdit::OnExGetSel (pcrSel)
 *
 *	@mfunc
 *		Get the current selection acpMin, acpMost packaged in a CHARRANGE.
 *	
 *	@comm
 *		This function outputs API cp's that may differ from the
 *		corresponding internal Unicode cp's.
 */
void CTxtEdit::OnExGetSel(
	CHARRANGE *pcrSel)	//@parm Output parm to receive acpMin, acpMost
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnExGetSel");

	pcrSel->cpMin  = GetAcpFromCp(GetSelMin());
	pcrSel->cpMost = GetAcpFromCp(GetSelMost());
}

/*
 *	CTxtEdit::OnGetSel (pacpMin, pacpMost)
 *
 *	@mfunc
 *		Get the current selection acpMin, acpMost.
 *	
 *	@rdesc
 *		LRESULT = acpMost > 65535L ? -1 : MAKELRESULT(acpMin, acpMost)
 *
 *	@comm
 *		This function outputs API cp's that may differ from the
 *		corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnGetSel(
	LONG *pacpMin,		//@parm Output parm to receive acpMin
	LONG *pacpMost)		//@parm Output parm to receive acpMost
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetSel");

	CHARRANGE crSel;

	OnExGetSel(&crSel);
	if(pacpMin)
		*pacpMin = crSel.cpMin;
	if(pacpMost)
		*pacpMost = crSel.cpMost;

	return (crSel.cpMost > 65535l)	? (LRESULT) -1
				: MAKELRESULT((WORD) crSel.cpMin, (WORD) crSel.cpMost);
}

/*
 *	CTxtEdit::OnSetSel (acpMin, acpMost)
 *
 *	@mfunc
 *		Implements the EM_SETSEL message
 *
 *	Algorithm:
 *		There are three basic cases to handle
 *
 *		cpMin < 0,  cpMost ???		-- Collapse selection to insertion point
 *									   at text end if cpMost < 0 and else at
 *									   selection active end
 *		cpMin >= 0, cpMost < 0		-- select from cpMin to text end with
 *									   active end at text end
 *
 *		cpMin >= 0, cpMost >= 0		-- Treat as cpMin, cpMost with active
 *									   end at cpMost
 *
 *	@comm
 *		This function inputs API cp's that may differ from the
 *		corresponding internal Unicode cp's.
 */
LRESULT CTxtEdit::OnSetSel(
	LONG acpMin,		//@parm Input acpMin
	LONG acpMost)		//@parm Input acpMost
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetSel");

	// Since this is only called from the window proc, we are always active
	Assert(GetSel());
	
	CTxtSelection * const psel = GetSel();
	LONG cpMin, cpMost;

	if(acpMin < 0)
		cpMin = cpMost = (acpMost < 0) ? tomForward : psel->GetCp();
	else
	{
		cpMin  = GetCpFromAcp(acpMin);
		cpMost = (acpMost < 0) ? tomForward : GetCpFromAcp(acpMost);
	}
	if(Get10Mode() && cpMost < cpMin)	// In 10 mode, ensure
	{									//  cpMost >= cpMin.  In
		cpMin ^= cpMost;				//  SetSelection, we set active
		cpMost ^= cpMin;				//  end to cpMost, which can be
		cpMin ^= cpMost;				//  smaller than cpMin, in spite
	}									//  of its name.
	psel->SetSelection(cpMin, cpMost);
	return GetAcpFromCp(psel->GetCpMost());
}

///////////////////////////////  DROP FILES support  //////////////////////////////////////
#ifndef NODROPFILES

LRESULT CTxtEdit::InsertFromFile (
	LPCTSTR lpFile)
{
	REOBJECT		reobj;
	LPRICHEDITOLECALLBACK const precall = GetRECallback();
	HRESULT			hr = NOERROR;

	if(!precall)
		return E_NOINTERFACE;

	ZeroMemory(&reobj, sizeof(REOBJECT));
	reobj.cbStruct = sizeof(REOBJECT);

	// Get storage for the object from client
	hr = precall->GetNewStorage(&reobj.pstg);
	if(hr)
	{
		TRACEERRORSZ("GetNewStorage() failed.");
		goto err;
	}

	// Create an object site for new object
	hr = GetClientSite(&reobj.polesite);
	if(!reobj.polesite)
	{
		TRACEERRORSZ("GetClientSite() failed.");
		goto err;
	}
	
	hr = OleCreateLinkToFile(lpFile, IID_IOleObject, OLERENDER_DRAW,
				NULL, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);	
	if(hr)
	{
		TRACEERRORSZ("Failure creating link object.");
		goto err;
	}

 	reobj.cp = REO_CP_SELECTION;
	reobj.dvaspect = DVASPECT_CONTENT;

 	//Get object clsid
	hr = reobj.poleobj->GetUserClassID(&reobj.clsid);
	if(hr)
	{
		TRACEERRORSZ("GetUserClassID() failed.");
		goto err;
	}

	// Let client know what we're up to
	hr = precall->QueryInsertObject(&reobj.clsid, reobj.pstg,
			REO_CP_SELECTION);
	if(hr != NOERROR)
	{
		TRACEERRORSZ("QueryInsertObject() failed.");
		goto err;
	}

	hr = reobj.poleobj->SetClientSite(reobj.polesite);
	if(hr)
	{
		TRACEERRORSZ("SetClientSite() failed.");
		goto err;
	}

	if(hr = InsertObject(&reobj))
	{
		TRACEERRORSZ("InsertObject() failed.");
	}

err:
	if(reobj.poleobj)
		reobj.poleobj->Release();

	if(reobj.polesite)
		reobj.polesite->Release();

	if(reobj.pstg)
		reobj.pstg->Release();

	return hr;
}

typedef void (WINAPI*DRAGFINISH)(HDROP);
typedef UINT (WINAPI*DRAGQUERYFILEA)(HDROP, UINT, LPSTR, UINT);
typedef UINT (WINAPI*DRAGQUERYFILEW)(HDROP, UINT, LPTSTR, UINT);
typedef BOOL (WINAPI*DRAGQUERYPOINT)(HDROP, LPPOINT);

LRESULT	CTxtEdit::OnDropFiles(
	HANDLE hDropFiles)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDropFiles");

	UINT	cFiles;
	UINT	iFile;
	char	szFile[MAX_PATH];
	WCHAR	wFile[MAX_PATH];
	POINT	ptDrop;
	CTxtSelection * const psel = GetSel();
	HMODULE		hDLL = NULL;
	DRAGFINISH		fnDragFinish; 
	DRAGQUERYFILEA	fnDragQueryFileA;
	DRAGQUERYFILEW	fnDragQueryFileW;
	DRAGQUERYPOINT	fnDragQueryPoint;

	if (_fReadOnly)
		return 0;

	AssertSz((hDropFiles != NULL), "CTxtEdit::OnDropFiles invalid hDropFiles");

	// dynamic load Shell32

	hDLL = LoadLibrary (TEXT("Shell32.DLL"));
	if(hDLL)
	{
		fnDragFinish = (DRAGFINISH)GetProcAddress (hDLL, "DragFinish");
		fnDragQueryFileA = (DRAGQUERYFILEA)GetProcAddress (hDLL, "DragQueryFileA");
		fnDragQueryFileW = (DRAGQUERYFILEW)GetProcAddress (hDLL, "DragQueryFileW");
		fnDragQueryPoint = (DRAGQUERYPOINT)GetProcAddress (hDLL, "DragQueryPoint");
	}
	else
		return 0;

	if(!fnDragFinish || !fnDragQueryFileA || !fnDragQueryFileW || !fnDragQueryPoint)
	{
		AssertSz(FALSE, "Shell32 GetProcAddress failed");
		goto EXIT0;
	}

	(*fnDragQueryPoint) ((HDROP)hDropFiles, &ptDrop);
	if(W32->OnWin9x())
		cFiles = (*fnDragQueryFileA) ((HDROP)hDropFiles, (UINT)-1, NULL, 0);
	else
		cFiles = (*fnDragQueryFileW) ((HDROP)hDropFiles, (UINT)-1, NULL, 0);

	if(cFiles)
	{
		LONG		cp = 0;
		ptDrop;
		CRchTxtPtr  rtp(this);
		const CCharFormat	*pCF;		
		POINTUV		pt;

		_pdp->PointuvFromPoint(pt, ptDrop);
		if(_pdp->CpFromPoint(pt, NULL, &rtp, NULL, FALSE) >= 0)
		{
			cp = rtp.GetCp();
			pCF = rtp.GetCF();
		}
		else
		{
			LONG iCF = psel->Get_iCF();
			cp = psel->GetCp();	
			pCF = GetCharFormat(iCF);
			ReleaseFormats(iCF, -1);
		}
		
		// Notify user for dropfile
		if(_dwEventMask & ENM_DROPFILES)
		{
			ENDROPFILES endropfiles;

			endropfiles.hDrop = hDropFiles;
			endropfiles.cp = Get10Mode() ? GetAcpFromCp(cp) : cp;
			endropfiles.fProtected = !!(pCF->_dwEffects & CFE_PROTECTED);

			if(TxNotify(EN_DROPFILES, &endropfiles))
				goto EXIT;					// Ignore drop file
			
			cp = Get10Mode() ? GetCpFromAcp(endropfiles.cp) : endropfiles.cp;	// Allow callback to update cp
		}
		psel->SetCp(cp, FALSE);	
	}

	for (iFile = 0;  iFile < cFiles; iFile++)
	{
		if(W32->OnWin9x())
		{
			(*fnDragQueryFileA) ((HDROP)hDropFiles, iFile, szFile, MAX_PATH);
			MultiByteToWideChar(CP_ACP, 0, szFile, -1, 
							wFile, MAX_PATH);
		}
		else
			(*fnDragQueryFileW) ((HDROP)hDropFiles, iFile, wFile, MAX_PATH);

		InsertFromFile (wFile);
	}

EXIT:
	(*fnDragFinish) ((HDROP)hDropFiles);

EXIT0:
	FreeLibrary (hDLL);
	return 0;
}

#else // NODROPFILES

LRESULT	CTxtEdit::OnDropFiles(HANDLE hDropFiles)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDropFiles");

	return 0;
}

#endif	// NODROPFILES


///////////////////////////////  Exposable methods  //////////////////////////////////////

/*
 *	CTxtEdit::TxCharFromPos (ppt, plres)
 *
 *	@mfunc
 *		Get the acp at the point *ppt.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (CpFromPoint succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function outputs an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
HRESULT	CTxtEdit::TxCharFromPos(
	LPPOINT	 ppt,	//@parm Point to find the acp for
	LRESULT *plres)	//@parm Output parm to receive the acp
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxCharFromPos");

	if(!fInplaceActive())
	{
		// We have no valid display rectangle if this object is not active
		*plres = -1;
		return OLE_E_INVALIDRECT;
	}
	POINTUV pt;
	_pdp->PointuvFromPoint(pt, *ppt);
	*plres = _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE);
	if(*plres == -1)
		return E_FAIL;

	*plres = GetAcpFromCp(*plres);
	return S_OK;
}

/*
 *	CTxtEdit::TxPosFromChar (acp, ppt)
 *
 *	@mfunc
 *		Get the point at acp.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (PointFromTp succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function inputs an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxPosFromChar(
	LONG	acp,		//@parm Input cp to get the point for
	POINT *	ppt)		//@parm Output parm to receive the point
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxPosFromChar");

	if(!fInplaceActive())
		return OLE_E_INVALIDRECT;

	CRchTxtPtr rtp(this, GetCpFromAcp(acp));

	POINTUV pt;
	if(_pdp->PointFromTp(rtp, NULL, FALSE, pt, NULL, TA_TOP) < 0)
		return E_FAIL;

	_pdp->PointFromPointuv(*ppt, pt);

	return S_OK;
}

/*
 *	CTxtEdit::TxFindWordBreak (nFunction, acp, plres)
 *
 *	@mfunc
 *		Find word break or classify character at acp.
 *	
 *	@rdesc
 *		HRESULT = plRet ? S_OK : E_INVALIDARG
 *
 *	@comm
 *		This function inputs and exports API cp's and cch's that may differ
 *		from the internal Unicode cp's and cch's.
 */
HRESULT CTxtEdit::TxFindWordBreak(
	INT		 nFunction,	//@parm Word break function
	LONG	 acp,		//@parm Input cp
	LRESULT *plres)		//@parm	cch moved to reach break
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxFindWordBreak");

	CTxtPtr tp(this, GetCpFromAcp(acp));		// This validates cp
	LONG	cpSave = tp.GetCp();				// Save starting value
	
	if(!plres)
		return E_INVALIDARG;
	
	*plres = tp.FindWordBreak(nFunction);

	// WB_CLASSIFY and WB_ISDELIMITER return values; others return offsets
	// this function returns values, so it converts when necessary
	if(nFunction != WB_CLASSIFY && nFunction != WB_ISDELIMITER)
		*plres = GetAcpFromCp(LONG(*plres + cpSave));

	return S_OK;
}

/*
 *	INT CTxtEdit::TxWordBreakProc (pch, ich, cb, action)
 *	
 *	@func
 *		Default word break proc used in conjunction with FindWordBreak. ich
 *		is character offset (start position) in the buffer pch, which is cb
 *		bytes in length.  Possible action values are:
 *
 *	WB_CLASSIFY
 *		Returns char class and word break flags of char at start position.
 *
 *	WB_ISDELIMITER
 *		Returns TRUE iff char at start position is a delimeter.
 *
 *	WB_LEFT
 *		Finds nearest word beginning before start position using word breaks.
 *
 *	WB_LEFTBREAK
 *		Finds nearest word end before start position using word breaks.
 *		Used by CMeasurer::Measure()
 *
 *	WB_MOVEWORDLEFT
 *		Finds nearest word beginning before start position using class
 *		differences. This value is used during CTRL+LEFT key processing.
 *
 *	WB_MOVEWORDRIGHT
 *		Finds nearest word beginning after start position using class
 *		differences. This value is used during CTRL+RIGHT key processing.
 *
 *	WB_RIGHT
 *		Finds nearest word beginning after start position using word breaks.
 *		Used by CMeasurer::Measure()
 *
 *	WB_RIGHTBREAK
 *		Finds nearest word end after start position using word breaks.
 *	
 *	@rdesc
 *		Character offset from start of buffer (pch) of the word break
 */
INT CTxtEdit::TxWordBreakProc(
	WCHAR *	pch,	    //@parm Char buffer
	INT		ich,	    //@parm Char offset of _cp in buffer
	INT		cb,		    //@parm Count of bytes in buffer
	INT		action,	    //@parm Type of breaking action
	LONG    cpStart,    //@parm cp for first character in pch
	LONG	cp)		    //@parm cp associated to ich
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxWordBreakProc");

	if (_pfnWB)
	{
		// Client overrode the wordbreak proc, delegate the call to it.		
		if (!Get10Mode())
		{
		    Assert(!_fExWordBreakProc);
			//8638: return number of characters, not bytes.
		    return _pfnWB(pch, ich, CchOfCb(cb), action);
		}
#ifndef NOANSIWINDOWS
		else
		{
            int ret = 0;
            char sz[256];
            char* pach = sz;
    		if (cb >= 255)
    		    pach = new char [cb + 1];

    		// this indicates if we have to adjust the pach because the api's for
		    // EDITWORDBREAKPROCEX and EDITWORDBREAKPROC are different when looking to the left
            BOOL fAdjustPtr = _fExWordBreakProc && (action == WB_LEFT || action == WB_MOVEWORDLEFT || action == WB_LEFTBREAK);

            // RichEdit 1.0, create a buffer, translate ich and WCTMB
    		// pch into the buffer.  Need codepage to use. Then get translate
    		// return value. Translations are like GetCachFromCch() and
    		// GetCchFromCach()
            if (_fExWordBreakProc)
            {
                Assert(ich == 0 || ich == 1 || ich == CchOfCb(cb));

                // We need to adjust the cp to the starting point of the buffer
                if (!fAdjustPtr)
                {
                    cpStart += ich;
                    pch += ich;
                    cb -= (2 * ich);                    
                }

                // initialize string w/ zero's so we can determine the length of the string for later
                memset(pach, 0, cb + 1);
            }
                
			int nLen = CchOfCb(cb);
    		CRchTxtPtr rtp(this, cpStart);
    		BYTE iCharRep = rtp.GetCF()->_iCharRep;
   	        if (WideCharToMultiByte(CodePageFromCharRep(iCharRep), 0, pch, nLen, pach, cb + 1, NULL, NULL))
       	    {
       	        // Documentation stipulates we need to point to the end of the string
       	        if (fAdjustPtr)
       	            pach += strlen(pach);

        	    if (_fExWordBreakProc)
	                ret = ((EDITWORDBREAKPROCEX)_pfnWB)(pach, nLen, CharSetFromCharRep(iCharRep), action);
	            else
				{
	                ret = ((EDITWORDBREAKPROCA)_pfnWB)(pach, rtp.GetCachFromCch(ich), nLen, action);

					// Need to reset cp position because GetCachFromCch may move the cp
					if (ich)
						rtp.SetCp(cpStart);
				}
	            
	            // For WB_ISDELIMITER and WB_CLASSIFY don't need to convert back
    	        // to ich because return value represents a BOOL
    	        if (action != WB_ISDELIMITER && action != WB_CLASSIFY)
    	            ret = rtp.GetCchFromCach(ret);
            }  		

    	    // Delete any allocated memory
    	    if (pach != sz)
    		    delete [] pach;
    		return ret;
		}
#endif // NOANSIWINDOWS
	}

	LONG	cchBuff = CchOfCb(cb);
	LONG	cch = cchBuff - ich;
	WCHAR	ch;
	WORD	cType3[MAX_CLASSIFY_CHARS];
	INT		kinsokuClassifications[MAX_CLASSIFY_CHARS];
	LCID	lcid = 0;
	WORD *	pcType3;
	INT  *	pKinsoku1, *pKinsoku2;
	WORD *	pwRes;
	WORD	startType3 = 0;
	WORD	wb = 0;
	WORD	wClassifyData[MAX_CLASSIFY_CHARS];	// For batch classifying

	Assert(cchBuff < MAX_CLASSIFY_CHARS);
	Assert(ich >= 0 && ich < cchBuff);

	if(W32->OnWin9x())						// Win9x needs lcid to do conversions
	{									 	// Complete fix would break pch into
    	CFormatRunPtr rpCF(_story.GetCFRuns());//  runs <--> lcid
		rpCF.BindToCp(cp, GetTextLength());
		lcid = GetCharFormat(rpCF.GetFormat())->_lcid;
	}
	// Single character actions
	if ( action == WB_CLASSIFY )
	{
	    // 1.0 COMPATABILITY - 1.0 returned 0 for apostrohpe's
	    WCHAR ch = pch[ich];
		if (Get10Mode() && ( ch ==  0x0027 /*APOSTROPHE*/ ||
	        ch == 0xFF07 /*FULLWIDTH APOSTROPHE*/))
	    {
	        return 0;	        
	    }
		return ClassifyChar(ch, lcid);
	}

	if ( action == WB_ISDELIMITER )
		return !!(ClassifyChar(pch[ich], lcid) & WBF_BREAKLINE);

	// Batch classify buffer for whitespace and kinsoku classes
	BatchClassify(pch, cchBuff, lcid, cType3, kinsokuClassifications, wClassifyData);

#ifndef NOCOMPLEXSCRIPTS
    if (_pbrk && cp > -1)
    {
		cp -= ich;

        for (LONG cbrk = cchBuff-1; cbrk >= 0; --cbrk)
        {
            if (cp + cbrk >= 0 && _pbrk->CanBreakCp(BRK_WORD, cp + cbrk))
            {
                // Mimic class open/close in Kinsoku classification.
                kinsokuClassifications[cbrk] = brkclsOpen;
                if (cbrk > 0)
				{
                    kinsokuClassifications[cbrk-1] = brkclsClose;
                    wClassifyData[cbrk-1] |= WBF_WORDBREAKAFTER;
				}
            }
        }
    }
#endif

	// Setup pointers
	pKinsoku2 = kinsokuClassifications + ich; 		// Ptr to current  kinsoku
	pKinsoku1 = pKinsoku2 - 1;						// Ptr to previous kinsoku

	if(!(action & 1))								// WB_(MOVE)LEFTxxx
	{
		ich--;
		Assert(ich >= 0);
	}
	pwRes	 = &wClassifyData[ich];
	pcType3	 = &cType3[ich];						// for ideographics

	switch(action)
	{
	case WB_LEFT:
		for(; ich >= 0 && *pwRes & WBF_BREAKLINE;	// Skip preceding line
			ich--, pwRes--)							//  break chars
				;									// Empty loop. Then fall
													//  thru to WB_LEFTBREAK
	case WB_LEFTBREAK:
		for(; ich >= 0 && !CanBreak(*pKinsoku1, *pKinsoku2);
			ich--, pwRes--, pKinsoku1--, pKinsoku2--)
				;									// Empty loop
		if(action == WB_LEFTBREAK)					// Skip preceding line
		{											//  break chars
			for(; ich >= 0 && *pwRes & WBF_BREAKLINE;
				ich--, pwRes--)
					;								// Empty loop
		}
		return ich + 1;

	case WB_MOVEWORDLEFT:
		for(; ich >= 0 && (*pwRes & WBF_CLASS) == 2;// Skip preceding blank
			ich--, pwRes--, pcType3--)				//  chars
				;
		if(ich >= 0)								// Save starting wRes and
		{											//  startType3
			wb = *pwRes--;							// Really type1
			startType3 = *pcType3--;				// type3
			ich--;
		}
		// Skip to beginning of current word
		while(ich >= 0 && (*pwRes & WBF_CLASS) != 3 && 
            !(*pwRes & WBF_WORDBREAKAFTER) &&
			(IsSameClass(*pwRes, wb, *pcType3, startType3) ||
			!wb && ich && ((ch = pch[ich]) == '\'' || ch == RQUOTE)))
		{
			ich--, pwRes--, pcType3--;
		}
		return ich + 1;


	case WB_RIGHTBREAK:
		for(; cch > 0 && *pwRes & WBF_BREAKLINE;	// Skip any leading line
			cch--, pwRes++)							//  break chars
				;									// Empty loop
													// Fall thru to WB_RIGHT
	case WB_RIGHT:
		// Skip to end of current word
		for(; cch > 0 && !CanBreak(*pKinsoku1, *pKinsoku2);
			cch--, pKinsoku1++, pKinsoku2++, pwRes++)
				;
		if(action != WB_RIGHTBREAK)					// Skip trailing line
		{											//  break chars
			for(; cch > 0 && *pwRes & WBF_BREAKLINE;
				cch--, pwRes++)
					;
		}
		return cchBuff - cch;

	case WB_MOVEWORDRIGHT:
		if(cch <= 0)								// Nothing to do
			return ich;

		wb = *pwRes;								// Save start wRes
		startType3 = *pcType3;						//  and startType3

		// Skip to end of word
		if (startType3 & C3_IDEOGRAPH ||			// If ideographic or
			(*pwRes & WBF_CLASS) == 3)				//  tab/cell, just
		{
			cch--, pwRes++;							//  skip one char
		}
		else while(cch > 0 && 
            !(*pwRes & WBF_WORDBREAKAFTER) &&
			(IsSameClass(*pwRes, wb, *pcType3, startType3) || !wb &&
			 ((ch = pch[cchBuff - cch]) == '\'' || ch == RQUOTE)))
		{
			cch--, pwRes++, pcType3++;
		}

		for(; cch > 0 && 
			((*pwRes & WBF_CLASS) == 2 				// Skip trailing blank
            || (*pwRes & WBF_WORDBREAKAFTER)); 		// Skip Thai break after
			cch--, pwRes++)							//  chars
					;
		return cchBuff - cch;
	}

	TRACEERRSZSC("CTxtEdit::TxWordBreakProc: unknown action", action);
	return ich;
}


/*
 *	CTxtEdit::TxFindText (flags, cpMin, cpMost, pch, pcpRet)
 *
 *	@mfunc
 *		Find text in direction specified by flags starting at cpMin if
 *		forward search (flags & FR_DOWN nonzero) and cpMost if backward
 *		search.
 *
 *	@rdesc
 *		HRESULT (success) ? NOERROR : S_FALSE
 *
 *	@comm
 *		Caller is responsible for setting cpMin to the appropriate end of
 *		the selection depending on which way the search is proceding.
 */
HRESULT CTxtEdit::TxFindText(
	DWORD		flags,	 //@parm Specify FR_DOWN, FR_MATCHCASE, FR_WHOLEWORD
	LONG		cpStart, //@parm Find start cp
	LONG		cpLimit, //@parm Find limit cp 
	const WCHAR*pch,	 //@parm Null terminated string to search for
	LONG *		pcpMin,	 //@parm Out parm to receive start of matched string
	LONG *		pcpMost) //@parm Out parm to receive end of matched string
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxFindText");

	if(Get10Mode())							// RichEdit 1.0 only searches
	{
		flags |= FR_DOWN;					//  forward
		if (cpLimit < -1)
		    cpLimit = -1;
	}

	DWORD		cchText = GetTextLength();
	LONG		cchToFind;
	const BOOL	fSetCur = (cchText >= 4096);
	HCURSOR		hcur = NULL;				// Init to keep compiler happy

	Assert(pcpMin && pcpMost);

	// Validate parameters
	if(!pch || !(cchToFind = wcslen(pch)) || cpStart < 0 || cpLimit < -1)
		return E_INVALIDARG;				// Nothing to search for

	CTxtPtr	tp(this, cpStart);	  
	
	if(fSetCur)								// In case this takes a while...
		hcur = TxSetCursor(LoadCursor(0, IDC_WAIT), NULL);
	
	*pcpMin  = tp.FindText(cpLimit, flags, pch, cchToFind);
	*pcpMost = tp.GetCp();

	if(fSetCur)
		TxSetCursor(hcur, NULL);
	
	return *pcpMin >= 0 ? NOERROR : S_FALSE;
}

/*
 *	CTxtEdit::TxGetLineCount (plres)
 *
 *	@mfunc
 *		Get the line count.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (WaitForRecalc succeeded) ? S_OK : E_FAIL
 */
HRESULT CTxtEdit::TxGetLineCount(
	LRESULT *plres)		//@parm Output parm to receive line count
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetLineCount");

	AssertSz(plres, "CTxtEdit::TxGetLineCount invalid pcli");

	if(!fInplaceActive())
		return OLE_E_INVALIDRECT;

	if(!_pdp->WaitForRecalc(GetTextLength(), -1))
		return E_FAIL;

	*plres = _pdp->LineCount();
	Assert(*plres > 0);

	return S_OK;
}

/*
 *	CTxtEdit::TxLineFromCp (acp, plres)
 *
 *	@mfunc
 *		Get the line containing acp.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (LineFromCp succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function inputs an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxLineFromCp(
	LONG	 acp,		//@parm Input cp
	LRESULT *plres)		//@parm Ouput parm to receive line number
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineFromCp");

	BOOL	fAtEnd = FALSE;
	LONG	cp = 0;

	AssertSz(plres, "CTxtEdit::TxLineFromCp invalid plres");

	if(!fInplaceActive())
	{
		AssertSz(*plres == 0, 
			"CTxtEdit::TxLineFromCp error return lres not correct");
		return OLE_E_INVALIDRECT;
	}

	if(acp < 0)									// Validate cp
	{
		if(_psel)
		{
			cp = _psel->GetCpMin();
			fAtEnd = !_psel->GetCch() && _psel->CaretNotAtBOL();
		}
	}
	else
	{
		LONG cchText = GetTextLength();
		cp = GetCpFromAcp(acp);
		cp = min(cp, cchText);
	}
 
	*plres = _pdp->LineFromCp(cp, fAtEnd);

	HRESULT hr = *plres < 0 ? E_FAIL : S_OK;

	// Old messages expect 0 as a result of this call if there is an error.
	if(*plres == -1)
		*plres = 0;

	return hr;
}

/*
 *	CTxtEdit::TxLineLength (acp, plres)
 *
 *	@mfunc
 *		Get the line containing acp.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (GetSel() succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function inputs an API cp and outputs an API cch that
 *		may differ from the	corresponding internal Unicode cp and cch.
 */
HRESULT CTxtEdit::TxLineLength(
	LONG	 acp,		//@parm Input cp
	LRESULT *plres)		//@parm Output parm to receive line length 
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineLength");

	LONG cch = 0;
	LONG cp;

	AssertSz(plres, "CTxtEdit::TxLineLength Invalid plres parameter");

	if(!fInplaceActive())
		return OLE_E_INVALIDRECT;

	if(acp < 0)
	{
		if(!_psel)
			return E_FAIL;
		cch = _psel->LineLength(&cp);
	}
	else
	{
		cp = GetCpFromAcp(acp);
		if(cp <= GetAdjustedTextLength())
		{
			CLinePtr rp(_pdp);
			rp.SetCp(cp, FALSE);
			cp -= rp.GetIch();				// Goto start of line
			cch = rp.GetAdjustedLineLength();
		}
	}
	if(fCpMap())							// Can be time consuming, so
	{										//  don't do it unless asked
		CRchTxtPtr rtp(this, cp);			//  for
		cch = rtp.GetCachFromCch(cch);
	}
	*plres = cch;
	return S_OK;
}

/*
 *	CTxtEdit::TxLineIndex (acp, plres)
 *
 *	@mfunc
 *		Get the line containing acp.
 *	
 *	@rdesc
 *		HRESULT = !fInplaceActive() ? OLE_E_INVALIDRECTS_OK :
 *				  (LineCount() && WaitForRecalcIli succeeded) ? S_OK : E_FAIL
 *	@comm
 *		This function outputs an API cp that may differ from the
 *		corresponding internal Unicode cp.
 */
HRESULT CTxtEdit::TxLineIndex(
	LONG	 ili,		//@parm Line # to find acp for
	LRESULT *plres)		//@parm Output parm to receive acp
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineIndex");

	HRESULT hr;
	AssertSz(plres, "CTxtEdit::TxLineIndex invalid plres");

	*plres = -1;
	if(!fInplaceActive())
		return OLE_E_INVALIDRECT;

	if(ili == -1)
	{
		// Fetch line from the current cp.
		LRESULT lres;					// For 64-bit compatibility
		hr = TxLineFromCp(-1, &lres);
		if(hr != NOERROR)
			return hr;
		ili = (LONG)lres;
	}

	// ili is a zero-based *index*, whereas count returns the total # of lines.
	// Therefore, we use >= for our comparisions.
	if(ili >= _pdp->LineCount() && !_pdp->WaitForRecalcIli(ili))
		return E_FAIL; 

	*plres = GetAcpFromCp(_pdp->CpFromLine(ili, NULL));
	
	return S_OK;
}


///////////////////////////////////  Miscellaneous messages  ////////////////////////////////////

/*
 *	CTxtEdit::OnFindText (msg, flags, pftex)
 *
 *	@mfunc
 *		Find text.
 *	
 *	@rdesc
 *		LRESULT = succeeded ? acpmin : -1
 *
 *	@comm
 *		This function inputs and exports API cp's that may differ
 *		from the internal Unicode cp's.
 */
LRESULT CTxtEdit::OnFindText(
	UINT		msg,
	DWORD		flags,
	FINDTEXTEX *pftex)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnFindText");

	LONG cpMin, cpMost;

	if(TxFindText(flags,
				  GetCpFromAcp(pftex->chrg.cpMin),
				  GetCpFromAcp(pftex->chrg.cpMost),
				  pftex->lpstrText, &cpMin, &cpMost) != S_OK)
	{
		if(msg == EM_FINDTEXTEX || msg == EM_FINDTEXTEXW)
		{
			pftex->chrgText.cpMin  = -1;
			pftex->chrgText.cpMost = -1;
		}
		return -1;
	}

	LONG acpMin  = GetAcpFromCp(cpMin);
	if(msg == EM_FINDTEXTEX || msg == EM_FINDTEXTEXW)	// We send a message
	{													//  back to change
		pftex->chrgText.cpMin  = acpMin;				//  selection to this
		pftex->chrgText.cpMost = GetAcpFromCp(cpMost);
	}
	return (LRESULT)acpMin;
}

	
// For plain-text instances, OnGetParaFormat() and OnSetParaFormat() apply to whole story
LRESULT CTxtEdit::OnGetCharFormat(
	CHARFORMAT2 *pCF2,
	DWORD		 dwFlags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetCharFormat");

	UINT cb = pCF2->cbSize;
	UINT CodePage = 1200;

	if(!IsValidCharFormatW(pCF2))
	{
		if(!IsValidCharFormatA((CHARFORMATA *)pCF2))
			return 0;
		CodePage = GetDefaultCodePage(EM_GETCHARFORMAT);
	}

	if(dwFlags & (SCF_ASSOCIATEFONT | SCF_ASSOCIATEFONT2))
		return OnGetAssociateFont(pCF2, dwFlags);

	if(cb == sizeof(CHARFORMATW) ||	cb == sizeof(CHARFORMATA))
		dwFlags |= CFM2_CHARFORMAT;				// Tell callees that only
												//  CHARFORMAT parms needed
	CCharFormat CF;
	DWORD dwMask = CFM_ALL2;

	if(dwFlags & SCF_SELECTION)
		dwMask = GetSel()->GetCharFormat(&CF, dwFlags);
	else
		CF = *GetCharFormat(-1);

	if(dwFlags & CFM2_CHARFORMAT)				// Maintain CHARFORMAT
	{											//  compatibility
		CF._dwEffects &= CFM_EFFECTS;
		dwMask		  &= CFM_ALL;
	}

	CF.Get(pCF2, CodePage);
	pCF2->dwMask = dwMask;
	return (LRESULT)dwMask;
}

LRESULT CTxtEdit::OnGetParaFormat(
	PARAFORMAT2 *pPF2,
	DWORD		 dwFlags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetParaFormat");

	if(!IsValidParaFormat(pPF2))
		return 0;

	DWORD dwMask2 = 0;
	if(pPF2->cbSize == sizeof(PARAFORMAT))	// Tell callees that only
		dwMask2 = PFM2_PARAFORMAT;			//  PARAFORMAT parms needed

	CParaFormat PF;
	DWORD		dwMask = GetSel()->GetParaFormat(&PF, dwMask2);

	if(dwMask2 & PFM2_PARAFORMAT)
		dwMask &= PFM_ALL;

	PF.Get(pPF2);
	pPF2->dwMask = dwMask;
	return (LRESULT)dwMask;
}

/*
 *	CTxtEdit::OnSetFontSize(yPoint, publdr)
 *
 *	@mfunc
 *		Set new font height by adding yPoint to current height  
 *		and rounding according to the table in cfpf.cpp
 *
 *	@rdesc
 *		LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetFontSize(
	LONG yPoint,			//@parm # pts to add to current height
	DWORD dwFlags,			//@parm Options
	IUndoBuilder *publdr)	//@parm Undobuilder to receive antievents
{	
	// TODO: ? Return nonzero if we set a new font size for some text.

	CCharFormat CF;
	CF._yHeight = (SHORT)yPoint;

	return OnSetCharFormat(dwFlags ? dwFlags : SCF_SELECTION, &CF, publdr,
						   CFM_SIZE, CFM2_CHARFORMAT | CFM2_USABLEFONT);
}

/*
 *	CTxtEdit::OnSetFont(hfont)
 *
 *	@mfunc
 *		Set new default font from hfont
 *
 *	@rdesc
 *		LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetFont(
	HFONT hfont)			//@parm Handle of font to use for default
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetFont");

	CCharFormat	CF;
	if(FAILED(CF.InitDefault(hfont)))
		return 0;

	DWORD dwMask2 = CFM2_CHARFORMAT;
	WPARAM wparam = SCF_ALL;

	if(!GetAdjustedTextLength())
	{
		dwMask2 = CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK;
		wparam = 0;
	}

	return !FAILED(OnSetCharFormat(wparam, &CF, NULL, CFM_ALL, dwMask2));
}

/*
 *	CTxtEdit::OnSetCharFormat(wparam, pCF, publdr, dwMask, dwMask2)
 *
 *	@mfunc
 *		Set new default CCharFormat
 *
 *	@rdesc
 *		LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetCharFormat(
	WPARAM		  wparam,	//@parm Selection flag
	CCharFormat * pCF,		//@parm CCharFormat to apply
	IUndoBuilder *publdr,	//@parm Undobuilder to receive antievents
	DWORD		  dwMask,	//@parm CHARFORMAT2 mask
	DWORD		  dwMask2)	//@parm Second mask
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetCharFormat");

	// This says that if there's a selection that's protected and the
	// parent window wants protection notifications and doesn't want
	// changes with a protected selection, then return 0.  This is more
	// stringent than RE 2.0, but it's more like 1.0.
	if (_psel && _psel->IsProtected(CHKPROT_EITHER) == PROTECTED_ASK &&
		_dwEventMask & ENM_PROTECTED)
	{
		CHARFORMAT CF0;					// Selection is protected, client
										//  wants protect notifications
		CF0.cbSize = sizeof(CHARFORMAT);//  and protected mask is on
		CF0.dwEffects = pCF->_dwEffects;// Concoct CHARFORMAT for query
		CF0.dwMask = dwMask;			// Maybe need more fields...			
		if(QueryUseProtection(_psel, EM_SETCHARFORMAT, wparam, (LPARAM)&CF0))
			return 0;					// No deal
	}

	BOOL fRet = TRUE;

	AssertSz(!_fSelChangeCharFormat || IsRich(),
		"Inconsistent _fSelChangeCharFormat flag");

	if ((wparam & SCF_ALL) ||
		!_fSelChangeCharFormat && _story.GetCFRuns() && !(wparam & SCF_SELECTION))
	{	
		CTxtRange rg(this, 0, -GetTextLength());

		if(publdr)
			publdr->StopGroupTyping();

		if ((dwMask & (CFM_CHARSET | CFM_FACE)) == (CFM_CHARSET | CFM_FACE))
		{
			if(GetAdjustedTextLength())
			{
				dwMask2 |= CFM2_MATCHFONT;
				if (_fAutoFontSizeAdjust)
				{
					dwMask2 |= CFM2_ADJUSTFONTSIZE;
					if (fUseUIFont())
						dwMask2 |= CFM2_UIFONT;
				}
			}
			else
				dwMask2 |= CFM2_NOCHARSETCHECK;
		}

		fRet = (rg.SetCharFormat(pCF, 0, publdr, dwMask, dwMask2) == NOERROR);

		// If we have an insertion point, apply format to it as well
		if (_psel && !_psel->GetCch() &&
			_psel->SetCharFormat(pCF, wparam, publdr, dwMask, dwMask2) != NOERROR)
		{
			fRet = FALSE;
		}
	}
	else if(wparam & SCF_SELECTION)
	{
		// Change selection character format unless protected
		if(!_psel || !IsRich())
			return 0;

		return _psel->SetCharFormat(pCF, wparam, publdr, dwMask, dwMask2) 
				== NOERROR;
	}

	// Change default character format
	CCharFormat		   CF;					// Local CF to party on
	LONG			   iCF;					// Possible new CF index
	const CCharFormat *pCF1;				// Ptr to current default CF
	ICharFormatCache  *pICFCache = GetCharFormatCache();

	if(FAILED(pICFCache->Deref(Get_iCF(), &pCF1)))	// Get ptr to current
	{										//  default CCharFormat
		fRet = FALSE;						
		goto Update;
	}
	CF = *pCF1;								// Copy current default CF
	CF.Apply(pCF, dwMask, dwMask2);			// Modify copy
	if(FAILED(pICFCache->Cache(&CF, &iCF)))	// Cache modified copy
	{
		fRet = FALSE;
		goto Update;
	}

#ifndef NOLINESERVICES
	if (g_pols)
		g_pols->DestroyLine(NULL);
#endif

	pICFCache->Release(Get_iCF());			// Release _iCF regardless
	Set_iCF(iCF);							//  of whether _iCF = iCF,
											//  i.e., only 1 ref count
	if(_psel && !_psel->GetCch() && _psel->Get_iFormat() == -1)
		_psel->UpdateCaret(FALSE);

	if ((dwMask & (CFM_CHARSET | CFM_FACE)) == CFM_FACE &&
		!GetFontName(pCF->_iFont)[0] && GetFontName(CF._iFont)[0] &&
		IsBiDiCharRep(CF._iCharRep))
	{
		// Client requested font/charset be chosen for it according to thread
		// locale. If BiDi, then also set RTL para default
		CParaFormat PF;
		PF._wEffects = PFE_RTLPARA;
		OnSetParaFormat(SPF_SETDEFAULT, &PF, publdr, PFM_RTLPARA, PFM2_PARAFORMAT);
	}

Update:
	// FUTURE (alexgo): this may be unnecessary if the display handles
	// updating more automatically.
	_pdp->UpdateView();
	return fRet;
}

/*
 *	CTxtEdit::OnSetParaFormat(wparam, pPF, publdr, dwMask, dwMask2)
 *
 *	@mfunc
 *		Set new default CParaFormat
 *
 *	@rdesc
 *		LRESULT nonzero if success
 */
LRESULT CTxtEdit::OnSetParaFormat(
	WPARAM		 wparam,	//@parm wparam passed thru to IsProtected()
	CParaFormat *pPF,		//@parm CParaFormat to use
	IUndoBuilder *publdr,	//@parm Undobuilder to receive antievents
	DWORD		  dwMask,	//@parm CHARFORMAT2 mask
	DWORD		  dwMask2)	//@parm Second mask
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetParaFormat");

	// If we're using context direction in the control, then we disallow
	// the paragraph direction property and the alignment property (unless
	// it's for center alignment).
	if(IsStrongContext(_nContextDir) || IsStrongContext(_nContextAlign))
	{
		Assert(!IsRich());
		if(dwMask & (PFM_RTLPARA | PFM_ALIGNMENT))
		{
			if (IsStrongContext(_nContextAlign) &&
				(pPF->_bAlignment == PFA_LEFT || pPF->_bAlignment == PFA_RIGHT))
			{
				dwMask &= ~PFM_ALIGNMENT;
			}
			if(IsStrongContext(_nContextDir))
				dwMask &= ~PFM_RTLPARA;
		}
	}
	BOOL fMatchKbdToPara = FALSE;

	if(dwMask & PFM_RTLPARA)
	{
		// In plain text allow DIR changes to change DIR and ALIGNMENT
		if(!IsRich())
		{
			// Clear all para masks, except for DIR and ALIGN
			dwMask &= (PFM_RTLPARA | PFM_ALIGNMENT);
			wparam |= SPF_SETDEFAULT;
		}
		if(_psel && _fFocus)
			fMatchKbdToPara = TRUE;
	}
	if(!(wparam & SPF_SETDEFAULT))	
	{
		// If DEFAULT flag is specified, don't change selection
		if(!_psel || IsProtected(EM_SETPARAFORMAT, wparam, (LPARAM)pPF))
			return 0;

		LRESULT lres = NOERROR == (pPF->fSetStyle(dwMask, dwMask2)
			 ? _psel->SetParaStyle(pPF, publdr, dwMask)
			 : _psel->SetParaFormat(pPF, publdr, dwMask, dwMask2));

		// This is a bit funky, but basically, if the text is empty
		// then we also need to set the default paragraph format
		// (done in the code below).  Thus, if we hit a failure or
		// if the document is not empty, go ahead and return.  
		// Otherwise, fall through to the default case.
		if(!lres || GetAdjustedTextLength())
		{
			if(fMatchKbdToPara)
				_psel->MatchKeyboardToPara();
			return lres;
		}
	}

	// No text in document or (wparam & SPF_SETDEFAULT): set default format

	LONG			   iPF;						// Possible new PF index
	CParaFormat		   PF = *GetParaFormat(-1);	// Local PF to party on
	IParaFormatCache  *pPFCache = GetParaFormatCache();

	PF.Apply(pPF, dwMask, dwMask2);				// Modify copy
	if(FAILED(pPFCache->Cache(&PF, &iPF)))		// Cache modified copy
		return 0;
	pPFCache->Release(Get_iPF());				// Release _iPF regardless of
	Set_iPF(iPF);								// Update default format index

	if(PF.IsRtlPara())		
		OrCharFlags(FRTL, publdr);				// BiDi in backing store

	if(!IsRich() && dwMask & PFM_RTLPARA)		// Changing plain-text default PF
	{
		ItemizeDoc(publdr);						// causing re-itemize the whole doc.

		// (#6503) We cant undo the -1 format change in plaintext and that causes
		// many problems when we undo ReplaceRange event happening before the paragraph
		// switches. We better abandon the whole stack for now. (wchao)
		// -FUTURE- We should create an antievent for -1 PF change.
		ClearUndo(publdr);						
	}
	_pdp->UpdateView();
	if (_psel)
		_psel->UpdateCaret(!Get10Mode() || _psel->IsCaretInView());
	if(fMatchKbdToPara)
		_psel->MatchKeyboardToPara();
	return TRUE;
}


////////////////////////////////  System notifications  ////////////////////////////////

LRESULT CTxtEdit::OnSetFocus()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetFocus");

	_fFocus = TRUE;
	
	// Update our idea of the current keyboard layout
	W32->RefreshKeyboardLayout();

	InitKeyboardFlags();

	if(!_psel)
		return 0;

	// _fMouseDown may sometimes be true.
	// This can happen when somebody steals our focus when we were doing
	// something with the mouse down--like processing a click. Thus, we'll
	// never get the MouseUpMessage.
	if(_fMouseDown)
	{
		TRACEWARNSZ("Getting the focus, yet we think the mouse is down");
	}
	_fMouseDown = FALSE;

	BOOL fAutoKeyboard = _fAutoKeyboard;	// Don't change keyboard on SetFocus
	_fAutoKeyboard = FALSE;

	// BUG FIX #5369
	// Special case where we don't have a selection (or a caret). We need
	// to display something on focus so display a caret
	_psel->UpdateCaret(_fScrollCaretOnFocus, _psel->GetCch() == 0);
	_fScrollCaretOnFocus = FALSE;

	_psel->ShowSelection(TRUE);

	// If there is an in-place active object, we need to set the focus to
	// it. (In addition to the work that we do; this maintains compatibility
	// with RichEdit 1.0).
	if(_pobjmgr)
	{
		COleObject *pobj = _pobjmgr->GetInPlaceActiveObject();
		if(pobj)
		{
			IOleInPlaceObject *pipobj;
			
			if(pobj->GetIUnknown()->QueryInterface(IID_IOleInPlaceObject, 
					(void **)&pipobj) == NOERROR)
			{
				HWND hwnd;
				pipobj->GetWindow(&hwnd);

				if(hwnd)
					SetFocus(hwnd);
				pipobj->Release();
			}
		}
	}

	if(IsInPageView())
		TxInvalidate();
	TxNotify(EN_SETFOCUS, NULL);
	_fAutoKeyboard = fAutoKeyboard;			// Restore setting
	return 0;
}

LRESULT CTxtEdit::OnKillFocus()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnKillFocus");

    StopMagellanScroll();
    
	if(_pundo)
		_pundo->StopGroupTyping();

	if(_psel)
	{
		// Scroll back to beginning if necessary
		if (_fScrollCPOnKillFocus)
		{
			bool fHideSelectionLocal = _fHideSelection;

			// cannot hide Selection so cp=0 will be scroll into view.
			_fHideSelection = 0;	
			OnSetSel(0, 0);
			_fHideSelection = fHideSelectionLocal;
		}

		_psel->DeleteCaretBitmap(TRUE);	// Delete caret bitmap if one exists
		if(_fHideSelection)
			_psel->ShowSelection(FALSE);
	}

	_fFocus = FALSE;
	DestroyCaret();
	TxNotify(EN_KILLFOCUS, NULL);

	_fScrollCaretOnFocus = FALSE;		// Just to be safe, clear this
	return 0;
}


#if defined(DEBUG) && !defined(NOFULLDEBUG)
void CTxtEdit::OnDumpPed()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnDumpPed");

	char sz[256];
	CTxtSelection * const psel = GetSel();
	SELCHANGE selchg;
	CHARRANGE crg = {0, 0};

	psel->SetSelectionInfo(&selchg);

	LONG cPage = 0;
	LONG nPage = 0;
	if(_pdp->IsMultiLine() && IsInPageView())
	{
		LONG cPageMoved;
		CTxtRange rg(this, 0, 0);

		_pdp->GetPage(&nPage, 0, &crg);
		rg.Set(crg.cpMin, 0);
		rg.Expand(tomPage, NULL);
		Assert(rg.GetCpMost() == crg.cpMost);
		rg.Set(0, 0);
		rg.Move(tomPage, tomForward, &cPageMoved);
		rg.GetIndex(tomPage, &cPage);
		Assert(cPageMoved == cPage ||
			rg.GetCp() == GetAdjustedTextLength() && cPageMoved == cPage - 1);
	}

	wsprintfA(sz,
		"cchText = %ld		cchTextMost = %ld\r\n"
		"cpSelActive = %ld		cchSel = %ld\r\n"
		"wSelType = %x		# lines = %ld\r\n"
		"SysDefLCID = %lx		UserDefLCID = %lx\r\n"
		"Page = %ld			cPage = %ld\r\n"
		"cpMinPage = %ld		cpMostPage = %ld",
		GetTextLength(),	TxGetMaxLength(),
		psel->GetCp(),	psel->GetCch(),
		selchg.seltyp,	_pdp->LineCount(),
		GetSystemDefaultLCID(), GetUserDefaultLCID(),
		nPage, cPage, crg.cpMin, crg.cpMost
	);
	Tracef(TRCSEVINFO, "%s", sz);
	MessageBoxA(0, sz, "ED", MB_OK);
}
#endif					// DEBUG


///////////////////////////// Scrolling Commands //////////////////////////////////////


HRESULT CTxtEdit::TxLineScroll(
	LONG cli,
	LONG cch)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxLineScroll");

	// Currently cch does nothing in the following call, so we ignore
	// its translation from cach to cch (need to instantiate an rtp
	// for the current line
	_pdp->LineScroll(cli, cch);
	return S_OK;
}

void CTxtEdit::OnScrollCaret()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnScrollCaret");

	if(_psel)
	{
		_psel->SetForceScrollCaret(TRUE);
        _psel->UpdateCaret(TRUE);
		_psel->SetForceScrollCaret(FALSE);
	}
}


///////////////////////////////// Editing messages /////////////////////////////////

void CTxtEdit::OnClear(
	IUndoBuilder *publdr)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnClear");

	if(!_psel || TxGetReadOnly())
	{
		Beep();
		return;
	}
	
	if(_psel->GetCch() && !IsProtected(WM_CLEAR, 0, 0))
	{
		_psel->StopGroupTyping();
		_psel->ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);
	}
}

void CTxtEdit::Beep()
{
	if(_fAllowBeep)
		MessageBeep(0);
}


///////////////////////////////////  Miscellaneous  ///////////////////////////////////////////

/*
 *	CTxtEdit::ItemizeDoc(publdr, cchRange)
 *
 *	@mfunc
 *		Helper routine to itemize the cchRange size of document content
 *		called by various clients outside CTxtRange.
 */
void CTxtEdit::ItemizeDoc(
	IUndoBuilder *	publdr,
	LONG			cchRange)
{
	// If cchRange = -1, itemize the whole doc
	if (cchRange == -1)
		cchRange = GetTextLength();

	// We wouldnt itemize if the doc only contains a single EOP
	// because we dont want Check_rpPF being called when the -1
	// PF format hasnt been properly established.
	// This is kind of hack, should be removed in the future.
	//

	if(cchRange && GetAdjustedTextLength())
	{										// Only itemize if more than
		CTxtRange rg(this, 0, -cchRange);	//  final EOP
		rg.ItemizeRuns(publdr);
	}

#if 0
	// =FUTURE=
	//		Once we open SPF_SETDEFAULT to public. We shall incorporate this code.
	// Basically, one can change the default paragraph reading order at runtime. All
	// PF runs referencing to -1 PF format then need to be reassigned a new paragraph
	// level value and reitemized.(6-10-99, wchao)
	//
    if(cchRange > 0)
    {
        CTxtRange rg(this, 0, -cchRange);

		// -1 PF format may have changed.
		// We shall make sure that the level of each PF run match the reading order
		// before start itemization.
		//
		if (rg.Check_rpPF())
		{
			LONG	cchLeft = cchRange;
			LONG	cchMove = 0;
			LONG	cch;

			while (cchLeft > 0)
			{
				rg._rpPF.GetRun(0)->_level._value = rg.IsParaRTL() ? 1 : 0;

				cch = rg._rpPF.GetCchLeft();

				if (!rg._rpPF.NextRun())
					break;		// no more run

				cchMove += cch;
				cchLeft -= cch;
			}

			Assert (cchMove + cchLeft == cchRange);

			rg._rpPF.Move(-cchMove);	// fly back to cp = 0
		}

		// Now we rerun itemization
        rg.ItemizeRuns(publdr);
    }
#endif
}

/*
 *  CTxtEdit::OrCharFlags(dwFlags, publdr)
 *
 *	@mfunc
 *		Or in new char flags and activate LineServices and Uniscribe
 *		if complex script chars occur.
 */
void CTxtEdit::OrCharFlags(
    QWORD qwFlags,
    IUndoBuilder* publdr)
{
#ifndef NOCOMPLEXSCRIPTS
	// REVIEW: Should we send a notification for LS turn on?
	// Convert dwFlags to new on flags
	qwFlags &= qwFlags ^ _qwCharFlags;
	if(qwFlags)
	{
		_qwCharFlags |= qwFlags;			// Update flags

		qwFlags &= FCOMPLEX_SCRIPT;

		if(qwFlags && (_qwCharFlags & FCOMPLEX_SCRIPT) == qwFlags)
		{
			// REVIEW: Need to check if Uniscribe and LineServices are available...
			OnSetTypographyOptions(TO_ADVANCEDTYPOGRAPHY, TO_ADVANCEDTYPOGRAPHY);
			ItemizeDoc();
            // FUTURE: (#6838) We cant undo operations before the first itemization.
            ClearUndo(publdr);
			_fAutoKeyboard = IsBiDi();
		}

		UINT brk = 0;

		if (qwFlags & FNEEDWORDBREAK)
			brk += BRK_WORD;

		if (qwFlags & FNEEDCHARBREAK)
			brk += BRK_CLUSTER;

		if (brk)
		{
			CUniscribe* pusp = Getusp();

			if (!_pbrk && pusp && pusp->IsValid())
			{
				// First time detecting the script that needs word/cluster-breaker 
				// (such as Thai, Indic, Lao etc.)
				_pbrk = new CTxtBreaker(this);
				Assert(_pbrk);
			}

			if (_pbrk && _pbrk->AddBreaker(brk))
			{
				// Sync up the breaking array(s)
				_pbrk->Refresh();
			}
		}
	}
#endif
}

/*
 *	CTxtEdit::OnSetTypographyOptions(wparam, lparam)
 *
 *	@mfunc
 *		If CTxtEdit isn't a password or accelerator control and wparam
 *		differs from _bTypography, update the latter and the view.
 *
 *	@rdesc
 *		HRESULT = S_OK
 */
HRESULT CTxtEdit::OnSetTypographyOptions(
	WPARAM wparam,		//@parm Typography flags
	LPARAM lparam)		//@parm Typography mask
{
	// Validate params
	if(wparam & ~(TO_SIMPLELINEBREAK | TO_ADVANCEDTYPOGRAPHY | TO_DISABLECUSTOMTEXTOUT | TO_ADVANCEDLAYOUT))
		return E_INVALIDARG;

	DWORD dwTypography = _bTypography & ~lparam;	// Kill current flag values
	dwTypography |= wparam & lparam;				// Or in new values

	if(_cpAccelerator == -1 && _bTypography != (BYTE)dwTypography)
	{
		_bTypography = (BYTE)dwTypography;
		_pdp->InvalidateRecalc();
		TxInvalidate();
	}
	return S_OK;
}

void CTxtEdit::TxGetViewInset(
	RECTUV *prc,
	const CDisplay *pdp) const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetViewInset");
	
	// Get inset, which is in HIMETRIC
	RECTUV rcHimetric;

	if(SUCCEEDED(_phost->TxGetViewInset((RECT*) &rcHimetric)))
	{
		if(!pdp)						// If no display is specified,
			pdp = _pdp;					//  use main display

		AssertSz(pdp->IsValid(), "CTxtEdit::TxGetViewInset Device not valid");

		prc->left	= pdp->HimetricUtoDU(rcHimetric.left);
		prc->top	= pdp->HimetricVtoDV(rcHimetric.top);
		prc->right	= pdp->HimetricUtoDU(rcHimetric.right);
		prc->bottom = pdp->HimetricVtoDV(rcHimetric.bottom);
	}
	else
	{
		// The call to the host failed. While this is highly improbable, we do 
		// want to something reasonably sensible. Therefore, we will just pretend 
		// there is no inset and continue.
		ZeroMemory(prc, sizeof(RECTUV));
	}
}


//
//	helper functions. FUTURE (alexgo) maybe we should get rid of
//  some of these
//

/*	FUTURE (murrays): Unless they are called a lot, the TxGetBit routines
	might be done more compactly as:

BOOL CTxtEdit::TxGetBit(
	DWORD dwMask)
{
	DWORD dwBits = 0;
	_phost->TxGetPropertyBits(dwMask, &dwBits);
	return dwBits != 0;
}

e.g., instead of TxGetSelectionBar(), we use TxGetBit(TXTBIT_SELECTIONBAR).
If they are called a lot (like TxGetSelectionBar()), the bits should probably
be cached, since that saves a bunch of cache misses incurred in going over to
the host.

*/

BOOL CTxtEdit::IsLeftScrollbar() const	
{
	if(!_fHost2)
		return FALSE;

#ifndef NOCOMPLEXSCRIPTS
	DWORD dwStyle, dwExStyle;

	_phost->TxGetWindowStyles(&dwStyle, &dwExStyle);
	return dwExStyle & WS_EX_LEFTSCROLLBAR;
#else
	return FALSE;
#endif
}

TXTBACKSTYLE CTxtEdit::TxGetBackStyle() const					
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetBackStyle");

	TXTBACKSTYLE style = TXTBACK_OPAQUE;
	_phost->TxGetBackStyle(&style);
	return style;
}

BOOL CTxtEdit::TxGetAutoSize() const					
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetAutoSize");

	return (_dwEventMask & ENM_REQUESTRESIZE);
}

BOOL CTxtEdit::TxGetAutoWordSel() const				
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetAutoWordSel");

	DWORD dwBits = 0;
	_phost->TxGetPropertyBits(TXTBIT_AUTOWORDSEL, &dwBits);
	return dwBits != 0;
}

DWORD CTxtEdit::TxGetMaxLength() const					
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetMaxLength");

	// Keep this a DWORD in case client uses a cpMost of 0xFFFFFFFF, which is
	// admittedly a little large, at least for 32-bit address spaces!
	// tomForward would be a more reasonable max length, altho it's also
	// probably larger than possible in a 32-bit address space.
	return _cchTextMost;
}

/*
 *	CTxtEdit::TxSetMaxToMaxText(LONG cExtra)
 *
 *	@mfunc
 *		Set new maximum text length based on length of text and possibly extra chars
 *		to accomodate.
 */
void CTxtEdit::TxSetMaxToMaxText(LONG cExtra)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxSetMaxToMaxText");

	// See if we need to update the text max
	LONG cchRealLen = GetAdjustedTextLength() + cExtra;

	if(_fInOurHost && _cchTextMost < (DWORD)cchRealLen)
		_cchTextMost = cchRealLen;
}

WCHAR CTxtEdit::TxGetPasswordChar() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetPasswordChar");

	if(_fUsePassword)
	{
		WCHAR ch = L'*';
		_phost->TxGetPasswordChar(&ch);

		// We don't allow these characters as password chars
		if(ch < 32 || ch == WCH_EMBEDDING)
			return L'*';
		return ch;
	}
	return 0;
}

void CTxtEdit::TxGetClientRect(RECTUV *prc) const
{
	RECT rc;
	_phost->TxGetClientRect(&rc);
	_pdp->RectuvFromRect(*prc, rc);
}

BOOL CTxtEdit::TxShowScrollBar(INT fnBar, BOOL fShow)
{
	//Convert scrollbar bits from logical to physical
	if (IsUVerticalTflow(_pdp->GetTflow()))
		fnBar = fnBar == SB_HORZ ? SB_VERT : SB_HORZ;

	return _phost->TxShowScrollBar(fnBar, fShow);
}

BOOL CTxtEdit::TxEnableScrollBar (INT fnBar, INT fuArrowFlags)
{
	//Convert scrollbar bits from logical to physical
	if (IsUVerticalTflow(_pdp->GetTflow()))
		fnBar = fnBar == SB_HORZ ? SB_VERT : SB_HORZ;

	return _phost->TxEnableScrollBar(fnBar, fuArrowFlags);
}

BOOL CTxtEdit::TxSetScrollRange(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)
{
	//Convert scrollbar bits from logical to physical
	if (IsUVerticalTflow(_pdp->GetTflow()))
		fnBar = fnBar == SB_HORZ ? SB_VERT : SB_HORZ;

	return _phost->TxSetScrollRange(fnBar, nMinPos, nMaxPos, fRedraw);
}

BOOL CTxtEdit::TxSetScrollPos (INT fnBar, INT nPos, BOOL fRedraw)
{
	//Convert scrollbar bits from logical to physical
	if (IsUVerticalTflow(_pdp->GetTflow()))
		fnBar = fnBar == SB_HORZ ? SB_VERT : SB_HORZ;

	return _phost->TxSetScrollPos(fnBar, nPos, fRedraw);
}

BOOL CTxtEdit::TxSetCaretPos(INT u, INT v)
{
	POINTUV ptuv = {u, v};
	POINT pt;
	_pdp->PointFromPointuv(pt, ptuv);
	return _phost->TxSetCaretPos(pt.x, pt.y);
}

DWORD CTxtEdit::TxGetScrollBars() const					
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetScrollBars");

	DWORD dwScroll;
	_phost->TxGetScrollBars(&dwScroll);

	//Convert scrollbar bits from physical to logical
	if (IsUVerticalTflow(_pdp->GetTflow()))
	{
		DWORD dwScrollT = dwScroll;

		dwScroll &= ~(WS_HSCROLL | WS_VSCROLL);

		if (dwScrollT & WS_VSCROLL)
			dwScroll |= WS_HSCROLL;

		if (dwScrollT & WS_HSCROLL)
			dwScroll |= WS_VSCROLL;
	}

	return dwScroll;
}

LONG CTxtEdit::TxGetSelectionBarWidth() const				
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetSelectionBarWidth");
	
	LONG lSelBarWidth = 0;
	_phost->TxGetSelectionBarWidth(&lSelBarWidth);
	return lSelBarWidth;
}

BOOL CTxtEdit::TxGetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetWordWrap");

	DWORD dwBits = 0;
	_phost->TxGetPropertyBits(TXTBIT_WORDWRAP, &dwBits);
	return dwBits != 0;
}

BOOL CTxtEdit::TxGetSaveSelection() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::TxGetSaveSelection");

	DWORD dwBits = 0;
	_phost->TxGetPropertyBits(TXTBIT_SAVESELECTION, &dwBits);
	return dwBits != 0;
}

/* 
 *	CTxtEdit::ClearUndo()
 *
 *	@mfunc	Clear all undo buffers
 */
void CTxtEdit::ClearUndo(
	IUndoBuilder *publdr)	//@parm the current undo context (may be NULL)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::ClearUndo");

	if(_pundo)
		_pundo->ClearAll();

	if(_predo)
		_predo->ClearAll();

	if(publdr)
		publdr->Discard();
}

/////////////////////////////// ITextHost2 Extensions //////////////////////////////

/*
 *	CTxtEdit::TxIsDoubleClickPending ()
 *
 *	@mfunc	calls host via ITextHost2 to find out if double click is pending.
 *
 *	@rdesc 	TRUE/FALSE
 */
BOOL CTxtEdit::TxIsDoubleClickPending()
{
	return _fHost2 ? _phost->TxIsDoubleClickPending() : FALSE;
}			

/*
 *	CTxtEdit::TxGetWindow(phwnd)
 *
 *	@mfunc	calls host via ITextHost2 to get current window for this edit
 *			instance.  This is very helpful for	OLE object support
 *
 *	@rdesc	HRESULT
 */
HRESULT	CTxtEdit::TxGetWindow(
	HWND *phwnd)
{
	return _fHost2 ? _phost->TxGetWindow(phwnd) : E_NOINTERFACE;
}

/*
 *	CTxtEdit::TxSetForegroundWindow ()
 *
 *	@mfunc	calls host via ITextHost2 to make our window the foreground
 *			window. Used to support drag/drop.
 *
 *	@rdesc	HRESULT
 */
HRESULT	CTxtEdit::TxSetForegroundWindow()
{
	return _fHost2 ? _phost->TxSetForegroundWindow() : E_NOINTERFACE;
}

/*
 *	CTxtEdit::TxGetPalette()
 *
 *	@mfunc	calls host via ITextHost2 to get current palette
 *
 *	@rdesc	HPALETTE
 */
HPALETTE CTxtEdit::TxGetPalette()
{
	return _fHost2 ? _phost->TxGetPalette() : NULL;
}

/*
 *	CTxtEdit::TxGetFEFlags(pFEFlags)
 *
 *	@mfunc	calls host via ITextHost2 to get current FE settings
 *
 *	@rdesc	HRESULT
 */
HRESULT	CTxtEdit::TxGetFEFlags(
	LONG *pFEFlags)
{
#ifndef NOFEPROCESSING
	*pFEFlags = 0;						// In case no ITextHost2 methods

	HRESULT hResult = _fHost2 ? _phost->TxGetFEFlags(pFEFlags) : E_NOINTERFACE;

	if (hResult == NOERROR || hResult == E_NOINTERFACE)
	{
		if (Get10Mode())
			*pFEFlags |= tomRE10Mode;
		if (_fUseAtFont)
			*pFEFlags |= tomUseAtFont;
		if (_fUsePassword)
			*pFEFlags |= tomUsePassword;
		*pFEFlags |= (_pdp->GetTflow()) << 2;
	}
	return hResult;
#else
	return E_NOINTERFACE;
#endif
}

/*
 *	CTxtEdit::TxSetCursor(hcur, fText)
 *
 *	@mfunc	calls host via ITextHost2 to set cursor
 *
 *	@rdesc	HCURSOR
 */
HCURSOR CTxtEdit::TxSetCursor(
	HCURSOR	hcur,
	BOOL	fText)
{
	return _fHost2 ? _phost->TxSetCursor2(hcur, fText) : ::SetCursor(hcur);
}


//
//	Event Notification methods
//

/*
 *	CTxtEdit::TxNotify(iNotify, pv)
 *
 *	@mfunc	This function checks bit masks and sends notifications to the
 *			host.
 *
 *	@devnote	Callers should check to see if a special purpose notification
 *			method has already been provided.
 *
 *	@rdesc	S_OK, S_FALSE, or some error
 */
HRESULT CTxtEdit::TxNotify(
	DWORD iNotify, 		//@parm Notification to send
	void *pv)			//@parm Data associated with notification
{
	// First, disallow notifications that we handle elsewhere
	Assert(iNotify != EN_SELCHANGE); 	//see SetSelectionChanged
	Assert(iNotify != EN_ERRSPACE);		//see SetOutOfMemory
	Assert(iNotify != EN_CHANGE);		//see SetChangedEvent
	Assert(iNotify != EN_HSCROLL);		//see SendScrollEvent
	Assert(iNotify != EN_VSCROLL);		//see SendScrollEvent
	Assert(iNotify != EN_MAXTEXT);		//see SetMaxText
	Assert(iNotify != EN_MSGFILTER);	//this is handled specially
										// in TxSendMessage

	// Switch on the event to check masks.  

	DWORD dwMask;
	switch(iNotify)
	{
		case EN_DROPFILES:
			dwMask = ENM_DROPFILES;
			goto Notify;

		case EN_PROTECTED:
			dwMask = ENM_PROTECTED;
			goto Notify;

		case EN_REQUESTRESIZE:
			dwMask = ENM_REQUESTRESIZE;
			goto Notify;

		case EN_PARAGRAPHEXPANDED:
			dwMask = ENM_PARAGRAPHEXPANDED;
			goto Notify;

		case EN_IMECHANGE:
			if (!Get10Mode())
				return S_FALSE;
			dwMask = ENM_IMECHANGE;
			goto Notify;

		case EN_PAGECHANGE:
			dwMask = ENM_PAGECHANGE;
			goto Notify;

		case EN_UPDATE:
		    if (!Get10Mode())
		        break;
		    dwMask = ENM_UPDATE;
		    //FALL THROUGH CASE

		Notify:
			if(!(_dwEventMask & dwMask))
				return NOERROR;			
	}
	return _phost->TxNotify(iNotify, pv);
}
			
/*
 *	CTxtEdit::SendScrollEvent(iNotify)
 *
 *	@mfunc	Sends scroll event if appropriate
 *
 *	@comm	Scroll events must be sent before any view updates have
 *			been requested and only if ENM_SCROLL is set.
 */
void CTxtEdit::SendScrollEvent(
	DWORD iNotify)		//@parm Notification to send
{
	Assert(iNotify == EN_HSCROLL || iNotify == EN_VSCROLL);

	// FUTURE (alexgo/ricksa).  The display code can't really
	// handle this assert yet.  Basically, we're trying to
	// say that scrollbar notifications have to happen
	// _before_ the window is updated.  When we do the
	// display rewrite, try to handle this better.

	// Assert(_fUpdateRequested == FALSE);

	if(_dwEventMask & ENM_SCROLL)
		_phost->TxNotify(iNotify, NULL);
}

/*
 *	CTxtEdit::HandleLowFiRTF (szControl)
 *
 *	@mfunc	Handles sending EN_LOWFIRTF notifications.
 *
 *	@rdesc	TRUE if the EN_LOWFIRTF message was sent and 
 *			processed successfully.
 */
BOOL CTxtEdit::HandleLowFiRTF(
	char * szControl)		//@parm	RTF control word prompting notification
{
	if(!(_dwEventMask & ENM_LOWFIRTF))
		return FALSE;

	ENLOWFIRTF enLowFiRTF;

	ZeroMemory(&enLowFiRTF, sizeof(enLowFiRTF));
	enLowFiRTF.nmhdr.code = EN_LOWFIRTF;
	enLowFiRTF.szControl = szControl;
	return _phost->TxNotify(EN_LOWFIRTF, &enLowFiRTF) == S_FALSE;
}

/*
 *	CTxtEdit::HandleLinkNotification (msg, wparam, lparam, pfInLink)
 *
 *	@mfunc	Handles sending EN_LINK notifications.
 *
 *	@rdesc	TRUE if the EN_LINK message was sent and 
 *			processed successfully.  Typically, that means the
 *			caller should stop whatever processing it was doing.
 */
BOOL CTxtEdit::HandleLinkNotification(
	UINT	msg,		//@parm	msg prompting the link notification
	WPARAM	wparam,		//@parm wparam of the message
	LPARAM	lparam,		//@parm lparam of the message
	BOOL *	pfInLink)	//@parm if non-NULL, indicate if over a link
{
	if(pfInLink)
		*pfInLink = FALSE;

	if(!(_dwEventMask & ENM_LINK) || !_fInPlaceActive)
		return FALSE;

	LONG cp;

	if(msg == WM_CHAR)
	{
		if(!_psel->GetCp() && !_psel->GetCch())
			return FALSE;

		_psel->_rpCF.AdjustBackward();
		DWORD dwEffectsPrev = _psel->GetCF()->_dwEffects;
		_psel->_rpCF.AdjustForward();

		if (!(dwEffectsPrev & CFE_LINK) || (CFE_LINKPROTECTED | CFE_HIDDEN)
			 == (dwEffectsPrev & (CFE_LINKPROTECTED | CFE_HIDDEN)) ||
			!(_psel->GetCF()->_dwEffects & CFE_LINK))
		{
			return FALSE;
		}
		cp = _psel->GetCp();
	}
	else
	{
		HITTEST Hit;
		POINT	ptxy = {LOWORD(lparam), HIWORD(lparam)};
		POINTUV	pt;
		if(msg == WM_SETCURSOR)
		{
			GetCursorPos(&ptxy);
			if(!_phost->TxScreenToClient(&ptxy))
				return FALSE;
		}
		_pdp->PointuvFromPoint(pt, ptxy);
		cp = _pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, &Hit);

		if(Hit != HT_Link)					// Not a hyperlink
			return FALSE;
	}

	LONG	  cpMin, cpMost;			// It's a hyperlink
	ENLINK	  enlink;
	CTxtRange rg(this, cp, 0);

	ZeroMemory(&enlink, sizeof(enlink));
	enlink.nmhdr.code = EN_LINK;

	if(pfInLink)
		*pfInLink = TRUE;

	rg.SetIgnoreFormatUpdate(TRUE);
	rg.Expander(tomLink, TRUE, NULL, &cpMin, &cpMost);

	//If the previous character of a link is hidden, then
	//this came in as an RTF hyperlink field, so just export
	//the hidden text to the client to be passed to the browser.
	rg.SetCp(cpMin + 1, FALSE);
	if (rg.GetCF()->_dwEffects & CFE_HIDDEN)
	{
		rg.Expander(tomHidden, TRUE, NULL, &cpMin, &cpMost);
		rg.SetCp(cpMin, FALSE);
		WCHAR ch;

		//Go to end of hyperlink (search for k)
		if (rg.CRchTxtPtr::FindText(cpMost, FR_DOWN, L"K", 1) == -1)
			return FALSE;

		cpMin = rg.GetCp();

		//Strip off quotes and spaces
		while ((ch = rg.CRchTxtPtr::GetChar()) == ' ' || ch == '\"')
		{
			rg.Move(1, FALSE);
			cpMin++;
		}

		//Find end of hyperlink. Do not just start from the end as
		//a fldinst can contain stuff which isn't part of the hyperlink
		WCHAR chPrev = rg.CRchTxtPtr::GetPrevChar();

		if (rg.CRchTxtPtr::FindText(cpMost, FR_DOWN, &chPrev, 1) == -1)
			return FALSE;

		cpMost = rg.GetCp() - 1;
	}

	// Fill in ENLINK data structure for our EN_LINK
	// callback asking client what we should do 
	enlink.msg = msg;
	enlink.wParam = wparam;
	enlink.lParam = lparam;
	enlink.chrg.cpMin  = GetAcpFromCp(cpMin);
	enlink.chrg.cpMost = GetAcpFromCp(cpMost);

	if(msg == WM_CHAR)							// Need to send both down and up
	{											//  msgs, since Outlook responds
		enlink.msg = WM_LBUTTONDOWN;			//  to down and others to up
		_phost->TxNotify(EN_LINK, &enlink);
		enlink.msg = WM_LBUTTONUP;
	}
	return _phost->TxNotify(EN_LINK, &enlink) == S_FALSE;
}

/*
 *	CTxtEdit::QueryUseProtection(prg, msg, wparam, lparam)
 *
 *	@mfunc	sends EN_PROTECTED to the host, asking if we should continue
 *	to honor the protection on a given range of characters
 *
 *	@rdesc	TRUE if protection should be honored, FALSE otherwise
 */
BOOL CTxtEdit::QueryUseProtection(
	CTxtRange *prg,	 	//@parm range to check for
	UINT	msg,   		//@parm msg used
	WPARAM	wparam,		//@parm wparam of the msg
	LPARAM 	lparam)		//@parm lparam of the msg
{
	LONG		cpMin, cpMost;
	ENPROTECTED enp;
	BOOL		fRet = FALSE;
	CCallMgr *	pcallmgr = GetCallMgr();

	Assert(_dwEventMask & ENM_PROTECTED);

	if( pcallmgr->GetInProtected() ||
		_fSuppressNotify)		// Don't ask host if we don't want to send notification
		return FALSE;

	pcallmgr->SetInProtected(TRUE);

	ZeroMemory(&enp, sizeof(ENPROTECTED));
	
	prg->GetRange(cpMin, cpMost);

	enp.msg = msg;
	enp.wParam = wparam;
	enp.lParam = lparam;
	enp.chrg.cpMin  = GetAcpFromCp(cpMin);
	enp.chrg.cpMost = GetAcpFromCp(cpMost);

	if(_phost->TxNotify(EN_PROTECTED, &enp) == S_FALSE)
		fRet = TRUE;

	pcallmgr->SetInProtected(FALSE);

	return fRet;
}


#ifdef DEBUG
//This is a debug api used to dump the document runs.
//If a pointer to the ped is passed, it is saved and
//used.  If NULL is passed, the previously saved ped
//pointer is used.  This allows the "context" to be
//setup by a function that has access to the ped and
//DumpDoc can be called lower down in a function that
//does not have access to the ped.
extern "C" {
void DumpStory(void *ped)
{
    static CTxtEdit *pedSave = (CTxtEdit *)ped;
    if(pedSave)
    {
        CTxtStory * pStory = pedSave->GetTxtStory();
        if(pStory)
            pStory->DbgDumpStory();

		CObjectMgr * pobjmgr = pedSave->GetObjectMgr();
        if(pobjmgr)
            pobjmgr->DbgDump();
    }
}
}
#endif

/*
 *	CTxtEdit::TxGetDefaultCharFormat (pCF)
 *
 *	@mfunc	helper function to retrieve character formats from the
 *			host.  Does relevant argument checking
 *
 *	@rdesc	HRESULT
 */
HRESULT CTxtEdit::TxGetDefaultCharFormat(
	CCharFormat *pCF,		//@parm Character format to fill in
	DWORD &		 dwMask)	//@parm Mask supplied by host or default
{
	HRESULT hr = pCF->InitDefault(0);
	dwMask = CFM_ALL2;

	const CHARFORMAT2 *pCF2 = NULL;

	if (_phost->TxGetCharFormat((const CHARFORMAT **)&pCF2) != NOERROR ||
		!IsValidCharFormatW(pCF2))
	{
		return hr;
	}

	dwMask  = pCF2->dwMask;
	DWORD dwMask2 = 0;
	if(pCF2->cbSize == sizeof(CHARFORMAT))
	{
		// Suppress CHARFORMAT2 specifications (except for Forms^3 disabled)
		dwMask	&= fInOurHost() ? CFM_ALL : (CFM_ALL | CFM_DISABLED);
		dwMask2 = CFM2_CHARFORMAT;
	}

	CCharFormat CF;							// Transfer external CHARFORMAT(2)
	CF.Set(pCF2, 1200);						//  parms to internal CCharFormat
	return pCF->Apply(&CF, dwMask, dwMask2);
}

/*
 *	CTxtEdit::TxGetDefaultParaFormat (pPF)
 *
 *	@mfunc	helper function to retrieve  paragraph formats.  Does
 *			the relevant argument checking.
 *
 *	@rdesc	HRESULT
 */
HRESULT CTxtEdit::TxGetDefaultParaFormat(
	CParaFormat *pPF)		//@parm Paragraph format to fill in
{
	HRESULT hr = pPF->InitDefault(0);

	const PARAFORMAT2 *pPF2 = NULL;

	if (_phost->TxGetParaFormat((const PARAFORMAT **)&pPF2) != NOERROR ||
		!IsValidParaFormat(pPF2))
	{
		return hr;
	}

	DWORD dwMask  = pPF2->dwMask;
	DWORD dwMask2 = 0;
	if(pPF2->cbSize == sizeof(PARAFORMAT))	// Suppress all but PARAFORMAT
	{										//  specifications
		dwMask &= PFM_ALL;
		dwMask2 = PFM2_PARAFORMAT;			// Tell Apply() that PARAFORMAT
	}										//  was used

	CParaFormat PF;							// Transfer external PARAFORMAT(2)
	PF.Set(pPF2);							//  parms to internal CParaFormat
	return pPF->Apply(&PF, dwMask, dwMask2);// Apply parms identified by dwMask
}										 


/*
 *	CTxtEdit::SetContextDirection(fUseKbd)
 *
 *	@mfunc
 *		Determine the paragraph direction and/or alignment based on the context
 *		rules (direction/alignment follows first strong character in the
 *		control) and apply this direction and/or alignment to the default
 *		format.
 *
 *	@comment
 *		Context direction only works for plain text controls. Note that 
 *		this routine only switches the default CParaFormat to RTL para if it
 *		finds an RTL char. IsBiDi() will automatically be TRUE for this case,
 *		since each char is checked before entering the backing store.
 */
void CTxtEdit::SetContextDirection(
	BOOL fUseKbd)		//@parm Use keyboard to set context when CTX_NEUTRAL
{
	// It turns out that Forms^3 can send EM_SETBIDIOPTIONS even for non BiDi controls.
	// AssertSz(IsBiDi(), "CTxtEdit::SetContextDirection called for nonBiDi control");
	if(IsRich() || !IsBiDi() || _nContextDir == CTX_NONE && _nContextAlign == CTX_NONE)
		return;

	LONG	cch = GetTextLength();
	CTxtPtr tp(this, 0);
	WCHAR	ch = tp.GetChar();
	WORD	ctx = CTX_NEUTRAL;
	BOOL	fChanged = FALSE;

	// Find first strongly directional character
	while (cch && !IsStrongDirectional(MECharClass(ch)))
	{
		ch = tp.NextChar();
		cch--;
	}

	// Set new context based on first strong character
	// if no strong charactes in ctrl and have Bidi keybd, then make RTL 
	if(cch)
		ctx = IsRTL(MECharClass(ch)) ? CTX_RTL : CTX_LTR;
	else
		ctx = (W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0)))) ? CTX_RTL : CTX_LTR;
	
	// Has context direction or alignment changed?
	if (_nContextDir   != CTX_NONE && _nContextDir   != ctx ||
		_nContextAlign != CTX_NONE && _nContextAlign != ctx)
	{
		// Start with current default CParaFormat
		CParaFormat PF = *GetParaFormat(-1);

		// If direction has changed...
		if(_nContextDir != CTX_NONE && _nContextDir != ctx)
		{
			if(ctx == CTX_LTR || ctx == CTX_RTL || fUseKbd)
			{
				if (ctx == CTX_RTL ||
					ctx == CTX_NEUTRAL && W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))))
				{
					PF._wEffects |= PFE_RTLPARA;
				}
				else
				{
					Assert(ctx == CTX_LTR || ctx == CTX_NEUTRAL);
					PF._wEffects &= ~PFE_RTLPARA;
				}
				fChanged = TRUE;
			}
			_nContextDir = ctx;
		}

		// If the alignment has changed...
		if(_nContextAlign != CTX_NONE && _nContextAlign != ctx)
		{
			if(PF._bAlignment != PFA_CENTER)
			{
				if(ctx == CTX_LTR || ctx == CTX_RTL || fUseKbd)
				{
					if (ctx == CTX_RTL ||
						ctx == CTX_NEUTRAL && W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))))
					{
						PF._bAlignment = PFA_RIGHT;
					}
					else
					{
						Assert(ctx == CTX_LTR || ctx == CTX_NEUTRAL);
						PF._bAlignment = PFA_LEFT;
					}
				}
			}
			_nContextAlign = ctx;
		}

		// Modify default CParaFormat
		IParaFormatCache *pPFCache = GetParaFormatCache();
		LONG iPF;

		if(SUCCEEDED(pPFCache->Cache(&PF, &iPF)))
		{
			pPFCache->Release(Get_iPF());	// Release _iPF regardless of
			Set_iPF(iPF);					// Update default format index
	
			if (fChanged)
				ItemizeDoc(NULL);

			// Refresh display
			Assert(_pdp);
			if(!_pdp->IsPrinter())
			{
				_pdp->InvalidateRecalc();
				TxInvalidate();
			}
		}
	}

	// Reset the first strong cp.
	_cpFirstStrong = tp.GetCp();

	Assert(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE);
}

/*
 *	CTxtEdit::GetAdjustedTextLength ()
 *
 *	@mfunc
 *		retrieve text length adjusted for the default end-of-document marker
 *
 *	@rdesc
 *		Text length without final EOP
 *
 *	@devnote
 *		For Word and RichEdit compatibility, we insert a CR or CRLF at the
 *		end of every new rich-text control.  This routine calculates the
 *		length of the document _without_ this final EOD marker.
 *
 *		For 1.0 compatibility, we insert a CRLF.  However, TOM (and Word)
 *		requires that we use a CR, from 2.0 on, we do that instead.
 */
LONG CTxtEdit::GetAdjustedTextLength()
{
	LONG cchAdjText = GetTextLength();

	Assert(!Get10Mode() || IsRich());		// No RE10 plain-text controls

	if(IsRich())
		cchAdjText -= fUseCRLF() ? 2 : 1;	// Subtract cch of final EOP

	return cchAdjText;
}

/*
 *	CTxtEdit::Set10Mode()
 *
 *	@mfunc
 *		Turns on the 1.0 compatibility mode bit.  If the control is
 *		rich text, it already has a default 'CR' at the end, which
 *		needs to turn into a CRLF for compatibility with RichEdit 1.0.
 *
 *	@devnote
 *		This function should only be called _immediately_ after
 *		creation of text services and before all other work.  There
 *		are Asserts to help ensure this.  Remark (murrays): why not
 *		allow the change provided the control is empty except for the
 *		final CR?
 *
 *		FUTURE: we might want to split _f10Mode into three flags:
 *		1) _fMapCps		// API cp's are MBCS and need conversion to Unicode 
 *		2) _fCRLF		// Use CRLFs for EOPs instead of CRs
 *		3) _f10Mode		// All other RE 1.0 compatibility things
 *
 *		Category 3 includes 1) automatically using FR_DOWN in searches,
 *		2) ignoring direction in CDataTransferObj::EnumFormatEtc(),
 *		3) not resetting _fModified when switching to a new doc,
 */
void CTxtEdit::Set10Mode()
{
	CCallMgr	callmgr(this);
	_f10Mode = TRUE;

	// Make sure nothing important has happened to the control.
	// If these values are non-NULL, then somebody is probably trying
	// to put us into 1.0 mode after we've already done work as
	// a 2.0 control.	
	Assert(GetTextLength() == cchCR);
	Assert(_psel == NULL);
	Assert(_fModified == NULL);

	SetRichDocEndEOP(cchCR);

	if(!_pundo)
		CreateUndoMgr(1, US_UNDO);

	if(_pundo)
		((CUndoStack *)_pundo)->EnableSingleLevelMode();

	// Turn off dual font
	_fDualFont = FALSE;

	// Turn on auto sizing for NTFE systems
	if (OnWinNTFE())
		_fAutoFontSizeAdjust = TRUE;
}

/*
 *	CTxtEdit::SetRichDocEndEOP(cchToReplace)
 *
 *	@mfunc	Place automatic EOP at end of a rich text document.
 */
void CTxtEdit::SetRichDocEndEOP(
	LONG cchToReplace)
{
	CRchTxtPtr rtp(this, 0);

	// Assume this is a 2.0 Doc
	LONG cchEOP = cchCR;
	const WCHAR *pszEOP = szCR;

	if(_f10Mode)
	{
		// Reset update values for a 1.0 doc
		cchEOP = cchCRLF;
		pszEOP = szCRLF;
	}

	rtp.ReplaceRange(cchToReplace, cchEOP, pszEOP, NULL, -1);
	
	_fModified = FALSE;
	_fSaved = TRUE;
	GetCallMgr()->ClearChangeEvent();
}

/*
 *	CTxtEdit::PopAndExecuteAntiEvent(pundomgr, void *pAE)
 *
 *	@mfunc	Freeze display and execute anti-event
 *
 *	@rdesc	HRESULT from IUndoMgr::PopAndExecuteAntiEvent
 */
HRESULT	CTxtEdit::PopAndExecuteAntiEvent(
	IUndoMgr *pundomgr,	//@parm Undo manager to direct call to
	void  *pAE)			//@parm AntiEvent for undo manager
{
	if(!pundomgr || _fReadOnly || !_fUseUndo || !pundomgr->CanUndo())
		return S_FALSE;

	if(_fReadOnly)
		return E_ACCESSDENIED;

	HRESULT hr;
	// Let stack based classes clean up before restoring selection
	{
		CFreezeDisplay		fd(_pdp);
		CSelPhaseAdjuster	selpa(this);

		hr = pundomgr->PopAndExecuteAntiEvent(pAE);
	}

	if(_psel)
	{
		// Once undo/redo has been executed, flush insertion point formatting
		_psel->Update_iFormat(-1);
		_psel->Update(TRUE);
	}
	return hr;
}

/*
 *	CTxtEdit::PasteDataObjectToRange(pdo, prg, cf, rps, publdr, dwFlags)
 *
 *	@mfunc	Freeze display and paste object
 *
 *	@rdesc	HRESULT from IDataTransferEngine::PasteDataObjectToRange
 */
HRESULT	CTxtEdit::PasteDataObjectToRange(
	IDataObject *	pdo, 
	CTxtRange *		prg, 
	CLIPFORMAT		cf, 
	REPASTESPECIAL *rps,
	IUndoBuilder *	publdr, 
	DWORD			dwFlags)
{
	HRESULT hr = _ldte.PasteDataObjectToRange(pdo, prg, cf, rps, publdr, 
		dwFlags);

	if(_psel)
	{
#ifdef DEBUG
		_psel->Invariant();
#endif
		_psel->Update(TRUE);		   // now update the caret
	}

	return hr;
}

/*
 *	GetECDefaultHeightAndWidth (pts, hdc, lZoomNumerator, lZoomDenominator,
 *					yPixelsPerInch, pxAveWidth, pxOverhang, pxUnderhang)
 *
 *	@mfunc	Helper for host to get ave char width and height for default 
 *			character set for the control.
 *
 *	@rdesc	Height of default character set
 *
 *	@devnote:
 *			This really only s/b called by the window's host.
 */
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,			//@parm ITextServices to conver to CTxtEdit.
	HDC hdc,					//@parm DC to use for retrieving the font.
	LONG lZoomNumerator,		//@parm Zoom numerator
	LONG lZoomDenominator,		//@parm Zoom denominator
	LONG yPixelsPerInch,		//@parm Pixels per inch for hdc
	LONG *pxAveWidth,			//@parm Optional ave width of character
	LONG *pxOverhang,			//@parm Optional overhang
	LONG *pxUnderhang)			//@parm Optional underhang
{
	CLock lock;					// Uses global (shared) FontCache
	// Convert the text-edit ptr
	CTxtEdit *ped = (CTxtEdit *) pts;

	// Get the CCcs that has all the information we need
	yPixelsPerInch = MulDiv(yPixelsPerInch, lZoomNumerator, lZoomDenominator);
	CCcs *pccs = ped->GetCcs(ped->GetCharFormat(-1), yPixelsPerInch);

	if(!pccs)
		return 0;

	if(pxAveWidth)
		*pxAveWidth = pccs->_xAveCharWidth;

	if(pxOverhang)
	{
		Assert(pxUnderhang);
		pccs->GetFontOverhang(pxOverhang, pxUnderhang);
	}
	
	SHORT	yAdjustFE = pccs->AdjustFEHeight(!ped->fUseUIFont() && ped->_pdp->IsMultiLine());
	LONG yHeight = pccs->_yHeight + (yAdjustFE << 1);

	pccs->Release();						// Release the CCcs
	return yHeight;
}

/* 
 *	CTxtEdit::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *									lprcUpdate, fupScroll)
 *	@mfunc
 *		Request Text Host to scroll the content of the specified client area
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtEdit::TxScrollWindowEx(
	INT		dx, 			//@parm	Amount of horizontal scrolling
	INT		dy, 			//@parm	Amount of vertical scrolling
	LPCRECT lprcScroll, 	//@parm	Scroll rectangle
	LPCRECT lprcClip)		//@parm	Clip rectangle
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEEXTERN, "CTxtEdit::TxScrollWindowEx");

	if(_fInPlaceActive)
	{
#if !defined(NOMAGELLAN)
		CMagellanBMPStateWrap bmpOff(*this, NULL);
#endif

		_phost->TxScrollWindowEx(dx, dy, lprcScroll, lprcClip, 0, 0, SW_INVALIDATE | SW_SCROLLCHILDREN);

	}
}

/*
 *	CTxtEdit::GetAcpFromCp (cp)
 *
 *	@mfunc
 *		Get API cp (acp) from Unicode cp in this text instance. The API cp
 *		may be Unicode, in which case it equals cp, or MBCS, in which case
 *		it's greater than cp if any Unicode characters preceding cp convert
 *		to double-byte characters.  An MBCS cp is the BYTE index of a character
 *		relative to the start of the story, while a Unicode cp is the character
 *		index.  The values are the same if all charsets are represented by
 *		SBCS charsets, e.g., ASCII.  If all characters are represented by
 *		double-byte characters, then acp = 2*cp.
 *
 *	@rdesc
 *		MBCS Acp from Unicode cp in this text instance
 *
 *	@devnote
 *		This could be made more efficient by having the selection maintain
 *		the acp that corresponds to its _rpTX._cp, provided RE 1.0 mode is
 *		active.  Alternatively CTxtEdit could have a _prg that tracks this
 *		value, but at a higher cost (17 DWORDs instead of 1 per instance).
 *
 *		FUTURE: we might want to have a conversion-mode state instead of just
 *		_f10Mode, since some people might want to know use MBCS cp's even in
 *		RE 3.0.  If so, use the corresponding new state flag instead of
 *		Get10Mode() in the following.
 */
LONG CTxtEdit::GetAcpFromCp(
	LONG cp,				//@parm Unicode cp to convert to MBCS cp
	BOOL fPrecise)			//@parm fPrecise flag to get byte count for MBCS
{
	if(!(IsFE() && (fCpMap() || fPrecise)))	// RE 2.0 and higher use char-count
		return cp;							//  cp's, while RE 1.0 uses byte
											//  counts
											//  bPrecise is for Ansi Apps that want byte counts
											//  (e.g. Outlook Subject line)

	CRchTxtPtr rtp(this);					// Start at cp = 0
	return rtp.GetCachFromCch(cp);
}

LONG CTxtEdit::GetCpFromAcp(
	LONG acp,				//@parm MBCS cp to convert to Unicode cp
	BOOL fPrecise)			//@parm fPrecise flag to get Unicode cp for MBCS
{
	if( acp == -1 || !(IsFE() && (fCpMap() || fPrecise)))
		return acp;

	CRchTxtPtr rtp(this);					// Start at cp = 0
	return rtp.GetCchFromCach(acp);
}


/*
 *	CTxtEdit::GetViewKind (plres)
 *
 *	@mfunc
 *		get view mode
 *
 *	@rdesc
 *		HRESULT = (plres) ? NOERROR : E_INVALIDARG
 *
 *	@devnote
 *		This could be a TOM property method (along with SetViewMode())
 */
HRESULT CTxtEdit::GetViewKind(
	LRESULT *plres)		//@parm Out parm to receive view mode
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetViewKind");

	if(!plres)
		return E_INVALIDARG;

	*plres = IsInOutlineView() ? VM_OUTLINE
		   : IsInPageView()	   ? VM_PAGE : VM_NORMAL;
	return NOERROR;
}

/*
 *	CTxtEdit::SetViewKind (Value)
 *
 *	@mfunc
 *		Turn outline mode on or off
 *
 *	@rdesc
 *		HRESULT = IsRich() ? NOERROR : S_FALSE
 *
 *	@devnote
 *		This could be a TOM property method (along with GetViewMode())
 */
HRESULT CTxtEdit::SetViewKind(
	long Value)		//@parm Turn outline mode on/off for Value nonzero/zero
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::SetViewKind");

	CTxtSelection *psel = GetSel();
	BOOL fPageView = Value == VM_PAGE && _pdp->IsMultiLine();

	if(fPageView || Value == VM_NORMAL && IsInPageView())
	{
		_fPageView = (WORD)fPageView;
		if(!IsInOutlineView())
		{
			_pdp->Paginate(0, TRUE);
			psel->Update(TRUE);
			TxInvalidate();
			return NOERROR;
		}
	}

	if(!IsRich() || !_pdp->IsMultiLine())
		return S_FALSE;

    Value = (Value == VM_OUTLINE);			// Convert to 1/0
	if(_fOutlineView != Value)
	{
		HCURSOR	hcur = TxSetCursor(LoadCursor(0, IDC_WAIT), NULL);

		_fOutlineView = (WORD)Value;
		if(!GetAdjustedTextLength())		// No text in control: in outline
		{									//  view, use Heading 1; in normal
			CParaFormat PF;					//  view, use Normal style
			PF._sStyle = (SHORT)(IsInOutlineView()
					  ? STYLE_HEADING_1 : STYLE_NORMAL);
			psel->SetParaStyle(&PF, NULL, PFM_STYLE);
		}
		else
		{
			// There is text. Make sure there is paragraph formatting.
			_psel->Check_rpPF();
		}

		psel->CheckIfSelHasEOP(-1, 0);
		_pdp->UpdateView();
	    psel->Update(TRUE);
		TxSetCursor(hcur, NULL);
	}
	return NOERROR;
}

/*
 *	CTxtEdit::GetViewScale (pValue)
 *
 *	@mfunc
 *		get view zoom scale in percent
 *
 *	@rdesc
 *		HRESULT = (pValue) ? NOERROR : E_INVALIDARG
 *
 *	@devnote
 *		This could be a TOM property method (along with SetViewScale())
 */
HRESULT CTxtEdit::GetViewScale(
	long *pValue)		//@parm Get % zoom factor
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetViewScale");

	if(!pValue)
		return E_INVALIDARG;

	*pValue = 100;
	if(GetZoomNumerator() && GetZoomDenominator())
		*pValue = (100*GetZoomNumerator())/GetZoomDenominator();

	return NOERROR;
}

/*
 *	CTxtEdit::SetViewScale (Value)
 *
 *	@mfunc
 *		Set zoom numerator equal to the scale percentage Value and
 *		zoom denominator equal to 100
 *
 *	@rdesc
 *		NOERROR
 *
 *	@devnote
 *		This could be a TOM property method (along with GetViewScale())
 */
HRESULT CTxtEdit::SetViewScale(
	long Value)		//@parm Set view scale factor
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::SetViewScale");

	if((unsigned)Value > 2000)
		return E_INVALIDARG;

	SetZoomNumerator(Value);
	SetZoomDenominator(100);
	return NOERROR;
}

/* 
 *	CTxtEdit::UpdateOutline()
 *
 *	@mfunc
 *		Update selection and screen after ExpandOutline() operation
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
HRESULT CTxtEdit::UpdateOutline()
{
	Assert(IsInOutlineView());

	GetSel()->Update(FALSE);
    TxInvalidate();
    return NOERROR;
}

/*
 *	CTxtEdit::MoveSelection(lparam, publdr)
 *
 *	@mfunc
 *		Move selected text up/down by the number of paragraphs given by
 *		LOWORD(lparam).
 *
 *	@rdesc
 *		TRUE iff movement occurred
 */
HRESULT CTxtEdit::MoveSelection (
	LPARAM lparam,			//@parm	# paragraphs to move by
	IUndoBuilder *publdr)	//@parm undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtRange::MoveSelection");

	CFreezeDisplay	fd(_pdp);
	CTxtSelection *	psel = GetSel();
	LONG			cch;
	LONG			cchSel = psel->GetCch();
	LONG			cpMin, cpMost;
	LONG			cpSel = psel->GetCp();
	IDataObject *	pdo = NULL; 
	CTxtRange		rg(*psel); 
	LONG			cpNext = 0;
	LONG			cpCur = 0;
	BOOL			fDeleteCR = FALSE;

	if(publdr)
		publdr->StopGroupTyping();

	rg.Expander(tomParagraph, TRUE, NULL, &cpMin, &cpMost);
	CPFRunPtr rp(rg);
	cch = rp.FindExpanded();			// Include subordinate paras
	if(cch < 0)
		cch = tomForward;
	rg.Move(cch, TRUE);
	cpMost = rg.GetCpMost();

	if(lparam > 0 && cpMost == GetTextLength())
	{									
		Beep();							// Already at end
		return S_FALSE;
	}

	HRESULT hr = _ldte.RangeToDataObject(&rg, SF_RTF, &pdo);
	if(hr != NOERROR)
		goto error;

	if(lparam > 0)
		psel->EndOf(tomParagraph, FALSE, NULL);
	else
		psel->StartOf(tomParagraph, FALSE, NULL);

	cpCur = psel->GetCp();
	hr = psel->Move(tomParagraph, lparam, NULL);
	if(psel->GetCp() == cpCur)
	{
		psel->Set(cpSel, cchSel);
		Beep();
		goto error;
	}

	// Since psel->Move() calls psel->Update(), the selection is forced
	// to be in noncollapsed text. Going backward, this might leave the
	// selection just before the EOP of a paragraph, instead of being at the
	// start of the paragraph where it should be.  Going forward it may have
	// tried to reach the EOD, but was adjusted backward. This case gets
	// a bit awkward...
	if(psel->GetCp() < cpCur)					// Going backward: be sure
		psel->StartOf(tomParagraph, FALSE, NULL);//  end up at start of para

	else if(!psel->_rpTX.IsAfterEOP())			// Going forward and sel
	{											//  adjusted backward
		psel->Move(tomForward, FALSE);			// Go to final CR, insert a CR
		CTxtRange rgDel(*psel);					//  use psel because UI
		rgDel.ReplaceRange(1, szCR, publdr, SELRR_REMEMBERRANGE);
		psel->Move(1, FALSE);
		fDeleteCR = TRUE;						// Remember to delete it
	}

	cpCur = psel->GetCp();
	hr = _ldte.PasteDataObjectToRange(pdo, psel, 0, NULL, 
									  publdr, PDOR_NONE);
	if(hr != NOERROR)
		goto error;

	if(fDeleteCR)								// Delete CR (final CR becomes
	{											//  CR for this para). Don't
		CTxtRange rgDel(*psel);					//  use psel because UI
		Assert(rgDel._rpTX.IsAfterEOP());		//  restricts it's ability to
		rgDel.Delete(tomCharacter, -1, &cch);	//  delete
	}											
												
	cpNext = psel->GetCp();			
	psel->Set(cpCur, 0);
	psel->CheckOutlineLevel(publdr);
	psel->Set(cpNext, 0);
	psel->CheckOutlineLevel(publdr);

	// Now set selection anti-events. If selection preceded paste point,
	// subtract its length from redo position, since selection will get
	// deleted if we are doing a DRAGMOVE within this instance.
	cch = cpMost - cpMin;						// cch of rg
	if(cpSel < cpCur)
		cpNext -= cch;

	psel->Set(psel->GetCp() + fDeleteCR, cch);	// Include final CR

	// rg.ReplaceRange won't delete final CR, so remember if it's included
	fDeleteCR = rg.GetCpMost() == GetTextLength();
	rg.ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE);

	if(fDeleteCR)								// Needed to delete final CR
		rg.DeleteTerminatingEOP(publdr);		// Delete one immediately
												//  before it instead
	rg.CheckOutlineLevel(publdr);
	if(publdr)
	{
		HandleSelectionAEInfo(this, publdr, cpSel, cchSel, cpNext, cch,
							  SELAE_FORCEREPLACE);
	}
	hr = NOERROR;

error:
	if(pdo)
		pdo->Release();
	return hr;
}

/*
 *	CTxtEdit::OnInsertTable(ptrp, pclp)
 *
 *	@mfunc
 *		EM_INSERTTABLE acts similarly to EM_REPLACESEL for a degenerate
 *		selection (insertion point), but inserts a number of identical
 *		empty table rows instead of some plain text. Specifically
 *		it inserts ptrp->cRow empty table rows with the row and cell
 *		parameters given by ptrp and pclp, respectively.  It leaves the
 *		selection pointing to the start of the first cell in the row.  The
 *		client can then populate the table cells by pointing the selection
 *		at the cell end marks and inserting and formatting the desired text.
 *		Such text can include nested table rows, etc.
 *
 *		The format for a table row is
 *
 *		{CR ... }CR
 *
 *		where { stands for STARTGROUP (0xFFF9), CR is 0xD, } stands for
 *		ENDGROUP (0xFFFB) and ... stands for TABLEROWPARMS::cCell cell-end
 *		marks.  A cell-end mark is given by CELL (0x7), which is what Word
 *		also uses for this purposes.  For example, a row with three cells has
 *		the plain text 0xFFF9 0xD 7 7 7 0xFFFB 0xD.  The start and end group
 *		character pairs are assigned identical PARAFORMAT2 information that
 *		describes the row and cell parameters.  If rows with different
 *		parameters are needed, multiple single-row calls can be made with the
 *		desired parameters.
 *
 *	@rdesc
 *		HRESULT = S_OK if row inserted
 */
HRESULT CTxtEdit::OnInsertTable(
	TABLEROWPARMS * ptrp,	//@parm Describes table row parameters
	TABLECELLPARMS *pclp,	//@parm Describes cell parameters
	IUndoBuilder *publdr)	//@parm Undo builder to receive antievents
{
	CParaFormat		PF;
	CTxtSelection *	pSel = GetSel();
	CELLPARMS		rgCellParms[MAX_TABLE_CELLS];

	if (!ptrp || !pclp || !ptrp->cRow ||
		!IN_RANGE(1, ptrp->cCell, MAX_TABLE_CELLS) || 
		ptrp->cbRow  != sizeof(TABLEROWPARMS) ||
		ptrp->cbCell != sizeof(TABLECELLPARMS))
	{
		return E_INVALIDARG;
	}
	if(pSel->GetCch() || !IsRich() || !_pdp || !_pdp->IsMultiLine())
		return E_FAIL;

	LONG cpSelSave = pSel->GetCp();

	pSel->StopGroupTyping();
	while(pSel->GetPF()->IsTableRowDelimiter())
		pSel->AdvanceCRLF(CSC_NORMAL, FALSE);

	PF.InitDefault(0);
	PF._bTabCount	  = ptrp->cCell;
	PF._bAlignment	  = ptrp->nAlignment;
	PF._dxOffset	  = ptrp->dxCellMargin;
	PF._dxStartIndent = ptrp->dxIndent;
	PF._dyLineSpacing = ptrp->dyHeight;
	PF._wEffects	  = PFE_TABLE | PFE_TABLEROWDELIMITER;
	PF._bTableLevel	  = pSel->GetPF()->_bTableLevel + 1;

	if(ptrp->fRTL)
		PF._wEffects |= PFE_RTLPARA;
	if(ptrp->fKeep)
		PF._wEffects |= PFE_KEEP;
	if(ptrp->fKeepFollow)
		PF._wEffects |= PFE_KEEPNEXT;

	LONG uCell;
	LONG dul = 0;
	CCellColor ccr;

	for(LONG i = 0; i < ptrp->cCell; i++)
	{
		uCell = pclp->dxWidth;			// Cell width must be between
		uCell = max(0, uCell);			//  0" and 22"
		uCell = min(1440*22, uCell);
		dul += uCell;
		if(dul > 1440*22)
			return E_INVALIDARG;
		uCell += (pclp->nVertAlign << 24);
		if(pclp->fMergeTop)
			uCell |= fTopCell;
		else if(pclp->fMergePrev)
			uCell |= fLowCell;
		if(pclp->fVertical)
			uCell |= fVerticalCell;

		rgCellParms[i].uCell = uCell;

		rgCellParms[i].dxBrdrWidths = (CheckTwips(pclp->dxBrdrLeft)   << 0*8)
									+ (CheckTwips(pclp->dyBrdrTop)	  << 1*8)
									+ (CheckTwips(pclp->dxBrdrRight)  << 2*8)
									+ (CheckTwips(pclp->dyBrdrBottom) << 3*8);

		rgCellParms[i].dwColors = (ccr.GetColorIndex(pclp->crBrdrLeft)	<< 0*5)
								+ (ccr.GetColorIndex(pclp->crBrdrTop)	<< 1*5)
								+ (ccr.GetColorIndex(pclp->crBrdrRight)	<< 2*5)
								+ (ccr.GetColorIndex(pclp->crBrdrBottom)<< 3*5)
								+ (ccr.GetColorIndex(pclp->crBackPat)	<< 4*5)
								+ (ccr.GetColorIndex(pclp->crForePat)	<< 5*5);
		if(pclp->wShading > 10000)
			return E_INVALIDARG;

		rgCellParms[i].bShading = (BYTE)(pclp->wShading/50);

		if(!ptrp->fIdentCells)
			pclp++;
	}
	if(ccr._crCellCustom1)
	{
		PF._crCustom1 = ccr._crCellCustom1;
		if(ccr._crCellCustom2)
			PF._crCustom2 = ccr._crCellCustom2;
	}

	PF._iTabs = GetTabsCache()->Cache((LONG *)&rgCellParms[0],
									  ptrp->cCell * (CELL_EXTRA + 1));
	HRESULT hr = S_OK;
	for(i = ptrp->cRow; i--; )
	{
		LONG cchCells = pSel->InsertTableRow(&PF, publdr);
		if(!cchCells)
		{
			hr = E_FAIL;
			break;
		}
		pSel->Move(cchCells + 2, FALSE);	// Leave selection at end of row
	}

	GetTabsCache()->Release(PF._iTabs);
	pSel->Update(TRUE);
	if(publdr)
		HandleSelectionAEInfo(this, publdr,
			cpSelSave, 0, pSel->GetCp(), 0, SELAE_FORCEREPLACE);
	return hr;
}

/*
 *	CTxtEdit::SetReleaseHost
 *
 *	@mfunc	Handles notification that edit control must keep its
 *			reference to the host alive.
 */
void CTxtEdit::SetReleaseHost()
{
	_phost->AddRef();
	_fReleaseHost = TRUE;
}

#if !defined(NOMAGELLAN)
/*
 *	CTxtEdit::HandleMouseWheel(wparam, lparam)
 *
 *	@mfunc	Handles scrolling as a result of rotating a mouse roller wheel.
 *
 *	@rdesc	LRESULT
 */
LRESULT	CTxtEdit::HandleMouseWheel(
	WPARAM wparam,
	LPARAM lparam)
{ 	
	// This bit of global state is OK
	static LONG gcWheelDelta = 0;
	short zdelta = (short)HIWORD(wparam);
	BOOL fScrollByPages = FALSE;

	// Cancel middle mouse scrolling if it's going.
	OnTxMButtonUp(0, 0, 0);

	// Handle zoom or data zoom
	if((wparam & MK_CONTROL) == MK_CONTROL)
	{
	    // bug fix 5760
	    // prevent zooming if control is NOT rich or
	    // is a single line control
	    if (!_pdp->IsMultiLine())
	        return 0;
	        
		LONG lViewScale;
		GetViewScale(&lViewScale);
		lViewScale += (zdelta/WHEEL_DELTA) * 10;	// 10% per click
		if(lViewScale <= 500 && lViewScale >= 10)	// Word's limits
		{
			SetViewScale(lViewScale);							
			_pdp->UpdateView();
		}
		return 0;
	}

	if(wparam & (MK_SHIFT | MK_CONTROL))
		return 0;

	gcWheelDelta += zdelta;

	if(abs(gcWheelDelta) >= WHEEL_DELTA)
	{
		LONG cLineScroll = W32->GetRollerLineScrollCount();
		if(cLineScroll != -1)
			cLineScroll *= abs(gcWheelDelta)/WHEEL_DELTA;

		gcWheelDelta %= WHEEL_DELTA;

		// -1 means scroll by pages; so simply call page up/down. 
		if(cLineScroll == -1 || IsInPageView())
		{
			fScrollByPages = TRUE;
			if(_pdp)
				_pdp->VScroll(zdelta < 0 ? SB_PAGEDOWN : SB_PAGEUP, 0);
		}
		else
		{
			mouse.MagellanRollScroll(_pdp, zdelta, cLineScroll, 
				SMOOTH_ROLL_NUM, SMOOTH_ROLL_DENOM, TRUE);
		}

		// notify through the messagefilter that we scrolled
		if(_dwEventMask & ENM_SCROLLEVENTS)
		{
			MSGFILTER msgfltr;
			ZeroMemory(&msgfltr, sizeof(MSGFILTER));
			msgfltr.msg	   = WM_VSCROLL;
			msgfltr.wParam = fScrollByPages ?
								(zdelta < 0 ? SB_PAGEDOWN: SB_PAGEUP):
								(zdelta < 0 ? SB_LINEDOWN: SB_LINEUP);
			
			// We don't check the result of this call --
			// it's not a message we received and we're not going to
			// process it any further
			_phost->TxNotify(EN_MSGFILTER, &msgfltr);			
		}
		return TRUE;
	}
	return 0;
}
#endif

const int cchCorrectMax = 256; //Max characters to be autocorrected (Office spec)
const int cchFromMax = 768;

/*
 *	CTxtEdit::AutoCorrect(psel, ch, publdr)
 *
 *	@mfunc	Call the client to autocorrect the recently added word. Don't replace
 *	the recently added character in string passed to client. (We don't want to
 *	ReplaceRange a CELL character, for example.)
 */
void CTxtEdit::AutoCorrect(
	CTxtSelection *psel,
	WCHAR		   chAdd, 
	IUndoBuilder * publdr)
{
	LONG	cch = 0;
	WCHAR	pchFrom[cchFromMax + 1];
	WCHAR	pchTo[cchCorrectMax + 1];
	CTxtPtr	tp(psel->_rpTX);
	WCHAR	chPrev = tp.GetPrevChar();
	BOOL	fCheckIsLink = (L':' == chPrev || L'.' == chPrev) && GetDetectURL();

	for(LONG i = 4; i-- && tp.GetCp(); )
	{
		LONG cchWord =  -tp.FindWordBreak(WB_MOVEWORDLEFT);
		if (i == 2 && fCheckIsLink)
		{
			BOOL fURLLeadin = FALSE;
			GetDetectURL()->IsURL(tp, cchWord + 1, &fURLLeadin);
			if(fURLLeadin)
				return;	
		}
		if(cch + cchWord > cchFromMax)		// Don't bite off more than
			break;							//  buffer can chew

		cch += cchWord;
		if (IsEOP(tp.GetPrevChar()))		// Don't autocorrect across an EOP
			break;
	}
	// Be sure we don't go into hyperlink or SYMBOL_CHARSET territory
	if(psel->_rpCF.IsValid())
	{
		CCFRunPtr		   rp(*psel);

		for(LONG cchMax = 0; cchMax < cch; rp.SetIch(0))
		{
			rp.AdjustBackward();
			const CCharFormat *pCF = rp.GetCF();
			if (pCF->_dwEffects & (CFE_LINK | CFE_HIDDEN) ||
				pCF->_iCharRep == SYMBOL_INDEX)
			{
				break;
			}
			cchMax += rp.GetIch();
			if(!rp.GetIRun())
				break;						// Reached start of doc
		}
		if(cchMax < cch)					// Hyperlink within words to check
		{
			tp.Move(cch - cchMax);			// Only check chars back to link,
			cch = cchMax;					//  symbols, or CharRep change
		}
	}
	tp.GetText(cch, pchFrom);
	pchFrom[cch] = 0;

	long	  cchTo = cchCorrectMax, cchReplaced = 0;
	CCFRunPtr rp(*psel);
	rp.Move(-2);

	if(_pDocInfo->_pfnAutoCorrect(rp.GetCF()->_lcid, pchFrom, pchTo, cchTo, &cchReplaced))
	{
		// If plain text check for special cases to suppress per bug 8717.		
		// copyright, registered trademark, trademark, ellipses.
		if(!_fRich && (pchTo[0] == 0xA9 || pchTo[0] == 0xAE ||
			pchTo[0] == 0x2122 || pchTo[0] == 0x2026))
		{
			return;
		}

		if (publdr)
		{
			publdr->Done();
			publdr->StopGroupTyping();
		}

		CTxtRange rg(*psel);
		DWORD	  ch = rg.GetPrevChar();
		LONG	  cpSave = psel->GetCp();
		LONG	  cchDelim = 1;

		if(ch >= 0x1100)					// Most East Asian chars aren't delims
		{
			if(ch < 0x1200 || IN_RANGE(0x3040, ch, 0xD7FF) ||
				ch >= 0xF900 && (ch < 0xFAFF || IN_RANGE(0xFF21, ch, 0xFFDF)))
			{
				cchDelim = 0;
			}
		}
		rg.Set(rg.GetCp() - cchDelim, cchReplaced - cchDelim);
		rg.CleanseAndReplaceRange(wcslen(pchTo) - cchDelim, pchTo, FALSE, publdr, pchTo);
		if(!cchDelim)
			psel->SetCp(rg.GetCp(), FALSE);
		if (publdr)
			HandleSelectionAEInfo(this, publdr, cpSave, 0, psel->GetCp(), 0, SELAE_FORCEREPLACE);

//		publdr->SetNameID(UID_AUTOCORRECT);
	}
}

/*
 *	CTxtEdit::OnSetAssociateFont(pCF, dwFlags)
 *
 *	@mfunc	Set the Associate font for the input LCID or charset
 *
 *	@rdesc	LRESULT
 */
LRESULT	CTxtEdit::OnSetAssociateFont(
	CHARFORMAT2 *pCF2,
	DWORD		dwFlags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnSetAssociateFont");

	int		cpg = 0;
	SHORT	iFont;
	BYTE	yHeight;
	int		cbSize = pCF2->cbSize;

	Assert(cbSize == sizeof(CHARFORMAT2W) || cbSize == sizeof(CHARFORMAT2A));

	int iCharRep = CharRepFromCharSet(pCF2->bCharSet);

	if (pCF2->dwMask & CFM_LCID)
	{
		iCharRep = CharRepFromLID(cbSize == sizeof(CHARFORMAT2W)
								  ? pCF2->lcid : ((CHARFORMAT2A *)pCF2)->lcid,
								  dwFlags & SCF_ASSOCIATEFONT2);
		cpg = CodePageFromCharRep(iCharRep);
	}

	if (iCharRep == -1)
		return 0;							// Can't get Char repertoire, so forget it

	if (cbSize == sizeof(CHARFORMAT2W))
		iFont = GetFontNameIndex(pCF2->szFaceName);
	else
	{
		// need to convert CHARFORMAT2A face name
		LONG	cch;
		BOOL	fMissingCodePage;
		WCHAR	szFaceName[LF_FACESIZE];				

		cch = MBTWC(cpg, 0,
					((CHARFORMAT2A *)pCF2)->szFaceName,	-1, 
					szFaceName, LF_FACESIZE, &fMissingCodePage);

		if (fMissingCodePage || cch <= 0)
			return 0;

		iFont = GetFontNameIndex(szFaceName);
	}

	yHeight = pCF2->yHeight / TWIPS_PER_POINT;

	CLock lock;
	if (W32->SetPreferredFontInfo(iCharRep, dwFlags & SCF_USEUIRULES ? true : false, iFont, yHeight, pCF2->bPitchAndFamily))
		return 1;

	return 0;
}

/*
 *	CTxtEdit::OnGetAssociateFont(pCF, dwFlags)
 *
 *	@mfunc	Get the Associate font for the input LCID or charset
 *
 *	@rdesc	LRESULT
 */
LRESULT	CTxtEdit::OnGetAssociateFont(
	CHARFORMAT2 *pCF2,
	DWORD		dwFlags)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::OnGetAssociateFont");

	int		cpg = 0;
	SHORT	iFont;
	BYTE	yHeight;
	BYTE	bPitchAndFamily;
	int		cbSize = pCF2->cbSize;

	Assert(cbSize == sizeof(CHARFORMAT2W) || cbSize == sizeof(CHARFORMAT2A));

	int iCharRep = CharRepFromCharSet(pCF2->bCharSet);
	if (pCF2->dwMask & CFM_LCID)
	{
		iCharRep = CharRepFromLID(cbSize == sizeof(CHARFORMAT2W)
								  ? pCF2->lcid : ((CHARFORMAT2A *)pCF2)->lcid,
								  dwFlags & SCF_ASSOCIATEFONT2);
		cpg = CodePageFromCharRep(iCharRep);
	}

	if (iCharRep == -1)
		return 0;							// Can't get char repertoire, so forget it

	if (W32->GetPreferredFontInfo(iCharRep, dwFlags & SCF_USEUIRULES ? true : false, iFont, yHeight, bPitchAndFamily))
	{
		pCF2->yHeight = yHeight * TWIPS_PER_POINT;
		pCF2->bPitchAndFamily = bPitchAndFamily;
		
		if (cbSize == sizeof(CHARFORMAT2W))
			wcscpy(pCF2->szFaceName, GetFontName((LONG)iFont));
		else
		{
			// need to convert CHARFORMAT2A face name
			LONG	cch;
			BOOL	fMissingCodePage;
			const WCHAR	*pszFaceName = GetFontName((LONG)iFont);				

			cch = WCTMB(cpg, 0,
						pszFaceName, -1,
						((CHARFORMAT2A *)pCF2)->szFaceName, LF_FACESIZE, 
						NULL, NULL, &fMissingCodePage);

			if (fMissingCodePage || cch <= 0)
				return 0;
		}
		return 1;
	}
	return 0;
}

#ifndef NOINKOBJECT
/*
 *	CTxtEdit::SetInkProps(ILineInfo *pILineInfo, UINT *piInkWidth)
 *
 *	@mfunc	Setup the Ink object properties
 *
 *	@rdesc	HRESULT
 */
HRESULT	CTxtEdit::SetInkProps(
	LONG		cp,
	ILineInfo	*pILineInfo, 
	UINT		*piInkWidth)
{
	HRESULT		hr = E_FAIL;
	INKMETRIC	inkMetric;
	CTxtRange	rg(this, cp, 1);
	const CCharFormat *pCF = rg.GetCF();
	
	if (pCF)
	{
		memset(&inkMetric, 0, sizeof(inkMetric));

		if (pCF->_wWeight > FW_NORMAL)
			inkMetric.iWeight = 3;								// Bold

		inkMetric.fItalic = !!(pCF->_dwEffects & CFE_ITALIC);	// Italic
																// Height in HIMETRIC
		inkMetric.iHeight = (UINT)MulDiv(pCF->_yHeight, HIMETRIC_PER_INCH, LY_PER_INCH);

		inkMetric.color = pCF->_crTextColor;					// Color

		// Get zoomed height
		LONG dvpInch = MulDiv(GetDeviceCaps(W32->GetScreenDC(), LOGPIXELSY), _pdp->GetZoomNumerator(), _pdp->GetZoomDenominator());
		CCcs *pccs = GetCcs(pCF, dvpInch);

		if (pccs)
		{
			inkMetric.iFontDescent = (UINT)MulDiv(inkMetric.iHeight, pccs->_yDescent, pccs->_yHeight);
			inkMetric.iFontAscent = inkMetric.iHeight - inkMetric.iFontDescent;

			// Release cache entry since we are done with it.
			pccs->Release();
		}

		hr = pILineInfo->SetFormat(&inkMetric);
	}

	return hr;
}
#endif
/*
 *	CTxtEdit::GetCaretWidth()
 *
 *	@mfunc	Get caret width
 *
 *	@rdesc
 *		caret width
 */
HRESULT	CTxtEdit::GetCaretWidth()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetCaretWidth");

	RECT rcInset;

	if(!fInHost2()	||					// Host 1
		SUCCEEDED(_phost->TxGetViewInset(&rcInset)) && !rcInset.right)
		return duCaret;

	return 0;
}

/*
 *	CCellColor::GetColorIndex(cr)
 *
 *	@mfunc
 *		Get color index corresponding to cr. Possible return values are 0
 *		(autocolor), 1-16 (the 16 standard colors: g_Colors), and two custom
 *		colors, 17 and 18 defined on a first-come basis.
 *
 *	@rdesc
 *		Color index corresponding to cr
 */
LONG CCellColor::GetColorIndex(
	COLORREF cr)
{
	if(cr == tomAutoColor)
		return 0;

	for(LONG i = 0; i < 16; i++)
	{
		if(cr == g_Colors[i])
			return i + 1;
	}
	if(!_crCellCustom1 || cr == _crCellCustom1)
	{
		_crCellCustom1 = cr;				// First custom cr 
		return 17;
	}

	if(!_crCellCustom2 || cr == _crCellCustom2)	
	{
		_crCellCustom2 = cr;				// Second custom cr
		return 18;
	}
	return 0;								// No custom cr available	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\font.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module FONT.CPP -- font cache |
 *
 *		Includes font cache, char width cache;
 *		create logical font if not in cache, look up
 *		character widths on an as needed basis (this
 *		has been abstracted away into a separate class
 *		so that different char width caching algos can
 *		be tried.) <nl>
 *		
 *	Owner: <nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		7/26/95		jonmat	cleanup and reorganization, factored out
 *					char width caching code into a separate class.
 *		7/1/99	    KeithCu  Removed multiple levels in CWidthCache, cached
 *					30K FE characters in 2 bytes, sped up cache by
 *					lowering acceptable collision rate, halved memory
 *					usage by storing widths in 2 bytes instead of 4
 *					Shrunk much out of CCcs (i.e. LOGFONT)
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */								

#include "_common.h"
#include "_font.h"
#include "_rtfconv.h"	// Needed for GetCodePage
#include "_uspi.h"

#define CLIP_DFA_OVERRIDE   0x40	//  Used to disable Korea & Taiwan font association
#define FF_BIDI		7

extern ICustomTextOut *g_pcto;

ASSERTDATA

// Corresponds to yHeightCharPtsMost in richedit.h
#define yHeightCharMost 32760

// NOTE: this is global across all instances in the same process.
static CFontCache *g_fc;

static FONTINFO *g_pFontInfo = NULL;
static LONG g_cFontInfo = 0;
static LONG g_cFontInfoMax = 0;

//Fonts automatically added to our font table
const WCHAR *szArial			= L"Arial";				// IFONT_ARIAL
const WCHAR *szTimesNewRoman	= L"Times New Roman";	// IFONT_TIMESNEWROMAN
const WCHAR *szSymbol			= L"Symbol";			// IFONT_SYMBOL
const WCHAR *szSystem			= L"System";			// IFONT_SYSTEM
const int cfontsDflt = 4;

//Other fonts that we do use, but aren't automatically added to our font table
const WCHAR *szMicrosSansSerif	= L"Microsoft Sans Serif";
const WCHAR *szMSSansSerif		= L"MS Sans Serif";
const WCHAR *szMangal			= L"Mangal";
const WCHAR *szLatha			= L"Latha";
const WCHAR *szRaavi			= L"Raavi";
const WCHAR *szShruti			= L"Shruti";
const WCHAR *szTunga			= L"Tunga";
const WCHAR *szGautami			= L"Gautami";
const WCHAR *szCordiaNew		= L"Cordia New";
const WCHAR *szTahoma			= L"Tahoma";
const WCHAR *szArialUnicode		= L"Arial Unicode MS";
const WCHAR *szWingdings		= L"Wingdings";
const WCHAR *szSylfaen			= L"Sylfaen";
const WCHAR *szSyriac			= L"Estrangelo Edessa";
const WCHAR *szThaana			= L"MV Boli";

#define szFontOfChoice szArial

/*
 *	GetFontNameIndex(pFontName)
 *
 *	@func
 *		return index into global pszFontName table for fontname pFontName.
 *		If fontname isn't in table, add it and return index.
 *
 *	@rdesc
 *		fontname index corresponding to pFontName
 *
 *	@devnote
 *		This uses a linear search, so the most common font names should be
 *		up front. Internally, we use the fontname indices, so the search
 *		isn't done that often.  Note also that the fontname table only grows,
 *		but this is probably OK for most clients.  Else we need ref counting...
 */
SHORT GetFontNameIndex(
	const WCHAR *pFontName)
{
	CLock Lock;					// Wonder how much this slows things down...

	for(LONG i = 0; i < g_cFontInfo; i++)
	{
		// A hash could speed this up if perf turns out poor
		if(!wcscmp(pFontName, g_pFontInfo[i].szFontName))
			return i;
	}

	if(g_cFontInfo + 1 >= g_cFontInfoMax)
	{
		// Note that PvReAlloc() reverts to PvAlloc() if g_pFontInfo is NULL
		FONTINFO *pFI = (FONTINFO *)PvReAlloc((LPVOID)g_pFontInfo,
									sizeof(FONTINFO) * (8 + g_cFontInfo));
		if(!pFI)
			return IFONT_ARIAL;					// Out of memory...

		// Initialize the structure
		ZeroMemory (&pFI[g_cFontInfo], 8 * sizeof(FONTINFO));

												//  attempts to fill them in
		if(!g_cFontInfoMax)						// First allocation
		{
			Assert(IFONT_ARIAL  == 0 && IFONT_TMSNEWRMN == 1 &&
				   IFONT_SYMBOL == 2 && IFONT_SYSTEM == 3);

			pFI[IFONT_ARIAL].szFontName		= szArial;
			pFI[IFONT_TMSNEWRMN].szFontName = szTimesNewRoman;
			pFI[IFONT_SYMBOL].szFontName	= szSymbol;
			pFI[IFONT_SYSTEM].szFontName	= szSystem;
			g_cFontInfo			 = cfontsDflt;
		}
		g_pFontInfo = pFI;
		g_cFontInfoMax += 8;
	}											

	LONG	cb = (wcslen(pFontName) + 1)*sizeof(WCHAR);
	WCHAR *	pch = (WCHAR *)PvAlloc(cb, GMEM_MOVEABLE);

	if(!pch)
		return IFONT_ARIAL;					// Out of memory...

	g_pFontInfo[g_cFontInfo].szFontName = pch;
	CopyMemory((void *)pch, pFontName, cb);
	return g_cFontInfo++;
}

/*
 *	GetFontName(iFont)
 *
 *	@func
 *		return fontname given by g_pFontInfo[iFont].szFontName.
 *
 *	@rdesc
 *		fontname corresponding to fontname index iFont
 */
const WCHAR *GetFontName(
	LONG iFont)
{
	return (iFont >= 0 && iFont < g_cFontInfo) ? g_pFontInfo[iFont].szFontName : NULL;
}

void SetFontSignature(
	LONG  iFont,
	QWORD qwFontSig)
{
	if(iFont >= 0 && iFont < g_cFontInfo)
		g_pFontInfo[iFont].qwFontSig |= qwFontSig;
}

/*
 *	SetFontLegitimateSize(iFont, fUIFont, bSize, fFEcpg)
 *
 *	@func
 *		Set the legitimate size (readable smallest size to use) of a given font
 *
 *	@rdesc
 *		TRUE if successful
 */
BOOL SetFontLegitimateSize(
	LONG 	iFont,
	BOOL	fUIFont,
	BYTE	bSize,
	BOOL	fFEcpg)
{
	if (iFont < g_cFontInfo)
	{
		// East Asia wanted to do it per codepage.
		//
		// FUTURE: Bear in mind that this approach is bug-prone. Once there's
		// any new FE font created with different metric from the existing one.
		// Font scaling will not perform well or even broken for such font [wchao].

		g_pFontInfo[iFont].ff.fScaleByCpg = fFEcpg;

		if (fUIFont)
		{
			if (!g_pFontInfo[iFont].bSizeUI)
				g_pFontInfo[iFont].bSizeUI = bSize;
			else
				// more than one legit size were updated per font,
				// We fallback to the codepage-driven approach.
				g_pFontInfo[iFont].ff.fScaleByCpg = g_pFontInfo[iFont].bSizeUI != bSize;
		}
		else
		{
			if (!g_pFontInfo[iFont].bSizeNonUI)
				g_pFontInfo[iFont].bSizeNonUI = bSize;
			else
				g_pFontInfo[iFont].ff.fScaleByCpg = g_pFontInfo[iFont].bSizeNonUI != bSize;
		}
		return TRUE;
	}
	return FALSE;
}

/*
 *	GetFontLegitimateSize(iFont, fUIFont, iCharRep)
 *
 *	@func
 *		Get the legitimate size (readable smallest size to use) of a given font
 *
 *	@rdesc
 *		Legitimate size of font
 */
BYTE GetFontLegitimateSize(
	LONG	iFont,			//@parm	Font to get size for
	BOOL	fUIFont,		//@parm	TRUE if for UI font
	int		iCharRep)		//@parm Char repertoire to use
{
	BYTE	bDefPaf;
	SHORT	iDefFont;
	BYTE	yHeight = 0;

	if (iFont < g_cFontInfo && !g_pFontInfo[iFont].ff.fScaleByCpg)
		yHeight = fUIFont ? g_pFontInfo[iFont].bSizeUI : g_pFontInfo[iFont].bSizeNonUI;

	if (!yHeight && fc().GetInfoFlags(iFont).fNonBiDiAscii)
	{
		// Non-BiDi ASCII font uses table font (of the same charset) legitimate height
		QWORD	qwFontSig = GetFontSignatureFromFace(iFont) & ~(FASCII | FFE);
		LONG	iCharRepT = GetFirstAvailCharRep(qwFontSig);
		
		if(W32->GetPreferredFontInfo(iCharRepT, fUIFont ? true : false, iDefFont, yHeight, bDefPaf))
		{
			SetFontLegitimateSize(iFont, fUIFont, yHeight ? yHeight : fUIFont ? 8 : 10,
								  IsFECharRep(iCharRepT));
		}
	}

	if (!yHeight)
	{
		if (fc().GetInfoFlags(iFont).fThaiDTP)
		{
			iCharRep = THAI_INDEX;
			fUIFont = FALSE;
		}
		W32->GetPreferredFontInfo(iCharRep, fUIFont ? true : false, iDefFont, yHeight, bDefPaf);
	}
	return yHeight ? yHeight : fUIFont ? 8 : 10;
}

/*
 *	GetTextCharsetInfoPri(hdc, pFontSig, dwFlags)
 *
 *	@func
 *		Wrapper to GDI's GetTextCharsetInfo. This to handle BiDi old-style fonts
 *
 *	@rdesc
 *		CharSet for info
 */
UINT GetTextCharsetInfoPri(
	HDC				hdc,
	FONTSIGNATURE*	pFontSig,
	DWORD			dwFlags)
{
#ifndef NOCOMPLEXSCRIPTS
	OUTLINETEXTMETRICA 	otm;
	INT					uCharSet = -1;

	if (pFontSig && GetOutlineTextMetricsA(hdc, sizeof(OUTLINETEXTMETRICA), &otm))
	{
		ZeroMemory (pFontSig, sizeof(FONTSIGNATURE));

		switch (otm.otmfsSelection & 0xFF00)
		{
			case 0xB200:	// Arabic Simplified
			case 0xB300:	// Arabic Traditional
			case 0xB400:	// Arabic Old UDF
				uCharSet = ARABIC_CHARSET; break;
			case 0xB100:	// Hebrew Old style
				uCharSet = HEBREW_CHARSET;
		}
	}
	if (uCharSet == -1)
		uCharSet = W32->GetTextCharsetInfo(hdc, pFontSig, dwFlags);

	if (uCharSet == DEFAULT_CHARSET)
		uCharSet = ANSI_CHARSET;	// never return ambiguous

	return (UINT)uCharSet;
#else
	return DEFAULT_CHARSET;
#endif
}

/*
 *	GetFontSignatureFromDC(hdc, &fNonBiDiAscii)
 *
 *	@func
 *		Compute RichEdit font signature for font selected into hdc. Uses
 *		info from OS font signature
 *
 *	@rdesc
 *		RichEdit font signature for font selected into hdc
 */
QWORD GetFontSignatureFromDC(
	HDC		hdc,
	BOOL &	fNonBiDiAscii)
{
	union
	{										// Endian-dependent way of
		QWORD qwFontSig;					//  avoiding 64-bit shifts
		DWORD dwFontSig[2];
	};

#ifndef NOCOMPLEXSCRIPTS

	// Try to get FONTSIGNATURE data
	CHARSETINFO csi;
	UINT 	uCharSet = GetTextCharsetInfoPri(hdc, &(csi.fs), 0);
	DWORD	dwUsb0 = 0;
	DWORD	dwUsb2 = 0;
	if(!W32->OnWin9x())
	{
		dwUsb0 = csi.fs.fsUsb[0];
		dwUsb2 = csi.fs.fsUsb[2];
	}

	if ((csi.fs.fsCsb[0] | dwUsb0 | dwUsb2) ||
		TranslateCharsetInfo((DWORD *)(DWORD_PTR)uCharSet, &csi, TCI_SRCCHARSET))
	{
		DWORD			fsCsb0 = csi.fs.fsCsb[0];
		CUniscribe *	pusp;
		SCRIPT_CACHE	sc = NULL;
		WORD			wGlyph;

		qwFontSig = ((fsCsb0 & 0x1FF) << 8)		// Shift left since we use
				  | ((fsCsb0 & 0x1F0000) << 3);	//  low byte for fBiDi, etc.
		// Also look at Unicode subrange if available
		// FUTURE: we may want to drive Unicode ranges with a
		// table approach, i.e., use for loop shifting dwUsb0 right
		// to convert each bit into an index into a table of BYTEs
		// that return the appropriate script index for rgCpgCharSet:
		//
		//	for(LONG i = 0; dwUsb0; dwUsb0 >>= 1, i++)
		//	{
		//		static const BYTE rgiCharRep[32] = {...};
		//		if(dwUsb0 & 1)
		//			dwFontSig |= FontSigFromCharRep(rgiCharRep[i]);
		//	}
		if(dwUsb0)
		{
			if (dwUsb0 & 0x00000400)
				qwFontSig |= FARMENIAN;

			Assert(FDEVANAGARI == 0x0000000800000000);
			dwFontSig[1] |= (dwUsb0 & 0x00FF8000) >> 12;	// 9 Indic scripts

			if (dwUsb0 & 0x02000000)
				qwFontSig |= FLAO;

			if (dwUsb0 & 0x04000000)
				qwFontSig |= FGEORGIAN;

			if (dwUsb0 & 0x10000000)
				qwFontSig |= FJAMO;
		}

		// The new Unicode 3.0 scripts are defined by dwUsb2 as follows
		// (see \\sparrow\sysnls\nlsapi\font-sig.txt):
		// 128	32	Script
		//----------------------
		//	70	 6	Tibetan
		//	71	 7	Syriac
		//	72	 8	Thaana
		//	73	 9	Sinhala
		//	74	10	Myanmar
		//	75	11	Ethiopic
		//	76	12	Cherokee
		//	77	13	Canadian Aboriginal Syllabics
		//	78	14	Ogham
		//	79	15	Runic
		//	80	16	Khmer
		//	81	17	Mongolian
		//	82	18	Braille
		//	83	19	Yi
		if(dwUsb2 & 0xFFFC0)			// Bits 6 - 19
		{
			if(dwUsb2 & 0x40)						// Bit 6 of dwUsb[2]
				dwFontSig[1] |= FTIBETAN > 32;		//  is Tibetan

			dwFontSig[1] |= (dwUsb2 & 0x180) >> 6;	// Syriac (7), Thaana (8)

			if(dwUsb2 & 0x200)						// Bit 9 of dwUsb[2]
				dwFontSig[1] |= FSINHALA > 32;		//  is Sinhala

			if(dwUsb2 & 0x400)						// Bit 10 of dwUsb[2]
				dwFontSig[1] |= FMYANMAR > 32;		//  is Myanmar

			dwFontSig[1] |= (dwUsb2 & 0xFF800) << 6;// Bits 11-19 of dwUsb[2]
		}
		if((qwFontSig & FCOMPLEX_SCRIPT) && !(qwFontSig & FHILATIN1)
		   && (pusp = GetUniscribe()))
		{
			// Signature says no Latin-1 support

			// Search for the 'a' and '0' glyph in the font to
			// determine if the font supports ASCII or European
			// Digit. This is necessary to overcome the font having
			// an incomplete font signature.
			if(ScriptGetCMap(hdc, &sc, L"a", 1, 0, &wGlyph) == S_OK)
				qwFontSig |= FASCIIUPR;

			if(ScriptGetCMap(hdc, &sc, L"0", 1, 0, &wGlyph) == S_OK)
				qwFontSig |= FBELOWX40;

			if(!IsBiDiCharSet(uCharSet) &&
				(qwFontSig & FASCII) == FASCII)
				fNonBiDiAscii = TRUE;		// Non-BiDi ASCII font

			ScriptFreeCache(&sc);
		}

		if (qwFontSig & FHILATIN1)
			qwFontSig |= FASCII;		// FLATIN1 has 3 bits

		// HACK for symbol font. We assign FSYMBOL for Symbol font signature.
		// REVIEW: should we just use csi.fs.fsCsb[0] bit 31 for symbol bit?
		if (uCharSet == SYMBOL_CHARSET && !qwFontSig || fsCsb0 & 0x80000000)
			qwFontSig = FSYMBOL;
	}
	else								// No font signature info
		qwFontSig = FontSigFromCharRep(CharRepFromCharSet(uCharSet));

#else
	qwFontSig = FLATIN1;					// Default Latin1
#endif // NOCOMPLEXSCRIPTS

	return qwFontSig;
}

/*
 *	GetFontSignatureFromFace(iFont, pqwFontSig)
 *
 *	@func
 *		Giving font signature matching the index of given facename.
 *	    This signature may not match the one in Cccs since this is the
 *		signature of the font of given facename. The Cccs one is
 *		per GDI realization.
 *
 *	@rdesc
 *		- font signature if pqwFontSig is NULL.
 *		- If pqwFontSig != NULL. It's a boolean.
 *			ZERO means returned signature is not sensible by following reasons
 *			 1. Bad facename (junk like "!@#$" or name that doesnt exist in the system)
 *			 2. Given face doesnt support even one valid ANSI codepage (symbol fonts,
 *				e.g., Marlett)
 */
QWORD GetFontSignatureFromFace(
	int 	iFont,
	QWORD *	pqwFontSig)
{
	Assert((unsigned)iFont < (unsigned)g_cFontInfo);

	FONTINFO_FLAGS	ff;
	QWORD			qwFontSig = g_pFontInfo[iFont].qwFontSig;
	ff.wFlags = g_pFontInfo[iFont].ff.wFlags;

	if(!ff.fCached)
	{
		int		i = 0;
		HDC	  	hdc = GetDC(NULL);
		LOGFONT	lf;
		WCHAR*	pwchTag = lf.lfFaceName;

		ZeroMemory(&lf, sizeof(LOGFONT));
	
		wcscpy(lf.lfFaceName, GetFontName(iFont));

		// Exclude Win95's tag name e.g. "Arial(Greek)"
		while (pwchTag[i] && pwchTag[i] != '(')
			i++;
		if(pwchTag[i] && i > 0)
		{
			while (i > 0 && pwchTag[i-1] == 0x20)
				i--;
			pwchTag[i] = 0;
		}

		lf.lfCharSet = DEFAULT_CHARSET;
	
		// Obtain a charset supported by given facename
		// to force GDI gives facename priority over charset.
		W32->GetFacePriCharSet(hdc, &lf);	
	
		HFONT hfont = CreateFontIndirect(&lf);
		if(hfont)
		{
			HFONT hfontOld = SelectFont(hdc, hfont);
			WCHAR szNewFaceName[LF_FACESIZE];
	
			GetTextFace(hdc, LF_FACESIZE, szNewFaceName);
	
			if(!wcsicmp(szNewFaceName, lf.lfFaceName) ||	// Got it
				((GetCharFlags(szNewFaceName, 2) & FFE) &&	// or Get back FE font name for English name
				 (GetCharFlags(lf.lfFaceName, 2) & FASCII)))//	because NT5 supports dual font names.
			{
				BOOL fNonBiDiAscii = FALSE;
				qwFontSig = GetFontSignatureFromDC(hdc, fNonBiDiAscii);
				if(fNonBiDiAscii)
					ff.fNonBiDiAscii = TRUE;
			}
			else
				ff.fBadFaceName = TRUE;

			TEXTMETRIC tm;

			GetTextMetrics(hdc, &tm);
			ff.fTrueType = tm.tmPitchAndFamily & TMPF_TRUETYPE ? 1 : 0;
			ff.fBitmap = tm.tmPitchAndFamily & (TMPF_TRUETYPE | TMPF_VECTOR | TMPF_DEVICE) ? 0 : 1;

			if(!ff.fBadFaceName && qwFontSig & FTHAI)
			{
				// Some heuristic test on Thai fonts.
				// Most Thai fonts will fall to this category currently except for
				// Tahoma and Microsoft Sans Serif.
				ff.fThaiDTP = tm.tmDescent && tm.tmAscent/tm.tmDescent < 3;
			}
			SelectObject(hdc, hfontOld);
			SideAssert(DeleteObject(hfont));
		}
		ReleaseDC(NULL, hdc);
	
		// Cache code pages supported by this font
		ff.fCached = TRUE;
		g_pFontInfo[iFont].qwFontSig |= qwFontSig;
		g_pFontInfo[iFont].ff.wFlags = ff.wFlags;
	}

	if (!pqwFontSig)
		return qwFontSig;

	*pqwFontSig = qwFontSig;

	// 22-29 are reserved for alternate ANSI/OEM, as of now we use 21, 22 for Devanagari and Tamil
	return qwFontSig && !ff.fBadFaceName;
}

/*
 *	FreeFontNames()
 *
 *	@func
 *		Free fontnames given by g_pFontInfo[i].szFontName allocated by
 *		GetFontNameIndex() as well as g_pFontInfo itself.
 */
void FreeFontNames()
{
	for(LONG i = cfontsDflt; i < g_cFontInfo; i++)
		FreePv((LPVOID)g_pFontInfo[i].szFontName);
	FreePv(g_pFontInfo);
	g_pFontInfo = NULL;
}

SHORT	g_iFontJapanese;
SHORT	g_iFontHangul;
SHORT	g_iFontBig5;
SHORT	g_iFontGB2312;

/*
 *	InitFontCache()
 *	
 *	@func
 *		Initializes font cache.
 *
 *	@devnote
 *		This is exists so reinit.cpp doesn't have to know all about the
 *		font cache.
 */
void InitFontCache()
{
	g_fc = new CFontCache;
	g_fc->Init();
}

/*
 *	FreeFontCache()
 *	
 *	@mfunc
 *		Frees font cache.
 *
 *	@devnote
 *		This is exists so reinit.cpp doesn't have to know all about the
 *		font cache.
 */
void FreeFontCache()
{
	for (int i = 0; i < g_cFontInfo; i++)
		delete g_pFontInfo[i]._pffm;

	delete g_fc;
	g_fc = NULL;
	FreeFontNames();
}

/*
 *	CFontCache & fc()
 *	
 *	@func
 *		initialize the global g_fc.
 *	@comm
 *		current #defined to store 16 logical fonts and
 *		respective character widths.
 */
CFontCache & fc()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "fc");
    return *g_fc;
}

FONTINFO_FLAGS CFontCache::GetInfoFlags(int ifont)
{
	if (!g_pFontInfo[ifont].ff.fCached)
		GetFontSignatureFromFace(ifont);

	return g_pFontInfo[ifont].ff;
}

CFontFamilyMgr::~CFontFamilyMgr()
{
	for (int i = 0; i < _rgf.Count(); i++)
	{
		CFontFamilyMember *pf = _rgf.Elem(i);
		pf->Free();
	}
}

CFontFamilyMember* CFontFamilyMgr::GetFontFamilyMember(LONG weight, BOOL fItalic)
{
	for (int i = 0; i < _rgf.Count(); i++)
	{
		CFontFamilyMember *pf = _rgf.Elem(i);
		if (pf->_weight == weight && pf->_fItalic == fItalic)
			return pf;
	}

	CFontFamilyMember f(weight, fItalic);
	CFontFamilyMember *pf = _rgf.Add(1, 0);
	*pf = f;
	return pf;
}

CKernCache * CFontCache::GetKernCache(LONG iFont, LONG weight, BOOL fItalic)
{
	if (!g_fc->GetInfoFlags(iFont).fTrueType)
		return 0;
	CFontFamilyMgr *pffm = GetFontFamilyMgr(iFont);
	CFontFamilyMember *pf = pffm->GetFontFamilyMember(weight, fItalic);
	return pf->GetKernCache();
}

CFontFamilyMgr* CFontCache::GetFontFamilyMgr(LONG iFont)
{
	if (!g_pFontInfo[iFont]._pffm)
		g_pFontInfo[iFont]._pffm = new CFontFamilyMgr();

	return g_pFontInfo[iFont]._pffm;
}


// ===================================  CFontCache  ====================================
/*
 *	CFontCache::Init()
 *	
 *	@mfunc
 *		Initializes font cache.
 *
 *	@devnote
 *		This is not a constructor because something bad seems to happen
 *		if we try to construct a global object.
 */
void CFontCache::Init()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::CFontCache");

	_dwAgeNext = 0;
}

/*
 *	CFontCache::MakeHashKey(pCF)
 *	
 *	@mfunc
 *		Build a hash key for quick searches for a CCcs matching
 *		the pCF.
 *		Format:
 *		iFont : 14
 *		Bold/Italic : 2
 *      Height : 16
 *
 */
CCSHASHKEY CFontCache::MakeHashKey(
	const CCharFormat *pCF)
{
	CCSHASHKEY ccshashkey;
	ccshashkey = pCF->_iFont | ((pCF->_dwEffects & 3) << 14);
	ccshashkey |= pCF->_yHeight << 16;
	return ccshashkey;
}

/*
 *	CFontCache::GetCcs(pCF, dvpInch, dwFlags, hdc)
 *	
 *	@mfunc
 *		Search the font cache for a matching logical font and return it.
 *		If a match is not found in the cache,  create one.
 *
 *	@rdesc
 *		A logical font matching the given CHARFORMAT info.
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs* CFontCache::GetCcs(
	CCharFormat *pCF,		//@parm Logical font (routine is allowed to change it)
	const LONG	dvpInch,	//@parm Y pixels per inch
	DWORD		dwFlags,	//@parm flags
	HDC			hdc)		//@parm HDC font is to be created for
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::GetCcs");
									//  display font
	const CCcs * const	pccsMost = &_rgccs[FONTCACHESIZE - 1];
	CCcs *				pccs;
    CCSHASHKEY			ccshashkey;
	int					iccsHash;

	if (dwFlags & FGCCSUSETRUETYPE)
	{
		//On Win '9x Thai/Vietnamese, you cannot force truetype fonts! Therefore,
		//we will force Tahoma if the font doesn't support the right charset.
		if (W32->OnWin9x())
		{
			UINT acp = GetACP();
			if (acp == 1258 || acp == 874)
			{
				QWORD qwFontSig = GetFontSignatureFromFace(pCF->_iFont);
				if (pCF->_iCharRep == THAI_INDEX && (qwFontSig & FTHAI) == 0 ||
					pCF->_iCharRep == VIET_INDEX && (qwFontSig & FVIETNAMESE) == 0 ||
					!g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
				{
					pCF->_iFont = GetFontNameIndex(szTahoma);
				}
			}
		}
		else if (!g_fc->GetInfoFlags(pCF->_iFont).fTrueType)
			dwFlags |= FGCCSUSETRUETYPE;
	}

	if (hdc == NULL)
		hdc = W32->GetScreenDC();

	// Change _yHeight in the case of sub/superscript
	if(pCF->_dwEffects & (CFE_SUPERSCRIPT | CFE_SUBSCRIPT))
		 pCF->_yHeight = 2 * pCF->_yHeight / 3;

	//Convert CCharFormat into logical units (round)
	pCF->_yHeight = (pCF->_yHeight * dvpInch + LY_PER_INCH / 2) / LY_PER_INCH;
	if (pCF->_yHeight == 0)
		pCF->_yHeight = 1;

	if ((dwFlags & FGCCSUSEATFONT) && !IsFECharRep(pCF->_iCharRep))
	{
		QWORD qwFontSig = GetFontSignatureFromFace(pCF->_iFont);

		if (!(qwFontSig & FFE))				// No At font for non-FE charset and
			dwFlags &= ~FGCCSUSEATFONT;		//	font signature doesen't support FE
	}

	ccshashkey = MakeHashKey(pCF);

	// Check our hash before going sequential.
	iccsHash = ccshashkey % CCSHASHSEARCHSIZE;
	if(ccshashkey == quickHashSearch[iccsHash].ccshashkey)
	{
		pccs = quickHashSearch[iccsHash].pccs;
		if(pccs && pccs->_fValid)
		{
	        if(pccs->Compare(pCF, hdc, dwFlags))
                goto matched;
		}
	}
	else	//Setup this hash hint for next time
		quickHashSearch[iccsHash].ccshashkey = ccshashkey;


	// Sequentially search ccs for same character format
	for(pccs = &_rgccs[0]; pccs <= pccsMost; pccs++)
	{
		if(pccs->_ccshashkey == ccshashkey && pccs->_fValid)
		{
	        if(!pccs->Compare(pCF, hdc, dwFlags))
                continue;

			quickHashSearch[iccsHash].pccs = pccs;

		matched:
			//$ FUTURE: make this work even with wrap around of dwAgeNext
			// Mark as most recently used if it isn't already in use.
			if(pccs->_dwAge != _dwAgeNext - 1)
				pccs->_dwAge = _dwAgeNext++;
			pccs->_cRefs++;		// bump up ref. count
			return pccs;
		}
	}

	// We did not find a match: init a new font cache.
	pccs = GrabInitNewCcs(pCF, hdc, dwFlags);
	quickHashSearch[iccsHash].pccs = pccs;
	pccs->_ccshashkey = ccshashkey;
	return pccs;
}

/*
 *	CFontCache::GrabInitNewCcs(pCF, hdc, dwFlags)
 *	
 *	@mfunc
 *		Create a logical font and store it in our cache.
 *
 *	@rdesc
 *		New CCcs created
 */
CCcs* CFontCache::GrabInitNewCcs(
	const CCharFormat * const pCF,	//@parm Description of desired logical font
	HDC			hdc,
	DWORD		dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CFontCache::GrabInitNewCcs");

	DWORD				dwAgeOldest = 0xffffffff;
	CCcs *				pccs;
	const CCcs * const	pccsMost = &_rgccs[FONTCACHESIZE - 1];
	CCcs *				pccsOldest = NULL;

	// Look for unused entry and oldest in use entry
	for(pccs = &_rgccs[0]; pccs <= pccsMost && pccs->_fValid; pccs++)
		if(pccs->_cRefs == 0 && pccs->_dwAge < dwAgeOldest)
		{
			dwAgeOldest = pccs->_dwAge;
			pccsOldest = pccs;
		}

	if(pccs > pccsMost)		// Didn't find an unused entry, use oldest entry
	{
		pccs = pccsOldest;
		if(!pccs)
		{
			AssertSz(FALSE, "CFontCache::GrabInitNewCcs oldest entry is NULL");
			return NULL;
		}
	}

	// Initialize new CCcs
	pccs->_hdc = hdc;
	pccs->_fFECharSet = IsFECharRep(pCF->_iCharRep);
	pccs->_fUseAtFont = (dwFlags & FGCCSUSEATFONT) != 0;
	pccs->_tflow = dwFlags & 0x3;
	if(!pccs->Init(pCF))
		return NULL;

	pccs->_cRefs++;
	return pccs;
}

// =============================  CCcs  class  ===================================================
/*
 *	BOOL CCcs::Init(pCF)
 *	
 *	@mfunc
 *		Init one font cache object. The global font cache stores
 *		individual CCcs objects.
 */
BOOL CCcs::Init (
	const CCharFormat * const pCF)	//@parm description of desired logical font
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Init");

	if(_fValid)
		Free();				// recycle already in-use fonts.

	if(MakeFont(pCF))
	{
		_iFont = pCF->_iFont;
		_dwAge = g_fc->_dwAgeNext++;
		_fValid = TRUE;			// successfully created a new font cache.
	}
	return _fValid;
}

/*
 *	void CCcs::Free()
 *	
 *	@mfunc
 *		Free any dynamic memory allocated by an individual font's cache.
 */
void CCcs::Free()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Free");

	Assert(_fValid);

	_widths.Free();

	if(_hfont)
	{
		DestroyFont();
		if (_fCustomTextOut)
			g_pcto->NotifyDestroyFont(_hfont);
	}

#ifndef NOCOMPLEXSCRIPTS
	if (_sc && g_pusp)
		ScriptFreeCache(&_sc);
#endif

	_fValid = FALSE;
	_cRefs = 0;
}

/*
 *	CCcs::BestCharRep(iCharRep, iCharRepDefault, fFontMatching)
 *
 *	@mfunc
 *		This function returns the best charset that the currently selected font
 *		is capable of rendering. If the currently selected font cannot support
 *		the requested charset, then the function returns bCharSetDefault, which
 *		is generally taken from the charformat.
 *		
 *	@rdesc
 *		The closest charset to bCharSet that can be rendered by the current
 *		font.
 *
 *	@devnote
 *		Currently this function is only used with plain text, however I don't
 *		believe there is any special reason it couldn't be used to improve
 *		rendering of rich text as well.
 */
BYTE CCcs::BestCharRep(
	BYTE iCharRep, 
	BYTE iCharRepDefault,
	int  fFontMatching)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::BestCharSet");

	// Does desired charset match currently selected charset or is it
	// supported by the currently selected font?
	if((iCharRep != CharRepFromCharSet(_bCharSet) || !iCharRep) &&
		(fFontMatching == MATCH_CURRENT_CHARSET || !(_qwFontSig & FontSigFromCharRep(iCharRep))))
	{
		// If desired charset is not selected and we can't switch to it,
		// switch to fallback charset (probably from backing store).
		return iCharRepDefault;
	}

	// We already match desired charset, or it is supported by the font.
	// Either way, we can just return the requested charset.
	return iCharRep;
}


/* 	
 *	CCcs::FillWidth (ch, &dup)
 *
 *	@mfunc
 *		Fill in width for given character. Sometimes we don't
 *		call the OS for the certain characters because fonts have bugs.
 *
 *	@rdesc
 *		TRUE if OK, FALSE if failed
 */
BOOL CCcs::FillWidth(
	WCHAR ch, 	//@parm WCHAR character we need a width for.
	LONG &dup)	//@parm the width of the character
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::FillWidth");
	AssertSz(_hfont, "CCcs::Fill - CCcs has no font");
	dup = 0;
	WCHAR chWidth = ch;

	HFONT hfontOld = SelectFont(_hdc, _hfont);

	BOOL fLookaside = _widths.FLookasideCharacter(ch);

	if (fLookaside)
		chWidth = 0x4E00;
	else switch(ch)
	{
	case NBHYPHEN:
	case SOFTHYPHEN:
		chWidth = '-';
		break;

	case NBSPACE:
		chWidth = ' ';
		break;

	case EMSPACE:
		chWidth = EMDASH;
		break;

	case ENSPACE:
		chWidth = ENDASH;
		break;
	}

	W32->REGetCharWidth(_hdc, chWidth, (INT*) &dup, _wCodePage, _fCustomTextOut);

	dup -= _xOverhangAdjust;
	if (dup <= 0)
		dup = max(_xAveCharWidth, 1);

	if (fLookaside)
		_widths._dupCJK = dup;
	else
	{
		CacheEntry *pWidthData = _widths.GetEntry(ch);		
		pWidthData->ch = ch;
		pWidthData->width = dup;
	}

	SelectFont(_hdc, hfontOld);
	return TRUE;
}

/* 	
 *	BOOL CCcs::MakeFont(pCF)
 *
 *	@mfunc
 *		Wrapper, setup for CreateFontIndirect() to create the font to be
 *		selected into the HDC.
 *
 *	@devnote The pCF here is in logical units
 *
 *	@rdesc
 *		TRUE if OK, FALSE if allocation failure
 */
BOOL CCcs::MakeFont(
	const CCharFormat * const pCF)	//@parm description of desired logical font
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::MakeFont");
	LONG	iFont = pCF->_iFont;
	LOGFONT	lf;
	ZeroMemory(&lf, sizeof(lf));

	_bCMDefault = pCF->_dwEffects & CFE_RUNISDBCS ? CVT_LOWBYTE : CVT_NONE;

	_yHeightRequest = pCF->_yHeight;
	_bCharSetRequest = CharSetFromCharRep(pCF->_iCharRep);

	_fCustomTextOut = (pCF->_dwEffects & CFE_CUSTOMTEXTOUT) ? TRUE : FALSE;

	lf.lfHeight = -_yHeightRequest;

	if(pCF->_wWeight)
		_weight = pCF->_wWeight;
	else
		_weight	= (pCF->_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

	lf.lfWeight	 = _weight;
	lf.lfItalic	 = _fItalic = (pCF->_dwEffects & CFE_ITALIC) != 0;
	lf.lfCharSet = _bCMDefault == CVT_LOWBYTE ? ANSI_CHARSET : CharSetFromCharRep(pCF->_iCharRep);
	if (lf.lfCharSet == PC437_CHARSET)
		lf.lfCharSet = DEFAULT_CHARSET;

	lf.lfOutPrecision = OUT_DEFAULT_PRECIS;

	if (_tflow)
		lf.lfOrientation = lf.lfEscapement = (4 - _tflow) * 900;

#ifndef UNDER_CE
	if (_fForceTrueType || _tflow && g_fc->GetInfoFlags(GetFontNameIndex(lf.lfFaceName)).fBitmap)
	{
		lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
		if (!W32->OnWin9x() && g_fc->GetInfoFlags(iFont).fTrueType)
			lf.lfOutPrecision = OUT_SCREEN_OUTLINE_PRECIS;
	}
#endif

	lf.lfClipPrecision	= CLIP_DFA_OVERRIDE;
	lf.lfPitchAndFamily = _bPitchAndFamily = pCF->_bPitchAndFamily;
	lf.lfQuality		= _bQuality		   = pCF->_bQuality;

#ifdef UNDER_CE
	// DEBUGGGGGG for EBOOK!!  Presumably this should be a registry setting
	// that overrules DEFAULT_QUALITY (0) the way ANTIALIASED_QUALITY, etc., do
#ifndef CLEARTYPE_QUALITY
#define CLEARTYPE_QUALITY	5
#endif
	lf.lfQuality = CLEARTYPE_QUALITY;
#endif

	// If family is virtual BiDi family (FF_BIDI), replace by FF_ROMAN
	if((lf.lfPitchAndFamily & 0xF0) == (FF_BIDI << 4))
		lf.lfPitchAndFamily = (FF_ROMAN << 4) | (lf.lfPitchAndFamily & 0xF);

	// If the run is DBCS, that means the font's codepage is not available in
	// this system.  Use the English ANSI codepage instead so we will display
	// ANSI characters correctly.  NOTE: _wCodePage is only used for Win95.
	_wCodePage = CodePageFromCharRep(CharRepFromCharSet(lf.lfCharSet));

	wcscpy(lf.lfFaceName, GetFontName(iFont));

	if (_fUseAtFont && lf.lfFaceName[0] != L'@')
	{
		wcscpy(&(lf.lfFaceName[1]), GetFontName(iFont));
		lf.lfFaceName[0] = L'@';
	}
	// In BiDi system, always create ANSI bitmap font with system charset
	BYTE 	bCharSetSys = W32->GetSysCharSet();

	if (IsBiDiCharSet(bCharSetSys) && lf.lfCharSet == ANSI_CHARSET &&
		fc().GetInfoFlags(iFont).fBitmap &&
		!fc().GetInfoFlags(iFont).fBadFaceName)
		lf.lfCharSet = bCharSetSys;

	// Reader! A bundle of spagghetti code lies ahead of you!
	// But go on boldly, for these spagghetti are seasoned with
	// lots of comments, and ... good luck to you...

	HFONT	hfontOriginalCharset = NULL;
	BYTE	bCharSetOriginal = lf.lfCharSet;
	WCHAR	szNewFaceName[LF_FACESIZE];

	if(pCF->_dwEffects & (CFE_BOLD | CFE_ITALIC))
		iFont = -1;							// Don't use cached font info unless
											//  normal font
	GetFontWithMetrics(&lf, szNewFaceName);

	if(0 != wcsicmp(szNewFaceName, lf.lfFaceName))					
	{
		BOOL fCorrectFont = FALSE;
		iFont = -1;							// pCF->_iFont wasn't used

		if(lf.lfCharSet == SYMBOL_CHARSET)					
		{
			// #1. if the face changed, and the specified charset was SYMBOL,
			//     but the face name exists and suports ANSI, we give preference
			//     to the face name

			lf.lfCharSet = ANSI_CHARSET;

			hfontOriginalCharset = _hfont;
			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
				// That's right, ANSI is the asnwer
				fCorrectFont = TRUE;
			else
				// No, fall back by default; the charset we got was right
				lf.lfCharSet = bCharSetOriginal;
		}
		else if(lf.lfCharSet == DEFAULT_CHARSET && _bCharSet == DEFAULT_CHARSET)
		{
			// #2. If we got the "default" font back, we don't know what it means
			// (could be anything) so we veryfy that this guy's not SYMBOL
			// (symbol is never default, but the OS could be lying to us!!!)
			// we would like to veryfy more like whether it actually gave us
			// Japanese instead of ANSI and labeled it "default"...
			// but SYMBOL is the least we can do

			lf.lfCharSet = SYMBOL_CHARSET;
			wcscpy(lf.lfFaceName, szNewFaceName);

			hfontOriginalCharset = _hfont;
			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
				// That's right, it IS symbol!
				// 'correct' the font to the 'true' one,
				//  and we'll get fMappedToSymbol
				fCorrectFont = TRUE;
				
			// Always restore the charset name, we didn't want to
			// question the original choice of charset here
			lf.lfCharSet = bCharSetOriginal;
		}
		else if(lf.lfCharSet == ARABIC_CHARSET || lf.lfCharSet == HEBREW_CHARSET)
		{
			DestroyFont();
			wcscpy(lf.lfFaceName, szNewFaceName);
			GetFontWithMetrics(&lf, szNewFaceName);
			fCorrectFont = TRUE;
		}
		else if(_bConvertMode != CVT_LOWBYTE && IsFECharSet(lf.lfCharSet)
			&& !OnWinNTFE() && !W32->OnWin9xFE())
		{
			const WCHAR *pch = NULL;
			if(_bCharSet != lf.lfCharSet && W32->OnWin9x())
			{
				// On Win95 when rendering to PS driver, we'll get something
				// other than what we asked. So try a known font we got from GDI
				switch (lf.lfCharSet)
				{
					case CHINESEBIG5_CHARSET:
						pch = GetFontName(g_iFontBig5);
						break;

					case SHIFTJIS_CHARSET:
						pch = GetFontName(g_iFontJapanese);
						break;

					case HANGEUL_CHARSET:
						pch = GetFontName(g_iFontHangul);
						break;

					case GB2312_CHARSET:
						pch = GetFontName(g_iFontGB2312);
						break;
				}
			}
			else							// FE Font (from Lang pack)
				pch = szNewFaceName;		//  on a nonFEsystem

			if(pch)
				wcscpy(lf.lfFaceName, pch);
			hfontOriginalCharset = _hfont;		

			GetFontWithMetrics(&lf, szNewFaceName);

			if(0 == wcsicmp(szNewFaceName, lf.lfFaceName))
			{
				// That's right, it IS the FE font we want!
				// 'correct' the font to the 'true' one.
				fCorrectFont = TRUE;
				if(W32->OnWin9x())
				{
					// Save up the GDI font names for later printing use
					switch(lf.lfCharSet)
					{
						case CHINESEBIG5_CHARSET:
							g_iFontBig5 = GetFontNameIndex(lf.lfFaceName);
							break;

						case SHIFTJIS_CHARSET:
							g_iFontJapanese = GetFontNameIndex(lf.lfFaceName);
							break;

						case HANGEUL_CHARSET:
							g_iFontHangul = GetFontNameIndex(lf.lfFaceName);
							break;

						case GB2312_CHARSET:
							g_iFontGB2312 = GetFontNameIndex(lf.lfFaceName);
							break;
					}
				}
			}
		}

		if(hfontOriginalCharset)
		{
			// Either keep old font or new one		
			if(fCorrectFont)
			{
				SideAssert(DeleteObject(hfontOriginalCharset));
			}
			else
			{
				// Fall back to original font
				DestroyFont();
				_hfont = hfontOriginalCharset;
				GetMetrics();
			}
			hfontOriginalCharset = NULL;
		}
	}

RetryCreateFont:
	{
		// Could be that we just plain simply get mapped to symbol.
		// Avoid it
		BOOL fMappedToSymbol =	(_bCharSet == SYMBOL_CHARSET &&
								 lf.lfCharSet != SYMBOL_CHARSET);

		BOOL fChangedCharset = (_bCharSet != lf.lfCharSet &&
								lf.lfCharSet != DEFAULT_CHARSET);

		if(fChangedCharset || fMappedToSymbol)
		{
			// Here, the system did not preserve the font language or mapped
			// our non-symbol font onto a symbol font, which will look awful
			// when displayed.  Giving us a symbol font when we asked for a
			// non-symbol font (default can never be symbol) is very bizarre
			// and means that either the font name is not known or the system
			// has gone complete nuts. The charset language takes priority
			// over the font name.  Hence, I would argue that nothing can be
			// done to save the situation at this point, and we have to
			// delete the font name and retry.

			if (fChangedCharset && lf.lfCharSet == THAI_CHARSET && _bCharSet == ANSI_CHARSET)
			{
				// We have charset substitution entries in Thai platforms that
				// will substitute all the core fonts with THAI_CHARSET to
				// ANSI_CHARSET. This is because we dont have Thai in such fonts.
				// Here we'll internally substitute the core font to Thai default
				// font so it matches its underlying THAI_CHARSET request (wchao).

				SHORT	iDefFont;
				BYTE	yDefHeight;
				BYTE	bDefPaf;

				W32->GetPreferredFontInfo(THAI_INDEX, TRUE, iDefFont, (BYTE&)yDefHeight, bDefPaf);

				const WCHAR* szThaiDefault = GetFontName(iDefFont);

				if (szThaiDefault)
				{
					DestroyFont();
					wcscpy(lf.lfFaceName, szThaiDefault);
					GetFontWithMetrics(&lf, szNewFaceName);
					goto GetOutOfHere;
				}
			}

			if(!wcsicmp(lf.lfFaceName, szFontOfChoice))
			{
				// We've been here already; no font with an appropriate
				// charset is on the system. Try getting the ANSI one for
				// the original font name. Next time around, we'll null
				// out the name as well!!
				if (lf.lfCharSet == ANSI_CHARSET)
				{
					TRACEINFOSZ("Asking for ANSI ARIAL and not getting it?!");

					// Those Win95 guys have definitely outbugged me
					goto GetOutOfHere;
				}

				DestroyFont();
				wcscpy(lf.lfFaceName, GetFontName(pCF->_iFont));
				lf.lfCharSet = ANSI_CHARSET;
			}
			else
			{
				DestroyFont();
				wcscpy(lf.lfFaceName, szFontOfChoice);
			}
			GetFontWithMetrics(&lf, szNewFaceName);
			goto RetryCreateFont;
		}
    }

GetOutOfHere:
	if (hfontOriginalCharset)
		SideAssert(DeleteObject(hfontOriginalCharset));

	// If we're really really stuck, get system font and hope for the best
	if(!_hfont)
	{
		iFont = IFONT_SYSTEM;
		_hfont = W32->GetSystemFont();
	}

	// Cache essential FONTSIGNATURE and GetFontLanguageInfo() information
	Assert(_hfont);
	if(iFont >= 0)							// Use cached value
		_qwFontSig = GetFontSignatureFromFace(iFont, NULL);

	if(_hfont && (iFont < 0 || _fCustomTextOut))
	{
		BOOL  fNonBiDiAscii;
		HFONT hfontOld = SelectFont(_hdc, _hfont);

		if (_fCustomTextOut)
			g_pcto->NotifyCreateFont(_hdc);

		if(iFont < 0)
			_qwFontSig = GetFontSignatureFromDC(_hdc, fNonBiDiAscii);

		SelectFont(_hdc, hfontOld);
	}

	return TRUE;
}

/*
 *	HFONT CCcs::GetFontWithMetrics (plf, szNewFaceName)
 *	
 *	@mfunc
 *		Get metrics used by the measurer and renderer and the new face name.
 *
 *	@rdesc
 *		HFONT if successful
 */
HFONT CCcs::GetFontWithMetrics (
	LOGFONT *plf,
	WCHAR *	 szNewFaceName)
{
	_hfont = CreateFontIndirect(plf);
    if(_hfont)
		GetMetrics(szNewFaceName);

	return (_hfont);
}

/*
 *	CCcs::GetOffset(pCF, dvpInch, pyOffset, pyAdjust);
 *	
 *	@mfunc
 *		Return the offset information for
 *
 *	@comm
 *		Return the offset value (used in line height calculations)
 *		and the amount to raise	or lower the text because of superscript
 *		or subscript considerations.
 */
void CCcs::GetOffset(
	const CCharFormat * const pCF, 
	LONG	dvpInch,
	LONG *	pyOffset, 
	LONG *	pyAdjust)
{
	*pyOffset = 0;
	*pyAdjust = 0;

	if (pCF->_yOffset)
		*pyOffset = MulDiv(pCF->_yOffset, dvpInch, LY_PER_INCH);

	if (pCF->_dwEffects & CFE_SUPERSCRIPT)
		*pyAdjust = _yHeight * 2 / 5;

	else if (pCF->_dwEffects & CFE_SUBSCRIPT)
		*pyAdjust = -_yDescent * 3 / 5;
}

/*
 *	void CCcs::GetFontOverhang(pdupOverhang, pdupUnderhang)
 *	
 *	@mfunc
 *		Synthesize font overhang/underhang information.
 *		Only applies to italic fonts.
 */
void CCcs::GetFontOverhang(
	LONG *pdupOverhang, 
	LONG *pdupUnderhang)
{
	if(_fItalic)
	{
		*pdupOverhang =  (_yHeight - _yDescent + 1) / 4;
		*pdupUnderhang =  (_yDescent + 1) / 4;
	}
	else
	{
		*pdupOverhang = 0;
		*pdupUnderhang = 0;
	}
}

/*
 *	BOOL CCcs::GetMetrics(szNewFaceName)
 *	
 *	@mfunc
 *		Get metrics used by the measurer and renderer.
 *
 *	@rdesc
 *		TRUE if successful
 *
 *	@comm
 *		These are in logical coordinates which are dependent
 *		on the mapping mode and font selected into the hdc.
 */
BOOL CCcs::GetMetrics(
	WCHAR *szNewFaceName)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::GetMetrics");
	AssertSz(_hfont, "No font has been created.");

	if (szNewFaceName)
		*szNewFaceName = 0;

	HFONT hfontOld = SelectFont(_hdc, _hfont);
    if(!hfontOld)
    {
        DestroyFont();
        return FALSE;
    }

	if (szNewFaceName)
		GetTextFace(_hdc, LF_FACESIZE, szNewFaceName);

	TEXTMETRIC tm;
	if(!GetTextMetrics(_hdc, &tm))
	{
		SelectFont(_hdc, hfontOld);
    	DestroyFont();
		return FALSE;
	}

	// The metrics, in logical units, dependent on the map mode and font.
	_yHeight		= (SHORT) tm.tmHeight;
	_yDescent		= (SHORT) tm.tmDescent;
	_xAveCharWidth	= (SHORT) tm.tmAveCharWidth;
	_xOverhangAdjust= (SHORT) tm.tmOverhang;

	// If fixed pitch, the tm bit is clear
	_fFixPitchFont = !(TMPF_FIXED_PITCH & tm.tmPitchAndFamily);

	_bCharSet = tm.tmCharSet;
	_fFECharSet = IsFECharSet(_bCharSet);

	// Use convert-mode proposed by CF, for which we are creating the font and
	// then tweak as necessary below.
	_bConvertMode = _bCMDefault;

	// If SYMBOL_CHARSET is used, use the A APIs with the low bytes of the
	// characters in the run
	if(_bCharSet == SYMBOL_CHARSET)
		_bConvertMode = CVT_LOWBYTE;

	else if (_bConvertMode == CVT_NONE)
		_bConvertMode = W32->DetermineConvertMode(_hdc, tm.tmCharSet);

	W32->CalcUnderlineInfo(_hdc, this, &tm);

	SelectFont(_hdc, hfontOld);
	return TRUE;
}

/* 	
 *	CCcs::DestroyFont()
 *
 *	@mfunc
 *		Destroy font handle for this CCcs
 */
void CCcs::DestroyFont()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::DestroyFont");

	// Clear out any old font
	if(_hfont)
	{
		SideAssert(DeleteObject(_hfont));
		_hfont = 0;
	}
}

/*
 *	CCcs::Compare (pCF,	hdc, dwFlags)
 *
 *	@mfunc
 *		Compares this font cache with the font properties of a
 *      given CHARFORMAT

 *	@devnote The pCF size here is in logical units
 *
 *	@rdesc
 *		FALSE iff did not match exactly.
 */
BOOL CCcs::Compare (
	const CCharFormat * const pCF,	//@parm Description of desired font
	HDC		hdc,
	DWORD	dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CCcs::Compare");

	BYTE bCharSet = CharSetFromCharRep(pCF->_iCharRep);
	BOOL result =
		_iFont			== pCF->_iFont &&
        _weight			== pCF->_wWeight &&
	    _fItalic		== ((pCF->_dwEffects & CFE_ITALIC) != 0) &&
		_hdc			== hdc &&
		_yHeightRequest	== pCF->_yHeight &&
		(_bCharSetRequest == bCharSet || _bCharSet == bCharSet
		//	|| _qwFontSig & FontSigFromCharRep(pCF->_iCharRep)// FUTURE:
		) &&	//  ok except for codepage conversions (metafiles and Win9x)
		_fCustomTextOut == ((pCF->_dwEffects & CFE_CUSTOMTEXTOUT) != 0) &&
		_fForceTrueType == ((dwFlags & FGCCSUSETRUETYPE) != 0) &&
		_fUseAtFont		== ((dwFlags & FGCCSUSEATFONT) != 0) &&
		_tflow			== (dwFlags & 0x3) &&
        _bPitchAndFamily == pCF->_bPitchAndFamily &&
		(!(pCF->_dwEffects & CFE_RUNISDBCS) || _bConvertMode == CVT_LOWBYTE);

	return result;
}

// =========================  WidthCache by jonmat  =========================
/*
 *	CWidthCache::CheckWidth(ch, &dup)
 *	
 *	@mfunc
 *		Check to see if we have a width for a WCHAR character.
 *
 *	@comm
 *		Used prior to calling FillWidth(). Since FillWidth
 *		may require selecting the map mode and font in the HDC,
 *		checking here first saves time.
 *
 *	@comm
 *		Statistics are maintained to determine when to
 *		expand the cache. The determination is made after a constant
 *		number of calls in order to make calculations faster.
 *
 *	@rdesc
 *		returns TRUE if we have the width of the given WCHAR.
 */
BOOL CWidthCache::CheckWidth (
	const WCHAR ch,		//@parm char, can be Unicode, to check width for
	LONG &		dup)	//@parm Width of character
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CheckWidth");
	BOOL	fExist;

	// 30,000 FE characters all have the same width
	if (FLookasideCharacter(ch))
	{
		dup = _dupCJK;
		return dup != 0;
	}

	const	CacheEntry * pWidthData = GetEntry ( ch );

	fExist = (ch == pWidthData->ch		// Have we fetched the width?
				&& pWidthData->width);	//  only because we may have ch == 0.

	dup = fExist ? pWidthData->width : 0;

	if(!_fMaxPerformance)				//  if we have not grown to the max...
	{
		_accesses++;
		if(!fExist)						// Only interesting on collision.
		{
			if(0 == pWidthData->width)	// Test width not ch, 0 is valid ch.
			{
				_cacheUsed++;			// Used another entry.
				AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
			}
			else
				_collisions++;			// We had a collision.

			if(_accesses >= PERFCHECKEPOCH)
				CheckPerformance();		// After some history, tune cache.
		}
	}
#ifdef DEBUG							// Continue to monitor performance
	else
	{
		_accesses++;
		if(!fExist)						// Only interesting on collision.
		{
			if(0 == pWidthData->width)	// Test width not ch, 0 is valid ch.
			{
				_cacheUsed++;			// Used another entry.
				AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
			}
			else
				_collisions++;			// We had a collision.
		}

		if(_accesses > PERFCHECKEPOCH)
		{
			_accesses = 0;
			_collisions = 0;
		}
	}
#endif

	return fExist;
}

/*
 *	CWidthCache::CheckPerformance()
 *	
 *	@mfunc
 *		check performance and increase cache size if deemed necessary.
 *
 */
void CWidthCache::CheckPerformance()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CheckPerformance");

	if(_fMaxPerformance)				// Exit if already grown to our max.
		return;

	// Grow the cache when cacheSize > 0 && 75% utilized or approx 8%
	// collision rate
	if (_cacheSize > DEFAULTCACHESIZE && (_cacheSize >> 1) + (_cacheSize >> 2) < _cacheUsed ||
		_collisions > 0 && _accesses / _collisions <= 12)
	{
		GrowCache( &_pWidthCache, &_cacheSize, &_cacheUsed );
	}
	_collisions	= 0;					// This prevents wraps but makes
	_accesses	= 0;					//  calc a local rate, not global.
										
	if(_cacheSize >= maxCacheSize)		// Note if we've max'ed out
		_fMaxPerformance = TRUE;

	AssertSz( _cacheSize <= maxCacheSize, "max must be 2^n-1");
	AssertSz( _cacheUsed <= _cacheSize+1, "huh?");
}

/*
 *	CWidthCache::GrowCache(ppWidthCache, pCacheSize, pCacheUsed)
 *	
 *	@mfunc
 *		Exponentially expand the size of the cache.
 *
 *	@comm
 *		The cache size must be of the form 2^n as we use a
 *		logical & to get the hash MOD by storing 2^n-1 as
 *		the size and using this as the modulo.
 *
 *	@rdesc
 *		Returns TRUE if we were able to allocate the new cache.
 *		All in params are also out params.
 *		
 */
BOOL CWidthCache::GrowCache(
	CacheEntry **ppWidthCache,	//@parm cache
	INT *		pCacheSize,		//@parm cache's respective size.
	INT *		pCacheUsed)		//@parm cache's respective utilization.
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::GrowCache");

	CacheEntry		*pNewWidthCache, *pOldWidthCache, *pWidthData;
	INT 			j, newCacheSize, newCacheUsed;
	WCHAR			ch;
	
	j = *pCacheSize;						// Allocate cache of 2^n.
	newCacheSize = max ( INITIALCACHESIZE, (j << 1) + 1);
	pNewWidthCache = (CacheEntry *)
			PvAlloc( sizeof(CacheEntry) * (newCacheSize + 1 ), GMEM_ZEROINIT);

	if(pNewWidthCache)
	{
		newCacheUsed = 0;
		*pCacheSize = newCacheSize;			// Update out params.
		pOldWidthCache = *ppWidthCache;
		*ppWidthCache = pNewWidthCache;
		for (; j >= 0; j--)					// Move old cache info to new.
		{
			ch = pOldWidthCache[j].ch;
			if ( ch )
			{
				pWidthData			= &pNewWidthCache [ch & newCacheSize];
				if ( 0 == pWidthData->ch )
					newCacheUsed++;			// Used another entry.
				pWidthData->ch		= ch;
				pWidthData->width	= pOldWidthCache[j].width;
			}
		}
		*pCacheUsed = newCacheUsed;			// Update out param.
											// Free old cache.
		if (pOldWidthCache < &_defaultWidthCache[0] ||
			pOldWidthCache >= &_defaultWidthCache[DEFAULTCACHESIZE+1])
		{
			FreePv(pOldWidthCache);
		}
	}
	return NULL != pNewWidthCache;
}


/*
 *	CWidthCache::Free()
 *	
 *	@mfunc
 *		Free any dynamic memory allocated by the width cache and prepare
 *		it to be recycled.
 */
void CWidthCache::Free()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::Free");

	_fMaxPerformance = FALSE;
	_dupCJK = 0;
	_cacheSize		= DEFAULTCACHESIZE;
	_cacheUsed		= 0;
	_collisions		= 0;
	_accesses		= 0;
	if(_pWidthCache != &_defaultWidthCache[0])
	{
		FreePv(_pWidthCache);
		_pWidthCache = &_defaultWidthCache[0];
	}	
	ZeroMemory(_pWidthCache, sizeof(CacheEntry)*(DEFAULTCACHESIZE + 1));
}

/*
 *	CWidthCache::CWidthCache()
 *	
 *	@mfunc
 *		Point the caches to the defaults.
 */
CWidthCache::CWidthCache()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::CWidthCache");

	_pWidthCache = &_defaultWidthCache[0];
}

/*
 *	CWidthCache::~CWidthCache()
 *	
 *	@mfunc
 *		Free any allocated caches.
 */
CWidthCache::~CWidthCache()
{
	TRACEBEGIN(TRCSUBSYSFONT, TRCSCOPEINTERN, "CWidthCache::~CWidthCache");

	if (_pWidthCache != &_defaultWidthCache[0])
		FreePv(_pWidthCache);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\frunptr.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	FRUNPTR.C -- FormatRunPtr methods |
 *
 *		common code to handle character and paragraph format runs
 *	
 *	Original Authors: <nl>
 *		Original RichEdit 1.0 code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	History:
 *		6/25/95		alexgo	convert to use Auto-Doc and simplified backing
 *		store model
 *
 *	@devnote
 *		BOR and EOR mean Beginning Of Run and End Of Run, respectively
 *
 *	Copyright (c) 1995-1999, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_rtext.h"
#include "_font.h"

ASSERTDATA

//
//	Invariant stuff
//
#define DEBUG_CLASSNAME	CFormatRunPtr

#include "_invar.h"

#ifdef DEBUG
/*
 *	CFormatRunPtr::Invariant
 *
 *	@mfunc	Invariant for format run pointers
 *
 *	@rdesc	BOOL
 */
BOOL CFormatRunPtr::Invariant() const
{
	if(IsValid())
	{
		CFormatRun *prun = GetRun(0);
		if(prun && _iRun)
		{
			Assert(prun->_cch > 0);
		}
	}
	else
	{
		Assert(_ich == 0);
	}
	return CRunPtrBase::Invariant();
}
#endif

/*
 *	CFormatRunPtr::InitRuns(ich, cch, iFormat, ppfrs)
 *
 *	@mfunc
 *		Setup this format run ptr for rich-text operation, namely,
 *		allocate CArray<lt>CFormatRun<gt> if not allocated, assign it to this
 *		run ptr's _pRuns, add initial run if no runs are present, and store
 *		initial cch and ich
 *	
 *	@rdesc
 *		TRUE if succeeds
 */
BOOL CFormatRunPtr::InitRuns(
	LONG ich,				//@parm # chars in initial run
	LONG cch,				//@parm char offset in initial run
	CFormatRuns **ppfrs)	//@parm ptr to CFormatRuns ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::InitRuns");

	_TEST_INVARIANT_

	AssertSz( ppfrs,
		"FRP::InitRuns: illegal ptr to runs");
	AssertSz( !IsValid(),
		"FRP::InitRuns: ptr already valid");

	if(!*ppfrs)									// Allocate format runs
	{
		_pRuns = (CRunArray *) new CFormatRuns();
		if(!_pRuns)
			goto NoRAM;
		*ppfrs = (CFormatRuns *)_pRuns;
	}
	else										// Format runs already alloc'd
		_pRuns = (CRunArray *)*ppfrs;			// Cache ptr to runs

	if(!Count())								// No runs yet, so add one
	{
		CFormatRun *pRun= Add(1, NULL);
		if(!pRun)
			goto NoRAM;

#ifdef DEBUG
		PvSet(*(void**)_pRuns);
#endif
		_ich			= ich;

		ZeroMemory(pRun, sizeof(*pRun));
		pRun->_cch		= cch;					// Define its _cch
		pRun->_iFormat 	= -1;					//  and _iFormat
	}
	else
		BindToCp(ich);							// Format runs are in place

	return TRUE;

NoRAM:
	TRACEERRSZSC("CFormatRunPtr::InitRuns: Out Of RAM", E_OUTOFMEMORY);
	return FALSE;
}


/*
 *	CFormatRunPtr::Delete(cch, pf, cchMove)
 *	
 *	@mfunc
 *		Delete/modify runs starting at this run ptr up to cch chars. <nl>
 *		There are 7 possibilities: <nl>
 *		1.	cch comes out of this run with count left over, i.e.,
 *			cch <lt>= (*this)->_cch - _ich && (*this)->_cch > cch
 *			(simple: no runs deleted/merged, just subtract cch) <nl>
 *		2.	cch comes out of this run and empties run and doc
 *			(simple: no runs left to delete/merge) <nl>
 *		3.	cch comes out of this run and empties run, which is last
 *			(need to delete run, no merge possibility) <nl>
 *		4.	cch comes out of this run and empties run, which is first
 *			(need to delete run, no merge possibility) <nl>
 *		5.	cch exceeds count available in this run and this run is last
 *			(simple: treat as 3.)  <nl>
 *		6.	cch comes out of this run and empties run with runs before
 *			and after (need to delete run; merge possibility) <nl>
 *		7.	cch comes partly out of this run and partly out of later run(s)
 *			(may need to delete and merge) <nl>
 *
 *	@comm
 *		PARAFORMATs have two special cases that use the cchMove argument set
 *		up in CRchTxtPtr::ReplaceRange().
 */
void CFormatRunPtr::Delete(
	LONG		  cch,		//@parm # chars to modify format runs for
	IFormatCache *pf,		//@parm IFormatCache ptr for ReleaseFormat
	LONG		  cchMove)	//@parm cch to move between runs (always 0 for CF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::Delete");

	_TEST_INVARIANT_

	// We should not have any boundary cases for empty or NULL pointers.
	// (i.e. if there's no text, then nobody should be calling delete).

	Assert(IsValid());

	LONG			cchEnd = 0;				// Probably unnecessary: see below
	LONG			cRun = 1;
	BOOL			fLast = (_iRun == Count() - 1);
	LONG			ifmtEnd, ifmtStart;
	CFormatRun *	pRun = Elem(_iRun);
	CFormatRun *	pRunRp;
	LONG			cchChunk = pRun->_cch - _ich;
	CFormatRunPtr	rp(*this);				// Clone this run ptr
    CBiDiLevel      levelStart = {0,0};
    CBiDiLevel      levelEnd = {0,0};

	rp.AdjustBackward();					// If at BOR, move to prev EOR
	ifmtStart = rp.GetRun(0)->_iFormat;		//  to get start format
    levelStart = rp.GetRun(0)->_level;      // and level
	rp = *this;								// In case RpAdjustCp() backed up

// Process deletes confined to this run first, since their logic tends to
// clutter up other cases

	AssertSz(cch >= 0, "FRP::Delete: cch < 0");

	if(fLast)								// Handle oversized cch on last
		cch = min(cch, cchChunk); 			//  run here

	if(cch <= cchChunk)						// cch comes out of this run
	{
		pRun->_cch -= cch;
		Assert(pRun->_cch >= 0);
		if(cchMove)							// If nonzero here, we are
		{									//  deleting EOP at end of run
			rp.AdjustForward();				// Adjust rp to beginning of
			goto move;						//  next run and go move cchMove
		}									//  chars back into this run
		if(pRun->_cch)						// Something left in run: done
			return;
											// Note: _ich = 0
		if(!_iRun || fLast)					// This run is either first
		{									//  or last
			AdjustBackward();				// If last, go to prev EOR
			if(_ich)						// This run is empty so delete
				cRun++;						// Compensate for cRun-- coming up
			ifmtStart = -2;					// No runs eligible for merging
		}									//  so use unmatchable ifmtStart
		rp.NextRun();						// Set up to get next _iFormat
	}		
	else
	{
		rp.Move(cch);						// Move clone to end of delete
		pRunRp = rp.GetRun(0);
		cRun = rp._iRun - _iRun				// If at EOR, then need to add
			 + (rp._ich == pRunRp->_cch);	//  one more run to delete
		pRun->_cch = _ich;					// Shorten this run to _ich chars
		pRunRp->_cch -= rp._ich;			// Shorten last run by rp._ich
		rp._ich = 0;

		Assert(pRunRp->_cch >= 0);
		AssertSz(cRun > 0, "FRP: bogus runptr");

		if(!_iRun)		  					// First run?
			ifmtStart = -2;					// Then we cannot merge runs so
	}										//  set to unmergable format

	ifmtEnd = -3;							// Default invalid format at end
	if(rp.IsValid())
	{
		// FUTURE (murrays): probably rp is always valid here now and
		// pRun->_cch is nonzero
		pRun = rp.GetRun(0);
		if (pRun->_cch)                     // run not empty
		{
			ifmtEnd = pRun->_iFormat;		// Remember end format and count
            levelEnd = pRun->_level;
			cchEnd  = pRun->_cch;			//  in case of merge
		}
		else if(rp._iRun != rp.Count() - 1)	// run not last
		{
			pRun = rp.GetRun(1);
			ifmtEnd = pRun->_iFormat;		// Remember end format and count
            levelEnd = pRun->_level;
			cchEnd  = pRun->_cch;			//  in case of merge
		}
	}

	rp = *this;								// Default to delete this run
	if(_ich)								// There are chars in this run
	{
		if(cchMove + _ich == 0)				// Need to combine all chars of
		{									//  this run with run after del,
			pf->AddRef(ifmtEnd);			//  so setup merge below using
			ifmtStart = ifmtEnd;			//  ifmtEnd. This run then takes
			pf->Release(GetRun(0)->_iFormat);
			GetRun(0)->_iFormat = ifmtEnd;	//  place of run after del.
            GetRun(0)->_level = levelEnd;
			cchMove = 0;					// cchMove all accounted for
		}
		rp.NextRun();						// Don't delete this run; start
		cRun--;								//  with next one
	}

	AdjustBackward();						// If !_ich, go to prev EOR

    if(ifmtEnd >=0 &&                       // Same formats: merge runs
       ifmtEnd == ifmtStart &&
       levelStart == levelEnd)
	{
		GetRun(0)->_cch += cchEnd;			// Add last-run cch to this one's
		Assert(GetRun(0)->_cch >= 0);
		cRun++;								// Setup to eat last run
	}

	if(cRun > 0)							// There are run(s) to delete
	{
		rp.Remove(cRun, pf);
		if(!Count())						// If no more runs, keep this rp
			_ich = _iRun = 0;				//  valid by pointing at cp = 0
	}

move:
	if(cchMove)								// Need to move some cch between
	{										//  this run and next (See
		GetRun(0)->_cch += cchMove;			//  CRchTxtPtr::ReplaceRange())
		rp.GetRun(0)->_cch -= cchMove;

		Assert(GetRun(0)->_cch >= 0);
		Assert(rp.GetRun(0)->_cch >= 0);
		Assert(_iRun < rp._iRun);

		if(!rp.GetRun(0)->_cch)				// If all chars moved out of rp's
			rp.Remove(1, pf);				//  run, delete it

		if(cchMove < 0)						// Moved -cchMove chars from this
		{									//  run to next
			if(!GetRun(0)->_cch)
				Remove(1, pf);
			else
				_iRun++;					// Keep this run ptr in sync with

			_ich = -cchMove;				//  cp (can't use NextRun() due
		}									//  to Invariants)
	}
	AdjustForward();						// Don't leave ptr at EOR unless
}											//  there are no more runs

/*
 *	CFormatRunPtr::InsertFormat(cch, ifmt, pf)
 *	
 *	@mfunc
 *		Insert cch chars with format ifmt into format runs starting at
 *		this run ptr	
 *
 *	@rdesc
 *		count of characters added
 *
 *	@devnote	
 *		It is the caller's responsibility to ensure that we are in the
 *		"normal" or "empty" state.  A format run pointer doesn't know about
 *		CTxtStory, so it can't create the run array without outside help.
 */
LONG CFormatRunPtr::InsertFormat(
	LONG cch,				//@parm # chars to insert
	LONG ifmt,				//@parm format to use
	IFormatCache *pf)		//@parm pointer to IFormatCache to AddRefFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::InsertFormat");

	LONG		cRun;
	CFormatRun *pRun;
	CFormatRun *pRunPrev;
	LONG		cchRun;						// Current-run length,
	LONG		ich;						//  offset, and
	LONG		iFormat; 					//  format

	_TEST_INVARIANT_

	Assert(_pRuns);
	if(!IsValid())
	{		
		// Empty run case (occurs when inserting after all text is deleted)
		pRun = Add(1, NULL);
		goto StoreNewRunData;				// (located at end of function)
	}

	// Go to previous run if at a boundary case
	AdjustBackward();
	pRun	= Elem(_iRun);					// Try other cases
	cchRun 	= pRun->_cch;
	iFormat = pRun->_iFormat;
	ich 	= _ich;							

	// Same run case.  Note that there is an additional boundary case; if we
	// are the _end_ of one run, then the next run may have the necessary
	// format.
	if(ifmt == iFormat)						// IP already has correct fmt
	{
		pRun->_cch	+= cch;
		_ich		+= cch;					// Inc offset to keep in sync
		return cch;
	}
	if(_ich == pRun->_cch && _iRun < _pRuns->Count() - 1)
	{
		AdjustForward();
		pRun = Elem(_iRun);

		Assert(pRun);

		if(pRun->_iFormat == ifmt)
		{
			pRun->_cch += cch;
			_ich += cch;
			return cch;
		}
		AdjustBackward();
	}

	// Prior run case (needed when formatting change occurs on line break
	//		and caret is at beginning of new line)
	if(!ich && _iRun > 0 )					// IP at start of run
	{
		pRunPrev = GetPtr(pRun, -1);
		if( ifmt == pRunPrev->_iFormat)		// Prev run has same format:
		{									//  add count to prev run and
			pRunPrev->_cch += cch;
			return cch;
		}
	}

	// Create new run[s] cases.  There is a special case for a format
	// run of zero length: just re-use it.
	if(!pRun->_cch)
	{
		// This assert has been toned down to ignore a plain text control
		// being forced into IME Rich Composition.
		AssertSz( /* FALSE */ pRun->_iFormat == -1 && Count() == 1,
			"CFormatRunPtr::InsertFormat: 0-length run");
		pf->Release(pRun->_iFormat);
	}
	else									// Need to create 1 or 2 new
	{										//  runs for insertion
		cRun = 1;							// Default 1 new run
		if(ich && ich < cchRun)				// Not at beginning or end of
			cRun++;							//  run, so need two new runs

		// The following insert call adds one or two runs at the current
		// position. If the new run is inserted at the beginning or end
		// of the current run, the latter needs no change; however, if
		// the new run splits the current run in two, both pieces have
		// to be updated (cRun == 2 case).

		pRun = Insert(cRun);				// Insert cRun run(s)
		if(!pRun)							// Out of RAM. Can't insert
		{									//  new format, but can keep
			_ich += cch;					//  run ptr and format runs
			GetRun(0)->_cch += cch;			//  valid.  Note: doesn't
			return cch;						//  signal any error; no access
		}									//  to _ped->_fErrSpace

		if(ich)								// Not at beginning of run,
		{
			pRunPrev = pRun;				// Previous run is current run
			IncPtr(pRun);					// New run is next run
			VALIDATE_PTR(pRun);
			pRun->_cch = cch;				// Keep NextRun() invariant happy
			NextRun();						// Point this runptr at it too
			if(cRun == 2)					// Are splitting current run
			{								// _iFormat's are already set
				AssertSz(pRunPrev->_iFormat == iFormat,
					"CFormatRunPtr::InsertFormat: bad format inserted");
				pRunPrev->_cch = ich;		// Divide up original cch
				GetPtr(pRun, 1)->_cch		//  accordingly
					= cchRun - ich;
				pf->AddRef(iFormat);		// Addref iFormat for extra run
			}
		}
	}

StoreNewRunData:
	pf->AddRef(ifmt);						// Addref ifmt
	ZeroMemory(pRun, sizeof(*pRun));
	pRun->_iFormat	= ifmt;					// Store insert format and count
	pRun->_cch		= cch;					//  of new run
	_ich			= cch;					// cp goes at end of insertion

	return cch;
}

/*
 *	CFormatRunPtr::MergeRuns(iRun, pf)
 *	
 *	@mfunc
 *		Merge adjacent runs that have the same format between this run
 *		<md CFormatRunPtr::_iRun> and that for <p iRun>		
 *
 *	@comm
 *		Changes this run ptr
 */
void CFormatRunPtr::MergeRuns(
	LONG iRun, 				//@parm last run to check (can preceed or follow
							// <md CFormatRunPtr::_iRun>)
	IFormatCache *pf)		//@parm pointer to IFormatCache to ReleaseFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::MergeRuns");

	LONG	cch;
	LONG	cRuns		= iRun - _iRun;
	LONG	iDirection	= 1;				// Default going forward
	CFormatRun *pRun;

	_TEST_INVARIANT_

	if(cRuns < 0)
	{
		cRuns = -cRuns;
		iDirection = -1;
	}
	if(!IsValid())							// Allow starting run to be
	{										//  invalid
		Assert(FALSE);						// I think this is old...
		ChgRun(iDirection);					
	}

	while(cRuns--)
	{
        if(!GetRun(0)->_cch && !_iRun && _iRun < Count() - 1)
        {
            if(iDirection > 0)
                PrevRun();
            Remove(1, pf);
            continue;
        }

		pRun = GetRun(0);					// Save the current run

		if(!ChgRun(iDirection))				// Go to next (or prev) run
			return;							// No more runs to check

		if(pRun->SameFormat(GetRun(0)))
		{									// Like formatted runs
			if(iDirection > 0)				// Point at the first of the
				PrevRun();					//  two runs
			cch = GetRun(0)->_cch;			// Save its count
			Remove(1, pf);					// Remove it
			GetRun(0)->_cch += cch;			// Add its count to the other's,
		}									//  i.e., they're merged
	}
}

/*
 *	CFormatRunPtr::Remove(cRun, flag, pf)
 *	
 *	@mfunc
 *		Remove cRun runs starting at _iRun
 */
void CFormatRunPtr::Remove(
	LONG		  cRun,
	IFormatCache *pf)
{
	CFormatRun *pRun = GetRun(0);			// Point at run(s) to delete

	for(LONG j = 0; j < cRun; j++, IncPtr(pRun))
		pf->Release(pRun->_iFormat);		// Decrement run reference count

	CRunPtr<CFormatRun>::Remove(cRun);
}

/*
 *	CFormatRunPtr::SetFormat(ifmt, cch, pf, pLevel)
 *	
 *	@mfunc
 *		Set format for up to cch chars of this run to ifmt, splitting run
 *		as needed, and returning the character count actually processed
 *
 *	@rdesc
 *		character count of run chunk processed, CP_INFINITE on failure
 *		this points at next run
 *
 *	Comments:
 *		Changes this run ptr.  cch must be >= 0.
 *
 *		Note 1) for the first run in a series, _ich may not = 0, and 2) cch
 *		may be <lt>, =, or <gt> the count remaining in the run. The algorithm
 *		doesn't split runs when the format doesn't change.
 */
LONG CFormatRunPtr::SetFormat(
	LONG			ifmt, 	//@parm format index to use
	LONG			cch, 	//@parm character count of remaining format range
	IFormatCache *	pf,		//@parm pointer to IFormatCache to
	CBiDiLevel*		pLevel) //@parm pointer to BiDi level structure
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::SetFormat");
							//		AddRefFormat/ReleaseFormat
	LONG			cchChunk;
	LONG			iFormat;
	CFormatRun *	pRun;
	CFormatRun *	pChgRun;	// run that was reformatted
    CBiDiLevel      level;

	_TEST_INVARIANT_

	if(!IsValid())
		return 0;

	pRun 		= GetRun(0);				// pRun points at current run in
	cchChunk 	= pRun->_cch - _ich;		//  this function
	iFormat 	= pRun->_iFormat;
    level       = pRun->_level;
	pChgRun		= pRun;

	AssertSz(cch, "Have to have characters to format!");
	AssertSz(pRun->_cch, "uh-oh, empty format run detected");

    if(ifmt != iFormat || (pLevel && level != *pLevel)) // New and current formats differ
	{
		AssertSz(cchChunk, "Caller did not call AdjustForward");

		if(_ich)							// Not at either end of run: need
		{									//  to split into two runs of
			if(!(pRun = Insert(1)))			//  counts _ich and _pRun->_cch
			{								//  - _ich, respectively
				return CP_INFINITE;			// Out of RAM: do nothing; just
			}								//  keep current format
			pRun->_cch		= _ich;
			pRun->_iFormat	= iFormat;		// New run has same format
            pRun->_level    = level;        // and same level
			pf->AddRef(iFormat);			// Increment format ref count
			NextRun();						// Go to second (original) run
			IncPtr(pRun);					// Point pRun at current run
			pRun->_cch = cchChunk;			// Note: IncPtr is a bit more
			pChgRun = pRun;
		}									//  efficient than GetRun, but
											//  trickier to code right
		if(cch < cchChunk)					// cch doesn't cover whole run:
		{									//  need to split into two runs
			if(!(pRun = Insert(1)))
			{
				// Out of RAM, so formatting's wrong, oh well.  We actually
				// "processed" all of the characters, so return that (though
				// the tail end formatting isn't split out right)
				return cch;
			}
			pRun->_cch = cch;				// New run gets the cch
			pRun->_iFormat = ifmt;			//  and the new format
			pChgRun = pRun;
			IncPtr(pRun);					// Point pRun at current run
			pRun->_cch = cchChunk - cch;	// Set leftover count
		}
		else								// cch as big or bigger than
		{									//  current run
			pf->Release(iFormat);			// Free run's current format
			pRun->_iFormat = ifmt;			// Change it to new format		
			pChgRun = pRun;
		}									// May get merged later
		pf->AddRef(ifmt);					// Increment new format ref count
	}
	else if(!cchChunk)
	{
		pRun->_cch += cch;					// Add cch to end of current run
		cchChunk = cch;						// Report that all cch are done
		IncPtr(pRun);
		pRun->_cch -= cch;					// Remove count from next run
		if(!pRun->_cch)						// Next run is now empty, so 
		{									//  remove it
			_iRun++;
			Remove(1, pf);			
			_iRun--;						// Backup to start run
		}
	}

	// Record embedding level to changed run
	if (pLevel)
		pChgRun->_level = *pLevel;

	cch = min(cch, cchChunk);
	Move(cch);
	AdjustForward();
	return cch;
}

/*
 *	CFormatRunPtr::GetFormat()
 *
 *	@mfunc
 *		return format index at current run pointer position
 *
 *	@rdesc
 *		current format index
 */
short CFormatRunPtr::GetFormat() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFormatRunPtr::GetFormat");
	_TEST_INVARIANT_

	return IsValid() ? GetRun(0)->_iFormat : -1;
}


/*
 *	CFormatRunPtr::SplitFormat(IFormatCache*)
 *
 *	@mfunc
 *		Split a format run
 *
 *	@rdesc
 *		If succeeded the run pointer moves to the next splitted run
 */
void CFormatRunPtr::SplitFormat(IFormatCache* pf)
{
	if (!_ich || _ich == GetRun(0)->_cch)
		return;

	CFormatRun*		pRun = GetRun(0);
	LONG			iFormat = pRun->_iFormat;
	LONG			cch = pRun->_cch - _ich;
	CBiDiLevel		level = pRun->_level;

	if (pRun = Insert(1))
	{
		pRun->_cch = _ich;
		pRun->_iFormat = iFormat;
		pRun->_level = level;
		pf->AddRef(iFormat);
		NextRun();
		IncPtr(pRun);
		pRun->_cch = cch;
	}
}

/*
 *	CFormatRunPtr::SetLevel(level)
 *
 *	@mfunc
 *		Set run's embedding level
 */
void CFormatRunPtr::SetLevel (CBiDiLevel& level)
{
	if (!IsValid())
	{
		Assert(FALSE);
		return;
	}

	CFormatRun*	pRun = GetRun(0);

	if (pRun)
		pRun->_level = level;
}

BYTE CFormatRunPtr::GetLevel (CBiDiLevel* pLevel)
{
	CFormatRun*	pRun;


	if (!IsValid() || !(pRun = GetRun(0)))
	{
		Assert(FALSE);

		if (pLevel)
		{
			pLevel->_value = 0;
			pLevel->_fStart = FALSE;
		}
		return 0;
	}

	if (pLevel)
		*pLevel = pRun->_level;

	return pRun->_level._value;
}

/*
 *	CFormatRunPtr::AdjustFormatting(cch, pf)
 *	
 *	@mfunc
 *		Use the same format index for the cch chars at this run ptr
 *		as that immediately preceeding it (if on run edge).
 *
 *	@devnote
 *		This runptr ends up pointing at what was the preceeding run,
 *		since the current run has been moved into the preceeding run.
 *
 *		FUTURE: might be better to take the cch equal to chars in
 *		the following run.
 */	
void CFormatRunPtr::AdjustFormatting(
	LONG		  cch,		//@parm Count of chars to extend formatting
	IFormatCache *pf)		//@parm Format cache ptr for AddRef/Release
{
	if(!IsValid())
		return;							// Nothing to merge

	CFormatRunPtr rp(*this);
	CBiDiLevel	  level;
										// Move this run ptr to end of
	AdjustBackward();					//  preceeding run (if at run edge)
	rp.AdjustForward();					//  (merge may delete run at entry)
	if(_iRun != rp._iRun)				// On a format edge: copy previous
	{									//  format index over
		GetLevel(&level);
		rp.SetFormat(GetFormat(), cch, pf, &level);	// Format cch chars at this
		rp.MergeRuns(_iRun, pf);			//  runptr
	}
}


///////////////////////////// CCFRunPtr ///////////////////////////////

CCFRunPtr::CCFRunPtr(const CRchTxtPtr &rtp)
		: CFormatRunPtr(rtp._rpCF)
{
	_ped = rtp.GetPed();
}

CCFRunPtr::CCFRunPtr(const CFormatRunPtr &rp, CTxtEdit *ped)
		: CFormatRunPtr(rp)
{
	_ped = ped;
}

/*
 *	CCFRunPtr::IsMask(dwMask, MaskOp)
 *	
 *	@mfunc
 *		return TRUE according to the mask operation MaskOp operating on
 *		_dwEffects.
 *
 *	@rdesc
 *		TRUE if bits in CCharFormat::dwEffects correspond to those in dwMask
 */
BOOL CCFRunPtr::IsMask(
	DWORD	dwMask,		//@parm Bit mask to use on dwEffects
	MASKOP	MaskOp)		//@parm Logic operation for bits
{
	DWORD dwEffects = _ped->GetCharFormat(GetFormat())->_dwEffects;

	if(MaskOp == MO_EXACT)				// Bit masks must be identical
		return dwEffects == dwMask;

	dwEffects &= dwMask;
	if(MaskOp == MO_OR)					// TRUE if one or more effect bits
		return dwEffects != 0;			//  identified by mask are on

	if(MaskOp == MO_AND)				// TRUE if all effect bits
		return dwEffects == dwMask;		//  identified by mask are on

	AssertSz(FALSE, "CCFRunPtr::IsMask: illegal mask operation");
	return FALSE;
}

/*
 *	CCFRunPtr::IsInHidden()
 *	
 *	@mfunc
 *		return TRUE if CCharFormat for this run ptr has CFE_HIDDEN bit set
 *
 *	@rdesc
 *		TRUE if CCharFormat for this run ptr has CFE_HIDDEN bit set
 */
BOOL CCFRunPtr::IsInHidden()
{	
	if (!IsValid())
		return FALSE;		// No format run, not hidden

	AdjustForward();
	BOOL fHidden = IsHidden();
	if(_ich)
		return fHidden;

	AdjustBackward();
	return fHidden && IsHidden();
}

/*
 *	CCFRunPtr::FindUnhidden()
 *	
 *	@mfunc
 *		Find nearest expanded CF going forward. If none, find nearest going
 *		backward.  If none, go to start of document
 *	
 *	@rdesc
 *		cch to nearest expanded CF as explained in function description
 *
 *	@devnote
 *		changes this run ptr
 */
LONG CCFRunPtr::FindUnhidden()
{
	LONG cch = FindUnhiddenForward();

	if(IsHidden())
		cch = FindUnhiddenBackward();

	return cch;
}

/*
 *	CCFRunPtr::FindUnhiddenForward()
 *	
 *	@mfunc
 *		Find nearest expanded CF going forward.  If none, go to EOD
 *	
 *	@rdesc
 *		cch to nearest expanded CF going forward
 *
 *	@devnote
 *		changes this run ptr
 */
LONG CCFRunPtr::FindUnhiddenForward()
{
	LONG cch = 0;

	AdjustForward();
	while(IsHidden())
	{
		cch += GetCchLeft();
		if(!NextRun())
			break;
	}
	return cch;
}

/*
 *	CCFRunPtr::MatchFormatSignature
 *	
 *	@mfunc
 *		Match the current format's font signature with the script (index to codepage).
 *		It takes care single-codepage fonts which implicitly supports ASCII range.
 *
 *	@rdesc
 *		return how font matched
 */

inline int CCFRunPtr::MatchFormatSignature (
	const CCharFormat*	pCF,
	int					iCharRep,
	int					iMatchCurrent,
	QWORD *				pqwFontSig)
{
	QWORD qwFontSig = 0;

	if (GetFontSignatureFromFace(pCF->_iFont, &qwFontSig) != 0)
	{
		if (pqwFontSig)
			*pqwFontSig = qwFontSig;

		if (iMatchCurrent & MATCH_ASCII && fc().GetInfoFlags(pCF->_iFont).fNonBiDiAscii)
			return MATCH_ASCII;

		if (FontSigFromCharRep(iCharRep) & ~FASCII & qwFontSig)
			return MATCH_FONT_SIG;
	}
	return 0;
}

/*
 *	CCFRunPtr::GetPreferredFontInfo(iCharRep, &iCharRepRet, &iFont, &yHeight, &bPitchAndFamily,
 *									iFormat, iMatchCurrent, piFormatOut )
 *	
 *	@mfunc
 *		Find the preferred font for the given code page around the range.
 *
 *	@rdesc
 *		boolean true if suitable font found, false otherwise.
 */
bool CCFRunPtr::GetPreferredFontInfo(
	BYTE	iCharRep,
	BYTE &	iCharRepRet,
	SHORT&	iFont,
	SHORT&	yHeight,				// return in twips
	BYTE&	bPitchAndFamily,
	int		iFormat,
	int		iMatchCurrent,
	int		*piFormatOut)
{
	int				   i;
	bool			   fr = false;
	static int const   MAX_FONTSEARCH = 256;
	const CCharFormat *pCF;
	const CCharFormat *pCFCurrent;
	const CCharFormat *pCFPrevious = NULL;
	int				   iMatch = 0;			// how signature match?
	QWORD			   qwFontSigCurrent = 0;
	SHORT			   yNewHeight = 0;
	bool			   fUseUIFont = _ped->fUseUIFont() || _ped->Get10Mode();

	Assert(!(iMatchCurrent & MATCH_ASCII) || iCharRep == ANSI_INDEX);

	if(_ped->fUseUIFont())
		pCFCurrent = _ped->GetCharFormat(-1);	// Plain text or UI font specified
	else
		pCFCurrent = _ped->GetCharFormat(iFormat != -1 ? iFormat : GetFormat());

	if (iMatchCurrent == GET_HEIGHT_ONLY)	// Just do the font autosizing.
	{
		fr = true;
		pCF = NULL;
		goto DO_SIZE;
	}

	if ((iMatchCurrent & MATCH_FONT_SIG) &&
		(iMatch = MatchFormatSignature(pCFCurrent, iCharRep, iMatchCurrent, &qwFontSigCurrent)) != 0)
	{
		pCF = pCFCurrent;					// Setup to use it
	}
	else
	{
		int iFormatOut;

		// Try searching backwards
		if (IsValid())						// If doc has CF runs
			AdjustBackward();
		i = MAX_FONTSEARCH;					// Don't be searching for years
		iFormatOut = GetFormat();
		pCF = _ped->GetCharFormat(iFormatOut);
		while (i--)
		{
			if(iCharRep == pCF->_iCharRep)	// Equal charset ids?
			{
				pCFPrevious = pCF;
				break;
			}
			if (!PrevRun())					// Done searching?
				break;
			iFormatOut = GetFormat();
			pCF = _ped->GetCharFormat(iFormatOut);
		}
		pCF = pCFPrevious;
		if (piFormatOut && pCF)
		{
			*piFormatOut = iFormatOut;
			return true;					// Done since we only ask for the format.
		}
	}

	// Try match charset if requested
	if(!pCF && iMatchCurrent == MATCH_CURRENT_CHARSET)
	{
		CCcs* pccs = _ped->GetCcs(pCFCurrent, W32->GetYPerInchScreenDC());
		if (pccs)
		{
			if(pccs->BestCharRep(iCharRep, DEFAULT_INDEX, MATCH_CURRENT_CHARSET) != DEFAULT_INDEX)
				pCF = pCFCurrent;			// Current font can do it
			pccs->Release();
		}
	}

	// Try default document format
	if (!pCF)
	{
		pCF = _ped->GetCharFormat(-1);
		if(iCharRep != pCF->_iCharRep)	// Diff charset ids?
			pCF = NULL;
	}

DO_SIZE:
	yHeight = pCFCurrent->_yHeight;		// Assume current height

	if (!pCF)
	{
		// Default to table if no match.
		fr = W32->GetPreferredFontInfo(
			iCharRep, fUseUIFont, iFont, (BYTE&)yNewHeight, bPitchAndFamily );

		if (!_ped->_fAutoFontSizeAdjust && iCharRep == THAI_INDEX)
			// Kick in font size adjusting in first bind to Thai.
			_ped->_fAutoFontSizeAdjust = TRUE;
	}

	if (pCF)
	{
		// Found previous or current font
		iFont = pCF->_iFont;
		bPitchAndFamily = pCF->_bPitchAndFamily;

		if (pCF == pCFCurrent && (iMatchCurrent & MATCH_FONT_SIG) &&
			(IsFECharRep(pCF->_iCharRep) && W32->IsFECodePageFont(qwFontSigCurrent) ||
			 iMatch == MATCH_ASCII && iCharRep == ANSI_INDEX))
		{
			// The current font matches the requested signature.
			// If it's a East Asia or ASCII font, we leave the charset intact.
			iCharRepRet = pCF->_iCharRep;
			return true;
		}
	}

	if (_ped->_fAutoFontSizeAdjust && iFont != pCFCurrent->_iFont)
	{
		if (IsValid())
		{
			// If the last run format is available. We will scale the size relative to it.
			AdjustBackward();
			if (GetIch() > 0)
			{
				pCFCurrent = _ped->GetCharFormat(GetFormat());
				yHeight = pCFCurrent->_yHeight;
			}
			AdjustForward();
		}

		if (iFont != pCFCurrent->_iFont)
		{
			// Scale the height relative to the preceding format
			if (pCF)
				yNewHeight = GetFontLegitimateSize(iFont, fUseUIFont, iCharRep);
	
			if (yNewHeight)
			{
				// Get legitimate size of current font
				SHORT yDefHeight = GetFontLegitimateSize(pCFCurrent->_iFont,
										fUseUIFont, pCFCurrent->_iCharRep);
	
				// Calculate the new height relative to the current height
				if (yDefHeight)
				{
					if (fUseUIFont)
					{
						// For UIFont, we only convert from one preferred size to another preferred size.
						if (pCFCurrent->_yHeight / TWIPS_PER_POINT == yDefHeight)
							yHeight = yNewHeight * TWIPS_PER_POINT;
					}
					else
						yHeight = (SHORT)MulDiv(pCFCurrent->_yHeight, yNewHeight, yDefHeight);
				}
			}
		}
	}

	if (!yHeight)
		yHeight = (SHORT)MulDiv(pCFCurrent->_yHeight, yNewHeight, 10);

	return pCF || fr;
}

/*
 *	CCFRunPtr::FindUnhiddenBackward()
 *	
 *	@mfunc
 *		Find nearest expanded CF going backward.  If none, go to BOD
 *	
 *	@rdesc
 *		cch to nearest expanded CF going backward
 *
 *	@devnote
 *		changes this run ptr
 */
LONG CCFRunPtr::FindUnhiddenBackward()
{
	LONG cch = 0;

	AdjustBackward();
	while(IsHidden())
	{
		cch -= GetIch();
		if(!_iRun)
			break;
		_ich = 0;
		AdjustBackward();
	}
	return cch;
}

///////////////////////////// CPFRunPtr ///////////////////////////////

CPFRunPtr::CPFRunPtr(const CRchTxtPtr &rtp)
		: CFormatRunPtr(rtp._rpPF)
{
	_ped = rtp.GetPed();
}

/*
 *	CPFRunPtr::FindHeading(cch, lHeading)
 *	
 *	@mfunc
 *		Find heading with number lHeading (e.g., = 1 for Heading 1) or above
 *		in a range starting at this PFrun pointer.  If successful, this run
 *		ptr points at the matching run; else it remains unchanged.
 *	
 *	@rdesc
 *		cch to matching heading or tomBackward if not found
 *
 *	@devnote
 *		changes this run ptr
 */
LONG CPFRunPtr::FindHeading(
	LONG	cch,		//@parm Max cch to move
	LONG&	lHeading)	//@parm Lowest lHeading to match
{
	LONG	cchSave	 = cch;
	LONG	ichSave  = _ich;
	LONG	iRunSave = _iRun;
	LONG	OutlineLevel;

	Assert((unsigned)lHeading <= NHSTYLES);

	if(!IsValid())
		return tomBackward;

	while(TRUE)
	{
		OutlineLevel = GetOutlineLevel();

		if (!(OutlineLevel & 1) &&
			(!lHeading || (lHeading - 1)*2 >= OutlineLevel))
		{
			lHeading = OutlineLevel/2 + 1;	// Return heading # found
			return cchSave - cch;			// Return how far away it was
		}

		if(cch >= 0)
		{
			cch -= GetCchLeft();
			if(cch <= 0 || !NextRun())
				break;
		}			
		else
		{
			cch += GetIch();
			if(cch > 0 || !_iRun)
				break;
			AdjustBackward();
		}
	}

	_ich  = ichSave;
	_iRun = iRunSave;
	return tomBackward;						// Didn't find desired heading
}

/*
 *	CPFRunPtr::FindRowEnd(TableLevel)
 *	
 *	@mfunc
 *		Advance this ptr just past table-row terminator that matches
 *		the passed-in table level
 *	
 *	@rdesc
 *		TRUE if matching table row end is found
 *
 *	@devnote
 *		changes this run ptr only if TableLevel is found within cch chars
 */
BOOL CPFRunPtr::FindRowEnd(
	LONG	TableLevel)	//@parm Table level to match
{
	LONG	ichSave  = _ich;
	LONG	iRunSave = _iRun;

	Assert(IsValid());

	do
	{
		if(IsTableRowDelimiter() && GetPF()->_bTableLevel == (BYTE)TableLevel)
		{
			NextRun();					// Bypass delimiter
			return TRUE;
		}
	} while(NextRun());

	_ich  = ichSave;					// Restore run ptr indices
	_iRun = iRunSave;
	return FALSE;						// Didn't find desired heading
}

/*
 *	CPFRunPtr::IsCollapsed()
 *	
 *	@mfunc
 *		return TRUE if CParaFormat for this run ptr has PFE_COLLAPSED bit set
 *
 *	@rdesc
 *		TRUE if CParaFormat for this run ptr has PFE_COLLAPSED bit set
 */
BOOL CPFRunPtr::IsCollapsed()
{
	return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_COLLAPSED) != 0;
}

/*
 *	CPFRunPtr::IsTableRowDelimiter()
 *	
 *	@mfunc
 *		return TRUE if CParaFormat for this run ptr has PFE_TABLEROWDELIMITER bit set
 *
 *	@rdesc
 *		TRUE if CParaFormat for this run ptr has PFE_TABLEROWDELIMITER bit set
 */
BOOL CPFRunPtr::IsTableRowDelimiter()
{
	return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_TABLEROWDELIMITER) != 0;
}

/*
 *	CPFRunPtr::InTable()
 *	
 *	@mfunc
 *		return TRUE if CParaFormat for this run ptr has PFE_TABLE bit set
 *
 *	@rdesc
 *		TRUE if CParaFormat for this run ptr has PFE_TABLE bit set
 */
BOOL CPFRunPtr::InTable()
{
	return (_ped->GetParaFormat(GetFormat())->_wEffects & PFE_TABLE) != 0;
}

/*
 *	CPFRunPtr::FindExpanded()
 *	
 *	@mfunc
 *		Find nearest expanded PF going forward. If none, find nearest going
 *		backward.  If none, go to start of document
 *	
 *	@rdesc
 *		cch to nearest expanded PF as explained in function description
 *
 *	@devnote
 *		Moves this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpanded()
{
	LONG cch, cchRun;

	for(cch = 0; IsCollapsed(); cch += cchRun)	// Try to find expanded PF
	{											//  run going forward
		cchRun = GetCchLeft();
		if(!NextRun())							// Aren't any
		{
			Move(-cch);							// Go back to starting point
			return FindExpandedBackward();		// Try to find expanded PF
		}										//  run going backward
	}
	return cch;
}

/*
 *	CPFRunPtr::FindExpandedForward()
 *	
 *	@mfunc
 *		Find nearest expanded PF going forward.  If none, go to EOD
 *	
 *	@rdesc
 *		cch to nearest expanded PF going forward
 *
 *	@devnote
 *		advances this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpandedForward()
{
	LONG cch = 0;

	while(IsCollapsed())
	{
		LONG cchLeft = GetCchLeft();
		_ich += cchLeft;						// Update _ich in case
		cch  += cchLeft;						//  if(!NextRun()) breaks
		if(!NextRun())
			break;
	}
	return cch;
}

/*
 *	CPFRunPtr::FindExpandedBackward()
 *	
 *	@mfunc
 *		Find nearest expanded PF going backward.  If none, go to BOD
 *	
 *	@rdesc
 *		cch to nearest expanded PF going backward
 *
 *	@devnote
 *		Moves this run ptr the amount returned (cch)
 */
LONG CPFRunPtr::FindExpandedBackward()
{
	LONG cch = 0;

	while(IsCollapsed())
	{
		cch -= GetIch();
		_ich = 0;
		if(!_iRun)
			break;
		AdjustBackward();
	}
	return cch;
}

/*
 *	CPFRunPtr::GetOutlineLevel()
 *	
 *	@mfunc
 *		Find outline level this rp is pointing at
 *	
 *	@rdesc
 *		Outline level this rp is pointing at
 */
LONG CPFRunPtr::GetOutlineLevel()
{
	const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
	LONG OutlineLevel = pPF->_bOutlineLevel;

	AssertSz(IsHeadingStyle(pPF->_sStyle) ^ (OutlineLevel & 1),
		"CPFRunPtr::GetOutlineLevel: sStyle/bOutlineLevel mismatch");

	return OutlineLevel;
}

/*
 *	CPFRunPtr::GetStyle()
 *	
 *	@mfunc
 *		Find style this rp is pointing at
 *	
 *	@rdesc
 *		Style this rp is pointing at
 */
LONG CPFRunPtr::GetStyle()
{
	const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
	LONG Style = pPF->_sStyle;

	AssertSz(IsHeadingStyle(Style) ^ (pPF->_bOutlineLevel & 1),
		"CPFRunPtr::GetStyle: sStyle/bOutlineLevel mismatch");

	return Style;
}

/*
 *	CPFRunPtr::ResolveRowStartPF()
 *	
 *	@mfunc
 *		Resolve table row start PF corresponding to the current table row
 *		end.  Assumes that all table rows contained in the current row are
 *		resolved, which should be the case for nested tables in RTF.
 *	
 *	@rdesc
 *		TRUE iff success
 */
BOOL CPFRunPtr::ResolveRowStartPF()
{
	AdjustBackward();
	LONG iFormat = GetFormat();
	Assert(IsTableRowDelimiter());

	const CParaFormat *pPF = NULL;

	while(PrevRun())
	{
		pPF = _ped->GetParaFormat(GetFormat());
		if((pPF->_wEffects & PFE_TABLEROWDELIMITER) && pPF->_iTabs == -1)
			break;
	}
	Assert(IsTableRowDelimiter());
	Assert(pPF->_iTabs == -1);

	CFormatRun*	pRun = GetRun(0);
	IParaFormatCache *pf = GetParaFormatCache();

	pf->Release(pRun->_iFormat);
	pf->AddRef(iFormat);
	pRun->_iFormat = iFormat;
	return TRUE;
}

/*
 *	CPFRunPtr::GetMinTableLevel(cch)
 *	
 *	@mfunc
 *		Get the lowest table level in the range of cch chars from this
 *		run ptr.  This is the lesser of the level ending at the range
 *		cpMost and that starting at cpMin.  Leave this run ptr at cpMin.
 *	
 *	@rdesc
 *		Lowest table level in the cch chars from this run ptr
 */
LONG CPFRunPtr::GetMinTableLevel(
	LONG cch)		//@parm cch to check for table level
{
	if(cch > 0)
		AdjustBackward();

	const CParaFormat *pPF = GetPF();
	LONG Level = pPF->_bTableLevel;		// Default: level at active end

	if(cch)
	{
		Move(-cch);						// Go find table level at other
		pPF = GetPF();					//  end of range
		if(pPF->_bTableLevel < Level)
			Level = pPF->_bTableLevel;
		if(cch < 0)						// Range active end at cpMin
			Move(cch);					// Start at cpMin
	}
	AssertSz(Level >= 0, "CPFRunPtr::GetMinTableLevel: invalid table level");
	return Level;
}

/*
 *	CPFRunPtr::GetTableLevel()
 *	
 *	@mfunc
 *		Get table level this run ptr is at
 *
 *	@rdesc
 *		Table level this run ptr is at
 */
LONG CPFRunPtr::GetTableLevel()
{
	const CParaFormat *pPF = _ped->GetParaFormat(GetFormat());
	AssertSz(!(pPF->_wEffects & PFE_TABLE) || pPF->_bTableLevel > 0,
		"CPFRunPtr::GetTableLevel: invalid table level");
	return pPF->_bTableLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\format.cpp ===
/*
 *	@doc	INTERNAL
 *	
 *	@module - FORMAT.C
 *		CCharFormatArray and CParaFormatArray classes |
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_format.h"


ASSERTDATA

// ===============================  CFixArrayBase  =================================


CFixArrayBase::CFixArrayBase(
	LONG cbElem)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::CFixArrayBase");

	_prgel = NULL;
	_cel = 0;
	_ielFirstFree = 0;

#ifdef _WIN64
	// Make sure each element + Ref. count is 64-bit aligned.
	LONG	cbTemp = (cbElem + 4) & 7;	// Do a Mod 8

	_cbPad = 0;
	if (cbTemp)							// Need padding?
		_cbPad = 8 - cbTemp;

#endif

	_cbElem = cbElem + 4 + _cbPad;		// 4 is for reference count
}

/*
 *	CFixArrayBase::Add()
 *
 *	@mfunc	
 *		Return index of new element, reallocing if necessary
 *
 *	@rdesc
 *		Index of new element.
 *
 *	@comm
 *		Free elements are maintained in place as a linked list indexed
 *		by a chain of ref-count entries with their sign bits set and the
 *		rest of the entry giving the index of the next element on the
 *		free list.  The list is terminated by a 0 entry. This approach
 *		enables element 0 to be on the free list.
 */
LONG CFixArrayBase::Add()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Add");

	char *pel;
	LONG iel, ielRet;

	if(_ielFirstFree)					// Return first element of free list
	{
		ielRet = _ielFirstFree & ~FLBIT;
		_ielFirstFree = RefCount(ielRet);
	}
	else								// All lower positions taken: need 
	{									//  to add another celGrow elements
		pel = (char*)PvReAlloc(_prgel, (_cel + celGrow) * _cbElem);
		if(!pel)
			return -1;

		// Clear out the *end* of the newly allocated memory
		ZeroMemory(pel + _cel*_cbElem, celGrow*_cbElem);

		_prgel = pel;

		ielRet = _cel;					// Return first one added 
		iel = _cel + 1;
		_cel += celGrow;

		// Add elements _cel+1 thru _cel+celGrow-1 to free list. The last
		// of these retains a 0, stored by fZeroFill in Alloc
		_ielFirstFree = iel | FLBIT;

		for(pel = (char *)&RefCount(iel);
			++iel < _cel;
			pel += _cbElem)
		{
			*(INT *)pel = iel | FLBIT;
		}
	}		
	return ielRet;
}

void CFixArrayBase::Free(
	LONG iel)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Free(iel)");

	// Simply add it to free list
	RefCount(iel) = _ielFirstFree;
	_ielFirstFree = iel | FLBIT;
}

void CFixArrayBase::Free()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::Free()");

#if defined(DEBUG) && !defined(NOFULLDEBUG)
	// Only do this validation if all the ped's are gone. Visual basic shutsdown apps
	// without freeing all the resources so this safety check is necessary.
	if (0 == W32->GetRefs())
	{
		// Display message if any CCharFormats, CParaFormats, or CTabs have
		// reference counts > 0.  This only happens if an error has occurred.
		// Since this is called as the RichEdit dll is unloading, we can't use
		// the usual AssertSz() macros.
		BOOL fComplained = FALSE;
		for(LONG iel = 0; iel < Count(); iel++)
		{
			while(RefCount(iel) > 0)
			{
				if (!fComplained)
				{
					fComplained = TRUE;
					AssertSz(FALSE, (_cbElem - _cbPad) == sizeof(CCharFormat) + 4 ? "CCharFormat not free" :
								 (_cbElem - _cbPad) == sizeof(CParaFormat) + 4 ? "CParaFormat not free" :
									 "CTabs not free");
				}
				Release(iel);
			}
		}
	}
#endif
	FreePv(_prgel);
	_prgel = NULL;
	_cel = 0;
	_ielFirstFree = 0;
}

HRESULT CFixArrayBase::Deref(
	LONG iel,
	const void **ppel) const
{
	Assert(ppel);
	AssertSz(iel >= 0,
		"CFixArrayBase::Deref: bad element index" );
	AssertSz(*(LONG *)(_prgel + (iel + 1) * _cbElem - 4) > 0,
		"CFixArrayBase::Deref: element index has bad ref count");

	if(!ppel)
		return E_INVALIDARG;

	*ppel = Elem(iel);
	return S_OK;
}

/*
 *	CFixArrayBase::RefCount(iel)
 *
 *	@mfunc
 *		The reference count for an element is stored as a LONG immediately
 *		following the element in the CFixArray. If the element isn't used
 *		i.e., is free, then the reference count is used as a link to the
 *		next free element.  The last free element in this list has a 0
 *		"reference count", which terminates the list.
 *
 *		The ref count follows the element instead of preceding it because
 *		this allows Elem(iel) to avoid an extra addition.  Elem() is used
 *		widely in the code.
 *
 *	@rdesc
 *		Ptr to reference count
 */
LONG & CFixArrayBase::RefCount(
	LONG iel)
{
	Assert(iel < Count());
	return (LONG &)(*(_prgel + (iel + 1) * _cbElem - 4));
}

LONG CFixArrayBase::Release(
	LONG iel)
{
	LONG  cRef = -1;

	if(iel >= 0)							// Ignore default iel
	{
		CLock lock;
		CheckFreeChain();
		AssertSz(RefCount(iel) > 0, "CFixArrayBase::Release(): already free");

		cRef = --RefCount(iel); 
		if(!cRef)							// Entry no longer referenced
			Free(iel);						// Add it to the free chain
	}
	return cRef;
}

LONG CFixArrayBase::AddRef(
	LONG iel)
{
	LONG  cRef = -1;

	if(iel >= 0)
	{
		CLock lock;
		CheckFreeChain();
    	AssertSz(RefCount(iel) > 0, "CFixArrayBase::AddRef(): add ref to free elem");
		cRef = ++RefCount(iel);
	}
	return cRef;
}

LONG CFixArrayBase::Find(
	const void *pel)
{
	CheckFreeChain();
	
	for(LONG iel = 0; iel < Count(); iel++)
	{
		// RefCount < 0 means entry not in use and is index of next free entry.
		// RefCount = 0 marks last free element in list.  _cbElem = sizeof(ELEM)
		// plus sizeof(RefCount), which is a LONG.
		if (RefCount(iel) > 0 &&
			!CompareMemory(Elem(iel), pel, _cbElem - sizeof(LONG) - _cbPad))
		{
			return iel;
		}
	}
	return -1;
}

HRESULT CFixArrayBase::Cache(
	const void *pel,
	LONG *		piel)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Cache");

	CLock	lock;
	LONG	iel = Find(pel);

	if(iel >= 0)
		RefCount(iel)++;
	else
	{	
		iel = Add();
		if(iel < 0)
			return E_OUTOFMEMORY;
		CopyMemory(Elem(iel), pel, _cbElem - sizeof(LONG) - _cbPad);
		RefCount(iel) = 1;
	}

	CheckFreeChain();
	
	if(piel)
		*piel = iel;
	
	return S_OK;
}

#ifdef DEBUG

void CFixArrayBase::CheckFreeChainFn(
	LPSTR	szFile,
	INT		nLine)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CFixArrayBase::CheckFreeChainFn");

	LONG cel = 0;
	LONG iel = _ielFirstFree;
	LONG ielT;

	while(iel)
	{
		Assert(iel < 0);
		ielT = RefCount(iel & ~FLBIT);

		if((LONG)(ielT & ~FLBIT) > _cel)
			Tracef(TRCSEVERR, "AttCheckFreeChainCF(): elem %ld points to out of range elem %ld", iel, ielT);

		iel = ielT;
		if(++cel > _cel)
		{
			AssertSzFn("CFixArrayBase::CheckFreeChain() - CF free chain seems to contain an infinite loop", szFile, nLine);
			return;
		}
	}
}

#endif


// ===========================  CCharFormatArray  ===========================================

HRESULT CCharFormatArray::Deref(
	LONG iCF,
	const CCharFormat **ppCF) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Deref");

	return CFixArrayBase::Deref(iCF, (const void **)ppCF);
}

LONG CCharFormatArray::Release(
	LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::ReleaseFormat");

	return CFixArrayBase::Release(iCF);
}

LONG CCharFormatArray::AddRef(
	LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::AddRefFormat");

	return CFixArrayBase::AddRef(iCF);
}

void CCharFormatArray::Destroy()
{
	delete this;
}

LONG CCharFormatArray::Find(
	const CCharFormat *pCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Find");

	LONG iCF;

	#define QUICKCRCSEARCHSIZE	15	// Must be 2^n - 1 for quick MOD
									//  operation, it is a simple hash.
 	static struct {
		BYTE	bCRC;
		LONG	iCF;
	} quickCrcSearch[QUICKCRCSEARCHSIZE+1];
 	BYTE	bCRC;
	WORD	hashKey;

	CheckFreeChain();

	// Check our cache before going sequential
	bCRC = (BYTE)pCF->_iFont;
	hashKey = (WORD)(bCRC & QUICKCRCSEARCHSIZE);
	if(bCRC == quickCrcSearch[hashKey].bCRC)
	{
		iCF = quickCrcSearch[hashKey].iCF - 1;
		if (iCF >= 0 && iCF < Count() && RefCount(iCF) > 0 &&
			!CompareMemory(Elem(iCF), pCF, sizeof(CCharFormat)))
		{
			return iCF;
		}
	}

	for(iCF = 0; iCF < Count(); iCF++)
	{
		if(RefCount(iCF) > 0 && !CompareMemory(Elem(iCF), pCF, sizeof(CCharFormat)))
		{
			quickCrcSearch[hashKey].bCRC = bCRC;
			quickCrcSearch[hashKey].iCF = iCF + 1;
			return iCF;
		}
	}
	return -1;
}

HRESULT CCharFormatArray::Cache(
	const CCharFormat *pCF,
	LONG* piCF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormatArray::Cache");

	CLock lock;
	LONG  iCF = Find(pCF);

	if(iCF >= 0)
		RefCount(iCF)++;
	else
	{
		iCF = Add();
		if(iCF < 0)
			return E_OUTOFMEMORY;
		*Elem(iCF) = *pCF;			// Set entry iCF to *pCF
		RefCount(iCF) = 1;
	}					 

	CheckFreeChain();
	
	if(piCF)
		*piCF = iCF;

	return S_OK;
}


// ===============================  CParaFormatArray  ===========================================

HRESULT CParaFormatArray::Deref(
	LONG iPF,
	const CParaFormat **ppPF) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Deref");

	return CFixArrayBase::Deref(iPF, (const void **)ppPF);
}

LONG CParaFormatArray::Release(
	LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::ReleaseFormat");

	CLock lock;
	LONG  cRef = CFixArrayBase::Release(iPF);

#ifdef TABS
	if(!cRef)
		GetTabsCache()->Release(Elem(iPF)->_iTabs);
#endif
	return cRef;
}

LONG CParaFormatArray::AddRef(
	LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::AddRefFormat");

	return CFixArrayBase::AddRef(iPF);
}

void CParaFormatArray::Destroy()
{
	delete this;
}

HRESULT CParaFormatArray::Cache(
	const CParaFormat *pPF,
	LONG *piPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormatArray::Cache");

	HRESULT hr = CFixArrayBase::Cache((const void *)pPF, piPF);
#ifdef TABS
	if(hr == NOERROR && RefCount(*piPF) == 1)
		GetTabsCache()->AddRef(pPF->_iTabs);
#endif
	return hr;
}


// ===============================  CTabsArray  ===========================================

CTabsArray::~CTabsArray()
{
	for(LONG iTabs = 0; iTabs < Count(); iTabs++)
	{
		// It shouldn't be necessary to release any tabs, since when all
		// controls are gone, no reference counts should be > 0.
		while(RefCount(iTabs) > 0)
		{
#ifdef DEBUG
			// Only do this validation if all the ped's are gone. Visual basic shutsdown apps
			// without freeing all the resources so this safety check is necessary.
			AssertSz(0 != W32->GetRefs(), "CTabs not free");
#endif
			Release(iTabs);
		}
	}
}

const LONG *CTabsArray::Deref(
	LONG iTabs) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Deref");

	return iTabs >= 0 ? Elem(iTabs)->_prgxTabs : NULL;
}

LONG CTabsArray::Release(
	LONG iTabs)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Release");

	LONG cRef = CFixArrayBase::Release(iTabs);
	if(!cRef)
		FreePv(Elem(iTabs)->_prgxTabs);
	return cRef;
}

LONG CTabsArray::AddRef(
	LONG iTabs)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::AddRef");

	return CFixArrayBase::AddRef(iTabs);
}

LONG CTabsArray::Find(
	const LONG *prgxTabs,	//@parm Array of tab/cell data
	LONG		cTab)		//@parm # tabs or LONGs in cells
{
	CheckFreeChain();

	CTabs *pTab;
	LONG	cb = cTab*sizeof(LONG);
	
	for(LONG iel = 0; iel < Count(); iel++)
	{
		// RefCount < 0 means entry not in use and is index of next free entry.
		// RefCount = 0 marks last free element in list.  _cbElem = sizeof(ELEM)
		// plus sizeof(RefCount), which is a LONG.
		if(RefCount(iel) > 0)
		{
			pTab = Elem(iel);
			if (pTab->_cTab == cTab &&
				!CompareMemory(pTab->_prgxTabs, prgxTabs, cb))
			{
				return iel;
			}
		}
	}
	return -1;
}

LONG CTabsArray::Cache(
	const LONG *prgxTabs,	//@parm Array of tab/cell data
	LONG		cTab)		//@parm # tabs or LONGs in cells
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTabsArray::Cache");

	if(!cTab)
		return -1;						// No tabs defined: use default

	CLock	lock;
	LONG	iTabs = Find(prgxTabs, cTab);

	if(iTabs >= 0)
		RefCount(iTabs)++;
	else
	{
		iTabs = Add();
		if(iTabs < 0)					// Out of memory: use default
			return -1;

		CTabs *pTabs = Elem(iTabs);
		LONG   cb = sizeof(LONG)*cTab;

		pTabs->_prgxTabs = (LONG *)PvAlloc(cb, GMEM_FIXED);
		if(!pTabs->_prgxTabs)
			return -1;					// Out of memory: use default
		CopyMemory(pTabs->_prgxTabs, prgxTabs, cb);
		pTabs->_cTab = cTab;
		RefCount(iTabs) = 1;
	}					 
	return iTabs;
}


// ==================================  Factories  ===========================================

static ICharFormatCache *pCFCache = NULL;		// CCharFormat cache
static IParaFormatCache *pPFCache = NULL;	 	// CParaFormat cache
static CTabsArray *	   pTabsCache = NULL;	 	// CTabs cache

ICharFormatCache *GetCharFormatCache()
{
	return pCFCache;
}

IParaFormatCache *GetParaFormatCache()
{
	return pPFCache;
}

CTabsArray *GetTabsCache()
{
	return pTabsCache;
}

HRESULT CreateFormatCaches()					// Called by DllMain()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CreateFormatCaches");
	CLock	lock;

	pCFCache = new CCharFormatArray();
	if(!pCFCache)
		return E_OUTOFMEMORY;
     
    pPFCache = new CParaFormatArray();
	if(!pPFCache)
	{
		delete pCFCache;
		return E_OUTOFMEMORY;
	}

    pTabsCache = new CTabsArray();
	if(!pTabsCache)
	{
		delete pCFCache;
		delete pPFCache;
		return E_OUTOFMEMORY;
	}
	return S_OK;
}

HRESULT DestroyFormatCaches()					// Called by DllMain()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "DeleteFormatCaches");

	if (pCFCache)
		pCFCache->Destroy();
	if (pPFCache)
		pPFCache->Destroy();
	if (pTabsCache)
		delete pTabsCache;
	return NOERROR;
}

/*
 *	ReleaseFormats(iCF, iPF)
 *
 *	@mfunc
 *		Release char and para formats corresponding to the indices <p iCF>
 *		and <p iPF>, respectively
 */
void ReleaseFormats (
	LONG iCF,			//@parm CCharFormat index for releasing
	LONG iPF)			//@parm CParaFormat index for releasing
{
	AssertSz(pCFCache && pPFCache,
		"ReleaseFormats: uninitialized format caches");
	if (iCF != -1)
		pCFCache->Release(iCF);
	if (iPF != -1)
		pPFCache->Release(iPF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\host.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	HOST.C	-- Text Host for CreateWindow() Rich Edit Control |
 *		Implements CTxtWinHost message and ITextHost interfaces
 *		
 *	Original Author: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		8/1/95   ricksa  Documented and brought to new ITextHost definition
 *		10/28/95 murrays cleaned up and moved default char/paraformat cache
 *						 cache code into text services
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"

#ifndef NOWINDOWHOSTS

ASSERTDATA

CTxtWinHost *g_phostdel = NULL;

#define EN_CLIPFORMAT			0x0712
#define ENM_CLIPFORMAT			0x00000080

void DeleteDanglingHosts()
{
	CLock lock;
	CTxtWinHost *phostdel = g_phostdel;
	while(phostdel)
	{
		CTxtWinHost *phost = phostdel;
		phostdel = phostdel->_pnextdel;
		CTxtWinHost::OnNCDestroy(phost);
	}
	g_phostdel = NULL;
}


#ifndef NOANSIWINDOWS

//////////////////////////// System Window Procs ////////////////////////////
LRESULT CreateAnsiWindow(
	HWND hwnd, 
	UINT msg, 
	CREATESTRUCTA *pcsa,
	BOOL fIs10)
{
	AssertSz((WM_CREATE == msg) || (WM_NCCREATE == msg), 
		"CreateAnsiWindow called with invalid message!");

	CTxtWinHost *phost = (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed);

	// The only thing we need to convert are the strings,
	// so just do a structure copy and replace the strings. 
	CREATESTRUCTW csw = *(CREATESTRUCTW *)pcsa;
	CStrInW strinwName(pcsa->lpszName, GetKeyboardCodePage());
	CStrInW strinwClass(pcsa->lpszClass, CP_ACP);

	csw.lpszName = (WCHAR *)strinwName;
	csw.lpszClass = (WCHAR *)strinwClass;

	if (!phost)
	{
		// No host yet so create it
		phost = CTxtWinHost::OnNCCreate(hwnd, &csw, TRUE, fIs10);
	}

	if (WM_NCCREATE == msg)
	{
		return phost != NULL;
	}

	if (NULL == phost)
	{
		// For WM_CREATE -1 indicates failure
		return -1;
	}

	// Do the stuff specific to create
	return phost->OnCreate(&csw);
}

extern "C" LRESULT CALLBACK RichEdit10ANSIWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEdit10ANSIWndProc", msg);

	if ((WM_CREATE == msg) || (WM_NCCREATE == msg))
	{
		return CreateAnsiWindow(hwnd, msg, (CREATESTRUCTA *) lparam, TRUE);
	}

    // ignore WM_DESTROY and wait for WM_NCDESTROY
	if (WM_DESTROY == msg)
	{
#ifndef NOWINDOWHOSTS
		CLock lock;
		CTxtWinHost *phost = (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed);
		phost->_pnextdel = g_phostdel;
		g_phostdel = phost;
#endif		
		return 0;
	}


	if (WM_NCDESTROY == msg)
	    msg = WM_DESTROY;

	return W32->ANSIWndProc( hwnd, msg, wparam, lparam, TRUE);
}

LRESULT CALLBACK RichEditANSIWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditANSIWndProc", msg);

	if ((WM_CREATE == msg) || (WM_NCCREATE == msg))
	{
		return CreateAnsiWindow(hwnd, msg, (CREATESTRUCTA *) lparam, FALSE);
	}

	return W32->ANSIWndProc( hwnd, msg, wparam, lparam, FALSE);

}

#else	// NOANSIWINDOWS

extern "C" LRESULT CALLBACK RichEdit10ANSIWndProc(
	HWND ,
	UINT ,
	WPARAM ,
	LPARAM)
{
	return 0;
}

LRESULT CALLBACK RichEditANSIWndProc(
	HWND ,
	UINT ,
	WPARAM ,
	LPARAM)
{
	return 0;
}

#endif	// NOANSIWINDOWS


/*
 *	RichEditWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services.
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CALLBACK RichEditWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditWndProc");

	LRESULT lres = 0;
	HRESULT hr;
	SETTEXTEX st;

	CTxtWinHost *phost = hwnd ? (CTxtWinHost *) GetWindowLongPtr(hwnd, ibPed) : NULL;

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	switch(msg)
	{
#ifdef WM_NCCREATE
	case WM_NCCREATE:
		return CTxtWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam, FALSE, FALSE) != NULL;
#endif

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WinCE)
		if (!phost)
		{
			phost = CTxtWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam, FALSE, FALSE);
		}

		break;

	case WM_DESTROY:
		if(phost)
		{
#ifndef NOWINDOWHOSTS
			CLock lock;
			CTxtWinHost *phostdel = g_phostdel;
			if (phostdel == phost)
				g_phostdel = phost->_pnextdel;
			else
			{
				while (phostdel)
				{
					if (phostdel->_pnextdel == phost)
					{
						phostdel->_pnextdel = phost->_pnextdel;
						break;
					}
					phostdel = phostdel->_pnextdel;
				}
			}
#endif
			CTxtWinHost::OnNCDestroy(phost);
		}
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// In certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	// Handle mouse/keyboard/scroll message-filter notifications
	if(phost->_fKeyMaskSet || phost->_fMouseMaskSet || phost->_fScrollMaskSet)
	{
		// We may need to fire a MSGFILTER notification.  In the tests
		// below, we check to see if mouse, keyboard, or scroll events
		// are hit and enabled for notifications.  If so, we fire the
		// msgfilter notification.  The list of events was generated
		// from	RichEdit 1.0 sources. The code gets all keyboard and
		// mouse actions, whereas the RichEdit 1.0 code only got
		// WM_KEYDOWN, WM_KEYUP, WM_CHAR, WM_SYSKEYDOWN, WM_SYSKEYUP,
		// WM_MOUSEACTIVATE, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MOUSEMOVE,
		// WM_RBUTTONDBLCLK, WM_RBUTTONDOWN, WM_RBUTTONUP. Note that the
		// following code doesn't send a notification for AltGr characters
		// (LeftCtrl+RightAlt+vkey), since some hosts misinterpret these
		// characters as hot keys.
		if (phost->_fKeyMaskSet && IN_RANGE(WM_KEYFIRST, msg, WM_KEYLAST) &&
				(msg != WM_KEYDOWN ||
				 (GetKeyboardFlags() & (ALT | CTRL)) != (LCTRL | RALT)) || // AltGr
			phost->_fMouseMaskSet && (msg == WM_MOUSEACTIVATE ||
							IN_RANGE(WM_MOUSEFIRST, msg, WM_MOUSELAST)) ||
			phost->_fScrollMaskSet && IN_RANGE(WM_HSCROLL, msg, WM_VSCROLL))
		{
			MSGFILTER msgfltr;

			ZeroMemory(&msgfltr.nmhdr, sizeof(NMHDR));
			msgfltr.msg = msg;
			msgfltr.wParam = wparam;
			msgfltr.lParam = lparam;

			// The MSDN document on MSGFILTER is wrong, if the
			// send message returns 0 (NOERROR via TxNotify in this
			// case), it means process the event.  Otherwise, return.
			//
			// The documentation states the reverse.
			//
			if(phost->TxNotify(EN_MSGFILTER, &msgfltr) == NOERROR)
			{
				// Since client is allowed to modify the contents of
				// msgfltr, we must use the returned values.
				msg	   = msgfltr.msg;
				wparam = msgfltr.wParam;
				lparam = msgfltr.lParam;
			}
			else
			{
				lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
				goto Exit;
			}
		}
	}

	switch(msg)
	{
    case EM_SETEVENTMASK:
		phost->_fKeyMaskSet = !!(lparam & ENM_KEYEVENTS);
		phost->_fMouseMaskSet = !!(lparam & ENM_MOUSEEVENTS);
		phost->_fScrollMaskSet = !!(lparam & ENM_SCROLLEVENTS);
		goto serv;

	case EM_SETSEL:

		// When we are in a dialog box that is empty, EM_SETSEL will not select
		// the final always existing EOP if the control is rich.
		if (phost->_fUseSpecialSetSel &&
			((CTxtEdit *)phost->_pserv)->GetAdjustedTextLength() == 0 &&
			wparam != -1)
		{
			lparam = 0;
			wparam = 0;
		}
		goto serv;

	case WM_CREATE:
		{
			//bug fix #5386
			//need to convert ANSI -> UNICODE for Win9x systems which didn't go through
			//the ANSI wndProc
#ifndef NOANSIWINDOWS
			if (W32->OnWin9x() && !phost->_fANSIwindow)
			{
				CREATESTRUCT cs = *(CREATESTRUCT*)lparam;
				CStrInW strinwName(((CREATESTRUCTA*)lparam)->lpszName, GetKeyboardCodePage());
				CStrInW strinwClass(((CREATESTRUCTA*)lparam)->lpszClass, CP_ACP);

				cs.lpszName = (WCHAR*)strinwName;
				cs.lpszClass = (WCHAR*)strinwClass;
				
				lres = phost->OnCreate(&cs);
			}
			else
#endif
				lres = phost->OnCreate((CREATESTRUCT*)lparam);			
		}
		break;
	
	case WM_KEYDOWN:		
		lres = phost->OnKeyDown((WORD) wparam, (DWORD) lparam);
		if(lres)							// Didn't process code:
			goto serv;						//  give it to text services
		
		break;		   

	case WM_GETTEXT:
#ifndef NOANSIWINDOWS
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
#endif
		goto serv;

	case WM_COPYDATA:
		PCOPYDATASTRUCT pcds;
		pcds = (PCOPYDATASTRUCT) lparam;
		if (HIWORD(pcds->dwData) == 1200 &&		// Unicode code page
			LOWORD(pcds->dwData) == WM_SETTEXT)	// Only message we know about
		{
			st.flags = ST_CHECKPROTECTION;
			st.codepage = 1200;
			msg = EM_SETTEXTEX;
			wparam = (WPARAM) &st;
			lparam = (LPARAM) pcds->lpData;
			goto serv;
		}
		else
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_GETTEXTLENGTH:
#ifndef NOANSIWINDOWS
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
#endif
		goto serv;

	case WM_CHAR:
		if(GetKeyboardFlags() & ALTNUMPAD)	// Handle Alt+0ddd in CTxtEdit
			goto serv;						//  so that other hosts also work
#ifndef NOANSIWINDOWS
		else if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci, 
				((CTxtEdit *)phost->_pserv)->Get10Mode() );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
#endif

		lres = phost->OnChar((WORD) wparam, (DWORD) lparam);
		if(lres)							// Didn't process code:
			goto serv;						//  give it to text services
		break;

	case WM_ENABLE:
		if(!wparam ^ phost->_fDisabled)
		{
			// Stated of window changed so invalidate it so it will
			// get redrawn.
			phost->TxInvalidateRect(NULL, TRUE);
			phost->SetScrollBarsForWmEnable(wparam);
		}
		phost->_fDisabled = !wparam;				// Set disabled flag
		lres = 0;							// Return value for message
											// Fall thru to WM_SYSCOLORCHANGE?
	case WM_SYSCOLORCHANGE:
		phost->OnSysColorChange();
		goto serv;							// Notify text services that
											//  system colors have changed
	case WM_GETDLGCODE:
		lres = phost->OnGetDlgCode(wparam, lparam);
		break;

	case EM_GETOPTIONS:
		lres = phost->OnGetOptions();
		break;

	case EM_GETPASSWORDCHAR:
		lres = phost->_chPassword;
		break;

	case EM_GETRECT:
		phost->OnGetRect((LPRECT)lparam);
		break;

	case EM_HIDESELECTION:
		if(lparam)
		{
			DWORD dwPropertyBits = 0;

			phost->_dwStyle |= ES_NOHIDESEL;
			if(wparam)
			{
				phost->_dwStyle &= ~ES_NOHIDESEL;
				dwPropertyBits = TXTBIT_HIDESELECTION;
			}

			// Notify text services of change in status.
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_HIDESELECTION, 
				dwPropertyBits);
		}
		goto serv;

	case EM_SETBKGNDCOLOR:
		lres = (LRESULT) phost->_crBackground;
		phost->_fNotSysBkgnd = !wparam;
		phost->_crBackground = (COLORREF) lparam;

		if(wparam)
			phost->_crBackground = GetSysColor(COLOR_WINDOW);

		if(lres != (LRESULT) phost->_crBackground)
		{
			// Notify text services that color has changed
			LRESULT	lres1 = 0;
			phost->_pserv->TxSendMessage(WM_SYSCOLORCHANGE, 0, 0, &lres1);
			phost->TxInvalidateRect(NULL, TRUE);
		}
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_STYLECHANGED:
		//
		// For now, we only interested in GWL_EXSTYLE Transparent mode changed.
		// This is to fix Bug 753 since Window95 is not passing us
		// the WS_EX_TRANSPARENT.
		// 
		lres = 1;
		if(GWL_EXSTYLE == wparam)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lparam;
			if(phost->IsTransparentMode() != (BOOL)(lpss->styleNew & WS_EX_TRANSPARENT))
			{
				phost->_dwExStyle = lpss->styleNew;
				((CTxtEdit *)phost->_pserv)->OnTxBackStyleChange(TRUE);

				// Return 0 to indicate we have handled this message
				lres = 0;
			}
		}
		break;

	case EM_SHOWSCROLLBAR:
		{
			Assert(wparam == SB_VERT || wparam == SB_HORZ);
			DWORD dwBit = wparam == SB_VERT ? WS_VSCROLL : WS_HSCROLL;

			phost->_dwStyle |= dwBit;
			if(!lparam)
				phost->_dwStyle &= ~dwBit;

			phost->TxShowScrollBar((int) wparam, lparam);
			if (lparam)
			    phost->TxSetScrollRange((int) wparam, 0, 0, TRUE);
		}
		break;

	case EM_SETOPTIONS:
		phost->OnSetOptions((WORD) wparam, (DWORD) lparam);
		lres = (phost->_dwStyle & ECO_STYLES);
		if(phost->_fEnableAutoWordSel)
			lres |= ECO_AUTOWORDSELECTION;
		break;

	case EM_SETPASSWORDCHAR:
		if(phost->_chPassword != (TCHAR)wparam)
		{
			phost->_chPassword = (TCHAR)wparam;
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_USEPASSWORD,
				phost->_chPassword ? TXTBIT_USEPASSWORD : 0);
		}
		break;

	case EM_SETREADONLY:
		phost->OnSetReadOnly(BOOL(wparam));
		lres = 1;
		break;

	case EM_SETRECTNP:
	case EM_SETRECT:
		phost->OnSetRect((LPRECT)lparam, wparam == 1, msg == EM_SETRECT);
		break;
		
	case WM_SIZE:
		phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		lres = phost->OnSize(hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));
		break;

	case WM_WINDOWPOSCHANGING:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		// richedit 1.0 didn't cause InvalidateRect which OnSunkenWindowPosChanging will do
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && !((CTxtEdit *)phost->_pserv)->Get10Mode())
			phost->OnSunkenWindowPosChanging(hwnd, (WINDOWPOS *) lparam);
		break;

	case WM_SETCURSOR:
		//			Only set cursor when over us rather than a child; this
		//			helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
			{
				POINT pt;
				GetCursorPos(&pt);
				::ScreenToClient(hwnd, &pt);
				phost->_pserv->OnTxSetCursor(
					DVASPECT_CONTENT,	
					-1,
					NULL,
					NULL,
					NULL,
					NULL,
					NULL,			// Client rect - no redraw 
					pt.x, 
					pt.y);
				lres = TRUE;
			}
		}
		break;

	case WM_SHOWWINDOW:
		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_PRINTCLIENT:
	case WM_PAINT:
		{
			PAINTSTRUCT ps;
			HPALETTE hpalOld = NULL;
			HDC		hdc;
			RECT rcClient;

			//RAID 6964: WM_PRINTCLIENT should not call BeginPaint. If a HDC is passed
			//down in the wparam, use it instead of calling BeginPaint.
			if (!wparam || ((CTxtEdit *)phost->_pserv)->Get10Mode())
				hdc = BeginPaint(hwnd, &ps);
			else
				hdc = (HDC) wparam;

			// Set up the palette for drawing our data
			if(phost->_hpal)
			{
				hpalOld = SelectPalette(hdc, phost->_hpal, TRUE);
				RealizePalette(hdc);
			}

			// Since we are using the CS_PARENTDC style, make sure
			// the clip region is limited to our client window.
			GetClientRect(hwnd, &rcClient);
			SaveDC(hdc);
			IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);

			phost->_pserv->TxDraw(
				DVASPECT_CONTENT,  		// Draw Aspect
				-1,						// Lindex
				NULL,					// Info for drawing optimazation
				NULL,					// target device information
				hdc,					// Draw device HDC
				NULL, 				   	// Target device HDC
				(const RECTL *) &rcClient,// Bounding client rectangle
				NULL,	                // Clipping rectangle for metafiles
				&ps.rcPaint,			// Update rectangle
				NULL, 	   				// Call back function
				NULL,					// Call back parameter
				TXTVIEW_ACTIVE);		// What view - the active one!

			// Restore palette if there is one
#ifndef NOPALETTE
			if(hpalOld)
				SelectPalette(hdc, hpalOld, TRUE);
#endif
			RestoreDC(hdc, -1);
			if (!wparam || ((CTxtEdit *)phost->_pserv)->Get10Mode())
				EndPaint(hwnd, &ps);
		}
		break;

	case EM_SETMARGINS:
		phost->OnSetMargins(wparam, LOWORD(lparam), HIWORD(lparam));
		break;

	case EM_SETPALETTE:
		// Application is setting a palette for us to use.
		phost->_hpal = (HPALETTE) wparam;

		// Invalidate the window & repaint to reflect the new palette.
		InvalidateRect(hwnd, NULL, TRUE);
		break;

	default:
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		if(hr == S_FALSE)
		{			
			// Message was not processed by text services so send it
			// to the default window proc.
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}
	}

Exit:
	phost->Release();
	return lres;
}
												 
static BOOL GetIconic(
	HWND hwnd) 
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetIconic");

	while(hwnd)
	{
		if(IsIconic(hwnd))
			return TRUE;
		hwnd = GetParent(hwnd);
	}
	return FALSE;
}

//////////////// CTxtWinHost Creation/Initialization/Destruction ///////////////////////

/*
 *	CTxtWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
CTxtWinHost *CTxtWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs,
	BOOL fIsAnsi,
	BOOL fIs10Mode)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnNCCreate");

#if defined DEBUG && !defined(NOFULLDEBUG) 
	GdiSetBatchLimit(1);
#endif

	CTxtWinHost *phost = new CTxtWinHost();

	if(!phost)
		return 0;

	CREATESTRUCT cs = *pcs;		// prefer C++ compiler not to modify constant

#ifndef NOCOMPLEXSCRIPTS
	BOOL		 fMirrorWnd = !!(cs.dwExStyle & WS_EX_LAYOUTRTL);	// Inherit parent window's mirroring

	if (fMirrorWnd)
	{
		// Force RTL reading
		cs.style |= ES_RIGHT;
		cs.dwExStyle |= WS_EX_RTLREADING;
	}
#endif

#ifndef NOANSIWINDOWS
	//bug fix #5386
	// Window wasn't created with the Richedit20A window class
	// and we are under Win9x, need to convert string to UNICODE
	CStrInW strinwName(((LPSTR)pcs->lpszName), GetKeyboardCodePage());
	CStrInW strinwClass(((LPSTR)pcs->lpszClass), CP_ACP);
	if (!fIsAnsi && W32->OnWin9x())
	{
		cs.lpszName = (WCHAR *)strinwName;
		cs.lpszClass = (WCHAR *)strinwClass;
	}
#endif

	// Stores phost in associated window data
	if(!phost->Init(hwnd, (const CREATESTRUCT*)&cs, fIsAnsi, fIs10Mode))
	{
		phost->Shutdown();
		delete phost;
		phost = NULL;
	}

#ifndef NOCOMPLEXSCRIPTS
	if (phost && fMirrorWnd)
	{
		// Disable mirroring layout to avoid mirrored mapping mode
		SetWindowLong(hwnd, GWL_STYLE, cs.style | ES_RIGHT);
		SetWindowLong(hwnd, GWL_EXSTYLE, (cs.dwExStyle & ~WS_EX_LAYOUTRTL) | WS_EX_LEFTSCROLLBAR);
	}
#endif

	return phost;
}

/*
 *	CTxtWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_CREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLong())
 */
void CTxtWinHost::OnNCDestroy(
	CTxtWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnNCDestroy");

	phost->Shutdown();
	phost->Release();
}

/*
 *	CTxtWinHost::CTxtWinHost()
 *
 *	@mfunc
 *		constructor
 */
CTxtWinHost::CTxtWinHost() 
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::CTxtWinHost");

#ifndef NOACCESSIBILITY
    _pTypeInfo = NULL;
#endif

	_fRegisteredForDrop = FALSE;
	_crefs = 1;	
	if(!_fNotSysBkgnd)
		_crBackground = GetSysColor(COLOR_WINDOW);
}

/*
 *	CTxtWinHost::~CTxtWinHost()
 *
 *	@mfunc
 *		destructor
 */
CTxtWinHost::~CTxtWinHost()
{
	AssertSz(_pserv == NULL, 
		"CTxtWinHost::~CTxtWinHost - shutdown not called till destructor");

	if(_pserv)
		Shutdown();
}

/*
 *	CTxtWinHost::Shutdown()
 *
 *	@mfunc	Shut down this object, but doesn't delete memory
 */
void CTxtWinHost::Shutdown()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Shutdown");
	ITextServices *pserv;
	
	HostRevokeDragDrop();					// Revoke our drop target
	
	if(_pserv)
	{
		// Guarantee that no recursive callbacks can happen during shutdown.
		pserv = _pserv;
		_pserv = NULL;

		pserv->OnTxInPlaceDeactivate();
		pserv->Release();

		// Host release was not the final release so notify
		// text services that they need to keep their reference
		// to the host valid.
		if (!_fTextServiceFree)
		{
			((CTxtEdit *)pserv)->SetReleaseHost();

		}
	}

#if 0
	ImmTerminate();						// Terminate only useful on Mac.
#endif

	if(_hwnd)
		SetWindowLongPtr(_hwnd, ibPed, 0);
}

/*
 *	CTxtWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CTxtWinHost
 */
BOOL CTxtWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs,	//@parm Corresponding CREATESTRUCT
	BOOL fIsAnsi,				//@parm is ansi window
	BOOL fIs10Mode)				//@parm is 1.0 mode window
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Init");

	AssertSz(!fIs10Mode || (fIsAnsi && fIs10Mode), 
		"CTxtWinHost::Init input flags are out of sync!");

	if(!pcs->lpszClass)
		return FALSE;

	// Set pointer back to CTxtWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;

	// Here we want to keep track of the "RichEdit20A"window class
	// The RICHEDIT window class is handled by a wrapper dll.
	// If the class name is "RICHEDIT", then we need to turn on the
	// RichEdit 1.0 compatibility bit.  IsAnsiWindowClass tests that class as well.
	_fANSIwindow = fIsAnsi;

 	// Edit controls created without a window are multiline by default
	// so that paragraph formats can be
	_dwStyle = ES_MULTILINE;
	_fHidden = TRUE;
	
	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		if (!fIs10Mode)
		{
			// Only set this for 2.0 windows
			// According to the edit control documentation WS_HSCROLL implies that
			// ES_AUTOSCROLL is set and WS_VSCROLL implies that ES_AUTOVSCROLL is
			// set. Here, we make this so.
			if(_dwStyle & WS_HSCROLL)
				_dwStyle |= ES_AUTOHSCROLL;

			// handle default disabled
			if(_dwStyle & WS_DISABLED)
				_fDisabled = TRUE;
		}
		else
		{
		if (GetBkMode(GetDC(hwnd)) == TRANSPARENT)
			_dwExStyle |= WS_EX_TRANSPARENT;
		else
			_dwExStyle &= ~WS_EX_TRANSPARENT;
		}

		if(_dwStyle & WS_VSCROLL)
			_dwStyle |= ES_AUTOVSCROLL;

		_fBorder = !!(_dwStyle & WS_BORDER);

		if((_dwStyle & ES_SUNKEN) || (_dwExStyle & WS_EX_CLIENTEDGE))
			_fBorder = TRUE;

		// handle default passwords
		if(_dwStyle & ES_PASSWORD)
			_chPassword = TEXT('*');

		// On Win95 ES_SUNKEN and WS_BORDER get mapped to WS_EX_CLIENTEDGE
		if(_fBorder && W32->_dwMajorVersion >= VERS4)
        {
			_dwExStyle |= WS_EX_CLIENTEDGE;
			SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
        }

#ifndef NORIGHTTOLEFT
		// Process some flags for mirrored control
		if (_dwExStyle & WS_EX_LAYOUTRTL)
		{
			// Swap whatever RTL params we have
			_dwStyle = (_dwStyle & ~ES_RIGHT) | (_dwStyle & ES_RIGHT ^ ES_RIGHT);
			_dwExStyle = (_dwExStyle & ~WS_EX_RTLREADING) | (_dwExStyle & WS_EX_RTLREADING ^ WS_EX_RTLREADING);
			_dwExStyle = (_dwExStyle & ~WS_EX_LEFTSCROLLBAR) |
						 (_dwStyle & ES_RIGHT ? WS_EX_LEFTSCROLLBAR : 0);
	
			// Disable mirroring layout to avoid GDI mirroring mapping mode
			_dwExStyle &= ~WS_EX_LAYOUTRTL;
	
			SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
			SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
		}
#endif		
	}

	// Create Text Services component
	// Watch out for sys param and sys font initialization!!  see below.
	if(FAILED(CreateTextServices()))
		return FALSE;

	_xInset = (char)W32->GetCxBorder();
	_yInset = (char)W32->GetCyBorder();

	if (!_fBorder)
	{
		_xInset += _xInset;
		_yInset += _yInset;
	}

	// At this point the border flag is set and so is the pixels per inch
	// so we can initalize the inset.
	// This must be done after CreatingTextServices so sys params are valid
	SetDefaultInset();

	// Set alignment and paragraph direction
	PARAFORMAT PF2;
	
	PF2.dwMask = 0;

#ifndef NOCOMPLEXSCRIPTS
	BOOL fRCAlign = _dwStyle & (ES_RIGHT | ES_CENTER) || _dwExStyle & WS_EX_RIGHT;
	if(fRCAlign)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = (WORD)(_dwStyle & ES_CENTER ? PFA_CENTER : PFA_RIGHT);	// right or center-aligned
	}

	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}
#endif

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}

	if (fIs10Mode)
	{
		 ((CTxtEdit *)_pserv)->Set10Mode();
		 // Remove the WS_VSCROLL and WS_HSCROLL initially
        if (_hwnd && !(_dwStyle & ES_DISABLENOSCROLL))
        {
            SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
    		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);
            DWORD dwStyle = _dwStyle & ~(WS_VSCROLL | WS_HSCROLL);
            SetWindowLong(_hwnd, GWL_STYLE, dwStyle);

            // bug fix:
            // On some systems, ie Digital PII-266, we don't get a WM_PAINT message
            // when we change the window style.  So force a WM_PAINT into the message queue
            TxInvalidateRect(NULL, TRUE);
        }
    }

	// Set window text
	if(pcs && pcs->lpszName)
	{
		if(FAILED(_pserv->TxSetText((TCHAR *)pcs->lpszName)))
		{
			SafeReleaseAndNULL((IUnknown **)&_pserv);
			return FALSE;
		}
	}

	if(_dwStyle & ES_LOWERCASE)
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_LOWERCASE,
							  SES_LOWERCASE | SES_UPPERCASE, NULL);

#if 0
	if(!ImmInitialize())			// Mac Only
	{
		#if defined(DEBUG)
		OutputDebugString(TEXT("Could not register Imm ImmInitializeForMac.\r\n"));
		#endif	// DEBUG
	}
#endif

	return TRUE;
}

HRESULT CTxtWinHost::CreateTextServices()
{
	IUnknown *pUnk;
	HRESULT	  hr = ::CreateTextServices(NULL, this, &pUnk);

	if(hr != NOERROR)
		return hr;

	// Get text services interface
	hr = pUnk->QueryInterface(IID_ITextServices, (void **)&_pserv);

	// Regardless of whether the previous call succeeded or failed, we are
	// done with the private interface.
	pUnk->Release();

#ifndef NOCOMPLEXSCRIPTS
	if(hr == NOERROR)
	{
		((CTxtEdit *)_pserv)->_fInOurHost = TRUE;
		// FE extended styles might set the fFE bit 
		if(_dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR))
			_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_BIDI, SES_BIDI, NULL);
	}
#endif

	return hr;
}

/*
 *	CTxtWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CTxtWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;
	
	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;

	DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
	
	// Hide all scrollbars to start
	if(_hwnd && !(dwStyle & ES_DISABLENOSCROLL) && !((CTxtEdit *)_pserv)->Get10Mode())
	{
		SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);

		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);
		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
	}

	if(!(dwStyle & (ES_READONLY | ES_NOOLEDRAGDROP)))
	{
		// This isn't a read only window or a no drop window,
		// so we need a drop target.
		HostRegisterDragDrop();
	}

	_usIMEMode = 0;	
	if(dwStyle & ES_NOIME)
	{
		_usIMEMode = ES_NOIME;
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	
	}
	else if(dwStyle & ES_SELFIME)
		_usIMEMode = ES_SELFIME;

	return 0;
}


/////////////////////////////////  IUnknown ////////////////////////////////

HRESULT CTxtWinHost::QueryInterface(REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");
  
  	if(IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown *)(ITextHost2*)this;

	else if(IsEqualIID(riid, IID_ITextHost) )
		*ppv = (ITextHost *)(CTxtWinHost*)this;

	else if(IsEqualIID(riid, IID_ITextHost2) )
		*ppv = (ITextHost2 *)(CTxtWinHost*)this;

	else
		*ppv = NULL;

	if(*ppv)
	{
		AddRef();
		return NOERROR;
	}
	return E_NOINTERFACE;
}

ULONG CTxtWinHost::AddRef(void)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::AddRef");

	return ++_crefs;
}

ULONG CTxtWinHost::Release(void)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::Release");

	--_crefs;

	if(!_crefs)
	{
#ifndef NOACCESSIBILITY
        if(_pTypeInfo)
        {
            _pTypeInfo->Release();
            _pTypeInfo = NULL;
        }           
#endif
		delete this;
		return 0;
	}
	return _crefs;
}


//////////////////////////////// Activation ////////////////////////////////

//////////////////////////////// Properties ////////////////////////////////


TXTEFFECT CTxtWinHost::TxGetEffects() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxGetEffects");

	if((_dwStyle & ES_SUNKEN) || (_dwExStyle & WS_EX_CLIENTEDGE))
		return TXTEFFECT_SUNKEN;

	return TXTEFFECT_NONE;
}

///////////////////////////////  Keyboard Messages  //////////////////////////////////

/*
 *	CTxtWinHost::OnKeyDown (vkey, dwFlags)
 *
 *	@mfunc
 *		Handle WM_KEYDOWN messages that need to send a message to the parent
 *		window (may happen when control is in a dialog box)
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CTxtWinHost::OnKeyDown(
	WORD	vkey,			//@parm WM_KEYDOWN wparam (virtual key code)
	DWORD	dwFlags)		//@parm WM_KEYDOWN flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnKeyDown");

	if(!_fInDialogBox) 					// Not in a dialog box
		return 1;						// Signal key-down msg not processed

	DWORD dwKeyFlags = GetKeyboardFlags();

	switch(vkey)
	{
	case VK_ESCAPE:
		PostMessage(_hwndParent, WM_CLOSE, 0, 0);
		return 0;
	
	case VK_RETURN:
		if(!(dwKeyFlags & CTRL) && !(_dwStyle & ES_WANTRETURN))
		{
			// Send to default button
			HWND	hwndT;
			LRESULT id = SendMessage(_hwndParent, DM_GETDEFID, 0, 0);

			if(LOWORD(id) && (hwndT = GetDlgItem(_hwndParent, LOWORD(id))))
			{
				SendMessage(_hwndParent, WM_NEXTDLGCTL, (WPARAM) hwndT, (LPARAM) 1);
				if(GetFocus() != _hwnd)
					PostMessage(hwndT, WM_KEYDOWN, (WPARAM) VK_RETURN, 0);
			}
			return 0;
		}
		break;

	case VK_TAB:
		if(!(dwKeyFlags & CTRL))
		{
			SendMessage(_hwndParent, WM_NEXTDLGCTL, 
								!!(dwKeyFlags & SHIFT), 0);
			return 0;
		}
		break;
	}

	return 1;
}

/*
 *	CTxtWinHost::OnChar (vkey, dwFlags)
 *
 *	@mfunc
 *		Eat some WM_CHAR messages for a control in a dialog box
 *
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CTxtWinHost::OnChar(
	WORD	vkey,			//@parm WM_CHAR wparam (translated key code)
	DWORD	dwFlags)		//@parm WM_CHAR flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnChar");

	if(!_fInDialogBox || (GetKeyboardFlags() & CTRL)) 
		return 1;
	
	switch(vkey)
	{
	case 'J' - 0x40:					// Ctrl-Return generates Ctrl-J (LF):
	case VK_RETURN:						//  treat it as an ordinary return
		// We need to filter-out cases where we don't want to insert <cr> in
		// 1.0 mode here since the info isn't available within the ped
		if (((CTxtEdit*)_pserv)->Get10Mode())
		{
			if (_fInDialogBox && dwFlags != MK_CONTROL && !(_dwStyle & ES_WANTRETURN))
				return 0;
				
			if (!(_dwStyle & ES_MULTILINE))
			{
				//richedit beeps in this case
				((CTxtEdit*)_pserv)->Beep();
				return 0;
			}
		}
		else if (!(_dwStyle & ES_WANTRETURN))
			return 0;					// Signal char processed (eaten)		
		break;

	case VK_TAB:
		return 0;
	}
	
	return 1;							// Signal char not processed
}


/////////////////////////////////  View rectangle //////////////////////////////////////

void CTxtWinHost::OnGetRect(
	LPRECT prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetRect");

	RECT rcInset;
	LONG lSelBarWidth = 0;

	if(_fEmSetRectCalled)
	{
		// Get the selection bar width and add it back to the view inset so
		// we return the rectangle that the application set.
		TxGetSelectionBarWidth(&lSelBarWidth);
	}

	// Get view inset (in HIMETRIC)
	TxGetViewInset(&rcInset);

	// Get client rect in pixels
	TxGetClientRect(prc);

	// Modify the client rect by the inset converted to pixels
	prc->left	+= W32->HimetricToDevice(rcInset.left + lSelBarWidth, W32->GetXPerInchScreenDC());
	prc->top	+= W32->HimetricToDevice(rcInset.top, W32->GetYPerInchScreenDC());
	prc->right	-= W32->HimetricToDevice(rcInset.right, W32->GetXPerInchScreenDC());
	prc->bottom -= W32->HimetricToDevice(rcInset.bottom, W32->GetYPerInchScreenDC());
}

void CTxtWinHost::OnSetRect(
	LPRECT prc,				//@parm Desired formatting RECT
	BOOL fNewBehavior,		//@parm If TRUE, prc is inset RECT directly
	BOOL fRedraw)			//@parm If TRUE, redraw after setting RECT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetRect");

	RECT rcClient;
	LONG lSelBarWidth;
	
	// Assuming this is not set to the default, turn on special EM_SETRECT 
	// processing. The important part of this is that we subtract the selection 
	// bar from the view inset because the EM_SETRECT rectangle does not 
	// include the selection bar.
	_fEmSetRectCalled = TRUE;

	if(!prc)
	{
		// We are back to the default so turn off special EM_SETRECT procesing.
		_fEmSetRectCalled = FALSE;
		SetDefaultInset();
	}
	else	
	{
		// For screen display, the following intersects new view RECT
		// with adjusted client area RECT
		TxGetClientRect(&rcClient);

		// Adjust client rect. Factors in space for borders
		if(_fBorder)
		{																					  
			rcClient.top		+= _yInset;
			rcClient.bottom 	-= _yInset - 1;
			rcClient.left		+= _xInset;
			rcClient.right		-= _xInset;
		}
	
		if(!fNewBehavior)
		{
			// Intersect new view rectangle with adjusted client area rectangle
			if(!IntersectRect(&_rcViewInset, &rcClient, prc))
				_rcViewInset = rcClient;
		}
		else
			_rcViewInset = *prc;

		// Get selection bar width 
		TxGetSelectionBarWidth(&lSelBarWidth);

		// Compute inset in pixels and convert to HIMETRIC.
		_rcViewInset.left = W32->DeviceToHimetric(_rcViewInset.left - rcClient.left, W32->GetXPerInchScreenDC()) - lSelBarWidth;
		_rcViewInset.top = W32->DeviceToHimetric(_rcViewInset.top - rcClient.top, W32->GetYPerInchScreenDC());
		_rcViewInset.right = W32->DeviceToHimetric(rcClient.right - _rcViewInset.right, W32->GetXPerInchScreenDC());
		_rcViewInset.bottom = W32->DeviceToHimetric(rcClient.bottom - _rcViewInset.bottom, W32->GetYPerInchScreenDC());
	}
	if(fRedraw)
	{
		_pserv->OnTxPropertyBitsChange(TXTBIT_VIEWINSETCHANGE, 
			TXTBIT_VIEWINSETCHANGE);
	}
}


///////////////////////////////  System notifications  //////////////////////////////////

void CTxtWinHost::OnSysColorChange()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSysColorChange");

	if(!_fNotSysBkgnd)
		_crBackground = GetSysColor(COLOR_WINDOW);
	TxInvalidateRect(NULL, TRUE);
}

/*
 *	CTxtWinHost::OnGetDlgCode (wparam, lparam)
 *
 *	@mfunc
 *		Handle some WM_GETDLGCODE messages
 *
 *	#rdesc
 *		LRESULT = dialog code
 */
LRESULT CTxtWinHost::OnGetDlgCode(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetDlgCode");

	LRESULT lres = DLGC_WANTCHARS | DLGC_WANTARROWS | DLGC_WANTTAB;

	if(_dwStyle & ES_MULTILINE)
		lres |= DLGC_WANTALLKEYS;

	if(!(_dwStyle & ES_SAVESEL))
		lres |= DLGC_HASSETSEL;

	// HACK: If we get one of these messages then we turn on the special
	// EM_SETSEL behavior. The problem is that _fInDialogBox gets turned
	// on after the EM_SETSEL has occurred.
	_fUseSpecialSetSel = TRUE;

	/*
	** -------------------------------------------- JEFFBOG HACK ----
	** Only set Dialog Box Flag if GETDLGCODE message is generated by
	** IsDialogMessage -- if so, the lParam will be a pointer to the
	** message structure passed to IsDialogMessage; otherwise, lParam
	** will be NULL.  Reason for the HACK alert:  the wParam & lParam
	** for GETDLGCODE is still not clearly defined and may end up
	** changing in a way that would throw this off
	** -------------------------------------------- JEFFBOG HACK ----
	 */
	if(lparam)
		_fInDialogBox = TRUE;

	/*
	** If this is a WM_SYSCHAR message generated by the UNDO keystroke
	** we want this message so we can EAT IT in remain.c, case WM_SYSCHAR:
	 */
	if (lparam &&
		(((LPMSG)lparam)->message == WM_SYSCHAR)  &&
		(((LPMSG)lparam)->lParam & SYS_ALTERNATE) &&	
		wparam == VK_BACK)
	{
		lres |= DLGC_WANTMESSAGE;
	}

	return lres;
}


/////////////////////////////////  Other messages  //////////////////////////////////////

LRESULT CTxtWinHost::OnGetOptions() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnGetOptions");

	LRESULT lres = (_dwStyle & ECO_STYLES);

	if(_fEnableAutoWordSel)
		lres |= ECO_AUTOWORDSELECTION;
	
	return lres;
}

void CTxtWinHost::OnSetOptions(
	WORD  wOp,
	DWORD eco)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetOptions");

	DWORD		dwChangeMask = 0;
	DWORD		dwProp = 0;
	DWORD		dwStyle;
	DWORD		dwStyleNew = _dwStyle;
	const BOOL	fAutoWordSel = !!(eco & ECO_AUTOWORDSELECTION);		
	BOOL		bNeedToTurnOffIME = FALSE;

	// We keep track of the bits changed and then if any have changed we
	// query for all of our property bits and then send them. This simplifies
	// the code because we don't have to set all the bits specially. If the
	// code is changed to make the properties more in line with the new 
	// model, we want to look at this code again.

	// Single line controls can't have a selection bar or do vertical writing
	if(!(_dwStyle & ES_MULTILINE))
		eco &= ~ECO_SELECTIONBAR;

	Assert((DWORD)fAutoWordSel <= 1);			// Make sure that BOOL is 1/0
	dwStyle = (eco & ECO_STYLES);

	switch(wOp)
	{
	case ECOOP_SET:
		dwStyleNew			= (dwStyleNew & ~ECO_STYLES) | dwStyle;
		_fEnableAutoWordSel = fAutoWordSel;
		break;

	case ECOOP_OR:
		dwStyleNew |= dwStyle;					// Setting a :1 flag = TRUE
		if(fAutoWordSel)						//  or FALSE is 1 instruction
			_fEnableAutoWordSel = TRUE;			// Setting it to a BOOL
		break;									//  averages 9 instructions!

	case ECOOP_AND:
		dwStyleNew &= (dwStyle | ~ECO_STYLES);
		if(!fAutoWordSel)
			_fEnableAutoWordSel = FALSE;
		break;

	case ECOOP_XOR:
		dwStyleNew ^= dwStyle;
		if(fAutoWordSel)
			_fEnableAutoWordSel ^= 1;
		break;
	}

	if(_fEnableAutoWordSel != (unsigned)fAutoWordSel)
		dwChangeMask |= TXTBIT_AUTOWORDSEL; 

	if(dwStyleNew != _dwStyle)
	{
		DWORD dwChange = dwStyleNew ^ _dwStyle;

		AssertSz(!(dwChange & ~ECO_STYLES), "non-eco style changed");
		if(!(dwStyleNew & ES_MULTILINE))
			dwStyleNew &= ~ES_VERTICAL;

		_dwStyle = dwStyleNew;
		SetWindowLong(_hwnd, GWL_STYLE, dwStyleNew & ~ES_VERTICAL);

		if(dwChange & ES_NOHIDESEL)	
			dwChangeMask |= TXTBIT_HIDESELECTION;

		// These two local variables to use to keep track of
		// previous setting of ES_READONLY
		BOOL bReadOnly = (_dwStyle & ES_READONLY);

		if(dwChange & ES_READONLY)
		{
			dwChangeMask |= TXTBIT_READONLY;

			// Change drop target state as appropriate.
			if(dwStyleNew & ES_READONLY)
				HostRevokeDragDrop();

			else
				HostRegisterDragDrop();
			
			bReadOnly = (dwStyleNew & ES_READONLY);
		}

		if(dwChange & ES_VERTICAL)
			dwChangeMask |= TXTBIT_VERTICAL;

		if(dwChange & ES_NOIME)
		{
			_usIMEMode = (dwStyleNew & ES_NOIME) ? ES_NOIME : 0;
			bNeedToTurnOffIME = (_usIMEMode ==ES_NOIME);
		}
		else if(dwChange & ES_SELFIME)
			_usIMEMode = (dwStyleNew & ES_SELFIME) ? ES_SELFIME : 0;
		
		// No action required for ES_WANTRETURN nor for ES_SAVESEL
		// Do this last
		if(dwChange & ES_SELECTIONBAR)
			dwChangeMask |= TXTBIT_SELBARCHANGE;
	}

	if (dwChangeMask)
	{
		TxGetPropertyBits(dwChangeMask, &dwProp);
		_pserv->OnTxPropertyBitsChange(dwChangeMask, dwProp);
	}

	if (bNeedToTurnOffIME)
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	
}

void CTxtWinHost::OnSetReadOnly(
	BOOL fReadOnly)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSetReadOnly");

	DWORD dwT = GetWindowLong(_hwnd, GWL_STYLE);
	DWORD dwUpdatedBits = 0;

	if(fReadOnly)
	{
		dwT |= ES_READONLY;
		_dwStyle |= ES_READONLY;

		// Turn off Drag Drop 
		HostRevokeDragDrop();
		dwUpdatedBits |= TXTBIT_READONLY;
	}
	else
	{
		dwT		 &= ~ES_READONLY;
		_dwStyle &= ~ES_READONLY;

		// Turn drag drop back on
		HostRegisterDragDrop();	
	}

	_pserv->OnTxPropertyBitsChange(TXTBIT_READONLY, dwUpdatedBits);

	SetWindowLong(_hwnd, GWL_STYLE, dwT);
}


////////////////////////////////////  Helpers  /////////////////////////////////////////

void CTxtWinHost::SetDefaultInset()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::SetDefaultInset");

	// Generate default view rect from client rect
	if(_fBorder)
	{
		// Factors in space for borders
  		_rcViewInset.top	= W32->DeviceToHimetric(_yInset, W32->GetYPerInchScreenDC());
   		_rcViewInset.bottom	= W32->DeviceToHimetric(_yInset - 1, W32->GetYPerInchScreenDC());
   		_rcViewInset.left	= W32->DeviceToHimetric(_xInset, W32->GetXPerInchScreenDC());
   		_rcViewInset.right	= W32->DeviceToHimetric(_xInset, W32->GetXPerInchScreenDC());
	}
	else
	{
		// Default the top and bottom inset to 0 and the left and right
		// to the size of the border.
		_rcViewInset.top = 0;
		_rcViewInset.bottom = 0;
		_rcViewInset.left = W32->DeviceToHimetric(W32->GetCxBorder(), W32->GetXPerInchScreenDC());
		_rcViewInset.right = W32->DeviceToHimetric(W32->GetCxBorder(), W32->GetXPerInchScreenDC());
	}
}


/////////////////////////////////  East Asia Support  //////////////////////////////////////

HIMC CTxtWinHost::TxImmGetContext()
{
#ifndef NOFEPROCESSING
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxImmGetContext");

	HIMC himc;

	Assert(_hwnd);
	himc = ImmGetContext(_hwnd, FALSE);
	return himc;
#else
    return NULL;
#endif
}

void CTxtWinHost::TxImmReleaseContext(
	HIMC himc)
{
#ifndef NOFEPROCESSING
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::TxImmReleaseContext");

	Assert(_hwnd);
	ImmReleaseContext(_hwnd, himc, FALSE);
#endif
}


void CTxtWinHost::HostRevokeDragDrop()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::HostRevokeDragDrop");

	if(_fRegisteredForDrop)
	{
		// Note that if the revoke fails we want to know about this in debug
		// builds so we can fix any problems. In retail, we can't really do 
		// so we just ignore it.
#if !defined(NOFULLDEBUG) && defined(DEBUG)
		HRESULT hr = 
#endif // DEBUG

			RevokeDragDrop(_hwnd);

#if !defined(NOFULLDEBUG) && defined(DEBUG)
		TESTANDTRACEHR(hr);
#endif // DEBUG

		_fRegisteredForDrop = FALSE;
	}
}

void CTxtWinHost::HostRegisterDragDrop()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::RegisterDragDrop");

	IDropTarget *pdt = NULL;

	if(!_fRegisteredForDrop && _pserv->TxGetDropTarget(&pdt) == NOERROR)
	{
		// The most likely reason for RegisterDragDrop to fail is some kind of
		// bug in our program.

		HRESULT hr = RegisterDragDrop(_hwnd, pdt);

		if(hr == NOERROR)
			_fRegisteredForDrop = TRUE;

		if (pdt)
			pdt->Release();
	}
}


#define cmultBorder 1

void CTxtWinHost::OnSunkenWindowPosChanging(
	HWND hwnd,
	WINDOWPOS *pwndpos)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSunkenWindowPosChanging");

	if(IsWindowVisible(hwnd))
	{
		RECT rc;
		HWND hwndParent;

		GetWindowRect(hwnd, &rc);
		InflateRect(&rc, W32->GetCxBorder() * cmultBorder, W32->GetCyBorder() * cmultBorder);
		hwndParent = GetParent(hwnd);
		MapWindowPoints(HWND_DESKTOP, hwndParent, (POINT *) &rc, 2);
		InvalidateRect(hwndParent, &rc, TRUE);
	}
}

LRESULT CTxtWinHost::OnSize(
	HWND hwnd,
	WORD fwSizeType,
	int  nWidth,
	int  nHeight)
{	 
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnSize");

	BOOL fIconic = GetIconic(hwnd);
	DWORD dw = TXTBIT_CLIENTRECTCHANGE;
	if(_sWidth != nWidth && !fIconic && !_fIconic)
	{
		_sWidth = (short)nWidth;				// Be sure to update _sWidth
		dw = TXTBIT_EXTENTCHANGE;
	}

	if(!_fVisible)
	{
		if(!fIconic)
			_fResized = TRUE;
	}
	else if(!fIconic)
	{
		// We use this property because this will force a recalc.
		// We don't actually recalc on a client rect change because
		// most of the time it is pointless. We force one here because
		// some applications use size changes to calculate the optimal 
		// size of the window.
		_pserv->OnTxPropertyBitsChange(dw, dw);

		if(_fIconic)
		{
			TRACEINFOSZ("Restoring from iconic");
			InvalidateRect(hwnd, NULL, TRUE);
		}
	}
	_fIconic = fIconic;						// Update _fIconic
	return 0;
}

HRESULT CTxtWinHost::OnTxVisibleChange(
	BOOL fVisible)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::OnTxVisibleChange");

	_fVisible = fVisible;

	if(!_fVisible && _fResized)
	{
		RECT rc;
		// Control was resized while hidden, need to really resize now
		TxGetClientRect(&rc);
		_fResized = FALSE;
		_pserv->OnTxPropertyBitsChange(TXTBIT_CLIENTRECTCHANGE, 
				TXTBIT_CLIENTRECTCHANGE);
	}
	return S_OK;
}


//////////////////////////// ITextHost Interface  ////////////////////////////

// @doc EXTERNAL 
/* 
 *	CTxtWinHost::TxGetDC()
 *
 *	@mfunc
 *		Abstracts GetDC so Text Services does not need a window handle.
 *
 *	@rdesc
 *		A DC or NULL in the event of an error.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
HDC CTxtWinHost::TxGetDC()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetDC");

	Assert(_hwnd);
	return ::GetDC(_hwnd);
}

/* 
 *	CTxtWinHost::TxReleaseDC (hdc)
 *
 *	@mfunc
 *		Release DC gotten by TxGetDC. 
 *
 *	@rdesc	
 *		1 - HDC was released. <nl>
 *		0 - HDC was not released. <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
int CTxtWinHost::TxReleaseDC(
	HDC hdc)				//@parm	DC to release
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxReleaseDC");

	Assert(_hwnd);
	return ::ReleaseDC (_hwnd, hdc);
}

/* 
 *	CTxtWinHost::TxShowScrollBar (fnBar, fShow)
 *
 *	@mfunc
 *		Shows or Hides scroll bar in Text Host window 
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxShowScrollBar(
	INT  fnBar, 		//@parm	Specifies scroll bar(s) to be shown or hidden
	BOOL fShow)			//@parm	Specifies whether scroll bar is shown or hidden
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxShowScrollBar");

	Assert(_hwnd);
	LONG nMax;

	if(fnBar == SB_HORZ) 
		_pserv->TxGetHScroll(NULL, &nMax, NULL, NULL, NULL);
	else
		_pserv->TxGetVScroll(NULL, &nMax, NULL, NULL, NULL);

	return W32->ShowScrollBar(_hwnd, fnBar, fShow, nMax);
}

/* 
 *	CTxtWinHost::TxEnableScrollBar (fuSBFlags, fuArrowflags)
 *
 *	@mfunc
 *		Enables or disables one or both scroll bar arrows 
 *		in Text Host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return 
 *		value is TRUE. If the arrows are already in the requested state or an 
 *		error occurs, the return value is FALSE. 
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.	
 */
BOOL CTxtWinHost::TxEnableScrollBar (
	INT fuSBFlags, 		//@parm Specifies scroll bar type	
	INT fuArrowflags)	//@parm	Specifies whether and which scroll bar arrows
						//		are enabled or disabled
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxEnableScrollBar");

	Assert(_hwnd);
	return W32->EnableScrollBar(_hwnd, fuSBFlags, fuArrowflags);
}

/* 
 *	CTxtWinHost::TxSetScrollRange (fnBar, nMinPos, nMaxPos, fRedraw)
 *
 *	@mfunc
 *		Sets the minimum and maximum position values for the specified 
 *		scroll bar in the text host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return value
 *		is TRUE. If the arrows are already in the requested state or an error
 *		occurs, the return value is FALSE. 
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetScrollRange(
	INT	 fnBar, 		//@parm	Scroll bar flag
	LONG nMinPos, 		//@parm	Minimum scrolling position
	INT  nMaxPos, 		//@parm	Maximum scrolling position
	BOOL fRedraw)		//@parm	Specifies whether scroll bar should be redrawn
{						//		to reflect change
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetScrollRange");

	Assert(_hwnd);

	if(NULL == _pserv)
	{
		// We are initializing so do this instead of callback
		return ::SetScrollRange(_hwnd, fnBar, nMinPos, nMaxPos, fRedraw);
	}
	SetScrollInfo(fnBar, fRedraw);
	return TRUE;  
}

/* 
 *	CTxtWinHost::TxSetScrollPos (fnBar, nPos, fRedraw)
 *
 *	@mfunc
 *		Tells Text host to set the position of the scroll box (thumb) in the 
 *		specified scroll bar and, if requested, redraws the scroll bar to
 *		reflect the new position of the scroll box.
 *
 *	@rdesc
 *		TRUE on success; FALSE otherwise.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetScrollPos (
	INT		fnBar, 		//@parm	Scroll bar flag
	INT		nPos, 		//@parm	New position in scroll box
	BOOL	fRedraw)	//@parm	Redraw flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetScrollPos");

	Assert(_hwnd);

	if(NULL == _pserv)
	{
		// We are initializing so do this instead of callback
		return ::SetScrollPos(_hwnd, fnBar, nPos, fRedraw);
	}
	SetScrollInfo(fnBar, fRedraw);
	return TRUE;  
}

/* 
 *	CTxtWinHost::TxInvalidateRect (prc, fMode)
 *
 *	@mfunc
 *		Adds a rectangle to the Text Host window's update region
 *
 *	@comm
 *		This function may be called while inactive; however the host
 *		implementation is free to invalidate an area greater than
 *		the requested rect.
 *
 *	Note: In transparent mode, we need to pass TRUE to InvalidateRect.
 *	However, in all other cases, it is best to pass FALSE, because we always
 *	repaint the backgrounds of our displays.
 */
void CTxtWinHost::TxInvalidateRect(
	LPCRECT	prc, 		//@parm	Address of rectangle coordinates
	BOOL	fMode)		//@parm	Erase background flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxInvalidateRect");

	Assert(_hwnd);

	if(!_fVisible)
	{
		// There doesn't seem to be a deterministic way to determine whether
		// our window is visible or not via message notifications. Therefore,
		// we check this each time in case it might have changed.
		_fVisible = IsWindowVisible(_hwnd);

		if(_fVisible)
			OnTxVisibleChange(TRUE);
	}

	// Don't bother with invalidating rect if we aren't visible
	if(_fVisible)
	{
		if(IsTransparentMode())
		{
			RECT	rcParent;
			HWND	hParent = ::GetParent(_hwnd);
		
			Assert(hParent);

	 		// For transparent mode, we need to invalidate the parent
			// so it will paint the background.
			if(prc)
				rcParent = *prc;
			else
				TxGetClientRect(&rcParent);	

			::MapWindowPoints(_hwnd, hParent, (LPPOINT)&rcParent, 2);
			::InvalidateRect(hParent, &rcParent, TRUE);
//			::HideCaret(_hwnd);
		}
		::InvalidateRect(_hwnd, prc, FALSE);
	}
}

/* 
 *	CTxtWinHost::TxViewChange (fUpdate)
 *
 *	@mfunc
 *		Notify Text Host that update region should be repainted. 
 *	
 *	@comm
 *		It is the responsibility of the text services to call 
 *		TxViewChanged every time it decides that it's visual representation 
 *		has changed, regardless of whether the control is active or 
 *		not. If the control is active, the text services has the additional
 *		responsibility of making sure the controls window is updated.
 *		It can do this in a number of ways: 1) get a DC for the control's 
 *		window and start blasting pixels (TxGetDC and TxReleaseDC), 2) 
 *		invalidate the control's window (TxInvalidate), or 3) scroll 
 *		the control's window (TxScrollWindowEx).
 *
 *		Text services can choose to call TxViewChange after it has
 *		performed any operations to update the active view and pass a
 *		true along with the call.  By passing true, the text host
 *		calls UpdateWindow to make sure any unpainted areas of the
 *		active control are repainted.
 */
void CTxtWinHost::TxViewChange(
	BOOL fUpdate)		//@parm TRUE = call update window
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxViewChange");

	Assert(_hwnd);

	// Don't bother with paint since we aren't visible
	if(_fVisible)
	{
		// For updates requests that are FALSE, we will let the next WM_PAINT 
		// message pick up the draw.
		if(fUpdate)
		{
			if(IsTransparentMode())
			{
				HWND	hParent = GetParent (_hwnd);
				Assert(hParent);

	 			// For transparent mode, we need to update the parent first
				// before we can update ourself.  Otherwise, what we painted will
				// be erased by the parent's background later.
				::UpdateWindow (hParent);
			}
			::UpdateWindow (_hwnd);
		}
	}
}

/* 
 *	CTxtWinHost::TxCreateCaret (hbmp, xWidth, yHeight)
 *
 *	@mfunc
 *		Create new shape for Text Host's caret
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxCreateCaret(
	HBITMAP hbmp, 		//@parm Handle of bitmap for caret shape	
	INT xWidth, 		//@parm	Caret width
	INT yHeight)		//@parm	Caret height
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxCreateCaret");

	Assert(_hwnd);
	return ::CreateCaret (_hwnd, hbmp, xWidth, yHeight);
}

/* 
 *	CTxtWinHost::TxShowCaret (fShow)
 *
 *	@mfunc
 *		Make caret visible/invisible at caret position in Text Host window. 
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxShowCaret(
	BOOL fShow)			//@parm Flag whether caret is visible
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxShowCaret");

	return fShow ? ::ShowCaret(_hwnd)  :  ::HideCaret(_hwnd);
}

/* 
 *	CTxtWinHost::TxSetCaretPos (x, y)
 *
 *	@mfunc
 *		Move caret position to specified coordinates in Text Host window. 
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CTxtWinHost::TxSetCaretPos(
	INT x, 				//@parm	Horizontal position (in client coordinates)
	INT y)				//@parm	Vertical position (in client coordinates)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCaretPos");

	return ::SetCaretPos(x, y);
}

/* 
 *	CTxtWinHost::TxSetTimer (idTimer, uTimeout)
 *
 *	@mfunc
 *		Request Text Host to creates a timer with specified time out.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 */
BOOL CTxtWinHost::TxSetTimer(
	UINT idTimer, 		//@parm Timer identifier	
	UINT uTimeout)		//@parm	Timeout in msec
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetTimer");

	Assert(_hwnd);	
	return ::SetTimer(_hwnd, idTimer, uTimeout, NULL);
}

/* 
 *	CTxtWinHost::TxKillTimer (idTimer)
 *
 *	@mfunc
 *		Destroy specified timer
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This method may be called at any time irrespective of active versus
 *		inactive state.
 */
void CTxtWinHost::TxKillTimer(
	UINT idTimer)		//@parm	id of timer
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxKillTimer");

	Assert(_hwnd);			
	::KillTimer(_hwnd, idTimer);
}

/* 
 *	CTxtWinHost::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *									lprcUpdate, fuScroll)
 *	@mfunc
 *		Request Text Host to scroll the content of the specified client area
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtWinHost::TxScrollWindowEx (
	INT		dx, 			//@parm	Amount of horizontal scrolling
	INT		dy, 			//@parm	Amount of vertical scrolling
	LPCRECT lprcScroll, 	//@parm	Scroll rectangle
	LPCRECT lprcClip,		//@parm	Clip rectangle
	HRGN	hrgnUpdate, 	//@parm	Handle of update region
	LPRECT	lprcUpdate,		//@parm	Update rectangle
	UINT	fuScroll)		//@parm	Scrolling flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxScrollWindowEx");

	Assert(_hwnd);
	::ScrollWindowEx(_hwnd, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate, fuScroll);
}

/* 
 *	CTxtWinHost::TxSetCapture (fCapture)
 *
 *	@mfunc
 *		Set mouse capture in Text Host's window.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may do nothing.
 */
void CTxtWinHost::TxSetCapture(
	BOOL fCapture)		//@parm	Whether to get or release capture
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCapture");

	Assert(_hwnd);
	if (fCapture)
		::SetCapture(_hwnd);
	else
		::ReleaseCapture();
}

/* 
 *	CTxtWinHost::TxSetFocus ()
 *
 *	@mfunc
 *		Set focus in text host window.
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
void CTxtWinHost::TxSetFocus()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetFocus");

	Assert(_hwnd);
	::SetFocus(_hwnd);
}

/* 
 *	CTxtWinHost::TxSetCursor (hcur, fText)
 *
 *	@mfunc
 *		Establish a new cursor shape in the Text Host's window.
 *
 *	@comm
 *		This method may be called at any time, irrespective of 
 *		active vs. inactive state.
 *
 *		ITextHost::TxSetCursor should be called back by the Text Services 
 *		to actually set the mouse cursor. If the fText parameter is TRUE, 
 *		Text Services is trying to set the "text" cursor (cursor over text 
 *		that is not selected, currently an IBEAM). In that case, the host 
 *		can set it to whatever the control MousePointer property is. This is 
 *		required by VB compatibility since, via the MousePointer property, 
 *		the VB programmer has control over the shape of the mouse cursor, 
 *		whenever it would normally be set to an IBEAM.
 */
void CTxtWinHost::TxSetCursor(
	HCURSOR hcur,		//@parm	Handle to cursor
	BOOL	fText)		//@parm Indicates caller wants to set text cursor
						//		(IBeam) if true.
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxSetCursor");

	::SetCursor(hcur);
}

/* 
 *	CTxtWinHost::TxScreenToClient (lppt)
 *
 *	@mfunc
 *		Convert screen coordinates to Text Host window coordinates.
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 */
BOOL CTxtWinHost::TxScreenToClient(
	LPPOINT lppt)		//@parm	Coordinates for point
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxScreenToClient");

	Assert(_hwnd);
	return ::ScreenToClient(_hwnd, lppt);	
}

/* 
 *	CTxtWinHost::TxClientToScreen (lppt)
 *
 *	@mfunc
 *		Convert Text Host coordinates to screen coordinates 
 *
 *	@rdesc	
 *		TRUE - call succeeded <nl>
 *		FALSE - call failed <nl>
 *
 *	@comm
 *		This call is valid at any time, although it is allowed to
 *		fail.  In general, if text services has coordinates it needs
 *		to translate from client coordinates (e.g. for TOM's 
 *		PointFromRange method) the text services will actually be 
 *		visible.
 *
 *		However, if no conversion is possible, then the method will fail.
 */
BOOL CTxtWinHost::TxClientToScreen(
	LPPOINT lppt)		//@parm	Client coordinates to convert.
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxClientToScreen");

	Assert(_hwnd);
	return ::ClientToScreen(_hwnd, lppt);
}

/* 
 *	CTxtWinHost::TxActivate (plOldState)
 *
 *	@mfunc
 *		Notify Text Host that control is active
 *
 *	@rdesc	
 *		S_OK 	- call succeeded. <nl>
 *		E_FAIL	- activation is not possible at this time
 *
 *	@comm
 *		It is legal for the host to refuse an activation request;
 *		the control may be minimized and thus invisible, for instance.
 *
 *		The caller should be able to gracefully handle failure to activate.
 *
 *		Calling this method more than once does not cumulate; only
 *		once TxDeactivate call is necessary to deactive.
 *
 *		This function returns an opaque handle in <p plOldState>. The caller
 *		(Text Services) should hang onto this handle and return it in a
 *		subsequent call to TxDeactivate.
 */
HRESULT CTxtWinHost::TxActivate(
	LONG *plOldState)	//@parm Where to put previous activation state
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxActivate");

	return S_OK;
}

/* 
 *	CTxtWinHost::TxDeactivate (lNewState)
 *
 *	@mfunc
 *		Notify Text Host that control is now inactive
 *
 *	@rdesc	
 *		S_OK - call succeeded. <nl>
 *		E_FAIL				   <nl>
 *
 *	@comm
 *		Calling this method more than once does not cumulate
 */
HRESULT CTxtWinHost::TxDeactivate(
	LONG lNewState)		//@parm	New state (typically value returned by
						//		TxActivate
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxDeactivate");

	return S_OK;
}
	
/* 
 *	CTxtWinHost::TxGetClientRect (prc)
 *
 *	@mfunc
 *		Retrieve client coordinates of Text Host's client area.
 *
 *	@rdesc
 *		HRESULT = (success) ? S_OK : E_FAIL
 */
HRESULT CTxtWinHost::TxGetClientRect(
	LPRECT prc)		//@parm	Where to put client coordinates
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetClientRect");

	Assert(_hwnd && prc);
	return ::GetClientRect(_hwnd, prc) ? S_OK : E_FAIL;
}

/* 
 *	CTxtWinHost::TxGetViewInset	(prc)
 *
 *	@mfunc
 *		Get inset for Text Host window.  Inset is the "white space"
 *		around text.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		The Inset rectangle is not strictly a rectangle.  The top, bottom,
 *		left, and right fields of the rect structure indicate how far in
 *		each direction drawing should be inset. Inset sizes are in client
 *		coordinates.
 */
HRESULT CTxtWinHost::TxGetViewInset(
	LPRECT prc)			//@parm Where to put inset rectangle	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetViewInset");

	Assert(prc);

	*prc = _rcViewInset;
	return NOERROR;	
}

/* 
 *	CTxtWinHost::TxGetCharFormat (ppCF)
 *
 *	@mfunc
 *		Get Text Host's default character format
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL (not needed in simple Windows host, since text
 *		services provides desired default)
 *
 *	@comm
 *		The callee retains ownwership of the charformat returned.  However,
 *		the pointer returned must remain valid until the callee notifies
 *		Text Services via OnTxPropertyBitsChange that the default character
 *		format has changed.
 */
HRESULT CTxtWinHost::TxGetCharFormat(
	const CHARFORMAT **ppCF) 		//@parm	Where to put ptr to default
									//		character format
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetCharFormat");

	return E_NOTIMPL;
}

/* 
 *	CTxtWinHost::TxGetParaFormat (ppPF)
 *
 *	@mfunc
 *		Get Text Host default paragraph format
 *
 *	@rdesc
 *		HRESULT = E_NOTIMPL (not needed in simple Windows host, since text
 *		services provides desired default)
 *
 *	@comm
 *		The host object (callee) retains ownership of the PARAFORMAT returned.
 *		However, the pointer returned must remain valid until the host notifies
 *		Text Services (the caller) via OnTxPropertyBitsChange that the default
 *		paragraph format has changed.
 */
HRESULT CTxtWinHost::TxGetParaFormat(
	const PARAFORMAT **ppPF) 	//@parm Where to put ptr to default
								//		paragraph format
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetParaFormat");

	return E_NOTIMPL;
}

/* 
 *	CTxtWinHost::TxGetSysColor (nIndex)
 *
 *	@mfunc
 *		Get specified color identifer from Text Host.
 *
 *	@rdesc
 *		Color identifier
 *
 *	@comm
 *		Note that the color returned may be *different* than the
 *		color that would be returned from a call to GetSysColor.
 *		This allows hosts to override default system behavior.
 *
 *		Needless to say, hosts should be very careful about overriding
 *		normal system behavior as it could result in inconsistent UI
 *		(particularly with respect to Accessibility	options).
 */
COLORREF CTxtWinHost::TxGetSysColor(
	int nIndex)			//@parm Color to get, same parameter as
						//		GetSysColor Win32 API
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetSysColor");

	if (!_fDisabled ||
		nIndex != COLOR_WINDOW && nIndex != COLOR_WINDOWTEXT)
	{
		// This window is not disabled or the color is not interesting
		// in the disabled case.
		return (nIndex == COLOR_WINDOW && _fNotSysBkgnd)
			? _crBackground : GetSysColor(nIndex);
	}

	// Disabled case
	if (COLOR_WINDOWTEXT == nIndex)
	{
		// Color of text for disabled window
		return GetSysColor(COLOR_GRAYTEXT);
	}

	// Background color for disabled window
	return GetSysColor(COLOR_3DFACE);
	
}

/* 
 *	CTxtWinHost::TxGetBackStyle	(pstyle)
 *
 *	@mfunc
 *		Get Text Host background style.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@xref	<e TXTBACKSTYLE>
 */
HRESULT CTxtWinHost::TxGetBackStyle(
	TXTBACKSTYLE *pstyle)  //@parm Where to put background style
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetBackStyle");

	*pstyle = (_dwExStyle & WS_EX_TRANSPARENT)
			? TXTBACK_TRANSPARENT : TXTBACK_OPAQUE;
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxGetMaxLength	(pLength)
 *
 *	@mfunc
 *		Get Text Host's maximum allowed length.
 *
 *	@rdesc
 *		HRESULT = S_OK	
 *
 *	@comm
 *		This method parallels the EM_LIMITTEXT message.
 *		If INFINITE (0xFFFFFFFF) is returned, then text services
 *		will use as much memory as needed to store any given text.
 *
 *		If the limit returned is less than the number of characters
 *		currently in the text engine, no data is lost.  Instead,
 *		no edits will be allowed to the text *other* than deletion
 *		until the text is reduced to below the limit.
 */
HRESULT CTxtWinHost::TxGetMaxLength(
	DWORD *pLength) 	//@parm Maximum allowed length, in number of 
						//		characters
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetMaxLength");
	AssertSz(FALSE, "CTxtWinHost::TxGetMaxLength why is this being called?");
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxGetScrollBars (pdwScrollBar)
 *
 *	@mfunc
 *		Get Text Host's scroll bars supported.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@comm
 *		<p pdwScrollBar> is filled with a boolean combination of the 
 *		window styles related to scroll bars.  Specifically, these are:
 *
 *			WS_VSCROLL	<nl>
 *			WS_HSCROLL	<nl>
 *			ES_AUTOVSCROLL	<nl>
 *			ES_AUTOHSCROLL	<nl>
 *			ES_DISABLENOSCROLL	<nl>
 */
HRESULT CTxtWinHost::TxGetScrollBars(
	DWORD *pdwScrollBar) 	//@parm Where to put scrollbar information
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetScrollBars");

	*pdwScrollBar =  _dwStyle & (WS_VSCROLL | WS_HSCROLL | ES_AUTOVSCROLL | 
						ES_AUTOHSCROLL | ES_DISABLENOSCROLL);
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxGetPasswordChar (pch)
 *
 *	@mfunc
 *		Get Text Host's password character.
 *
 *	@rdesc
 *		HRESULT = (password character not enabled) ? S_FALSE : S_OK
 *
 *	@comm
 *		The password char will only be shown if the TXTBIT_USEPASSWORD bit
 *		is enabled in TextServices.  If the password character changes,
 *		re-enable the TXTBIT_USEPASSWORD bit via 
 *		ITextServices::OnTxPropertyBitsChange.
 */
HRESULT CTxtWinHost::TxGetPasswordChar(
	TCHAR *pch)		//@parm Where to put password character
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetPasswordChar");

	*pch = _chPassword;
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxGetAcceleratorPos (pcp)
 *
 *	@mfunc
 *		Get special character to use for underlining accelerator character.
 *
 *	@rdesc
 *		Via <p pcp>, returns character position at which underlining 
 *		should occur.  -1 indicates that no character should be underlined. 
 *		Return value is an HRESULT (usually S_OK).
 *
 *	@comm
 *		Accelerators allow keyboard shortcuts to various UI elements (like
 *		buttons.  Typically, the shortcut character is underlined.
 *
 *		This function tells Text Services which character is the accelerator
 *		and thus should be underlined.  Note that Text Services will *not*
 *		process accelerators; that is the responsiblity of the host.
 *
 *		This method will typically only be called if the TXTBIT_SHOWACCELERATOR
 *		bit is set in text services.  
 *
 *		Note that *any* change to the text in text services will result in the
 *		invalidation of the accelerator underlining.  In this case, it is the 
 *		host's responsibility to recompute the appropriate character position 
 *		and inform text services that a new accelerator is available.
 */
HRESULT CTxtWinHost::TxGetAcceleratorPos(
	LONG *pcp) 		//@parm Out parm to receive cp of character to underline
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetAcceleratorPos");

	*pcp = -1;
	return S_OK;
} 										   

/* 
 *	CTxtWinHost::OnTxCharFormatChange
 *
 *	@mfunc
 *		Set default character format for the Text Host.
 *
 *	@rdesc
 *		S_OK - call succeeded.	<nl>
 *		E_INVALIDARG			<nl>
 *		E_FAIL					<nl>
 */
HRESULT CTxtWinHost::OnTxCharFormatChange(
	const CHARFORMAT *pcf) //@parm New default character format	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::OnTxCharFormatChange");

	return S_OK;
}

/* 
 *	CTxtWinHost::OnTxParaFormatChange
 *
 *	@mfunc
 *		Set default paragraph format for the Text Host.
 *
 *	@rdesc
 *		S_OK - call succeeded.	<nl>
 *		E_INVALIDARG			<nl>
 *		E_FAIL					<nl>
 */
HRESULT CTxtWinHost::OnTxParaFormatChange(
	const PARAFORMAT *ppf) //@parm New default paragraph format	
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::OnTxParaFormatChange");

	return S_OK;
}

/* 
 *	CTxtWinHost::TxGetPropertyBits (dwMask, dwBits)
 *
 *	@mfunc
 *		Get the bit property settings for Text Host.
 *
 *	@rdesc
 *		S_OK
 *
 *	@comm
 *		This call is valid at any time, for any combination of
 *		requested property bits.  <p dwMask> may be used by the
 *		caller to request specific properties.	
 */
HRESULT CTxtWinHost::TxGetPropertyBits(
	DWORD dwMask,		//@parm	Mask of bit properties to get
	DWORD *pdwBits)		//@parm Where to put bit values
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetPropertyBits");

// FUTURE: Obvious optimization is to save bits in host the same way that
// they are returned and just return them instead of this mess.

	// Note: this RichEdit host never sets TXTBIT_SHOWACCELERATOR or
	// TXTBIT_SAVESELECTION. They are currently only used by Forms^3 host.
	// This host is always rich text.

	DWORD dwProperties = TXTBIT_RICHTEXT | TXTBIT_ALLOWBEEP;

#ifdef DEBUG
	// make sure that TS doesn't think it's plain text mode when
	// we return TXTBIT_RICHTEXT
	if((dwMask & TXTBIT_RICHTEXT) && _pserv)
	{
		DWORD mode;
		mode = _pserv->TxSendMessage(EM_GETTEXTMODE, 0, 0, NULL);
		Assert(mode == TM_RICHTEXT);
	}
#endif // DEBUG

	if(_dwStyle & ES_MULTILINE)
		dwProperties |= TXTBIT_MULTILINE;

	if(_dwStyle & ES_READONLY)
		dwProperties |= TXTBIT_READONLY;

	if(_dwStyle & ES_PASSWORD)
		dwProperties |= TXTBIT_USEPASSWORD;

	if(!(_dwStyle & ES_NOHIDESEL))
		dwProperties |= TXTBIT_HIDESELECTION;

	if(_fEnableAutoWordSel)
		dwProperties |= TXTBIT_AUTOWORDSEL;

	if(!(_dwStyle & ES_AUTOHSCROLL))
		dwProperties |= TXTBIT_WORDWRAP;

	if(_dwStyle & ES_VERTICAL)
		dwProperties |= TXTBIT_VERTICAL;

	if(_dwStyle & ES_NOOLEDRAGDROP) 
		dwProperties |= TXTBIT_DISABLEDRAG;

	*pdwBits = dwProperties & dwMask; 
	return NOERROR;
}

/* 
 *	CTxtWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  Direct events are sent immediately as
 *		they need some processing: EN_PROTECTED is a canonical
 *		example.  Delayed events are sent after all processing
 *		has occurred; the control is thus in a "stable" state.
 *		EN_CHANGE, EN_ERRSPACE, EN_SELCHANGED are examples
 *		of delayed notifications.
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		The notification events are the same as the notification
 *		messages sent to the parent window of a richedit window.
 *		The firing of events may be controlled with a mask set via
 *		the EM_SETEVENTMASK message.
 *
 *		In general, is legal to make any calls to text services while
 *		processing this method; however, implementors are cautioned
 *		to avoid excessive recursion. 
 *
 *		Here is the complete list of notifications that may be
 *		sent and a brief description of each:
 *
 *		<p EN_CHANGE>		Sent when some data in the edit control
 *		changes (such as text or formatting).  Controlled by the
 *		ENM_CHANGE event mask.  This notification is sent _after_
 *		any screen updates have been requested. 
 *
 *		<p EN_CORRECTTEXT>	PenWin only; currently unused.
 *
 *		<p EN_DROPFILES>	If the client registered the edit
 *		control via DragAcceptFiles, this event will be sent when
 *		a WM_DROPFILES or DragEnter(CF_HDROP) message is received.
 *		If S_FALSE is returned, the drop will be ignored, otherwise,
 *		the drop will be processed.  The ENM_DROPFILES mask
 *		controls this event notification.
 *
 *		<p EN_ERRSPACE>		Sent when the edit control cannot
 *		allocate enough memory.  No additional data is sent and
 *		there is no mask for this event.
 *
 *		<p EN_HSCROLL>		Sent when the user clicks on an edit
 *		control's horizontal scroll bar, but before the screen
 *		is updated.  No additional data is sent.  The ENM_SCROLL
 *		mask controls this event.
 *
 *		<p EN_IMECHANGE>	unused
 *
 *		<p EN_KILLFOCUS>	Sent when the edit control looses focus.
 *		No additional data is sent and there is no mask.
 *
 *		<p EN_MAXTEXT>	Sent when the current text insertion
 *		has exceeded the specified number of characters for the
 *		edit control.  The text insertion has been truncated.  
 *		There is no mask for this event.
 *
 *		<p EN_MSGFILTER>	NB!!! THIS MESSAGE IS NOT SENT TO
 *		TxNotify, but is included here for completeness.  With
 *		ITextServices::TxSendMessage, client have complete
 *		flexibility in filtering all window messages.
 *	
 *		Sent on a keyboard or mouse event
 *		in the control.  A MSGFILTER data structure is sent, 
 *		containing the msg, wparam and lparam.  If S_FALSE is
 *		returned from this notification, the msg is processed by
 *		TextServices, otherwise, the message is ignored.  Note
 *		that in this case, the callee has the opportunity to modify
 *		the msg, wparam, and lparam before TextServices continues
 *		processing.  The ENM_KEYEVENTS and ENM_MOUSEEVENTS masks
 *		control this event for the respective event types.
 *
 *		<p EN_OLEOPFAILED> 	Sent when an OLE call fails.  The
 *		ENOLEOPFAILED struct is passed with the index of the object
 *		and the error code.  Mask value is nothing.
 *		
 *		<p EN_PROTECTED>	Sent when the user is taking an
 *		action that would change a protected range of text.  An
 *		ENPROTECTED data structure is sent, indicating the range
 *		of text affected and the window message (if any) affecting
 *		the change.  If S_FALSE is returned, the edit will fail.
 *		The ENM_PROTECTED mask controls this event.
 *
 *		<p EN_REQUESTRESIZE>	Sent when a control's contents are
 *		either smaller or larger than the control's window size.
 *		The client is responsible for resizing the control.  A
 *		REQRESIZE structure is sent, indicating the new size of
 *		the control.  NB!  Only the size is indicated in this
 *		structure; it is the host's responsibility to do any 
 *		translation necessary to generate a new client rectangle.
 *		The ENM_REQUESTRESIZE mask controls this event.
 *
 *		<p EN_SAVECLIPBOARD> Sent when an edit control is being
 *		destroyed, the callee should indicate whether or not 
 *		OleFlushClipboard should be called.  Data indicating the
 *		number of characters and objects to be flushed is sent
 *		in the ENSAVECLIPBOARD data structure.
 *		Mask value is nothing.
 *
 *		<p EN_SELCHANGE>	Sent when the current selection has
 *		changed.  A SELCHANGE data structure is also sent, which
 *		indicates the new selection range at the type of data
 *		the selection is currently over.  Controlled via the
 *		ENM_SELCHANGE mask.
 *
 *		<p EN_SETFOCUS>	Sent when the edit control receives the
 *		keyboard focus.  No extra data is sent; there is no mask.
 *
 *		<p EN_STOPNOUNDO>	Sent when an action occurs for which
 *		the control cannot allocate enough memory to maintain the
 *		undo state.  If S_FALSE is returned, the action will be
 *		stopped; otherwise, the action will continue.
 *
 *		<p EN_UPDATE>	Sent before an edit control requests a
 *		redraw of altered data or text.  No additional data is
 *		sent.  This event is controlled via the ENM_UPDATE mask.
 *
 *		<p EN_VSCROLL>	Sent when the user clicks an edit control's
 *		vertical scrollbar bar before the screen is updated.
 *		Controlled via the ENM_SCROLL mask; no extra data is sent.
 *
 *		<p EN_LINK>		Sent when a mouse event (or WM_SETCURSOR) happens
 *		over a range of text that has the EN_LINK mask bit set.
 *		An ENLINK data structure will be sent with relevant info.
 */
HRESULT CTxtWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxNotify");

	HRESULT		hr = NOERROR;
	LONG		nId;
	NMHDR *		phdr;
	REQRESIZE *	preq;
	RECT		rcOld;

	// We assume here that TextServices has already masked out notifications,
	// so if we get one here, it should be sent
	if(_hwndParent)
	{
		nId = GetWindowLong(_hwnd, GWL_ID);
		// First, handle WM_NOTIFY style notifications
		switch(iNotify)
		{
		case EN_REQUESTRESIZE:
			// Need to map new size into correct rectangle
			Assert(pv);
			GetWindowRect(_hwnd, &rcOld);
			MapWindowPoints(HWND_DESKTOP, _hwndParent, (POINT *) &rcOld, 2);
			
			preq = (REQRESIZE *)pv;
			preq->rc.top	= rcOld.top;
			preq->rc.left	= rcOld.left;
			preq->rc.right	+= rcOld.left;
			preq->rc.bottom += rcOld.top;

			// FALL-THROUGH!!
					
		case EN_DROPFILES:
		case EN_MSGFILTER:
		case EN_OLEOPFAILED:
		case EN_PROTECTED:
		case EN_SAVECLIPBOARD:
		case EN_SELCHANGE:
		case EN_STOPNOUNDO:
		case EN_LINK:
		case EN_OBJECTPOSITIONS:
		case EN_DRAGDROPDONE:
		case EN_LOWFIRTF:
		case EN_CLIPFORMAT:
	
			if(pv)						// Fill out NMHDR portion of pv
			{
				phdr = (NMHDR *)pv;
  				phdr->hwndFrom = _hwnd;
				phdr->idFrom = nId;
				phdr->code = iNotify;
			}

			if(SendMessage(_hwndParent, WM_NOTIFY, (WPARAM) nId, (LPARAM) pv))
				hr = S_FALSE;
			break;

		default:
			SendMessage(_hwndParent, WM_COMMAND, 
					GET_WM_COMMAND_MPS(nId, _hwnd, iNotify));
		}
	}

	return hr;
}

/*
 *	CTxtWinHost::TxGetExtent (lpExtent)
 *
 *	@mfunc
 *		Return native size of the control in HIMETRIC
 *
 *	@rdesc
 *		S_OK	<nl>
 *		some failure code <nl>
 *
 *	@comm
 *		This method is used by Text Services to implement zooming.
 *		Text Services would derive the zoom factor from the ratio between 
 *		the himetric and device pixel extent of the client rectangle.
 *	
 *		[vertical zoom factor] = [pixel height of the client rect] * 2540
 *		/ [himetric vertical extent] * [pixel per vertical inch (from DC)]
 *	
 *		If the vertical and horizontal zoom factors are not the same, Text 
 *		Services could ignore the horizontal zoom factor and assume it is 
 *		the same as the vertical one.
 */
HRESULT CTxtWinHost::TxGetExtent(
	LPSIZEL lpExtent) 	//@parm  Extent in himetric
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::TxGetExtent");

	AssertSz(lpExtent, "CTxtWinHost::TxGetExtent Invalid lpExtent");

	// We could implement the TxGetExtent in the following way. However, the
	// call to this in ITextServices is implemented in such a way that it 
	// does something sensible in the face of an error in this call. That 
	// something sensible is that it sets the extent equal to the current
	// client rectangle which is what the following does in a rather convoluted
	// manner. Therefore, we dump the following and just return an error.


#if 0
	// The window's host extent is always the same as the client
	// rectangle.
	RECT rc;
	HRESULT hr = TxGetClientRect(&rc);

	// Get our client rectangle
	if(SUCCEEDED(hr))
	{
		// Calculate the length & convert to himetric
		lpExtent->cx = DXtoHimetricX(rc.right - rc.left, W32->GetXPerInchScreenDC());
		lpExtent->cy = DYtoHimetricY(rc.bottom - rc.top, W32->GetYPerInchScreenDC());
	}

	return hr;
#endif // 0

	return E_NOTIMPL;
}

 HRESULT CTxtWinHost::TxEBookLoadImage( LPWSTR lpszName, LPARAM * pID, SIZE * psize, DWORD *pdwFlags)  
{
    return E_NOTIMPL;
}

HRESULT CTxtWinHost::TxEBookImageDraw(LPARAM ID, HDC hdc, POINT *topLeft, RECT  *prcRenderint,
                                BOOL fSelected)
{
    return E_NOTIMPL;
}

HRESULT CTxtWinHost::TxGetHorzExtent(LONG *plHorzExtent)
{
    return E_NOTIMPL;
}

/*
 *	CTxtWinHost::TxGetSelectionBarWidth (lSelBarWidth)
 *
 *	@mfunc
 *		Returns size of selection bar in HIMETRIC
 *
 *	@rdesc
 *		S_OK	<nl>
 */
HRESULT	CTxtWinHost::TxGetSelectionBarWidth (
	LONG *lSelBarWidth)		//@parm  Where to return selection bar width 
							// in HIMETRIC
{
	*lSelBarWidth = (_dwStyle & ES_SELECTIONBAR) ? W32->GetDxSelBar() : 0;
	return S_OK;
}

//
//	ITextHost2 methods
//

/*
 *	CTxtWinHost::TxIsDoubleClickPending
 *
 *	@mfunc	Look into the message queue for this hwnd and see if a
 *			double click is pending.  This enables TextServices to 
 *			effeciently transition between two inplace active objects.
 *
 *	@rdesc	BOOL
 */
BOOL CTxtWinHost::TxIsDoubleClickPending()
{
	MSG msg;

	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, 
			"CTxtWinHost::TxIsDoubleClickPending");

	if(PeekMessage(&msg, _hwnd, WM_LBUTTONDBLCLK, WM_LBUTTONDBLCLK,
			PM_NOREMOVE | PM_NOYIELD))
	{
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtWinHost::TxGetWindow
 *
 *	@mfunc	Fetches the window associated with this control (or
 *			set of controls potentially).  Useful for answering 
 *			IOleWindow::GetWindow.
 *
 *	@rdesc	HRESULT
 */
HRESULT CTxtWinHost::TxGetWindow(HWND *phwnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CTxtWinHost::GetWindow");
	
	*phwnd = _hwnd;
	return NOERROR;
}	


/*
 *	CTxtWinHost::SetForegroundWindow
 *
 *	@mfunc	Sets window to foreground window & gives the focus
 *
 *	@rdesc	NOERROR - succeeded
 *			E_FAIL - failed.
 */
HRESULT CTxtWinHost::TxSetForegroundWindow()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, 
		"CTxtWinHost::SetForegroundWindow");

	if(!SetForegroundWindow(_hwnd))
		SetFocus(_hwnd);

	return NOERROR;
}	


/*
 *	CTxtWinHost::TxGetPalette
 *
 *	@mfunc	Returns application specific palette if there is one
 *
 *	@rdesc	~NULL - there was one
 *			NULL - use default palette
 */
HPALETTE CTxtWinHost::TxGetPalette()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, 
		"CTxtWinHost::TxGetPalette");

	return _hpal;
}	


/*
 *	CTxtWinHost::TxGetFEFlags
 *
 *	@mfunc	return FE settings
 *
 *	@rdesc	NOERROR - succeeded
 *			E_FAIL - failed.
 */
HRESULT CTxtWinHost::TxGetFEFlags(LONG *pFEFlags)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, 
		"CTxtWinHost::TxGetFEFlags");

	if (!pFEFlags)
		return E_INVALIDARG;
	*pFEFlags = 0;

	if (_usIMEMode == ES_NOIME)
		*pFEFlags |= ES_NOIME;
	if (_usIMEMode == ES_SELFIME)
		*pFEFlags |= ES_SELFIME;

	return NOERROR;
}


// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);


/*
 *	CTxtWinHost::OnSetMargins
 *
 *	@mfunc	Handle EM_SETMARGINS message
 *
 *	@rdesc	None.
 */
void CTxtWinHost::OnSetMargins(
	DWORD fwMargin,		//@parm Type of requested operation
	DWORD xLeft,		//@parm Where to put left margin
	DWORD xRight)		//@parm Where to put right margin
{
	LONG xLeftMargin = -1;
	LONG xRightMargin = -1;
	HDC hdc;

	if(EC_USEFONTINFO == fwMargin)
	{
		// Get the DC since it is needed for the call
		hdc = GetDC(_hwnd);

		// Multiline behaves differently than single line
		if (_dwStyle & ES_MULTILINE)
		{
			// Multiline - over/underhange controls margin
			GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), NULL, 
				&xLeftMargin, &xRightMargin);
		}
		else
		{
			// Single line edit controls set the margins to 
			// the average character width on both left and
			// right.
			GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), &xLeftMargin, NULL, NULL);

			xRightMargin = xLeftMargin;
		}
		ReleaseDC(_hwnd, hdc);
	}
	else
	{
		// The request is for setting exact pixels.
		if(EC_LEFTMARGIN & fwMargin)
			xLeftMargin = xLeft;

		if(EC_RIGHTMARGIN & fwMargin)
			xRightMargin = xRight;
	}

	// Set left margin if so requested
	if (xLeftMargin != -1)
		_rcViewInset.left =	W32->DeviceToHimetric(xLeftMargin, W32->GetXPerInchScreenDC());

	// Set right margin if so requested
	if (xRightMargin != -1)
		_rcViewInset.right = W32->DeviceToHimetric(xRightMargin, W32->GetXPerInchScreenDC());

	if (xLeftMargin != -1 || xRightMargin != -1)
		_pserv->OnTxPropertyBitsChange(TXTBIT_VIEWINSETCHANGE, TXTBIT_VIEWINSETCHANGE);
}

/*
 *	CTxtWinHost::SetScrollInfo
 *
 *	@mfunc	Set scrolling information for the scroll bar.
 */
void CTxtWinHost::SetScrollInfo(
	INT fnBar,			//@parm	Specifies scroll bar to be updated
	BOOL fRedraw)		//@parm whether redraw is necessary
{
	// Set up the basic structure for the call
	SCROLLINFO si;
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_ALL;

	AssertSz(_pserv != NULL, 
		"CTxtWinHost::SetScrollInfo called with NULL _pserv");

	// Call back to the control to get the parameters
	if(fnBar == SB_HORZ)
	{
		_pserv->TxGetHScroll((LONG *) &si.nMin, (LONG *) &si.nMax, 
			(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
	}
	else
	{
		_pserv->TxGetVScroll((LONG *) &si.nMin, 
			(LONG *) &si.nMax, (LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
	}

	// Do the call
	::SetScrollInfo(_hwnd, fnBar, &si, fRedraw);
}

/*
 *	CTxtWinHost::SetScrollBarsForWmEnable
 *
 *	@mfunc	Enable/Disable scroll bars
 *
 *	@rdesc	None.
 */
void CTxtWinHost::SetScrollBarsForWmEnable(
	BOOL fEnable)		//@parm Whether scrollbars s/b enabled or disabled.
{
	if(!_pserv)						// If no edit object,
		return;						//  no scrollbars

	BOOL fHoriz = FALSE;
	BOOL fVert = FALSE;
	UINT wArrows = fEnable ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH;

	_pserv->TxGetHScroll(NULL, NULL, NULL, NULL, &fHoriz);
	_pserv->TxGetVScroll(NULL, NULL, NULL, NULL, &fVert);

	if(fHoriz)						// There is a horizontal scroll bar
		W32->EnableScrollBar(_hwnd, SB_HORZ, wArrows);

	if(fVert)						// There is a vertical scroll bar
		W32->EnableScrollBar(_hwnd, SB_VERT, wArrows);
}

/*
 *	CTxtWinHost::SetScrollBarsForWmEnable
 *
 *	@mfunc	Notification that Text Services is released.
 *
 *	@rdesc	None.
 */
void CTxtWinHost::TxFreeTextServicesNotification()
{
	_fTextServiceFree = TRUE;
}

/*
 *	CTxtWinHost::TxGetEditStyle
 *
 *	@mfunc	Get Edit Style flags
 *
 *	@rdesc	NOERROR is data available.
 */
HRESULT CTxtWinHost::TxGetEditStyle(
	DWORD dwItem, 
	DWORD *pdwData)
{
	if (!pdwData)
		return E_INVALIDARG;
	
	*pdwData = 0;

	if (dwItem & TXES_ISDIALOG && _fInDialogBox)
		*pdwData |= TXES_ISDIALOG;

	return NOERROR;
}

/*
 *	CTxtWinHost::TxGetWindowStyles
 *
 *	@mfunc	Return window style bits
 *
 *	@rdesc	NOERROR is data available.
 */
HRESULT CTxtWinHost::TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle)
{
	if (!pdwStyle || !pdwExStyle)
		return E_INVALIDARG;

	*pdwStyle = _dwStyle;
	*pdwExStyle = _dwExStyle;

	return NOERROR;
}

#endif // NOWINDOWHOSTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\hwxink.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#define iverbInkRecog 351
#define iverbInkAlternates 352

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/


#ifndef __HWXInk_h__
#define __HWXInk_h__

#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITfRange_FWD_DEFINED__
#define __ITfRange_FWD_DEFINED__
typedef interface ITfRange ITfRange;
#endif 	/* __ITfRange_FWD_DEFINED__ */

#ifndef __IInk_FWD_DEFINED__
#define __IInk_FWD_DEFINED__
typedef interface IInk IInk;
#endif 	/* __IInk_FWD_DEFINED__ */


#ifndef __ILineInfo_FWD_DEFINED__
#define __ILineInfo_FWD_DEFINED__
typedef interface ILineInfo ILineInfo;
#endif 	/* __ILineInfo_FWD_DEFINED__ */

#ifndef __IThorFnConversion_FWD_DEFINED__
#define __IThorFnConversion_FWD_DEFINED__
typedef interface IThorFnConversion IThorFnConversion;
#endif 	/* __IThorFnConversion_FWD_DEFINED__ */

#ifndef __Ink_FWD_DEFINED__
#define __Ink_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ink Ink;
#else
typedef struct Ink Ink;
#endif /* __cplusplus */

#endif 	/* __Ink_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_HWXInk_0000 */
/* [local] */ 

typedef struct  tagINKMETRIC
    {
    UINT iHeight;
    UINT iFontAscent;
    UINT iFontDescent;
    UINT iWeight;
    BOOL fFontHDC;
    DWORD dwAmbientProps;
    COLORREF color;
    BOOL fItalic;
    UINT nItalicPitch;
    DWORD dwReserved;
    }	INKMETRIC;

typedef struct  tagSTROKEHEADER
    {
    UINT cByteCount;
    UINT cByteOffset;
    DWORD dwFlags;
    RECT rectBounds;
    }	STROKEHEADER;

typedef struct  tagSTROKE
    {
    UINT cPoints;
    BOOL fUpStroke;
    POINT __RPC_FAR *pPoints;
    UINT __RPC_FAR *pPressure;
    UINT __RPC_FAR *pTime;
    UINT __RPC_FAR *pAngle;
    }	STROKE;

typedef struct  tagSTROKELIST
    {
    UINT cStrokes;
    STROKE __RPC_FAR *pStrokes;
    }	STROKELIST;


enum __MIDL___MIDL_itf_HWXInk_0000_0001
    {	LOSSY	= 0x1,
	LOSSLESS	= 0x2,
	XYPOINTS	= 0x4,
	PRESSURE	= 0x8,
	TIME	= 0x10,
	ANGLE	= 0x20
    };


extern RPC_IF_HANDLE __MIDL_itf_HWXInk_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_HWXInk_0000_v0_0_s_ifspec;

#ifndef __IInk_INTERFACE_DEFINED__
#define __IInk_INTERFACE_DEFINED__

/* interface IInk */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IInk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03F8E511-43A1-11D3-8BB6-0080C7D6BAD5")
    IInk : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInk __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInk __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IInk __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IInk __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IInk __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IInk __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IInkVtbl;

    interface IInk
    {
        CONST_VTBL struct IInkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInk_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInk_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInk_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInk_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IInk_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IInk_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IInk_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInk_INTERFACE_DEFINED__ */


#ifndef __ILineInfo_INTERFACE_DEFINED__
#define __ILineInfo_INTERFACE_DEFINED__

/* interface ILineInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILineInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C1C5AD5-F22F-4DE4-B453-A2CC482E7C33")
    ILineInfo : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFormat( 
            INKMETRIC __RPC_FAR *pim) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFormat( 
            INKMETRIC __RPC_FAR *pim) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInkExtent( 
            INKMETRIC __RPC_FAR *pim,
            UINT __RPC_FAR *pnWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TopCandidates( 
            UINT nCandidateNum,
            BSTR __RPC_FAR *pbstrRecogWord,
            UINT __RPC_FAR *pcchRecogWord,
            LONG fAllowRecog,
            LONG fForceRecog) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recognize( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStroke( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStroke( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPoints( 
            UINT iStroke,
            STROKE __RPC_FAR *pStroke,
            BOOL fUpStroke,
            UINT nFrameHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILineInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILineInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILineInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILineInfo __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormat )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInkExtent )( 
            ILineInfo __RPC_FAR * This,
            INKMETRIC __RPC_FAR *pim,
            UINT __RPC_FAR *pnWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TopCandidates )( 
            ILineInfo __RPC_FAR * This,
            UINT nCandidateNum,
            BSTR __RPC_FAR *pbstrRecogWord,
            UINT __RPC_FAR *pcchRecogWord,
            LONG fAllowRecog,
            LONG fForceRecog);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Recognize )( 
            ILineInfo __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStroke )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStroke )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPoints )( 
            ILineInfo __RPC_FAR * This,
            UINT iStroke,
            STROKE __RPC_FAR *pStroke,
            BOOL fUpStroke,
            UINT nFrameHeight);
        
        END_INTERFACE
    } ILineInfoVtbl;

    interface ILineInfo
    {
        CONST_VTBL struct ILineInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILineInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILineInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILineInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILineInfo_SetFormat(This,pim)	\
    (This)->lpVtbl -> SetFormat(This,pim)

#define ILineInfo_GetFormat(This,pim)	\
    (This)->lpVtbl -> GetFormat(This,pim)

#define ILineInfo_GetInkExtent(This,pim,pnWidth)	\
    (This)->lpVtbl -> GetInkExtent(This,pim,pnWidth)

#define ILineInfo_TopCandidates(This,nCandidateNum,pbstrRecogWord,pcchRecogWord,fAllowRecog,fForceRecog)	\
    (This)->lpVtbl -> TopCandidates(This,nCandidateNum,pbstrRecogWord,pcchRecogWord,fAllowRecog,fForceRecog)

#define ILineInfo_Recognize(This)	\
    (This)->lpVtbl -> Recognize(This)

#define ILineInfo_SetStroke(This,iStroke,pStroke)	\
    (This)->lpVtbl -> SetStroke(This,iStroke,pStroke)

#define ILineInfo_GetStroke(This,iStroke,pStroke)	\
    (This)->lpVtbl -> GetStroke(This,iStroke,pStroke)

#define ILineInfo_AddPoints(This,iStroke,pStroke,fUpStroke,nFrameHeight)	\
    (This)->lpVtbl -> AddPoints(This,iStroke,pStroke,fUpStroke,nFrameHeight)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_SetFormat_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim);


void __RPC_STUB ILineInfo_SetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetFormat_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim);


void __RPC_STUB ILineInfo_GetFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetInkExtent_Proxy( 
    ILineInfo __RPC_FAR * This,
    INKMETRIC __RPC_FAR *pim,
    UINT __RPC_FAR *pnWidth);


void __RPC_STUB ILineInfo_GetInkExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_TopCandidates_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT nCandidateNum,
    BSTR __RPC_FAR *pbstrRecogWord,
    UINT __RPC_FAR *pcchRecogWord,
    LONG fAllowRecog,
    LONG fForceRecog);


void __RPC_STUB ILineInfo_TopCandidates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_Recognize_Proxy( 
    ILineInfo __RPC_FAR * This);


void __RPC_STUB ILineInfo_Recognize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_SetStroke_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke);


void __RPC_STUB ILineInfo_SetStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_GetStroke_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke);


void __RPC_STUB ILineInfo_GetStroke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILineInfo_AddPoints_Proxy( 
    ILineInfo __RPC_FAR * This,
    UINT iStroke,
    STROKE __RPC_FAR *pStroke,
    BOOL fUpStroke,
    UINT nFrameHeight);


void __RPC_STUB ILineInfo_AddPoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILineInfo_INTERFACE_DEFINED__ */

#ifndef __IThorFnConversion_INTERFACE_DEFINED__
#define __IThorFnConversion_INTERFACE_DEFINED__

/* interface IThorFnConversion */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IThorFnConversion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62130000-ED22-4015-B038-A04CD0866E69")
    IThorFnConversion : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange __RPC_FAR *pRange,
            /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
            /* [out] */ BOOL __RPC_FAR *pfConvertable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Convert( 
            /* [in] */ ITfRange __RPC_FAR *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThorFnConversionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IThorFnConversion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IThorFnConversion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayName )( 
            IThorFnConversion __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryRange )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ ITfRange __RPC_FAR *pRange,
            /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
            /* [out] */ BOOL __RPC_FAR *pfConvertable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Convert )( 
            IThorFnConversion __RPC_FAR * This,
            /* [in] */ ITfRange __RPC_FAR *pRange);
        
        END_INTERFACE
    } IThorFnConversionVtbl;

    interface IThorFnConversion
    {
        CONST_VTBL struct IThorFnConversionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThorFnConversion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IThorFnConversion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IThorFnConversion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IThorFnConversion_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define IThorFnConversion_QueryRange(This,pRange,ppNewRange,pfConvertable)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfConvertable)

#define IThorFnConversion_Convert(This,pRange)	\
    (This)->lpVtbl -> Convert(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IThorFnConversion_QueryRange_Proxy( 
    IThorFnConversion __RPC_FAR * This,
    /* [in] */ ITfRange __RPC_FAR *pRange,
    /* [unique][out][in] */ ITfRange __RPC_FAR *__RPC_FAR *ppNewRange,
    /* [out] */ BOOL __RPC_FAR *pfConvertable);


void __RPC_STUB IThorFnConversion_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThorFnConversion_Convert_Proxy( 
    IThorFnConversion __RPC_FAR * This,
    /* [in] */ ITfRange __RPC_FAR *pRange);


void __RPC_STUB IThorFnConversion_Convert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IThorFnConversion_INTERFACE_DEFINED__ */

#ifndef __HWXINKLib_LIBRARY_DEFINED__
#define __HWXINKLib_LIBRARY_DEFINED__

/* library HWXINKLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HWXINKLib;

EXTERN_C const CLSID CLSID_Ink;

#ifdef __cplusplus

class DECLSPEC_UUID("13DE4A42-8D21-4C8E-BF9C-8F69CB068FCA")
Ink;
#endif
#endif /* __HWXINKLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\hyph.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	HYPH.CPP -- Hyphenation class |
 *
 *	A table which holds the non-standard hyphenation cases. We store
 *	these entries in the table because we cache the results of hyphenation
 *	in our CLine structure, storing the actual WCHAR and khyph would cost
 *	4 bytes. With this mechanism we can use 5 bits.
 *
 *
 *	Several elements are reserved:
 *	0 - No hyphenation
 *	1 - Normal hyphenation
 *	2 - Delete before
 *
 *	All other ones contain a khyph and a WCHAR.
 *	If performance is an issue, this table could be sorted and binary
 *	searched. We assume this table typically has few entries in use.
 *	
 *	Owner:<nl>
 *		Keith Curtis:	Created
 * 
 *	Copyright (c) 1995-1999, Microsoft Corporation. All rights reserved.
 */
#include <_common.h>
#include <_array.h>
#include <_hyph.h>

const int chyphReserved = 3;

extern CHyphCache *g_phc;

void FreeHyphCache(void)
{
	delete g_phc;
}

/*
 *	CHyphCache::Add (khyph, chHyph)
 *
 *	@mfunc
 *		Adds a new special hyphenation entry to the cache
 *
 *	@rdesc
 *		ihyph to be used
 */
int CHyphCache::Add(UINT khyph, WCHAR chHyph)
{
	HYPHENTRY he;
	he.khyph = khyph;
	he.chHyph = chHyph;

	HYPHENTRY *phe;
	if (phe = CArray<HYPHENTRY>::Add(1, NULL))
	{
		*phe = he;
		return Count() + chyphReserved - 1;
	}
	return 1; //If we run out of memory, just do normal hyphenation
}

/*
 *	CHyphCache::Find(khyph, chHyph)
 *
 *	@mfunc
 *		Finds a special hyphenation entry in the cache.
 *		If it doesn't exist, then it will add it.
 *
 *	@rdesc
 *		index into table if successful, FALSE if failed
 */
int CHyphCache::Find(UINT khyph, WCHAR chHyph)
{
	HYPHENTRY *phe = Elem(0);

	//Special cases
	if (khyph <= khyphNormal)
		return khyph;
	if (khyph == khyphDeleteBefore)
		return 2;

	for (int ihyph = 0; ihyph < Count(); ihyph++, phe++)
	{
		if (chHyph == phe->chHyph && phe->khyph == khyph)
			return ihyph + chyphReserved;
	}

	//Not found, so add 
	return Add(khyph, chHyph);
}

/*
 *	CHyphCache::GetAt(iHyph, khyph, chHyph)
 *
 *	@mfunc
 *		Given an ihyph as stored in the CLine array, fill in
 *		the khyph and the chHyph
 *
 *	@rdesc
 *		void
 */
void CHyphCache::GetAt(int ihyph, UINT & khyph, WCHAR & chHyph)
{
	Assert(ihyph - chyphReserved < Count());

	//Special cases
	if (ihyph <= 2)
	{
		chHyph = 0;
		if (ihyph <= khyphNormal)
			khyph = ihyph;
		if (ihyph == 2)
			khyph = khyphDeleteBefore;
		return;
	}

	ihyph -= chyphReserved;
	HYPHENTRY *phe = Elem(ihyph);
	khyph = phe->khyph;
	chHyph = phe->chHyph;
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\iaccess.cpp ===
/*
 *	IACCESS.CPP 
 *
 *  Purpose:
 *      Implemenation of IAccessibility for listbox and combobox
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/04/99 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-2001 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_host.h"
#include "_cbhost.h"

#ifndef NOACCESSIBILITY

extern "C" LRESULT CALLBACK RichListBoxWndProc(HWND, UINT, WPARAM, LPARAM);

#define InitPv(pv)              *pv = NULL
#define InitPlong(plong)        *plong = 0
#define InitPvar(pvar)           pvar->vt = VT_EMPTY
#define ValidateFlags(flags, valid)         (!((flags) & ~(valid)))
#define InitAccLocation(px, py, pcx, pcy)   {InitPlong(px); InitPlong(py); InitPlong(pcx); InitPlong(pcy);}

#ifdef _WIN64
#define HwndFromHWNDID(lId)         (HWND)((DWORD_PTR)(lId) & ~0x80000000)
#else
#define HwndFromHWNDID(lId)         (HWND)((lId) & ~0x80000000)
#endif // _WIN64

// this is for ClickOnTheRect
typedef struct tagMOUSEINFO
{
    int MouseThresh1;
    int MouseThresh2;
    int MouseSpeed;
}
MOUSEINFO, FAR* LPMOUSEINFO;

#define IsHWNDID(lId)               ((lId) & 0x80000000)

//////////////////////// Accessibility Utility Functions ///////////////////////////

namespace MSAA
{

// --------------------------------------------------------------------------
//
//  InitTypeInfo()
//
//  This initializes our type info when we need it for IDispatch junk.
//
// --------------------------------------------------------------------------
HRESULT InitTypeInfo(ITypeInfo** ppiTypeInfo)
{
    Assert(ppiTypeInfo);

    if (*ppiTypeInfo)
        return S_OK;

    // Try getting the typelib from the registry
    ITypeLib    *piTypeLib;    
    HRESULT hr = LoadRegTypeLib(LIBID_Accessibility, 1, 0, 0, &piTypeLib);

    if (FAILED(hr))
        hr = LoadTypeLib(OLESTR("OLEACC.DLL"), &piTypeLib);

    if (SUCCEEDED(hr))
    {
        hr = piTypeLib->GetTypeInfoOfGuid(IID_IAccessible, ppiTypeInfo);
        piTypeLib->Release();

        if (!SUCCEEDED(hr))
            *ppiTypeInfo = NULL;
    }
    return(hr);
}


// --------------------------------------------------------------------------
//
//  ValidateChild()
//
// --------------------------------------------------------------------------
BOOL ValidateChild(VARIANT *pvar, int ctChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "ValidateChild");
    
    // Missing parameter, a la VBA
TryAgain:
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            W32->VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

        case VT_I4:
            if ((pvar->lVal < 0) || (pvar->lVal > ctChild))
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  ValidateSelFlags()
//
//  Validates selection flags.
// this makes sure the only bits set are in the valid range and that you don't
// have any invalid combinations.
// Invalid combinations are
// ADDSELECTION and REMOVESELECTION
// ADDSELECTION and TAKESELECTION
// REMOVESELECTION and TAKESELECTION
// EXTENDSELECTION and TAKESELECTION
//
// --------------------------------------------------------------------------
BOOL ValidateSelFlags(long flags)
{
    if (!ValidateFlags((flags), SELFLAG_VALID))
        return (FALSE);

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_REMOVESELECTION))
        return FALSE;

    if ((flags & SELFLAG_ADDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_REMOVESELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    if ((flags & SELFLAG_EXTENDSELECTION) && 
        (flags & SELFLAG_TAKESELECTION))
        return FALSE;

    return TRUE;
}

// --------------------------------------------------------------------------
//
//  GetStringResource(UINT id, WCHAR* psz, int nSize)
//
//  Gets the string resource for a given id and puts it in the passed buffer
//
// --------------------------------------------------------------------------
HRESULT GetStringResource(UINT id, BSTR* pbstr)
{
    
    WCHAR sz[MAX_PATH] = L"\0";

    if (!pbstr)
        return S_FALSE;

/*     
    // UNDONE:
    //  Need a workaround for this localization issue

    if (Win9x())
    {
        if (!LoadStringA(hinstResDll, id, sz, MAX_PATH))
            return(E_OUTOFMEMORY);

        // On Win9x we get ansi so convert it
        int cchUText = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)sz, -1, NULL, 0) + 1;
        *pbstr = SysAllocStringLen(NULL, cchUText);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)psz, -1, *pbstr, cchUText);
    }
    else
    {
        if (!LoadStringW(hinstResDll, id, sz, MAX_PATH))
            return(E_OUTOFMEMORY);    
        *pbstr = SysAllocString(sz);
    }
*/

#define STR_DOUBLE_CLICK            1
#define STR_DROPDOWN_HIDE           2
#define STR_DROPDOWN_SHOW           3
#define STR_ALT                     4
#define STR_COMBOBOX_LIST_SHORTCUT  5

    switch (id)
    {
        case STR_DOUBLE_CLICK:
            //"Double Click"
            wcscpy(sz, L"Double Click");
            break;
            
        case STR_DROPDOWN_HIDE:
            //"Hide"
            wcscpy(sz, L"Hide");
            break;
            
        case STR_DROPDOWN_SHOW:
            //"Show"
            wcscpy(sz, L"Show");
            break;

        case STR_ALT:
            //"Alt+"
            wcscpy(sz, L"Alt+");
            break;
            
        case STR_COMBOBOX_LIST_SHORTCUT:
            //"Alt+Down Arrow"
            wcscpy(sz, L"Alt+Down Arrow");
            break;

        default:
            AssertSz(FALSE, "id not found!!");
    }

    *pbstr = SysAllocString(sz);
    if (!*pbstr)
        return(E_OUTOFMEMORY);
        
    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  HWND GetAncestor(HWND hwnd, UINT gaFlags)
//
//  This gets the ancestor window where
//      GA_PARENT   gets the "real" parent window
//      GA_ROOT     gets the "real" top level parent window (not inc. owner)r
//
//      * The _real_ parent.  This does NOT include the owner, unlike
//          GetParent().  Stops at a top level window unless we start with
//          the desktop.  In which case, we return the desktop.
//      * The _real_ root, caused by walking up the chain getting the
//          ancestor.
//
//  NOTE:
//      User32.exe provides a undocumented function similar to this but
//  it doesn't exist in NT4.  Also, GA_ROOT works differently on Win98 so
//  I copied this over from msaa
// --------------------------------------------------------------------------
HWND GetAncestor(HWND hwnd, UINT gaFlags)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetAncestor");
    
    HWND hwndDesktop = GetDesktopWindow();
    if (hwnd == hwndDesktop || !::IsWindow(hwnd))
        return(NULL);
        
    DWORD dwStyle = GetWindowLong (hwnd, GWL_STYLE);

    HWND	hwndParent;
    switch (gaFlags)
    {
        case GA_PARENT:
            if (dwStyle & WS_CHILD)
                hwndParent = GetParent(hwnd);
            else
                hwndParent = GetWindow(hwnd, GW_OWNER);
    		hwnd = hwndParent;
            break;
            
        case GA_ROOT:
            if (dwStyle & WS_CHILD)
                hwndParent = GetParent(hwnd);
            else
                hwndParent = GetWindow(hwnd, GW_OWNER);
            while (hwndParent != hwndDesktop && hwndParent != NULL)
            {
                hwnd = hwndParent;
                dwStyle = GetWindowLong(hwnd, GWL_STYLE);
                if (dwStyle & WS_CHILD)
                    hwndParent = GetParent(hwnd);
                else
                    hwndParent = GetWindow(hwnd, GW_OWNER);
            }
            break;

        default:
            AssertSz(FALSE, "Invalid flag");
    }    
    return(hwnd);
}


// --------------------------------------------------------------------------
//
//  GetTextString(HWND hwnd, BSTR* bstr)
//
//  Parameters: hwnd of the window to get the text from
//
// --------------------------------------------------------------------------
HRESULT GetTextString(HWND hwnd, BSTR* pbstr)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetTextString");
    
    WCHAR   sz[MAX_PATH + 1];
    WCHAR   *psz = sz;

    int cchText = SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);

    // allocate memory from heap if stack buffer is insufficient
    if (cchText >= MAX_PATH)
        psz = new WCHAR[cchText + 1];

    if (!psz)
        return E_OUTOFMEMORY;

    // retrieve text
    HRESULT hres = S_OK;
    SendMessage(hwnd, WM_GETTEXT, cchText + 1, (LPARAM)psz);

    if (!*psz)
        *pbstr = NULL;
    else
    {
        *pbstr = SysAllocString(psz);
        if (!*pbstr)
            hres = E_OUTOFMEMORY;
    }
    
    // free memory if memory was allocated from heap
    if (psz != sz)
        delete [] psz;

    return hres;
}


// --------------------------------------------------------------------------
//
//  HRESULT GetLabelString(HWND hwnd, BSTR* pbstr)
//
//  This walks backwards among peer windows to find a static field.  It stops
//  if it gets to the front or hits a group/tabstop, just like the dialog 
//  manager does.
//
//  RETURN:
//   HRESULT ? S_OK on success : S_FALSE or COM error on failure
// --------------------------------------------------------------------------
HRESULT GetLabelString(HWND hwnd, BSTR* pbstr)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetLabelString");
    
    HWND hwndLabel = hwnd;
    while (hwndLabel = ::GetWindow(hwndLabel, GW_HWNDPREV))
    {
        LONG lStyle = GetWindowLong(hwndLabel, GWL_STYLE);

        // Skip if invisible
        if (!(lStyle & WS_VISIBLE))
            continue;

        // Is this a static dude?
        LRESULT lResult = SendMessage(hwndLabel, WM_GETDLGCODE, 0, 0L);
        if (lResult & DLGC_STATIC)
        {
            // Great, we've found our label.
            return GetTextString(hwndLabel, pbstr);
        }

        // Is this a tabstop or group?  If so, bail out now.
        if (lStyle & (WS_GROUP | WS_TABSTOP))
            break;
    }

    return S_FALSE;
}


// --------------------------------------------------------------------------
//
//  HRESULT StripMnemonic(BSTR bstrSrc, WCHAR** pchAmp, BOOL bStopOnAmp)
//
//  This removes the mnemonic prefix.  However, if we see '&&', we keep
//  one '&'.
//
// --------------------------------------------------------------------------
HRESULT StripMnemonic(BSTR bstrSrc, WCHAR** pchAmp, BOOL bStopOnAmp)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "StripMnemonic");

    const WCHAR amp = L'&';

    if (pchAmp)
        *pchAmp = NULL;

    WCHAR *psz = (WCHAR*)bstrSrc;
    while (*psz)
    {
        if (*psz == amp)
        {
            if (*(psz + 1) != amp)
            {
                if (pchAmp)
                    *pchAmp = psz;
                break;
            }
        }
        psz++;
    }

    // Start moving all the character up 1 position
    if (!bStopOnAmp)
        while (*psz)
		{
            *psz = *(psz+1);
			psz++;
		}

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  HRESULT GetWindowName(HWND hwnd, BSTR* pbstrName)
//
// --------------------------------------------------------------------------
HRESULT GetWindowName(HWND hwnd, BSTR* pbstrName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetWindowName");
        
    // If use a label, do that instead
    if (S_OK != GetLabelString(hwnd, pbstrName) || !*pbstrName)
        return S_FALSE;

    // Strip out the mnemonic.
    return StripMnemonic(*pbstrName, NULL, FALSE);
}


// --------------------------------------------------------------------------
//
//  HRESULT GetWindowShortcut(HWND hwnd, BSTR* pbstrShortcut)
//
// --------------------------------------------------------------------------
HRESULT GetWindowShortcut(HWND hwnd, BSTR* pbstrShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "GetWindowShortcut");
    
    if (S_OK != GetLabelString(hwnd, pbstrShortcut) || !*pbstrShortcut)
        return S_FALSE;

    WCHAR *pch;
    StripMnemonic(*pbstrShortcut, &pch, TRUE);

    // Is there a mnemonic?
    if (pch)
    {   
        // Get a localized "Alt+" string
        BSTR pbstrAlt = NULL;
        HRESULT hr = GetStringResource(STR_ALT, &pbstrAlt);
        if (hr != S_OK || !pbstrAlt)
            return hr;
            
        // Make a string of the form "Alt+ch".
        WCHAR   szKey[MAX_PATH];
        wcsncpy (szKey, pbstrAlt, MAX_PATH);
        WCHAR   *pchTemp = szKey + wcslen(szKey);

        // Copy shortcut character
        *pchTemp = *pch;
        *(++pchTemp) = L'\0';

        // Release allocated string allocate space for new string
        SysFreeString(pbstrAlt);
        *pbstrShortcut = SysAllocString(pchTemp);
        return (*pbstrShortcut ? S_OK : E_OUTOFMEMORY);
    }

    return(S_FALSE);
}

// --------------------------------------------------------------------------
//
//  GetWindowObject()
//
//  Gets an immediate child object.
//
// --------------------------------------------------------------------------
HRESULT GetWindowObject(HWND hwndChild, VARIANT * pvar)
{
    pvar->vt = VT_EMPTY;
    IDispatch * pdispChild = NULL;
    HRESULT hr = W32->AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch,
        (void **)&pdispChild);

    if (!SUCCEEDED(hr))
        return(hr);
    if (!pdispChild)
        return(E_FAIL);

    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdispChild;

    return(S_OK);
}

} //namespace


//////////////////////// ListBox CListBoxSelection Methods ///////////////////////////

// --------------------------------------------------------------------------
//
//  CListBoxSelection::CListBoxSelection()
//
//  We AddRef() once plistFrom so that it won't go away out from us.  When
//  we are destroyed, we will Release() it.
//
// --------------------------------------------------------------------------
CListBoxSelection::CListBoxSelection(
	int iChildCur,
	int cSelected,
	LPINT lpSelection,
	BOOL fClone)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::CListBoxSelection");
    
    _idChildCur = iChildCur;

    _cRef = 1;
	_cSel = cSelected;
	_piSel = lpSelection;

	if (fClone)
	{
		_piSel = new int[cSelected];
		if (!_piSel)
			_cSel = 0;
		else
			memcpy(_piSel, lpSelection, cSelected*sizeof(int));
	}
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::~CListBoxSelection()
//
// --------------------------------------------------------------------------
CListBoxSelection::~CListBoxSelection()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::~CListBoxSelection");

	// Free item memory
	if (_piSel)
		delete [] _piSel;
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::QueryInterface()
//
//  We only respond to IUnknown and IEnumVARIANT!  It is the responsibility
//  of the caller to loop through the items using IEnumVARIANT interfaces,
//  and get the child IDs to then pass to the parent object (or call 
//  directly if VT_DISPATCH--not in this case they aren't though).
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::QueryInterface(REFIID riid, void** ppunk)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::QueryInterface");
    
    *ppunk = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IEnumVARIANT))
    {
        *ppunk = this;
    }
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN) *ppunk)->AddRef();
    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::AddRef(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::AddRef");
    
    return(++_cRef);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::Release(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Release");
    
    if ((--_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return(_cRef);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Next()
//
//  This returns a VT_I4 which is the child ID for the parent listbox that
//  returned this object for the selection collection.  The caller turns
//  around and passes this variant to the listbox object to get acc info
//  about it.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Next(ULONG celt, VARIANT* rgvar, ULONG *pceltFetched)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Next");
    
    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    // reset temporary variable to beginning
    VARIANT *pvar = rgvar;
    long cFetched = 0;
    long iCur = _idChildCur;

    // Loop through our items
    while ((cFetched < (long)celt) && (iCur < _cSel))
    {
        VariantInit(pvar);
        pvar->vt = VT_I4;
        pvar->lVal = _piSel[iCur] + 1;

        cFetched++;
        iCur++;
        pvar++;
    }

    // Initialize the variant after the last valid one just
    // in case the client is looping based on invalid variants
    if ((ULONG)cFetched < celt)
        VariantInit(pvar);

    // Advance the current position
    _idChildCur = iCur;

    // Fill in the number fetched
    if (pceltFetched)
        *pceltFetched = cFetched;

    // Return S_FALSE if we grabbed fewer items than requested
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Skip()
//
// -------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Skip(ULONG celt)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Skip");
    
    _idChildCur += celt;
    if (_idChildCur > _cSel)
        _idChildCur = _cSel;

    // We return S_FALSE if at the end.
    return((_idChildCur >= _cSel) ? S_FALSE : S_OK);
}


// --------------------------------------------------------------------------
//
//  CListBoxSelection::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Reset(void)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Reset");
    
    _idChildCur = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Clone(IEnumVARIANT **ppenum)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CListBoxSelection::Clone");
    
    InitPv(ppenum);
    CListBoxSelection * plistselnew = new CListBoxSelection(_idChildCur, _cSel, _piSel, TRUE);
    if (!plistselnew)
        return(E_OUTOFMEMORY);

    HRESULT hr = plistselnew->QueryInterface(IID_IEnumVARIANT, (void**)ppenum);
	plistselnew->Release();		// Release the AddRef being done in new CListBoxSelection
	return hr;
}

//////////////////////// ListBox IAccessible Methods //////////////////////////////
/*
 *	CLstBxWinHost::InitTypeInfo()
 *
 *	@mfunc
 *		Retrieves type library
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
HRESULT CLstBxWinHost::InitTypeInfo()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InitTypeInfo");

	if (_fShutDown)
		return CO_E_RELEASED;

    return MSAA::InitTypeInfo(&_pTypeInfo);
}


/*
 *	CLstBxWinHost::get_accName(VARIANT varChild, BSTR *pbstrName)
 *
 *	@mfunc
 *		SELF ? label of control : item text 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accName(VARIANT varChild, BSTR *pbstrName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accName");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPv(pbstrName);

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        if (_fLstType == kCombo)
            return  _pcbHost->get_accName(varChild, pbstrName);
        else
            return(MSAA::GetWindowName(_hwnd, pbstrName));
    }
    else
    {
        // Get the item text.
        LRESULT lres = RichListBoxWndProc(_hwnd, LB_GETTEXTLEN, varChild.lVal-1, 0);

        // First Check for error
        if (lres == LB_ERR)
            return S_FALSE;
       
        if (lres > 0)
        {
            // allocate some buffer
            *pbstrName = SysAllocStringLen(NULL, lres + 1);
            if (!*pbstrName)
                return E_OUTOFMEMORY;
                
            RichListBoxWndProc(_hwnd, LB_GETTEXT, varChild.lVal-1, (LPARAM)*pbstrName);
        }
    }
    return(S_OK);
}


/*
 *	CLstBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
 *
 *	@mfunc
 *		Retrieves the object's Role property. 
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accRole");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarRole);

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return S_OK;
}


/*
 *	CLstBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
 *
 *	@mfunc
 *		Retrieves the current state of the object or child item.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accState");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    InitPvar(pvarState);
    if (varChild.lVal == CHILDID_SELF)
    {
        pvarState->vt = VT_I4;
        pvarState->lVal = 0;

        if (!IsWindowVisible(_hwnd))
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

        if (!IsWindowEnabled(_hwnd))
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (_fFocus)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;

        if (::GetForegroundWindow() == MSAA::GetAncestor(_hwnd, GA_ROOT))
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        return S_OK;
    }


    --varChild.lVal;

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    // Is this item selected?
    if (IsSelected(varChild.lVal))
        pvarState->lVal |= STATE_SYSTEM_SELECTED;

    // Does it have the focus?  Remember that we decremented the lVal so it
    // is zero-based like listbox indeces.
    if (_fFocus)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (varChild.lVal == GetCursor())
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;            
    }

    // Is the listbox read-only?
    long lStyle = GetWindowLong(_hwnd, GWL_STYLE);

    if (lStyle & LBS_NOSEL)
        pvarState->lVal |= STATE_SYSTEM_READONLY;
    else
    {
        pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

        // Is the listbox multiple and/or extended sel?  NOTE:  We have
        // no way to implement accSelect() EXTENDSELECTION so don't.
        if (lStyle & LBS_MULTIPLESEL)
            pvarState->lVal |= STATE_SYSTEM_MULTISELECTABLE;
    }

    // Is the item in view?
    //
	// SMD 09/16/97 Offscreen things are things never on the screen,
	// and that doesn't apply to this. Changed from OFFSCREEN to
	// INVISIBLE.
	RECT    rcItem;
    if (!RichListBoxWndProc(_hwnd, LB_GETITEMRECT, varChild.lVal, (LPARAM)&rcItem))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return S_OK;
}

/*
 *	CLstBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
 *
 *	@mfunc
 *		Retrieves an object's KeyboardShortcut property.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accKeyboardShortcut");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if ((varChild.lVal == 0) && _fLstType != kCombo)
    {
        InitPv(pszShortcut);
        return(MSAA::GetWindowShortcut(_hwnd, pszShortcut));
    }
    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::get_accFocus(VARIANT *pvarChild)
 *
 *	@mfunc
 *		Retrieves the child object that currently has the keyboard focus.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accFocus(VARIANT *pvarChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accFocus");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarChild);

    // Are we the focus?
    if (_fFocus)
    {
        pvarChild->vt = VT_I4;
        if (GetCursor() >= 0)
            pvarChild->lVal = GetCursor() + 1;
        else
            pvarChild->lVal = 0;
        return S_OK;
    }
    else
        return S_FALSE;
}


/*
 *	CLstBxWinHost::get_accSelection(VARIANT *pvarSelection)
 *
 *	@mfunc
 *		Retrieves the selected children of this object. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accSelection(VARIANT *pvarSelection)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accSelection");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarSelection);

    int cSel = RichListBoxWndProc(_hwnd, LB_GETSELCOUNT, 0, 0);
    
    if (cSel <= 1)
    {
        // cSelected is -1, 0, or 1.  
        //      -1 means this is a single sel listbox.  
        //      0 or 1 means this is multisel
        if (GetCursor() < 0)
            return S_FALSE;
            
        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = GetCursor() + 1;
        return(S_OK);
    }

    // Allocate memory for the list of item IDs
    int * plbs = new int[cSel];
    if (!plbs)
        return(E_OUTOFMEMORY);
    
    // Multiple items; must make a collection
    // Get the list of selected item IDs
    int j = 0;
    for (long i = 0; i < GetCount(); i++)
    {
		if (IsSelected(i) == TRUE)
		    plbs[j++] = i;
	}

	// Note: we don't need to free plbs since it will be kept inside plbsel.
    CListBoxSelection *plbsel = new CListBoxSelection(0, cSel, plbs, FALSE);

    // check if memory allocation failed
    if (!plbsel)
	{
		delete [] plbs;
        return(E_OUTOFMEMORY);
	}
        
    pvarSelection->vt = VT_UNKNOWN;
	HRESULT hr = plbsel->QueryInterface(IID_IUnknown, (void**)&(pvarSelection->punkVal));
	plbsel->Release();		// Release the AddRef being done in new CListBoxSelection
	return hr;
}


/*
 *	CLstBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
 *
 *	@mfunc
 *		Retrieves a string containing a localized sentence that describes the object's default action. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accDefaultAction");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPv(pszDefAction);

    // Validate.
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return (MSAA::GetStringResource(STR_DOUBLE_CLICK, pszDefAction));

    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
 *
 *	@mfunc
 *		Retrieves the object's current screen location (if the object was placed on 
 *  the screen) and optionally, the child element. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accLocation");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    // Validate params
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return E_INVALIDARG;

    RECT    rc;
    if (!varChild.lVal)
        GetClientRect(_hwnd, &rc);
    else if (!RichListBoxWndProc(_hwnd, LB_GETITEMRECT, varChild.lVal-1, (LPARAM)&rc))
        return S_OK;

    // Convert coordinates to screen coordinates
    *pcxWidth = rc.right - rc.left;
    *pcyHeight = rc.bottom - rc.top;    
    
    ClientToScreen(_hwnd, (LPPOINT)&rc);
    *pxLeft = rc.left;
    *pyTop = rc.top;

    return S_OK;
}

/*
 *	CLstBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
 *
 *	@mfunc
 *		Retrieves the child object at a given point on the screen. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accHitTest");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarHit);

    // Is the point in our client area?
    POINT   pt = {xLeft, yTop};
    ScreenToClient(_hwnd, &pt);

    RECT    rc;
    GetClientRect(_hwnd, &rc);

    if (!PtInRect(&rc, pt))
        return(S_FALSE);

    // What item is here?
    long l = GetItemFromPoint(&pt);
    pvarHit->vt = VT_I4;
    pvarHit->lVal = (l >= 0) ? l + 1 : 0;
    
    return(S_OK);
}


/*
 *	CLstBxWinHost::accDoDefaultAction(VARIANT varChild)
 *
 *	@mfunc
 *		Performs the object's default action. 
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accDoDefaultAction(VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accDoDefaultAction");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, GetCount()))
        return(E_INVALIDARG);

    if (varChild.lVal)
    {        
        // this will check if WindowFromPoint at the click point is the same
	    // as m_hwnd, and if not, it won't click. Cool!
	    
        RECT	rcLoc;
	    HRESULT hr = accLocation(&rcLoc.left, &rcLoc.top, &rcLoc.right, &rcLoc.bottom, varChild);
	    if (!SUCCEEDED (hr))
		    return (hr);

        // Find Center of rect
        POINT ptClick;
    	ptClick.x = rcLoc.left + (rcLoc.right/2);
    	ptClick.y = rcLoc.top + (rcLoc.bottom/2);

    	// check if hwnd at point is same as hwnd to check
    	if (WindowFromPoint(ptClick) != _hwnd)
    		return DISP_E_MEMBERNOTFOUND;

        W32->BlockInput(TRUE);
        
        // Get current cursor pos.
        POINT ptCursor;
        DWORD dwMouseDown, dwMouseUp;
        GetCursorPos(&ptCursor);
    	if (GetSystemMetrics(SM_SWAPBUTTON))
    	{
    		dwMouseDown = MOUSEEVENTF_RIGHTDOWN;
    		dwMouseUp = MOUSEEVENTF_RIGHTUP;
    	}
    	else
    	{
    		dwMouseDown = MOUSEEVENTF_LEFTDOWN;
    		dwMouseUp = MOUSEEVENTF_LEFTUP;
    	}

        // Get delta to move to center of rectangle from current
        // cursor location.
        ptCursor.x = ptClick.x - ptCursor.x;
        ptCursor.y = ptClick.y - ptCursor.y;

        // NOTE:  For relative moves, USER actually multiplies the
        // coords by any acceleration.  But accounting for it is too
        // hard and wrap around stuff is weird.  So, temporarily turn
        // acceleration off; then turn it back on after playback.

        // Save mouse acceleration info
        MOUSEINFO	miSave, miNew;
        if (!SystemParametersInfo(SPI_GETMOUSE, 0, &miSave, 0))
        {
            W32->BlockInput(FALSE);
            return (DISP_E_MEMBERNOTFOUND);
        }

        if (miSave.MouseSpeed)
        {
            miNew.MouseThresh1 = 0;
            miNew.MouseThresh2 = 0;
            miNew.MouseSpeed = 0;

            if (!SystemParametersInfo(SPI_SETMOUSE, 0, &miNew, 0))
            {
                W32->BlockInput(FALSE);
                return (DISP_E_MEMBERNOTFOUND);
            }
        }

        // Get # of buttons
        int nButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);

        // mouse move to center of start button
        INPUT		rgInput[6];
        rgInput[0].type = INPUT_MOUSE;
        rgInput[0].mi.dwFlags = MOUSEEVENTF_MOVE;
        rgInput[0].mi.dwExtraInfo = 0;
        rgInput[0].mi.dx = ptCursor.x;
        rgInput[0].mi.dy = ptCursor.y;
        rgInput[0].mi.mouseData = nButtons;
		rgInput[0].mi.time = 0;

        int i = 1;

        // MSAA's order of double click is 
        // WM_LBUTTONDOWN
        // WM_LBUTTONUP
        // WM_LBUTTONDOWN
        // WM_LBUTTONUP
        while (i <= 4)
        {
            if (i % 2)
                rgInput[i].mi.dwFlags = dwMouseDown;
            else
                rgInput[i].mi.dwFlags = dwMouseUp;
                
            rgInput[i].type = INPUT_MOUSE;
            rgInput[i].mi.dwExtraInfo = 0;
            rgInput[i].mi.dx = 0;
            rgInput[i].mi.dy = 0;
            rgInput[i].mi.mouseData = nButtons;
			rgInput[i].mi.time = 0;
            i++;
        }
        
    	// move mouse back to starting location
        rgInput[i].type = INPUT_MOUSE;
        rgInput[i].mi.dwFlags = MOUSEEVENTF_MOVE;
        rgInput[i].mi.dwExtraInfo = 0;
        rgInput[i].mi.dx = -ptCursor.x;
        rgInput[i].mi.dy = -ptCursor.y;
        rgInput[i].mi.mouseData = nButtons;
		rgInput[i].mi.time = 0;
        i++;
        if (!W32->SendInput(i, rgInput, sizeof(INPUT)))
            MessageBeep(0);

        // Restore Mouse Acceleration
        if (miSave.MouseSpeed)
            SystemParametersInfo(SPI_SETMOUSE, 0, &miSave, 0);

        W32->BlockInput (FALSE);
	    return (S_OK);
    }
    return(DISP_E_MEMBERNOTFOUND);
}


/*
 *	CLstBxWinHost::accSelect(long selFlags, VARIANT varChild)
 *
 *	@mfunc
 *		Modifies the selection or moves the keyboard focus according to the specified flags.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accSelect(long selFlags, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accSelect");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, GetCount()) || !MSAA::ValidateSelFlags(selFlags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(S_FALSE);

    varChild.lVal--;

    long lStyle = GetWindowLong(_hwnd, GWL_STYLE);
    if (lStyle & LBS_NOSEL)
        return DISP_E_MEMBERNOTFOUND;

    if (!IsSingleSelection())
    {
        // get the focused item here in case we change it. 
        int nFocusedItem = GetCursor();

	    if (selFlags & SELFLAG_TAKEFOCUS) 
        {
            if (!_fFocus)
                return(S_FALSE);

            RichListBoxWndProc (_hwnd, LB_SETCARETINDEX, varChild.lVal, 0);
        }

        // reset and select requested item
	    if (selFlags & SELFLAG_TAKESELECTION)
	    {
	        // deselect the whole range of items
            RichListBoxWndProc(_hwnd, LB_SETSEL, FALSE, -1);
            // Select this one
            RichListBoxWndProc(_hwnd, LB_SETSEL, TRUE, varChild.lVal);
        }

        if (selFlags & SELFLAG_EXTENDSELECTION)
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                RichListBoxWndProc (_hwnd, LB_SELITEMRANGE, (selFlags & SELFLAG_ADDSELECTION), 
                             MAKELPARAM(nFocusedItem, varChild.lVal));
            else
            {
                BOOL bSelected = RichListBoxWndProc (_hwnd, LB_GETSEL, nFocusedItem, 0);
                RichListBoxWndProc (_hwnd, LB_SELITEMRANGE, bSelected, MAKELPARAM(nFocusedItem,varChild.lVal));
            }
        }
        else // not extending, check add/remove
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                RichListBoxWndProc(_hwnd, LB_SETSEL, (selFlags & SELFLAG_ADDSELECTION), varChild.lVal);
        }
        // set focus to where it was before if SELFLAG_TAKEFOCUS not set
        if ((selFlags & SELFLAG_TAKEFOCUS) == 0)
            RichListBoxWndProc (_hwnd, LB_SETCARETINDEX, nFocusedItem, 0);
    }
    else // listbox is single select
    {
        if (selFlags & (SELFLAG_ADDSELECTION | SELFLAG_REMOVESELECTION | SELFLAG_EXTENDSELECTION))
            return (E_INVALIDARG);

        // single select listboxes do not allow you to set the
        // focus independently of the selection, so we send a 
        // LB_SETCURSEL for both TAKESELECTION and TAKEFOCUS
	    if ((selFlags & SELFLAG_TAKESELECTION) || (selFlags & SELFLAG_TAKEFOCUS))
            RichListBoxWndProc(_hwnd, LB_SETCURSEL, varChild.lVal, 0);
    } // end if listbox is single select
	
    return(S_OK);
}


/*
 *	CLstBxWinHost::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
 *
 *	@mfunc
 *		Retrieves the next or previous sibling or child object in a specified direction.  
 *
 *	@rdesc
 *		Returns S_OK if successful or one of the following values or a standard COM 
 *  error code otherwise.
 */
STDMETHODIMP CLstBxWinHost::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::accNavigate");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarEnd);

    // Validate parameters
    if (!MSAA::ValidateChild(&varStart, GetCount()))
        return(E_INVALIDARG);

    // Is this something for the client (or combobox) to handle?
    long lEnd = 0;
    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        lEnd = GetCount() ? 1 : 0;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
        lEnd = GetCount();
    else if (varStart.lVal == CHILDID_SELF)
    {   
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        IAccessible* poleacc = NULL;
        HRESULT hr = W32->AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW, IID_IAccessible, (void**)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);

        // Ask it to navigate
        VARIANT varStart;
        VariantInit(&varStart);
        varStart.vt = VT_I4;
        varStart.lVal = OBJID_CLIENT;

        hr = poleacc->accNavigate(dwNavDir, varStart, pvarEnd);

        // Release our parent
        poleacc->Release();
        return(hr);
    }
    else
    {
        //long lT = varStart.lVal - 1;
        switch (dwNavDir)
        {
            // We're a single column list box only so ignore
            // these flags
            //case NAVDIR_RIGHT:
            //case NAVDIR_LEFT:
            //    break;

            case NAVDIR_PREVIOUS:
            case NAVDIR_UP:
                // Are we in the top-most row?
                lEnd = varStart.lVal - 1;
                break;

            case NAVDIR_NEXT:
            case NAVDIR_DOWN:
                lEnd = varStart.lVal + 1;
                if (lEnd > GetCount())
                    lEnd = 0;
                break;
        }
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
    }

    return(lEnd ? S_OK : S_FALSE);
}


/*
 *	CLstBxWinHost::get_accParent(IDispatch **ppdispParent)
 *
 *	@mfunc
 *		Retrieves the IDispatch interface of the current object's parent. 
 *  Return S_FALSE and set the variable at ppdispParent to NULL. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accParent(IDispatch **ppdispParent)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accParent");

	if (_fShutDown)
		return CO_E_RELEASED;

    AssertSz(ppdispParent != NULL, "null pointer");
    if (ppdispParent == NULL)
        return S_FALSE;
        
    InitPv(ppdispParent);
    HWND hwnd;
    if (_fLstType != kCombo)
    {
        hwnd = MSAA::GetAncestor(_hwnd, GA_PARENT);
        AssertSz(hwnd, "Invalid Hwnd");
        if (!hwnd)
            return S_FALSE;
    }
    else
    {
        if (_pcbHost)
        {
            hwnd = _pcbHost->_hwnd;
            Assert(hwnd);
        }
        else
            return S_FALSE;
        
    }

    HRESULT hr = W32->AccessibleObjectFromWindow(hwnd, (DWORD)OBJID_CLIENT, IID_IDispatch,
                                          (void **)ppdispParent);

#ifdef DEBUG
    if (FAILED(hr))
        Assert(FALSE);
#endif
    return hr;
}


/*
 *	CLstBxWinHost::get_accChildCount(long *pcCount)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CLstBxWinHost::get_accChildCount(long *pcCount)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::get_accChildCount");

	if (_fShutDown)
		return CO_E_RELEASED;

    *pcCount = GetCount();
    return(S_OK);
}

/*
 *	CCmbBxWinHost::InitTypeInfo()
 *
 *	@mfunc
 *		Retrieves type library
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise.
 */
HRESULT CCmbBxWinHost::InitTypeInfo()
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::InitTypeInfo");

	if (_fShutDown)
		return CO_E_RELEASED;

    return MSAA::InitTypeInfo(&_pTypeInfo);
}

/*
 *	CCmbBxWinHost::get_accName(VARIANT varChild, BSTR *pszName)
 *
 *	@mfunc
 *		Retrieves the Name property for this object. 
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accName(VARIANT varChild, BSTR *pszName)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accName");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    // The name of the combobox, the edit inside of it, and the dropdown
    // are all the same.  The name of the button is Drop down/Pop up
    InitPv(pszName);
    if (varChild.lVal != INDEX_COMBOBOX_BUTTON)
        return(MSAA::GetWindowName(_hwnd, pszName));
    else
    {
        if (IsWindowVisible(_hwndList))
            return (MSAA::GetStringResource(STR_DROPDOWN_HIDE, pszName));
        else
            return(MSAA::GetStringResource(STR_DROPDOWN_SHOW, pszName));
    }
}

/*
 *	CCmbBxWinHost::get_accValue(VARIANT varChild, BSTR *pszValue)
 *
 *	@mfunc
 *		Retrieves the object's Value property.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accValue(VARIANT varChild, BSTR *pszValue)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accValue");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
        case INDEX_COMBOBOX_ITEM:
            InitPv(pszValue);
            LRESULT lres;
            _pserv->TxSendMessage(WM_GETTEXTLENGTH, 0, 0, &lres);

            // If windows text length is 0 then MSAA searches
            // for the label associated with the control
            if (lres <= 0)
                return MSAA::GetLabelString(_hwnd, pszValue);
                
            GETTEXTEX gt;
            memset(&gt, 0, sizeof(GETTEXTEX));
            gt.cb = (lres + 1) * sizeof(WCHAR);
            gt.codepage = 1200;
            gt.flags = GT_DEFAULT;

            *pszValue = SysAllocStringLen(NULL, lres + 1);
            if (!*pszValue)
                return E_OUTOFMEMORY;
                
            _pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)*pszValue, &lres);
            return S_OK;
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
 *
 *	@mfunc
 *		Retrieves the object's Role property.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accRole");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate--this does NOT accept a child ID.
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            pvarRole->lVal = ROLE_SYSTEM_COMBOBOX;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (_cbType == kDropDown)
                pvarRole->lVal = ROLE_SYSTEM_TEXT;
            else
                pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;
            break;

        case INDEX_COMBOBOX_BUTTON:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_COMBOBOX_LIST:
            pvarRole->lVal = ROLE_SYSTEM_LIST;
            break;

        default:
            AssertSz(FALSE, "Invalid ChildID for child of combo box" );
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
 *
 *	@mfunc
 *		Retrieves the current state of the object or child item.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accState");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate--this does NOT accept a child ID.
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    VARIANT var;
    HRESULT hr;
    IAccessible* poleacc;
    InitPvar(pvarState);
    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    HWND hwndActive = GetForegroundWindow();
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX_BUTTON:
            if (_fMousedown)
                pvarState->lVal |= STATE_SYSTEM_PRESSED;
            break;

        case INDEX_COMBOBOX_ITEM:
            if (_cbType == kDropDownList)
            {              
                if (hwndActive == MSAA::GetAncestor(_hwnd, GA_ROOT))
                    pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
                if (_fFocus)
                    pvarState->lVal |= STATE_SYSTEM_FOCUSED;
                break;
            }
            
            // FALL THROUGH CASE
            
        case INDEX_COMBOBOX:
            if (!(_dwStyle & WS_VISIBLE))
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

            if (_dwStyle & WS_DISABLED)
                pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

            if (_fFocus)
                pvarState->lVal |= STATE_SYSTEM_FOCUSED;

            if (hwndActive == MSAA::GetAncestor(_hwnd, GA_ROOT))
                pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
            break;            

        case INDEX_COMBOBOX_LIST:
            {

                // First we incorporate the state of the window in general
                //
                VariantInit(&var);
                if (FAILED(hr = MSAA::GetWindowObject(_hwndList, &var)))
                    return(hr);

                Assert(var.vt == VT_DISPATCH);

                // Get the child acc object
                poleacc = NULL;
                hr = var.pdispVal->QueryInterface(IID_IAccessible,
                    (void**)&poleacc);
                var.pdispVal->Release();

                if (FAILED(hr))
                {
                    Assert(FALSE);
                    return(hr);
                }

                // Ask the child its state
                VariantInit(&var);
                hr = poleacc->get_accState(var, pvarState);
                poleacc->Release();
                if (FAILED(hr))
                {
                    Assert(FALSE);
                    return(hr);
                }

                // The listbox is always going to be floating
                //
                pvarState->lVal |= STATE_SYSTEM_FLOATING;

                if (_plbHost->_fDisabled)
                    pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;
                else
                    pvarState->lVal &= ~STATE_SYSTEM_UNAVAILABLE;

                if (_fListVisible)
                    pvarState->lVal &= ~STATE_SYSTEM_INVISIBLE;
                else
                    pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
                    
                break;
            }
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
 *
 *	@mfunc
 *		Retrieves an object's KeyboardShortcut property.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszShortcut)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accKeyboardShortcut");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Shortcut for combo is label's hotkey.
    // Shortcut for dropdown (if button) is Alt+F4.
    // CWO, 12/5/96, Alt+F4? F4, by itself brings down the combo box,
    //                       but we add "Alt" to the string.  Bad!  Now use 
    //                       down arrow and add Alt to it via HrMakeShortcut()
    //                       As documented in the UI style guide.
    //
    // As always, shortcuts only apply if the container has "focus".  In other
    // words, the hotkey for the combo does nothing if the parent dialog
    // isn't active.  And the hotkey for the dropdown does nothing if the
    // combobox/edit isn't focused.
  

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    InitPv(pszShortcut);
    if (varChild.lVal == INDEX_COMBOBOX)
    {
        return(MSAA::GetWindowShortcut(_hwnd, pszShortcut));
    }
    else if (varChild.lVal == INDEX_COMBOBOX_BUTTON)
    {
        return(MSAA::GetStringResource(STR_COMBOBOX_LIST_SHORTCUT, pszShortcut));
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accFocus(VARIANT *pvarFocus)
 *
 *	@mfunc
 *		Retrieves the child object that currently has the keyboard focus.  
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accFocus(VARIANT *pvarFocus)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accFocus");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarFocus);
    // Is the current focus a child of us?
    if (_fFocus)
    {
        pvarFocus->vt = VT_I4;
        pvarFocus->lVal = 0;
    }
    else 
    {
        // NOTE:
        //  We differ here in we don't get the foreground thread's focus window.  Instead,
        //  we just get the current threads focus window
        HWND hwnd = GetFocus();
        if (IsChild(_hwnd, hwnd))            
            return(MSAA::GetWindowObject(hwnd, pvarFocus));
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
 *
 *	@mfunc
 *		Retrieves a string containing a localized sentence that describes the object's
 *  default action.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accDefaultAction");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate parameters
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    if ((varChild.lVal != INDEX_COMBOBOX_BUTTON)/* || _fHasButton*/)
        return DISP_E_MEMBERNOTFOUND;

    // Default action of button is to press it.  If pressed already, pressing
    // it will pop dropdown back up.  If not pressed, pressing it will pop
    // dropdown down.
    InitPv(pszDefaultAction);

    if (IsWindowVisible(_hwndList))
        return(MSAA::GetStringResource(STR_DROPDOWN_HIDE, pszDefaultAction));
    else
        return(MSAA::GetStringResource(STR_DROPDOWN_SHOW, pszDefaultAction));
}


/*
 *	CCmbBxWinHost::accSelect(long flagsSel, VARIANT varChild)
 *	@mfunc
 *		Modifies the selection or moves the keyboard focus according to the specified 
 *  flags.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accSelect(long flagsSel, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accSelect");

	if (_fShutDown)
		return CO_E_RELEASED;

    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX) || !MSAA::ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
 *	@mfunc
 *		Retrieves the object's current screen location (if the object was placed on 
 *   the screen) and optionally, the child element.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accLocation");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    RECT rc;
    HWND hwnd = _hwnd;
    switch (varChild.lVal)
    {        
        case INDEX_COMBOBOX_BUTTON:
            //if (!m_fHasButton)
            //    return(S_FALSE);
            rc = _rcButton;
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;
            ClientToScreen(_hwnd, (LPPOINT)&rc);
            break;

        case INDEX_COMBOBOX_ITEM:
            //  Need to verify this is the currently selected item.
            //  if no item is selected then pass the rect of the first item in the list
            _plbHost->LbGetItemRect((_plbHost->GetCursor() < 0) ? 0 : _plbHost->GetCursor(), &rc);
            
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;   
            ClientToScreen(_hwndList, (LPPOINT)&rc);
            break;

        case INDEX_COMBOBOX_LIST:
            hwnd = _hwndList;
            // fall through!!!
            
        case 0: //default window
            GetWindowRect(hwnd, &rc);
            // copy over dimensions            
            *pcxWidth = rc.right - rc.left;
            *pcyHeight = rc.bottom - rc.top;
            break;

        default:
            AssertSz(FALSE, "Invalid ChildID for child of combo box" );
            return (S_OK);
    }
    
    *pxLeft = rc.left;
    *pyTop = rc.top;
    return(S_OK);
}


/*
 *	CCmbBxWinHost::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
 *
 *	@mfunc
 *		Retrieves the next or previous sibling or child object in a specified 
 *  direction.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accNavigate(long dwNav, VARIANT varStart, VARIANT* pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accNavigate");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarEnd);

    // Validate parameters
    if (!MSAA::ValidateChild(&varStart, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    long lEnd = 0;
    if (dwNav == NAVDIR_FIRSTCHILD)
    {
        lEnd =  INDEX_COMBOBOX_ITEM;
        goto GetTheChild;
    }
    else if (dwNav == NAVDIR_LASTCHILD)
    {
        dwNav = NAVDIR_PREVIOUS;
        varStart.lVal = CCHILDREN_COMBOBOX + 1;
    }
    else if (!varStart.lVal)
    {
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        IAccessible* poleacc = NULL;
        HRESULT hr = W32->AccessibleObjectFromWindow(_hwnd, OBJID_WINDOW, IID_IAccessible, (void**)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);

        // Ask it to navigate
        VARIANT varStart;
        VariantInit(&varStart);
        varStart.vt = VT_I4;
        varStart.lVal = OBJID_CLIENT;

        hr = poleacc->accNavigate(dwNav, varStart, pvarEnd);

        // Release our parent
        poleacc->Release();
        return(hr);
    }

    // Map HWNDID to normal ID.  We work with both (it is easier).
    if (IsHWNDID(varStart.lVal))
    {
        HWND hWndTemp = HwndFromHWNDID(varStart.lVal);

        if (hWndTemp == _hwnd)
            varStart.lVal = INDEX_COMBOBOX_ITEM;
        else if (hWndTemp == _hwndList)
            varStart.lVal = INDEX_COMBOBOX_LIST;
        else
            // Don't know what the heck this is
            return(S_FALSE);
    }

    switch (dwNav)
    {
        case NAVDIR_UP:
            if (varStart.lVal == INDEX_COMBOBOX_LIST)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_DOWN:
            if ((varStart.lVal != INDEX_COMBOBOX_LIST) && _fListVisible)
                lEnd = INDEX_COMBOBOX_LIST;
            break;

        case NAVDIR_LEFT:
            if (varStart.lVal == INDEX_COMBOBOX_BUTTON)
                lEnd = INDEX_COMBOBOX_ITEM;
            break;

        case NAVDIR_RIGHT:
            if ((varStart.lVal == INDEX_COMBOBOX_ITEM)/* && !(cbi.stateButton & STATE_SYSTEM_INVISIBLE)*/)
               lEnd = INDEX_COMBOBOX_BUTTON;
            break;

        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            if ((lEnd == INDEX_COMBOBOX_LIST) && !_fListVisible)
                --lEnd;
            break;

        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > CCHILDREN_COMBOBOX || ((lEnd == INDEX_COMBOBOX_LIST) && !_fListVisible))
                lEnd = 0;
            break;
    }

GetTheChild:
    if (lEnd)
    {
        // NOTE:
        // MSAA tries to make a distinction for controls by implementing 2 different types of
        // interfaces for controls.
        // OBJID_WINDOW - will include the windows border along with the client.  This control
        //              should be perceived from a dialog or some window containers perspective.
        //              Where the control is just an abstract entity contained in the window container
        // OBJID_CLIENT - only includes the client area.  This interface is only concerned with 
        //              the control itself and disregards the outside world
        if ((lEnd == INDEX_COMBOBOX_ITEM)/* && cbi.hwndItem*/)
            return(MSAA::GetWindowObject(_hwnd, pvarEnd));
        else if ((lEnd == INDEX_COMBOBOX_LIST)/* && cbi.hwndList*/)
            return(MSAA::GetWindowObject(_hwndList, pvarEnd));

        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }

    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarEnd)
 *
 *	@mfunc
 *		Retrieves the child object at a given point on the screen.    
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accHitTest(long xLeft, long yTop, VARIANT *pvarEnd)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accHitTest");
    
    POINT   pt;
    RECT    rc;

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarEnd);

    pt.x = xLeft;
    pt.y = yTop;

    // Check list first, in case it is a dropdown.
    GetWindowRect(_hwndList, &rc);
    if (_fListVisible && PtInRect(&rc, pt))
        return(MSAA::GetWindowObject(_hwndList, pvarEnd));
    else
    {
        ScreenToClient(_hwnd, &pt);
        GetClientRect(_hwnd, &rc);        

        if (PtInRect(&_rcButton, pt))
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = INDEX_COMBOBOX_BUTTON;
        }
        else
        {
            if (!PtInRect(&rc, pt))
                return(S_FALSE);
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = 0;
        }
    }

    return(S_OK);
}


/*
 *	CCmbBxWinHost::accDoDefaultAction(VARIANT varChild)
 *
 *	@mfunc
 *		Performs the object's default action.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::accDoDefaultAction(VARIANT varChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::accDoDefaultAction");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    if ((varChild.lVal == INDEX_COMBOBOX_BUTTON)/* && m_fHasButton*/)
    {
        if (_fListVisible)
            PostMessage(_hwnd, WM_KEYDOWN, VK_RETURN, 0);
        else
            PostMessage(_hwnd, CB_SHOWDROPDOWN, TRUE, 0);

        return(S_OK);
    }
    return DISP_E_MEMBERNOTFOUND;
}


/*
 *	CCmbBxWinHost::get_accSelection(VARIANT *pvarChildren)
 *
 *	@mfunc
 *		Retrieves the selected children of this object.   
 *
 *	@rdesc
 *		Returns S_OK if successful or E_INVALIDARG or another standard COM error code 
 *  otherwise. 
 */
STDMETHODIMP CCmbBxWinHost::get_accSelection(VARIANT *pvarChildren)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accSelection");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPvar(pvarChildren);
    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::get_accParent(IDispatch **ppdispParent)
 *
 *	@mfunc
 *		Retrieves the IDispatch interface of the current object's parent. 
 *  Return S_FALSE and set the variable at ppdispParent to NULL. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accParent(IDispatch **ppdispParent)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accParent");

	if (_fShutDown)
		return CO_E_RELEASED;

    InitPv(ppdispParent);

    if (_hwnd)
    {
        HWND hwnd = MSAA::GetAncestor(_hwnd, GA_PARENT);
        if (hwnd)
            return W32->AccessibleObjectFromWindow(hwnd, OBJID_WINDOW,
                    IID_IDispatch, (void **)ppdispParent);
    }
    
    return(S_FALSE);
}


/*
 *	CCmbBxWinHost::get_accChildCount(long *pcountChildren)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accChildCount(long *pcountChildren)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accChildCount");

	if (_fShutDown)
		return CO_E_RELEASED;

    if (pcountChildren)
        *pcountChildren = CCHILDREN_COMBOBOX;
    return S_OK;
}


/*
 *	CCmbBxWinHost::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
 *
 *	@mfunc
 *		Retrieves the number of children belonging to the current object. 
 *
 *	@rdesc
 *		HRESULT = S_FALSE.
 */
STDMETHODIMP CCmbBxWinHost::get_accChild(VARIANT varChild, IDispatch **ppdispChild)
{
    TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::get_accChild");

	if (_fShutDown)
		return CO_E_RELEASED;

    // Validate
    if (!MSAA::ValidateChild(&varChild, CCHILDREN_COMBOBOX))
        return(E_INVALIDARG);

    InitPv(ppdispChild);
    HWND hwndChild = NULL;
    switch (varChild.lVal)
    {
        case INDEX_COMBOBOX:
            return E_INVALIDARG;

        //case INDEX_COMBOBOX_ITEM:
        //   hwndChild = _hwnd;
        //   break;

        case INDEX_COMBOBOX_LIST:
            hwndChild = _hwndList;
            break;
    }

    if (!hwndChild)
        return(S_FALSE);
    else
        return(W32->AccessibleObjectFromWindow(hwndChild, OBJID_WINDOW, IID_IDispatch, (void**)ppdispChild));
}


//////////////////////// CTxtWinHost IDispatch Methods ///////////////////////////
// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetTypeInfoCount()
//
//  This hands off to our typelib for IAccessible().  Note that
//  we only implement one type of object for now.  BOGUS!  What about IText?
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetTypeInfoCount(UINT * pctInfo)
{
    HRESULT hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        InitPv(pctInfo);
        *pctInfo = 1;
    }
    return(hr);
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetTypeInfo()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetTypeInfo(UINT itInfo, LCID lcid,
    ITypeInfo ** ppITypeInfo)
{
    HRESULT hr = InitTypeInfo();
    if (SUCCEEDED(hr))
    {
        if (ppITypeInfo == NULL)
            return(E_POINTER);

        InitPv(ppITypeInfo);

        if (itInfo != 0)
            return(TYPE_E_ELEMENTNOTFOUND);
        _pTypeInfo->AddRef();
        *ppITypeInfo = _pTypeInfo;
    }
    return(hr);
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::GetIDsOfNames()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::GetIDsOfNames(REFIID riid,
    OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgDispID)
{
    HRESULT hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(_pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgDispID));
}



// --------------------------------------------------------------------------
//
//  CTxtWinHost::Invoke()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTxtWinHost::Invoke(DISPID dispID, REFIID riid,
    LCID lcid, WORD wFlags, DISPPARAMS * pDispParams,
    VARIANT* pvarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
    HRESULT hr = InitTypeInfo();
    if (!SUCCEEDED(hr))
        return(hr);

    return(_pTypeInfo->Invoke((IAccessible *)this, dispID, wFlags,
        pDispParams, pvarResult, pExcepInfo, puArgErr));
}



#endif // NOACCESSIBILITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\makefile.inc ===
$(O)\w32sys.obj : w32sys.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\w32sys.cpp
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\ime.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module ime.cpp -- support for Win95 IME API |
 *	
 *		Most everything to do with FE composition string editing passes
 *		through here.
 *	
 *	Authors: <nl>
 *		Jon Matousek <nl>
 *		Hon Wah Chan <nl>
 *		Justin Voskuhl <nl>
 * 
 *	History: <nl>
 *		10/18/1995		jonmat	Cleaned up level 2 code and converted it into
 *								a class hierarchy supporting level 3.
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */				
#include "_common.h"
#ifndef NOFEPROCESSING
#include "msctf.h"
#include "textserv.h"
#include "_cmsgflt.h"				 
#include "_ime.h"
#include "imeapp.h"

#define HAVE_COMPOSITION_STRING() ( 0 != (lparam & (GCS_COMPSTR | GCS_COMPATTR)))
#define CLEANUP_COMPOSITION_STRING() ( 0 == lparam )
#define HAVE_RESULT_STRING() ( 0 != (lparam & GCS_RESULTSTR))

ASSERTDATA


/*
 *	HRESULT StartCompositionGlue (CTextMsgFilter &TextMsgFilter)
 *	
 *	@func
 *		Initiates an IME composition string edit.
 *	@comm
 *		Called from the message loop to handle WM_IME_STARTCOMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *
 *	@devnote
 *		We decide if we are going to do a level 2 or level 3 IME
 *		composition string edit. Currently, the only reason to 
 *		create a level 2 IME is if the IME has a special UI, or it is
 *		a "near caret" IME, such as the ones found in PRC and Taiwan.
 *		Near caret simply means that a very small window opens up
 *		near the caret, but not on or at the caret.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT StartCompositionGlue (
	CTextMsgFilter &TextMsgFilter)				// @parm containing message filter.

{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "StartCompositionGlue");

	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->IsTerminated()
		&& !TextMsgFilter._ime->_compMessageRefCount && !(TextMsgFilter._fHangulToHanja))
	{
		delete TextMsgFilter._ime;
		TextMsgFilter._ime = NULL;
	}

	if(!TextMsgFilter.IsIMEComposition())
	{
		if(TextMsgFilter._pTextSel->CanEdit(NULL) == NOERROR &&
			!TextMsgFilter.NoIMEProcess())
		{
			// Hold notification if needed
			if (!(TextMsgFilter._fIMEAlwaysNotify))
				TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);	
	
			// If a special UI, or IME is "near caret", then drop into lev. 2 mode.
			DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
			
			// use Unicode if not running under Win95
			TextMsgFilter._fUnicodeIME =
				(imeProperties & IME_PROP_UNICODE) && !W32->OnWin95();

			if ((imeProperties & IME_PROP_SPECIAL_UI) ||
				!(imeProperties & IME_PROP_AT_CARET))
			{
				TextMsgFilter._ime = new CIme_Lev2(TextMsgFilter);		// level 2 IME.
			}
			else
				TextMsgFilter._ime = new CIme_Lev3(TextMsgFilter);		// level 3 IME->TrueInline.
		}
		else													// Protect or read-only or NOFEPROCESSING:
			TextMsgFilter._ime = new CIme_Protected;			// Ignore all ime input
	}
	else
	{
		// Ignore further StartCompositionMsg.
		// Hanin 5.1 CHT symbol could cause multiple StartCompoisitonMsg.
		return S_OK;								
	}

	if(TextMsgFilter.IsIMEComposition())					
	{
		long		lSelFlags;
		HRESULT		hResult;
		
		hResult = TextMsgFilter._pTextSel->GetFlags(&lSelFlags);
		if (hResult == NOERROR)
		{
			TextMsgFilter._fOvertypeMode = !!(lSelFlags & tomSelOvertype);		
			if (TextMsgFilter._fOvertypeMode)
				TextMsgFilter._pTextSel->SetFlags(lSelFlags & ~tomSelOvertype);	// Turn off overtype mode
		}
		
		TextMsgFilter._pTextDoc->IMEInProgress(tomTrue);				// Inform client IME compostion in progress

		return TextMsgFilter._ime->StartComposition(TextMsgFilter);		// Make the method call.
	}
	else
		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

	
	return S_FALSE;
}

/*
 *	HRESULT CompositionStringGlue (const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *	
 *	@func
 *		Handle all intermediary and final composition strings.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_COMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *		We may be called independently of a WM_IME_STARTCOMPOSITION
 *		message, in which case we return S_FALSE to allow the
 *		DefWindowProc to return WM_IME_CHAR messages.
 *
 *	@devnote
 *		Side Effect: the _ime object may be deleted if composition
 *		string processing is finished.
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CompositionStringGlue (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CompositionStringGlue");

	HRESULT hr = S_FALSE;

	if(TextMsgFilter.IsIMEComposition())						// A priori fHaveIMMProcs.
	{
		TextMsgFilter._ime->_compMessageRefCount++;			// For proper deletion.
													// Make the method call.
		hr = TextMsgFilter._ime->CompositionString(lparam, TextMsgFilter);

		TextMsgFilter._ime->_compMessageRefCount--;			// For proper deletion.
		Assert (TextMsgFilter._ime->_compMessageRefCount >= 0);

		CheckDestroyIME (TextMsgFilter);						// Finished processing?
	}
	else // Even when not in composition mode, we may receive a result string.
	{
	
		DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
		long		lSelFlags;
		HRESULT		hResult;
		long		cpMin, cpMax;

		hResult = TextMsgFilter._pTextSel->GetFlags(&lSelFlags);
		if (hResult == NOERROR)
		{
			TextMsgFilter._fOvertypeMode = !!(lSelFlags & tomSelOvertype);		
			if (TextMsgFilter._fOvertypeMode)
				TextMsgFilter._pTextSel->SetFlags(lSelFlags & ~tomSelOvertype);	// Turn off overtype mode
		}

		// Use Unicode if not running under Win95
		TextMsgFilter._fUnicodeIME =
			(imeProperties & IME_PROP_UNICODE) && !W32->OnWin95();
		
		TextMsgFilter._pTextSel->GetStart(&cpMin);
		TextMsgFilter._pTextSel->GetEnd(&cpMax);
		
		if (cpMin != cpMax)			
			TextMsgFilter._pTextSel->SetText(NULL);							// Delete current selection

		CIme::CheckKeyboardFontMatching (cpMin, &TextMsgFilter, NULL);

		TextMsgFilter._pTextDoc->IMEInProgress(tomTrue);					// Inform client IME compostion in progress
		hr = CIme::CheckInsertResultString(lparam, TextMsgFilter);

		if(TextMsgFilter._fOvertypeMode)
			TextMsgFilter._pTextSel->SetFlags(lSelFlags | tomSelOvertype);	// Turn on overtype mode

		TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);					// Inform client IME compostion is done
	}

	return hr;
}

/*
 *	HRESULT EndCompositionGlue (CTextMsgFilter &TextMsgFilter, BOOL fForceDelete)
 *
 *	@func
 *		Composition string processing is about to end.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_ENDCOMPOSITION.
 *		This is a glue routine into the IME object hierarchy.
 *
 *	@devnote
 *		The only time we have to handle WM_IME_ENDCOMPOSITION is when the
 *		user changes input method during typing.  For such case, we will get
 *		a WM_IME_ENDCOMPOSITION message without getting a WM_IME_COMPOSITION
 *		message with GCS_RESULTSTR later.  So, we will call CompositionStringGlue
 *		with GCS_RESULTSTR to let CompositionString to get rid of the string. 
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT EndCompositionGlue (
	CTextMsgFilter &TextMsgFilter,				// @parm the containing message filter.
	BOOL fForceDelete)							// @parm forec to terminate
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "EndCompositionGlue");

	if(TextMsgFilter.IsIMEComposition())
	{
		// ignore the EndComposition message if necessary.  We may 
		// get this from 3rd party IME - EGBRIGDE after we have received
		// both result and composition strings.  
		if ( !(TextMsgFilter._ime->_fIgnoreEndComposition) )
		{
			// Set this flag. If we are still in composition mode, then
			// let the CompositionStringGlue() to destroy the ime object.
			TextMsgFilter._ime->_fDestroy = TRUE;

			if (!fForceDelete)				
				CompositionStringGlue(GCS_COMPSTR , TextMsgFilter);	// Remove any remaining composition string.

			// Finished with IME, destroy it.
			CheckDestroyIME(TextMsgFilter);

			// Turn on undo
			TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

			// Inform client IME compostion is done
			TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);				
		}
		else
		{
			// reset this so we will handle next EndComp msg
			TextMsgFilter._ime->_fIgnoreEndComposition = FALSE;
		}

		if(!TextMsgFilter.IsIMEComposition() && TextMsgFilter._fOvertypeMode)
		{
			long		lSelFlags;
			HRESULT		hResult;
			ITextSelection	*pLocalTextSel = TextMsgFilter._pTextSel;
			BOOL		fRelease = FALSE;

			if (!pLocalTextSel)
			{
				// Get the selection
				TextMsgFilter._pTextDoc->GetSelectionEx(&pLocalTextSel);
				fRelease = TRUE;
			}

			if (pLocalTextSel)
			{
				hResult = pLocalTextSel->GetFlags(&lSelFlags);
				if (hResult == NOERROR)
					pLocalTextSel->SetFlags(lSelFlags | tomSelOvertype);	// Turn on overtype mode

				if (fRelease)
					pLocalTextSel->Release();
			}
		}
	}
	return S_FALSE;
}

/*
 *	HIMC LocalGetImmContext ( CTextMsgFilter &TextMsgFilter )
 *
 *	@func
 *		Get Imm Context from host 
 *
 */
HIMC LocalGetImmContext(
	CTextMsgFilter &TextMsgFilter)
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "LocalGetImmContext");
	
	HIMC		hIMC = NULL;							// Host's IME context.
	HRESULT		hResult;

	hResult = TextMsgFilter._pTextDoc->GetImmContext((long *)&hIMC);

	if (hResult != NOERROR)
		hIMC = ImmGetContext(TextMsgFilter._hwnd, TextMsgFilter._fUsingAIMM);		// Get host's IME context.

	return hIMC;	
}

/*
 *	void LocalReleaseImmContext ( CTextMsgFilter &TextMsgFilter, HIMC hIMC )
 *
 *	@func
 *		call host to Release Imm Context
 *
 */
void LocalReleaseImmContext(
	CTextMsgFilter &TextMsgFilter, 
	HIMC hIMC )
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "LocalReleaseImmContext");

	HRESULT		hResult;

	hResult = TextMsgFilter._pTextDoc->ReleaseImmContext((long)hIMC);

	if (hResult != NOERROR)
		ImmReleaseContext(TextMsgFilter._hwnd, hIMC, TextMsgFilter._fUsingAIMM);
}

/*
 *	long IMEShareToTomUL ( UINT ulID )
 *
 *	@func
 *		Convert IMEShare underline to Tom underline.
 *
 *	@rdesc
 *		Tom underline value
 */
long IMEShareToTomUL ( 
	UINT ulID )
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEShareToTomUL");

	long lTomUnderline;

	switch (ulID)
	{
		case IMESTY_UL_NONE:
			lTomUnderline = tomNone;
			break;

		case IMESTY_UL_DOTTED:
			lTomUnderline = tomDotted;
			break;

		case IMESTY_UL_THICK:
		case IMESTY_UL_THICKLOWER:
			lTomUnderline = tomThick;
			break;

		case IMESTY_UL_DITHLOWER:
		case IMESTY_UL_THICKDITHLOWER:
			lTomUnderline = tomWave;
			break;

		// case IMESTY_UL_SINGLE:
		// case IMESTY_UL_LOWER:
		default:
			lTomUnderline = tomSingle;
			break;
	}

	return lTomUnderline;
}

/*
 *	void IMEMessage (CTextMsgFilter &TextMsgFilter , UINT uMsg, BOOL bPostMessage)
 *
 *	@func
 *		Either post or send message to IME 
 *
 */
BOOL IMEMessage(
	CTextMsgFilter &TextMsgFilter,
	UINT uMsg,
	WPARAM	wParam,
	LPARAM	lParam,
	BOOL bPostMessage)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMessage");
	
	HIMC	hIMC;									// Host's IME context.
	HWND	hwndIME;
	BOOL	fRetCode = FALSE;
	HWND	hHostWnd = TextMsgFilter._hwnd;
	long	hWnd;

	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;
		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.

	if(hIMC)
	{
		hwndIME = ImmGetDefaultIMEWnd(hHostWnd, TextMsgFilter._fUsingAIMM);
		LocalReleaseImmContext(TextMsgFilter, hIMC);

		// check if we want to send or post message
		if (hwndIME)
		{
			if (bPostMessage)
				fRetCode = PostMessage(hwndIME, uMsg, wParam, lParam);
			else
				fRetCode = SendMessage(hwndIME, uMsg, wParam, lParam);
		}
	}

	return fRetCode;
}


/*
 *	void CheckDestroyIME (CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		Check for IME and see detroy if it needs it..
 *
 */
void CheckDestroyIME (
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CheckDestroyIME");
	
	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->_fDestroy)
	{
		if(0 == TextMsgFilter._ime->_compMessageRefCount)
		{
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)	
			{
				TextMsgFilter._pTextDoc->SetCaretType(tomNormalCaret);		// Reset Block caret mode	
				TextMsgFilter._fHangulToHanja = FALSE;					// Reset korean conversion mode
			}

		 	delete TextMsgFilter._ime;									// All done with object.
			TextMsgFilter._ime = NULL;

			TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);		// Turn on Notification
		}
	}
}

/*
 *	void PostIMECharGlue (CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		Called after processing a single WM_IME_CHAR in order to
 *		update the position of the IME's composition window. This
 *		is glue code to call the CIME virtual equivalent.
 */
void PostIMECharGlue (
	CTextMsgFilter &TextMsgFilter)				// @parm containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "PostIMECharGlue");

	if(TextMsgFilter.IsIMEComposition())
		TextMsgFilter._ime->PostIMEChar(TextMsgFilter);
}

/*
 *	BOOL	IMEMouseCheck(CTextMsgFilter &TextMsgFilter, UINT *pmsg, 
 *				WPARAM *pwparam, LPARAM *plparam, LRESULT *plres)
 *
 *	@func
 *		Called when receiving a mouse event.  Need to pass this event
 *		to MSIME98 for composition handling
 *
 */
HRESULT IMEMouseCheck(
	CTextMsgFilter &TextMsgFilter,	// @parm MsgFilter
	UINT *pmsg,						// @parm the message 
	WPARAM *pwparam,				// @parm WParam
	LPARAM *plparam,				// @parm LParam
	LRESULT *plres)					// @parm Lresult			
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEMouseCheck");

	BOOL fRetCode = FALSE;
	if(TextMsgFilter.IsIMEComposition())
	{
		BOOL	fTerminateIME;
		fRetCode = TextMsgFilter._ime->IMEMouseOperation(TextMsgFilter, *pmsg, *pwparam, fTerminateIME);

		if ( fTerminateIME && WM_MOUSEMOVE != *pmsg )
			TextMsgFilter._ime->TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_NORMAL);
	}

	return fRetCode ? S_OK : S_FALSE;
}

/*
 *	HRESULT IMENotifyGlue (const WPARAM wparam, const LPARAM lparam,
 *				CTextMsgFilter &TextMsgFilter)
 *
 *	@func
 *		IME is going to change some state.
 *
 *	@comm
 *		Currently we are interested in knowing when the candidate
 *		window is about to be opened.
 *		
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT IMENotifyGlue (
	const WPARAM wparam,		// @parm associated with message.
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMENotifyGlue");

	if (TextMsgFilter._fRE10Mode &&
		(wparam == IMN_SETCONVERSIONMODE ||
		wparam == IMN_SETSENTENCEMODE ||
		wparam == IMN_SETOPENSTATUS))
	{
		TextMsgFilter._pTextDoc->Notify(EN_IMECHANGE);			
	}
	else if(TextMsgFilter.IsIMEComposition())						// A priori fHaveIMMProcs.
		return TextMsgFilter._ime->IMENotify(wparam, lparam, TextMsgFilter, FALSE);// Make the method call
	
	return S_FALSE;
}

/*
 *	void IMECompositionFull (&TextMsgFilter)
 *
 *	@func
 *		Current IME Composition window is full.
 *
 *	@comm
 *		Called from the message loop to handle WM_IME_COMPOSITIONFULL.
 *		This message applied to Level 2 only.  We will use the default 
 *		IME Composition window.
 */
void IMECompositionFull (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMECompositionFull");

	if(TextMsgFilter.IsIMEComposition())
	{
		HIMC 				hIMC	= LocalGetImmContext(TextMsgFilter);
		COMPOSITIONFORM		cf;

		if(hIMC)
		{																									 
			// No room for text input in the current level 2 IME window, 
			// fall back to use the default IME window for input.
			cf.dwStyle = CFS_DEFAULT;
			ImmSetCompositionWindow(hIMC, &cf, TextMsgFilter._fUsingAIMM);	// Set composition window.
			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
 	}
}

/*
 *	LRESULT OnGetIMECompositionMode (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Returns whether or not IME composition is being handled by RE,
 *		and if so, what level of processing.
 *		
 *	@rdesc
 *		One of ICM_NOTOPEN, ICM_LEVEL2_5, ICM_LEVEL2_SUI, ICM_LEVEL2, ICM_LEVEL3.
 */
LRESULT OnGetIMECompositionMode (
	CTextMsgFilter &TextMsgFilter)	  	// @parm containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "OnGetIMECompositionMode");

	if(TextMsgFilter.IsIMEComposition())
		return TextMsgFilter._ime->GetIMECompositionMode(TextMsgFilter);

	return ICM_NOTOPEN;
}

/*
 *	LRESULT TestPoint (&pt1, &pt2, &ptTest, lTestOption, lTextFlow)
 *
 *	@mfunc
 *		Returns which side the ptTest is relative to the line (pt1, pt2) based on the lTextFlow.
 *
 *	@rdesc
 *		Sides detected
 */
LONG TestPoint( 
	POINT &pt1, 
	POINT &pt2, 
	POINT &ptTest, 
	LONG lTestOption, 
	LONG lTextFlow)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "TestPoint");

	LONG lSidesDetect = 0;

	switch (lTextFlow)
	{
		case tomTextFlowES:

			if (lTestOption & TEST_LEFT)
				lSidesDetect |= (ptTest.x < pt1.x) ? TEST_LEFT : 0;

			if (lTestOption & TEST_RIGHT)
				lSidesDetect |= (ptTest.x > pt1.x) ? TEST_RIGHT : 0;

			if (lTestOption & TEST_TOP)
				lSidesDetect |= (ptTest.y < pt1.y) ? TEST_TOP : 0;

			if (lTestOption & TEST_BOTTOM)
				lSidesDetect |= (ptTest.y > pt2.y) ? TEST_BOTTOM : 0;

			break;

		case tomTextFlowSW:

			if (lTestOption & TEST_LEFT)
				lSidesDetect |= (ptTest.y < pt1.y) ? TEST_LEFT : 0;

			if (lTestOption & TEST_RIGHT)
				lSidesDetect |= (ptTest.y > pt1.y) ? TEST_RIGHT : 0;

			if (lTestOption & TEST_TOP)
				lSidesDetect |= (ptTest.x > pt1.x) ? TEST_TOP : 0;

			if (lTestOption & TEST_BOTTOM)
				lSidesDetect |= (ptTest.x < pt2.x) ? TEST_BOTTOM : 0;

			break;

		case tomTextFlowWN:

			if (lTestOption & TEST_LEFT)
				lSidesDetect |= (ptTest.x > pt1.x) ? TEST_LEFT : 0;

			if (lTestOption & TEST_RIGHT)
				lSidesDetect |= (ptTest.x < pt1.x) ? TEST_RIGHT : 0;

			if (lTestOption & TEST_TOP)
				lSidesDetect |= (ptTest.y > pt1.y) ? TEST_TOP : 0;

			if (lTestOption & TEST_BOTTOM)
				lSidesDetect |= (ptTest.y < pt2.y) ? TEST_BOTTOM : 0;

			break;

		case tomTextFlowNE:

			if (lTestOption & TEST_LEFT)
				lSidesDetect |= (ptTest.y > pt1.y) ? TEST_LEFT : 0;

			if (lTestOption & TEST_RIGHT)
				lSidesDetect |= (ptTest.y < pt1.y) ? TEST_RIGHT : 0;

			if (lTestOption & TEST_TOP)
				lSidesDetect |= (ptTest.x < pt1.x) ? TEST_TOP : 0;

			if (lTestOption & TEST_BOTTOM)
				lSidesDetect |= (ptTest.x > pt2.x) ? TEST_BOTTOM : 0;

			break;
	}
	return lSidesDetect;
}

/*
 *	void CIme::CheckKeyboardFontMatching (long cp, CTextMsgFilter &TextMsgFilter, ITextFont	*pTextFont)
 *	
 *	@mfunc
 *		Setup current font to matches the keyboard Codepage.
 *
 *	@comm
 *		Called from CIme_Lev2::CIme_Lev2 and CompositionStringGlue
 *
 *	@devnote
 *		We need to switch to a preferred font for the keyboard during IME input.
 *		Otherwise, we will display garbage.
 *		
 */
void CIme::CheckKeyboardFontMatching (
	long cp,
	CTextMsgFilter *pTextMsgFilter, 
	ITextFont	*pTextFont)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::CheckKeyboardFontMatching");

	long	lPitchAndFamily;
	HRESULT	hResult;
	BSTR	bstr = NULL;
	long	lValue;
	long	lNewFontSize=0;
	float	nFontSize;
	ITextFont *pLocalFont = NULL;

	if (!pTextMsgFilter)
		return;

	if (!pTextFont)
	{	
		// No font supplied, get current font from selection
		hResult = pTextMsgFilter->_pTextSel->GetFont(&pLocalFont);			
		
		if (hResult != S_OK || !pLocalFont)		// Can't get font, forget it
			return;			

		pTextFont = pLocalFont;
	}

	// Check if current font matches the keyboard
	lValue = tomCharset;
	hResult = pTextFont->GetLanguageID(&lValue);
	BYTE bCharSet = (BYTE)lValue;
	BYTE bCharSetKB = GetCharSet(pTextMsgFilter->_uKeyBoardCodePage);

	if (hResult == S_OK && bCharSet == bCharSetKB)
		goto Exit;								// Current font is fine

	hResult = pTextFont->GetSize(&nFontSize);

	if (hResult != S_OK)
		goto Exit;

	hResult = pTextMsgFilter->_pTextDoc->GetPreferredFont(cp, 
		pTextMsgFilter->_uKeyBoardCodePage, tomMatchFontCharset, 
		CodePageFromCharRep(CharRepFromCharSet(bCharSet)), (long)nFontSize,
		&bstr, &lPitchAndFamily, &lNewFontSize);

	if (hResult == S_OK)
	{	
		pTextFont->Reset(tomApplyLater);		

		if (bstr)
			pTextFont->SetName(bstr);

		// Set the font charset and Pitch&Family by overloading the SetLanguageID i/f			
		lValue = tomCharset + ((BYTE)lPitchAndFamily << 8) + bCharSetKB;
		pTextFont->SetLanguageID(lValue);				
		
		if (lNewFontSize)
			pTextFont->SetSize((float)lNewFontSize);

		pTextFont->Reset(tomApplyNow);
	}

Exit:
	if (pLocalFont)
			pLocalFont->Release();
	
	if (bstr)
		SysFreeString(bstr);
}

/*
 *	INT CIme::GetCompositionStringInfo(HIMC hIMC, DWORD dwIndex,
 *			  WCHAR *szCompStr, INT cchMax, BYTE *attrib, INT cbAttrib
 *			  LONG cchAttrib, UINT kbCodePage, BOOL bUnicodeIME)
 *
 *	@mfunc
 *		For WM_IME_COMPOSITION string processing to get the requested
 *		composition string, by type, and convert it to Unicode.
 *
 *	@devnote
 *		We must use ImmGetCompositionStringA because W is not supported
 *		on Win95.
 *		
 *	@rdesc
 *		INT-cch of the Unicode composition string.
 *		Out param in szCompStr.
 */
INT CIme::GetCompositionStringInfo(
	HIMC hIMC,			// @parm IME context provided by host.
	DWORD dwIndex,		// @parm The type of composition string.
	WCHAR *szCompStr,	// @parm Out param, unicode result string.
	INT cchMax,			// @parm The cch for the Out param.
	BYTE *attrib,		// @parm Out param, If attribute info is needed.
	INT cbMax,			// @parm The cb of the attribute info.
	LONG *cpCursor,		// @parm Out param, returns the CP of cusor.
	LONG *cchAttrib,	// @parm how many attributes returned.
	UINT kbCodePage,	// @parm codepage
	BOOL bUnicodeIME,	// @parm Unciode IME
	BOOL bUsingAimm)	// @parm Using Aimm
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::GetCompositionStringInfo");

	BYTE	compStr[256], attribInfo[256];
	INT		i, j, iMax, cchCompStr=0, cbAttrib, cursor;
	INT		cchAnsiCompStr=0;

	Assert(hIMC && szCompStr);

	if(cpCursor)									// Init cursor out param.
		*cpCursor = -1;
	if(cchAttrib)
		*cchAttrib = 0;
													// Get composition string.
	if (bUnicodeIME)
		cchCompStr = ImmGetCompositionStringW(hIMC, dwIndex, szCompStr, cchMax, bUsingAimm )/sizeof(WCHAR);
	else
		cchAnsiCompStr = ImmGetCompositionStringA(hIMC, dwIndex, compStr, 255, bUsingAimm);

	if(cchAnsiCompStr > 0 || cchCompStr > 0)		// If valid data.
	{
		if (!bUnicodeIME)
		{
			Assert(cchAnsiCompStr >> 1 < cchMax - 1);		// Convert to Unicode.
			cchCompStr = UnicodeFromMbcs(szCompStr, cchMax,
					(CHAR *) compStr, cchAnsiCompStr, kbCodePage);
		}

		if(attrib || cpCursor)						// Need cursor or attribs?
		{
			if (bUnicodeIME)
			{										// Get Unicode Cursor cp.
				cursor = ImmGetCompositionStringW(hIMC, GCS_CURSORPOS, NULL, 0, bUsingAimm);
													// Get Unicode attributes.
				cbAttrib = ImmGetCompositionStringW(hIMC, GCS_COMPATTR,
								attribInfo, 255, bUsingAimm);

				iMax = max(cursor, cbAttrib);
				iMax = min(iMax, cchCompStr);
			}
			else
			{										// Get DBCS Cursor cp.
				cursor = ImmGetCompositionStringA(hIMC, GCS_CURSORPOS, NULL, 0, bUsingAimm);
													// Get DBCS attributes.
				cbAttrib = ImmGetCompositionStringA(hIMC, GCS_COMPATTR,
								attribInfo, 255, bUsingAimm);

				iMax = max(cursor, cbAttrib);
				iMax = min(iMax, cchAnsiCompStr);
			}

			if(NULL == attrib)
				cbMax = cbAttrib;

			for(i = 0, j = 0; i <= iMax && j < cbMax; i++, j++)
			{
				if(cursor == i)
					cursor = j;

				if(!bUnicodeIME && GetTrailBytesCount(compStr[i], kbCodePage))
					i++;

				if(attrib && i < cbAttrib)
					*attrib++ = attribInfo[i];
			}
													// attrib cch==unicode cch
			Assert(0 >= cbAttrib || j-1 == cchCompStr);

			if(cursor >= 0 && cpCursor)				// If client needs cursor
				*cpCursor = cursor;					//  or cchAttrib.
			if(cbAttrib >= 0 && cchAttrib)
				*cchAttrib = j-1;
		}
	}
	else
	{
		if(cpCursor)
			*cpCursor = 0;
		cchCompStr = 0;
	}
	return cchCompStr;
}

/*
 *	void CIme::SetCompositionFont (CTextMsgFilter &TextMsgFilter, ITextFont *pTextFont)
 *
 *	@mfunc
 *		Important for level 2 IME so that the composition window
 *		has the correct font. The lfw to lfa copy is due to the fact that
 *		Win95 does not support the W)ide call.
 *		It is also important for both level 2 and level 3 IME so that
 *		the candidate list window has the proper. font.
 */
void CIme::SetCompositionFont (
	CTextMsgFilter &TextMsgFilter,		// @parm the containing message filter.
	ITextFont *pTextFont) 		 		// @parm ITextFont for setting lfa.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::SetCompositionFont");
	
	HIMC 		hIMC;
	LOGFONTA	lfa;

	if (pTextFont)
	{
		hIMC = LocalGetImmContext(TextMsgFilter);
		if (hIMC)
		{
			// Build the LOGFONT based on pTextFont
			float	FontSize;
			long	lValue;
			BSTR	bstr;
			long	lTextFlow;

			memset (&lfa, 0, sizeof(lfa));

			if (pTextFont->GetSize(&FontSize) == NOERROR)			
				lfa.lfHeight = (LONG) FontSize;			
			
			if (pTextFont->GetBold(&lValue) == NOERROR && lValue == tomTrue)
				lfa.lfWeight = FW_BOLD;

			if (pTextFont->GetItalic(&lValue) == NOERROR && lValue == tomTrue)
				lfa.lfItalic = TRUE;

			lfa.lfCharSet = (BYTE)GetCharSet(TextMsgFilter._uKeyBoardCodePage);

			lValue = tomCharset;
			if (pTextFont->GetLanguageID(&lValue) == NOERROR && 
				lfa.lfCharSet == (BYTE)lValue)
				lfa.lfPitchAndFamily = (BYTE)(lValue >> 8);

			if (pTextFont->GetName(&bstr) == NOERROR)
			{
				if ((TextMsgFilter._lFEFlags & tomUseAtFont) && bstr[0] != L'@')
				{
					lfa.lfFaceName[0] = '@';
					MbcsFromUnicode(&(lfa.lfFaceName[1]), sizeof(lfa.lfFaceName)-1, bstr,
						-1, CP_ACP, UN_NOOBJECTS);
				}
				else				
					MbcsFromUnicode(lfa.lfFaceName, sizeof(lfa.lfFaceName), bstr,
						-1, CP_ACP, UN_NOOBJECTS);	

				SysFreeString(bstr);
			}

			lTextFlow = TextMsgFilter._lFEFlags & tomTextFlowMask;
			if (lTextFlow)
			{
				DWORD imeUIProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_UI, TextMsgFilter._fUsingAIMM);

				if (imeUIProperties & (UI_CAP_2700 | UI_CAP_ROT90 | UI_CAP_ROTANY))
				{
					if (lTextFlow == tomTextFlowSW)
						lfa.lfOrientation = lfa.lfEscapement = 2700;
					else if (lTextFlow == tomTextFlowNE)
						lfa.lfOrientation = lfa.lfEscapement = 900;
				}
			}

			ImmSetCompositionFontA( hIMC, &lfa, TextMsgFilter._fUsingAIMM );

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.		
		}
	}
}

/*
 *	void CIme::SetCompositionForm (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Important for level 2 IME so that the composition window
 *		is positioned correctly. 
 *
 *	@comm
 *		We go through a lot of work to get the correct height. This requires
 *		getting information from the font cache and the selection.
 */
void CIme::SetCompositionForm (
	CTextMsgFilter &TextMsgFilter)	   	// @parm the containing text edit.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::SetCompositionForm");

	HIMC 				hIMC;
	COMPOSITIONFORM		cf;

	if(IME_LEVEL_2 == GetIMELevel())
	{
		hIMC = LocalGetImmContext(TextMsgFilter);					// Get IME context.
		
		if(hIMC)
		{				
			// get the location of cpMin
			cf.ptCurrentPos.x = cf.ptCurrentPos.y = 0;
			TextMsgFilter._pTextSel->GetPoint( tomStart+tomClientCoord+TA_BOTTOM+TA_LEFT,
				&(cf.ptCurrentPos.x), &(cf.ptCurrentPos.y) );			
			
			// Set-up bounding rect. for the IME (lev 2) composition window, causing
			// composition text to be wrapped within it.
			cf.dwStyle = CFS_RECT;
			TextMsgFilter._pTextDoc->GetClientRect(tomIncludeInset+tomClientCoord,
				&(cf.rcArea.left), &(cf.rcArea.top),
				&(cf.rcArea.right), &(cf.rcArea.bottom));		 

			// Make sure the starting point is not
			// outside the rcArea.  This happens when
			// there is no text on the current line and the user 
			// has selected a large font size.
			if(cf.ptCurrentPos.y < cf.rcArea.top)
				cf.ptCurrentPos.y = cf.rcArea.top;
			else if(cf.ptCurrentPos.y > cf.rcArea.bottom)
				cf.ptCurrentPos.y = cf.rcArea.bottom; 

			if(cf.ptCurrentPos.x < cf.rcArea.left)
				cf.ptCurrentPos.x = cf.rcArea.left;
			else if(cf.ptCurrentPos.x > cf.rcArea.right)
				cf.ptCurrentPos.x = cf.rcArea.right;

			ImmSetCompositionWindow(hIMC, &cf, TextMsgFilter._fUsingAIMM);	// Set composition window.

			LocalReleaseImmContext(TextMsgFilter, hIMC);				// Done with IME context.
		}
	}
}



/*
 *
 *	CIme::TerminateIMEComposition (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	Terminate the IME Composition mode using CPS_COMPLETE
 *	@comm	The IME will generate WM_IME_COMPOSITION with the result string
 * 
 */
void CIme::TerminateIMEComposition(
	CTextMsgFilter &TextMsgFilter, 			// @parm the containing message filter.
	TerminateMode mode)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::TerminateIMEComposition");
	DWORD dwTerminateMethod;

	HIMC hIMC = LocalGetImmContext(TextMsgFilter);

	if(TextMsgFilter.IsIMEComposition() && TextMsgFilter._ime->IsTerminated())
	{
		// Turn if off now
		EndCompositionGlue(TextMsgFilter, TRUE);
		return;
	}

	_fIMETerminated = TRUE;

	if (mode == TERMINATE_FORCECANCEL)
		TextMsgFilter._pTextDoc->IMEInProgress(tomFalse);		// Inform client IME compostion is done

	dwTerminateMethod = CPS_COMPLETE;
	if (IME_LEVEL_2 == GetIMELevel()  ||	// force cancel for near-caret IME
		mode == TERMINATE_FORCECANCEL ||	// caller wants force cancel
		TextMsgFilter._fIMECancelComplete)				// Client wants force cancel
	{
		dwTerminateMethod = CPS_CANCEL;
	}
	
	// force the IME to terminate the current session
	if(hIMC)
	{
		BOOL fRetCode;

		fRetCode = ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, 
			dwTerminateMethod, 0, TextMsgFilter._fUsingAIMM);
		
		if(!fRetCode && !TextMsgFilter._fIMECancelComplete)
		{
			// CPS_COMPLETE fail, try CPS_CANCEL.  This happen with some ime which do not support
			// CPS_COMPLETE option (e.g. ABC IME version 4 with Win95 simplified Chinese)
			fRetCode = ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, 0, TextMsgFilter._fUsingAIMM);

		}

		LocalReleaseImmContext(TextMsgFilter, hIMC);
	}
	else
	{
		// for some reason, we didn't have a context, yet we thought we were still in IME
		// compostition mode.  Just force a shutdown here.
		EndCompositionGlue(TextMsgFilter, TRUE);
	}
}


/*
 *	CIme_Lev2::CIme_Lev2()
 *
 *	@mfunc
 *		CIme_Lev2 Constructor/Destructor.
 *
 *	@comm
 *		Needed to make sure _iFormatSave was handled properly.
 *
 */
CIme_Lev2::CIme_Lev2(	
	CTextMsgFilter &TextMsgFilter)		// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::CIme_Lev2");

	long		cpMin, cpMax, cpLoc;
	HRESULT		hResult;
	ITextFont	*pCurrentFont = NULL;

	_pTextFont = NULL;
	_cIgnoreIMECharMsg = 0;

	// setup base Font format for later use during composition
	hResult	= TextMsgFilter._pTextSel->GetStart(&cpMin);
	cpLoc = cpMin;	

	if (TextMsgFilter._fHangulToHanja)
		cpMax = cpMin + 1;				// Select the Hangul character
	else
		hResult	= TextMsgFilter._pTextSel->GetEnd(&cpMax);

	_fSkipFirstOvertype = FALSE;
	if (cpMax != cpMin)
	{
		// selection case, get format for at cpMin
		ITextRange *pTextRange;
		HRESULT		hResult;
				
		hResult = TextMsgFilter._pTextDoc->Range(cpMin, cpMin+1, &pTextRange);
		Assert (pTextRange != NULL);
		
		if (hResult == NOERROR && pTextRange)
		{
			pTextRange->GetFont(&pCurrentFont);
			Assert(pCurrentFont != NULL);		
			pTextRange->Release();
			cpLoc = cpMin+1;
		}	

		if (!TextMsgFilter._fHangulToHanja)
			_fSkipFirstOvertype = TRUE;			// For Korean Overtype support
	}
	
	if (!pCurrentFont)
		TextMsgFilter._pTextSel->GetFont(&pCurrentFont);

	Assert(pCurrentFont != NULL);

	pCurrentFont->GetDuplicate(&_pTextFont);		// duplicate the base format for later use
	pCurrentFont->Release();
	Assert(_pTextFont != NULL);
		
	// setup font to match current keyboard
	CIme::CheckKeyboardFontMatching (cpLoc, &TextMsgFilter, _pTextFont);

	_fIgnoreEndComposition = FALSE;
	
	_fIMETerminated = FALSE;
}

CIme_Lev2::~CIme_Lev2()
{
	if ( _pTextFont )
		_pTextFont->Release();
}

/*
 *	HRESULT CIme_Lev2::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin IME Level 2 composition string processing.		
 *
 *	@comm
 *		Set the font, and location of the composition window which includes
 *		a bounding rect and the start position of the cursor. Also, reset
 *		the candidate window to allow the IME to set its position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev2::StartComposition(
	CTextMsgFilter &TextMsgFilter)		// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::StartComposition");

	_imeLevel = IME_LEVEL_2;

	SetCompositionFont(TextMsgFilter, _pTextFont);	// Set font, & comp window.
	SetCompositionForm(TextMsgFilter);

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *	HRESULT CIme_Lev2::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 2 WM_IME_COMPOSITION messages.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing.  
 *		
 *		Side effect: 
 *			The Host needs to mask out the lparam before calling DefWindowProc to
 *			prevent unnessary WM_IME_CHAR messages.
 */
HRESULT CIme_Lev2::CompositionString (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::CompositionString");

	_cIgnoreIMECharMsg = 0;
	if(HAVE_RESULT_STRING())
	{
		_fGotFinalString = TRUE;

		if (_pTextFont)
		{
			// setup the font before insert final string
			ITextFont *pFETextFont=NULL;

			_pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			TextMsgFilter._pTextSel->SetFont(pFETextFont);
			pFETextFont->Release();
		}

		TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

		CheckInsertResultString(lparam, TextMsgFilter, &_cIgnoreIMECharMsg);
		SetCompositionForm(TextMsgFilter);			// Move Composition window.
		
	}

	// Always return S_FALSE so the DefWindowProc will handle the rest.
	// Host has to mask out the ResultString bit to avoid WM_IME_CHAR coming in.
	return S_FALSE;																	
}

/*
 *	HRESULT CIme::CheckInsertResultString (const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		handle inserting of GCS_RESULTSTR text, the final composed text.
 *
 *	@comm
 *		When the final composition string arrives we grab it and set it into the text.
 *
 *	@devnote
 *		A GCS_RESULTSTR message can arrive and the IME will *still* be in
 *		composition string mode. This occurs because the IME's internal
 *		buffers overflowed and it needs to convert the beginning of the buffer
 *		to clear out some room.	When this happens we need to insert the
 *		converted text as normal, but remain in composition processing mode.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme::CheckInsertResultString (
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	short	*pcch,					// @parm number of character read
	int		*pcbOutBuff,			// @parm byte size of the output buffer
	WCHAR	*pOutBuff)				// @parm buffer to receive the text
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme::CheckInsertResultString");

	HRESULT			hr = S_FALSE;
	HIMC 			hIMC;
	INT				cch;
	WCHAR			szCompStr[256];

	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING())	// If result string..
	{
		hIMC = LocalGetImmContext(TextMsgFilter);				// Get host's IME context.

		cch = 0;
		if(hIMC)												// Get result string.
		{
			cch = GetCompositionStringInfo(hIMC, pOutBuff ? GCS_RESULTREADSTR : GCS_RESULTSTR, 
							szCompStr,
							sizeof(szCompStr)/sizeof(szCompStr[0]),
							NULL, 0, NULL, NULL, TextMsgFilter._uKeyBoardCodePage, 
							TextMsgFilter._fUnicodeIME, TextMsgFilter._fUsingAIMM);

			if (pcch)
				*pcch = (short)cch;

			cch = min (cch, 255);
			szCompStr[cch] = L'\0';
			LocalReleaseImmContext(TextMsgFilter, hIMC);		// Done with IME context.
		}

		// Don't need to replace range when there isn't any text. Otherwise, the character format is
		// reset to previous run.
		if(cch)
		{
			if (pOutBuff)
			{
				if (*pcbOutBuff > (int) ((cch + 1) * sizeof(WCHAR)))
					*pcbOutBuff = (cch + 1) * sizeof(WCHAR);

				memcpy(pOutBuff, szCompStr, *pcbOutBuff);
			}
			else
			{
				BSTR bstr = SysAllocString(szCompStr);
				if (!bstr)
					return E_OUTOFMEMORY;

				TextMsgFilter._pTextSel->TypeText(bstr);
				SysFreeString(bstr);
			}
		}
		else if (pOutBuff)
			*pcbOutBuff = 0;

		hr = S_OK;												// Don't want WM_IME_CHARs.
		
	}

	return hr;
}

/*
 *	HRESULT CIme_Lev2::IMENotify(const WPARAM wparam, const LPARAM lparam,
 *					CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 2 WM_IME_NOTIFY messages.
 *
 *	@comm
 *		Currently we are only interested in knowing when to reset
 *		the candidate window's position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev2::IMENotify(
	const WPARAM wparam,			// @parm associated with message.
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	BOOL fIgnore)					// @parm Level3 Chinese Composition window only
{
 	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::IMENotify");

	if(IMN_OPENCANDIDATE == wparam)
	{
		Assert (0 != lparam);

		HIMC			hIMC;							// Host's IME context.

		INT				index;							// Candidate window index.
		CANDIDATEFORM	cdCandForm;

		hIMC = LocalGetImmContext(TextMsgFilter);				// Get host's IME context.

		if(hIMC)
		{
													// Convert bitID to INDEX.
			for (index = 0; index < 32; index++)	//  because *stupid* API.
			{
				if((1 << index) & lparam)
					break;
			}
			Assert (((1 << index) & lparam) == lparam);	// Only 1 set?
			Assert (index < 32);						
													// Reset to CFS_DEFAULT
			if(ImmGetCandidateWindow(hIMC, index, &cdCandForm, TextMsgFilter._fUsingAIMM)
					&& CFS_DEFAULT != cdCandForm.dwStyle)
			{
				cdCandForm.dwStyle = CFS_DEFAULT;
				ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
	}	

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *	void CIme_Lev2::PostIMEChar (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Called after processing a single WM_IME_CHAR in order to
 *		update the position of the IME's composition window.		
 *
 */
void CIme_Lev2::PostIMEChar (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
 	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::PostIMEChar");

	SetCompositionForm(TextMsgFilter);						// Move Composition window.
}

/*
 *
 *	CIme_Lev2::IMEMouseOperation (CTextMsgFilter &TextMsgFilter, UINT msg, BOOL	&fTerminateIME)
 *
 *	@mfunc	Level 2 IME does not handle the mouse events, we need to check if
 *		we should terminate IME.
 *
 *	@rdesc
 *		BOOL-FALSE since Level 2 IME does not handle the mouse events
 *		fTermineateIME-TRUE if we want to terminateIME
 *
 */
BOOL CIme_Lev2::IMEMouseOperation(
	CTextMsgFilter	&TextMsgFilter, 		// @parm the containing message filter.
	UINT			msg,					// @parm message id
	WPARAM			wParam,					// @parm wparam
	BOOL			&fTerminateIME)			// @parm need to terminate IME					
	
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::IMEMouseOperation");

	// Level 2 IME, check if we need to terminate IME
	fTerminateIME = FALSE;
	switch(msg)
	{
		case WM_LBUTTONDOWN:
 		case WM_LBUTTONDBLCLK:
 		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
 		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
			fTerminateIME = TRUE;
	}
	return FALSE;
}

/*
 *
 *	CIme_Lev2::GetIMECompositionMode (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	Return the current IME composition mode when we haven't received any final string
 *
 *	@rdesc
 *			IME Level
 * 
 */
LRESULT  CIme_Lev2::GetIMECompositionMode(
	CTextMsgFilter &TextMsgFilter)			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev2::GetIMECompositionMode");

	LRESULT lres = ICM_NOTOPEN;

	if (!_fGotFinalString)
	{
		DWORD imeProperties;

		imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_PROPERTY, TextMsgFilter._fUsingAIMM);
		if(imeProperties & IME_PROP_AT_CARET)
			lres = ICM_LEVEL2_5;				// level 2.5.
		else if	(imeProperties & IME_PROP_SPECIAL_UI)
			lres = ICM_LEVEL2_SUI;				// special UI.
		else
			lres = ICM_LEVEL2;					// stock level 2.
	}

	return lres;
}

/*
 *	CIme_Lev3::CIme_Lev3()
 *
 *	@mfunc
 *		CIme_Lev3 Constructor/Destructor.
 *
 */
CIme_Lev3::CIme_Lev3(	
	CTextMsgFilter &TextMsgFilter) : CIme_Lev2 ( TextMsgFilter )
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::CIme_Lev3");

	_sIMESuportMouse = 0;		// initial to 0 so we will check mouse operation if need
	_wParamBefore = 0;
	_fUpdateWindow = FALSE;
}

/*
 *	HRESULT CIme_Lev3::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin IME Level 3 composition string processing.		
 *
 *	@comm
 *		For rudimentary processing, remember the start and
 *		length of the selection. Set the font in case the
 *		candidate window actually uses this information.
 *
 *	@rdesc
 *		This is a rudimentary solution for remembering were
 *		the composition is in the text. There needs to be work
 *		to replace this with a composition "range".
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::StartComposition(
	CTextMsgFilter &TextMsgFilter)			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::StartComposition");
	long	cpMin;
	TextMsgFilter._pTextSel->GetStart(&cpMin);

	_ichStart = cpMin;
	_cchCompStr		= 0;
	_imeLevel		= IME_LEVEL_3;

	SetCompositionFont (TextMsgFilter, _pTextFont);	

	// Delete current selection
	TextMsgFilter._pTextSel->SetText(NULL);
	
	// turn off undo
	TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

	if (_pTextFont)
	{
		_pTextFont->GetForeColor(&_crTextColor);
		_pTextFont->GetBackColor(&_crBkColor);
	}

	// Setup IMEShare Lid if necessary
	if (!TextMsgFilter._fRE10Mode && 
		TextMsgFilter._uKeyBoardCodePage != CP_KOREAN &&
		W32->HaveIMEShare())
	{
		CIMEShare *pIMEShare;
		if (W32->getIMEShareObject(&pIMEShare))
		{
			LID hKL = (LID)GetKeyboardLayout(0x0FFFFFFFF);
			if (pIMEShare->LidGetLid() != hKL)
				pIMEShare->LidSetLid(hKL);
		}
	}

	return S_OK;									// No DefWindowProc
}													//  processing.

/*
 *	HRESULT CIme_Lev3::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 3 WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		Display all of the intermediary composition text as well as the final
 *		reading.
 *
 *	@devnote
 *		This is a rudimentary solution for replacing text in the backing store.
 *		Work is left to do with the undo list, underlining, and hiliting with
 *		colors and the selection.	
 *		
 *	@devnote
 *		A GCS_RESULTSTR message can arrive and the IME will *still* be in
 *		composition string mode. This occurs because the IME's internal
 *		buffers overflowed and it needs to convert the beginning of the buffer
 *		to clear out some room.	When this happens we need to insert the
 *		converted text as normal, but remain in composition processing mode.
 *
 *		Another reason, GCS_RESULTSTR can occur while in composition mode
 *		for Korean because there is only 1 correct choice and no additional 
 *		user intervention is necessary, meaning that the converted string can
 *		be sent as the result before composition mode is finished.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::CompositionString(
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::CompositionString");
	
	long	cpMin;
	
	_fIgnoreEndComposition = FALSE;

	if (_fUpdateWindow)
	{
		TextMsgFilter._pTextDoc->UpdateWindow();
		_fUpdateWindow = FALSE;
	}

 	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING())	// Any final readings?
	{
		long	lCount;

		if (!_fHandlingFinalString)
		{
			_fHandlingFinalString = TRUE;

			if (HAVE_RESULT_STRING())
				_fGotFinalString = TRUE;

			if (!CLEANUP_COMPOSITION_STRING())
				TextMsgFilter._pTextDoc->Freeze(&lCount);				// Turn off display


			if (_cchCompStr)
			{
				ITextRange *pTextRange = NULL;

				// Create a range to delete composition text
				TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart + _cchCompStr, &pTextRange);
				Assert (pTextRange != NULL);

				// delete composition text
				pTextRange->SetText(NULL);
				pTextRange->Release();
				_cchCompStr	= 0;							//  be in composition mode.
			};

			// setup the font before insert final string
			ITextFont *pFETextFont;

			_pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			TextMsgFilter._pTextSel->SetFont(pFETextFont);
			pFETextFont->Release();

			// turn on undo
			TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

			// Turn on Notification again
			TextMsgFilter._pTextDoc->SetNotificationMode(tomTrue);

			// get final string
			CheckInsertResultString(lparam, TextMsgFilter);

			if (!CLEANUP_COMPOSITION_STRING())
				TextMsgFilter._pTextDoc->Unfreeze(&lCount);				// Turn on display

			// Reset as we may still in Composition
			TextMsgFilter._pTextSel->GetStart(&cpMin);
			_ichStart = cpMin;

			// turn off undo for Korean IME since we will get Composition string message
			// again without getting EndComposition
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
				TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

			_fHandlingFinalString = FALSE;
		}
	}

	if(HAVE_COMPOSITION_STRING())						// In composition mode?
	{
		HIMC	hIMC;
		INT		cchOld = _cchCompStr;
		LONG	cpCursor = 0, cchAttrib = 0;
		LONG	i, j;				// For applying attrib effects.
		WCHAR	szCompStr[256];
		BYTE	startAttrib, attrib[256];
		BSTR	bstr = NULL;
		ITextRange *pTextRange = NULL;
		long	cpMax;
		long	lCount;

		_cchCompStr = 0;

		if (!_fDestroy)
		{
			hIMC = LocalGetImmContext(TextMsgFilter);			// Get host's IME context.

			if(hIMC)								// Get composition string.
			{
				_cchCompStr = GetCompositionStringInfo(hIMC, GCS_COMPSTR, 
						szCompStr, sizeof(szCompStr)/sizeof(szCompStr[0]),
						attrib, sizeof(attrib)/sizeof(attrib[0]), 
						&cpCursor, &cchAttrib, TextMsgFilter._uKeyBoardCodePage, TextMsgFilter._fUnicodeIME, TextMsgFilter._fUsingAIMM);
				_cchCompStr = min (_cchCompStr, 255);
				szCompStr[_cchCompStr] = L'\0';

				LocalReleaseImmContext(TextMsgFilter, hIMC);		// Done with IME context.
			}
		}

		// any new composition string?
		if(_cchCompStr)
		{
			long	cchExced = 0;
			if (TextMsgFilter._pTextDoc->CheckTextLimit(_cchCompStr-cchOld, &cchExced) == NOERROR &&
				cchExced > 0)
			{
				// We reach text limit, beep...
				TextMsgFilter._pTextDoc->SysBeep();

				if (_cchCompStr > cchExced)
					_cchCompStr -= cchExced;
				else
					_cchCompStr = 0;

				szCompStr[_cchCompStr] = L'\0';

				if (!_cchCompStr && TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)				
					TextMsgFilter._pTextDoc->SetCaretType(tomNormalCaret);		// Turn off Block caret mode
			}

			bstr = SysAllocString(szCompStr);

			if (!bstr)
				return E_OUTOFMEMORY;

			if (HAVE_RESULT_STRING())
			{
				// ignore next end composition
				_fIgnoreEndComposition = TRUE;

				// turn off undo
				TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);

				// Get the new format that may have changed by apps (e.g. Outlook)
				_pTextFont->Release();

				ITextFont	*pCurrentFont = NULL;
				TextMsgFilter._pTextSel->GetFont(&pCurrentFont);

				Assert(pCurrentFont != NULL);

				pCurrentFont->GetDuplicate(&_pTextFont);		// duplicate the base format for later use
				pCurrentFont->Release();
				Assert(_pTextFont != NULL);
				CIme::CheckKeyboardFontMatching (_ichStart, &TextMsgFilter, _pTextFont);
			}			
		}

		if (cchOld || _cchCompStr)
		{
			bool	fFreezeDisplay = false;

			// Hold notification if needed
			if (!(TextMsgFilter._fIMEAlwaysNotify) && !HAVE_RESULT_STRING())
				TextMsgFilter._pTextDoc->SetNotificationMode(tomFalse);

			// We only support overtype mode in Korean IME
			if (!cchOld && TextMsgFilter._uKeyBoardCodePage == CP_KOREAN && 
				TextMsgFilter._fOvertypeMode && !_fSkipFirstOvertype)
			{				
				long		cCurrentChar;	
				HRESULT		hResult;

				// Create a range using the next character
				hResult	= TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+1, &pTextRange);
				Assert (pTextRange != NULL);

				// Check if it is par character. If so, we don't want to 
				// delete it.
				hResult	= pTextRange->GetChar(&cCurrentChar);
				if (hResult == NOERROR)
				{
					if (cCurrentChar != (long)'\r' && cCurrentChar != (long)'\n')
					{			
						TextMsgFilter._pTextDoc->Undo(tomResume, NULL);		// Turn on undo
						pTextRange->SetText(NULL);							// Delete the character
						TextMsgFilter._pTextDoc->Undo(tomSuspend, NULL);	// Turn off undo
					}
					else
					{
						// Unselect the par character
						hResult	= pTextRange->SetRange(_ichStart, _ichStart);
					}
				}
			}	
			else
			{
				// Create a range using the preivous composition text and delete the text
				TextMsgFilter._pTextDoc->Range(_ichStart, _ichStart+cchOld, &pTextRange);
				Assert (pTextRange != NULL);
				if (cchOld)
				{
					if (cpCursor >= 0)
					{
						TextMsgFilter._pTextDoc->Freeze(&lCount);	// Turn off display
						fFreezeDisplay = true;
					}
					pTextRange->SetText(NULL);
				}
			}
			
			_fSkipFirstOvertype = FALSE;
			
			if (cpCursor >= 0 && !fFreezeDisplay)
				TextMsgFilter._pTextDoc->Freeze(&lCount);			// Turn off display
			
			// Make sure the composition string is formatted with the base font
			ITextFont *pFETextFont;
			HRESULT		hResult;

			hResult = _pTextFont->GetDuplicate(&pFETextFont);
			Assert(pFETextFont != NULL);

			if (!(hResult != NOERROR || pFETextFont == NULL))
			{
				if (TextMsgFilter._fHangulToHanja && !_cchCompStr)
					// Hangul to Hanja mode, setup font for selection to 
					// handle the Hanja character the come in after the end composition
					// message
					TextMsgFilter._pTextSel->SetFont(pFETextFont);
				else
					pTextRange->SetFont(pFETextFont);				
			}

			pTextRange->SetText(bstr);								// Replace with the new text			
			if (pFETextFont)
				pFETextFont->Release();

			// update how many composition characters have been added
			pTextRange->GetEnd(&cpMax); 
			_cchCompStr = cpMax - _ichStart;
			
			if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
			{
				// no formatting for Korean
				POINT		ptBottomPos;

				if (cpCursor == 0)
					TextMsgFilter._pTextDoc->Unfreeze(&lCount);			// Turn on display
			
				if (pTextRange->GetPoint( tomEnd+TA_BOTTOM+TA_RIGHT,
					&(ptBottomPos.x), &(ptBottomPos.y) ) != NOERROR)
					pTextRange->ScrollIntoView(tomEnd);
				
				// Setup Block caret mode only when there is One char and the caret pos is 0.
				TextMsgFilter._pTextDoc->SetCaretType((_cchCompStr == 1 && !cpCursor) ? tomKoreanBlockCaret : tomNormalCaret);
				
			}
			else if (_cchCompStr && _cchCompStr <= cchAttrib)
			{				
				for ( i = 0; i < _cchCompStr; )			// Parse the attributes...
				{										//  to apply styles.					
					ITextFont *pFETextFont;
					HRESULT		hResult;

					hResult = _pTextFont->GetDuplicate(&pFETextFont);
					Assert(pFETextFont != NULL);

					if (hResult != NOERROR || pFETextFont == NULL)
						break;
					
					// Rsest the clone font so we will only apply effects returned
					// from SetCompositionStyle
					pFETextFont->Reset(tomUndefined);

					startAttrib = attrib[i];			// Get attrib's run length.
					for ( j = i+1; j < _cchCompStr; j++ )
					{
						if ( startAttrib != attrib[j] )	// Same run until diff.
							break; 
					}

					SetCompositionStyle(TextMsgFilter, startAttrib, pFETextFont);

					// Apply FE clause's style
					pTextRange->SetRange(_ichStart+i, _ichStart+j);
					pTextRange->SetFont(pFETextFont);
					pFETextFont->Release();

					i = j;
				}
			}

			pTextRange->Release();
		}
		else if (TextMsgFilter._uKeyBoardCodePage == CP_KOREAN)
			TextMsgFilter._pTextDoc->Update(tomTrue);		// Force an Update

		// setup caret pos
		if ( !(TextMsgFilter._uKeyBoardCodePage == CP_KOREAN) || cpCursor > 0)
		{
			if ( cpCursor >= 0 )
			{
				HRESULT hResult;
				int		cpLocal = min(cpCursor, _cchCompStr) + _ichStart;

				hResult	= TextMsgFilter._pTextDoc->Range(cpLocal, cpLocal, &pTextRange);
				Assert (pTextRange != NULL);
				
				if (hResult == NO_ERROR)
				{
					pTextRange->Select();
					pTextRange->Release();
				}
				TextMsgFilter._pTextDoc->Unfreeze(&lCount);			// Turn on display
			}
		}

		if (bstr)	
			SysFreeString(bstr);
		
		// setup composition window for Chinese in-caret IME
		if (!_fDestroy && (TextMsgFilter._uKeyBoardCodePage == CP_CHINESE_TRAD || 
			TextMsgFilter._uKeyBoardCodePage == CP_CHINESE_SIM))
			IMENotify ( IMN_OPENCANDIDATE, 0x01, TextMsgFilter, TRUE );

	}

	return S_OK;									// No DefWindowProc
}													//  processing.

/*
 *	void CIme_Lev3::SetCompositionStyle (CTextMsgFilter &TextMsgFilter, CCharFormat &CF)
 *
 *	@mfunc
 *		Set up a composition clause's character formmatting.
 *
 *	@comm
 *		If we loaded Office's IMEShare.dll, then we ask it what the formatting
 *		should be, otherwise we use our own, hardwired default formatting.
 *
 *	@devnote
 *		Note the use of pointers to functions when dealing with IMEShare funcs.
 *		This is because we dynamically load the IMEShare.dll.
 *
 */
void CIme_Lev3::SetCompositionStyle (
	CTextMsgFilter &TextMsgFilter,
	UINT attribute,
	ITextFont *pTextFont)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::SetCompositionStyle");

	UINT			ulID = 0;
	COLORREF		crText = UINTIMEBOGUS;
	COLORREF		crBackground = UINTIMEBOGUS;
	BOOL			fBold = FALSE;
	BOOL			fItalic = FALSE;
	BOOL			fStrikeThru = FALSE;
	long			lUnderlineStyle = tomNone;

	if (TextMsgFilter._fRE10Mode)
	{
		COMPCOLOR* pcrComp = TextMsgFilter.GetIMECompAttributes();
		
		if (!pcrComp)
			goto defaultStyle;

		if (attribute > ATTR_TARGET_NOTCONVERTED)
			attribute = ATTR_CONVERTED;

		// IME input for 1.0 mode, need to use IME Color
		fBold = (pcrComp[attribute].dwEffects & CFE_BOLD);		
		fItalic = (pcrComp[attribute].dwEffects & CFE_ITALIC);
		fStrikeThru = (pcrComp[attribute].dwEffects & CFE_STRIKEOUT);

		if (pcrComp[attribute].dwEffects & CFE_UNDERLINE)
			lUnderlineStyle = tomSingle;

		crText = pcrComp[attribute].crText;			
		crBackground = pcrComp[attribute].crBackground;
	}
	else if (W32->HaveIMEShare())
	{
		CIMEShare *pIMEShare;
		if (W32->getIMEShareObject(&pIMEShare))
		{
			if (TextMsgFilter._fUsingAIMM)
			{
				HIMC	hIMC = LocalGetImmContext(TextMsgFilter);	// Get host's IME context.

				if (hIMC)
				{
					attribute = W32->GetDisplayGUID (hIMC, attribute);
					LocalReleaseImmContext(TextMsgFilter, hIMC);	// Done with IME context.
				}
			}

			// IMEShare 98 interface
			fBold = pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFBold);			
			fItalic = pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFItalic);

			if (pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareFUl))
			{
				ulID = pIMEShare->DwGetIMEStyle(attribute, IdstyIMEShareUKul);
				if(UINTIMEBOGUS != ulID)
				{
					long		lUnderlineCrIdx = 0;
					COLORREF	crUl;

					// get color for underline					
					crUl = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubUl);					
					if(UINTIMEBOGUS != crUl)
					{
						// NOTE:- attribute is 0 based and index for EffectColor is 1 based,
						HRESULT hResult = TextMsgFilter._pTextDoc->SetEffectColor(attribute+1, crUl);
						
						// setup the high nibble for color index
						if (hResult == NOERROR)
							lUnderlineCrIdx = (attribute+1) << 8;
					}

					lUnderlineStyle = IMEShareToTomUL(ulID) + lUnderlineCrIdx;
				}
			}

			crText = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubText);		
			crBackground = GetIMEShareColor(pIMEShare, attribute, IdstyIMEShareSubBack);
		}
		else
		{
			// IMEShare 96 interface
			const IMESTYLE	*pIMEStyle = PIMEStyleFromAttr(attribute);
			if (NULL == pIMEStyle)
				goto defaultStyle;		

			fBold = FBoldIMEStyle(pIMEStyle);
			fItalic = FItalicIMEStyle(pIMEStyle);

			if (FUlIMEStyle(pIMEStyle))
			{			
				ulID = IdUlIMEStyle (pIMEStyle);
				if(UINTIMEBOGUS != ulID)
					lUnderlineStyle = IMEShareToTomUL(ulID);
			}

			crText = RGBFromIMEColorStyle(PColorStyleTextFromIMEStyle(pIMEStyle));						
			crBackground = RGBFromIMEColorStyle(PColorStyleBackFromIMEStyle(pIMEStyle));
		}
	}
	else // default styles when no IMEShare.dll exist.
	{
defaultStyle:
		switch(attribute)
		{										// Apply underline style.
			case ATTR_INPUT:
			case ATTR_CONVERTED:
				pTextFont->SetUnderline(tomDotted);
				break;

			case ATTR_TARGET_NOTCONVERTED:
				pTextFont->SetUnderline(tomSingle);
				break;

			case ATTR_TARGET_CONVERTED:			// Target *is* selection.			
			{
				pTextFont->SetForeColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
				pTextFont->SetBackColor(::GetSysColor(COLOR_HIGHLIGHT));
			}
			break;
		}
		return;			// Done
	}

	//  Now setup all the attribute
	pTextFont->Reset(tomApplyLater);

	if (fBold)
		pTextFont->SetBold(tomTrue);
	else if (TextMsgFilter._fRE10Mode)
		pTextFont->SetBold(tomFalse);

	if (fItalic)
		pTextFont->SetItalic(tomTrue);
	else if (TextMsgFilter._fRE10Mode)
		pTextFont->SetItalic(tomFalse);

	if (fStrikeThru)
		pTextFont->SetStrikeThrough(tomTrue);
	else if (TextMsgFilter._fRE10Mode)
		pTextFont->SetStrikeThrough(tomFalse);

	pTextFont->SetUnderline(lUnderlineStyle);

	// ignore case where text color is same as background color
	if (crText != crBackground)
	{
		if(UINTIMEBOGUS != crText)
			pTextFont->SetForeColor(crText);
		
		if(UINTIMEBOGUS != crBackground)
			pTextFont->SetBackColor(crBackground);		
	}

	pTextFont->Reset(tomApplyNow);
}
/*
 *	COLORREF CIme_Lev3::GetIMEShareColor (CIMEShare *pIMEShare, DWORD dwAttribute, DWORD dwProperty)
 *
 *	@mfunc
 *		Get the IME share color for the given dwAttribute and property
 *
 *
 *	@rdesc
 *		COLORREF of the color
 *
 */
COLORREF CIme_Lev3::GetIMEShareColor(
	CIMEShare *pIMEShare,
	DWORD dwAttribute,
	DWORD dwProperty)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::GetIMEShareColor");

	if (pIMEShare->DwGetIMEStyle(dwAttribute,IdstyIMEShareFSpecCol | dwProperty))
	{
		if (pIMEShare->DwGetIMEStyle(dwAttribute,IdstyIMEShareFSpecColText | dwProperty))
			return (COLORREF) _crTextColor;
		else
			return (COLORREF) _crBkColor;
	}
	else
		return (COLORREF) (pIMEShare->DwGetIMEStyle(dwAttribute, 
				IdstyIMEShareRGBCol | dwProperty));
}

/*
 *	HRESULT CIme_Lev3::IMENotify(const WPARAM wparam, const LPARAM lparam,
 *					CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle Level 3 WM_IME_NOTIFY messages.
 *
 *	@comm
 *		Currently we are only interested in knowing when to update
 *		the n window's position.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_Lev3::IMENotify(
	const WPARAM wparam,			// @parm associated with message.
	const LPARAM lparam,			// @parm associated with message.
	CTextMsgFilter &TextMsgFilter,	// @parm the containing message filter.
	BOOL fCCompWindow)				// @parm Level3 Chinese Composition window
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMENotify");

	if(IMN_OPENCANDIDATE == wparam || IMN_CLOSECANDIDATE == wparam )
	{
		Assert (0 != lparam);

		INT				index;							// Candidate window index.
		CANDIDATEFORM	cdCandForm;
		POINT			ptCaret;
		HIMC			hIMC = LocalGetImmContext(TextMsgFilter);	// Get host's IME context.

		if(hIMC)
		{
			for (index = 0; index < 32; index++)	// Convert bitID to INDEX
			{										//  because *stupid* API
				if((1 << index) & lparam)
					break;
			}
			Assert(((1 << index) & lparam) == lparam);	// Only 1 set?
			Assert(index < 32);

			if(IMN_OPENCANDIDATE == wparam && !(TextMsgFilter._uKeyBoardCodePage == CP_KOREAN))	// Set candidate to caret.
			{
				HRESULT	hResult;
				POINT	ptCurrentBottomPos;
				long	lTextFlow;
				long	lTomType = tomStart+tomClientCoord+TA_BOTTOM+TA_LEFT;
		
				TextMsgFilter._pTextDoc->GetFEFlags(&(TextMsgFilter._lFEFlags));
				lTextFlow = TextMsgFilter._lFEFlags & tomTextFlowMask;

				if (lTextFlow == tomTextFlowWN)
					lTomType = tomStart+tomClientCoord+TA_TOP+TA_LEFT;

				GetCaretPos(&ptCaret);			// Start at caret.

				ptCaret.x = max(0, ptCaret.x);
				ptCaret.y = max(0, ptCaret.y);
					
				cdCandForm.dwStyle = CFS_CANDIDATEPOS;
				
				if ( !fCCompWindow )			// Not positioning the Chinese composition
				{								//	Window.
					hResult = TextMsgFilter._pTextSel->GetPoint( lTomType,
							&(ptCurrentBottomPos.x), &(ptCurrentBottomPos.y) );

					if (hResult != NOERROR)
					{
						RECT	rcArea;

						// GetPoint fails, use application rect in screen coordinates
						hResult = TextMsgFilter._pTextDoc->GetClientRect(tomIncludeInset+tomClientCoord,
									&(rcArea.left), &(rcArea.top),
									&(rcArea.right), &(rcArea.bottom));
						ptCurrentBottomPos.x = ptCaret.x;
						ptCurrentBottomPos.y = rcArea.bottom;
					}

					if (hResult == NOERROR)
					{
						if (TextMsgFilter._uKeyBoardCodePage == CP_JAPAN)
						{
							// Change style to CFS_EXCLUDE, this is to
							// prevent the candidate window from covering
							// the current selection.
							cdCandForm.dwStyle = CFS_EXCLUDE;
							cdCandForm.rcArea.left = ptCaret.x;					

							// FUTURE: for verticle text, need to adjust
							// the rcArea to include the character width.
							cdCandForm.rcArea.right = (lTextFlow == tomTextFlowNE) ? ptCurrentBottomPos.x :
								cdCandForm.rcArea.left + 2;
							cdCandForm.rcArea.top = ptCaret.y;
							ptCaret.y = ptCurrentBottomPos.y + 4;
							cdCandForm.rcArea.bottom = ptCaret.y;
						}
						else
							ptCaret.y = ptCurrentBottomPos.y + 4;
					}
				}

				// Most IMEs will have only 1, #0, candidate window. However, some IMEs
				//  may want to have a window organized alphabetically, by stroke, and
				//  by radical.
				cdCandForm.dwIndex = index;				
				cdCandForm.ptCurrentPos = ptCaret;
				ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
			}
			else									// Reset back to CFS_DEFAULT.
			{
				if(ImmGetCandidateWindow(hIMC, index, &cdCandForm, TextMsgFilter._fUsingAIMM)
						&& CFS_DEFAULT != cdCandForm.dwStyle)
				{
					cdCandForm.dwStyle = CFS_DEFAULT;
					ImmSetCandidateWindow(hIMC, &cdCandForm, TextMsgFilter._fUsingAIMM);
				}				
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.

			if (TextMsgFilter._fHangulToHanja == TRUE  &&
				IMN_CLOSECANDIDATE == wparam &&					 
				W32->OnWinNT4() && OnWinNTFE() && !TextMsgFilter._fUsingAIMM)
			{
				// By pass NT4.0 Kor Bug where we didn't get EndComposition message
				// when user toggle the VK_HANJA key to terminate the reconversion.
				TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_NORMAL);
			}

			if (IMN_CLOSECANDIDATE == wparam && CP_JAPAN == TextMsgFilter._uKeyBoardCodePage)
				_fUpdateWindow = TRUE;			
		}
	}	

	return S_FALSE;									// Allow DefWindowProc
}													//  processing.

/*
 *
 *	CIme_Lev3::IMEMouseOperation (CTextMsgFilter &TextMsgFilter, UINT msg, BOOL	&fTerminateIME)
 *
 *	@mfunc	if current IME support Mouse operation, need to pass
 *		mouse events to IME for processing
 *
 *	@rdesc
 *		BOOL-TRUE if IME handled the mouse events
 *		fTermineateIME-TRUE if we want to terminateIME
 *
 */
BOOL CIme_Lev3::IMEMouseOperation(
	CTextMsgFilter	&TextMsgFilter, 		// @parm the containing message filter.
	UINT			msg,					// @parm message id
	WPARAM			wParam,					// @parm wparam
	BOOL			&fTerminateIME)			// @parm need to terminate IME						
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMEMouseOperation");

	if (IMESupportMouse(TextMsgFilter))
		return TextMsgFilter.MouseOperation(msg, _ichStart, _cchCompStr, wParam, &_wParamBefore, &fTerminateIME, _hwndIME);

	fTerminateIME = TRUE;
	return FALSE;
}

/*
 *
 *	CIme_Lev3::IMESupportMouse (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	check if current IME supports Mouse events.  This should be
 *			a feature for IME Level 3.
 * 
 *	@comm	_sIMESupportMouse is a flag with the following values:
 *				== 0	if we haven't checked IME mouse support
 *				== -1	if we have checked and IME doesn't support mouse events
 *				== 1	if we have checked and IME supports mouse events and we have
 *						retrieved the IME hWnd
 */
BOOL CIme_Lev3::IMESupportMouse(
	CTextMsgFilter &TextMsgFilter) 			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::IMESupportMouse");
	HIMC	hIMC;									// Host's IME context.
	HWND	hHostWnd;
	long	hWnd;

	if (!MSIMEMouseMsg || _sIMESuportMouse == -1)
		return FALSE;								// No mouse operation support

	if (_sIMESuportMouse == 1)
		return TRUE;								// IME supports mouse operation

	hHostWnd = TextMsgFilter._hwnd;
	
	if (!hHostWnd)									// Windowless mode...
	{		
		if (TextMsgFilter._pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;
		
		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	// Check if this IME supports mouse operation
	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.

	_sIMESuportMouse = -1;							// Init. to no support
	if(hIMC)
	{
		_hwndIME = ImmGetDefaultIMEWnd(hHostWnd, TextMsgFilter._fUsingAIMM);
		LocalReleaseImmContext(TextMsgFilter, hIMC);

		// SendMessage returns TRUE if IME supports mouse operation
		if (_hwndIME && SendMessage(_hwndIME, MSIMEMouseMsg, (WPARAM)IMEMOUSE_VERSION, hIMC) )
			_sIMESuportMouse = 1;
	}

	return (_sIMESuportMouse == 1);
}

/*
 *
 *	CIme_Lev3::GetIMECompositionMode (CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc	Return the current IME composition mode when we have composition characters
 *			or when we haven't received any final string
 * 
 */
LRESULT  CIme_Lev3::GetIMECompositionMode(
	CTextMsgFilter &TextMsgFilter)			// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Lev3::GetIMECompositionMode");

	if (_cchCompStr || !_fGotFinalString)
		return ICM_LEVEL3;

	if (!_fDestroy)
	{
		HIMC	hIMC = LocalGetImmContext(TextMsgFilter);	// Get host's IME context.
		int		cchCompStr = 0;

		if(hIMC)											// Check if there is composition string.
		{
			if (TextMsgFilter._fUnicodeIME)
				cchCompStr = ImmGetCompositionStringW(hIMC, GCS_COMPSTR, NULL, 0, TextMsgFilter._fUsingAIMM);
			else
				cchCompStr = ImmGetCompositionStringA(hIMC, GCS_COMPSTR, NULL, 0, TextMsgFilter._fUsingAIMM);

			LocalReleaseImmContext(TextMsgFilter, hIMC);
		}

		if (cchCompStr)
			return ICM_LEVEL3;
	}
	return ICM_NOTOPEN;
}

/*
 *	BOOL IMEHangeulToHanja (&TextMsgFilter)
 *	
 *	@func
 *		Initiates an IME composition string edit to convert Korean Hanguel to Hanja.
 *	@comm
 *		Called from the message loop to handle VK_KANJI_KEY.
 *
 *	@devnote
 *		We decide if we need to do a conversion by checking:
 *		- the Fonot is a Korean font,
 *		- the character is a valid SBC or DBC,
 *		- ImmEscape accepts the character and bring up a candidate window
 *
 *	@rdesc
 *		BOOL - FALSE for no conversion. TRUE if OK.
 */
BOOL IMEHangeulToHanja (
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "IMEHangeulToHanja");

	if(!TextMsgFilter.IsIMEComposition())
	{
		if(TextMsgFilter._pTextSel->CanEdit(NULL) == NOERROR)
		{
			WCHAR		szCurrentChar;
			long		cCurrentChar;	
			HRESULT		hResult;
			HKL			hKL = GetKeyboardLayout(0x0FFFFFFFF);
			HIMC		hIMC;	

			if (!hKL)
				goto Exit;
			
			hIMC = LocalGetImmContext(TextMsgFilter);
			if (!hIMC)
				goto Exit;

			// Collapse to cpMin
			hResult	= TextMsgFilter._pTextSel->Collapse(tomTrue);

			// get the current character
			hResult	= TextMsgFilter._pTextSel->GetChar(&cCurrentChar);

			if (hResult != NOERROR)
				goto Exit;

			szCurrentChar = (WCHAR)cCurrentChar;
			
			// Check if the IME has a conversion for this Hangeul character.					
			if (ImmEscape(hKL, hIMC, IME_ESC_HANJA_MODE, (LPVOID)&szCurrentChar, TextMsgFilter._fUsingAIMM) != FALSE)
			{
				ITextRange *pTextRange;
				POINT		ptMiddlePos;
				LONG		cpCurrent;

				hResult = TextMsgFilter._pTextSel->GetStart(&cpCurrent);
				if (hResult == S_OK)
				{
					hResult = TextMsgFilter._pTextDoc->Range(cpCurrent, cpCurrent+1, &pTextRange);
					if (hResult == S_OK && pTextRange)
					{
						// Check if the character is in view
						if (pTextRange->GetPoint( tomEnd+TA_BASELINE+TA_LEFT,
							&(ptMiddlePos.x), &(ptMiddlePos.y) ) != NOERROR)
							pTextRange->ScrollIntoView(tomEnd);
						pTextRange->Release();
					}
				}

				TextMsgFilter._fHangulToHanja = TRUE;

				TextMsgFilter._ime = new CIme_HangeulToHanja(TextMsgFilter);

				if(TextMsgFilter.IsIMEComposition())
				{
					// start IME composition for the conversion
					LocalReleaseImmContext(TextMsgFilter, hIMC);
					return TextMsgFilter._ime->StartComposition(TextMsgFilter);
				}
				else
					TextMsgFilter._fHangulToHanja = FALSE;				
			}

			LocalReleaseImmContext(TextMsgFilter, hIMC);
		}
	}

Exit:
	return S_FALSE;
}

/*
 *	CIme_HangeulToHanja::CIme_HangeulToHanja()
 *
 *	@mfunc
 *		CIme_HangeulToHanja Constructor.
 *
 *
 */
 CIme_HangeulToHanja::CIme_HangeulToHanja(CTextMsgFilter &TextMsgFilter)	:
	CIme_Lev3(TextMsgFilter)
{
}

/*
 *	HRESULT CIme_HangeulToHanja::StartComposition(CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Begin CIme_HangeulToHanja composition string processing.		
 *
 *	@comm
 *		Call Level3::StartComposition.  Then setup the Korean block
 *		caret for the Hanguel character.
 *
 *	@rdesc
 *		Need to adjust _ichStart and _cchCompStr to make the Hanguel character
 *		"become" a composition character.
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 */
HRESULT CIme_HangeulToHanja::StartComposition(
	CTextMsgFilter &TextMsgFilter )				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_HangeulToHanja::StartComposition");
	HRESULT				hr;

	hr = CIme_Lev3::StartComposition(TextMsgFilter);
	
	// initialize to 1 so Composition string will get rid of the selected Hangeul
	_cchCompStr		= 1;

	// turn on undo
	TextMsgFilter._pTextDoc->Undo(tomResume, NULL);

	// Setup Block caret mode
	TextMsgFilter._pTextDoc->SetCaretType(tomKoreanBlockCaret);

	return hr;
}

/*
 *	HRESULT CIme_HangeulToHanja::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle CIme_HangeulToHanja WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		call CIme_Lev3::CompositionString to get rid of the selected Hanguel character,
 *		then setup the format for the next Composition message.
 *
 *	@devnote
 *		When the next Composition message comes in and that we are no longer in IME,
 *		the new character will use the format as set here.
 */
HRESULT CIme_HangeulToHanja::CompositionString(
	const LPARAM lparam,		// @parm associated with message
	CTextMsgFilter &TextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_HangeulToHanja::CompositionString");

	CIme_Lev3::CompositionString(lparam, TextMsgFilter);

	return S_OK;
}
/*
 *	HRESULT CIme_Protected::CompositionString(const LPARAM lparam, CTextMsgFilter &TextMsgFilter)
 *
 *	@mfunc
 *		Handle CIme_Protected WM_IME_COMPOSITION messages.
 *
 *	@comm
 *		Just throw away the result string since we are
 *	in read-only or protected mode
 *
 *
 *	@rdesc
 *		HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
 *
 */
HRESULT CIme_Protected::CompositionString (
	const LPARAM lparam,		// @parm associated with message.
	CTextMsgFilter &TextMsgFilter)				// @parm the containing message filter.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CIme_Protected::CompositionString");

	if(CLEANUP_COMPOSITION_STRING() || HAVE_RESULT_STRING()) // If result string..
	{
		LONG	cch = 0;
		HIMC	hIMC = LocalGetImmContext(TextMsgFilter);		// Get host's IME context.
		WCHAR	szCompStr[256];

		if(hIMC)									// Get result string.
		{
			cch = GetCompositionStringInfo(hIMC, GCS_RESULTSTR, 
							szCompStr, sizeof(szCompStr)/sizeof(szCompStr[0]),
							NULL, 0, NULL, NULL, TextMsgFilter._uKeyBoardCodePage, FALSE, TextMsgFilter._fUsingAIMM);

			LocalReleaseImmContext(TextMsgFilter, hIMC);			// Done with IME context.
		}
		return NOERROR;								// Don't want WM_IME_CHARs.
	}

	// Terminate composition to force a end composition message
	TerminateIMEComposition(TextMsgFilter, CIme::TERMINATE_FORCECANCEL);
	return S_FALSE;
}

#endif // NOFEPROCESSING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\layout.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	LAYOUT.CPP -- CLayout class |
 *
 *	Recursive structure which contains an array of lines.
 *	
 *	Owner:<nl>
 *		Murray Sargent: Initial table implementation
 *		Keith Curtis:	Factored into a separate class for
 *						performance, simplicity
 * 
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

//FUTURE: (KeithCu) More stuff should be put into here, e.g., RecalcLines, 
//The CDisplayML should just be a class that knows about Device descriptors, 
//pagination and scrolling, etc., i.e., things that are the same for all
//layouts and things that apply only to the outermost layout. This code knows
//how to manage and update recursive arrays of lines.

#include "_common.h"
#include "_dispml.h"
#include "_select.h"
#include "_measure.h"
#include "_render.h"

void CLayout::DeleteSubLayouts(
	LONG ili,
	LONG cLine)
{
	CLine *pli = Elem(ili);

	if(cLine < 0)
		cLine = Count();

	LONG cLineMax = Count() - ili;
	cLine = min(cLine, cLineMax);

	AssertSz(ili >= 0 && cLine >= 0, "DeleteSubLayouts: illegal line count");

	// Delete sublayouts 
	for(; cLine--; pli++)
		delete pli->GetPlo();
}

/*
 *	CLayout::VposFromLine(pdp, ili)
 *
 *	@mfunc
 *		Computes top of line position
 *
 *	@rdesc
 *		top position of given line (relative to the first line)
 */
LONG CLayout::VposFromLine(
	CDisplayML *pdp,		//@parm Parent display 
	LONG		ili) 		//@parm Line we're interested in
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLayout::VposFromLine");
	LONG cli = 0, vPos = 0;
	CLine *pli = 0;

	if (IsNestedLayout())
	{
		Assert(!IsTableRow());					// _iPFCell layouts are horizontal
		Assert(ili < Count());
		cli = ili;
		pli = Elem(0);
		vPos = 0;
	}
	else
	{
		if(!pdp->WaitForRecalcIli(ili))			// out of range, use last valid line
		{
			ili = Count() - 1;
			ili = (ili > 0) ? ili : 0;
		}
		cli	= ili - pdp->_iliFirstVisible;
		pli = Elem(pdp->_iliFirstVisible);
		vPos = pdp->_vpScroll + pdp->_dvpFirstVisible;
	}

	while(cli > 0)
	{
		vPos += pli->GetHeight();
		cli--;
		pli++;
	}
	while(cli < 0)
	{	
		pli--;
		vPos -= pli->GetHeight();
		cli++;
	}

	AssertSz(vPos >= 0, "VposFromLine height less than 0");
	return vPos;
}

/*
 *	CLayout::LineFromVPos(pdp, vPos, pdvpLine, pcpFirst)
 *
 *	@mfunc
 *		Computes line at given y position. Returns top of line vPos
 *		cp at start of line cp, and line index.
 *
 *	@rdesc
 *		index of line found
 */
LONG CLayout::LineFromVpos(
	CDisplayML *pdp,	//@parm Parent display
	LONG vPos,			//@parm Vpos to look for (relative to first line)
	LONG *pdvpLine,		//@parm Returns vPos at top of line /r first line (can be NULL)
	LONG *pcpFirst)		//@parm Returns cp at start of line (can be NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLayout::LineFromVpos");
	LONG cpLi;
	LONG dy;
	LONG ili = 0;
	LONG yLi;
	CLine *pli;

	if(IsNestedLayout())
		goto BindFrom0;

	yLi = pdp->_vpScroll;

	if(!pdp->WaitForRecalc(-1, pdp->_vpScroll))
	{
		yLi = 0;
		cpLi = 0;
		goto done;
	}

	cpLi = pdp->_cpFirstVisible;
	ili = pdp->_iliFirstVisible;
	if(!pdp->IsInPageView())
		yLi += pdp->_dvpFirstVisible;
	dy = vPos - yLi;
	
	if(dy < 0 && -dy <= pdp->_vpScroll)
	{
		// Closer to first visible line than to first line:
		// go backwards from first visible line.
		while(vPos < yLi && ili > 0)
		{
			pli = Elem(--ili);
			yLi -= pli->GetHeight();
			cpLi -= pli->_cch;
		}
	}
	else
	{
		if(dy < 0)
		{
			// Closer to first line than to first visible line:
			// so start at first line.
BindFrom0:
			cpLi = _cpMin;
			yLi = 0;
			ili = 0;
		}
		pli = Elem(ili);
		while(vPos > yLi && ili < Count()-1)
		{
			yLi += pli->GetHeight();
			cpLi += pli->_cch;
			ili++;
			pli++;
		}
		if(vPos < yLi && ili > 0)
		{
			ili--;
			pli--;
			yLi -= pli->GetHeight();
			cpLi -= pli->_cch;
		}
	}

done:
	if(pdvpLine)
		*pdvpLine = yLi;

	if(pcpFirst)
		*pcpFirst = cpLi;

	return ili;
}

/*
 *	CLayout::FindTopCell(&cch, pli, &ili, dul, &dy, pdvp, pliMain,iliMain, pcLine)
 *
 *	@mfunc
 *		Find cch and height change back to current position in 
 *		top cell corresponding to the current vertically merged cell.
 *		Enter with cch = cch from current cell back to start of row.
 *
 *	@rdesc
 *		target line in top cell
 */
CLine * CLayout::FindTopCell(
	LONG &		cch,		//@parm In/out parm for cch back to top
	CLine	*	pli,		//@parm Table-row line
	LONG &		ili,		//@parm Corresponding line index & return ili
	LONG		dul,		//@parm Current cell x offset
	LONG &		dy,			//@parm In/Out parm for y offset in top cell
	LONG *		pdvp,		//@parm TopCellHeight - heights of inbetween rows
	CLine *		pliMain,	//@parm Line preceding first line accessible by pli
	LONG		iliMain,	//@parm Line index corresponding to pliMain
	LONG *		pcLine)		//@parm Count() of possible CLayout for returned pli
{
	LONG		cCell;
	LONG		iCell;
	CLayout	*	plo;
	const CELLPARMS *prgCellParms;
	const CParaFormat *pPF;

#ifdef DEBUG
	BYTE bTableLevel = pli->GetPlo()->GetPFCells()->_bTableLevel;
#endif

	if(pcLine)
		*pcLine = 0;					// Default no lines in case of error

	// Need to use uCell to identify cell rather than iCell, since
	// horizontal merge can change iCell from row to row
	do									// Backup row by row
	{
		if(ili > 0)
		{
			pli--;						// Go to previous row
			ili--;
		}
		else if(pliMain)
		{
			pli = pliMain;
			ili = iliMain;
			pliMain = NULL;				// Switch to pliMain only once!
			
		}
		else
		{
			AssertSz(FALSE, "CLayout::FindTopCell: no accessible top cell");
			return NULL;
		}
		plo = pli->GetPlo();			// Get its cell display
		if(!plo || !plo->IsTableRow())	// Illegal structure or not table row
		{
			AssertSz(FALSE, "CLayout::FindTopCell: no accessible top cell");
			return NULL;
		}
		pPF = plo->GetPFCells();
		AssertSz(pPF->_bTableLevel == bTableLevel,
			"CLayout::FindTopCell: no accessible top cell");
		prgCellParms = pPF->GetCellParms();
		cCell = plo->Count();
		iCell = prgCellParms->ICellFromUCell(dul, cCell);
		dy  += pli->GetHeight();	// Add row height
		cch += pli->_cch;			// Add in cch for whole row
	}
	while(!IsTopCell(prgCellParms[iCell].uCell));

	cch -= 2;						// Sub cch for StartRow delim
	
	pli = plo->Elem(0);				// Point at 1st cell in row
	for(ili = 0; ili < iCell; ili++)// Sub cch's for cells
		cch -= (pli++)->_cch;		//  preceding iCellth cell

	if(pdvp)						// Return top-cell height - heights of
		*pdvp = pli->GetHeight() - dy;//  cells in between

	LONG cLine = 0;
	LONG dvpBrdrTop = plo->_dvpBrdrTop;
	ili = 0;
	dy -= dvpBrdrTop;
	plo = pli->GetPlo();
	if(plo)							// Top cell is multiline
	{
		cLine = plo->Count();
		pli	  = plo->Elem(0);		// Advance pli to line in plo
		if(pli->IsNestedLayout())
			dy += dvpBrdrTop;
		while(ili < cLine && dy >= pli->GetHeight())	//  nearest to input position
		{
			dy -= pli->GetHeight();
			ili++;
			if(ili == cLine)		// Done: leave pli pointing at last line
				break;
			cch -= pli->_cch;
			pli++;
		}
	}

	if(pcLine)
		*pcLine = cLine;
	return pli;
}

/*
 *	CLayout::FindTopRow(pli, ili, pliMain, iliMain, pPF)
 *
 *	@mfunc
 *		Find CLine for top row in a table
 *
 *	@rdesc
 *		CLine for top row in table
 */
CLine * CLayout::FindTopRow(
	CLine	*	pli,		//@parm Entry table-row line
	LONG 		ili,		//@parm Corresponding line index
	CLine *		pliMain,	//@parm Line preceding first line accessible by pli
	LONG		iliMain,	//@parm Line index corresponding to pliMain
	const CParaFormat *pPF)	//@parm CParaFormat for entry plo
{
	BYTE	 bAlignment  = pPF->_bAlignment;	// Target row must have same
	BYTE	 bTableLevel = pPF->_bTableLevel;	//  alignment and level
	CLine *	 pliLast;
	CLayout *plo;
	do									// Backup row by row
	{
		pliLast = pli;					// Last line pointing at row in table
		if(ili > 0)
		{
			pli--;						// Go to previous line
			ili--;
		}
		else if(pliMain)				// More lines to go back to
		{
			pli = pliMain;
			ili = iliMain;
			pliMain = NULL;				// Switch to pliMain only once!
		}
		else
			break;

		plo = pli->GetPlo();			// Get its cell display
		if(!plo || !plo->IsTableRow())
			break;
		pPF = plo->GetPFCells();
	}
	while(pPF->_bAlignment == bAlignment && pPF->_bTableLevel == bTableLevel);

	return pliLast;
}

/*
 *	CLayout::GetCFCells()
 *
 *	@mfunc
 *		Return CCharFormat for the table row described by this CLayout
 *
 *	@rdesc
 *		Table row CCharFormat
 */
const CCharFormat* CLayout::GetCFCells()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CLayout::GetCFCells");

	Assert(_iCFCells >= 0);
	
	const CCharFormat *pCF;
	
	if(FAILED(GetCharFormatCache()->Deref(_iCFCells, &pCF)))
	{
		AssertSz(FALSE, "CLayout::GetCFCells: couldn't deref _iCFCells");
		pCF = NULL;
	}
	return pCF;
}

/*
 *	CLayout::GetPFCells()
 *
 *	@mfunc
 *		Return CParaFormat for the table row described by this CLayout
 *
 *	@rdesc
 *		Table row CParaFormat
 */
const CParaFormat* CLayout::GetPFCells() const
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CLayout::GetPFCells");

	Assert(_iPFCells >= 0);
	
	const CParaFormat *pPF;
	
	if(FAILED(GetParaFormatCache()->Deref(_iPFCells, &pPF)))
	{
		AssertSz(FALSE, "CLayout::GetPF: couldn't deref _iPFCells");
		pPF = NULL;
	}
	return pPF;
}

/*
 *	CLayout::GetLORowAbove(pli, ili, pliMain, iliMain)
 *
 *	@mfunc
 *		Return CLayout for the table row described by the line above pli.
 *		If not a table row, return NULL.
 *
 *	@rdesc
 *		Table row CLayout for row above pli's
 */
const CLayout* CLayout::GetLORowAbove(
	CLine *	pli,		//@parm Entry table-row line
	LONG	ili,		//@parm Corresponding line index
	CLine *	pliMain,	//@parm Line preceding first line accessible by pli
	LONG	iliMain)	//@parm Line index corresponding to pliMain
{
	if(!ili && pliMain && iliMain)			// More lines to go back to
	{
		pli = pliMain;
		ili = iliMain;
	}
	if(ili)
	{
		CLayout *plo = (pli - 1)->GetPlo();	// Get cell display for row above
		if(plo && plo->IsTableRow())
			return plo;
	}
	return NULL;							// No line above 
}

/*
 *	CLayout::CpFromPoint(&me, pt, prcClient, prtp, prp, fAllowEOL, phit,
 *							pdispdim, pcpActual, pliParent, iliParent)
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CLayout::CpFromPoint(
	CMeasurer	&me,		//@parm Measurer
	POINTUV		pt,			//@parm Point to compute cp at (client coords)
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const prtp,//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual,	//@parm Out cp that pt is above
	CLine *		pliParent,	//@parm Parent pli for table row displays
	LONG		iliParent)	//@parm Parent ili corresponding to pli
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLayout::CpFromPoint");

	LONG	cch = 0;
	LONG	cp = 0;
	HITTEST	hit = HT_Nothing;
	LONG	ili;
	CLine *	pli;
	CLayout *plo = NULL;
    RECTUV	rcView;
	int		v = pt.v;						// Save input y coordinate
	LONG	yLine = 0;
	CDisplayML *pdp = (CDisplayML*) me.GetPdp();

	if (IsNestedLayout())
		rcView = *prcClient;
	else
	{
		pdp->GetViewRect(rcView, prcClient);
		pt.v += pdp->GetVpScroll();
		if(pt.u >= 0)						// If x coordinate is within view,
			pt.u += pdp->GetUpScroll();		//  adjust by scroll value
	}

	if(phit)
		*phit = HT_Nothing;					// Default in case early return

	// Get line under hit
	if(IsTableRow())						// This display is a table row
	{										// Shrink to cell text boundaries 
		pli = Elem(0);						// Point at starting cell CLine

		// Move over to start of cells
		const CParaFormat *pPFCells = GetPFCells();
		LONG		dul = 0;
		LONG		dulRTLRow = pPFCells->GetRTLRowLength();
		LONG		dup = 0;
		BOOL		fCellLow;
		LONG		h  = me.LUtoDU(pPFCells->_dxOffset);
		const CELLPARMS *prgCellParms = pPFCells->GetCellParms();
		LONG		u;						// Tracks start of text in cell
		LONG		u0 = pli->_upStart;
		LONG		uCell = 0;

		pt.v -= _dvpBrdrTop;				// Subtract off border top
		cp = _cpMin;
		if(dulRTLRow)
			u0 += me.LUtoDU(dulRTLRow);
		ili = 0;

		while(1)
		{
			u = u0 + dup + h;				// Indent in current cell
			cch = cp - _cpMin;
			uCell = prgCellParms[ili].uCell;
			fCellLow = IsLowCell(uCell);
			dul += GetCellWidth(uCell);
			me.SetDulLayout(GetCellWidth(uCell) - 2*pPFCells->_dxOffset);
			dup = me.LUtoDU(dul);
			if(!dulRTLRow && pt.u < u0 + dup ||// pt.u is inside current cell
			    dulRTLRow && pt.u > u0 - dup)
			{
				LONG ili0 = iliParent;
				if(fCellLow)				// Cell merged vertically
				{							//  with the one above it
					LONG   dy = pt.v;
					CLine *pli0 = FindTopCell(cch, pliParent, ili0, dul, dy,
											  NULL, NULL, 0, NULL);
					if(pli0)
					{						// Found top cell
						cch += 2;			// Include cch of row-start delim
						pli = pli0;			// Use its pli and backup
						ili = ili0;
						cp -= cch;			// Backup to start of pli
						pt.v += dy;
					}
				}
				if(!dulRTLRow && pt.u < u)
				{							// In cell gap, so select cell							
					hit = HT_LeftOfText;
					cch = 0;				// Setup for start of row
					goto finish;				
				}
				break;
			}
			cp += pli->_cch;				// Add in cell's cch
			ili++;
			if(ili == Count())
			{
				hit = HT_RightOfText;
				goto finish;				
			}
			pli++;
		}
		LONG dupCell = me.LUtoDU(GetCellWidth(uCell));
		if(dulRTLRow)
			pt.u -= me.LUtoDU(dulRTLRow - dul) + h;
		else
			pt.u -= dup - dupCell + h;
		rcView.right = dupCell - 2*h;
		pt.v -= GetVertAlignShift(uCell, pli->GetHeight());
	}
	else									// This display isn't a table row
	{
		// Adjust coordinates relative to view origin
		rcView.right -= rcView.left;
		pt.u -= rcView.left;
		pt.v -= rcView.top;
		ili = LineFromVpos(pdp, pt.v, &yLine, &cp);
		if(ili < 0)
			return -1;
		pli = Elem(ili);
		if(yLine + pli->GetHeight() < pt.v)
			hit = HT_BelowText;				// Return hit below text
	}
	rcView.left = 0;
	rcView.top = 0;

	AssertSz(pli || !ili, "CLayout::CpFromPoint invalid line pointer");

	if(pli)									// Line exists, even it it's
	{										//  above or below current screen
		HITTEST hit0;
		if(v < rcView.top)					// Note if hit occurs above or
			hit = HT_AboveScreen;			//  below text
		if(v > rcView.bottom && !IsNestedLayout())
			hit = HT_BelowText;

		plo = pli->GetPlo();
	    pt.v -= yLine;

		if(plo)								// Child layout
		{
			pt.u -= pli->_upStart;
			plo->_cpMin = cp;				// Update child's _cpMin
			if(plo->IsTableRow())			// Table row
			{
				plo->_cpMin += 2;			// Bypass TR start delimiter

				if(pt.u < 0)
				{
					plo = NULL;
					hit = HT_LeftOfText;	// Return hit left of text
					Assert(cch >= 0);		//  (should be row)
					goto finish;
				}
			}
			cp = plo->CpFromPoint(me, pt, &rcView, prtp, prp, fAllowEOL,
								  &hit0, pdispdim, pcpActual, pli, ili);
			if(cp == -1)
				return -1;
			cch = cp - _cpMin;
		}
		else								// Leaf line
		{
			me.SetLayout(this);
			me.SetCp(cp);

			// Support khyphChangeAfter
			me.SetIhyphPrev(ili > 0 ? (pli - 1)->_ihyph : 0);

			// Get character in line
			cch = pli->CchFromUp(me, pt, pdispdim, &hit0, pcpActual);

			// Don't allow click at EOL to select EOL marker and take into
			// account single line edits as well
			if(cch == pli->_cch && pli->_cchEOP && (!fAllowEOL || me.GetPrevChar() == CELL))
			{
				// Adjust position on line by amount backed up. OK for
				// me._rpCF and me._rpPF to get out of sync with me._rpTX,
				// since they're not needed for me.GetCp().
				cch += me._rpTX.BackupCRLF();
			}
			cp = me.GetCp();
		}
		if(hit != HT_BelowText && hit != HT_AboveScreen || hit0 == HT_RightOfText)
			hit = hit0;
	}

finish:
	if(!plo)								// Store info from leaf line
	{
		if(prtp)
			prtp->SetCp(cp);
		if(prp)
		{
			Assert(cch >= 0);
			prp->Set(ili, cch, this);
		}
	}
	if (phit)
		*phit = hit;

	return cp;
}

/*
 *	CLayout::PointFromTp(&me, rtp, prcClient, fAtEnd, pt, prp, taMode, pdispdim)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CLayout::PointFromTp(
	CMeasurer	&me,		//@parm Measurer
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECTUV *prcClient,//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of prev line for ambiguous cp
	POINTUV &	pt,			//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	LONG	 cp = rtp.GetCp();
	LONG	 dy = 0;
	RECTUV	 rcView;
	CDisplayML *pdp = (CDisplayML*) me.GetPdp();
	CLinePtr rp(pdp);

    if(!pdp->WaitForRecalc(cp, -1))
		return -1;

    if(!IsNestedLayout())				// Main display
	{
		if(!rp.SetCp(cp, fAtEnd))
			return -1;

		pdp->GetViewRect(rcView, prcClient);
		pt.u = rcView.left - pdp->_upScroll;
		pt.v = rcView.top  - pdp->_vpScroll;
	}
	else								// Subdisplay
	{
		rp.Init(*this);

		rp.BindToCp(cp - _cpMin);
		if(fAtEnd && !IsTableRow())		// Ambiguous-cp caret position
			rp.AdjustBackward();		//  belongs at prev EOL

		rcView = *prcClient;
		pt.u = rcView.left;
		pt.v = rcView.top;
	}

	AssertSz(pdp->_ped->_fInPlaceActive || prcClient, "Invalid client rect");
	
	LONG ili = rp.GetLineIndex();
	CLine *pli = NULL;
	CLayout *plo = NULL;
	LONG xEnd = -1;						// pt.u to use at end of table row

	if(IsTableRow())					// This layout is a table row
	{									// Shrink to cell text boundaries
		const CParaFormat *pPFCells = GetPFCells();
		const CELLPARMS *  prgCellParms = pPFCells->GetCellParms();
		LONG dul = 0;
		LONG dulRTLRow = pPFCells->GetRTLRowLength();
		LONG h = me.LUtoDU(pPFCells->_dxOffset);
		LONG i;

		cp = _cpMin;
		pli = Elem(0);

		for(i = 0; i < ili; i++, pli++)
		{
			dul += GetCellWidth(prgCellParms[i].uCell);
			cp += pli->_cch;
		}
		LONG uCell = prgCellParms[ili].uCell;
		me.SetDulLayout(GetCellWidth(uCell) - 2 * pPFCells->_dxOffset);

		if(dulRTLRow)
		{
			if(dul < dulRTLRow)
			{
				uCell = prgCellParms[ili + 1].uCell;
				dul += GetCellWidth(prgCellParms[i].uCell);
			}
			dul = dulRTLRow - dul;
		}
		rcView.left  = pt.u + me.LUtoDU(dul) + h;
		rcView.right = pt.u + me.LUtoDU(dul + GetCellWidth(uCell)) - h;
		pt.u = rcView.left;
		if(!GetCellWidth(uCell))
		{
			pt.v += _dvp;
			goto done;
		}
		if(ili + 1 == Count() && rp->_cch == rp.GetIch())
		{
			xEnd = rcView.right + h + 1;
			if(dulRTLRow)
				xEnd = rcView.left - h - 1;
		}
		pt.v += GetVertAlignShift(uCell, pli->GetHeight());
		if(!(taMode & TA_CELLTOP))
			pt.v += _dvpBrdrTop;
	}
	else								// This layout isn't a table row
	{
		pt.v += VposFromLine(pdp, ili);
		cp -= rp.GetIch();
	}

	pli = Elem(ili);
	plo = pli->GetPlo();

	if(plo)								// Line has child display
	{									// Define child rcView and delegate
		RECTUV rc;						//  to child
		pt.u	 += pli->_upStart;
		rc.left	  = pt.u;
		rc.right  = pt.u + rcView.right - rcView.left;
		rc.top	  = pt.v;
		rc.bottom = pt.v + pli->GetHeight();
		plo->_cpMin = cp;				// Update child display's _cpMin
		if(plo->IsTableRow())
			plo->_cpMin += 2;			// Bypass table row start code	

		if(plo->PointFromTp(me, rtp, &rc, fAtEnd, pt, prp, taMode, pdispdim) == -1)
			return -1;
	}
	else								// Line is a leaf line
	{
		me.SetLayout(this);
		me.Move(-rp.GetIch());			// Backup to start of line		
		me.NewLine(*rp);				// Measure from there to where we are

		//Support khyphChangeAfter
		me.SetIhyphPrev(ili > 0 ? (pli - 1)->_ihyph : 0);

		LONG xCalc = rp->UpFromCch(me, rp.GetIch(), taMode, pdispdim, &dy);

		if(pt.u + xCalc <= rcView.right || !pdp->GetWordWrap() || pdp->GetTargetDev())
		{
			// Width is in view or there is no wordwrap so just
			// add the length to the point.
			pt.u += xCalc;
		}
		else
			pt.u = rcView.right; //Hit-test went too far, limit it.

		pt.v += dy;
	}
	if(xEnd != -1)
		pt.u = xEnd;				// Return x coord at end of table row

done:
	if(prp && !plo)
		*prp = rp;						// Return innermost rp
	return rp;							// Return outermost iRun
}

/*
 *	CLayout::Measure(&me, pli, ili, uiFlags, pliTarget, iliMain, pliMain, pdvpExtra)
 *
 *	@mfunc
 *		Computes line break (based on target device) and fills
 *		in *pli with resulting metrics on rendering device
 *
 *	@rdesc 
 *		TRUE if OK
 */
BOOL CLayout::Measure (
	CMeasurer&	me,			//@parm Measurer pointing at text to measure 
	CLine	*	pli,		//@parm Line to store result in
	LONG		ili,		//@parm Line index corresponding to pli
	UINT		uiFlags,	//@parm Flags
	CLine *		pliTarget,	//@parm Returns target-device line metrics (optional)
	LONG		iliMain,	//@parm Line index corresponding to pliMain
	CLine *		pliMain,	//@parm Line preceding 1st line in pli layout (optional)
	LONG *		pdvpExtra)	//@parm Returns extra line height for vmrged cells (opt)
//REVIEW (keithcu) pliTarget is busted in the recursive case.
{
	CTxtEdit *	ped = me.GetPed();
	LONG		cchText = ped->GetTextLength();
	LONG		cpSave = me.GetCp();
	CLine *		pliNew;
	const CDisplayML * pdp = (const CDisplayML *)me.GetPdp();
	const CParaFormat *pPF = me.GetPF();

	// Measure one line, which is either a table row or a line in a paragraph
	if(pPF->IsTableRowDelimiter())
	{
		// Measure table row, which is modeled as a CLayout with one
		// CLine per cell. In the backing store, table rows start with
		// the two chars STARTFIELD CR and end with ENDFIELD CR. Cells
		// are delimited by CELL.
		LONG		cpStart = me.GetCp();
		LONG		dul = 0;
		LONG		dxCell = 0;
		LONG		dvp = 0;
		LONG		dvpMax = 0;
		CLayout *	plo = new CLayout();
		const CLayout *	 ploAbove = GetLORowAbove(pli, ili, pliMain, iliMain);
		const CELLPARMS *prgCellParms = pPF->GetCellParms();

		if(!plo)
			return FALSE;

		plo->_iCFCells = me.Get_iCF();
		plo->_iPFCells = me.Get_iPF();
		pli->SetPlo(plo);

		AssertSz(pPF->_bTabCount && me.GetChar() == STARTFIELD, "Invalid table-row header");
		me.Move(2);
		AssertSz(me.GetPrevChar() == CR, "Invalid table-row header");

		plo->_cpMin = me.GetCp();
		
		// Save current values
		LONG	 dulLayoutOld = me.GetDulLayout();
		LONG	 dvlBrdrTop	  = 0;
		LONG	 dvlBrdrBot	  = 0;
		const CLayout *ploOld = me.GetLayout();
		CArray <COleObject*> rgpobjWrapOld;
		me._rgpobjWrap.TransferTo(rgpobjWrapOld);

		// Create CLines for each cell and measure them
		for(LONG iCell = 0; iCell < pPF->_bTabCount; iCell++)
		{
			me.SetNumber(0);
			LONG uCell = prgCellParms[iCell].uCell;
			dxCell = GetCellWidth(uCell);
			dul += dxCell;

			// Add a line for the next cell
			pliNew = plo->Add(1, NULL);
			if(!pliNew)
				return FALSE;

			LONG dvl = prgCellParms[iCell].GetBrdrWidthTop();
			dvlBrdrTop = max(dvlBrdrTop, dvl);
			dvl = prgCellParms[iCell].GetBrdrWidthBottom();
			dvlBrdrBot = max(dvlBrdrBot, dvl);

			if(!ploAbove)
				uCell &= ~fLowCell;			// Can't be a low cell if no row above
			AssertSz(!IsLowCell(uCell) || me.GetChar() == NOTACHAR,
				"CLayout::Measure: invalid low cell");
			me.SetLayout(plo);
			me.SetDulLayout(dxCell - 2*pPF->_dxOffset);
			plo->Measure(me, pliNew, iCell, uiFlags | MEASURE_FIRSTINPARA, pliTarget, iliMain, pliMain);

			if(IsLowCell(uCell))		
			{							 
				// If a low cell in set of vertically merged cells, check
				// if corresponding cell on next row is also merged
				CPFRunPtr rp(me);
				rp.FindRowEnd(pPF->_bTableLevel);

				const CParaFormat *pPF1 = rp.GetPF();
				BOOL  fBottomCell = !pPF1->IsTableRowDelimiter();

				if(!fBottomCell)
				{
					const CELLPARMS *prgCellParms1 = pPF1->GetCellParms();
					LONG iCell1 = prgCellParms1->ICellFromUCell(dul, pPF1->_bTabCount);

					if(iCell1 >= 0 && !IsLowCell(prgCellParms1[iCell1].uCell))
						fBottomCell = TRUE;
				}
				if(fBottomCell)
				{
					// Need to include top cell in current row height
					// calculation
					LONG cch = me.GetCp() - cpStart;
					LONG dy1 = 0;
					LONG iliT = ili;
					LONG dvpCell = 0;
					
					if(!FindTopCell(cch, pli, iliT, dul, dy1, &dvpCell, pliMain, iliMain, NULL))
						uCell &= ~fLowCell;	// Not a valid low cell
					else if(dvpCell > 0)
						dvp = max(dvp, dvpCell);
				}								
			}
			if(!IsVertMergedCell(uCell) && dxCell || !dvp && iCell == pPF->_bTabCount - 1)
				dvp = max(pliNew->GetHeight(), dvp);
			dvpMax = max(dvpMax, pliNew->GetHeight());
		}

		//Restore original values
		me.SetDulLayout(dulLayoutOld);
		me.SetLayout(ploOld);
		me.SetIhyphPrev(0);
		me._rgpobjWrap.Clear(AF_DELETEMEM);
		
		rgpobjWrapOld.TransferTo(me._rgpobjWrap);

#ifdef DEBUG
		// Bypass table-row terminator
		if(me.GetChar() != ENDFIELD)
			me._rpTX.MoveGapToEndOfBlock();
		AssertSz(me.GetPrevChar() == CELL && pPF->_bTabCount == plo->Count(),
			"Incorrect table cell count");
		AssertSz(me.GetChar() == ENDFIELD,
			"CLayout::Measure: invalid table-row terminator");
		me._rpPF.AdjustForward();
		const CParaFormat *pPFme = me.GetPF();
		AssertSz(pPFme->IsTableRowDelimiter(),
			"CLayout::Measure: invalid table-row terminator");
#endif

		me.UpdatePF();						// me._pPF points at TRD PF
		me.Move(2);							// Bypass table row terminator
		AssertSz(me.GetPrevChar() == CR,
			"CLayout::Measure: invalid table-row terminator");
		if(me.IsHidden())
		{
			CCFRunPtr rp(me);
			me.Move(rp.FindUnhiddenForward());
		}

		if(me.GetChar() == CELL)			// Bypass possible CELL delimeter
		{									//  at end of table row (happens
			Assert(pPF->_bTableLevel > 1);	//  when table row is last line
			CTxtSelection *psel = ped->GetSelNC();	//  of cell
			if(!psel || psel->GetCch() ||	// Don't bypass CELL if selection
			   psel->GetCp() !=me.GetCp() ||//  is an IP at this position,
			   !psel->GetShowCellLine())	//  i.e., display a blank line
			{
				me.Move(1);
				pli->_fIncludeCell = TRUE;
			}
		}

		plo->_dvpBrdrBot = me.GetPBorderWidth(dvlBrdrBot);
		plo->_dvpBrdrTop = me.GetPBorderWidth(dvlBrdrTop);
		if(ploAbove)
			plo->_dvpBrdrTop = max(plo->_dvpBrdrTop, ploAbove->_dvpBrdrBot);
		dvp += plo->_dvpBrdrTop;			  // Add top border width
		if(!me.GetPF()->IsTableRowDelimiter())// End of table: add in 
			dvp += plo->_dvpBrdrBot;		  //  bottom border width

		// Define CLine parameters for table row
		if(pPF->_dyLineSpacing)
		{
			LONG dvpLine = me.LUtoDU(pPF->_dyLineSpacing);
			if(dvpLine < 0)					// Negative row height means use
				dvp = -dvpLine;				//  the magnitude exactly
			else
				dvp = max(dvp, dvpLine);	// Positive row height means
		}									//  "at least"
		plo->_dvp = dvp;
		dvpMax = max(dvpMax, dvp);
		if(pdvpExtra)
			*pdvpExtra = dvpMax - dvp;

		// Fill in CLine structure for row
		pli->_cch = me.GetCp() - cpSave;
		pli->_fFirstInPara = pli->_fHasEOP = TRUE;
		pli->_dup = me.LUtoDU(dul);
		me._li._fFirstInPara = TRUE;
		pli->_upStart  = me.MeasureLeftIndent();
		me.MeasureRightIndent();			// Define me._upEnd
		pli->_cObjectWrapLeft  = me._li._cObjectWrapLeft;
		pli->_cObjectWrapRight = me._li._cObjectWrapRight;
		USHORT dvpLine = plo->_dvp;
		USHORT dvpDescent = 0;
		me.UpdateWrapState(dvpLine, dvpDescent);
		pli->_fFirstWrapLeft  = me._li._fFirstWrapLeft;
		pli->_fFirstWrapRight = me._li._fFirstWrapRight;

		if(!pdp->IsInOutlineView() && IN_RANGE(PFA_RIGHT, pPF->_bAlignment, PFA_CENTER))
		{
			// Normal view with center or flush-right para. Move right accordingly
			// If not top row of like-aligned rows, use indent of top row
			CLine *pliFirst = FindTopRow(pli, ili, pliMain, iliMain, pPF);
			if(pli != pliFirst)
				pli->_upStart = pliFirst->_upStart;

			else
			{
				LONG uShift = me.LUtoDU(dulLayoutOld - dul);  
				uShift = max(uShift, 0);		// Don't allow alignment to go < 0
												// Can happen with a target device
				if(pPF->_bAlignment == PFA_CENTER)
					uShift /= 2;
				pli->_upStart = uShift;
			}
		}
		me.SetNumber(0);					// Update me._wNumber in case next
	}										//  para is numbered
	else if(!pli->Measure(me, uiFlags, pliTarget))	// Not a table row
		return FALSE;						// Measure failed

	if(pli->_fFirstInPara && pPF->_wEffects & PFE_PAGEBREAKBEFORE)
		pli->_fPageBreakBefore = TRUE;

	me.SetIhyphPrev(pli->_ihyph);

	if(!IsTableRow() || me.GetPrevChar() == CELL)// Not a table row display or	
		return TRUE; 							//  cell text fits on 1 line

	// Multiline table cell: allocate its CLayout
	CLayout *plo = new CLayout();
	if(!plo)
		return FALSE;						// Not enuf RAM

	plo->_cpMin = cpSave;
	pliNew = plo->Add(1, NULL);
	if(!pliNew)
	{
		ped->GetCallMgr()->SetOutOfMemory();
		TRACEWARNSZ("Out of memory Recalc'ing lines");
		return FALSE;
	}
	*pliNew = *pli;							// Copy first line of cell layout
	pli->SetPlo(plo);						// Turn line into a layout line

	// Calculate remaining lines in cell.
	// Eventually would be nice to share this code with RecalcLines()
	BOOL fFirstInPara;
	LONG dvp = pliNew->GetHeight();
	LONG iliNew = 0;

	while(me.GetCp() < cchText)
	{
		fFirstInPara = pliNew->_fHasEOP;
		pliNew = plo->Add(1, NULL);
		iliNew++;

		if(!pliNew)
		{
			ped->GetCallMgr()->SetOutOfMemory();
			TRACEWARNSZ("Out of memory Recalc'ing lines");
			return FALSE;
		}
		// New table row can start after EOP, i.e., allow recursion here
		uiFlags = MEASURE_BREAKATWORD | (fFirstInPara ? MEASURE_FIRSTINPARA : 0);
		if(!plo->Measure(me, pliNew, iliNew, uiFlags, pliTarget))
		{
			Assert(FALSE);
			return FALSE;
		}
		dvp += pliNew->GetHeight();
		if(me.GetPrevChar() == CELL)
			break;							// Done with current cell
	}
	pli->_upStart = 0;
	plo->_dvp = dvp;
	pli->_cch = me.GetCp() - cpSave;

	return TRUE;
}

/*
 *	CLayout::Render(&re, pli, prcView, fLastLine, ili, cLine)
 *
 *	@mfunc
 *		Render visible part of the line *pli
 *
 *	@rdesc
 *		TRUE iff successful
 *
 *	@devnote
 *		re is moved past line (to beginning of next line).
 *		FUTURE: the RenderLine functions return success/failure.
 *		Could do something on failure, e.g., be specific and fire
 *		appropriate notifications like out of memory or character
 *		not in font.  Note that CLayout::_cpMin isn't used in
 *		rendering, so we don't have to update it the way we do in
 *		the query functions.
 */
BOOL CLayout::Render(
	CRenderer &	  re,		//@parm Renderer to use
	CLine *		  pli,		//@parm Line to render
	const RECTUV *prcView,	//@parm View rect to use
	BOOL		  fLastLine,//@parm TRUE iff last line of control
	LONG		  ili,		//@parm Line index of pli
	LONG		  cLine)	//@parm # lines in pli's CLayout
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLayout::Render");

	CLayout *plo = pli->GetPlo();
	if(!plo)
		return pli->Render(re, fLastLine);	// Render leaf line

	LONG	cLine1 = plo->Count();			// Count of lines in sublayout
	LONG	ili1;							// Index of first line in sublayout
	CLine *	pli1 = plo->Elem(0);			// Ptr to first line in sublayout
	POINTUV	pt;

	if(plo->IsTableRow())					// Line's nested display is a table row
	{
		// Render table row, which is modeled as a CLayout with one
		// CLine per cell. In the backing store, table rows start with
		// the two chars STARTFIELD CR and end with ENDFIELD CR. Cells
		// are terminated by CELL.
		const CLayout *		ploAbove = GetLORowAbove(pli, ili);
		const CParaFormat *	pPF = plo->GetPFCells();
		const CELLPARMS *	prgCellParms = pPF->GetCellParms();
		LONG	cpStart = re.GetCp();
		LONG	dul = 0;
		BOOL	fSetErase = FALSE;
		LONG	hl = pPF->_dxOffset;		// Logical half gap
		LONG	h  = re.LUtoDU(hl);			// Device  half gap
		RECTUV	rcView;
		LONG	u = prcView->left + pli->_upStart - re._pdp->GetUpScroll();

		// Bypass table-row start
		AssertSz(pPF->_bTabCount && re.GetChar() == STARTFIELD,	"Invalid table-row header");
		AssertSz(pPF == re.GetPF(), "Invalid table-row pPF");
		re.Move(2);
		AssertSz(re.GetPrevChar() == CR, "Invalid table-row header");

		// Save current state
		LONG	crBackOld	  = re.GetDefaultBackColor();
		LONG	crTextOld	  = re.GetDefaultTextColor();
		LONG	dulLayoutOld  = re.GetDulLayout();
		LONG	dulRTLRow	  = pPF->GetRTLRowLength();
		LONG	dvpBrdrTop	  = plo->_dvpBrdrTop;
		CLine *	pli0;
		POINTUV	ptOld		  = re.GetCurPoint();
		RECTUV	rcRender;
		RECTUV	rcRenderOld	  = re.GetRcRender();
		RECTUV	rcViewOld	  = re.GetRcView();
		const CLayout *ploOld = re.GetLayout();

		rcView.left		= u + h;				// Default for LTR row
		rcView.right	= rcView.left;			// Suppress compiler warning
		rcView.top		= ptOld.v;
		rcRender.top	= rcView.top;
		rcView.bottom	= rcView.top + pli->GetHeight();
		rcRender.bottom	= rcView.bottom;

		if(dulRTLRow)
			rcView.right = u + re.LUtoDU(dulRTLRow);

		// Render each cell
		for(ili1 = 0; ili1 < cLine1; ili1++, pli1++)
		{
			LONG dvp = 0;					// Additional cell height if
			LONG uCell = prgCellParms[ili1].uCell;

			dul += GetCellWidth(uCell);
			re.SetLayout(pli1->GetPlo());
			re.SetDulLayout(GetCellWidth(uCell) - 2*hl);

			// Reduce roundoff by converting dul instead of multiple uCell
			if(dulRTLRow)					// Right-To-Left row
				rcView.left	 = u + h + re.LUtoDU(dulRTLRow - dul);	// Convert horizontal coords
			else
				rcView.right = u + re.LUtoDU(dul);

			rcRender.left  = rcView.left - h;	   
			rcRender.right = rcView.right;

			//Set state
			re.StartRender(rcView, rcRender);
			pt.u = rcView.left;
			pt.v = rcView.top + plo->GetVertAlignShift(uCell, pli1->GetHeight());
			if(!IsLowCell(uCell))
				pt.v += dvpBrdrTop;
			re.SetRcViewTop(pt.v);			// Clear to top of cell 
			re.SetCurPoint(pt);
			if(IsTopCell(uCell))
			{
				// Calculate bottom of set of vertically merged cells
				LONG	 ili0;
				LONG	 iCell;
				CLayout *plo0;
				const CELLPARMS *prgCellParms0;

				for(ili0 = ili + 1, pli0 = pli + 1; ili0 < cLine; ili0++, pli0++)
				{
					plo0 = pli0->GetPlo();
					if(!plo0 || !plo0->IsTableRow())
						break;
					prgCellParms0 = plo0->GetPFCells()->GetCellParms();
					iCell = prgCellParms0->ICellFromUCell(dul, plo0->Count());
					if(iCell < 0 || !IsLowCell(prgCellParms0[iCell].uCell))
						break;
					dvp += pli0->GetHeight();	// Add row height
				}
				if(dvp)
				{
					rcView.bottom += dvp;
					rcRender.bottom += dvp;
					re.SetRcBottoms(rcView.bottom, rcRender.bottom);
				}
			}
			COLORREF crf = crTextOld;
			LONG icrf = prgCellParms[ili1].GetColorIndexForegound();
			LONG icrb = prgCellParms[ili1].GetColorIndexBackgound();
			if(icrf | icrb)						// If any nonzero bits,
			{									//  calc special color
				BYTE	 bS = prgCellParms[ili1].bShading;
				COLORREF crb = re.GetShadedColorFromIndices(icrf, icrb, bS, pPF);
				fSetErase = re.EraseRect(&rcRender, crb);
				if(IsTooSimilar(crf, crb))
					crf = re.GetShadedColorFromIndices(icrb, icrf, bS, pPF);
			}
			else
				re.SetDefaultBackColor(crBackOld);
			re.SetDefaultTextColor(crf);

			if(!ploAbove)
				uCell &= ~fLowCell;				// Can't be low cell if no row above
			if(IsLowCell(uCell))				// Cell merged vertically with
			{									//  the one above it
				LONG cch = re.GetCp() -cpStart;	// Use cLine0, ili0, pli0 to
				LONG cLine0;					//  refer to text in set
				LONG cpNext = re.GetCp()	 	//  of vert merged cells
							+ (re.GetChar() == NOTACHAR ? 2 : 1);
				LONG dy = 0;
				LONG ili0 = ili;

				// Get target line to display
				pli0 = FindTopCell(cch, pli, ili0, dul, dy, NULL, NULL, 0, &cLine0);
				if(!pli0)
					uCell &= ~fLowCell;			// Whoops, no cell above
				else
				{
					pt.v -= dy;
					re.SetCurPoint(pt);
					re.Move(-cch);
					for(; ili0 < cLine0; ili0++, pli0++)
					{
						//Support khyphChangeAfter
						re.SetIhyphPrev(ili0 > 0 ? (pli0 - 1)->_ihyph : 0);

						if(!Render(re, pli0, &rcView, ili0 == cLine0 - 1, ili0, cLine0))
							return FALSE;
					}
					re.SetCp(cpNext);			 // Bypass [NOTACHAR] CELL
				}
			}
			if(!IsLowCell(uCell))				// Solo cell or top cell of
			{									//  vertically merged set
				if(!Render(re, pli1, &rcView, !pli1->GetPlo(), ili1, cLine1))
					return FALSE;
				if(dvp)							// Rendered set of vmerged cells
				{
					rcView.bottom -= dvp;		// Restore rcView/rcRender bottoms
					rcRender.bottom -= dvp;
					re.SetRcBottoms(rcView.bottom, rcRender.bottom);
				}
			}
			if(fSetErase)
				re.SetErase(TRUE);				// Restore CRenderer::_fErase
			re.SetRcViewTop(rcView.top);		// Restore re._rcView.top in case changed
			if(dulRTLRow)						// Restore rcView.right
				rcView.right = rcView.left - h;
			else
				rcView.left = rcView.right + h;
		}

		//Restore previous state
		re.SetLayout(ploOld);
		re.SetDulLayout(dulLayoutOld);
		re.SetDefaultBackColor(crBackOld);
		re.SetDefaultTextColor(crTextOld);
		re.StartRender(rcViewOld, rcRenderOld);
		re.SetCurPoint(ptOld);

		// Bypass table-row terminator
		AssertSz(re.GetPrevChar() == CELL && pPF->_bTabCount == plo->Count(),
			"CLayout::Render:: incorrect table cell count");
		AssertSz(re.GetChar() == ENDFIELD, "CLayout::Render: invalid table-row terminator");

		re.Move(2);							// Bypass table row terminator
		AssertSz(re.GetPrevChar() == CR, "invalid table-row terminator");

		BOOL fDrawBottomLine = !re._rpTX.IsAtTRD(STARTFIELD);
		LONG dvp = re.DrawTableBorders(pPF, u, plo->_dvp,
									   fDrawBottomLine | fLastLine*2, dul,
									   ploAbove ? ploAbove->GetPFCells() : NULL);
		if(re.IsHidden())
		{
			CCFRunPtr rp(re);
			re.Move(rp.FindUnhiddenForward());
		}
		if(re.GetChar() == CELL && pli->_fIncludeCell)
		{
			Assert(pPF->_bTableLevel > 1);
			re.Move(1);						// Bypass CELL at end of cell 
		}									//  containing a table
		ptOld.v += pli->GetHeight() + dvp;	// Advance to next line	position
		re.SetCurPoint(ptOld);
		if(fLastLine)
			re.EraseToBottom();
		return TRUE;
	}

	RECTUV	rcRender  = re.GetRcRender();
	LONG	dvpBottom = min(prcView->bottom, rcRender.bottom);
	LONG	dvpTop	  = max(prcView->top, rcRender.top);
	LONG	v0;
	dvpTop = max(dvpTop, 0);

	// Line's nested layout is a regular layout galley, i.e., not a table row
	for(ili1 = 0; ili1 < cLine1; ili1++, pli1++)
	{
		pt = re.GetCurPoint();
		v0 = pt.v + pli1->GetHeight();
		fLastLine = ili1 == cLine1 - 1 || v0 >= dvpBottom;

		//Support khyphChangeAfter
		re.SetIhyphPrev(ili1 > 0 ? (pli1 - 1)->_ihyph : 0);

		if(v0 < dvpTop)
		{
			pt.v = v0;						// Advance to next line	position
			re.SetCurPoint(pt);
			re.Move(pli1->_cch);
		}
		else if(pt.v >= dvpBottom)
			re.Move(pli1->_cch);			// Get to end of nested display

		else if(!Render(re, pli1, prcView, fLastLine, ili1, cLine1))
			return FALSE;
	}

	return TRUE;
 }

/*
 *	CLayout::GetVertAlignShift(uCell, dypText)
 *
 *	@mfunc
 *		Render visible part of the line *pli
 *
 *	@rdesc
 *		Vertical shift for cell text
 *
 *	@devnote
 *		Calculating this shift for vertically merged cells is tricky because
 *		dypCell = sum of the cell heights of all cells in the vertically
 *		merged set. In particular, if the table is not nested, one needs to
 *		wait for recalc of all rows in the set. dypText is relatively easy
 *		since it's the height of the top cell in the set.
 */
LONG CLayout::GetVertAlignShift(
	LONG	uCell,		//@parm uCell to use
	LONG	dypText)	//@parm Text height in cell
{
	LONG dyp = 0;
	if(IsVertMergedCell(uCell))
	{
	}
	else if(GetCellVertAlign(uCell))
	{
		dyp = _dvp - _dvpBrdrTop - _dvpBrdrBot - dypText;
		if(dyp > 0 && IsCellVertAlignCenter(uCell))
			dyp /= 2;
	}
	return dyp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\kern.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	KERN.CPP -- CCKernCache class |
 *
 *	Class which implements a kerning pair cache. Note that these widths
 *	are stored in the font's design units (2048 pixel high font)
 *	This allows us to share the same kerning pair information for all
 *	sizes of a font.
 *	
 *	The kerning cache assumes you know in advance how many entries
 *	you will put into the cache. It does not support the expensive
 *	operations of growing and re-hashing all the data.
 *
 *	Owner:<nl>
 *		Keith Curtis: Stolen from Quill '98, simplified and improved upon.
 * 
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include <_common.h>
#include <_kern.h>

const int dvpDesign = 2048;

/*
 *	CKernCache::FetchDup(chFirst, chSecond, dvpFont)
 *
 *	@mfunc
 *	Looks up the characters in the table and returns their pair
 *	adjustment if found.
 *
 *	We will scale the value from the font's design units.
 *	
 *	This routine is very important for performance.
 *	Many optimizations (double hashing, early returns if the data 
 *	didn't match but a collision wasn't found) actually slowed things down!
 *
 *	Note this is very similar to the below function but having
 *	separate functions makes pagination 7% faster.
 */
LONG CKernCache::FetchDup(WCHAR chFirst, WCHAR chSecond, LONG dvpFont)
{
	KERNHASHKEY kernhashkey = MakeHashKey(chFirst, chSecond);
	int ikpe = Hash(kernhashkey);

	KPE *pkpe = _pmpkpe.Elem(ikpe);

	for(;;)
	{
		if (pkpe->chFirst == chFirst && pkpe->chSecond == chSecond)
			return MulDiv(pkpe->du, dvpFont, dvpDesign);

		if (pkpe->chFirst == 0)			//Empty slot, so no pair
			return 0;

		ikpe++;
		pkpe++;
		if (ikpe == _pmpkpe.Count())	//Loop around if necessary
		{
			ikpe = 0;
			pkpe = _pmpkpe.Elem(0);
		}
	}
}

/*
 *	CKernCache::Add(chFirst, chSecond, du)
 *
 *	@mfunc
 *	Finds a free spot to put the kerning pair information.
 *	This function cannot fail because the array has been preallocated.
 *
 */
void CKernCache::Add(WCHAR chFirst, WCHAR chSecond, LONG du)
{
	KERNHASHKEY kernhashkey = MakeHashKey(chFirst, chSecond);
	int ikpe = Hash(kernhashkey);

	KPE *pkpe = _pmpkpe.Elem(ikpe);

	for(;;)
	{
		if (pkpe->chFirst == 0)
		{
			pkpe->chFirst = chFirst;
			pkpe->chSecond = chSecond;
			pkpe->du = du;
			return;
		}

		ikpe++;
		pkpe++;
		if (ikpe == _pmpkpe.Count())
		{
			ikpe = 0;
			pkpe = _pmpkpe.Elem(0);
		}
	}
}

/*
 *	CKernCache::FInit(hfont)
 *
 *	@mfunc
 *	If the kern cache is uninitialized, Init it. If there are no
 *	kerning pairs (or it failed) return FALSE.
 *
 *	@rdesc
 *	Return TRUE if you can fetch kerning pairs for this cache
 *
 */
BOOL CKernCache::FInit(HFONT hfont)
{
	if (_kcis == Unitialized)
		Init(hfont);

	return _kcis == Initialized;
}

/*
 *	CKernCache::Init(hfont)
 *
 *	@mfunc
 *	Fetches the kerning pairs from the OS in design units and hashes them
 *	all into a table. Updates _ckis with result
 *	
 */
void CKernCache::Init(HFONT hfont)
{
	KERNINGPAIR *pkp = 0;
	int prime, ikp;
	HFONT hfontOld = 0;
	HFONT hfontIdeal = 0;
	int ckpe = 0;

	HDC hdc = W32->GetScreenDC();

	LOGFONT lfIdeal;
	W32->GetObject(hfont, sizeof(LOGFONT), &lfIdeal);

	//FUTURE (keithcu) Support kerning of Greek, Cyrillic, etc.
	lfIdeal.lfHeight = -dvpDesign;
	lfIdeal.lfCharSet = ANSI_CHARSET;
	hfontIdeal = CreateFontIndirect(&lfIdeal);
	if (!hfontIdeal)
		goto LNone;

	hfontOld = SelectFont(hdc, hfontIdeal);
	Assert(hfontOld);

	ckpe = GetKerningPairs(hdc, 0, 0);
	if (ckpe == 0)
		goto LNone;

	prime = FindPrimeLessThan(ckpe * 5 / 2);
	if (prime == 0)
		goto LNone;

	pkp = new KERNINGPAIR[ckpe];
	if (!pkp)
		goto LNone;

	GetKerningPairs(hdc, ckpe, pkp);

	_pmpkpe.Add(prime, 0);

	PvSet(*(void**) &_pmpkpe);
	
	for (ikp = 0; ikp < ckpe; ikp++)
		Add(pkp[ikp].wFirst, pkp[ikp].wSecond, pkp[ikp].iKernAmount);

	_kcis = Initialized;
	goto LDone;

LNone:
	_kcis = NoKerningPairs;

LDone:
	delete []pkp;
	if (hfontOld)
		SelectObject(hdc, hfontOld);
	DeleteObject(hfontIdeal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\lbhost.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LBHOST.CPP -- Text Host for CreateWindow() Rich Edit 
 *		List Box Control | 
 *		Implements CLstBxWinHost message
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		12/15/97 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

#ifndef NOLISTCOMBOBOXES

#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"
#include "_cbhost.h"

ASSERTDATA

// REListbox scroll notification
#define LBN_PRESCROLL			0x04000
#define LBN_POSTSCROLL			0x08000

// special define to set VSCROLL topindex to index directly
#define SB_SETINDEX 0x0fff0

#ifdef DEBUG
const UINT db_rgLBUnsupportedStyle[] = {
	LBS_MULTICOLUMN,
	LBS_NODATA,			
	LBS_NOREDRAW,
	LBS_NOSEL,
	0
};

const UINT db_rgLBUnsupportedMsg[] = {
	LB_GETLOCALE,
	LB_SETLOCALE,
//	LB_INITSTORAGE,
	LB_ITEMFROMPOINT,
	LB_SETANCHORINDEX,
	LB_SETCOLUMNWIDTH,
	LB_ADDFILE,
	LB_DIR,
	EM_GETLIMITTEXT,
	EM_POSFROMCHAR,
	EM_CHARFROMPOS,
	EM_SCROLLCARET,
	EM_CANPASTE,
	EM_DISPLAYBAND,
	EM_EXGETSEL,
	EM_EXLIMITTEXT,
	EM_EXLINEFROMCHAR,
	EM_EXSETSEL,
	EM_FINDTEXT,
	EM_FORMATRANGE,
	EM_GETEVENTMASK,
	EM_GETOLEINTERFACE,
	EM_GETPARAFORMAT,
	EM_GETSELTEXT, 
	EM_HIDESELECTION,
	EM_PASTESPECIAL,
	EM_REQUESTRESIZE,
	EM_SELECTIONTYPE,
	EM_SETBKGNDCOLOR,
	EM_SETEVENTMASK,
	EM_SETOLECALLBACK,
	EM_SETTARGETDEVICE,
	EM_STREAMIN,
	EM_STREAMOUT,
	EM_GETTEXTRANGE,
	EM_FINDWORDBREAK,
	EM_SETOPTIONS,
	EM_GETOPTIONS,
	EM_FINDTEXTEX,
#ifdef _WIN32
	EM_GETWORDBREAKPROCEX,
	EM_SETWORDBREAKPROCEX,
#endif

	/* Richedit v2.0 messages */
	EM_SETUNDOLIMIT,
	EM_REDO,
	EM_CANREDO,
	EM_GETUNDONAME,
	EM_GETREDONAME,
	EM_STOPGROUPTYPING,
	EM_SETTEXTMODE,
	EM_GETTEXTMODE,
	EM_AUTOURLDETECT,
	EM_GETAUTOURLDETECT,
	EM_SHOWSCROLLBAR,	
	/* East Asia specific messages */
	EM_SETPUNCTUATION,
	EM_GETPUNCTUATION,
	EM_SETWORDWRAPMODE,
	EM_GETWORDWRAPMODE,
	EM_SETIMECOLOR,
	EM_GETIMECOLOR,
	EM_CONVPOSITION,
	EM_SETLANGOPTIONS,
	EM_GETLANGOPTIONS,
	EM_GETIMECOMPMODE,
	EM_FINDTEXTW,
	EM_FINDTEXTEXW,

	/* RE3.0 FE messages */
	EM_RECONVERSION,
	EM_SETIMEMODEBIAS,
	EM_GETIMEMODEBIAS,
	/* Extended edit style specific messages */
	0
};

// Checks if the style is in the passed in array
BOOL LBCheckStyle(UINT msg, const UINT* rg)
{
	for (int i = 0; rg[i]; i++)
		if (rg[i] & msg)
		{
			char Buffer[128];
			sprintf(Buffer, "Unsupported style recieved 0x0%lx", rg[i]);
			AssertSz(FALSE, Buffer);
			return TRUE;
		}
	return FALSE;
}

// Checks if the msg is in the passed in array
BOOL LBCheckMessage(UINT msg, const UINT* rg)
{
	for (int i = 0; rg[i]; i++)
		if (rg[i] == msg)
		{
			char Buffer[128];
			sprintf(Buffer, "Unsupported message recieved 0x0%lx", msg);
			AssertSz(FALSE, Buffer);
			return TRUE;
		}
	return FALSE;
}

#define CHECKSTYLE(msg) LBCheckStyle(msg, db_rgLBUnsupportedStyle)
#define CHECKMESSAGE(msg) LBCheckMessage(msg, db_rgLBUnsupportedMsg)
#else
#define CHECKSTYLE(msg)	
#define CHECKMESSAGE(msg)
#endif

// internal listbox messages
#define LB_KEYDOWN WM_USER+1

// UNDONE:
//	Should this go into _w32sys.h??
#ifndef CSTR_LESS_THAN
// 
//  Compare String Return Values. 
// 
#define CSTR_LESS_THAN            1           // string 1 less than string 2 
#define CSTR_EQUAL                2           // string 1 equal to string 2 
#define CSTR_GREATER_THAN         3           // string 1 greater than string 
#endif


// UNDONE : LOCALIZATION
// these vary by country/region!  For US they are VK_OEM_2 VK_OEM_5.
//       Change lboxctl2.c MapVirtualKey to character - and fix the spelling?
#define VERKEY_SLASH     0xBF   /* Vertual key for '/' character */
#define VERKEY_BACKSLASH 0xDC   /* Vertual key for '\' character */

// Used for Listbox notifications
#define LBNOTIFY_CANCEL 	1
#define LBNOTIFY_SELCHANGE 	2
#define LBNOTIFY_DBLCLK		4

// Used for LBSetSelection
#define LBSEL_SELECT	1
#define LBSEL_NEWANCHOR	2
#define LBSEL_NEWCURSOR	4
#define LBSEL_RESET		8
#define LBSEL_HIGHLIGHTONLY 16

#define LBSEL_DEFAULT (LBSEL_SELECT | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR | LBSEL_RESET)

// Used for keyboard and mouse messages
#define LBKEY_NONE 0
#define LBKEY_SHIFT	1
#define LBKEY_CONTROL 2
#define LBKEY_SHIFTCONTROL 3

extern const TCHAR szCR[];

// Size of allocated string
#define LBSEARCH_MAXSIZE 256

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);

// helper function for compare string.  This function checks for null strings
// because CStrIn doesn't like initializing string with zero length
int CompareStringWrapper( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cch1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cch2 			// size, in bytes or characters, of second string  
)
{
	// check if one of the 2 strings is 0-length if so then
	// no need to proceed the one with the 0-length is the less
	if (!cch1 || !cch2)
	{
		if (cch1 < cch2)
			return CSTR_LESS_THAN;
		else if (cch1 > cch2)
			return CSTR_GREATER_THAN;
		return CSTR_EQUAL;
	}
	return CompareString(Locale, dwCmpFlags, lpString1, cch1, lpString2, cch2);	
}

template<class CLbData> CLbData
CDynamicArray<CLbData>::_sDummy = {0, 0};

//////////////////////////// System Window Procs ////////////////////////////
/*
 *	RichListBoxWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services.
 *
 *	@rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
extern "C" LRESULT CALLBACK RichListBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichListBoxWndProc", msg);

	LRESULT	lres = 0;
	HRESULT hr;
	CLstBxWinHost *phost = (CLstBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
	BOOL	fRecalcHeight = FALSE;

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CLstBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam);

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WINCE)
		if (!phost)
		{
			(void) CLstBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam);
			phost = (CLstBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
		}
		break;

	case WM_DESTROY:
		if(phost)
			CLstBxWinHost::OnNCDestroy(phost);
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// in certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	CHECKMESSAGE(msg);

	long nTemp = 0;
	switch(msg)
	{
	///////////////////////Painting. Messages///////////////////////////////
	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		phost->OnSysColorChange();
		break;

	case WM_PRINTCLIENT:
	case WM_PAINT:
		{
			PAINTSTRUCT ps;
			RECT rc;
 			HPALETTE hpalOld = NULL;
			HDC		hdc;
			RECT rcClient;
			BOOL fErase = TRUE;

			//RAID 6964: WM_PRINTCLIENT should not call BeginPaint. If a HDC is passed
			//down in the wparam, use it instead of calling BeginPaint.
			if (!wparam)
			{
				hdc = BeginPaint(hwnd, &ps);
				fErase = ps.fErase;
			}
			else
				hdc = (HDC) wparam;
			
			// Since we are using the CS_PARENTDC style, make sure
			// the clip region is limited to our client window.
			GetClientRect(hwnd, &rcClient);

			// Set up the palette for drawing our data
			if(phost->_hpal)
			{
				hpalOld = SelectPalette(hdc, phost->_hpal, TRUE);
				RealizePalette(hdc);
			}

			SaveDC(hdc);
			IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
				rcClient.bottom);
				
			if (!phost->_fOwnerDraw)
			{
				phost->_pserv->TxDraw(
					DVASPECT_CONTENT,  		// Draw Aspect
					-1,						// Lindex
					NULL,					// Info for drawing optimazation
					NULL,					// target device information
					hdc,					// Draw device HDC
					NULL, 				   	// Target device HDC
					(const RECTL *) &rcClient,// Bounding client rectangle
					NULL, 					// Clipping rectangle for metafiles
					&ps.rcPaint,			// Update rectangle
					NULL, 	   				// Call back function
					NULL,					// Call back parameter
					TXTVIEW_ACTIVE);		// What view - the active one!
			}
			else if (phost->LbEnableDraw())
			{
				// Owner draw
				int nViewsize = phost->GetViewSize();
				int nCount = phost->GetCount();
				int nTopidx = phost->GetTopIndex();
				
				if (!phost->_fOwnerDrawVar)
				{
					// notify each visible item and then the one which has the focus
					int nBottom = min(nCount, nTopidx + nViewsize);
					if (nBottom >= nCount || !phost->IsItemViewable(nBottom))
						nBottom--;
					for (int i = nTopidx; i <= nBottom; i++) 
					{
						// get Rect of region and see if it intersects
			    		phost->LbGetItemRect(i, &rc);
			    		if (IntersectRect(&rc, &rc, &ps.rcPaint))
			    		{
							//first erase the background and notify parent to draw
							if (fErase)
								FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
			    			phost->LbDrawItemNotify(hdc, i, ODA_DRAWENTIRE, phost->IsSelected(i) ? ODS_SELECTED : 0);
			    		}
					}

					// Now draw onto the area where drawing may not have been done or erased
					if (fErase)
					{
						int nDiff = nCount - nTopidx;
						if (nDiff < nViewsize || 
							(phost->_fNoIntegralHeight && nDiff == nViewsize))
						{
							rc = rcClient;
							if (nDiff < 0)
								nDiff *= -1;  // lets be positive

							rc.top = nDiff * phost->GetItemHeight();
							if (IntersectRect(&rc, &rc, &ps.rcPaint))
								FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
						}
					}
				}
				else
				{
					// Owner draw with variable height case
					rc = rcClient;
					rc.left = 0;
					rc.bottom = rc.top;

					for (int i = nTopidx; i < nCount && rc.bottom < rcClient.bottom; i++)
					{
						RECT rcIntersect;
						rc.top = rc.bottom;
						rc.bottom = rc.top + phost->_rgData[i]._uHeight;
						if (IntersectRect(&rcIntersect, &rc, &ps.rcPaint))
			    		{
							//first erase the background and notify parent to draw
							if (fErase)
								FillRect(hdc, &rcIntersect, (HBRUSH)(COLOR_WINDOW + 1));
			    			phost->LbDrawItemNotify(hdc, i, ODA_DRAWENTIRE, phost->IsSelected(i) ? ODS_SELECTED : 0);
			    		}
					}

					if (fErase)
					{
						// Now draw onto the area where drawing may not have been done or erased
						if (rc.bottom < rcClient.bottom)
						{
							rc.top = rc.bottom;
							rc.bottom = rcClient.bottom;
							if (IntersectRect(&rc, &rc, &ps.rcPaint))
								FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW + 1));
						}
					}
				}
			}

			// Restore palette if there is one
#ifndef NOPALETTE
			if(hpalOld)
				SelectPalette(hdc, hpalOld, TRUE);
#endif
			RestoreDC(hdc, -1);

			// NOTE: Bug #5431
			// This bug could be fixed by replacing the hDC to NULL
			// The hdc can be clipped from BeginPaint API.  So just pass in NULL
			// when drawing focus rect
			phost->SetCursor(hdc, phost->GetCursor(), FALSE);			
			if (!wparam)
				EndPaint(hwnd, &ps);
		}
		break;

	/////////////////////////Mouse Messages/////////////////////////////////
	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
		break;

	case WM_LBUTTONDBLCLK:
		phost->_fDblClick = 1;
		/* Fall through case */
	case WM_LBUTTONDOWN:
		if (!phost->_fFocus)
			SetFocus(hwnd);
		phost->OnLButtonDown(wparam, lparam);
		break;
		
	case WM_MOUSEMOVE:
		if (!phost->GetCapture())
			break;
		phost->OnMouseMove(wparam, lparam);
		break;
		
	case WM_LBUTTONUP:	
		if (!phost->GetCapture())
			break;
		phost->OnLButtonUp(wparam, lparam, LBN_SELCHANGE);
		break;

	case WM_MOUSEWHEEL:
		if (wparam & (MK_SHIFT | MK_CONTROL))
			goto defwndproc;

		lres = phost->OnMouseWheel(wparam, lparam);
		break;

	///////////////////////KeyBoard Messages////////////////////////////////
	case WM_KEYDOWN:
		phost->OnKeyDown(LOWORD(wparam), lparam, 0);
		break;

	case WM_CHAR:
		if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				// UNDONE:
				// Need to see what we should do in WM_IME_CHAR
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
		
		phost->OnChar(LOWORD(wparam), lparam);
		break;
		
	case WM_TIMER:
		if (phost->OnTimer(wparam, lparam))
			goto serv;
		break;

	case LBCB_TRACKING:
		phost->OnCBTracking(wparam, lparam);
		break;

	//UNDONE:
	//	Messages should be ordered from most often called --> least often called
	//		
	case LB_GETITEMRECT:
		Assert(lparam);
		lres = -1;
		if (((wparam < (unsigned)phost->GetCount()) && 
			phost->IsItemViewable((long)wparam)) || wparam == (unsigned int)-1 ||
			wparam == 0 && phost->GetCount() == 0)
			lres = phost->LbGetItemRect(wparam, (RECT*)lparam);
		break;
	
	///////////////////////ListBox Messages/////////////////////////////////
	case LB_GETITEMDATA:
		if ((unsigned)phost->GetCount() <= wparam) 
			lres = LB_ERR;
		else
			lres = phost->GetData(wparam);
		break;
		
	case LB_SETITEMDATA:
		lres = LB_ERR;
		if ((int)wparam >= -1 && (int)wparam < phost->GetCount())
		{
			// if index is -1 this means all the dataItems are set
			// to the value
			lres = 1;
			if (wparam == -1)
				phost->LbSetItemData(0, phost->GetCount() - 1, lparam);
			else
				phost->LbSetItemData(wparam, wparam, lparam);
		}
		break;
	
	case LB_GETSELCOUNT:
		if (lparam != NULL || wparam != 0)
		{
			lres = LB_ERR;
			break;
		}
		// FALL through case
		
	case LB_GETSELITEMS:
		// retrieves all the selected items in the list
		lres = LB_ERR;
		if (!phost->IsSingleSelection())
		{
			int j = 0;
			for (int i = 0; i < phost->GetCount(); i++)
			{
				if (phost->IsSelected(i))
				{
					if (lparam)
					{
						if (j < (int)wparam)						
							((int*)lparam)[j] = i;
						else
							break;		// exced the buffer size
					}
					j++;
				}
			}
			lres = j;
		}
		break;
		
	case LB_GETSEL:
		// return the select state of the passed in index
		lres = LB_ERR;
		if ((int)wparam >= 0 && (int)wparam < phost->GetCount())
			lres = phost->IsSelected((long)wparam);		
		break;
		
	case LB_GETCURSEL:
		// Get the current selection
		lres = phost->LbGetCurSel();
		break;
		
	case LB_GETTEXTLEN:
		// Retieves the text at the requested index
		lres = LB_ERR;
		if (wparam < (unsigned)phost->GetCount())
			lres = phost->GetString(wparam, (PWCHAR)NULL);
		break;

	case LB_GETTEXT:			
		// Retieves the text at the requested index
		lres = LB_ERR;
		if ((int)lparam != NULL && (int)wparam >= 0 && (int)wparam < phost->GetCount())
			lres = phost->GetString(wparam, (PWCHAR)lparam);
		break;
		
	case LB_RESETCONTENT:
		// Reset the contents
		lres = phost->LbDeleteString(0, phost->GetCount() - 1);
		break;
		
	case LB_DELETESTRING:
		// Delete requested item
		lres = phost->LbDeleteString(wparam, wparam);
		break;
		
	case LB_ADDSTRING:
		lres = phost->LbInsertString((phost->_fSort) ? -2 : -1, (LPCTSTR)lparam);
		break;
		
	case LB_INSERTSTRING:
		lres = LB_ERR;
		if (wparam <= (unsigned long)phost->GetCount() || (signed int)wparam == -1 || wparam == 0)
			lres = phost->LbInsertString(wparam, (LPCTSTR)lparam);
		break;		

	case LB_GETCOUNT:
		// retrieve the count
		lres = phost->GetCount();
		break;
		
	case LB_GETTOPINDEX:
		// Just return the top index
		lres = phost->GetTopIndex();
		break;

	case LB_GETCARETINDEX:
		lres = phost->GetCursor();
		break;

	case LB_GETANCHORINDEX:
		lres = phost->GetAnchor();
		break;
		
	case LB_FINDSTRINGEXACT:
		// For NT compatibility
		wparam++;
		
		// Find and select the item matching the string text
		if ((int)wparam >= phost->GetCount() || (int)wparam < 0)
			wparam = 0;

		lres = phost->LbFindString(wparam, (LPCTSTR)lparam, TRUE);
		if (0 <= lres)
			break;
				
		lres = LB_ERR;
		break;
		
	case LB_FINDSTRING:	
		// For NT compatibility
		wparam++;
		
		// Find and select the item matching the string text
		if (wparam >= (unsigned)phost->GetCount())
			wparam = 0;

		lres = phost->LbFindString(wparam, (LPCTSTR)lparam, FALSE);
		if (0 > lres)
			lres = LB_ERR;
		break;
	
	case LB_SELECTSTRING:
		if (phost->IsSingleSelection())
		{			
			// For NT compatibility
			wparam++;
			
			// Find and select the item matching the string text
			if ((int)wparam >= phost->GetCount() || (int)wparam < 0)
				wparam = 0;

			lres = phost->LbFindString(wparam, (LPCTSTR)lparam, FALSE);
			if (0 <= lres)
			{
				// bug fix #5260 - need to move to selected item first
				// Unselect last item and select new one
				Assert(lres >= 0 && lres < phost->GetCount());
				if (phost->LbShowIndex(lres, FALSE) && phost->LbSetSelection(lres, lres, LBSEL_DEFAULT, lres, lres))
				{
#ifndef NOACCESSIBILITY
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);

					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
					break;
				}
			}			
		}
		// If failed then let it fall through to the LB_ERR
		lres = LB_ERR;
		break;
		
	case LB_SETSEL:
		// We only update the GetAnchor() and _nCursor if we are selecting an item
		if (!phost->IsSingleSelection())
		{
			// We need to return zero to mimic system listbox
			if (!phost->GetCount())
				break;

			//bug fix #4265
			int nStart = lparam;
			int nEnd = lparam;
			int nAnCur = lparam;
			if (lparam == (unsigned long)-1)
			{
				nAnCur = phost->GetCursor();
				nStart = 0;
				nEnd = phost->GetCount() - 1;
			}
			if (phost->LbSetSelection(nStart, nEnd, (BOOL)wparam ? 
				LBSEL_SELECT | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR : 0, nAnCur, nAnCur))		
			{
				if (wparam && lparam != ((unsigned long)-1) && nAnCur >= 0 && nAnCur < phost->GetCount()
					&& !phost->IsItemViewable(nAnCur))			// Is selected item in view?
					phost->LbShowIndex(nAnCur, FALSE);			//	scroll to the selected item

#ifndef NOACCESSIBILITY
				if (lparam == (unsigned long)-1)
				{
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
				}
				else if (wparam)
				{
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
				}
				else
				{
					phost->_nAccessibleIdx = lparam + 1;
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
				}
				phost->_fNotifyWinEvt = TRUE;
				phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
				break;
			}
		}

		// We only get here if error occurs or list box is a singel sel Listbox
		lres = LB_ERR;
		break;

	case LB_SELITEMRANGEEX:
		// For this message we need to munge the messages a little bit so it
		// conforms with LB_SETITEMRANGE
		if ((int)lparam > (int)wparam)
		{
			nTemp = MAKELONG(wparam, lparam);
			wparam = 1;
			lparam = nTemp;
		}
		else
		{
			nTemp = MAKELONG(lparam, wparam);
			wparam = 0;
			lparam = nTemp;			
		}	
		/* Fall through case */

	case LB_SELITEMRANGE:				
		// We have to make sure the range is valid
		if (LOWORD(lparam) >= phost->GetCount())
		{
			if (HIWORD(lparam) >= phost->GetCount())
				//nothing to do so exit without error
				break;
			lparam = MAKELONG(HIWORD(lparam), phost->GetCount() - 1);
		}
		else if (HIWORD(lparam) > LOWORD(lparam))
		{
			// NT swaps the start and end value if start > end
			lparam = MAKELONG(LOWORD(lparam), HIWORD(lparam) < phost->GetCount() ? 
				HIWORD(lparam) : phost->GetCount()-1);
		}

		// Item range messages do not effect the GetAnchor() nor the _nCursor
		if (!phost->IsSingleSelection() && phost->LbSetSelection(HIWORD(lparam), 
				LOWORD(lparam), (wparam) ? LBSEL_SELECT : 0, 0, 0))
		{
#ifndef NOACCESSIBILITY
			phost->_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
			phost->_fNotifyWinEvt = TRUE;
			phost->TxNotify(phost->_dwWinEvent, NULL);
#endif		
			break;
		}

		// We only get here if error occurs or list box is a singel sel Listbox
		lres = LB_ERR;
		break;

	case LB_SETCURSEL:
		// Only single selection list box can call this!!
		if (phost->IsSingleSelection())
		{
			// -1 should return LB_ERR and turn off any selection

			// special flag indicating no items should be selected
			if (wparam == (unsigned)-1)
			{	
				// turn-off any selections
				int nCurrentCursor = phost->GetCursor();
				phost->LbSetSelection(phost->GetCursor(), phost->GetCursor(), LBSEL_RESET, 0, 0);
				phost->SetCursor(NULL, -1, phost->_fFocus);
#ifndef NOACCESSIBILITY
				if (nCurrentCursor != -1)
				{
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_nAccessibleIdx = nCurrentCursor + 1;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
					phost->_nAccessibleIdx = nCurrentCursor + 1;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
				}
#endif
			}
			else if (wparam < (unsigned)(phost->GetCount()))
			{
				if ((int)wparam == phost->GetCursor() && phost->IsSelected((int)wparam) && 
				    phost->IsItemViewable((signed)wparam) ||
					phost->LbShowIndex(wparam, FALSE) /* bug fix #5260 - need to move to selected item first */
					&& phost->LbSetSelection(wparam, wparam, LBSEL_DEFAULT, wparam, wparam))
				{
					lres = (unsigned)wparam;
#ifndef NOACCESSIBILITY
					phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
					phost->_dwWinEvent = EVENT_OBJECT_SELECTION;
					phost->_fNotifyWinEvt = TRUE;
					phost->TxNotify(phost->_dwWinEvent, NULL);
#endif
					break;
				}
			}
		}
		// If failed then let it fall through to the LB_ERR
		lres = LB_ERR;
		break;

	case LB_SETTOPINDEX:
		// Set the top index
		if ((!phost->GetCount() && !wparam) || phost->LbSetTopIndex(wparam) >= 0)
			break;

		// We get here if something went wrong
		lres = LB_ERR;
		break;

	case LB_SETITEMHEIGHT:
		if (!phost->LbSetItemHeight(wparam, lparam))
			lres = LB_ERR;
		break;	

	case LB_GETITEMHEIGHT:
		lres = LB_ERR;
		if ((unsigned)phost->GetCount() > wparam || wparam == 0 || wparam == (unsigned)-1)
		{
			if (phost->_fOwnerDrawVar)
			{
				if ((unsigned)phost->GetCount() > wparam)
					lres = phost->_rgData[wparam]._uHeight;
			}
			else
				lres = phost->GetItemHeight();
		}
		break;

	case LB_SETCARETINDEX:
        if (((phost->GetCursor() == -1) || (!phost->IsSingleSelection()) &&
                    (phost->GetCount() > (INT)wparam)))
        {
            /*
             * Set's the Cursor to the wParam
             * if lParam, then don't scroll if partially visible
             * else scroll into view if not fully visible
             */
            if (!phost->IsItemViewable(wparam) || lparam)
            {
                phost->LbShowIndex(wparam, FALSE);
                phost->SetCursor(NULL, wparam, TRUE);
            }
            lres = 0;            
        } 
        else        
            return LB_ERR;            
        break;

	case EM_SETTEXTEX:
		lres = LB_ERR;
		if (lparam)
			lres = phost->LbBatchInsert((WCHAR*)lparam);	
		break;

	////////////////////////Windows Messages////////////////////////////////
	case WM_VSCROLL:
		phost->OnVScroll(wparam, lparam);
		break;

	case WM_CAPTURECHANGED:
		lres = phost->OnCaptureChanged(wparam, lparam);
		if (!lres)
			break;
		goto serv;

	case WM_KILLFOCUS:
		lres = 1;
		phost->_fFocus = 0;
		phost->SetCursor(NULL, phost->GetCursor(), TRUE);	// force the removal of focus rect
		phost->InitSearch();
		phost->InitWheelDelta();
		if (phost->_fLstType == CLstBxWinHost::kCombo)
			phost->OnCBTracking(LBCBM_END, 0);	//this will internally release the mouse capture
		phost->TxNotify(LBN_KILLFOCUS, NULL);
		break;

	case WM_SETFOCUS:
		lres = 1;
		phost->_fFocus = 1;
		phost->SetCursor(NULL, (phost->GetCursor() < 0) ? -2 : phost->GetCursor(), 
			FALSE);  // force the displaying of the focus rect
		phost->TxNotify(LBN_SETFOCUS, NULL);

#ifndef NOACCESSIBILITY
		if (!phost->_fDisabled && phost->GetCursor() != -1)
		{
			phost->_dwWinEvent = EVENT_OBJECT_FOCUS;
			phost->_fNotifyWinEvt = TRUE;
			phost->TxNotify(phost->_dwWinEvent, NULL);
		}
#endif
		break;

	case WM_SETREDRAW:
		lres = phost->OnSetRedraw(wparam);
		break;

	case WM_HSCROLL:
		phost->OnHScroll(wparam, lparam);
		break;

	case WM_SETCURSOR:
		// Only set cursor when over us rather than a child; this
		// helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
				lres = phost->OnSetCursor();
		}
		break;

	case WM_CREATE:
		lres = phost->OnCreate((CREATESTRUCT*)lparam);
		break;

    case WM_GETDLGCODE:	
		phost->_fInDialogBox = TRUE;
		lres |= DLGC_WANTARROWS | DLGC_WANTCHARS;
        break;

	////////////////////////System setting messages/////////////////////
	case WM_SETTINGCHANGE:
		phost->OnSettingChange(wparam, lparam);
		// Fall thru

	case WM_SYSCOLORCHANGE:
		phost->OnSysColorChange();
		//	Need to update the edit controls colors!!!!
		goto serv;							// Notify text services that
											//  system colors have changed

	case EM_SETPALETTE:
		// Application is setting a palette for us to use.
		phost->_hpal = (HPALETTE) wparam;

		// Invalidate the window & repaint to reflect the new palette.
		InvalidateRect(hwnd, NULL, FALSE);
		break;

	/////////////////////////Misc. Messages/////////////////////////////////
	case WM_ENABLE:
		if(!wparam ^ phost->_fDisabled)
		{
			// Stated of window changed so invalidate it so it will
			// get redrawn.
			InvalidateRect(phost->_hwnd, NULL, FALSE);
			phost->SetScrollBarsForWmEnable(wparam);
		}
		phost->_fDisabled = !wparam;				// Set disabled flag
		InvalidateRect(hwnd, NULL, FALSE);
		lres = 0;
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		goto defwndproc;
		break;

	case WM_STYLECHANGED:
		// FUTURE:
		//	We should support style changes after the control has been created
		//  to be more compatible with the system controls
		//
		// For now, we only interested in GWL_EXSTYLE Transparent mode changed.
		// This is to fix Bug 753 since Window95 is not passing us
		// the WS_EX_TRANSPARENT.
		// 
		lres = 1;
		if(GWL_EXSTYLE == wparam)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lparam;
			if(phost->IsTransparentMode() != (BOOL)(lpss->styleNew & WS_EX_TRANSPARENT))
			{
				phost->_dwExStyle = lpss->styleNew;
				((CTxtEdit *)phost->_pserv)->OnTxBackStyleChange(TRUE);

				// Return 0 to indicate we have handled this message
				lres = 0;
			}
		}
		break;

	case WM_SIZE:
		// Check if we have to recalculate the height of the listbox
		// Note if window is resized we will receive another WM_SIZE message
		// upon which the RecalcHeight will fail and we will proceed
		// normally
		if (phost->RecalcHeight(LOWORD(lparam), HIWORD(lparam)))
			break;
		phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		lres = phost->OnSize(hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));
		break;

	case WM_WINDOWPOSCHANGING:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN || phost->IsCustomLook())
			phost->OnSunkenWindowPosChanging(hwnd, (WINDOWPOS *) lparam);
		break;

	case WM_SHOWWINDOW:
		if ((phost->GetViewSize() == 0 || phost->_fLstType == CLstBxWinHost::kCombo) && wparam == 1)
		{
			// we need to do this because if we are part of a combo box
			// we won't get the size message because listbox may not be visible at time of sizing
			RECT rc;
			GetClientRect(hwnd, &rc);
			phost->_fVisible = 1;
			phost->RecalcHeight(rc.right, rc.bottom);
			
			//Since we may not get the WM_SIZE message for combo boxes we need to
			// do this in WM_SHOWWINDOW: bug fix #4080
			if (phost->_fLstType == CLstBxWinHost::kCombo)
			{
				phost->_pserv->TxSendMessage(WM_SIZE, SIZE_RESTORED, MAKELONG(rc.right, rc.bottom), NULL);
				phost->OnSize(hwnd, SIZE_RESTORED, rc.right, rc.bottom);
			}
		}

		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case LB_SETTABSTOPS:
		msg = EM_SETTABSTOPS;
		goto serv;

	case WM_ERASEBKGND:
		// We will erase the background in WM_PAINT.  For owner LB, we want
		// to check PAINTSTRUCT fErase flag before we erase the background.
		// Thus, if client (ie PPT) sub-class us and have handled the WM_ERASEBKGND,
		// we don't want to erase the background.
		lres = phost->_fOwnerDraw ? 0 : 1;
		break;

	case EM_SETPARAFORMAT:
		fRecalcHeight = TRUE;
		wparam = SPF_SETDEFAULT;
		goto serv;
		
	case EM_SETCHARFORMAT:
		fRecalcHeight = TRUE;
		wparam = SCF_ALL;	//wparam for this message should always be SCF_ALL
		goto serv;

	case EM_SETEDITSTYLE:
		lres = phost->OnSetEditStyle(wparam, lparam);
		break;

	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;

	case LB_GETHORIZONTALEXTENT:
		lres = phost->GetHorzExtent();
		break;

	case LB_SETHORIZONTALEXTENT:
		if (phost->_fHorzScroll)
		{
			LONG lHorzExtentLocal = (LONG)wparam;
			if (lHorzExtentLocal < 0)
				lHorzExtentLocal = 0;

			if (phost->GetHorzExtent() != lHorzExtentLocal)
			{
				phost->SetHorzExtent(lHorzExtentLocal);
				fRecalcHeight = TRUE;
			}
		}
		break;

	case WM_SETFONT:
		if (wparam)
			fRecalcHeight = TRUE;
		goto serv;

	case WM_SETTEXT:
		// We don't handle WM_SETTEXT, pass onto defWindowPorc to set
		// the title if this came from SetWindowText()
		Tracef(TRCSEVWARN, "Unexpected WM_SETTEXT for REListbox");
		goto defwndproc;

#ifndef NOACCESSIBILITY
	case WM_GETOBJECT:	
		IUnknown* punk;
		phost->QueryInterface(IID_IUnknown, (void**)&punk);
		Assert(punk);
		lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
		AssertSz(!FAILED((HRESULT)lres), "WM_GETOBJECT message FAILED\n");
		punk->Release();
		break;
#endif		

	default:
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);
		if(hr == S_FALSE)
		{			
defwndproc:
			// Message was not processed by text services so send it
			// to the default window proc.
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}
	}

	// Special border processing. The inset changes based on the size of the
	// defautl character set. So if we got a message that changes the default
	// character set, we need to update the inset.
	if (fRecalcHeight)
	{
		// need to recalculate the height of each item
		phost->ResizeInset();

		// need to resize the window to update internal window variables
		RECT rc;
		GetClientRect(phost->_hwnd, &rc);
		phost->RecalcHeight(rc.right, rc.bottom);

		if (WM_SETFONT == msg)
			phost->ResetItemColor();
	}
Exit:
	phost->Release();
	return lres;
}


//////////////// CTxtWinHost Creation/Initialization/Destruction ///////////////////////
#ifndef NOACCESSIBILITY
/*
 *	CLstBxWinHost::QueryInterface (REFIID, void)
 *
 *	@mfunc
 *		QI for IID_IAccessible
 *		
 */
HRESULT CLstBxWinHost::QueryInterface(
	REFIID riid,
	void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");

  	if(riid == IID_IAccessible)
		*ppv = (IAccessible*)this;
    else if (riid == IID_IDispatch)
		*ppv = (IDispatch*)(IAccessible*)this;
    else if (IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown*)(IAccessible*)this;
    else
        return CTxtWinHost::QueryInterface(riid, ppv);

	AddRef();
	return NOERROR;
}
#endif

/*
 *	CLstBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
LRESULT CLstBxWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnNCCreate");

#if defined DEBUG && !defined(NOPALETTE) 
	GdiSetBatchLimit(1);
#endif

	CLstBxWinHost *phost = new CLstBxWinHost();
	Assert(phost);
	if(!phost)
		return 0;

	if(!phost->Init(hwnd, pcs))					// Stores phost in associated
	{											//  window data
		Assert(FALSE);
		phost->Shutdown();
		delete phost;
		return FALSE;
	}
	return TRUE;
}

/*
 *	CLstBxWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_CREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLong())
 */
void CLstBxWinHost::OnNCDestroy(
	CLstBxWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnNCDestroy");

	CNotifyMgr *pnm = ((CTxtEdit*)(phost->_pserv))->GetNotifyMgr();

	if(pnm)
		pnm->Remove((ITxNotify *)phost);

	phost->_fShutDown = 1;
	// We need to send WM_DELETEITEM messages for owner draw list boxes
	if (phost->_fOwnerDraw && phost->_nCount)
	{
		phost->LbDeleteItemNotify(0, phost->_nCount - 1);		
	}
	if (phost->_pwszSearch)
		delete phost->_pwszSearch;

	// set the combobox's listbox hwnd pointer to null so combo box won't try 
	// to delete the window twice
	if (phost->_pcbHost)
	{
		phost->_pcbHost->_hwndList = NULL;
		phost->_pcbHost->Release();
	}
	
	phost->Shutdown();
	phost->Release();
}

/*
 *	CLstBxWinHost::CLstBxWinHost()
 *
 *	@mfunc
 *		constructor
 */
CLstBxWinHost::CLstBxWinHost() : CTxtWinHost(), _nCount(0), _fSingleSel(0), _nidxSearch(0), 
	_pwszSearch(NULL), _pcbHost(NULL)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::CTxtWinHost");
#ifndef NOACCESSIBILITY
	_dwWinEvent = 0;				// Win Event code (ACCESSIBILITY use)
	_nAccessibleIdx = -1;			// Index (ACCESSIBILITY use)
#endif
}

/*
 *	CLstBxWinHost::~CLstBxWinHost()
 *
 *	@mfunc
 *		destructor
 */
CLstBxWinHost::~CLstBxWinHost()
{
}

/*
 *	CLstBxWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CLstBxWinHost
 */
BOOL CLstBxWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs)	//@parm Corresponding CREATESTRUCT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Init");

	if(!pcs->lpszClass)
		return FALSE;
		
	// Set pointer back to CLstBxWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;
	_fHidden = TRUE;
	
	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		CHECKSTYLE(_dwStyle);
		
		//	Internally WinNT defines a LBS_COMBOBOX to determine
		//	if the list box is part of a combo box.  So we will use
		//	the same flag and value!!
		if (_dwStyle & LBS_COMBOBOX)
		{
			AssertSz(pcs->hMenu == (HMENU)CB_LISTBOXID && pcs->lpCreateParams,
				"invalid combo box parameters");
			if (pcs->hMenu != (HMENU)CB_LISTBOXID || !pcs->lpCreateParams)
				return -1;
				
			_pcbHost = (CCmbBxWinHost*) pcs->lpCreateParams;
			_pcbHost->AddRef();
			_fLstType = kCombo;
			_fSingleSel = 1;
		}
		else
		{
			//	NOTE:
			//	  The order in which we check the style flags immulate
			//	WinNT's order.  So please verify with NT order before
			//	reaaranging order.

			//	determine the type of list box
			//if (_dwStyle & LBS_NOSEL)			//Not implemented but may be in the future
			//	_fLstType = kNoSel;
			//else
			_fSingleSel = 0;
			if (_dwStyle & LBS_EXTENDEDSEL)
				_fLstType = kExtended;
			else if (_dwStyle & LBS_MULTIPLESEL)
				_fLstType = kMultiple;
			else
			{
				_fLstType = kSingle;
				_fSingleSel = 1;
			}
		}

		_fNotify = ((_dwStyle & LBS_NOTIFY) != 0);

		if (!(_dwStyle & LBS_HASSTRINGS))
		{
			_dwStyle |= LBS_HASSTRINGS;
			SetWindowLong(_hwnd, GWL_STYLE, _dwStyle);
		}


		_fDisableScroll = 0;
		if (_dwStyle & LBS_DISABLENOSCROLL)
		{
			_fDisableScroll = 1;

			// WARNING!!!
			// ES_DISABLENOSCROLL is equivalent to LBS_NODATA
			// Since we don'w support LBS_NODATA this should be 
			// fine.  But in the event we do want to support this 
			// in the future we will have to override the
			// TxGetScrollBars member function and return the 
			// proper window style

			// set the equivalent ES style
			_dwStyle |= ES_DISABLENOSCROLL;
		}			

		_fNoIntegralHeight = !!(_dwStyle & LBS_NOINTEGRALHEIGHT);
		_fOwnerDrawVar = 0;
		_fOwnerDraw = !!(_dwStyle & LBS_OWNERDRAWFIXED);
		if (_dwStyle & LBS_OWNERDRAWVARIABLE)
		{
			_fOwnerDraw = 1;
			_fOwnerDrawVar = 1;
			_fNoIntegralHeight = 1;		// Force no intergal height - following System LB
		}
		_fIntegralHeightOld = _fNoIntegralHeight;
		_fSort = !!(_dwStyle & LBS_SORT);

		_fHorzScroll = !!(_dwStyle & WS_HSCROLL);
				
		_fBorder = !!(_dwStyle & WS_BORDER);
		if(_dwExStyle & WS_EX_CLIENTEDGE)
			_fBorder = TRUE;

		// handle default disabled
		if(_dwStyle & WS_DISABLED)
			_fDisabled = TRUE;

		_fWantKBInput = !!(_dwStyle & LBS_WANTKEYBOARDINPUT);
		_fHasStrings = !!(_dwStyle & LBS_HASSTRINGS);
	}

	DWORD dwStyleSaved = _dwStyle;

	// get rid of all ES styles except ES_DISABLENOSCROLL
	_dwStyle &= (~(0x0FFFFL) | ES_DISABLENOSCROLL);

	// Create Text Services component
	if(FAILED(CreateTextServices()))
		return FALSE;

	_dwStyle = dwStyleSaved;
	_yInset = 0;
	_xInset = 0; //_xWidthSys / 2;

	// Shut-off the undo stack since listbox don't have undo's
	((CTxtEdit*)_pserv)->HandleSetUndoLimit(0);

	// Set alignment
	PARAFORMAT PF2;	
	PF2.dwMask = 0;

	if(_dwExStyle & WS_EX_RIGHT)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = PFA_RIGHT;	// right or center-aligned
	}
	
	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}

	// Tell textservices to select the entire background & disable ime for listbox
	_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EXTENDBACKCOLOR | SES_NOIME, SES_EXTENDBACKCOLOR | SES_NOIME, NULL);

	// Tell textservices to turn-on auto font sizing
	_pserv->TxSendMessage(EM_SETLANGOPTIONS, 0, IMF_AUTOFONT | IMF_AUTOFONTSIZEADJUST | IMF_UIFONTS, NULL);

	// NOTE: 
	// It is important we call this after
	// ITextServices is created because this function relies on certain
	// variable initialization to be performed on the creation by ITextServices
	// At this point the border flag is set and so is the pixels per inch
	// so we can initalize the inset.  
	_rcViewInset.left = 0;
	_rcViewInset.bottom = 0;
	_rcViewInset.right = 0;
	_rcViewInset.top = 0;
	
	_fSetRedraw = 1;

	return TRUE;
}

/*
 *	CLstBxWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CLstBxWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;

	DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
	
	// init variables
	UpdateSysColors();
	_idCtrl = (UINT)(DWORD_PTR)pcs->hMenu;
	_fKeyMaskSet = 0;
	_fMouseMaskSet = 0;
	_fScrollMaskSet = 0;
	_nAnchor = _nCursor = -1;
	_nOldCursor = -1;
	_fMouseDown = 0;
	_nTopIdx = 0;
	_cpLastGetRange = 0;
	_nIdxLastGetRange = 0;
	_fSearching = 0;
	_nyFont = _nyItem = 1;
	_fNoResize = 1;
	_stvidx = -1;
	_lHorzExtent = 0;
	InitWheelDelta();

	// Hide all scrollbars to start unless the disable scroll flag
	// is set
	if(_hwnd && !_fDisableScroll)
	{
		SetScrollRange(_hwnd, SB_VERT, 0, 0, TRUE);
		SetScrollRange(_hwnd, SB_HORZ, 0, 0, TRUE);

		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);
		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
	}
	
	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;	

	// Initially the font height is the item height	
	ResizeInset();
	Assert(_yInset == 0); // _yInset should be zero since listbox's doesn't have yinsets

	//We never want to display the selection or caret so tell textservice this
	_pserv->TxSendMessage(EM_HIDESELECTION, TRUE, FALSE, NULL);

	//Set the indents to 2 pixels like system listboxes	
	SetListIndent(2);
		
	_fNoResize = 0;
	_usIMEMode = ES_NOIME;

	CNotifyMgr *pnm = ((CTxtEdit*)_pserv)->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);

	return 0;
}

/*
 *	CLstBxWinHost::SetListIndent(int)
 *
 *	@mfunc
 *		Sets the left indent of a paragraph to the equivalent point value of nLeft, nLeft is
 *	given in device-coordinate pixels.
 *
 *	@rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::SetListIndent(
	int nLeft)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetListIndent");

	LRESULT lres;
	PARAFORMAT2 pf2;

	// tranlate the nLeft pixel value to point value
	long npt = MulDiv(nLeft, 1440, W32->GetXPerInchScreenDC());

	//format message struct
	pf2.cbSize = sizeof(PARAFORMAT2);
	pf2.dwMask = PFM_STARTINDENT;
	pf2.dxStartIndent = npt;

	// indent first line
	_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf2, &lres);

	return lres;
}

///////////////////////////////  Helper Functions  ////////////////////////////////// 
/*
 *	CLstBxWinHost::FindString(long, LPCTSTR, BOOL)
 *
 *	@mfunc
 *		This function checks a given index matches the search string
 *
 *	@rdesc
 *		BOOL = Match ? TRUE : FALSE
 */
BOOL CLstBxWinHost::FindString(
	long idx, 
	LPCTSTR szSearch, 
	BOOL bExact)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::FindString");

	Assert(_nCount);	

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;
	int cch = wcslen(szSearch);
	
	if ( (cch + 3 /* 2 paragraphs and a NULL*/) > 1024)
		psz = new WCHAR[cch + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	// format the string the way we need it
	wcscpy(psz, szSearch);
	if (bExact)
		wcscat(psz, szCR);		
	BOOL bMatch = FALSE;	
	ITextRange *pRange = NULL;
	BSTR bstrQuery = SysAllocString(psz);
	if (!bstrQuery)
		goto CleanExit;

	if (psz != sz)
		delete [] psz;
	
	// Set starting position for the search
	long cp, cp2;
	if (!GetRange(idx, idx, &pRange))
	{
		SysFreeString(bstrQuery);
		return FALSE;
	}
	
	CHECKNOERROR(pRange->GetStart(&cp));
	CHECKNOERROR(pRange->FindTextStart(bstrQuery, 0, FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC, NULL));
	CHECKNOERROR(pRange->GetStart(&cp2));
	bMatch = (cp == cp2);

CleanExit:
	if (bstrQuery)
		SysFreeString(bstrQuery);
	if (pRange)
		pRange->Release();
	return bMatch;	
}

/*
 *	CLstBxWinHost::MouseMoveHelper(int, BOOL)
 *
 *	@mfunc
 *		Helper function for the OnMouseMove function.  Performs
 *		the correct type of selection given an index to select
 *
 *	@rdesc
 *		void
 */
void CLstBxWinHost::MouseMoveHelper(
	int idx,
	BOOL bSelect)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::MouseMoveHelper");

	int ff = LBSEL_RESET | LBSEL_NEWCURSOR;
	if (bSelect)
		ff |= LBSEL_SELECT;
		
	switch (_fLstType)
	{
	case kSingle:
	case kCombo:
	case kExtended:										// perform the extended selection		
		if (LbSetSelection(_fLstType == kExtended ? _nAnchor : idx, idx, ff, idx, 0))
		{
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);

			if (_fLstType == kCombo)
			{
				_dwWinEvent = bSelect ? EVENT_OBJECT_SELECTION : EVENT_OBJECT_SELECTIONREMOVE;
				_fNotifyWinEvt = TRUE;
				TxNotify(_dwWinEvent, NULL);
			}
#endif
		}

		break;			

	case kMultiple:
		// Just change the cursor position
		SetCursor(NULL, idx, TRUE);
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_FOCUS;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
		break;	
	}
}
	
/*
 *	CLstBxWinHost::ResizeInset
 *
 *	@mfunc	Recalculates rectangle for a font change.
 *
 *	@rdesc	None.
 */
void CLstBxWinHost::ResizeInset()
{
	// Create a DC
	HDC hdc = GetDC(_hwnd);
	// Get the inset information
	LONG xAveCharWidth = 0;
	LONG yCharHeight = GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
		W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);

	ReleaseDC(_hwnd, hdc);

	// update our internal font and item height information with the new font
	if (_nyItem == _nyFont)
	{
		// We need to set the new font height before calling set item height
		// so set item height will set exact height rather than space after
		// for the default paragraph
		_nyFont = yCharHeight;
		SetItemsHeight(yCharHeight, TRUE);
	}
	else		
		_nyFont = yCharHeight;
}


/*
 *	CLstBxWinHost::RecalcHeight(int, int)
 *
 *	@mfunc
 *		Resized the height so no partial text will be displayed
 *
 *	@rdesc
 *		BOOL = window has been resized ? TRUE : FALSE
 */
BOOL CLstBxWinHost::RecalcHeight(
	int nWidth, 
	int nHeight)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::RecalcHeight");

	// NOTE: We should also exit if nWidth == 0 but PPT does some
	// sizing tests which we cause it to fail because before we
	// just exited when nWidth was 0. (bug fix #4196)
	// Check if any resizing should be done in the first place
	if (_fNoResize || !nHeight || IsIconic(_hwnd))
		return FALSE;
  	
	// get # of viewable items
	Assert(_yInset == 0);
	_nViewSize = max(1, (nHeight / max(_nyItem, 1)));
	
   	// Calculate the viewport
   	_rcViewport.left = 0;//(_fBorder) ? _xInset : 0;
   	_rcViewport.bottom = nHeight;
	_rcViewport.right = nWidth;
   	_rcViewport.top	= 0;
   	
	// bug fix don't do anything if the height is smaller then our font height
	if (nHeight <= _nyItem)
		return FALSE;

	if (_nyItem && (nHeight % _nyItem) && !_fNoIntegralHeight)
	{   	
		// we need to get the window rect before we can call SetWindowPos because
		// we have to include the scrollbar if the scrollbar is visible
		RECT rc;
		::GetWindowRect(_hwnd, &rc);

		// instead of worrying about the dimensions of the client edge and stuff we
		// figure-out the difference between the window size and the client size and add
		// that to the end of calculating the new height
		int nDiff = max(rc.bottom - rc.top - nHeight, 0);

		nHeight = (_nViewSize * _nyItem) + nDiff;
	
		// Resize the window
		SetWindowPos(_hwnd, HWND_TOP, 0, 0, rc.right - rc.left, nHeight,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSENDCHANGING);
		return TRUE;
	}
	else
	{
	    // bug fix #6011
	    // we need to force the display to update the width since it doesn't do it on
	    // WM_SIZE
	    _sWidth = nWidth;
	    _pserv->OnTxPropertyBitsChange(TXTBIT_EXTENTCHANGE, TXTBIT_EXTENTCHANGE);

        // We may need to adjust the top index if suddenly the viewsize becomes larger
        // and causes empty space to be displayed at the bottom
		int idx = GetTopIndex();
		if (!_fOwnerDrawVar)
		{
			if ((GetCount() - max(0, idx)) < _nViewSize)
				idx = GetCount() - _nViewSize;
		}
		else
		{
			// Get top index for the last page
			int iLastPageTopIdx = PageVarHeight(_nCount, FALSE);
			if (iLastPageTopIdx < idx)
				idx = iLastPageTopIdx;
		}
		//bug fix #4374
		// We need to make sure our internal state is in sync so update the top index
		// based on the new _nViewSize
		SetTopViewableItem(max(0, idx));
	}
	return FALSE;
}

/*
 *	CLstBxWinHost::ResetItemColor( )
 *
 *	@mfunc
 *		reset all the item colors when needed
 *
 */
void CLstBxWinHost::ResetItemColor()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::ResetItemColor");

	int nStart = 0;
	int nEnd = 0;

	// Don't do anything if there LB is empty or 
	// it is an owner draw LB
	if (_nCount <= 0 || _fOwnerDraw)
		return;

	BOOL bSelection = _rgData.Get(0)._fSelected;

	for (int i = 1; i < _nCount; i++)
	{
		if (_rgData.Get(i)._fSelected != (unsigned)bSelection)
		{
			// Update the colors only for selections
			if (bSelection)
				SetColors(_crSelFore, _crSelBack, nStart, nStart + nEnd);

			// Update our cache to reflect the value of our current index
			bSelection = _rgData.Get(i)._fSelected;
			nStart = i;
			nEnd = 0;
		}
		else
			nEnd++;
	}

	// there was some left over so change the color for these
	if (bSelection)
		SetColors(_crSelFore, _crSelBack, nStart, nStart + nEnd);
}

/*
 *	CLstBxWinHost::SortInsertList(WCHAR* pszDst, WCHAR* pszSrc)
 *
 *	@mfunc
 *		inserts a list of strings rather than one at a time with addstring
 *
 *	@rdesc
 *		int = amount of strings inserted;
 */
int CLstBxWinHost::SortInsertList(
	WCHAR* pszDst,
	WCHAR* pszSrc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SortInsertList");
 
	Assert(pszSrc != NULL);
	Assert(pszDst != NULL);
	const int ARRAY_DEFAULT = 256;

	//calculate the amount of strings to be inserted
	CHARSORTINFO rg[ARRAY_DEFAULT];
	int nMax = ARRAY_DEFAULT;
	int nLen = wcslen(pszSrc);
	CHARSORTINFO* prg = rg;
	memset(rg, 0, sizeof(rg));

	//insert first item in list to head or array
	prg[0].str = pszSrc;
	int i = 1;

	// go through store strings into array and replace <CR> with NULL
	WCHAR* psz = nLen + pszSrc - 1;	//start at end of list

	int nSz = 0;
	while (psz >= pszSrc)
	{		
		if (*psz == *szCR)
		{
	 		// Check if we need to allocate memory since we hit the maximum amount
	 		// allowed in array
	 		if (i == nMax)
	 		{
	 			int nSize = nMax + ARRAY_DEFAULT;
	 			CHARSORTINFO* prgTemp = new CHARSORTINFO[nSize];

	 			// Check if memory allocation failed
	 			Assert(prgTemp);
	 			if (!prgTemp)
	 			{
	 				if (prg != rg)
	 					delete [] prg;

	 				TxNotify((unsigned long)LBN_ERRSPACE, NULL);
	 				return LB_ERR;
	 			}

				// copy memory from 1 array to the next
				memcpy(prgTemp, prg, sizeof(CHARSORTINFO) * nMax);

	 			// delete any previously allocated memory
	 			if (prg != rg)
	 				delete [] prg;

				// set pointers and max to new values
	 			prg = prgTemp;
	 			nMax = nSize;
	 		}

	 		// record position of string into array
			prg[i].str = psz + 1;
			prg[i].sz = nSz;
			i++;
			nSz = 0;
		}
		else
			nSz++;

		psz--;		
	}
	prg[0].sz = nSz;	// update the size of first index since we didn't do it before

	i--; // set i to last valid index

	//now sort the array of items
	QSort(prg, 0, i);

	//create string list with the newly sorted list
	WCHAR* pszOut = pszDst;
	for (int j = 0; j <= i; j++)
	{
		memcpy(pszOut, (prg + j)->str, (prg + j)->sz * sizeof(WCHAR));
		pszOut = pszOut + (prg + j)->sz;
		*pszOut++ = L'\r';
	}
	*(--pszOut) = L'\0';

	// delete any previously allocated memory
	if (prg != rg)
		delete [] prg;

	return ++i;
} 


/*
 *	CLstBxWinHost::QSort(CHARSORTINFO rg[], int nStart, int nEnd)
 *
 *	@mfunc
 *		recursively quick sorts a given list of strings
 *
 *	@rdesc
 *		int = SHOULD ALWAYS RETURN TRUE;
 */
int CLstBxWinHost::QSort(
	CHARSORTINFO rg[],
	int nStart,
	int nEnd)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::QSort");
	
	// it's important these values are what they are since we use < and >
	Assert(CSTR_LESS_THAN == 1);
	Assert(CSTR_EQUAL == 2);
	Assert(CSTR_GREATER_THAN == 3);

	if (nStart >= nEnd)
		return TRUE;

	// for statisical efficiency lets use the item in the middle of the array for 
	// the sentinal	
	int mid = (nStart + nEnd) / 2;
	CHARSORTINFO tmp = rg[mid];
	rg[mid] = rg[nEnd];
	rg[nEnd] = tmp;


	int x = nStart;
	int y = nEnd - 1;

	WCHAR* psz = rg[nEnd].str;
	int nSz = rg[nEnd].sz;	
	for(;;)
	{	
		while ((x < nEnd) && CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, rg[x].str, rg[x].sz, 
			   psz, nSz) == CSTR_LESS_THAN)
			   x++;

		while ((y > x) && CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, rg[y].str, rg[y].sz, 
			   psz, nSz) == CSTR_GREATER_THAN)
			   y--;

		// swap elements
		if (x >= y)
			break;

		//if we got here then we need to swap the indexes
		tmp = rg[x];
		rg[x] = rg[y];
		rg[y] = tmp;

		// move to next index
		x++;
		y--;
	}
	tmp = rg[x];
	rg[x] = rg[nEnd];
	rg[nEnd] = tmp;

	QSort(rg, nStart, x - 1);
	QSort(rg, x + 1, nEnd);

	return TRUE;
}

/*
 *	CLstBxWinHost::CompareIndex(LPCTSTR, int)
 *
 *	@mfunc
 *		Recursive function which returns the insertion index of a sorted list
 *
 *	@rdesc
 *		int = position to insert string
 */
int CLstBxWinHost::CompareIndex(
	LPCTSTR szInsert, 
	int nIndex)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::CompareIndex");
	Assert(0 <= nIndex && nIndex < _nCount);
	
	// Get the string at a given index
	// compare the string verses the index
	ITextRange* pRange;
	if (!GetRange(nIndex, nIndex, &pRange))
		return -1;

	// Exclude the paragraph character at the end
	if (NOERROR != pRange->MoveEnd(tomCharacter, -1, NULL))
	{
		pRange->Release();
		return -1;
	}

	// we need to get the locale for the comparison
	// we will just use the locale of the string we want to compare with
	ITextFont* pFont;
	if (NOERROR != pRange->GetFont(&pFont))
	{
		pRange->Release();
		return -1;
	}

	BSTR bstr;
	int nRet;
	CHECKNOERROR(pRange->GetText(&bstr));
	
	if (!bstr)
		nRet = CSTR_GREATER_THAN;
	else if (!szInsert || !*szInsert)
	    nRet = CSTR_LESS_THAN;
	else
	{
		nRet = CompareStringWrapper(LOCALE_USER_DEFAULT, NORM_IGNORECASE, szInsert, wcslen(szInsert), 
								bstr, wcslen(bstr));
 		SysFreeString(bstr);
	}
 	pFont->Release();
 	pRange->Release();
 	return nRet;

CleanExit:
 	Assert(FALSE);
 	pFont->Release();
 	pRange->Release();
 	return -1;
}

/*
 *	CLstBxWinHost::GetSortedPosition(LPCTSTR, int, int)
 *
 *	@mfunc
 *		Recursive function which returns the insertion index of a sorted list
 *
 *	@rdesc
 *		int = position to insert string
 */
int CLstBxWinHost::GetSortedPosition(
	LPCTSTR szInsert,
	int nStart,
	int nEnd)
{	
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetSortedPosition");

	Assert(nStart <= nEnd);
	
	// Start at the middle of the list
	int nBisect = (nStart + nEnd) / 2;
	int fResult = CompareIndex(szInsert, nBisect);
	if (fResult == CSTR_LESS_THAN)
	{
		if (nStart == nBisect)
			return nBisect;
		else
			return GetSortedPosition(szInsert, nStart, nBisect - 1); // [nStart, nBisect)
	}
	else if (fResult == CSTR_GREATER_THAN)
	{
		if (nEnd == nBisect)
			return nBisect + 1;
		else
			return GetSortedPosition(szInsert, nBisect + 1, nEnd);   // (nBisect, nStart]
	}
	else /*fResult == 0 (found match)*/
		return nBisect;
}

/*
 *	CLstBxWinHost::SetScrollInfo
 *
 *	@mfunc	Set scrolling information for the scroll bar.
 */
void CLstBxWinHost::SetScrollInfo(
	INT fnBar,			//@parm	Specifies scroll bar to be updated
	BOOL fRedraw)		//@parm whether redraw is necessary
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetScrollInfo");

	Assert(_pserv);

	// Set up the basic structure for the call
	SCROLLINFO si;
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_ALL;

	// Call back to the control to get the parameters	
	if(fnBar == SB_VERT)
	{
		// Bug Fix #4913
		// if the scrollbar is disabled and count is less than the view size
		// then there is nothing to do so just exit out
		BOOL fGreaterThanView;

		if (_fOwnerDrawVar)
			SumVarHeight(0, GetCount(), &fGreaterThanView);
		else
			fGreaterThanView = (GetCount() > _nViewSize);

		if (!fGreaterThanView)
		{
			if (_fDisableScroll)
			{
				// Since listboxes changes height according to its content textservice
				// might of turned-on the scrollbar during an insert string.  Make sure
				// the scrollbar is disabled
				TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
			}
			else
				TxShowScrollBar(SB_VERT, FALSE);
			return;
		}
		else
			TxEnableScrollBar(SB_VERT, _fDisabled ? ESB_DISABLE_BOTH : ESB_ENABLE_BOTH);

		RECT rc;
		TxGetClientRect(&rc);
		
		// For owner draw cases we have to set the scroll positioning
		// ourselves		
		if (_fOwnerDraw)
		{
			Assert(GetCount() >= 0);

			si.nMin = 0;
			if (!_fOwnerDrawVar)
			{
				// We don't do anything here if 
				// item height is smaller than font height 
				if (_nyItem < _nyFont)
				{
					if (!_fDisableScroll)
						TxShowScrollBar(SB_VERT, FALSE);
					return;
				}
				si.nMax = _nyItem * GetCount();
				si.nPos = _nyItem * max(GetTopIndex(), 0);
			}
			else
			{
				int iTopIdx = max(GetTopIndex(), 0);

				si.nPos = SumVarHeight(0, iTopIdx);
				si.nMax = SumVarHeight(iTopIdx, GetCount()) + si.nPos;
			}
		}
		else
			_pserv->TxGetVScroll((LONG *) &si.nMin, (LONG *) &si.nMax, 
				(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);
		
		// need to take care of cases where items are partially exposed
		if (si.nMax)
		{			
			si.nPage = rc.bottom;	//our scrollbar range is based on pixels so just use the 
									//height of the window for the page size
			if (!_fOwnerDrawVar)
				si.nMax += (rc.bottom % _nyItem);

			// We need to decrement the max by one so maximum scroll pos will match
			// what the listbox should be the maximum value
			si.nMax--;
		}
	}
	else
		_pserv->TxGetHScroll((LONG *) &si.nMin, (LONG *) &si.nMax, 
			(LONG *) &si.nPos, (LONG *) &si.nPage, NULL);

	// Do the call
	::SetScrollInfo(_hwnd, fnBar, &si, fRedraw);
}

/* 
 *	CLstBxWinHost::TxGetScrollBars (pdwScrollBar)
 *
 *	@mfunc
 *		Get Text Host's scroll bars supported.
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 *	@comm
 *		<p pdwScrollBar> is filled with a boolean combination of the 
 *		window styles related to scroll bars.  Specifically, these are:
 *
 *			WS_VSCROLL	<nl>
 *			WS_HSCROLL	<nl>
 *			ES_AUTOVSCROLL	<nl>
 *			ES_AUTOHSCROLL	<nl>
 *			ES_DISABLENOSCROLL	<nl>
 */
HRESULT CLstBxWinHost::TxGetScrollBars(
	DWORD *pdwScrollBar) 	//@parm Where to put scrollbar information
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxGetScrollBars");

	*pdwScrollBar =  _dwStyle & (WS_VSCROLL | WS_HSCROLL | ((_fDisableScroll) ?  ES_DISABLENOSCROLL : 0));
	return NOERROR;
}

/* 
 *	CLstBxWinHost::TxGetHorzExtent (plHorzExtent)
 *
 *	@mfunc
 *		Get Text Host's horizontal extent
 *
 *	@rdesc
 *		HRESULT = S_OK
 *
 */
HRESULT CLstBxWinHost::TxGetHorzExtent (
	LONG *plHorzExtent)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxGetHorzExtent");
	*plHorzExtent = _lHorzExtent;
	return S_OK;
}

/*
 *	CLstBxWinHost::TxGetEffects()
 *
 *	@mfunc
 *		Indicates if a sunken window effect should be drawn
 *
 *	@rdesc
 *		HRESULT = (_fBorder) ? TXTEFFECT_SUNKEN : TXTEFFECT_NONE
 */
TXTEFFECT CLstBxWinHost::TxGetEffects() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::TxGetEffects");

	return (_fBorder) ? TXTEFFECT_SUNKEN : TXTEFFECT_NONE;
}

/* 
 *	CLstBxWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  All listbox notifications are post-action
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		The notification events are the same as the notification
 *		messages sent to the parent window of a listbox window.
 *
 *		<LBN_DBLCLK> user double-clicks an item in teh list box
 *
 *		<LBN_ERRSPCAE> The list box cannot allocate enough memory to 
 *		fulfill a request
 *
 *		<LBN_KILLFOCUS> The list box loses the keyboard focus
 *
 *		<LBN_CANCEL> The user cancels te selection of an item in the list
 *		box
 *
 *		<LBN_SELCHANGE> The selection in a list box is about to change
 *
 *		<LBN_SETFOCUS> The list box receives the keyboard focus
 *
 */
HRESULT CLstBxWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxNotify");

	HRESULT	hr = NOERROR;
	
	// Filter-out all the messages except Listbox notification messages

	// If _fNotifyWinEvt is true, we only need to do NotifyWinEvent
	if (_fNotify && !_fNotifyWinEvt)		// Notify parent?
	{
		Assert(_hwndParent);
		switch (iNotify)
		{		
			case LBN_DBLCLK:
			case LBN_ERRSPACE:
			case LBN_KILLFOCUS:
			case LBN_SELCANCEL:
			case LBN_SELCHANGE:
			case LBN_SETFOCUS:
			case LBN_PRESCROLL:
			case LBN_POSTSCROLL:
				hr = SendMessage(_hwndParent, WM_COMMAND, 
							GET_WM_COMMAND_MPS(_idCtrl, _hwnd, iNotify));						
		}
	}

	_fNotifyWinEvt = 0;

#ifndef NOACCESSIBILITY
	DWORD	dwLocalWinEvent = _dwWinEvent;
	int		nLocalIdx = _nAccessibleIdx;
	_dwWinEvent = 0;
	if (nLocalIdx == -1)
		nLocalIdx = _nCursor+1;
	_nAccessibleIdx = -1;
	if (iNotify == LBN_SELCHANGE || dwLocalWinEvent)
		W32->NotifyWinEvent(dwLocalWinEvent ? dwLocalWinEvent : EVENT_OBJECT_SELECTION, _hwnd, _idCtrl, nLocalIdx);

#endif
	return hr;
}


/*
 *	CLstBxWinHost::TxGetPropertyBits(DWORD, DWORD *)
 *
 *	@mfunc
 *		returns the proper style.  This is a way to fool the edit 
 *		control to behave the way we want it to
 *
 *	@rdesc
 *		HRESULT = always NOERROR
 */
HRESULT CLstBxWinHost::TxGetPropertyBits(
	DWORD dwMask, 
	DWORD *pdwBits)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::TxGetPropertyBits");

	// Note: the rich edit host will never set TXTBIT_SHOWACCELERATOR or
	// TXTBIT_SAVESELECTION. Those are currently only used by forms^3 host.

	// This host is always rich text.
	*pdwBits = (TXTBIT_RICHTEXT | TXTBIT_MULTILINE | TXTBIT_HIDESELECTION | 
				TXTBIT_DISABLEDRAG | TXTBIT_USECURRENTBKG) & dwMask;

	return NOERROR;
}

/* 
 *	CLstBxWinHost::TxShowScrollBar (nBar, fShow)
 *
 *	@mfunc
 *		Shows or Hides scroll bar in Text Host window 
 *
 *	@rdesc
 *		TRUE on success, FALSE otherwise
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.
 */
BOOL CLstBxWinHost::TxShowScrollBar(
	INT  nBar,			//@parm	Specifies scroll bar(s) to be shown or hidden
	BOOL fShow)			//@parm	Specifies whether scroll bar is shown or hidden
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxShowScrollBar");

	Assert(fShow == TRUE || fShow == FALSE);

	if (SB_VERT == nBar)
	{
		// There maybe cases where the item height is smaller than the font size
		// which means the notifications from ITextServices is wrong because
		// it uses the wrong line height.  We will use the following case
		// 1a) if _nyItem >= _nyFont OR
		// 1b) if window style is LBS_DISABLESCROLL OR
		// 1c) We are showing the scrollbar w/ current count greater than viewsize OR
		// 1d) We are hiding the scrollbar w/ current count <= viewsize


		if (_fDisableScroll || !_fOwnerDrawVar && (_nyItem >= _nyFont || fShow == (GetCount() > _nViewSize)))
			return CTxtWinHost::TxShowScrollBar(nBar, fShow);

		if (_fOwnerDrawVar)
		{
			BOOL fGreaterThanView;

			SumVarHeight(0, GetCount(), &fGreaterThanView);

			if (fShow == fGreaterThanView)
				return CTxtWinHost::TxShowScrollBar(nBar, fShow);
		}
	}
	else
	{
		if (fShow)											// When showing Horz scrollbar,
			_fNoIntegralHeight = TRUE;						//	turn on _fNoIntegralHeight.
		else
			_fNoIntegralHeight = _fIntegralHeightOld;		// Reset to previous setting

		return CTxtWinHost::TxShowScrollBar(nBar, fShow);
	}

	return FALSE;
}

/* 
 *	CLstBxWinHost::TxEnableScrollBar (fuSBFlags, fuArrowflags)
 *
 *	@mfunc
 *		Enables or disables one or both scroll bar arrows 
 *		in Text Host window.
 *
 *	@rdesc
 *		If the arrows are enabled or disabled as specified, the return 
 *		value is TRUE. If the arrows are already in the requested state or an 
 *		error occurs, the return value is FALSE. 
 *
 *	@comm
 *		This method is only valid when the control is in-place active;
 *		calls while inactive may fail.	
 */
BOOL CLstBxWinHost::TxEnableScrollBar (
	INT fuSBFlags, 		//@parm Specifies scroll bar type	
	INT fuArrowflags)	//@parm	Specifies whether and which scroll bar arrows
						//		are enabled or disabled
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CLstBxWinHost::TxEnableScrollBar");

	// There may be cases where the item height is smaller than the font size
	// which means the notifications from ITextServices is wrong.  We have to perform
	// some manual checking for owner draw listboxes. The following cases will be valid
	// 1. If the listbox is NOT owner draw
	// 2. If the message is to disable the control
	// 3. If the count is greater than the viewsize
	if (!_fOwnerDraw || ESB_ENABLE_BOTH != fuArrowflags)
		return CTxtWinHost::TxEnableScrollBar(fuSBFlags, fuArrowflags);

	BOOL fGreaterThanView = GetCount() > _nViewSize;

	if (_fOwnerDrawVar)
		SumVarHeight(0, GetCount(), &fGreaterThanView);

	if (fGreaterThanView)
		return CTxtWinHost::TxEnableScrollBar(fuSBFlags, fuArrowflags);

	return FALSE;
}


/*
 *	CLstBxWinHost::SetItemsHeight(int, BOOL)
 *
 *	@mfunc
 *		Sets the items height for all items
 *
 *	@rdesc
 *		int = number of paragraphs whose fontsize has been changed
 */
int CLstBxWinHost::SetItemsHeight(
	int nHeight,
	BOOL bUseExact)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetItemsHeight");

	if (_fOwnerDrawVar)
		return 1;

	// Calculate the new size in points
	long nptNew = MulDiv(nHeight, 1440, W32->GetYPerInchScreenDC());
	long nptMin = MulDiv(_nyFont, 1440, W32->GetYPerInchScreenDC());

	// NOTE:
	// This diverges from what the system list box does but there isn't a way
	// to set the height of a item to smaller than what the richedit will allow and
	// is not ownerdraw.  If it is owner draw make sure our height is not zero
	if (((nptNew < nptMin && !_fOwnerDraw) || nHeight <= 0) && !bUseExact)
		nptNew = nptMin;

	// Start setting the new height
	Freeze();
	long nPt;
	PARAFORMAT2 pf2;
	pf2.cbSize = sizeof(PARAFORMAT2);

	if (bUseExact)
	{
		pf2.dwMask = PFM_LINESPACING;
		pf2.bLineSpacingRule = 4;
		pf2.dyLineSpacing = nPt = nptNew;
	}
	else
	{		
		pf2.dwMask = PFM_SPACEAFTER;
		pf2.dySpaceAfter = max(nptNew - nptMin, 0);
		nPt = pf2.dySpaceAfter + nptMin;
	}

	// Set the default paragraph format
	LRESULT lr;
	_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (WPARAM)&pf2, &lr);

	// set the item height
	if (lr)
		_nyItem = (_fOwnerDraw && nHeight > 0) ? nHeight : 
					MulDiv(nPt, W32->GetYPerInchScreenDC(), 1440);

	Unfreeze();
	return lr;
}

/*
 *	CLstBxWinHost::UpdateSysColors()
 *
 *	@mfunc
 *		update the system colors in the event they changed or for initialization
 *		purposes
 *
 *	@rdesc
 *		<none>
 */
void CLstBxWinHost::UpdateSysColors()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::UpdateSysColors");

	// Update the system colors
	_crDefBack = ::GetSysColor(COLOR_WINDOW);
	_crSelBack = ::GetSysColor(COLOR_HIGHLIGHT);
	_crDefFore = ::GetSysColor(COLOR_WINDOWTEXT);
	_crSelFore = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
}

/*
 *	CLstBxWinHost::SetCursor(HDC, int, BOOL)
 *
 *	@mfunc
 *		Sets the cursor position, if it's valid and draws the focus rectangle if
 *		the control has focus.  The BOOL is used to determine if the previous
 *		cursor drawing needs to be removed
 *
 *	@rdesc
 *		<none>
 */
void CLstBxWinHost::SetCursor(
	HDC hdc,
	int idx,
	BOOL bErase)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetCursor");

	Assert(idx >= -2 && idx < _nCount);

	// Get the hdc if it wasn't passed in
	BOOL bReleaseDC = (hdc == NULL);
	if (bReleaseDC)
 		hdc = TxGetDC();
	Assert(hdc);

	RECT rc;
	// don't draw outside the client rect draw the rectangle
	TxGetClientRect(&rc);
	IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

	// Check if we have to remove the previous position
	if ((idx != _nCursor && _fFocus && idx >= -1) || bErase)
	{
		if (LbEnableDraw())
		{
 			if (_fOwnerDraw)
 				LbDrawItemNotify(hdc, _nCursor, ODA_FOCUS, (IsSelected(max(_nCursor, 0)) ? ODS_SELECTED : 0));
 			else if (IsItemViewable(max(0, _nCursor)))
			{
	 			LbGetItemRect(max(_nCursor, 0), &rc);
	 			::DrawFocusRect(hdc, &rc);
			}
		}
	}

	// special flag meaning to set the cursor to the top index
	// if there are items in the listbox
	if (idx == -2)
	{
		if (GetCount())
		{
			idx = max(_nCursor, 0);
			if (!IsItemViewable(idx))
				idx = GetTopIndex();
		}
		else
			idx = -1;
	}

	_nCursor = idx;

	// Only draw the focus rect if the cursor item is
	// visible in the list box
	if (_fFocus && LbEnableDraw())
	{
		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, max(0, _nCursor), ODA_FOCUS, ODS_FOCUS | (IsSelected(max(0, _nCursor)) ? ODS_SELECTED : 0));
 		else if (IsItemViewable(max(0, idx)))
		{
			// Now draw the rectangle
	 		LbGetItemRect(max(0,_nCursor), &rc);
	 		::DrawFocusRect(hdc, &rc);
		}
	}

	if (bReleaseDC)
 		TxReleaseDC(hdc);
}

/*
 *	CLstBxWinHost::InitSearch()
 *
 *	@mfunc
 *		Sets the array to its initial state
 *
 *	@rdesc
 *		<none>
 */
void CLstBxWinHost::InitSearch()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InitSearch");

	_fSearching = 0;
	_nidxSearch = 0;
	if (_pwszSearch)
 		*_pwszSearch = 0;
}
 
/*
 *	CLstBxWinHost::PointInRect(const POINT*)
 *
 *	@mfunc
 *		Determines if the given point is inside the listbox windows rect
 *		The point parameter should be in client coordinates.
 *
 *	@rdesc
 *		BOOL = inside listbox window rectangle ? TRUE : FALSE
 */
BOOL CLstBxWinHost::PointInRect(
	const POINT * ppt)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::PointInRect");
	Assert(ppt);

	RECT rc;
	::GetClientRect(_hwnd, &rc);
	return PtInRect(&rc, *ppt);
}

/*
 *	CLstBxWinHost::GetItemFromPoint(POINT*)
 *
 *	@mfunc
 *		Retrieves the nearest viewable item from a passed in point.
 *		The point should be in client coordinates.
 *
 *	@rdesc
 *		int = item which is closest to the given in point, -1 if there 
 *			  are no items in the list box
 */
int CLstBxWinHost::GetItemFromPoint(
	const POINT * ppt)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetItemFromPoint");

	// perform error checking first
	if (_nCount == 0)
		return -1;

	int y = (signed short)ppt->y;

	// make sure y is in a valid range
	if (y < _rcViewport.top)
 		y = 0;
	else if (y > _rcViewport.bottom)
 		y = _rcViewport.bottom - 1;

	//need to factor in the possibility an item may not fit entirely into the window view

	int idx;

	if (_fOwnerDrawVar)
	{
		int iHeightCurrent = 0;
		int iHeight;

		for (idx = GetTopIndex(); idx < _nCount; idx++)
		{
			iHeight = iHeightCurrent + _rgData[idx]._uHeight;
			if (iHeightCurrent <= y && y <= iHeight)
				break;		// Found it

			iHeightCurrent = iHeight;
		}
	}
	else
	{
		Assert(_nyItem);
		idx = GetTopIndex() + (int)(max(0,(y - 1)) / max(1,_nyItem));
	}

	Assert(IsItemViewable(idx));
	return (idx < _nCount ? idx : _nCount - 1);
}
 
/*
 *	CLstBxWinHost::ResetContent()
 *
 *	@mfunc
 *		Deselects all the items in the list box
 *
 *	@rdesc
 *		BOOL = If everything went fine ? TRUE : FALSE
 */
BOOL CLstBxWinHost::ResetContent()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::ResetContent");

	Assert(_fOwnerDraw == 0);

	// lets try to be smart about reseting the colors by only select a range
	// from the first selection found to the last selection found

	int nStart = _nCount - 1;
	int nEnd = -1;
	for (int i = 0; i < _nCount; i++)
	{
		if (_rgData[i]._fSelected)
		{
			_rgData[i]._fSelected = 0;

			if (nStart > i)
				nStart = i;
			if (nEnd < i)
				nEnd = i;
		}
	}

	Assert(nStart <= nEnd || ((nStart == _nCount - 1) && (nEnd == -1)));
	if (nStart > nEnd)
		return TRUE;

	return (_nCount > 0) ? SetColors((unsigned)tomAutoColor, (unsigned)tomAutoColor, nStart, nEnd) : FALSE;
}
 
/*
 *	CLstBxWinHost::GetString(long, PWCHAR)
 *
 *	@mfunc
 *		Retrieve the string at the requested index.  PWSTR can be null
 *		if only the text length is requires
 *
 *	@rdesc
 *		long = successful ? length of string : -1
 */
long CLstBxWinHost::GetString(
	long nIdx, 
	PWCHAR szOut)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetString");

	Assert(0 <= nIdx && nIdx < _nCount);
	if (nIdx < 0 || _nCount <= nIdx)
 		return -1;

	long l = -1;
	long lStart;
	long lEnd;
	ITextRange* pRange;
	BSTR bstr;
	if (!GetRange(nIdx, nIdx, &pRange))
 		return -1;
 		
	// Need to move one character to the left to unselect the paragraph marker.
	Assert(pRange);
	CHECKNOERROR(pRange->MoveEnd(tomCharacter, -1, &lEnd));
	CHECKNOERROR(pRange->GetStart(&lStart));
	CHECKNOERROR(pRange->GetEnd(&lEnd));

	// Get the string
	if (szOut)
	{
		if (_dwStyle & LBS_HASSTRINGS)
		{
			CHECKNOERROR(pRange->GetText(&bstr));
			if (bstr)
			{
				wcscpy(szOut, bstr);
				SysFreeString(bstr);
			}
			else
				wcscpy(szOut, L"");	// we got an empty string!
		}
		else
			(*(LPARAM *)szOut) = GetData(nIdx);
	}
	l = lEnd - lStart;

CleanExit:
	pRange->Release();
	return l;
}
 
/*
 *	CLstBxWinHost::InsertString(long, LPCTSTR)
 *
 *	@mfunc
 *		Insert the string at the requested location.  If the
 *		requested index is larger than _nCount then the function
 *		will fail.  The string is inserted with CR appended to
 *		to the front and back of the string
 *
 *	@rdesc
 *		BOOL = successfully inserted ? TRUE : FALSE
 */
BOOL CLstBxWinHost::InsertString(
	long nIdx,
	LPCTSTR szInsert)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::InsertString");

	Assert(szInsert);
	Assert(0 <= nIdx && nIdx <= _nCount);

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;

	if ( (wcslen(szInsert) + 3 /* 2 paragraphs and a NULL*/) > 1024)
		psz = new WCHAR[wcslen(szInsert) + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	*psz = NULL;
	if (nIdx == _nCount && _nCount)
		wcscpy(psz, szCR);

	// copy string and add <CR> at the end
	wcscat(psz, szInsert);

	// don't add the carriage return if the entry point is the end
	if (nIdx < _nCount)
		wcscat(psz, szCR);			

	BOOL bRet = FALSE;
	ITextRange * pRange = NULL;
	int fFocus = _fFocus;
	long idx = nIdx;
	BSTR bstr = SysAllocString(psz);
	if (!bstr)
		goto CleanExit;
	Assert(bstr);

	if (psz != sz)
		delete [] psz;

	// Set the range to the point where we want to insert the string 	

	// make sure the requested range is a valid one
	if (nIdx == _nCount)
		idx = max(idx - 1, 0);

	if (!GetRange(idx, idx, &pRange))
	{
 		SysFreeString(bstr);
 		return FALSE;
	}

	// Collapse the range to the start if insertion is in the middle or top
	// of list, collapse range to the end if we are inserting at the end of the list
	CHECKNOERROR(pRange->Collapse((idx == nIdx)));

	// Need to assume the item was successfully added because during SetText TxEnable(show)Scrollbar
	// gets called which looks at the count to determine if we should display the scroll bar
	_nCount++;

	//bug fix #5411
	// Check if we have focus, if so we need to remove the focus rect first and update the cursor positions	
	_fFocus = 0;
	SetCursor(NULL, (idx > GetCursor() || GetCursor() < 0) ? GetCursor() : GetCursor() + 1, fFocus);
	_fFocus = fFocus;


	//For fix height cases where the item height is less than the font we need to manually
	//enable the scrollbar if we need the scrollbar and the scrollbar is disabled.
	BOOL fSetupScrollBar;
	fSetupScrollBar = FALSE;
	if (!_fOwnerDrawVar && _nCount - 1 == _nViewSize &&
		((_nyItem < _nyFont && _fDisableScroll) || _fOwnerDraw))
	{
		fSetupScrollBar = TRUE;
		TxEnableScrollBar(SB_VERT, _fDisabled ? ESB_DISABLE_BOTH : ESB_ENABLE_BOTH);
	}

#ifdef _DEBUG
	if (bstr && wcslen(bstr))
		Assert(FALSE);
#endif

	if (NOERROR != (pRange->SetText(bstr)))
	{
		// NOTE: SetText could return S_FALSE which means it has added some characters but not all.
		// We do want to clean up the text in such case.
		pRange->SetText(NULL);		// Cleanup text that may have been added.
		_nCount--;
		
		//Unsuccessful in adding the string so disable the scrollbar if we enabled it
		if (fSetupScrollBar)
			TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
			
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		goto CleanExit;
	} 

	//We need to update the top index after a string is inserted
	if (idx < GetTopIndex())
		_nTopIdx++;
		
	bRet = TRUE;

CleanExit:
	if (bstr)
 		SysFreeString(bstr);
	if (pRange)
 		pRange->Release();
	return bRet;
}

/*
 *	BOOL CLstBxWinHost::RemoveString(long, long)
 *
 *	@mfunc
 *		Prevents TOM from drawing
 *
 *	@rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::RemoveString(
	long nStart,
	long nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::RemoveString");

	Assert(nStart <= nEnd);
	Assert(nStart < _nCount && nEnd < _nCount);

	// Remove item from richedit
	Freeze();
	ITextRange* pRange;
	if (!GetRange(nStart, nEnd, &pRange))
	{
		Unfreeze();
		return FALSE;
	}
	long l;
	
	// Since we can't erase the last paragraph marker we will erase
	// the paragraph marker before the item if it's not the first item
	HRESULT hr;
	if (nStart != 0)
	{
		hr = pRange->MoveStart(tomCharacter, -1, &l);
		Assert(hr == NOERROR);
		hr = pRange->MoveEnd(tomCharacter, -1, &l);
		Assert(hr == NOERROR);
	}

	if (NOERROR != pRange->Delete(tomCharacter, 0, &l) && _nCount > 1)
	{
		Unfreeze();
		pRange->Release();
		return FALSE;
	}
	pRange->Release();
	int nOldCt = _nCount;
	_nCount -= (nEnd - nStart) + 1;

	// Because we delete the paragraph preceeding the item
	// rather than following the item we need to update 
	// the paragraph which followed the item. bug fix #4074	
	long nFmtPara = max(nStart -1, 0);
	if (!_fOwnerDraw && (IsSelected(nEnd) != IsSelected(nFmtPara) || _nCount == 0))
	{		
		DWORD dwFore = (unsigned)tomAutoColor;
		DWORD dwBack = (unsigned)tomAutoColor;		
		if (IsSelected(nFmtPara) && _nCount)
		{
			dwFore = _crSelFore;
			dwBack = _crSelBack;		
		}
		SetColors(dwFore, dwBack, nFmtPara, nFmtPara);
	}

	// update our internal listbox records	
	int j = nEnd + 1;
	for(int i = nStart; j < nOldCt; i++, j++)
	{
		_rgData[i]._fSelected = _rgData.Get(j)._fSelected;
		_rgData[i]._lparamData = _rgData.Get(j)._lparamData;
		_rgData[i]._uHeight = _rgData.Get(j)._uHeight;
	}

	//bug fix #5397 
	//we need to reset the internal array containing information
	//about previous items
	while (--j >= _nCount)
	{
		_rgData[j]._fSelected = 0;
		_rgData[j]._lparamData = 0;
		_rgData[i]._uHeight = 0;
	}
		
	if (_nCount > 0)
	{
		// update the cursor			
		if (nStart <= _nCursor)
			_nCursor--;
		_nCursor = min(_nCursor, _nCount - 1);

		if (_fLstType == kExtended)
		{
			if (_nCursor < 0)
			{
				_nOldCursor = min(_nAnchor, _nCount - 1);
				_nAnchor = -1;
			}
			else if (_nAnchor >= 0)
			{
				if (nStart <= _nAnchor && _nAnchor <= nEnd)
				{
					// Store the old anchor for future use
					_nOldCursor = min(_nAnchor, _nCount - 1);
					_nAnchor = -1;
				}
			}
		}

		if (_fOwnerDraw)
		{
			RECT rcStart;
			RECT rcEnd;
			LbGetItemRect(nStart, &rcStart);
			LbGetItemRect(nEnd, &rcEnd);
			rcStart.bottom = rcEnd.bottom;
			if (IntersectRect(&rcStart, &rcStart, &_rcViewport))
			{
				// the list will get bumped up so we need to redraw
				// everything from the top to the bottom
				rcStart.bottom = _rcViewport.bottom;
				::InvalidateRect(_hwnd, &rcStart, FALSE);
			}
		}
	}
	else
	{
		SetTopViewableItem(0);
		_nAnchor = -1;
		_nCursor = -1;
	}

	//For fix height cases where the item height is less than the font we need to manually
	//enable the scrollbar if we need the scrollbar and the scrollbar is disabled.
	if (!_fOwnerDrawVar)
	{
		if ((_nyItem < _nyFont) && (_fDisableScroll) && 
			(_nCount <= _nViewSize) && (nOldCt > _nViewSize))
			TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
	}

	LbDeleteItemNotify(nStart, nEnd);
	Assert(GetTopIndex() >= 0);
	if (_nCount)
		LbShowIndex(min(GetTopIndex(), _nCount - 1), FALSE);
	Unfreeze();
	return TRUE;
}
 
/*
 *	CLstBxWinHost::Freeze()
 *
 *	@mfunc
 *		Prevents TOM from drawing
 *
 *	@rdesc
 *		freeze count
 */
long CLstBxWinHost::Freeze()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Freeze");
	long l;
	((CTxtEdit*)_pserv)->Freeze(&l);

	return l;
}

/*
 *	inline CLstBxWinHost::FreezeCount()
 *
 *	@mfunc
 *		Returns the current freeze count
 *
 *	@rdesc
 *		<none>
 */
short CLstBxWinHost::FreezeCount() const
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetFreezeCount");
	return ((CTxtEdit*)_pserv)->GetFreezeCount();
}

/*
 *	CLstBxWinHost::Unfreeze(long *)
 *
 *	@mfunc
 *		Allows TOM to update itself
 *
 *	@rdesc
 *		freeze count
 */
long CLstBxWinHost::Unfreeze()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::Unfreeze");
	long l;
	((CTxtEdit*)_pserv)->Unfreeze(&l);

    // HACK ALERT!
    // When ITextRange::ScrollIntoView starts caching the scroll position
    // in cases where the display is frozen the following code can be removed
    
    // We could have failed in ITextRange::ScrollIntoView
    // Check if we did and try calling it again
	if (!l && _stvidx >= 0)
	{
	    ScrollToView(_stvidx);
	    _stvidx = -1;
	}

	return l;
}

/*
 *	CLstBxWinHost::ScrollToView(long)
 *
 *	@mfunc
 *		Sets the given index to be at the top of 
 *		the viewable window space
 *
 *	@rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::ScrollToView(
	long nTop)
{
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetTopViewableItem");

	//Get the range which contains the item desired
	BOOL bVal = FALSE;
	ITextRange* pRange = NULL;
	
	if (!GetRange(nTop, nTop, &pRange))
	    return bVal;
    Assert(pRange);	 

    CHECKNOERROR(pRange->Collapse(1));
	CHECKNOERROR(pRange->ScrollIntoView(tomStart + /* TA_STARTOFLINE */ 32768));
	bVal = TRUE;

CleanExit:
	pRange->Release();

    // HACK ALERT!
    // When ITextRange::ScrollIntoView starts caching the scroll position
    // in cases where the display is frozen the following code can be removed
    
	//if we failed record the index we failed to scroll to	
	if (!bVal && FreezeCount())
	    _stvidx = nTop;
	return bVal;	
}

/*
 *	CLstBxWinHost::SetTopViewableItem(long)
 *
 *	@mfunc
 *		Sets the given index to be at the top of 
 *		the viewable window space
 *
 *	@rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::SetTopViewableItem(
	long nTop)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetTopViewableItem");

	// if we don't have any items in the list box then just set the topindex to 
	// zero
	if (_nCount == 0)
	{
		Assert(nTop == 0);
		_nTopIdx = 0;
		return TRUE;
	}

	// don't do anything if the requested top index is greater
	// then the amount of items in the list box
	Assert(nTop < _nCount);
	if (nTop >= _nCount)
 		return FALSE;

	// Don't do this if it's ownerdraw
	if (!_fOwnerDraw)
	{
		// Since we erase and draw the focus rect here
		// cache the focus rect info and don't bother with the
		// focus rect stuff until later
		int fFocus = _fFocus;
		_fFocus = 0;
		if (fFocus && IsItemViewable(GetCursor()))
			SetCursor(NULL, GetCursor(), TRUE);
		
		//Get the range which contains the item desired
		long nOldIdx = _nTopIdx;
		_nTopIdx = nTop;
		if (!ScrollToView(nTop))
		{
			// HACK ALERT!
			// When ITextRange::ScrollIntoView starts caching the scroll position
			// in cases where the display is frozen the following code can be removed            
			if (_stvidx >= 0)
				return TRUE;

			// Something went wrong and we weren't able to display the index requested
			// reset top index
			_nTopIdx = nOldIdx;		
		}

		// Note:
		//	If the cursor was not viewable then we don't attempt
		// to display the focus rect because we never erased it 
		_fFocus = fFocus;
		if (_fFocus & IsItemViewable(GetCursor()))
		{
			// Now we need to redraw the focus rect which we erased
			SetCursor(NULL, GetCursor(), FALSE);
		}
	}
	else
	{				
		int dy = (_nTopIdx - nTop) * _nyItem;

		if (_fOwnerDrawVar)
		{
			if (_nTopIdx > nTop)
				dy = SumVarHeight(nTop, _nTopIdx);
			else
				dy = -SumVarHeight(_nTopIdx, nTop);
		}

		RECT rc;
		TxGetClientRect(&rc);
		_nTopIdx = nTop;
		_fSetScroll = 0;
		if (_fSetRedraw)
		{
			if (((CTxtEdit *)_pserv)->_fLBScrollNotify)
				TxNotify(LBN_PRESCROLL, NULL);

			TxScrollWindowEx(0, dy, NULL, &rc, NULL, NULL, 
					SW_INVALIDATE | SW_ERASE | SW_SCROLLCHILDREN);
			if (((CTxtEdit *)_pserv)->_fLBScrollNotify)
				TxNotify(LBN_POSTSCROLL, NULL);

			if (_dwStyle & WS_VSCROLL)
				SetScrollInfo(SB_VERT, TRUE); // we update the scrollbar manually if we are in ownerdraw mode
			UpdateWindow(_hwnd);
		}
		else
			_fSetScroll = 1;
	}
		
	return TRUE;
}
 
/*
 *	CLstBxWinHost::GetRange(long, long, ITextRange**)
 *
 *	@mfunc
 *		Sets the range given the top and bottom index
 *		by storing the range into ITextRange
 *
 *	@rdesc
 *		BOOL = if function succeeded ? TRUE : FALSE
 */
BOOL CLstBxWinHost::GetRange(
	long nTop,
	long nBottom,
	ITextRange** ppRange)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::GetRange");

	// do some error checking
	if (nTop < 0 || nTop > _nCount || nBottom < 0 || nBottom > _nCount)
		return FALSE;

	Assert(ppRange);
	if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, ppRange))
	{
		Assert(FALSE);
		return FALSE;
	}
	Assert(*ppRange);

	if (_nIdxLastGetRange && nTop >= _nIdxLastGetRange)
	{
		long Count;
		CHECKNOERROR((*ppRange)->SetRange(_cpLastGetRange, _cpLastGetRange));
		if (nTop > _nIdxLastGetRange)
			CHECKNOERROR((*ppRange)->Move(tomParagraph, nTop - _nIdxLastGetRange, &Count));
		CHECKNOERROR((*ppRange)->MoveEnd(tomParagraph, 1, &Count));
	}
	else
	{
		CHECKNOERROR((*ppRange)->SetIndex(tomParagraph, nTop + 1, 1));
	}

	if (nBottom > nTop)
	{
		long l;
		CHECKNOERROR((*ppRange)->MoveEnd(tomParagraph, nBottom - nTop, &l));
	}

	if (nTop)
	{
		_nIdxLastGetRange = nTop;
		CHECKNOERROR((*ppRange)->GetStart(&_cpLastGetRange));
	}

	return TRUE;
CleanExit:
	Assert(FALSE);
	(*ppRange)->Release();
	*ppRange = NULL;
	_nIdxLastGetRange = 0;
	_cpLastGetRange = 0;
	return FALSE;
}

/*
 *	CLstBxWinHost::SetColors(DWORD, DWORD, long, long)
 *
 *	@mfunc
 *		Sets the background color for the givin range of paragraphs.  This
 *		only operates in terms of paragraphs.
 *
 *	@rdesc
 *		BOOL = if function succeeded in changing different color
 */
BOOL CLstBxWinHost::SetColors(
	DWORD dwFgColor,
	DWORD dwBgColor,
	long nParaStart,
	long nParaEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::SetColors");

	Assert(_fOwnerDraw == 0);
	
	//Get the range of the index
	ITextRange* pRange;
	if (!GetRange(nParaStart, nParaEnd, &pRange))
		return FALSE;

	BOOL bRet = FALSE;	
	ITextFont* pFont;

	// Set the background and forground color
	if (NOERROR != pRange->GetFont(&pFont))
	{
		pRange->Release();
		return FALSE;
	}	

	Assert(pFont);
	CHECKNOERROR(pFont->SetBackColor(dwBgColor));
	CHECKNOERROR(pFont->SetForeColor(dwFgColor));

	bRet = TRUE;
CleanExit:
	// Release pointers
	pFont->Release();
	pRange->Release();
	return bRet;

}

/////////////////////////////  Message Map Functions  ////////////////////////////////
/*
 *	void CLstBxWinHost::OnSetCursor()
 *
 *	@mfunc
 *		Handles the WM_SETCURSOR message.
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnSetCursor()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSetCursor");

	// Just make sure the cursor is an arrow if it's over us
	TxSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
	return 1;
}

/*
 *	void CLstBxWinHost::OnSetRedraw(WAPRAM)
 *
 *	@mfunc
 *		Handles the WM_SETREDRAW message.
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnSetRedraw(
	WPARAM wparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSetRedraw");

	long lCount = 0;
	BOOL fSetRedraw = (wparam == TRUE);

	if (fSetRedraw != (BOOL)_fSetRedraw)
	{
		_fSetRedraw = fSetRedraw;

		if (fSetRedraw)
			lCount = Unfreeze();	// Turn on display
		else
			lCount = Freeze();		// Turn off display
	}

	if (fSetRedraw && lCount == 0)
	{
		if (_fSetScroll)
		{
			_fSetScroll = 0;
			if (_dwStyle & WS_VSCROLL)
				SetScrollInfo(SB_VERT, TRUE);
		}
		OnSunkenWindowPosChanging(_hwnd, NULL);		// Erase frame/scrollbars as well
	}

	return 1;
}

/*
 *	void CLstBxWinHost::OnSysColorChange()
 *
 *	@mfunc
 *		Handles the WM_SYSCOLORCHANGE message.
 *
 */
void CLstBxWinHost::OnSysColorChange()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSysColorChange");

	if (!_fOwnerDraw)
	{
		// set the new colors
 		COLORREF crDefBack = _crDefBack;
 		COLORREF crDefFore = _crDefFore;
 		COLORREF crSelBack = _crSelBack;
 		COLORREF crSelFore = _crSelFore;
 		
 		// update colors
 		UpdateSysColors();

		// optimization check; don't do anything if there are no elements
		if (_nCount <= 0)
			return;

		// Only update the list box if colors changed
		if (crDefBack != _crDefBack || crDefFore != _crDefFore ||
	 		crSelBack != _crSelBack || crSelFore != _crSelFore)
		{
	 		//Bug fix #4847
	 		// notify parent first
 			CTxtWinHost::OnSysColorChange();
 			
			ResetItemColor();
		}
	}
}

/*
 *	CLstBxWinHost::OnSettingChange()
 *
 *	@mfunc
 *		forwards the WM_SETTINGCHANGE message to RECombobox
 *
 */
void CLstBxWinHost::OnSettingChange(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSettingChange");

	if (_pcbHost)
		SendMessage(_hwndParent, WM_SETTINGCHANGE, wparam, lparam); // Forward this message to cb host
}

/*
 *	LRESULT CLstBxWinHost::OnChar(WORD, DWORD)
 *
 *	@mfunc
 *		Handles the WM_CHAR message.
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnChar(
	WORD vKey,
	DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnChar");

	// don't do anything if list box is empty or in the middle of
	// a mouse down
	if (_fMouseDown || _nCount == 0)
 		return 0;

	BOOL fControl = (GetKeyState(VK_CONTROL) < 0);

	int nSel = -1;
	int nRes;

	if (_fWantKBInput && _fOwnerDraw && !_fHasStrings)
	{
		nRes = SendMessage(_hwndParent, WM_CHARTOITEM, MAKELONG(vKey, _nCursor), (LPARAM)_hwnd);

		if (nRes < 0)
			return 1;

		goto SELECT_SEL;
	}

	switch (vKey)
	{
	case VK_ESCAPE:
 		InitSearch();
 		return 0;
 		
	case VK_BACK:
 		if (_pwszSearch && _nidxSearch)
 		{
 			if (_nidxSearch > 0)
 				_nidxSearch--;
 			_pwszSearch[_nidxSearch] = NULL;
 			break;	// we break out of case because we still want to perform the search
 		}
 		return 0;		

	case VK_SPACE:
 		if (_fLstType == kMultiple)
 			return 0;
 		/* Fall through case */
 		
	default:
 		// convert CTRL+char to char
 		if (fControl && vKey < 0x20)
 			vKey += 0x40;

		// don't go beyond the search array size
 		if (_nidxSearch >= LBSEARCH_MAXSIZE)
 		{
 			((CTxtEdit*)_pserv)->Beep();
 			return 0;
 		}

		// allocate string if not already allocated
		if (_pwszSearch == NULL)
			_pwszSearch = new WCHAR[LBSEARCH_MAXSIZE];

		// error checking
		if (_pwszSearch == NULL)
		{
			((CTxtEdit*)_pserv)->Beep();
			Assert(FALSE && "Unable to allocate search string");
			return 0;
		}		

		// put the input character into string array
 		_pwszSearch[_nidxSearch++] = (WCHAR)vKey;
 		_pwszSearch[_nidxSearch] = NULL;
	}

	if (_fSort)
	{		
		nSel = (_fSearching) ? _nCursor + 1 : 0;

		// Start the search for a string
 		TxSetTimer(ID_LB_SEARCH, ID_LB_SEARCH_DEFAULT);
		_fSearching = 1;
	}
	else
	{
		_nidxSearch = 0;
		nSel = _nCursor + 1;
	}

	// Make sure our index isn't more than the items we have
	if (nSel >= _nCount)
		nSel = 0;

	nRes = LbFindString(nSel, _pwszSearch, FALSE);
	if (nRes < 0)
	{
		if (_pwszSearch)
		{
			if (_nidxSearch > 0)
				_nidxSearch--;
			if (_nidxSearch == 1 && _pwszSearch[0] == _pwszSearch[1])
			{
				_pwszSearch[1] = NULL;
				nRes = LbFindString(nSel, _pwszSearch, FALSE);
			}
		}
	}

SELECT_SEL:
	// If a matching string is found then select it
	if (nRes >= 0)
		OnKeyDown(nRes, 0, 1);

	//	If Hi-Ansi need to send a wm_syskeyup message to ITextServices to 
	// stabalize the state
	if (0x80 <= vKey && vKey <= 0xFF && !HIWORD(GetKeyState(VK_MENU)))
	{
		LRESULT lres;
		_pserv->TxSendMessage(WM_SYSKEYUP, VK_MENU, 0xC0000000, &lres);
	}	

	return 0;
}

 
/*
 *	LRESULT CLstBxWinHost::OnKeyDown(WPARAM, LPARAM, INT)
 *
 *	@mfunc
 *		Handles the WM_KEYDOWN message.  The BOOL ff is used as a flag for calls
 *	made internally and not responsive to the WM_KEYDOWN message.  Since this
 *	function is used for other things, ie helper to dealing with the WM_CHAR message.
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnKeyDown(
	WPARAM vKey,
	LPARAM lparam,
	int ff)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnKeyDown");

	// Ignore keyboard input if we are in the middle of a mouse down deal or
	// if there are no items in the listbox. Note that we let F4's go
	// through for combo boxes so that the use can pop up and down empty
	// combo boxes.
	if (_fMouseDown || (_nCount == 0 && vKey != VK_F4))
 		return 1;

	// Check if the shift key is down for Extended listbox style only
	int ffShift = 0;
	if (_fLstType == kExtended)
 		ffShift = HIWORD(GetKeyState(VK_SHIFT));

	// Special case!
	// Check if this function is called as a helper
	int nSel = (ff) ? vKey : -1;

	TxKillTimer(ID_LB_CAPTURE);

	if (_fWantKBInput && ff == 0)	// Need to notify the parent the key was pressed
		nSel = SendMessage(_hwndParent, WM_VKEYTOITEM, MAKELONG(vKey, _nCursor), (LPARAM)_hwnd);

	// if the parent returns -2 then we don't do anything and immediately exit out
	// if the parent returns >=0 then we just jump to that index
	// else we just continue with the default procedure.	
	if (nSel == -2)
		return 1;
	else if (nSel >= 0) 
		goto SKIP_DEFAULT;

	if (nSel < 0)
	{
 		// Need to set the selection so find the new selection
 		// based on the virtual key pressed
 		switch (vKey)
 		{
 		// UNDONE: Later, not language independent!!!
 		// Need to find-out how NT5.0 determines the slash issue??
 		
 		case VERKEY_BACKSLASH:
 			// Deselect everything if we are in extended mode
 			if (HIWORD(GetKeyState(VK_CONTROL)) && _fLstType == kExtended)
 			{
 				// NOTE:
 				//	Winnt loses the anchor and performing a shift+<vkey> 
 				//  doesn't select any items.  Instead, it just moves the
 				//  cursor w/o selecting the current cursor
 				_nAnchor = -1;
 				LbSetSelection(_nCursor, _nCursor, LBSEL_RESET | LBSEL_SELECT, 0, 0); 
 				TxNotify(LBN_SELCHANGE, NULL);
 			} 			
 			return 1;

 		case VK_DIVIDE:
 		case VERKEY_SLASH:
 			// Select everything if we are in extended mode
 			if (HIWORD(GetKeyState(VK_CONTROL)) && _fLstType == kExtended)
 			{
 				// NOTE:
 				//  Winnt behaves as we expect.  In other words the anchor
 				//  isn't changed and neither is the cursor
 				LbSetSelection(0, _nCount - 1, LBSEL_SELECT, 0, 0);
 				TxNotify(LBN_SELCHANGE, NULL);
 			}
 			return 1;
 		
 		case VK_SPACE:
 			// just get out if there is nothing to select
 			if (_nCursor < 0 && !GetCount())
 				return 1;
 			// Just select current item
 			nSel = _nCursor;
 			break;
 			
 		case VK_PRIOR:
 			// move the cursor up enough so the current item which the cursor
 			// is pointing to is at the bottom and the new cursor position is at the top
			if (_fOwnerDrawVar)
				nSel = PageVarHeight(_nCursor, FALSE);
			else
 				nSel = _nCursor - _nViewSize + 1;
 			if (nSel < 0)
 				nSel = 0;
 			break;
 			
 		case VK_NEXT:
 			// move the cursor down enough so the current item which the cursor
 			// is point is at the top and the new cursor position is at the bottom
			if (_fOwnerDrawVar)
				nSel = PageVarHeight(_nCursor, TRUE);
			else
 				nSel = _nCursor + _nViewSize - 1;

 			if (nSel >= _nCount)
 				nSel = _nCount - 1;
 			break; 			

 		case VK_HOME:
 			// move to the top of the list
 			nSel = 0;
 			break;
 			
 		case VK_END:
 			// move to the bottom of the list
 			nSel = _nCount - 1;
 			break;

 		case VK_LEFT:
 		case VK_UP:
 			nSel = (_nCursor > 0) ? _nCursor - 1 : 0;
 			break;

 		case VK_RIGHT:
 		case VK_DOWN:
 			nSel = (_nCursor < _nCount - 1) ? _nCursor + 1 : _nCount - 1;
 			break;

 		case VK_RETURN:
 		case VK_F4:
 		case VK_ESCAPE:
 			if (_fLstType == kCombo)
 			{
	 			Assert(_pcbHost);
	 			int nCursor = (vKey == VK_RETURN) ? GetCursor() : _nOldCursor;
	 			_pcbHost->SetSelectionInfo(vKey == VK_RETURN, nCursor);
	 			LbSetSelection(nCursor, nCursor, LBSEL_RESET | 
	 				((nCursor == -1) ? 0 : LBSEL_NEWCURSOR | LBSEL_SELECT), nCursor, nCursor);
				OnCBTracking(LBCBM_END, 0); // we need to do this because we may have some extra messages
											// in our message queue which can change the selections
	 			SendMessage(_hwndParent, LBCB_TRACKING, 0, 0);
	 		}
 			// NOTE:
 			//	We differ from Winnt here in that we expect the
 			// combobox window handler to do all the positioning and 
 			// showing of the list box.  So when we get this message
 			// and we are part of a combobox we should notify the 
 			// combobox and in turn the combobox should immediately close us.
 			//return 1;

 		//case VK_F8: // not suppported 

 		// We need to return this to pserv to process these keys
		/*
		case VK_MENU:
 		case VK_CONTROL:
 		case VK_SHIFT:
 			return 1;
 		*/
 		
 		default:
 			return 1; 		
 		}
	}

	// There can be cases where nSel = -1; _nCursor = -1 && _nViewSize = 1
	// make sure the selection index is valid
	if (nSel < 0)
 		nSel = 0;

SKIP_DEFAULT:
	// Should the cursor be set at the top or bottom of the list box??
	BOOL bTop = (_nCursor > nSel) ? TRUE : FALSE;
	Freeze();
	if (_fLstType == kMultiple)
	{
		if (vKey == VK_SPACE)
		{
			BOOL fSel = IsSelected(nSel);
			if (LbSetSelection(nSel, nSel, LBSEL_NEWCURSOR | (IsSelected(nSel) ? 0 : LBSEL_SELECT), nSel, 0))
			{
				_nAnchor = nSel;
#ifndef NOACCESSIBILITY
				_dwWinEvent = EVENT_OBJECT_FOCUS;
				_fNotifyWinEvt = TRUE;
				TxNotify(_dwWinEvent, NULL);
				if (fSel)
					_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
#endif
			}
		}
		else
		{
			SetCursor(NULL, nSel, TRUE);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
#endif
		}
	}
	else
	{
		if (ffShift && _fLstType == kExtended)
		{	 		
	 		// Set the anchor if it already isn't set
	 		_nOldCursor = -1;
			if (_nAnchor < 0)
				_nAnchor = nSel;

			LbSetSelection(_nAnchor, nSel, LBSEL_RESET | LBSEL_SELECT | LBSEL_NEWCURSOR, nSel, 0);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
			_dwWinEvent = EVENT_OBJECT_SELECTIONWITHIN;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
#endif
		}
		else
		{
	 		// if the selected item is already selected then
	 		// just exit out
	 		if (_nCursor == nSel && IsSelected(_nCursor))
	 		{
	 			Unfreeze();
	 			return 1;
	 		}

	 		LbSetSelection(nSel, nSel, LBSEL_DEFAULT, nSel, nSel);
#ifndef NOACCESSIBILITY
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
#endif
		}
	}
	// LbShowIndex eventually calls ScrollToView which fails if display is frozen
	Unfreeze();

	// Make sure the selection is visible
	LbShowIndex(nSel, bTop);

	// key presses qualify as ok selections so we have to update the old cursor position		
	TxNotify(LBN_SELCHANGE, NULL);

	_nOldCursor = _nCursor;
	return 1;
}
 
/*
 *	LRESULT CLstBxWinHost::OnTimer(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_TIMER message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnTimer(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnTimer");

	// Check which timer we have
	switch (wparam)
	{
	case ID_LB_CAPTURE:
		// for mouse movements let mousemove handler deal with it
		if (_fCapture)
		{
			POINT pt;
			::GetCursorPos(&pt);
			// Must convert to client coordinates to mimic the mousemove call
			TxScreenToClient(&pt);
			OnMouseMove(0, MAKELONG(pt.x, pt.y));
		}
		break;

	case ID_LB_SEARCH:
		// for type search.  If we get here means > 2 seconds elapsed before last
		// character was typed in so reset type search and kill the timer
		InitSearch();
		TxKillTimer(ID_LB_SEARCH);
		break;

	default:
		return 1;	
	}
	return 0;
}
 
/*
 *	LRESULT CLstBxWinHost::OnVScroll(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_VSCROLL message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnVScroll(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnVScroll");

	if (_fOwnerDrawVar)
	{
		BOOL fGreaterThanView;
		SumVarHeight(0, _nCount, &fGreaterThanView);
		if (!fGreaterThanView)		// If less than current view size
			return 0;				//	nothing to scroll
	}
	else if (_nCount <= _nViewSize)
		return 0;

	int nCmd = LOWORD(wparam);
	int nIdx = 0;
	switch (nCmd)
	{
	case SB_TOP:
		nIdx = 0;
		break;
		
	case SB_BOTTOM:
		if (_fOwnerDrawVar)
			nIdx = PageVarHeight(_nCount, FALSE) + 1;
		else
			nIdx = _nCount - _nViewSize;

		if (nIdx < 0)
			nIdx = 0;

		if (nIdx >= _nCount)
			nIdx = _nCount - 1;
		break;

	case SB_LINEDOWN:
		nIdx = GetTopIndex() + 1;
		break;		
		
	case SB_LINEUP:
		nIdx = GetTopIndex() - 1;
		if (nIdx < 0)
			nIdx = 0;
		break;
		
	case SB_PAGEDOWN:
		if (_fOwnerDrawVar)
			nIdx = PageVarHeight(GetTopIndex(), TRUE);
		else
		{
			nIdx = GetTopIndex() + _nViewSize;

			if (nIdx > (_nCount - _nViewSize))
				nIdx = _nCount - _nViewSize;
		}
		break;
		
	case SB_PAGEUP:
		if (_fOwnerDrawVar)
			nIdx = PageVarHeight(GetTopIndex(), FALSE);
		else
			nIdx = GetTopIndex() - _nViewSize;

		if (nIdx < 0)
			nIdx = 0;
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		// NOTE:
		//	if the list box is expected to hold more that 0xffff items
		//  then we need to modify this code to call GetScrollInfo.		
		if (_fOwnerDrawVar)
			nIdx = GetIdxFromHeight(HIWORD(wparam));
		else
			nIdx =  HIWORD(wparam) / _nyItem;
		break;

	case SB_SETINDEX:
		// Internal case for setting the index directly.
		nIdx = HIWORD(wparam);
		break;

		// Don't need to do anything for this case
	case SB_ENDSCROLL:
		return 0;	
	}
		
	LbSetTopIndex(nIdx);
	return 0;
}
 
/*
 *	LRESULT CLstBxWinHost::OnHScroll(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_HSCROLL message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnHScroll(
	WPARAM wparam,
	LPARAM lparam)
{
	BOOL	fRedrawCursor = FALSE;
	BOOL	fFocus = _fFocus;
	LRESULT lres = 0;
	int		nCmd = LOWORD(wparam);

	if (nCmd == SB_LINEDOWN || nCmd == SB_PAGEDOWN)
	{
		LONG lMax, lPos, lPage;
		_pserv->TxGetHScroll(NULL, &lMax, &lPos, &lPage, NULL);
		if (lPos + lPage >= lMax)
			return 0;

	}
	else if (nCmd == SB_ENDSCROLL)
		return 0;		// Do nothing for this case

	if (!_fOwnerDraw && fFocus && IsItemViewable(GetCursor()))
	{
		fRedrawCursor = TRUE;
		_fFocus = 0;
		SetCursor(NULL, GetCursor(), TRUE);	// force the removal of focus rect
	}

	_pserv->TxSendMessage(WM_HSCROLL, wparam, lparam, &lres);

	if (fRedrawCursor)
	{
		_fFocus = fFocus;
		SetCursor(NULL, GetCursor(), FALSE);		// Redraw the focus rect which we erased
	}
	return lres;
}

/*
 *	LRESULT CLstBxWinHost::OnCaptureChanged(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_CAPTURECHANGED message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnCaptureChanged(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCaptureChanged");

	if (_fCapture)
	{
		POINT pt;
		::GetCursorPos(&pt);
		::ScreenToClient(_hwnd, &pt);

		// prevent us from trying to release capture since we don't have
		// it anyways by set flag and killing timer
		_fCapture = 0;
		TxKillTimer(ID_LB_CAPTURE);		
		OnLButtonUp(0, MAKELONG(pt.y, pt.x), LBN_SELCANCEL);
	}
	return 0;
}

//FUTURE:
// Do we need to support ReadModeHelper? 

/*
 *	LRESULT CLstBxWinHost::OnMouseWheel(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_MOUSEWHEEL message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnMouseWheel(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnMouseWheel");

	// we don't to any zooms or anything of the sort
	if ((wparam & MK_CONTROL) == MK_CONTROL)
		return 1;

	// Check if the scroll is ok w/ the listbox requirements
	LRESULT lReturn = 1;
	short delta = (short)(HIWORD(wparam));
	_cWheelDelta -= delta;
	if ((abs(_cWheelDelta) >= WHEEL_DELTA) && (_dwStyle & WS_VSCROLL )) 
	{
		BOOL fGreaterThanView = _nCount > _nViewSize;

		if (_fOwnerDrawVar)
			SumVarHeight(0, _nCount, &fGreaterThanView);

		if (!fGreaterThanView)	// Smaller than current view size
			return lReturn;		//	no need to scroll

		// shut-off timer for right now
		TxKillTimer(ID_LB_CAPTURE);

		Assert(delta != 0);
        
		int nlines = W32->GetRollerLineScrollCount();
		if (nlines == -1)
		{
			OnVScroll(MAKELONG((delta < 0) ? SB_PAGEUP : SB_PAGEDOWN, 0), 0);
		}
		else
		{
			int nIdx;

			//Calculate the number of lines to scroll
			nlines *= _cWheelDelta/WHEEL_DELTA;

			if (!_fOwnerDrawVar)
			{
				//Perform some bounds checking
				nlines = min(_nViewSize - 1, nlines);
				nIdx = max(0, nlines + GetTopIndex());
				nIdx = min(nIdx, _nCount - _nViewSize);
			}
			else
			{
				int	idxNextPage = PageVarHeight(GetTopIndex(), TRUE);

				if (nlines > idxNextPage - GetTopIndex())
					nIdx = idxNextPage;
				else
					nIdx = max(0, nlines + GetTopIndex());
			}

			if (nIdx != GetTopIndex()) 
				OnVScroll(MAKELONG(SB_SETINDEX, nIdx), 0);
		}		

		_cWheelDelta %= WHEEL_DELTA;
	}
	return lReturn;
}

/*
 *	LRESULT CLstBxWinHost::OnLButtonUp(WPARAM, LPARAM, int)
 *
 *	@mfunc
 *		Handles the WM_LBUTTONUP and WM_CAPTURECHANGED message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnLButtonUp(
	WPARAM wparam,
	LPARAM lparam,
	int ff)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnLButtonUp");

	// if mouse wasn't down then exit out
	if (!_fMouseDown)
		return 0;
	_fMouseDown = 0;

	POINT pt;
	POINTSTOPOINT(pt, lparam);
	if (_fLstType == kCombo)
	{
 		Assert(_fCapture);
 		// Check if user clicked outside the list box
 		// if so this signifies the user cancelled and we
 		// should send a message to the parentwindow
		if (!PointInRect(&pt))
 		{	
			//User didn't click in listbox so reselect old item
			LbSetSelection(_nOldCursor, _nOldCursor, LBSEL_DEFAULT, _nOldCursor, _nOldCursor);
			ff = 0;
 		}
 		else
			ff = LBN_SELCHANGE;	//item changed so notify parent
 		
 		_pcbHost->SetSelectionInfo(ff == LBN_SELCHANGE, GetCursor());
		OnCBTracking(LBCBM_END, 0);
		::PostMessage(_hwndParent, LBCB_TRACKING, LBCBM_END, 0);
	}
	else
	{
 		// Kill any initializations done by mouse down... 
		_fMouseDown = 0;
		_nOldCursor = -1;
	}

	if (_fCapture)
	{
 		TxKillTimer(ID_LB_CAPTURE);
		_fCapture = 0;
 		TxSetCapture(FALSE); 	
	}

	if (ff)
	{
#ifndef NOACCESSIBILITY
		if (ff == LBN_SELCHANGE)
		{
			_dwWinEvent = EVENT_OBJECT_FOCUS;
			_fNotifyWinEvt = TRUE;
			TxNotify(_dwWinEvent, NULL);
			if (!IsSelected(_nCursor))
			{
				_dwWinEvent = EVENT_OBJECT_SELECTIONREMOVE;
			}
		}
#endif
		// Send notification if a notification exists
		TxNotify(ff, NULL);
	}

	return 1;
}

/*
 *	LRESULT CLstBxWinHost::OnMouseMove(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_MOUSEMOVE message and possibly the
 *		WM_TIMER message for tracking mouse movements
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnMouseMove(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnMouseMove");

	// bug fix #4998
	// Check if previous mouse position is the same as current, if it is
	// then this is probably a bogus message from PPT.
	POINT pt;
	POINTSTOPOINT(pt, lparam);
	if (_nPrevMousePos == lparam && PtInRect(&_rcViewport, pt))
 		return 0;
	_nPrevMousePos = lparam;

	// This routine will only start the autoscrolling of the listbox
	// The autoscrolling is done using a timer where the and the elapsed
	// time is determined by how far the mouse is from the top and bottom
	// of the listbox.  The farther from the listbox the faster the timer
	// will be.  This function relies on the timer to scroll and select
	// items.
	// We get here if mouse cursor is in the list box.
	int idx = GetItemFromPoint(&pt);

	// We only do the following if mouse is down.
	if (_fMouseDown)
	{
		int y = (short)pt.y;
		if (y < 0 || y > _rcViewport.bottom - 1)
		{
			// calculate the new timer settings
			int dist = y < 0 ? -y : (y - _rcViewport.bottom + 1);
			int nTimer = ID_LB_CAPTURE_DEFAULT - (int)((WORD)dist << 4);
				
			// Scroll up or down depending on the mouse pos relative
			// to the list box
			idx = (y <= 0) ? max(0, idx - 1) : min(_nCount - 1, idx + 1);
			if (idx >= 0 && idx < _nCount)
			{	
				// The ordering of this is VERY important to prevent screen
				// flashing...
				if (idx != _nCursor)
					MouseMoveHelper(idx, (_fLstType == kCombo) ? FALSE : TRUE);
				OnVScroll(MAKELONG((y < 0) ? SB_LINEUP : SB_LINEDOWN, 0), 0);
			}
			// reset timer
			TxSetTimer(ID_LB_CAPTURE, (5 > nTimer) ? 5 : nTimer);
			return 0;
		}
		// Don't select if we are part of a combo box and mouse is outside client area
		else if (_fLstType == kCombo && (pt.x < 0 || pt.x > _rcViewport.right - 1))
			return 0;
	}
	else if (!PointInRect(&pt))
		return 0;

	if (idx != _nCursor || (_fLstType == kCombo && idx >= 0 && !IsSelected(idx)))
	{			
		// Prevent flashing by not redrawing if index
		// didn't change
		Assert(idx >= 0);
		MouseMoveHelper(idx, TRUE);
	}
	return 0;
}
 
/*
 *	LRESULT CLstBxWinHost::OnLButtonDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles the WM_LBUTTONDOWN message
 *
 *	@rdesc
 *		LRESULT = return value after message is processed
 */
LRESULT CLstBxWinHost::OnLButtonDown(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnLButtonDown");
	
	POINT pt;
	POINTSTOPOINT(pt, lparam);

	if (_fCapture)
	{
		// Need to check if the listbox is part of a combobox, if so
		// then we need to notify the parent class.
		if (_fLstType == kCombo)
		{
			// Need to perform the following
			// - check if click is within client area of combo box if not then
			//		behave as if user cancelled
			if (!PointInRect(&pt))
			{
				// reset our double click flag because we could be double clicking on the scrollbar
				_fDblClick = 0;
				
				// check if the scroll bar was clicked
				// mouse message won't get posted unless we release it 
				// for a short while
				TxClientToScreen(&pt);				
				LRESULT lHit = SendMessage(_hwnd, WM_NCHITTEST, 0, MAKELONG(pt.x, pt.y));
				// check if user clicked on the scrollbar
				if (HTVSCROLL == lHit || HTHSCROLL == lHit)
				{
					if (_fCapture)
					{
						_fCapture = 0;
						TxSetCapture(FALSE);
					}

					SendMessage(_hwnd, WM_NCLBUTTONDOWN, lHit, MAKELONG(pt.x, pt.y));

					TxSetCapture(TRUE);
					_fCapture = 1;
				}
				else if (HTGROWBOX != lHit)
				{
					// if user didn't click the scrollbar then notify parent and stop
					// tracking else just get out
					Assert(_pcbHost);
					_pcbHost->SetSelectionInfo(FALSE, _nOldCursor);
					LbSetSelection(_nOldCursor, _nOldCursor, LBSEL_RESET | 
						((_nOldCursor == -1) ? 0 : LBSEL_NEWCURSOR | LBSEL_SELECT), 
						_nOldCursor, _nOldCursor);
					OnCBTracking(LBCBM_END, 0);
					SendMessage(_hwndParent, LBCB_TRACKING, 0, 0);
				}				
				return 0;
			}
		}
	}	
	
	int idx = GetItemFromPoint(&pt);
	if (idx <= -1)
	{
		_fDblClick = 0;
		return 0;
	}

	_fMouseDown = 1;

	// if the message was a double click message than don't need to go
	// any further just fake a mouseup message to get back to a normal
	// state	
	if (_fDblClick)
	{
		_fDblClick = 0;
		OnLButtonUp(wparam, lparam, LBN_DBLCLK);
		return 0;
	}
		
	// Set the timer in case the user scrolls outside the listbox
	if (!_fCapture)
	{
		TxSetCapture(TRUE);
		_fCapture = 1;
		TxSetTimer(ID_LB_CAPTURE, ID_LB_CAPTURE_DEFAULT);	
	}

	int ffVirtKey = LBKEY_NONE;
	if (_fLstType == kExtended)
	{
		if (HIWORD(GetKeyState(VK_SHIFT)))
			ffVirtKey |= LBKEY_SHIFT;
		if (HIWORD(GetKeyState(VK_CONTROL)))
			ffVirtKey |= LBKEY_CONTROL;
	}

	int ff = 0;
	int i = 0;
	int nStart = idx;
	int nEnd = idx;
	int nAnchor = _nAnchor;
	switch (ffVirtKey)
	{	
	case LBKEY_NONE:
		// This case accounts for listbox styles with kSingle, kMultiple, and 
		// kExtended w/ no keys pressed
		if (_fLstType == kMultiple)
		{
			ff = (IsSelected(idx) ? 0 : LBSEL_SELECT) | LBSEL_NEWANCHOR | LBSEL_NEWCURSOR;			
		}
		else
		{
			// keep a copy of the old cursor position around for combo cancells			
			ff = LBSEL_DEFAULT;
		}
		nAnchor = idx;
		break;
		
	case LBKEY_SHIFT:		
		// Now select all the items between the anchor and the current selection
		// The problem is LbSetSelection expects the first index to be less then
		// or equal to the second index so we have to manage the Anchor and index
		// ourselves..				
		ff = LBSEL_SELECT | LBSEL_RESET | LBSEL_NEWCURSOR;
		i = !(IsSelected(_nAnchor));
		if (_nAnchor == -1)
		{
			ff |= LBSEL_NEWANCHOR;
			nAnchor = idx;
		}
		else if (_nAnchor > idx)
		{
			nEnd = _nAnchor - i;			
		}
		else if (_nAnchor < idx)
		{
			nEnd = _nAnchor + i;
		}
		else if (i) // _nAnchor == idx && idx IS selected
		{
			ff = LBSEL_RESET;
			nStart = 0;
			nEnd = 0;
		}
		break;
		
	case LBKEY_CONTROL:
		// Toggle the selected item and set the new anchor and cursor
		// positions
		ff = LBSEL_NEWCURSOR | LBSEL_NEWANCHOR | (IsSelected(idx) ? 0 : LBSEL_SELECT);
		nAnchor = idx;
		break;
		
	case LBKEY_SHIFTCONTROL:
		// De-select any items between the cursor and the anchor (excluding the anchor)
		// and select or de-select the new items between the anchor and the cursor

		// Set the anchor if it already isn't set
		if (_nAnchor == -1)
			_nAnchor = (_nOldCursor >= 0) ? _nOldCursor : idx;
			
		// Just deselect all items between the cursor and the anchor
		if (_nCursor != _nAnchor)
		{
			// remove selection from old cursor position to the current anchor position
			LbSetSelection(_nCursor, (_nCursor > _nAnchor) ? _nAnchor + 1 : _nAnchor - 1, 0, 0, 0);
		}

		// Check if we used a temporary anchor if so then set the anchor to
		// idx because we don't want the temporary anchor to be the actual anchor
		if (_nOldCursor >= 0)
		{
			_nOldCursor = -1;
			_nAnchor = idx;
		}

		// Set the state of all items between the new Cursor (idx) and 
		// the anchor to the state of the anchor
		ff = LBSEL_NEWCURSOR | (IsSelected(_nAnchor) ? LBSEL_SELECT : 0);
		nEnd = _nAnchor;
		break;
	default:
		Assert(FALSE && "Should not be here!!");		
	}

	if (LbSetSelection(nStart, nEnd, ff, idx, nAnchor))
	{
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_FOCUS;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
	}

	return 0;
}

///////////////////////////  ComboBox Helper Functions  ////////////////////////////// 
/*
 * void CLstBxWinHost::OnCBTracking(WPARAM, LPARAM)
 *
 * @mfunc
 * 	This should be only called by the combo box.  This is a general message used
 *  to determine the state the listbox should be in
 *
 * @rdesc
 *	void
 */
void CLstBxWinHost::OnCBTracking(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnCBTracking");

	Assert(_pcbHost);
	Assert(_hwndParent);

	switch (wparam)
	{
	// lparam = Set focus to listbox
	case LBCBM_PREPARE:
		Assert(IsWindowVisible(_hwnd));
		_fMouseDown = FALSE;		
		if (lparam & LBCBM_PREPARE_SAVECURSOR)
			_nOldCursor = GetCursor();
		if (lparam & LBCBM_PREPARE_SETFOCUS)
		{
			_fFocus = 1;
			TxSetFocus();
		}
		InitWheelDelta();
		break;

	// lparam = mouse is down
	case LBCBM_START:
		Assert(IsWindowVisible(_hwnd));
		_fMouseDown = !!lparam;
		TxSetCapture(TRUE);
		_fCapture = 1;
		break;		

	// lparam = Keep capture
	case LBCBM_END:
		TxKillTimer(ID_LB_CAPTURE);
		_fFocus = 0;
		if (_fCapture)
		{			
			_fCapture = FALSE;
			TxSetCapture(FALSE);
		}
		break;
	default:
		AssertSz(FALSE, "ALERT: Custom message being used by someone else");
	}	

}


///////////////////////////////  ListBox Functions  ////////////////////////////////// 
/*
 * void CLstBxWinHost::LbDeleteItemNotify(int, int)
 *
 * @mfunc
 * Sends message to the parent an item has been deleted.  This function should be
 *	called whenever the LB_DELETESTRING message is recieved or if the listbox is
 *	being destroyed and the listbox is owner draw
 *
 * @rdesc
 *	void
 */
void CLstBxWinHost::LbDeleteItemNotify(
	int nStart,
	int nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDeleteItemNotify");
	
	// Initialize structure
	DELETEITEMSTRUCT ds;

	ds.CtlType = ODT_LISTBOX;
	ds.CtlID = _idCtrl;
	ds.hwndItem = _hwnd;
	
	for(int i = nStart; i <= nEnd; i++)
	{		
		// We do this just in case the user decides to change
		// the structure
		ds.itemData = GetData(i);
		ds.itemID = i;
		SendMessage(_hwndParent, WM_DELETEITEM, _idCtrl, (LPARAM)&ds);
	}
}


/*
 * void CLstBxWinHost::LbDrawItemNotify(HDC, int, UINT, UINT)
 *
 * @mfunc
 * This fills the draw item struct with some constant data for the given
 * item.  The caller will only have to modify a small part of this data
 * for specific needs.
 *
 * @rdesc
 *	void
 */
void CLstBxWinHost::LbDrawItemNotify(
	HDC hdc,
	int nIdx,
	UINT itemAction,
	UINT itemState)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDrawItemNotify");
	
	// Only send the message if the item is viewable and no freeze is on
	if (!IsItemViewable(nIdx) || !LbEnableDraw())
		return;
		
    //Fill the DRAWITEMSTRUCT with the unchanging constants
	DRAWITEMSTRUCT dis;
    dis.CtlType = ODT_LISTBOX;
    dis.CtlID = _idCtrl;

    // Use -1 if an invalid item number is being used.  This is so that the app
    // can detect if it should draw the caret (which indicates the lb has the
    // focus) in an empty listbox
    dis.itemID = (UINT)(nIdx < _nCount ? nIdx : -1);
    dis.itemAction = itemAction;
    dis.hwndItem = _hwnd;
    dis.hDC = hdc;
    dis.itemState = itemState |
            (UINT)(_fDisabled ? ODS_DISABLED : 0);

    // Set the app supplied data
    if (_nCount == 0) 
    {
        // If no items, just use 0 for data.  This is so that we
        // can display a caret when there are no items in the listbox.
        dis.itemData = 0L;
    } 
    else 
    {
    	Assert(nIdx < _nCount);
        dis.itemData = GetData(nIdx);
    }

	LbGetItemRect(nIdx, &(dis.rcItem));

    /*
     * Set the window origin to the horizontal scroll position.  This is so that
     * text can always be drawn at 0,0 and the view region will only start at
     * the horizontal scroll offset. We pass this as wparam
     */
    SendMessage(_hwndParent, WM_DRAWITEM, _idCtrl, (LPARAM)&dis);
}

/*
 *	LRESULT CLstBxWinHost::OnSetEditStyle(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Check if we need to do custom look for ListBox
 *
 *	@rdesc
 *		return value same as EM_GETEDITSTYLE
 */
LRESULT CLstBxWinHost::OnSetEditStyle(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::OnSetEditStyle");
	LRESULT	lres;
	BOOL	fCustomLookBefore = ((CTxtEdit *) _pserv)->_fCustomLook;
	BOOL	fCustomLook;
	HRESULT	hr;

	hr = _pserv->TxSendMessage(EM_SETEDITSTYLE, wparam, lparam, &lres);
	fCustomLook = ((CTxtEdit *) _pserv)->_fCustomLook;

	if (fCustomLook != fCustomLookBefore)
	{
		DWORD	dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
		DWORD	dwExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);

		if (fCustomLook)
		{
			dwStyle |= WS_BORDER;
			dwExStyle &= ~WS_EX_CLIENTEDGE;
		}
		else
		{
			dwStyle &= ~WS_BORDER;
			dwExStyle |= WS_EX_CLIENTEDGE;
		}

		SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
		SetWindowLong(_hwnd, GWL_EXSTYLE, dwExStyle);
		OnSunkenWindowPosChanging(_hwnd, NULL);
	}
	return lres;
}


/*
 *	LONG CLstBxWinHost::IsCustomLook()
 *
 *	@mfunc
 *		return custom look setting for ListBox
 *
 *	@rdesc
 *		return custom look setting for ListBox
 */
BOOL CLstBxWinHost::IsCustomLook()
{
	return	((CTxtEdit *) _pserv)->_fCustomLook;
}

/*
 *	BOOL CLstBxWinHost::LbSetItemHeight(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Sets the height of the items within the given range [0, _nCount -1]
 *
 *	@rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbSetItemHeight(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetItemHeight");

	int		nHeight = (int)lparam;
	BOOL	retCode = FALSE;

	// Set the height of the items if there are between [1,255] : bug fix #4783
	if (nHeight < 256 && nHeight > 0)
	{
		if (_fOwnerDrawVar)
		{
			if ((unsigned)GetCount() > wparam)
				retCode = SetVarItemHeight(wparam, nHeight);
		}
		else if (SetItemsHeight(nHeight, FALSE))
		{
			//bug fix #4214
			//need to recalculate how many items are viewable, IN ITS ENTIRETY, 
			//using the current window size
			RECT rc;
			TxGetClientRect(&rc);
			_nViewSize = max(rc.bottom / max(_nyItem, 1), 1);
			retCode = TRUE;
		}

		if (retCode)
		{
			_fSetScroll = 0;
			if (_fSetRedraw)
			{
				if (_dwStyle & WS_VSCROLL)
					SetScrollInfo(SB_VERT, TRUE);
			}
			else
				_fSetScroll = 1;
		}
	}
	return retCode;
}

/*
 *	BOOL CLstBxWinHost::LbGetItemRect(int, RECT*)
 *
 *	@mfunc
 *		Returns the rectangle coordinates of a requested index
 *		The coordinates will be in client coordinates
 *
 *	@rdesc
 *		BOOL = Successful ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbGetItemRect(
	int idx,
	RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbGetItemRect");

	Assert(prc);
	Assert(idx >= -1);

#ifdef _DEBUG
	if (_nCount > 0)
		Assert(idx < _nCount);
	else
		Assert(idx == _nCount);
#endif //_DEBUG

	if (idx == -1)
		idx = 0;

	TxGetClientRect(prc);

	prc->left = 0; 
	if (_fOwnerDrawVar)
	{
		LONG lTop = _rcViewport.top;

		if (idx > _nCount)
			idx = _nCount - 1;
		else if (idx < 0)
			idx = 0;

		if (idx >= GetTopIndex())
		{
			for (int i = GetTopIndex(); i < idx; i++)
				lTop += _rgData[i]._uHeight;
		}
		else
		{
			for (int i = idx; i < GetTopIndex(); i++)
				lTop -= _rgData[i]._uHeight;
		}
		prc->top = lTop;
		prc->bottom = lTop + _rgData[idx]._uHeight;
	}
	else
	{
		prc->top = (idx - GetTopIndex()) * _nyItem + _rcViewport.top;
		prc->bottom = prc->top + _nyItem;
	}

	return TRUE;
}

	
/*
 *	BOOL CLstBxWinHost::LbSetItemData(long, long, LPARAM)
 *
 *	@mfunc
 *		Given a range [nStart,nEnd] the data for these items
 *		will be set to nValue
 *	@rdesc
 *		void
 */
void CLstBxWinHost::LbSetItemData(
	long	nStart,
	long	nEnd,
	LPARAM	nValue)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetItemData");
	
	Assert(nStart >= 0 && nStart < _nCount);
	Assert(nEnd >= 0 && nEnd < _nCount);
	Assert(nStart <= nEnd);
	
	int nMin = min(nEnd + 1, _nCount);
	for (int i = nStart; i < nMin; i++)
		_rgData[i]._lparamData = nValue;
}

/*
 *	long CLstBxWinHost::LbDeleteString(long, long)
 *
 *	@mfunc
 *		Delete the string at the requested range.
 *	@rdesc
 *		long = # of items in the list box.  If failed -1
 */
long CLstBxWinHost::LbDeleteString(
	long nStart,
	long nEnd)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbDeleteString");

	if ((nStart > nEnd) || (nStart < 0) || (nEnd >= _nCount))
		return -1;

	if (!RemoveString(nStart, nEnd))
		return -1;

	// set the top index to fill the window
	LbSetTopIndex(max(nStart -1, 0));

#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_DESTROY;
		_fNotifyWinEvt = TRUE;
		TxNotify(_dwWinEvent, NULL);
#endif
		
	return _nCount;
}
 
/*
 *	CLstBxWinHost::LbInsertString(long, LPCTSTR)
 *
 *	@mfunc
 *		Insert the string at the requested index.  If long >= 0 then the
 *	string insertion is at the requested index. If long == -2 insertion
 *	is at the position which the string would be alphabetically in order.
 *	If long == -1 then string is added to the bottom of the list
 *
 *	@rdesc
 *		long = If inserted, the index (paragraph) which the string
 *			was inserted.  If not inserted returns -1;
 */
long CLstBxWinHost::LbInsertString(
	long nIdx,
	LPCTSTR szText)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbInsertString");

	Assert(nIdx >= -2);
	Assert(szText);
	
	if (nIdx == -2)
	{
		if (_nCount > 0)
			nIdx = GetSortedPosition(szText, 0, _nCount - 1);
		else
			nIdx = 0; //nothing inside listbox
	}
	else if (nIdx == -1)
		nIdx = GetCount();	// Insert string to the bottom of list if -1

	if (InsertString(nIdx, szText))
	{
		// If the index was previously selected unselect the newly 
		// added item
		for (int i = _nCount - 1; i > nIdx; i--)
		{
			_rgData[i]._fSelected = _rgData.Get(i - 1)._fSelected;

			// bug fix #4916
			_rgData[i]._lparamData = _rgData.Get(i - 1)._lparamData;

			_rgData[i]._uHeight = _rgData.Get(i - 1)._uHeight;
		}
		_rgData[nIdx]._fSelected = 0;
		_rgData[nIdx]._uHeight = 0;
		_rgData[nIdx]._lparamData = 0;		// Need to Initialize data back to zero

		if (!_fOwnerDraw)
		{
			// if we inserted at the middle or top then check 1 index down to see if the item
			// was selected, if we inserted at the bottom then check 1 index up to see if the item
			// was selected.  If the item was selected we need to change the colors to default
			// because we inherit the color properties from the range which we inserted into
			if (_nCount > 1)
			{
				if (((nIdx < _nCount - 1) && _rgData.Get(nIdx + 1)._fSelected) ||
					(nIdx == (_nCount - 1) && _rgData.Get(nIdx - 1)._fSelected))
					SetColors((unsigned)tomAutoColor, (unsigned)tomAutoColor, nIdx, nIdx);
			}
		}
		else
		{
			if (_fOwnerDrawVar)
			{
				// Get item height for OwnerDrawFix listbox
				MEASUREITEMSTRUCT	measureItem;

				measureItem.CtlType = ODT_LISTBOX;
				measureItem.CtlID = _idCtrl;
				measureItem.itemHeight = _nyFont;
				measureItem.itemWidth = 0;
				measureItem.itemData = (ULONG_PTR)szText;
				measureItem.itemID = nIdx;

				SendMessage(_hwndParent, WM_MEASUREITEM, _idCtrl, (LPARAM)&measureItem);

				LbSetItemHeight(nIdx, measureItem.itemHeight);
			}

			// Force redraw of items if owner draw and new item is viewable
			if (IsItemViewable(nIdx))
			{
				RECT rc;
				LbGetItemRect(nIdx, &rc);
				rc.bottom = _rcViewport.bottom;
				InvalidateRect(_hwnd, &rc, FALSE);
			}
		}
#ifndef NOACCESSIBILITY
		_dwWinEvent = EVENT_OBJECT_CREATE;
		_fNotifyWinEvt = TRUE;
		_nAccessibleIdx = nIdx + 1;
		TxNotify(_dwWinEvent, NULL);
#endif
		return nIdx;
	}
	else
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return -1;
	}
}
 
/*
 *	CLstBxWinHost::LbFindString(long, LPCTSTR, BOOL)
 *
 *	@mfunc
 *		Searches the story for a given string.  The
 *		starting position will be determined by the index nStart.
 *		This routine expects the units to be in tomParagraph.
 *		If bExact is TRUE then the paragraph must match the BSTR.
 *
 *	@rdesc
 *		long = If found, the index (paragraph) which the string
 *			was found in.  If not found returns -1;
 */
long CLstBxWinHost::LbFindString(
	long nStart,
	LPCTSTR szSearch,
	BOOL bExact)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbFindString");

	Assert(szSearch);
	Assert(nStart <= _nCount);

	int nSize = wcslen(szSearch);
	// If string is empty and not finding exact match then just return -1 like
	// the system control.  We don't have to worry about the exact match case
	// because it will work properly
	if (nStart >= _nCount || (nSize == 0 && !bExact))
		return -1;

	// allocate string buffer into stack
	WCHAR sz[1024];
	WCHAR *psz = sz;

	if ((nSize + 3) > 1024)
		psz = new WCHAR[nSize + 3 /* 2 paragraphs and a NULL*/];
	Assert(psz);

	if (psz == NULL)
	{
		TxNotify((unsigned long)LBN_ERRSPACE, NULL);
		return FALSE;
	}

	// format the string the way we need it
	wcscpy(psz, szCR);
	wcscat(psz, szSearch);
	if (bExact)
		wcscat(psz, szCR);		
	long lRet = -1;
	long l, cp;
	ITextRange *pRange = NULL;
	BSTR bstrQuery = SysAllocString(psz);
	if(!bstrQuery)
		goto CleanExit;
	if (psz != sz)
		delete [] psz;

	// Set starting position for the search
	if (!GetRange(nStart, _nCount - 1, &pRange))
	{
		SysFreeString(bstrQuery);
		return lRet;
	}

	CHECKNOERROR(pRange->GetStart(&cp));
	if (cp > 0)
	{
		// We need to use the paragraph marker from the previous
		// paragraph when searching for a string
		CHECKNOERROR(pRange->SetStart(--cp));	
	}
	else
	{
		// Special case:
		// Check if the first item matchs
		if (FindString(0, szSearch, bExact))
		{
			lRet = 0;
			goto CleanExit;
		}
	}

	if (NOERROR != pRange->FindTextStart(bstrQuery, 0, FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC, &l))
	{
		// Didn't find the string...
		if (nStart > 0)
		{
			if (!FindString(0, szSearch, bExact))
			{
				// Start the search from top of list to the point where
				// we last started the search			
				CHECKNOERROR(pRange->SetRange(0, ++cp));
				CHECKNOERROR(pRange->FindTextStart(bstrQuery, 0, 0, &l));
			}
			else
			{
				// First item was a match
				lRet = 0;
				goto CleanExit;
			}
		}
		else
			goto CleanExit;
	}

	// If we got down here then we have a match.
	// Get the index and convert to listbox index
	CHECKNOERROR(pRange->MoveStart(tomCharacter, 1, &l));
	CHECKNOERROR(pRange->GetIndex(tomParagraph, &lRet));
	lRet--;	// index is 1 based so we need to changed it to zero based

CleanExit:
	if (lRet != -1 && nSize == 1 && *szSearch == CR && _fOwnerDraw)
	{
		// Special case
		if (GetString(lRet, sz) != 1 || sz[0] != *szSearch)
			lRet = -1;
	}

	if (bstrQuery)
		SysFreeString(bstrQuery);
	if (pRange)
		pRange->Release();
	return lRet;
}
 
/*
 *	CLstBxWinHost::LbShowIndex(int, BOOL)
 *
 *	@mfunc
 *		Makes sure the requested index is within the viewable space.
 *		In cases where the item is not in the viewable space bTop is
 *		used to determine the requested item should be at the top
 *		of the list else list box will scrolled enough to display the
 *		item.
 *		NOTE:
 *			There can be situations where bTop will fail.  These 
 *		situations occurr of the top index requested prevents the list
 *		box from being completely filled with items.  For more info
 *		read the comments for LBSetTopIndex.
 *
 *	@rdesc
 *		BOOL = Successfully displays the item ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbShowIndex(
	long nIdx,
	BOOL bTop)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbShowIndex");

	// Make sure the requested item is within valid bounds
	if (!(nIdx >= 0 && nIdx < _nCount))
		return FALSE;

	if (_fOwnerDrawVar)
	{
		if (nIdx >= GetTopIndex())
		{
			BOOL fGreaterThanView;

			SumVarHeight(GetTopIndex(), nIdx+1, &fGreaterThanView);
			if (!fGreaterThanView)
				return TRUE;		// Already visible
		}
		if (!bTop)
			nIdx = PageVarHeight(nIdx, FALSE);
	}
	else
	{
		int delta = nIdx - GetTopIndex();

		// If item is already visible then just return TRUE
		if (0 <= delta && delta < _nViewSize)
			return TRUE;

		if ((delta) >= _nViewSize && !bTop && _nViewSize)
			nIdx = nIdx - _nViewSize + 1;
	}

	return (LbSetTopIndex(nIdx) < 0) ? FALSE : TRUE;
}

/*
 *	CLstBxWinHost::LbSetTopIndex(long)
 *
 *	@mfunc
 *		Tries to make the requested item the top index in the list box.
 *		If making the requested item the top index prevents the list box
 *		from using the viewable region to its fullest then and alternative
 *		top index will be used which will display the requested index
 *		but NOT as the top index.  This ensures conformancy with the system
 *		list box and makes full use of the dislayable region.
 *
 *	@rdesc
 *		long = returns the new top index if successful.  If failed returns -1
 */
long CLstBxWinHost::LbSetTopIndex(
	long nIdx)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetTopIndex");
		
	// Make sure the requested item is within valid bounds
	if (nIdx < 0 || nIdx >= _nCount)
 		return -1;
		
	// Always try to display a full list of items in the list box
	// This may mean we have to adjust the requested top index if
	// the requested top index will leave blanks at the end of the
	// viewable space
	if (_fOwnerDrawVar)
	{
		// Get top index for the last page
		int iLastPageTopIdx = PageVarHeight(_nCount, FALSE);
		if (iLastPageTopIdx < nIdx)
			nIdx = iLastPageTopIdx;
	}
	else if (_nCount - _nViewSize < nIdx)
		nIdx = max(0, _nCount - _nViewSize);

	// Just check to make sure we not already at the top 
	if (GetTopIndex() == nIdx)
		return nIdx;

	if (!SetTopViewableItem(nIdx))
		nIdx = -1;

	return nIdx;
}

/*
 *	CLstBxWinHost::LbBatchInsert(WCHAR* psz)
 *
 *	@mfunc
 *		Inserts the given list of items into listbox.  The listbox is reset prior to adding
 *	the items into the listbox
 *
 *	@rdesc
 *		int = # of items in the listbox if successful else LB_ERR
 */
int CLstBxWinHost::LbBatchInsert(
	WCHAR* psz)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbBatchInsert");

	// make sure we get some sort of string
	if (!psz)
		return LB_ERR;
		
	WCHAR* pszOut = psz;
	LRESULT nRet = LB_ERR;
	BSTR bstr = NULL;
	ITextRange* pRange = NULL;
	int nCount = 0;
	
	if (_fSort)
	{
		pszOut = new WCHAR[wcslen(psz) + 1];
		Assert(pszOut);

		if (!pszOut)
		{
			TxNotify((unsigned long)LBN_ERRSPACE, NULL);
			return LB_ERR;
		}

		nCount = SortInsertList(pszOut, psz);
		if (nCount == LB_ERR)
			goto CleanExit;
	}
	else
	{
		//bug fix #5130 we need to know how much we are going to insert
		//prior to inserting because we may be getting showscrollbar message
		//during insertion
		WCHAR* pszTemp = psz;
		while(*pszTemp)
		{
			if (*pszTemp == L'\r')
				nCount++;
			pszTemp++;
		}
		nCount++;
	}

	//clear listbox and insert new list into listbox
	LbDeleteString(0, GetCount() - 1);

	bstr = SysAllocString(pszOut);
	if(!bstr)
		goto CleanExit;
	
	// Insert string into list	
	CHECKNOERROR(((CTxtEdit*)_pserv)->Range(0, 0, &pRange));

	//bug fix #5130
	// preset our _nCount for scrollbar purposes
	_nCount = nCount;	
	CHECKNOERROR(pRange->SetText(bstr));

    nRet = nCount;

CleanExit:
	if (pszOut != psz)
		delete [] pszOut;

	if (bstr)
		SysFreeString(bstr);

	if (pRange)
		pRange->Release();
	return nRet;
}

/*
 *	CLstBxWinHost::LbSetSelection(long, long, int, long, long)
 *
 *	@mfunc
 *		Given the range of nStart to nEnd set the selection state of each item
 *		This function will also update the anchor and cursor position
 *		if requested.
 *
 *	@rdesc
 *		BOOL = If everything went fine ? TRUE : FALSE
 */
BOOL CLstBxWinHost::LbSetSelection(
	long nStart,
	long nEnd,
	int ffFlags,
	long nCursor,
	long nAnchor)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbSetSelection");

	if (!_fOwnerDraw)
	{
		Freeze();
	
		// de-select all items
		if ((ffFlags & LBSEL_RESET))
		{
			if (!ResetContent())
			{
				Unfreeze();
				return FALSE;
			}

			// Reset, check if anything else needs to be done
			// else just exit out
			if (ffFlags == LBSEL_RESET)
			{
				Unfreeze();
				return TRUE;
			}
		}
	}
	
	// NOTE:
	//	This should be one big critical section because we rely on certain
	// member variables not changing during the process of this function

	// Check if we are changing the selection and if we have focus
	// if we do then we first need to xor out the focus rect from
	// old cursor
	RECT rc;
	HDC hdc;
	hdc = TxGetDC();
	Assert(hdc);
	// don't draw outside the client rect draw the rectangle
	TxGetClientRect(&rc);
	IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

	if ((ffFlags & LBSEL_NEWCURSOR) && _fFocus && LbEnableDraw())
	{
 		// If owner draw notify parentwindow
 		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, max(_nCursor, 0), ODA_FOCUS, IsSelected(_nCursor) ? ODS_SELECTED : 0);				
 		else
 		{
 			LbGetItemRect(_nCursor, &rc);
 			::DrawFocusRect(hdc, &rc);
 		}
	}
		
	//	check if all item should be selected
	if (nStart == -1 && nEnd == 0)
	{
		nStart = 0;
		nEnd = _nCount - 1;
	}
	else if (nStart > nEnd)	
	{
		// reshuffle so nStart is <= nEnd;
		long temp = nEnd;
		nEnd = nStart;
		nStart = temp;
	}

	// Check for invalid values
	if (nStart < -1 || nEnd >= _nCount)
	{
		if (!_fOwnerDraw)
			Unfreeze();

		// mimic system listbox behaviour
		if (nEnd >= _nCount)
			return FALSE;
		else
			return TRUE;
	}

	// Prepare the state we want to be in
	unsigned int bState;	
	DWORD dwFore;
	DWORD dwBack;
	if (ffFlags & LBSEL_SELECT)
	{
		bState = ODS_SELECTED;	//NOTE ODS_SELECTED must equal 1
		dwFore = _crSelFore;
		dwBack = _crSelBack;

		if (_fSingleSel)
			nEnd = nStart;
	}
	else 
	{
		bState = 0;
		dwFore = (unsigned)tomAutoColor;
		dwBack = (unsigned)tomAutoColor;
	}

	// A little optimization check
	// Checks to see if the state is really being changed if not then don't bother
	// calling SetColor, works only when nStart == nEnd;
	// The list box will not change the background color if nSame is true
	int nSame = (nStart == nEnd && nStart != -1) ? (_rgData.Get(nStart)._fSelected == bState) : FALSE;

	BOOL bRet = TRUE;
	if (_fOwnerDraw)
	{
		if (ffFlags & LBSEL_RESET || !bState)
		{
			// There are cases where we don't necessarily reset all the items
			// in the list but rather the range which was given.  The following
			// takes care of this case
			int ff = ffFlags & LBSEL_RESET;
			int i = (ff) ? 0 : nStart;
			int nStop = (ff) ? _nCount : nEnd + 1;
		 	for (; i < nStop; i++)
		 	{
		 		// Don't unselect an item which is going to be
		 		// selected in the next for loop
		 		if (!bState || (i < nStart || i > nEnd) &&
		 			(_rgData.Get(i)._fSelected != 0))
		 		{
		 			// Only send a unselect message if the item
		 			// is viewable
		 			_rgData[i]._fSelected = 0;
			 		if (IsItemViewable(i))
			 			LbDrawItemNotify(hdc, i, ODA_SELECT, 0);			 		
			 	}
		 	}
		}

		if (bState)
		{
			// We need to loop through and notify the parent
			// The item has been deselected or selected
			for (int i = max(0, nStart); i <= nEnd; i++)
			{		
				if (_rgData.Get(i)._fSelected != 1)
				{
					_rgData[i]._fSelected = 1;
					if (IsItemViewable(i))
						LbDrawItemNotify(hdc, i, ODA_SELECT, ODS_SELECTED);					
				}
			}
		}
		
	}
	else if (!nSame)
	{
		// Update our internal records	
		for (int i = max(0, nStart); i <= nEnd; i++)
			_rgData[i]._fSelected = bState;	
		bRet = SetColors(dwFore, dwBack, nStart, nEnd);
	}

    // Update the cursor and anchor positions
	if (ffFlags & LBSEL_NEWANCHOR)
		_nAnchor = nAnchor;

	// Update the cursor position
	if (ffFlags & LBSEL_NEWCURSOR)
		_nCursor = nCursor;

	// Draw the focus rect
	if (_fFocus && LbEnableDraw())
	{
		if (_fOwnerDraw)
 			LbDrawItemNotify(hdc, _nCursor, ODA_FOCUS, ODS_FOCUS | 
 				(IsSelected(_nCursor) ? ODS_SELECTED : 0));	
 		else
 		{
			LbGetItemRect(_nCursor, &rc);
	 		::DrawFocusRect(hdc, &rc);
	 	} 		
	}

	TxReleaseDC(hdc);
		
	// This will automatically update the window
	if (!_fOwnerDraw)
	{
		Unfreeze();
		// We need to do this because we are making so many changes
		// ITextServices might get confused
		ScrollToView(GetTopIndex());		
	}
	
	return bRet;
}

/*
 *	BOOL CLstBxWinHost::IsItemViewable(int)
 *
 *	@mfunc
 *		Helper to check if the idx is in current view
 *
 *	@rdesc
 *		TRUE if it is viewable
 */
BOOL CLstBxWinHost::IsItemViewable(
	long idx)
{
	if (idx < GetTopIndex())
		return FALSE;

	if (!_fOwnerDrawVar)
		return ((idx - GetTopIndex()) * _nyItem < _rcViewport.bottom);

	BOOL fGreateThanView;

	SumVarHeight(GetTopIndex(), idx, &fGreateThanView);

	return !fGreateThanView;
}

/*
 *	CLstBxWinHost::SumVarHeight(int, int, BOOL*)
 *
 *	@mfunc
 *		Helper to sum the height from iStart to iEnd for a variable item
 *		height listbox.  If pfGreaterThanView is not NULL, then set it to TRUE
 *		once the total height is bigger than current view size.
 *
 *	@rdesc
 *		int = hights from iStart to iEnd
 */
int CLstBxWinHost::SumVarHeight(
	int		iStart,
	int		iEnd,
	BOOL	*pfGreaterThanView)
{
	RECT	rc = {0};
	int		uHeightSum = 0;

	Assert(_fOwnerDrawVar);

	if (pfGreaterThanView)
	{
		*pfGreaterThanView = FALSE;
		TxGetClientRect(&rc);
	}

	if (GetCount() <= 0)
		return 0;

	if (iStart < 0)
		iStart = 0;

	if (iEnd >= GetCount())
		iEnd = GetCount();

	Assert(iEnd >= iStart);

	for (int nIdx = iStart; nIdx < iEnd; nIdx++)
	{
		uHeightSum += _rgData[nIdx]._uHeight;
		if (pfGreaterThanView && uHeightSum > rc.bottom)
		{
			*pfGreaterThanView = TRUE;
			break;
		}
	}

	return uHeightSum;
}

/*
 * int CLstBxWinHost::PageVarHeight(int, BOOL)
 *
 *	@mfunc
 *		For variable height ownerdraw listboxes, calaculates the new iTop we must
 *		move to when paging (page up/down) through variable height listboxes.
 *
 *	@rdesc
 *		int = new iTop
 */
int CLstBxWinHost::PageVarHeight(
	int	startItem,
	BOOL fPageForwardDirection)
{
	int     i;
	int iHeight;
	RECT    rc;

	Assert(_fOwnerDrawVar);

	if (GetCount() <= 1)
		return 0;

	TxGetClientRect(&rc);
	iHeight = rc.bottom;
	i = startItem;

	if (fPageForwardDirection)
	{
		while ((iHeight >= 0) && (i < GetCount()))
			iHeight -= _rgData[i++]._uHeight;

		return ((iHeight >= 0) ? GetCount() - 1 : max(i - 2, startItem + 1));
	} 
	else 
	{
		while ((iHeight >= 0) && (i >= 0))
			iHeight -= _rgData[i--]._uHeight;

		return ((iHeight >= 0) ? 0 : min(i + 2, startItem - 1));
	}
}

/*
 * BOOL CLstBxWinHost::SetVarItemHeight(int, int)
 *
 *	@mfunc
 *		For variable height ownerdraw listboxes, setup the para height.
 *
 *	@rdesc
 *		TRUE if setup new height
 */
BOOL CLstBxWinHost::SetVarItemHeight(
	int	idx,
	int iHeight)
{
	BOOL retCode = FALSE;
	ITextPara *pPara = NULL;
	ITextRange *pRange = NULL;

	Assert(_fOwnerDrawVar);

	// Calculate the new size in points
	long lptNew = MulDiv(iHeight, 1440, W32->GetYPerInchScreenDC());

	if (GetRange(idx, idx, &pRange))
	{
		CHECKNOERROR(pRange->GetPara(&pPara));
		CHECKNOERROR(pPara->SetLineSpacing(tomLineSpaceExactly, (float)lptNew));

		_rgData[idx]._uHeight = iHeight;
		retCode = TRUE;
	}

CleanExit:
	if (pPara)
		pPara->Release();

	if (pRange)
		pRange->Release();

	return retCode;
}

/*
 * int CLstBxWinHost::GetIdxFromHeight(int)
 *
 *	@mfunc
 *		Find the idx for the given iHeight from idx 0.
 *
 *	@rdesc
 *		idx
 */
int CLstBxWinHost::GetIdxFromHeight(
	int iHeight)
{
	int	idx;
	int	iHeightSum = 0;

	Assert(_fOwnerDrawVar);

	for(idx=0; idx < _nCount; idx++)
	{
		if (iHeight < iHeightSum + (int)_rgData[idx]._uHeight)
		{
			if (iHeight != iHeightSum)
				idx++;		// partial item, get the next idx
			break;
		}
		iHeightSum += _rgData[idx]._uHeight;
	}

	idx = min(idx, _nCount-1);

	return idx;
}

/*
 *	LRESULT CLstBxWinHost::LbGetCurSel()
 *
 *	@mfunc
 *		For Single-selection LB, returns the idnex of current selected item.
 *		For multiple-selection LB, returns the index of the item that has the
 *		focus rect.
 *
 *	@rdesc
 *		current select idx
 */
LRESULT CLstBxWinHost::LbGetCurSel()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CLstBxWinHost::LbGetCurSel");

	LRESULT lres;

	if (!IsSingleSelection() ||		// multiple-selection LB or
		IsSelected(_nCursor))		//	_nCursor is selected
		lres = _nCursor;
	else
	{
		lres = LB_ERR;
		// Check which item is selected in single-selection LB
		for (int idx=0; idx < _nCount; idx++)
		{
			if (_rgData[idx]._fSelected)
			{
				lres = idx;
				break;
			}
		}
	}
	return lres;
}

//
//	ITxNotify
//

/*
 *	CLstBxWinHost::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax, pNotifyData)
 *
 *	@mfunc	called after a change has been made to the backing store.
 */
void CLstBxWinHost::OnPostReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	_cpLastGetRange = 0;
	_nIdxLastGetRange = 0;
}

#endif // NOLISTCOMBOBOXES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\line.cpp ===
/*
 *	LINE.CPP
 *	
 *	Purpose:
 *		CLine class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_line.h"
#include "_measure.h"
#include "_render.h"
#include "_disp.h"
#include "_dispml.h"
#include "_edit.h"

ASSERTDATA

extern BOOL g_OLSBusy;

/*
 *	CLine::Measure(&me, uiFlags, pliTarget)
 *
 *	@mfunc
 *		Computes line break (based on target device) and fills
 *		in this CLine with resulting metrics on rendering device
 *
 *	@rdesc 
 *		TRUE if OK
 *
 *	@devnote
 *		me is moved past line (to beginning of next line).  Note: CLock is
 *		needed in the main four routines (Measure, MeasureText, CchFromUp,
 *		and RenderLine), since they use the global (shared) fc().GetCcs()
 *		facility and may use the LineServices global g_plsc and g_pols.
 */
BOOL CLine::Measure(
	CMeasurer& me,			//@parm Measurer pointing at text to measure
	UINT	   uiFlags,		//@parm Flags
	CLine *	   pliTarget)	//@parm Returns target-device line metrics (optional)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLine::Measure");

	CLock	lock;
	BOOL	fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
	BOOL	fMultiLine = me.GetPdp()->IsMultiLine();
	BOOL	fRet;

	if(fMultiLine && fFirstInPara && me.GetPrevChar() == VT)
	{
		fFirstInPara = FALSE;
		uiFlags &= ~MEASURE_FIRSTINPARA;
	}

	me.NewLine(fFirstInPara);

	if(fFirstInPara)
		me._li._fFirstInPara = TRUE;

	BYTE bNumber = me._wNumber < 256	// Store current para # offset
				 ? me._wNumber : 255;
	me._li._bNumber = bNumber;
	me._fMeasure = TRUE;

	//REVIEW (keithcu) uiFlags aren't needed in LS model? Can I remove
	//from the other model, too?
#ifndef NOLINESERVICES
	COls *	   pols = me.GetPols();			// Try for LineServices object
	if(pols)
	{						// Got it: use LineServices
		fRet = pols->MeasureLine(pliTarget);
		g_OLSBusy = FALSE;
	}
	else									// LineServices not active
#endif
		fRet = me.MeasureLine(uiFlags, pliTarget);

	if(!fRet)
		return FALSE;

	*this = me._li;							// Copy over line info

	if(!fMultiLine)							// Single-line controls can't
		return TRUE;						//  have paragraph numbering

	if(IsHeadingStyle(me._pPF->_sStyle))	// Store heading number if relevant
		_nHeading = (BYTE)(-me._pPF->_sStyle - 1);

	if(me.IsInOutlineView() && me._pPF->_wEffects & PFE_COLLAPSED)	// Cache collapsed bit
		_fCollapsed = TRUE;

	_bNumber = bNumber;
	
	if(_fHasEOP)							// Check for new para number
	{
		const CParaFormat *pPF = me.GetPF();

		me._wNumber	  = (WORD)pPF->UpdateNumber(me._wNumber, me._pPF);
	}
	if(me.GetPrevChar() == FF)
		_fHasFF = TRUE;

	return TRUE;
}
	
/*
 *	CLine::Render(&re, fLastLine)
 *
 *	@mfunc
 *		Render visible part of this line
 *
 *	@rdesc
 *		TRUE iff successful
 *
 *	@devnote
 *		re is moved past line (to beginning of next line).
 *		FUTURE: the RenderLine functions return success/failure.
 *		Could do something on failure, e.g., be specific and fire
 *		appropriate notifications like out of memory.
 */
BOOL CLine::Render(
	CRenderer& re,			//@parm Renderer to use
	BOOL fLastLine)			//@parm TRUE iff last line in layout
{
	if(_fCollapsed)						// Line is collapsed in Outline view
	{
		re.Move(_cch);					// Bypass line
		return TRUE;
	}

	BOOL	fRet;
	CLock	lock;
	POINTUV	pt = re.GetCurPoint();

#ifndef NOLINESERVICES
	COls *pols = re.GetPols();			// Try for LineServices object
	if(pols)
	{
		fRet = pols->RenderLine(*this, fLastLine);
		g_OLSBusy = FALSE;
	}
	else
#endif
		fRet = re.RenderLine(*this, fLastLine);

	pt.v += GetHeight();				// Advance to next line	position
	re.SetCurPoint(pt);
	return fRet;
}

/*
 *	CLine::CchFromUp(&me, pt, pdispdim, pHit, pcpActual)
 *
 *	@mfunc
 *		Computes cch corresponding to x position in a line.
 *		Used for hit testing.
 *
 *	@rdesc 
 *		cch found up to the x coordinate x	
 *
 *	@devnote
 *		me is moved to the cp at the cch offset returned
 */
LONG CLine::CchFromUp(
	CMeasurer& me,		//@parm Measurer position at start of line
	POINTUV	 pt,		//@parm pt.u is u coord to search for
	CDispDim*pdispdim,	//@parm Returns display dimensions
	HITTEST *phit,		//@parm Returns hit type at x	
	LONG	*pcpActual) const //@parm actual CP mouse is above
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLine::CchFromUp");
	
	CLock		lock;
	const BOOL	fFirst = _fFirstInPara;
	*phit =		HT_Text;
	LONG		cpActual = me.GetCp();
	CDispDim	dispdim;
	
	me._li = *this;
	*phit = me.HitTest(pt.u);
	me._li._cch = 0;					// Default zero count

	if(*phit == HT_Text || *phit == HT_RightOfText) // To right of left margin
	{
		me.NewLine(*this);

#ifndef NOLINESERVICES
		COls *pols = me.GetPols();		// Try for LineServices object
		if(pols)						// Got it: use LineServices
		{
			pols->CchFromUp(pt, &dispdim, &cpActual);
			g_OLSBusy = FALSE;
		}
		else
#endif
			if(me.Measure(me.DUtoLU(pt.u - _upStart), _cch,
						  MEASURE_BREAKBEFOREWIDTH | MEASURE_IGNOREOFFSET 
						  | (fFirst ? MEASURE_FIRSTINPARA : 0)) >= 0)
			{
				LONG dupBefore = me._li._dup;
				cpActual = me.GetCp();
				if (me._li._cch < _cch)
				{
					LONG dup = pt.u - _upStart - dupBefore;
					dispdim.dup = me._dupAddLast;
					if(dup > dispdim.dup / 2 ||
					   dup > W32->GetDupSystemFont()/2 && me.GetChar() == WCH_EMBEDDING)
					{
						me.Move(1);
						me._li._cch++;
						me._li._dup += dispdim.dup;
					}
				}
			}

		me._rpCF.AdjustForward();
		if(cpActual < me.GetCp() || pt.u >= _upStart + _dup)
			me._rpCF.AdjustBackward();
		DWORD dwEffects = me.GetCF()->_dwEffects;
		if(dwEffects & CFE_LINK)
		{
			if(cpActual < me.GetTextLength())
				*phit = HT_Link;
		}
		else if(dwEffects & CFE_ITALIC)
			*phit = HT_Italic;
	}

	if (pdispdim)
		*pdispdim = dispdim;
	if (pcpActual)
		*pcpActual = cpActual;

	return me._li._cch;
}

/*
 *	CLine::UpFromCch(&me, cch, taMode, pdispdim, pdy)
 *
 *	@mfunc
 *		Measures cch characters starting from this text ptr, returning
 *		the width measured and setting yOffset = y offset relative to
 *		top of line and dx = halfwidth of character at me.GetCp() + cch.
 *		Used for caret placement and object location. pdx returns offset
 *		into the last char measured (at me.GetCp + cch) if taMode includes
 *		TA_CENTER (dx = half the last char width) or TA_RIGHT (dx = whole
 *		char width). pdy returns the vertical offset relative to the top
 *		of the line if taMode includes TA_BASELINE or TA_BOTTOM.
 *
 *	@rdesc 
 *		width of measured text
 *
 *	@devnote
 *		me may be moved.  
 */
LONG CLine::UpFromCch(
	CMeasurer&	me,			//@parm Measurer pointing at text to measure
	LONG		cch,		//@parm Max cch to measure
	UINT		taMode,		//@parm Text-align mode
	CDispDim *	pdispdim,	//@parm display dimensions
	LONG *		pdy) const	//@parm dy offset due to taMode
{
	CLock	lock;
	LONG	dup;
	BOOL	fPols = FALSE;
	CDispDim dispdim;
	LONG	dy = 0;

#ifndef NOLINESERVICES
	COls *pols = me.GetPols();			// Try for LineServices object
	if(pols)
	{									// Got it: use LineServices
		if(cch)							
			taMode &= ~TA_STARTOFLINE;	// Not start of line
		if(cch != _cch)
			taMode &= ~TA_ENDOFLINE;	// Not end of line

		dup = pols->MeasureText(cch, taMode, &dispdim);
		fPols = TRUE;
		g_OLSBusy = FALSE;
	}
	else
#endif
	{
		dup = me.MeasureText(cch) + _upStart;
		dispdim.dup = me._dupAddLast;
	}

	if(taMode != TA_TOP)
	{
		// Check for vertical calculation request
		if(taMode & TA_BASELINE)			// Matches TA_BOTTOM and
		{									//  TA_BASELINE
			if(!_fCollapsed)
			{
				dy = _dvpHeight;
				AssertSz(_dvpHeight != -1, "control has no height; used to use default CHARFORMAT");
				if((taMode & TA_BASELINE) == TA_BASELINE)
				{
					dy -= _dvpDescent;		// Need "== TA_BASELINE" to
					if(!_dvpDescent)		//  distinguish from TA_BOTTOM
						dy--;				// Compensate for weird fonts
				}
			}
		}
	}

	LONG dupAdd = 0;

	if((taMode & TA_CENTER) == TA_CENTER)
		dupAdd = dispdim.dup / 2;
	else if (taMode & TA_RIGHT)
		dupAdd = dispdim.dup;

	if (dispdim.lstflow == lstflowWS && (taMode & TA_LOGICAL))
		dupAdd = -dupAdd;

	dup += dupAdd;

	if (pdispdim)
		*pdispdim = dispdim;
	if (pdy)
		*pdy = dy;

	return max(dup, 0);
}
	
/*
 *	CLine::GetHeight()
 *
 *	@mfunc
 *		Get line height unless in outline mode and collasped, in
 *		which case get 0.
 *
 *	@rdesc
 *		Line height (_yHeight), unless in outline mode and collapsed,
 *		in which case 0.
 */
LONG CLine::GetHeight() const
{
	if (_fCollapsed)
		return 0;

	return IsNestedLayout() ? _plo->_dvp : _dvpHeight;
}

/*
 *	CLine::GetDescent()
 *
 *	@mfunc
 *		Return descent of line. Assumed not to be collapsed
 *
 *	@rdesc
 */
LONG CLine::GetDescent() const
{
	return IsNestedLayout() ? 0 : _dvpDescent;
}

BOOL CLine::IsEqual(CLine& li)
{
	return	_upStart == li._upStart &&
			_plo   == li._plo && //checks _yHeight, _yDescent OR _plo
			_dup == li._dup && 
			_cch == li._cch;
}


// =====================  CLinePtr: Line Run Pointer  ==========================


CLinePtr::CLinePtr(CDisplay *pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::CLinePtr");

	_pdp = pdp;
	_pLine = NULL;
	_pdp->InitLinePtr(* this);
}

void CLinePtr::Init (CLine & line)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::Init");

	_pRuns = 0;
	_pLine = &line;
	_iRun = 0;
	_ich = 0;
}

void CLinePtr::Init (CLineArray & line_arr)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::Init");

	_pRuns = (CRunArray *) & line_arr;
	_iRun = 0;
	_ich = 0;
}

void CLinePtr::Set(
	LONG iRun,
	LONG ich,
	CLineArray *pla)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpSet");

	// See if this is a multi-line ptr
    if(_pRuns)
	{
		if(pla)
		{
			CRunPtr<CLine>::SetRun(0, 0);	// Be sure current state is valid
			_pRuns = (CRunArray *)pla;		//  for new _pRuns
		}
        CRunPtr<CLine>::SetRun(iRun, ich);	// Now set to desired run & ich
	}
    else
    {
        // single line, just reinit and set _ich
        AssertSz(iRun == 0, "CLinePtr::Set() - single line and iRun != 0");
	    _pdp->InitLinePtr(* this);		//  to line 0
	    _ich = ich;
    }
}

// Move runptr by a certain number of cch/runs

BOOL CLinePtr::Move(
	LONG cch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpMove");

	// See if this is a multi-line ptr

	if(_pRuns)
		return (cch == CRunPtr<CLine>::Move(cch));

	return MoveSL(cch);
}
	
BOOL CLinePtr::operator --(int)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator --");

	return _pRuns ? PrevRun() : OperatorPostDeltaSL(-1);
}

BOOL CLinePtr::operator ++(int)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator ++");

	return _pRuns ? NextRun() : OperatorPostDeltaSL(+1);
}

/*
 *	CLinePtr::MoveSL(cch)
 *
 *	@mfunc
 *		move this line pointer forward or backward on the line
 *
 *	@rdesc
 *		TRUE iff could Move cch chars within current line
 */
BOOL CLinePtr::MoveSL(
	LONG cch)	 //@parm signed count of chars to Move by
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpMoveSL");

	Assert(!_pRuns);
	
	if(!_pLine)
		return FALSE;

	_ich += cch;

	if(_ich < 0)
	{
		_ich = 0;
		return FALSE;
	}

	if(_ich > _pLine->_cch)
	{
		_ich = _pLine->_cch;
		return FALSE;
	}

	return TRUE;
}

/*
 *	CLinePtr::OperatorPostDeltaSL(Delta)
 *
 *	@mfunc
 *		Implement line-ptr ++ and -- operators for single-line case
 *
 *	@rdesc
 *		TRUE iff this line ptr is valid
 */
BOOL CLinePtr::OperatorPostDeltaSL(
	LONG Delta)			//@parm 1 for ++ and -1 for --
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::OperatorPostDeltaSL");

	AssertSz(_iRun <= 1 && !_pRuns,
		"LP::++: inconsistent line ptr");

	if(_iRun == -Delta)						// Operation validates an
	{										//  invalid line ptr by moving
		_pdp->InitLinePtr(* this);			//  to line 0
		return TRUE;
	}
	
	_iRun = Delta;							// Operation invalidates this line
	_ich = 0;								//  ptr (if it wasn't already)

	return FALSE;
}

CLine *	CLinePtr::operator ->() const		
{
	return _pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine;
}

CLine * CLinePtr::GetLine() const
{	
    return _pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine;
}

CLine &	CLinePtr::operator *() const      
{	
    return *(_pRuns ? (CLine *)_pRuns->Elem(_iRun) : _pLine);
}

CLine & CLinePtr::operator [](LONG dRun)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::operator []");

	if(_pRuns)
		return *(CLine *)CRunPtr<CLine>::GetRun(dRun);

	AssertSz(dRun + _iRun == 0 ,
		"LP::[]: inconsistent line ptr");

	return  *(CLine *)CRunPtr<CLine>::GetRun(_iRun);
}

BOOL CLinePtr::IsValid() const
{ 
	return !_pRuns ? _pLine != NULL : CRunPtrBase::IsValid(); 
}

/*
 *	CLinePtr::SetCp(cp, fAtEnd, lNest)
 *
 *	@mfunc	
 *		Set this line ptr to cp allowing for ambigous cp and taking advantage
 *		of _cpFirstVisible and _iliFirstVisible
 *
 *	@rdesc
 *		TRUE iff able to set to cp
 */
BOOL CLinePtr::SetCp(
	LONG cp,			//@parm Position to set this line ptr to
	BOOL fAtEnd,		//@parm If ambiguous cp: if fAtEnd = TRUE, set this
						// line ptr to end of prev line; else to line start
	LONG lNest)			//@parm Set to deep CLine in nested layouts
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::RpSetCp");

	_ich = 0;
	if(!_pRuns)
	{
		// This is a single line so just go straight to the single
		// line Move logic. It is important to note that the
		// first visible character is irrelevent to the cp Move
		// for single line displays.
		return MoveSL(cp);
	}

	BOOL fRet;
	LONG cpFirstVisible = _pdp->GetFirstVisibleCp();

	if(cp > cpFirstVisible / 2)
	{											// cpFirstVisible closer than 0
		_iRun = _pdp->GetFirstVisibleLine();
		fRet = Move(cp - cpFirstVisible);
	}
	else
		fRet = (cp == CRunPtr<CLine>::BindToCp(cp));// Start from 0

	if(lNest)
	{
		CLayout *plo;
		while(plo = GetLine()->GetPlo())
		{
			LONG cch = _ich;
			if(plo->IsTableRow())
			{
				if(cch <= 2 && lNest == 1)		// At start of table row:
					break;						//  leave this rp there
				cch -= 2;						// Bypass table row start code
			}
			Set(0, 0, (CLineArray *)plo);		// Goto start of layout plo
			Move(cch);							// Move to parent _ich
		}
	}

	if(fAtEnd)									// Ambiguous-cp caret position
		AdjustBackward();						//  belongs at prev EOL

	return fRet;
}

/*
 *	CLinePtr::FindParagraph(fForward)
 *
 *	@mfunc	
 *		Move this line ptr to paragraph (fForward) ? end : start,
 *		and return change in cp
 *
 *	@rdesc
 *		change in cp
 */
LONG CLinePtr::FindParagraph(
	BOOL fForward)		//@parm TRUE move to para end; else to para start
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLinePtr::FindParagraph");

	LONG	cch;
	CLine *	pli = GetLine();

	if(!fForward)							// Go to para start
	{
		cch = 0;							// Default already at para start
		if (_ich != pli->_cch ||
			!(pli->_fHasEOP))				// It isn't at para start
		{
			cch = -_ich;					// Go to start of current line
			while(!(pli->_fFirstInPara) && _iRun > 0)
			{
				pli--;
				_iRun--;
				cch -= pli->_cch;			// Subtract # chars in line
			}
			_ich = 0;						// Leave *this at para start
		}
	}
	else									// Go to para end
	{
		cch = GetCchLeft();					// Go to end of current line
		if(!_pRuns)
			return cch;						// Single line

		LONG cLine	 = _pRuns->Count();
		BOOL fNested = _pRuns->Elem(0) != ((CDisplayML *)_pdp)->Elem(0);

		while((_iRun < cLine - 1 || !fNested &&
				_pdp->WaitForRecalcIli(_iRun + 1))
			  && !(pli->_fHasEOP))
		{
			pli++;							// Go to start of next line
			_iRun++;
			cch += pli->_cch;				// Add # chars in line
		}
		_ich = pli->_cch;					// Leave *this at para end
	}
	return cch;
}

/*
 *	CLinePtr::GetAdjustedLineLength()
 *
 *	@mfunc	returns length of line _without_ EOP markers
 *
 *	@rdesc	LONG; length of line
 */
LONG CLinePtr::GetAdjustedLineLength()
{
	CLine * pline = GetLine();

	return pline->_cch - pline->_cchEOP;
}

/*
 *	CLinePtr::GetCchLeft()
 *
 *	@mfunc
 *		Calculate length of text left in run starting at the current cp.
 *		Complements GetIch(), which	is length of text up to this cp. 
 *
 *	@rdesc
 *		length of text so calculated
 */
LONG CLinePtr::GetCchLeft() const
{
	return _pRuns ? CRunPtrBase::GetCchLeft() : _pLine->_cch - _ich;
}

/*
 *	CLinePtr::GetNumber()
 *
 *	@mfunc
 *		Get paragraph number 
 *
 *	@rdesc
 *		paragraph number
 */
WORD CLinePtr::GetNumber()
{
	if(!IsValid())
		return 0;

	_pLine = GetLine();
	if(!_iRun && _pLine->_bNumber > 1)
		_pLine->_bNumber = 1;

	return _pLine->_bNumber;
}

/*
 *	CLinePtr::CountPages(&cPage, cchMax, cp, cchText)
 *
 *	@mfunc
 *		Count characters up to <p cPages> pages away or <p cchMax> chars,
 *		whichever comes first. If the target page and <p cchMax> are both
 *		beyond the corresponding end of the document, count up thru the
 *		closest page.  The direction of counting is	determined by the sign
 *		of <p cPage>.  To count without being limited by <p cchMax>, set it
 *		equal to tomForward. An initial partial	page counts as a page.
 *
 *	@rdesc
 *		Return the signed cch counted and set <p cPage> equal to count of
 *		pages actually counted.  If no pages are allocated, the text is
 *		treated as a single page.  If <p cPage> = 0, -cch to the start of the
 *		current page is returned. If <p cPage> <gt> 0 and cp is at the end
 *		of the document, 0 is returned.
 *
 *	@devnote
 *		The maximum count capability is included to be able to count units in
 *		a range.
 *
 *	@todo
 *		EN_PAGECHANGE
 */
LONG CLinePtr::CountPages (
	LONG &cPage,		//@parm Count of pages to get cch for
	LONG  cchMax,		//@parm Maximum char count
	LONG  cp,			//@parm CRchTxtPtr::GetCp()
	LONG  cchText) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CLinePtr::CountPages");

	if(!_pdp->IsInPageView())
	{
		cPage = 0;
		return tomBackward;					// Signal error
	}
	Assert(IsValid());

	LONG	cch;
	LONG	j = cPage;
	CLine *pli = (CLine *)GetLine();		// Not NULL since lines exist

	if(cPage < 0)							// Try to count backward cPage pages
	{
		// TODO: eliminate cchText and cp (currently only used for validation)
		Assert(cchMax <= cp);				// Don't undershoot
		for(cch = _ich; j && cch <= cchMax; cch += pli->_cch)
		{
			if(pli->_fFirstOnPage && cch)	// !cch prevents counting current
				j++;						//  page if at start of that page
			if(cch >= cchMax)					
			{
				Assert(cch == cp);
				break;						// At beginning of doc, so done
			}

			if (!j)
				break;						// Done counting backward

			pli--;
			VALIDATE_PTR(pli);
		}
		cPage -= j;							// Discount any pages not counted
		return -cch;
	}

	Assert(cPage > 0 && cchMax <= cchText - cp);

	for(cch	= GetCchLeft(); cch < cchMax; cch += pli->_cch)
	{
		pli++;
		VALIDATE_PTR(pli);
		if(pli->_fFirstOnPage && cch)		// !cch prevents counting current
		{									//  page if at start of that page
			j--;
			if(!j)
				break;
		}
	}
	cPage -= j;								// Discount any pages not counted
	return cch;
}

/*
 *	CLinePtr::FindPage (pcpMin, pcpMost, cpMin, cch, cchText)
 *
 *	@mfunc
 *		Set *<p pcpMin>  = closest page cpMin <lt>= range cpMin, and
 *		set *<p pcpMost> = closest page cpMost <gt>= range cpMost
 *
 *	@devnote
 *		This routine plays a role analogous to CTxtRange::FindParagraph
 *		(pcpMin, pcpMost), but needs extra arguments since this line ptr does
 *		not know the range cp's.  This line ptr is located at the range active
 *		end, which is determined by the range's signed length <p cch> in
 *		conjunction with <p cpMin>.  See also the very similar function
 *		CRunPtrBase::FindRun().  The differences seem to make a separate
 *		encoding simpler.
 */
void CLinePtr::FindPage (
	LONG *pcpMin,			//@parm Out parm for bounding-page cpMin
	LONG *pcpMost,			//@parm Out parm for bounding-page cpMost
	LONG cpMin,				//@parm Range cpMin
	LONG cch,				//@parm Range signed length
	LONG cchText)			//@parm Story length
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CLinePtr::FindPage");

	Assert(_pdp->IsMultiLine() && _pdp->IsInPageView());

	LONG	cp;							
	BOOL	fMove;						// Controls Move for pcpMost
	LONG	i;
	CLine *pli;

	AdjustForward();					// Select forward line
	if(pcpMin)
	{									// If cch != 0, rp is sure to end up
		fMove = cch;					//  at cpMin, so pcpMost needs advance
		if(cch > 0)						// rp is at cpMost, so move it to
			Move(-cch);					//  cpMin
		cp = cpMin - _ich;				// Subtract off line offset in this run
		pli = (CLine *)GetLine();
		for(i = GetLineIndex(); i > 0 && !pli->_fFirstOnPage; i--)
		{
			pli--;
			cp -= pli->_cch;
		}
		*pcpMin = cp;
	}
	else
		fMove = cch < 0;				// Need to advance to get pcpMost

	if(pcpMost)
	{
		LONG cLine = ((CDisplayML *)_pdp)->Count();

		cch = abs(cch);
		if(fMove)						// Advance to cpMost = cpMin + cch,
			Move(cch);					//  i.e., range's cpMost
		cp = cpMin + cch;
		pli = (CLine *)GetLine();
		i = GetLineIndex();
		if(pcpMin && cp == *pcpMin)		// Expand IP to next page
		{
			Assert(!_ich);
			cp += pli->_cch;			// Include first line even if it starts
			pli++;						//  a new page (pli->_fFirstOnPage = 1)
			i++;						
		}
		else if (_ich)
		{								// If not at start of line, add
			cp += GetCchLeft();			//  remaining cch in run to cpMost, and
			pli++;						//  skip to next line
			i++;
		}

		while(i < cLine && !pli->_fFirstOnPage)
		{
			cp += pli->_cch;			// Add in next line's
			pli++;
			i++;
		}
		*pcpMost = cp;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\ldte.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LDTE.C - RichEdit Light Data Transfer Engine |
 *
 *		This file contains data transfer code using IDataObject
 *
 *	Author: <nl>
 *		alexgo (4/25/95)
 *
 *	Revisions: <nl>
 *		murrays (7/6/95) auto-doc'd and added RTF support
 *
 *	FUTURE (AlexGo): <nl>
 *		Maybe merge this class with CTxtRange to make more efficient use of
 *		the this ptr.  All but two methods use a CTxtRange and one of these
 *		could be global.  The two are:
 *
 *		GetDropTarget( IDropTarget **ppDropTarget )
 *		GetDataObjectInfo(IDataObject *pdo, DWORD *pDOIFlags) // Can be global
 *
 *		In general, a range can spawn data objects, which need to have a clone
 *		of the range in case the range is moved around.  The contained range
 *		is used for delayed rendering.  A prenotification is sent to the data
 *		object just before the data object's data is to be changed.  The data
 *		object then renders the data in its contained range, whereupon the
 *		object becomes independent of the range and destroys the range.
 *
 *	@devnote
 *		We use the word ANSI in a general way to mean any multibyte character
 *		system as distinguished from 16-bit Unicode.  Technically, ANSI refers
 *		to a specific single-byte character system (SBCS).  We translate
 *		between "ANSI" and Unicode text using the Win32
 *		MultiByteToWideChar() and WideCharToMultiByte() APIs.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_ldte.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_edit.h"
#include "_disp.h"
#include "_select.h"
#include "_dragdrp.h"
#include "_dxfrobj.h"
#include "_rtfwrit.h"
#include "_rtfread.h"
#include "_urlsup.h"

ASSERTDATA


//Local Prototypes
DWORD CALLBACK WriteHGlobal(WRITEHGLOBAL *pwhg, LPBYTE pbBuff, LONG cb, LONG *pcb);

#define	SFF_ADJUSTENDEOP	0x80000000

#define FMITAL	(FMATHITAL >> 24)
#define FMBOLD	(FMATHBOLD >> 24)
#define FMSCRP	(FMATHSCRP >> 24)
#define FMFRAK	(FMATHFRAK >> 24)
#define FMOPEN	(FMATHOPEN >> 24)
#define FMSANS	(FMATHSANS >> 24)
#define FMMONO	(FMATHMONO >> 24)

#if FMITAL != 0x02 || FMBOLD != 0x04 || FMSCRP != 0x08 || FMFRAK != 0x10 || FMOPEN != 0x20 || FMSANS != 0x40 || FMMONO != 0x80
#error "Need to change >> 24 (and << 24) below"
#endif

//
// LOCAL METHODS
//

/*
 *	ReadHGlobal(dwCookie, pbBuff, cb, pcb)
 *
 *	@func
 *		EDITSTREAM callback for reading from an hglobal
 *
 *	@rdesc
 *		es.dwError
 */
DWORD CALLBACK ReadHGlobal(
	DWORD_PTR	dwCookie,		// @parm dwCookie
	LPBYTE	pbBuff,				// @parm Buffer to fill
	LONG	cb,					// @parm Buffer length
	LONG *	pcb)				// @parm Out parm for # bytes stored
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "ReadHGlobal");

	READHGLOBAL * const prhg = (READHGLOBAL *)dwCookie;

	cb = min(cb, prhg->cbLeft);
	CopyMemory(pbBuff, prhg->ptext, cb);
	prhg->cbLeft -= cb;
	prhg->ptext  += cb;

	if(pcb)
		*pcb = cb; 
	return NOERROR;	
}

/*
 *	WriteHGlobal(pwhg, pbBuff, cb, pcb)
 *
 *	@func
 *		EDITSTREAM callback for writing ASCII to an hglobal
 *
 *	@rdesc
 *		error (E_OUTOFMEMORY or NOERROR)
 */
DWORD CALLBACK WriteHGlobal(
	DWORD_PTR	dwCookie,		// @parm dwCookie
	LPBYTE	pbBuff,				// @parm Buffer to write from
	LONG	cb,					// @parm Buffer length
	LONG *	pcb)				// @parm Out parm for # bytes written
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "WriteHGlobal");

	WRITEHGLOBAL * const pwhg = (WRITEHGLOBAL *)dwCookie;

	HGLOBAL		hglobal = pwhg->hglobal;
	LPSTR		pstr;

	if(pwhg->cch + cb > pwhg->cb)			// Less than requested cb in
	{										//  current Alloc
		ULONG cbNewSize = GROW_BUFFER(pwhg->cb, cb);
		hglobal = GlobalReAlloc(hglobal, cbNewSize, GMEM_MOVEABLE);
		if(!hglobal)	
			return (DWORD)E_OUTOFMEMORY;
		pwhg->hglobal = hglobal;			// May be superfluous...
		pwhg->cb = cbNewSize;
	}
	pstr = (LPSTR)GlobalLock(hglobal);
	if(!pstr)
		return (DWORD)E_OUTOFMEMORY;

	CopyMemory(pstr + pwhg->cch, pbBuff, cb);
	GlobalUnlock(hglobal);
	pwhg->cch += cb;
	if(pcb)
		*pcb = cb; 
	return NOERROR;	
}


//
// PUBLIC METHODS
//

/*
 *	GetCharFlags(pch, cchPch, iCharRepDefault)
 *
 *	@func
 *		Return principle character flags corresponding to character *pch.
 *		Note that if *pch is a Unicode surrogate-pair lead word, then
 *		*(pch + 1) is used as the trail word. Note also that only math
 *		fonts return more than one flag. The values follow the Unicode
 *		Standard Version 3.0 with some extensions beyond that standard
 *		(limited plane-2 support and plane-1 math alphanumerics).
 *
 *	@rdesc
 *		Principle char flag corresponding to *pch.
 *
 *		=FUTURE= should be constructed as a 2-level lookup.
 */
QWORD GetCharFlags(
	const WCHAR *pch,			//@parm Gives char to get flag for
	LONG	cch,				//@parm cch of valid chars in pch
	BYTE	iCharRepDefault)	//@parm Default charrep in FE heuristics
{
	WCHAR ch = *pch;

	if(ch < 0x100)						// Latin1: divide into 3 bits
		return	ch > 0x7F ? FHILATIN1 : 
				ch < 0x40 ? FBELOWX40 : FASCIIUPR;

	if(ch < 0x590)
	{
		if(ch >= 0x530)
			return FARMENIAN;

		if(ch >= 0x492)
			return FOTHER;				// Extended Cyrillic

		if(ch >= 0x400)
			return FCYRILLIC;

		if(ch >= 0x370)
			return FGREEK;

		if(ch >= 0x300)					// Combining diacritical marks
			return FCOMBINING;			

		return (ch < 0x250) ? FLATIN2 : FOTHER;
	}
	// Complex scripts start at 0x590 with Hebrew (aside from combining)
	if(ch <= 0x11FF)					// Complex scripts end at 0x11FF
	{									//  (at least in July, 2000)
		if(ch < 0x900)
		{
			return (ch < 0x600 ? FHEBREW :
					ch < 0x700 ? FARABIC :
					ch < 0x750 ? FSYRIAC : 
					ch < 0x780 ? FRTL :
					ch < 0x7C0 ? FTHAANA : FRTL);
		}
		if(ch < 0xE00)					// 0x900 - 0xDFF: Indic scripts
			return FontSigFromCharRep(DEVANAGARI_INDEX + ((ch - 0x900) >> 7));

		if(ch < 0xF00)
			return ch < 0xE80 ? FTHAI : FLAO;

		if(ch < 0x1000)
			return ch < 0xFC0 ? FTIBETAN : FOTHER;

		if(ch < 0x1100)
			return ch < 0x10A0 ? FMYANMAR : FGEORGIAN;

		return FJAMO;
	}

	DWORD dwCharFlags = 0;
	if(ch < 0x3100)
	{
		if(ch >= 0x3000)
		{
			if(ch > 0x3040)
				return FKANA;
			goto CLASSIFY_CHINESE;
		}
		if(ch < 0x18AF)
		{
			Assert(ch >= 0x1200);

			if(ch <= 0x137F)
				return FETHIOPIC;

			if(IN_RANGE(0x13A0, ch, 0x16F0))
			{
				return ch < 0x1400 ? FCHEROKEE :
					   ch < 0x1680 ? FABORIGINAL :
					   ch < 0x16A0 ? FOGHAM : FRUNIC;
			}
			if(IN_RANGE(0x1780, ch, 0x18AF))
				return ch < 0x1800 ? FKHMER : FMONGOLIAN;

			return FOTHER;
		}

		if(IN_RANGE(RTLMARK, ch, 0x202E) && (ch == RTLMARK ||
			IN_RANGE(0x202A, ch, 0x202E)))
		{
			return FRTL;
		}

		if(ch == EURO || ch == 0x2122)			// Euro or TM
			return FHILATIN1;

		if(ch == 0x20AA)						// Hebrew currency sign
			return FHEBREW;

		if(W32->IsFESystem() || IsFECharRep(iCharRepDefault) || IN_RANGE(0x2460, ch, 0x24FF))
			goto CLASSIFY_CHINESE;

		if(IN_RANGE(0x200b, ch, 0x200d))		// ZWSP, ZWNJ, ZWJ
			return FUNIC_CTRL;

		if(ch == 0x2016 || ch == 0x2236)
		{
			// Some hack to make Word2000 happy
			if(VerifyFEString(CP_CHINESE_TRAD, &ch, 1, TRUE) == CP_CHINESE_TRAD)   
				return FBIG5;
			
			if(VerifyFEString(CP_CHINESE_SIM,  &ch, 1, TRUE) == CP_CHINESE_SIM)
				return FCHINESE;
		}
		if(IN_RANGE(0x2800, ch, 0x28FF))
			return FBRAILLE;

		return FOTHER;
	}
	if(ch < 0xD800)
	{		
		Assert(ch >= 0x3100);
		if(ch < 0x3400)
		{
			if(ch < 0x3130)						// Bopomofo annotation chars
			{									//  used in Chinese text
				return (W32->GetFEFontInfo() == BIG5_INDEX)
						? FBIG5 : FCHINESE;
			}
			if (ch < 0x3190 ||					// Hangul Compatibility Jamo
				IN_RANGE(0x3200, ch, 0x321F) ||	// Parenthesized Hangul
				IN_RANGE(0x3260, ch, 0x327F))	// Circled Hangul
			{
				return FHANGUL;
			}
			if(IN_RANGE(0x32D0, ch, 0x337F))	// Circled & Squared Katakana words
				return FKANA;
		}

		if(ch < 0x04DFF)
			return FOTHER;

		if(ch < 0xA000)
			goto CLASSIFY_CHINESE;

		if(ch < 0xA4D0)
			return FYI;

		if(ch < 0xAC00)
			goto CLASSIFY_CHINESE;

		return FHANGUL;
	}

	if(ch < 0xE000)
	{
		if(cch > 1 && IN_RANGE(UTF16_LEAD, ch, UTF16_TRAIL - 1))
		{
			pch++;
			if(IN_RANGE(UTF16_TRAIL, *pch, UTF16_TRAIL + 1023))
			{
				LONG lch = (*pch & 0x3FF) + ((ch & 0x3FF) << 10) + 0x10000;
				/* For testing purposes, implement math alphanumerics. Block
				 * starts with thirteen 52-char English alphabets, five 58-char
				 * Greek alphabets (2*24 + 10 variants), and ended with five
				 * 10-char digits as given by the following table (E - English,
				 * D - digit, G - Greek):
				 *
				 *  1) Math bold (EGD)			 2) Math italic (E) 
				 *  3) Math bold italic (EG)	 4) Math script (E)
				 *  5) Math script bold (E)		 6) Math fraktur (E)
				 *  7) Math fraktur bold (E)	 8) Math open-face (ED)
				 *  9) Math sans (ED)			10) Math sans bold (EGD)
				 * 11) Math sans italic (E)		12)	Math sans bold italic (EG)
				 * 13) Math monospace (ED)
				 */
				static BYTE rgFsE[] = {
					FMBOLD, FMITAL, FMBOLD + FMITAL, FMSCRP, FMSCRP + FMBOLD,
					FMFRAK, FMFRAK + FMBOLD, FMOPEN, FMSANS, FMSANS + FMBOLD,
					FMSANS + FMITAL, FMSANS + FMBOLD + FMITAL, FMMONO};

				static BYTE rgFsG[] = {
					FMBOLD, FMITAL, FMBOLD + FMITAL, FMSANS + FMBOLD,
					FMSANS + FMBOLD + FMITAL};

				static BYTE rgFsD[] = {
					FMBOLD, FMOPEN, FMSANS, FMSANS + FMBOLD, FMMONO};

				if(IN_RANGE(0x1D400, lch, 0x1D7FF))
				{
					lch -= 0x1D400;				// Sub math-alphanumerics origin
					if(lch < 13*52)				// 13 English alphabets
						return FSURROGATE + FASCIIUPR + (rgFsE[lch/52] << 24);

					lch -= 13*52;
					if(lch < 5*58)				// 5 Greek alphabets
						return FSURROGATE + FGREEK + (rgFsG[lch/58] << 24);

					lch -= 5*58 + (1024 - 5*58 - 13*52 - 5*10);
					if(lch >= 0)				// 5 digit groups
						return FSURROGATE + FBELOWX40 + (rgFsD[lch/10] << 24);
				}
				if(IN_RANGE(0x20000, lch, 0x2FFFF))	// Plane 2: Extension B
				{									//  CJK characters
					dwCharFlags = FSURROGATE;
					goto CLASSIFY_CHINESE;
				}
			}
		}
		return FSURROGATE;						// Surrogate
	}

	if(ch < 0xF900)								// Private Use Area
	{
		if(IN_RANGE(0xF020, ch, 0xF0FF))
			return FSYMBOL;

		return FOTHER;
	}

	if(ch < 0xFF00)
	{
		if(IN_RANGE(0xFE30, ch, 0xFE4F))		// CJK Vertical variants
			goto CLASSIFY_CHINESE;	

		if(IN_RANGE(0xF900, ch, 0xFAFF))		// CJK characters
			goto CLASSIFY_CHINESE;	

		return FOTHER;
	}

	if(IN_RANGE(0xFF00, ch, 0xFFEF))		
	{										
		if (ch < 0xFF60 || ch >= 0xFFE0 ||		// Fullwidth ASCII or Fullwidth symbols
			ch == 0xFF64)						// special case Half-width ideographic comma
			goto CLASSIFY_CHINESE;		
							
		return ch < 0xFFA0 ? FKANA : FHANGUL;	// Halfwidth Katakana/Hangul		
	}
	return FOTHER;


CLASSIFY_CHINESE:
	if(IN_RANGE(JPN2_INDEX, iCharRepDefault, CHT2_INDEX))
		iCharRepDefault -= JPN2_INDEX - SHIFTJIS_INDEX;

	if(IN_RANGE(SHIFTJIS_INDEX, iCharRepDefault, BIG5_INDEX))
	{
CLASS2:
		LONG dIndex = iCharRepDefault - SHIFTJIS_INDEX;
		if(!dwCharFlags)
			return (DWORD)FKANA << dIndex;

		union									// Plane 2
		{										// Endian-dependent way to
			QWORD qw;							//  avoid 64-bit left shift
			DWORD dw[2];
		};
		dw[0] = FSURROGATE;
		dw[1] = (DWORD)(FJPN2 >> 32) << dIndex;
		return qw;
	}

	iCharRepDefault = W32->GetFEFontInfo();

	if(IN_RANGE(SHIFTJIS_INDEX, iCharRepDefault, BIG5_INDEX))
		goto CLASS2;

	return FCHINESE;
}

/*
 *	CLightDTEngine::CLightDTEngine()
 *
 *	@mfunc
 *		Constructor for Light Data Transfer Engine
 */
CLightDTEngine::CLightDTEngine()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CLightDTEngine");

	_ped = NULL;
	_pdt = NULL;
	_pdo = NULL;
	_fUseLimit = FALSE;
	_fOleless = FALSE;
}

/*
 *	CLightDTEngine::~CLightDTEngine 
 *
 *	@mfunc
 *		Handles all necessary clean up for the object.
 */
CLightDTEngine::~CLightDTEngine()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::~CLightDTEngine");

	if( _pdt )
	{
		_pdt->Zombie();
		_pdt->Release();
		_pdt = NULL;
	}
	Assert(_pdo == NULL);
}

/*
 *	CLightDTEngine::Destroy()
 *
 *	@mfunc
 *		Deletes this instance
 */
void CLightDTEngine::Destroy()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::Destroy");

	delete this;
}

/*
 *	CLightDTEngine::CopyRangeToClipboard ( prg, lStreamFormat )
 *
 *	@mfunc
 *		Copy the text of the range prg to the clipboard using Win32 APIs
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::CopyRangeToClipboard(
	CTxtRange *prg,				//@parm Range to copy to clipboard
	LONG	   lStreamFormat)	//@parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CopyRangeToClipboard");

	HRESULT hresult = E_FAIL;
	IDataObject *pdo = NULL;
	IRichEditOleCallback * precall = _ped->GetRECallback();
	BOOL fSingleObject;
	CHARRANGE chrg;

	prg->GetRange(chrg.cpMin, chrg.cpMost);

	if (chrg.cpMin >= chrg.cpMost)
	{
		// We can't copy an insertion point to the clipboard so we are done.
		return NOERROR;
	}

	fSingleObject = chrg.cpMost - chrg.cpMin == 1 &&
		_ped->HasObjects() &&
		_ped->_pobjmgr->CountObjectsInRange(chrg.cpMin, chrg.cpMost);
	if(precall)
	{
		// Give the callback a chance to give us its own IDataObject
		hresult = precall->GetClipboardData(&chrg, RECO_COPY, &pdo);
	}

	// If we didn't get an IDataObject from the callback, build our own
	if(hresult != NOERROR)
	{
		// If the range is empty, don't bother creating it.  Just
		// leave the clipboard alone and return
		if( prg->GetCch() == 0 )
		{
			_ped->Beep();
			return NOERROR;
		}

		hresult = RangeToDataObject(prg, SF_TEXT | SF_RTF | lStreamFormat, &pdo);
	}

	// NB: it's important to check both hresult && pdo; it is legal for
	// our client to say "yep, I handled the copy, but there was nothing
	// to copy".
	if( hresult == NOERROR && pdo )
	{
		hresult = OleSetClipboard(pdo);
		if( hresult != NOERROR )
		{
			HWND hwnd;
			_fOleless = TRUE;
			// Ole less clipboard support
			if (_ped->TxGetWindow(&hwnd) == NOERROR &&
				::OpenClipboard(hwnd) &&
				::EmptyClipboard()
			)
			{
				::SetClipboardData(cf_RTF, NULL);

				::SetClipboardData(CF_UNICODETEXT, NULL);
				if(_ped->IsDocMoreThanLatin1Symbol())
				{
					::SetClipboardData(cf_RTFUTF8, NULL);
					::SetClipboardData(cf_RTFNCRFORNONASCII, NULL);
				}
				::SetClipboardData(CF_TEXT, NULL);

				if (fSingleObject)
					::SetClipboardData(CF_DIB, NULL);
				::CloseClipboard();
				hresult = NOERROR;				// To cause replace range to happen
			}
		}
        if(_pdo)
			_pdo->Release();
		_pdo = pdo;
	}
	return hresult;
}

/* 
 *	CLightDTEngine::CutRangeToClipboard( prg, lStreamFormat, publdr );
 *	
 *	@mfunc
 *		Cut text of the range prg to the clipboard
 *
 *	@devnote
 *		If publdr is non-NULL, antievents for the cut operation should be
 *		stuffed into this collection
 *
 *	@rdesc
 *		HRESULT from CopyRangeToClipboard()
 *
 *	@devnote
 *		First copy the text to the clipboard, then delete it from the range
 */
HRESULT CLightDTEngine::CutRangeToClipboard(
	CTxtRange *	  prg,				//@parm Range to cut to clipboard
	LONG		  lStreamFormat,	//@parm Stream format
	IUndoBuilder *publdr )			//@parm Undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CutRangeToClipboard");

	Assert(!_ped->TxGetReadOnly());

	prg->AdjustEndEOP(NONEWCHARS);				// Don't include trailing EOP
												//  in some selection cases
	HRESULT hr = CopyRangeToClipboard(prg, lStreamFormat);

	if( publdr )
	{
		publdr->SetNameID(UID_CUT);
		publdr->StopGroupTyping();
	}

	if(hr == NOERROR)							// Delete contents of range
		prg->Delete(publdr, SELRR_REMEMBERRANGE);	

	return hr;
}

/*
 *	CLightDTEngine::FlushClipboard()
 *
 *	@mfunc	flushes the clipboard (if needed).  Typically called during
 *			shutdown.
 */
void CLightDTEngine::FlushClipboard()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::FlushClipboard");
	ENSAVECLIPBOARD ens;

	if( _pdo )
	{
		if( OleIsCurrentClipboard(_pdo) == NOERROR )
		{
			CDataTransferObj *pdo = NULL;

			// check to see if we have to flush the clipboard.
			ZeroMemory(&ens, sizeof(ENSAVECLIPBOARD));

			// check to make sure the object is one of ours before accessing
			// the memory.  EVIL HACK ALERT.  'nuff said.

			if( _pdo->QueryInterface(IID_IRichEditDO, (void **)&pdo ) 
				== NOERROR && pdo  )
			{
				ens.cObjectCount = pdo->_cObjs;
				ens.cch = pdo->_cch;
				pdo->Release();
			}

			if( _ped->TxNotify(EN_SAVECLIPBOARD, &ens) == NOERROR )
				OleFlushClipboard();

			else
				OleSetClipboard(NULL);
		}
		_pdo->Release();
		_pdo = NULL;
	}
}

/*
 *	CLightDTEngine::CanPaste(pdo, cf, flags)
 *
 *	@mfunc
 *		Determines if clipboard format cf is one we can paste.
 *
 *	@rdesc
 *		BOOL - true if we can paste cf into range prg OR DF_CLIENTCONTROL
 *		if the client is going to handle this one.
 *
 *	@devnote
 *		we check the clipboard ourselves if cf is 0. Primarily, this
 *		is for backwards compatibility with Richedit1.0's EM_CANPASTE
 *		message.
 *
 */
DWORD CLightDTEngine::CanPaste(
	IDataObject *pdo,	// @parm Data object to check; if NULL use clipboard
	CLIPFORMAT cf, 		// @parm Clipboard format to query about; if 0, use
						//		 best available.
	DWORD flags)		// @parm Flags 
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CanPaste");

	IRichEditOleCallback *precall = _ped->GetRECallback();
	CLIPFORMAT	cf0 = cf;
	DWORD		cFETC = CFETC;
	HRESULT		hr = NOERROR;
	DWORD		ret = FALSE;

	if( pdo == NULL && precall )
	{
		// don't worry about errors
		OleGetClipboard(&pdo);
	}
	else if( pdo )
	{
		// So we can make just one 'Release' call below
		pdo->AddRef();
	}
	
	if( precall && pdo )
	{
		hr = precall->QueryAcceptData(pdo, &cf, flags, 0, NULL);

		if( SUCCEEDED(hr) && (hr != S_OK && hr != DATA_S_SAMEFORMATETC ) )
		{
			ret = DF_CLIENTCONTROL;
			goto Exit;
		}
		else if( FAILED(hr) && hr != E_NOTIMPL )
			goto Exit;

		else if(SUCCEEDED(hr))
		{
			// We should go on and check ourselves unless the client
			// modified the format when it shouldn't have
			if(cf0 && cf0 != cf)
				goto Exit;
		}

		// Otherwise, continue with our normal checks
	}

    if(_ped->TxGetReadOnly())		    // Can't paste if read only
		goto Exit;

	while(cFETC--)						// Does cf = format we can paste or
	{									//  is selection left up to us?
		cf0 = g_rgFETC[cFETC].cfFormat;
	    if( cf == cf0 || !cf )
		{
			// Either we hit the format requested, or no format was
			// requested.  Now see if the format matches what we can
			// handle in principle. There are three basic categories:
			//
			//		1. Rich text with OLE callback:
			//		   can handle pretty much everything.
			//		2. Rich text with no OLE callback:
			//		   can handle anything but OLE specific	formats.
			//		3. Plain text only:
			//		   can only handle plain text formats.
			if ((_ped->_fRich || (g_rgDOI[cFETC] & DOI_CANPASTEPLAIN)) &&
				(precall || !(g_rgDOI[cFETC] & DOI_CANPASTEOLE)))
			{
				// once we get this far, make sure the data format
				// is actually available.
				if( (pdo && pdo->QueryGetData(&g_rgFETC[cFETC]) == NOERROR ) ||
					(!pdo && IsClipboardFormatAvailable(cf0)) )
				{
					ret = TRUE;			// Return arbitrary non zero value.
					break;
				}
			}
		}
    }	

Exit:
	if(pdo)
		pdo->Release();

	return ret;
}

/*
 *	CLightDTEngine::RangeToDataObject (prg, lStreamFormat, ppdo)
 *
 *	@mfunc
 *		Create data object (with no OLE-formats) for the range prg
 *
 *	@rdesc
 *		HRESULT	= !ppdo ? E_INVALIDARG :
 *				  pdo ? NOERROR : E_OUTOFMEMORY
 */
HRESULT CLightDTEngine::RangeToDataObject(
	CTxtRange *		prg,			// @parm Range to get DataObject for
	LONG			lStreamFormat,	// @parm Stream format to use for loading
	IDataObject **	ppdo)			// @parm Out parm for DataObject
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::RangeToDataObject");

	if(!ppdo)
		return E_INVALIDARG;

	// Use SFF_SELECTION to indicate that this isn't used to write the whole doc.
	// Need to rethink if we add ITextDocument::Copy(), which would be used to
	// copy the whole doc.
	CDataTransferObj *pdo = CDataTransferObj::Create(_ped, prg, lStreamFormat | SFF_SELECTION);

	*ppdo = pdo;
	return pdo ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CLightDTEngine::RenderClipboardFormat(wFmt)
 *
 *	@mfunc
 *		Renders current clipboard data object in specified format. (Ole less transfer)
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::RenderClipboardFormat(
	WPARAM wFmt)
{
	HRESULT hr = S_OK;
	if (_fOleless && 
		(wFmt == cf_RTF || wFmt == CF_UNICODETEXT || wFmt == CF_DIB || wFmt == CF_TEXT))
	{
		Assert(_pdo);
		STGMEDIUM med;
		DWORD iFETC = iUnicodeFETC;

		if (wFmt == cf_RTF)
			iFETC = iRtfFETC;

		else if (wFmt == CF_DIB)
			iFETC = iDIB;

		else if (wFmt == CF_TEXT)
			iFETC = iAnsiFETC;

		med.tymed = TYMED_HGLOBAL;
		med.pUnkForRelease = NULL;
		med.hGlobal = NULL;
		hr = _pdo->GetData(&g_rgFETC[iFETC], &med);
		hr = hr || ::SetClipboardData(wFmt, med.hGlobal) == NULL;
	}
	return hr;								// Pretend we did the right thing.
}

/*
 *	CLightDTEngine::RenderAllClipboardFormats()
 *
 *	@mfunc
 *		Renders current clipboard data object (text and RTF). (Ole less transfer)
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::RenderAllClipboardFormats()
{
	HRESULT hr;
	if(_fOleless)
	{
		HWND howner = ::GetClipboardOwner();
		HWND hwnd;
		if (howner &&
			_ped->TxGetWindow(&hwnd) == NOERROR &&
			howner == hwnd &&
			::OpenClipboard(hwnd))
		{
			::EmptyClipboard();
			hr = RenderClipboardFormat(cf_RTF);
			hr = hr || RenderClipboardFormat(CF_UNICODETEXT);
			hr = hr || RenderClipboardFormat(CF_DIB);
			hr = hr || RenderClipboardFormat(CF_TEXT);
			::CloseClipboard();
			return hr;
		}
	}
	return S_OK;		// Pretend we did the right thing.
}

/*
 *	CLightDTEngine::DestroyClipboard()
 *
 *	@mfunc
 *		Destroys the clipboard data object
 *
 *	@rdesc
 *		HRESULT
 *
 */
HRESULT CLightDTEngine::DestroyClipboard()
{
	// Nothing to do.  This should work together with our Flush clipboard logic
	return S_OK;
}

/*
 *	CLightDTEngine::HGlobalToRange(dwFormatIndex, hGlobal, ptext, prg, publdr)
 *
 *	@mfunc
 *		Copies the contents of the given string (ptext) to the given range.
 *		The global memory handle may or may not point to the string depending
 *		on the format
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::HGlobalToRange(
	DWORD		dwFormatIndex,
	HGLOBAL		hGlobal,
	LPTSTR		ptext,
	CTxtRange *	prg,
	IUndoBuilder *publdr)
{
	READHGLOBAL	rhg;
	EDITSTREAM	es;	
	HCURSOR		hcur = NULL;

	// If RTF, wrap EDITSTREAM around hGlobal & delegate to LoadFromEs()
	if (dwFormatIndex == iRtfNoObjs || dwFormatIndex == iRtfFETC ||
		dwFormatIndex == iRtfUtf8 || dwFormatIndex == iRtfNCRforNonASCII)
	{
		Assert(hGlobal != NULL);
		rhg.ptext		= (LPSTR)ptext;			// Start at beginning
		rhg.cbLeft		= GlobalSize(hGlobal);	//  with full length
		es.dwCookie		= (DWORD_PTR)&rhg;		// The read "this" ptr
		es.dwError		= NOERROR;				// No errors yet
		es.pfnCallback	= ReadHGlobal;			// The read method
		// Want wait cursor to display sooner
		bool fSetCursor = rhg.cbLeft > NUMPASTECHARSWAITCURSOR;
		if (fSetCursor)
			hcur = _ped->TxSetCursor(LoadCursor(NULL, IDC_WAIT));
		LONG cchLoad = LoadFromEs(prg, SFF_SELECTION | SF_RTF, &es, TRUE, publdr);
		if (fSetCursor)
			_ped->TxSetCursor(hcur);
		return (es.dwError != NOERROR) ? es.dwError : 
			   cchLoad ? NOERROR : S_FALSE;
	}

	Assert( dwFormatIndex == iRtfAsTextFETC ||
			dwFormatIndex == iAnsiFETC ||
			dwFormatIndex == iUnicodeFETC );

	BOOL fTRDsInvolved;
	prg->CheckTableSelection(FALSE, TRUE, &fTRDsInvolved, 0);

	LONG cchEOP = 0;
	LONG cchMove = 0;
	if(fTRDsInvolved)
		cchEOP = prg->DeleteWithTRDCheck(publdr, SELRR_REMEMBERRANGE, &cchMove,
						RR_NEW_CHARS | RR_NO_LP_CHECK);

	LONG cchNew = prg->CleanseAndReplaceRange(-1, ptext, TRUE, publdr, NULL, NULL,
						RR_NEW_CHARS | RR_ITMZ_NONE | RR_NO_LP_CHECK | RR_UNHIDE);
	if(prg->GetCch() && prg->IsSel())
		return E_FAIL;						// Paste failed due to UI rules

	if (_ped->IsRich() &&
		(!_ped->Get10Mode() || cchEOP))		// If rich text & not 1.0 mode, &
	{										//  new text ends with EOP, delete
		prg->DeleteTerminatingEOP(publdr);	//  that EOP to agree with Word
	}
	prg->ItemizeReplaceRange(cchNew + cchEOP, cchMove, publdr, TRUE);// Itemize w/ UnicodeBidi
											
	return NOERROR;						
}

/* 
 *	CLightDTEngine::DIBToRange(hGlobal, prg, publdr)
 *
 *	@mfunc
 *		Inserts dib data from the clipboard into range in the control
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::DIBToRange(
	HGLOBAL			hGlobal,
	CTxtRange *		prg,	
	IUndoBuilder *	publdr)
{
	HRESULT         hresult = DV_E_FORMATETC;
	REOBJECT        reobj = { 0 };
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(hGlobal);

	reobj.clsid = CLSID_StaticDib;
	reobj.sizel.cx = _ped->_pdp->DUtoHimetricU(pbmi->bmiHeader.biWidth);
	reobj.sizel.cy = _ped->_pdp->DVtoHimetricV(pbmi->bmiHeader.biHeight);
	_ped->GetClientSite(&reobj.polesite);

	COleObject *pobj = (COleObject *)reobj.polesite;
	COleObject::ImageInfo *pimageinfo = new COleObject::ImageInfo;
	pobj->SetHdata(hGlobal);
	pimageinfo->xScale = 100;
	pimageinfo->yScale = 100;
	pimageinfo->xExtGoal = reobj.sizel.cx;
	pimageinfo->yExtGoal = reobj.sizel.cy;
	pimageinfo->cBytesPerLine = 0;
	pobj->SetImageInfo(pimageinfo);
	
	// FUTURE: Why are we not testing for NULL earlier before we assign it to pobj? v-honwch
	// Also, do we need to release interfaces inside reobj (poleobj, polesite, pstg) before exit?
	if (!reobj.polesite )
		return hresult;

	// Put object into the edit control
	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = prg->GetCp();
	reobj.dvaspect = DVASPECT_CONTENT;
	reobj.dwFlags = REO_RESIZABLE;

	// Since we are loading an object, it shouldn't be blank
	reobj.dwFlags &= ~REO_BLANK;

	prg->Set_iCF(-1);	
	hresult = _ped->GetObjectMgr()->InsertObject(prg, &reobj, NULL);

	return hresult;
}

/* 
 *	CLightDTEngine::PasteDataObjectToRange (pdo, prg, cf, rps, pubdlr, dwFlags)
 *
 *	@mfunc
 *		Inserts data from the data object pdo into the range prg. If the
 *		clipboard format cf is not NULL, that format is used; else the highest
 *		priority clipboard format is used.  In either case, any text that
 *		already existed in the range is replaced.  If pdo is NULL, the
 *		clipboard is used.
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::PasteDataObjectToRange(
	IDataObject *	pdo,		// @parm Data object to paste
	CTxtRange *		prg,		// @parm Range into which to paste
	CLIPFORMAT		cf,			// @parm ClipBoard format to paste
	REPASTESPECIAL *rps,		// @parm Special paste info
	IUndoBuilder *	publdr,		// @parm Undo builder to receive antievents
	DWORD			dwFlags)	// @parm DWORD packed flags
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::PasteDataObjectToRange");

	BOOL		f10Mode = _ped->Get10Mode();
	HGLOBAL		hGlobal = NULL;
	HRESULT		hresult = DV_E_FORMATETC;
	HGLOBAL		hUnicode = NULL;
	DWORD		i;
	STGMEDIUM	medium = {0, NULL};
	IDataObject *pdoSave = pdo;
	FORMATETC *	pfetc = g_rgFETC;
	LPTSTR		ptext = NULL;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();
	BOOL		fThawDisplay = FALSE;
	BOOL        bFormatFound = FALSE;   // flag which determines if a matching cf format
	                                    // was found in g_rgFETC (1.0 compatibility)

	if(!pdo)								// No data object: use clipboard
	{
		hresult = OleGetClipboard(&pdo);
		if(FAILED(hresult))
		{
			// Ooops.  No Ole clipboard support
			// Need to use direct clipboard access
			HWND howner = ::GetClipboardOwner();
			HWND hwnd;
			if (howner &&
				_ped->TxGetWindow(&hwnd) == NOERROR &&
				howner == hwnd)
			{
				// We are cut/pasting within the same richedit instance
				// Use our cached clipboard data object
				pdo = _pdo;
				if(!pdo)		// Some failure
				{
					_ped->Beep();
					return hresult;
				}
				pdo->AddRef();
			}
			else
			{
				// Oh Oh We need to transfer from clipboard without data object
				// Data must be coming from another window instance
				if (_ped->TxGetWindow(&hwnd) == NOERROR &&
					::OpenClipboard(hwnd)
				)
				{
					HGLOBAL		hUnicode = NULL;

					DWORD dwFmt = iRtfUtf8;				// Try for UTF8 RTF
					_ped->_pdp->Freeze();
					if(!f10Mode)
					{
						hGlobal = ::GetClipboardData(cf_RTFUTF8);
						if (hGlobal == NULL)				// Wasn't there, so
						{									//  try for RTF
							hGlobal = ::GetClipboardData(cf_RTFNCRFORNONASCII);
							dwFmt = iRtfNCRforNonASCII;
						}
					}
					if (hGlobal == NULL)				// Wasn't there, so
					{									//  try for RTF
						hGlobal = ::GetClipboardData(cf_RTF);
						dwFmt = iRtfFETC;
					}
					if (hGlobal == NULL && !f10Mode)	// Wasn't there either
					{									//  so try for plain
						hGlobal = ::GetClipboardData(CF_UNICODETEXT);
						dwFmt = iUnicodeFETC;
					}
					if (hGlobal == NULL)				// Wasn't there either
					{									//  so try for plain text
						hGlobal = ::GetClipboardData(CF_TEXT);
						dwFmt = iAnsiFETC;
					}
					if (hGlobal)
					{
						if (dwFmt == iAnsiFETC)
						{
							// Convert Ansi plain text to Unicode
							hUnicode = TextHGlobalAtoW(hGlobal);
							if (hUnicode)
								ptext = (LPTSTR)GlobalLock(hUnicode);
						}
						else
							ptext = (LPTSTR)GlobalLock(hGlobal);

						if (ptext)
							hresult = HGlobalToRange(dwFmt, hGlobal, ptext, prg, publdr);
						else
							hresult = E_OUTOFMEMORY;

						if (hUnicode)
						{
							// Free plain text buffer
							GlobalUnlock(hUnicode);
							GlobalFree(hUnicode);
						}
						else
							GlobalUnlock(hGlobal);
					}
					else								// hGlobal == NULL Try for bitmaps
					{
						hGlobal = ::GetClipboardData(CF_DIB);
						if (hGlobal)
							hresult =  DIBToRange(hGlobal, prg, publdr);
					}
					_ped->_pdp->Thaw();
					::CloseClipboard();
				}
				if (FAILED(hresult))
					_ped->Beep();
				return hresult;
			}
		}
	}

	// Paste an object uses the limit text calculation
	_fUseLimit = TRUE;

	//Call QueryAcceptData unless caller has specified otherwise
	if(!(dwFlags & PDOR_NOQUERY) && precall)
	{
		CLIPFORMAT cfReq = cf;
		HGLOBAL hmeta = NULL;

		if(rps)
			hmeta = (HGLOBAL)((rps->dwAspect == DVASPECT_ICON) ? rps->dwParam : NULL);

		// Ask callback if it likes the data object and cfReq.

		hresult = precall->QueryAcceptData(
			pdo,
			&cfReq,
			(dwFlags & PDOR_DROP) ? RECO_DROP : RECO_PASTE,
			TRUE,
			hmeta);

		if(hresult == DATA_S_SAMEFORMATETC)
		{
			// Allow callback to return DATA_S_SAMEFORMATETC if it only
			// wants cf as passed in - we don't really care because
			// any non-zero CLIPFORMAT causes us to only accept that format.
			hresult = S_OK;
		}

		if(hresult == S_OK || hresult == E_NOTIMPL)
		{
			// Callback either liked it or didn't implement the method.
			// It may have changed the format while it was at it.
			// Treat a change of cf to zero as acceptance of the original.
			// In any event, we will try to handle it.

			// If a specific CLIPFORMAT was originally requested and the
			// callback changed it, don't accept it.
			if(cfReq && cf && (cf != cfReq))
			{
				hresult = DV_E_FORMATETC;
				goto Exit;
			}

			// If a specific CLIPFORMAT was originally requested and the
			// callback either left it alone or changed it to zero,
			// make sure we use the original.  If no CLIPFORMAT was
			// originally requested, make sure we use what came back
			// from the callback.
			if(!cf)
				cf = cfReq;
		}
		else
		{
			// Some success other than S_OK && DATA_S_SAMEFORMATETC.
			// The callback has handled the paste.  OR some error
			// was returned.
			goto Exit;
		}
	}

	// Even if the RichEdit client wants CF_TEXT, if the data object
	// supports CF_UNICODETEXT, we should prefer it as long as we are
	// not in 1.0 or single-codepage modes.
	if(cf == CF_TEXT && !f10Mode && !_ped->_fSingleCodePage)
	{
		FORMATETC fetc = {CF_UNICODETEXT, NULL, 0, -1, TYMED_NULL};

		if(pdo->QueryGetData(&fetc) == S_OK)
			cf = CF_UNICODETEXT;
		else
		{
			// One more try - CDataTransferObj::QueryGetData is checking
			// the tymed format
			fetc.tymed = TYMED_HGLOBAL;
			if(pdo->QueryGetData(&fetc) == S_OK)
				cf = CF_UNICODETEXT;
		}
	}
	if(cf == CF_UNICODETEXT && _ped->_fSingleCodePage)
		cf = CF_TEXT;

	if (_ped->TxGetReadOnly())			// Should check for range protection
	{
		hresult = E_ACCESSDENIED;
		goto Exit;
	}

	// At this point we freeze the display
	fThawDisplay = TRUE;
	_ped->_pdp->Freeze();

	if( publdr )
	{
		publdr->StopGroupTyping();
		publdr->SetNameID(UID_PASTE);
	}

    for( i = 0; i < CFETC; i++, pfetc++ )
	{
		// Make sure the format is either 1.) a plain text format 
		// if we are in plain text mode or 2.) a rich text format
		// or 3.) matches the requested format.

		if( cf && cf != pfetc->cfFormat )
			continue;

		if( _ped->IsRich() || (g_rgDOI[i] & DOI_CANPASTEPLAIN) )
		{
			// Make sure format is available
			if( pdo->QueryGetData(pfetc) != NOERROR )
			    continue;
			
			if(i == iUnicodeFETC && _ped->_fSingleCodePage)
				continue;

			// If we have a format that uses an hGlobal get and lock it
			if (i == iRtfFETC  || i == iRtfAsTextFETC ||
				i == iAnsiFETC || i == iRtfNoObjs	  ||
				!f10Mode && (i == iUnicodeFETC || i == iRtfUtf8 || i == iRtfNCRforNonASCII))
			{
				if( pdo->GetData(pfetc, &medium) != NOERROR )
					continue;

                hGlobal = medium.hGlobal;
				ptext = (LPTSTR)GlobalLock(hGlobal);
				if( !ptext )
				{
					ReleaseStgMedium(&medium);

					hresult = E_OUTOFMEMORY;
					goto Exit;
				}

				// 1.0 COMPATBILITY HACK ALERT!  RichEdit 1.0 has a bit of
				// "error recovery" for parsing rtf files; if they aren't
				// valid rtf, it treats them as just plain text.
				// Unfortunately, apps like Exchange depend on this behavior,
				// i.e., they give RichEdit plain text data, but call it rich
				// text anyway.  Accordingly, we emulate 1.0 behavior here by
				// checking for an rtf signature.
				if ((i == iRtfFETC || i == iRtfNoObjs || i == iRtfUtf8) &&
					!IsRTF((char *)ptext, GlobalSize(hGlobal)))
				{
					i = iAnsiFETC;			// Not RTF, make it ANSI text
				}
			}			
			else if (f10Mode && (i == iUnicodeFETC || i == iRtfUtf8))
			{
				// This else handles the case where we want to keep searching
				// for a goood format.  i.e. Unicode in 10 Mode
				continue;
			}

			// Don't delete trail EOP in some cases
			prg->AdjustEndEOP(NONEWCHARS);
			
			// Found a format we want.
			bFormatFound = TRUE;

			switch(i)									
			{											
			case iRtfNoObjs:							
			case iRtfFETC:								
			case iRtfUtf8:								
			case iRtfNCRforNonASCII:								
				hresult = HGlobalToRange(i, hGlobal, ptext, prg, publdr);
				break;
	
			case iRtfAsTextFETC:
			case iAnsiFETC:								// ANSI plain text		
				hUnicode = TextHGlobalAtoW(hGlobal);
				ptext	 = (LPTSTR)GlobalLock(hUnicode);
				if(!ptext)
				{
					hresult = E_OUTOFMEMORY;			// Unless out of RAM,
					break;								//  fall thru to
				}										//  Unicode case
														
			case iUnicodeFETC:							// Unicode plain text
				// Ok to pass in NULL for hglobal since argument won't be used
				hresult = HGlobalToRange(i, NULL, ptext, prg, publdr);
				if(hUnicode)							// For iAnsiFETC case
				{
					GlobalUnlock(hUnicode);
					GlobalFree(hUnicode);
				}			
				break;

			case iObtDesc:	 // Object Descriptor
				continue;	 // To search for a good format.
				             // the object descriptor hints will be used
				             // when the format is found.

			case iEmbObj:	 // Embedded Object
			case iEmbSrc:	 // Embed Source
			case iLnkSrc:	 // Link Source
			case iMfPict:	 // Metafile
			case iDIB:		 // DIB
			case iBitmap:	 // Bitmap
			case iFilename:	 // Filename
				hresult = CreateOleObjFromDataObj(pdo, prg, rps, i, publdr);
				break;

			// COMPATIBILITY ISSUE (v-richa) iTxtObj is needed by Exchange and 
			// as a flag for Wordpad.  iRichEdit doesn't seem to be needed by 
			// anyone but might consider implementing as a flag.
			case iRichEdit:	 // RichEdit
			case iTxtObj:	 // Text with Objects
				break;
			default:
				// Ooops didn't find a format after all
				bFormatFound = FALSE;
				break;
			}
			_ped->_ClipboardFormat = bFormatFound ? i + 1 : 0;

			//If we used the hGlobal unlock it and free it.
			if(hGlobal)
			{
				GlobalUnlock(hGlobal);
				ReleaseStgMedium(&medium);
			}
			break;							//Break out of for loop
		}
	}

    // richedit 1.0 returned an error if an unsupported FORMATETC was
    // found.  This behaviour is expected by ccMail so it can handle the
    // format itself
	if (!bFormatFound && f10Mode)
	    hresult = DV_E_FORMATETC;

Exit:
	if (fThawDisplay)
		_ped->_pdp->Thaw();

	if(!pdoSave)							// Release data object
		pdo->Release();						//  used for clipboard

	return hresult;						
}	

/*
 *	CLightDTEngine::GetDropTarget (ppDropTarget)
 *
 *	@mfunc
 *		creates an OLE drop target
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote	The caller is responsible for AddRef'ing this object
 *				if appropriate.
 */
HRESULT CLightDTEngine::GetDropTarget(
	IDropTarget **ppDropTarget)		// @parm outparm for drop target
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::GetDropTarget");

	if(!_pdt)
	{
		_pdt = new CDropTarget(_ped);
		// the AddRef done by the constructor will be
		// undone by the destructor of this object
	}

	if(ppDropTarget)
		*ppDropTarget = _pdt;

	return _pdt ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	CLightDTEngine::StartDrag (psel, publdr)
 *
 *	@mfunc
 *		starts the main drag drop loop
 *
 */	
HRESULT CLightDTEngine::StartDrag(
	CTxtSelection *psel,		// @parm Selection to drag from
	IUndoBuilder *publdr)		// @parm undo builder to receive antievents
{
#ifndef NODRAGDROP
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::StartDrag");

	LONG			cch, cch1;
	LONG			cp1, cpMin, cpMost;
	DWORD			dwEffect = 0;
	HRESULT			hr;
	IDataObject *	pdo = NULL;
	IDropSource *	pds;
	IRichEditOleCallback * precall = _ped->GetRECallback();

	// If we're doing drag drop's, we should have our own drop target
	// It's possible that _pdt will be NULL at this point--some clients
	// will delay instantiation of our drop target until a drop target
	// in the parent window decides that ours is needed.  However, since
	// we need it just to initiate drag drop, go ahead and create one
	// here.

	if( _pdt == NULL )
	{
		hr = GetDropTarget(NULL);
		if(hr != NOERROR)
			return hr;
	}

	psel->CheckTableSelection(FALSE, TRUE, NULL, 0);

	if(precall)
	{
		CHARRANGE chrg;

		// give the callback a chance to give us its own IDataObject
		psel->GetRange(chrg.cpMin, chrg.cpMost);
		hr = precall->GetClipboardData(&chrg, RECO_COPY, &pdo);
	}
	else
	{
		// we need to build our own data object.
		hr = S_FALSE;
	}

	// If we didn't get an IDataObject from the callback, build our own
	if(hr != NOERROR || pdo == NULL)
	{										// Don't include trailing EOP
		psel->AdjustEndEOP(NONEWCHARS);		//  in some selection cases
		hr = RangeToDataObject(psel, SF_TEXT | SF_RTF, &pdo);
		if(hr != NOERROR)
			return hr;
	}

	cch = psel->GetRange(cpMin, cpMost);	// NB: prg is the selection
	cp1 = psel->GetCp();					// Save active end and signed
	cch1 = psel->GetCch();					//  length for Undo antievent
	CTxtRange rg(_ped, cpMost, cch);		// Use range copy to float over
											// mods made to backing store
	// The floating range that we just created on the stack needs to
	// think that it's protected, so it won't change size.
	rg.SetDragProtection(TRUE);

	pds = new CDropSource();
	if(pds == NULL)
	{
		pdo->Release();
		return E_OUTOFMEMORY;
	}

	// Cache some info with our own drop target
	_pdt->SetDragInfo(publdr, cpMin, cpMost);


	// Set allowable effects
	dwEffect = DROPEFFECT_COPY;
	if(!_ped->TxGetReadOnly())
		dwEffect |= DROPEFFECT_MOVE;
	
	// Let the client decide what it wants.
	if(precall)
		hr = precall->GetDragDropEffect(TRUE, 0, &dwEffect);

	if(!FAILED(hr) || hr == E_NOTIMPL)
	{
		// Start drag-drop operation
		psel->AddRef();					// Stabilize Selection around DoDragDrop
		hr = DoDragDrop(pdo, pds, dwEffect, &dwEffect);
		psel->Release();
	}

	// Clear drop target
	_pdt->SetDragInfo(NULL, -1, -1);

	// Handle 'move' operations	
	if( hr == DRAGDROP_S_DROP && (dwEffect & DROPEFFECT_MOVE) )
	{
		// We're going to delete the dragged range, so turn off protection.
		rg.SetDragProtection(FALSE);
		if( publdr )
		{
			LONG cpNext, cchNext;

			if(_ped->GetCallMgr()->GetChangeEvent() )
			{
				cpNext = cchNext = -1;
			}
			else
			{
				cpNext = rg.GetCpMin();
				cchNext = 0;
			}

			HandleSelectionAEInfo(_ped, publdr, cp1, cch1, cpNext, cchNext,
								  SELAE_FORCEREPLACE);
		}
		
		// Delete the data that was moved.  The selection will float
		// to the new correct location.
		rg.Delete(publdr, SELRR_IGNORE);

		// The update that happens implicitly by the update of the range may
		// have the effect of scrolling the window. This in turn may have the
		// effect in the drag drop case of scrolling non-inverted text into
		// the place where the selection was. The logic in the selection 
		// assumes that the selection is inverted and so reinverts it to turn
		// off the selection. Of course, it is obvious what happens in the
		// case where non-inverted text is scrolled into the selection area.
		// To simplify the processing here, we just say the whole window is
		// invalid so we are guaranteed to get the right painting for the
		// selection.
		// FUTURE: (ricksa) This solution does have the disadvantage of causing
		// a flash during drag and drop. We probably want to come back and
		// investigate a better way to update the screen.
		_ped->TxInvalidate();

		// Display is updated via notification from the range

		// Update the caret
		psel->Update(TRUE);
	}
	else if( hr == DRAGDROP_S_DROP && _ped->GetCallMgr()->GetChangeEvent() &&
		(dwEffect & DROPEFFECT_COPY) && publdr)
	{
		// if we copied to ourselves, we want to restore the selection to
		// the original drag origin on undo
		HandleSelectionAEInfo(_ped, publdr, cp1, cch1, -1, -1, 
				SELAE_FORCEREPLACE);
	}

	if(SUCCEEDED(hr))
		hr = NOERROR;

	pdo->Release();
	pds->Release();

	// we do this last since we may have re-used some 'paste' code which
	// will stomp the undo name to be UID_PASTE.
	if( publdr )
		publdr->SetNameID(UID_DRAGDROP);

	if(_ped->GetEventMask() & ENM_DRAGDROPDONE)
	{
		NMHDR	hdr;
		ZeroMemory(&hdr, sizeof(NMHDR));
		_ped->TxNotify(EN_DRAGDROPDONE, &hdr);
	}

	return hr;
#else
	return 0;
#endif // NODRAGDROP
}

/*
 *	CLightDTEngine::LoadFromEs (prg, lStreamFormat, pes, fTestLimit, publdr)
 *
 *	@mfunc
 *		Load data from the stream pes into the range prg according to the
 *		format lStreamFormat
 *
 *	@rdesc
 *		LONG -- count of characters read
 */
LONG CLightDTEngine::LoadFromEs(
	CTxtRange *	 prg,			// @parm Range to load into
	LONG		 lStreamFormat,	// @parm Stream format to use for loading
	EDITSTREAM * pes,			// @parm Edit stream to load from
	BOOL		 fTestLimit,	// @parm Whether to test text limit
	IUndoBuilder *publdr)		// @parm Undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::LoadFromEs");

#ifdef DEBUG
	// FUTURE: Currently freezing the display prior to loading text
	// is simply an optimization. This may become a requirement in the
	// future. If this does become a requirement then we'll want to
	// exit with an error.
	if( !_ped->_pdp->IsFrozen() )
	{
		TRACEWARNSZ("CLightDTEngine::LoadFromEs	display not frozen");
	}
#endif // DEBUG

	LONG		cch = 0;					// Default no chars read
	IAntiEvent *pae = NULL;

	if(publdr)
		publdr->StopGroupTyping();

	// Other components, such as the display and backing store, will
	// be able to make optimizations if they know that we are streaming
	// in text or RTF data.
	prg->CheckTableSelection(FALSE, TRUE, NULL, 0);
	if(lStreamFormat & SF_RTF)				// RTF case must precede
	{										//  TEXT case (see SF_x values)
		if(!_ped->IsRich())
			return 0;

		LONG cpMin, cpMost;

		// Here we do something a bit unusual for performance reasons.
		// Instead of letting the rtf reader generate its own undo actions,
		// we take care of it ourselves.  Instead of generating actions
		// for each little operation, we simply generate a "big" antievent
		// for the whole shebang

		// There is a subtlty w.r.t. to paragraph format runs.  By inserting
		// text with para formatting, it's possible that we will modify the
		// para formatting of the _current_ paragraph.  Thus, it's necessary
		// to remember what the formatting currently is for undo.  Note that
		// it may actually not be changed; but we go ahead and generate an
		// antievent anyways.  Note that we only need to do this if cpMin is
		// the middle of a paragraph
		
		CTxtPtr tp(prg->_rpTX);
		if(prg->GetCch() > 0)
			tp.Move(-prg->GetCch());
		
		if(publdr && !tp.IsAfterEOP())
		{
			tp.FindEOP(tomBackward);
			cpMin = tp.GetCp();
			tp.FindEOP(tomForward);
			cpMost = tp.GetCp();
			
			// We must be in rich text mode, so we must be able to always
			// find a paragraph.
			Assert(cpMost > cpMin);

			if (prg->_rpPF.IsValid())
			{
				CFormatRunPtr rpPF(prg->_rpPF);
				rpPF.Move(cpMin - prg->GetCp());
					
				pae = gAEDispenser.CreateReplaceFormattingAE(_ped, cpMin, rpPF, 
							cpMost - cpMin, GetParaFormatCache(), ParaFormat);
				if(pae)
					publdr->AddAntiEvent(pae);
			}

			// Also create the charformat antievent for the current paragraph
			// to preserve BiDi level. We cannot check fBiDi here since we may be running
			// on US platform inserting a BiDi rtf.
			if (prg->_rpCF.IsValid())
			{
				CFormatRunPtr rpCF(prg->_rpCF);
				rpCF.Move(cpMin - prg->GetCp());
				
				pae = gAEDispenser.CreateReplaceFormattingAE(_ped, cpMin, rpCF, 
							cpMost - cpMin, GetCharFormatCache(), CharFormat);
				if(pae)
					publdr->AddAntiEvent(pae);
			}
		} 

		// First, clear range
		LONG cchEOP = prg->DeleteWithTRDCheck(publdr, SELRR_REMEMBERRANGE, NULL,
											  RR_NO_LP_CHECK | RR_NO_CHECK_TABLE_SEL);
		if(prg->GetCch())
			return 0;							// Deletion suppressed, so
												//  can't insert text
		cpMin = prg->GetCp();
		_ped->SetStreaming(TRUE);
		CRTFRead rtfRead(prg, pes, lStreamFormat);

		cch	= rtfRead.ReadRtf();

		if(prg->_rpTX.IsAfterEOP() && (cchEOP ||// Inserted text ends with EOP
		    prg->_rpTX.GetChar() == CELL &&		// OK to delete EOP if we
			cch && !prg->_rpTX.IsAfterTRD(0)))	//  inserted one or if before
		{										//  CELL
			if(cchEOP)
			{
				Assert(prg->_rpTX.GetChar() == CR);
				prg->AdvanceCRLF(CSC_NORMAL, TRUE);
			}
			else
				prg->BackupCRLF(CSC_NORMAL, TRUE);

			prg->ReplaceRange(0, NULL, NULL, SELRR_REMEMBERRANGE);
		}
		cpMost = prg->GetCp();
		Assert(pes->dwError != 0 || cpMost >= cpMin);

		// If nothing changed, get rid of any antievents (like the formatting
		// one) that we may have "speculatively" added
		if(publdr && !_ped->GetCallMgr()->GetChangeEvent())
			publdr->Discard();

		if(publdr && cpMost > cpMin)
		{
			// If some text was added, create an antievent for
			// it and add it in.
			AssertSz(_ped->GetCallMgr()->GetChangeEvent(),
				"Something changed, but nobody set the change flag");

			pae = gAEDispenser.CreateReplaceRangeAE(_ped, cpMin, cpMost, 0, 
						NULL, NULL, NULL);

			HandleSelectionAEInfo(_ped, publdr, -1, -1, cpMost, 0, 
						SELAE_FORCEREPLACE);
			if(pae)
				publdr->AddAntiEvent(pae);
		}
	}
	else if(lStreamFormat & SF_TEXT)
	{
		_ped->SetStreaming(TRUE);
		cch = ReadPlainText(prg, pes, fTestLimit, publdr, lStreamFormat);
	}
	_ped->SetStreaming(FALSE);

	// Before updating the selection, try the auto-URL detect.  This makes
	// two cases better: 1. a long drag drop is now faster and 2. the
	// selection _iFormat will now be udpated correctly for cases of
	// copy/paste of a URL.

	if(_ped->GetDetectURL())
		_ped->GetDetectURL()->ScanAndUpdate(publdr);

	// The caret belongs in one of two places:
	//		1. if we loaded into a selection, at the end of the new text
	//		2. otherwise, we loaded an entire document, set it to cp 0
	//
	// ReadPlainText() and ReadRtf() set prg to an insertion point
	// at the end, so if we loaded a whole document, reset it.
	CTxtSelection *psel = _ped->GetSelNC();
	if(psel)
	{
		if(!(lStreamFormat & SFF_SELECTION))
		{
			psel->Set(0,0);
			psel->Update(FALSE);
		}
		psel->Update_iFormat(-1);
	}

	if (!fTestLimit)
	{
		// If we don't limit the text then we adjust the text limit
		// if we have exceeded it.
		_ped->TxSetMaxToMaxText();
	}
	return cch;
}

/*
 *	CLightDTEngine::SaveToEs (prg, lStreamFormat, pes)
 *
 *	@mfunc
 *		save data into the given stream
 *
 *	@rdesc
 *		LONG -- count of characters written
 */
LONG CLightDTEngine::SaveToEs(
	CTxtRange *	prg,			//@parm Range to drag from
	LONG		lStreamFormat,	//@parm Stream format to use for saving
	EDITSTREAM *pes )			//@parm Edit stream to save to
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::SaveToEs");

	LONG cch = 0;								// Default no chars written

	prg->AdjustCRLF(1);
	if(lStreamFormat & SF_RTF)					// Be sure to check for SF_RTF
	{											//  before checking for SF_TEXT
		if(prg->CheckTableSelection(FALSE, TRUE, NULL, 0))
			lStreamFormat |= SFF_WRITEXTRAPAR;	// Signal to write \par for CELL
		CRTFWrite rtfWrite( prg, pes, lStreamFormat );
	
		cch = rtfWrite.WriteRtf();
	}
	else if(lStreamFormat & (SF_TEXT | SF_TEXTIZED))
		cch = WritePlainText(prg, pes, lStreamFormat);

	else
	{
		Assert(FALSE);
	}
	return cch;
}

/*
 *	CLightDTEngine::UnicodePlainTextFromRange (prg)
 *
 *	@mfunc
 *		Fetch plain text from a range and put it in an hglobal
 *
 *	@rdesc
 *		an allocated HGLOBAL.
 *
 *	@devnote
 *		FUTURE: Export bullets as does Word for plain text
 */
HGLOBAL CLightDTEngine::UnicodePlainTextFromRange(
	CTxtRange *prg)				// @parm range to get text from
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::UnicodePlainTextFromRange");

	LONG	cpMin, cpMost;
	LONG	cch = prg->GetRange(cpMin, cpMost);
	LONG	cchT = 2*(cch + 1);					// Allocate 2* in  case all CRs

	HGLOBAL	hText = GlobalAlloc(GMEM_FIXED,	cchT*sizeof(WCHAR));
	if(!hText)
		return NULL;

	WCHAR *pText = (WCHAR *)GlobalLock(hText);
	if(!pText)
		return NULL;

	if(cch)
	{
		CRchTxtPtr rtp(*prg);
		rtp.SetCp(cpMin);
		cch = rtp.GetPlainText(cchT, pText, cpMost, FALSE, TRUE);
		AssertSz(cch <= cchT,
			"CLightDTEngine::UnicodePlainTextFromRange: got too much text");
	}
	*(pText + cch) = 0;
	
	GlobalUnlock(hText);

	HGLOBAL	hTemp = GlobalReAlloc(hText, 2*(cch + 1), GMEM_MOVEABLE);

	if(!hTemp)
		GlobalFree(hText);

	return hTemp;
}

/*
 *	CLightDTEngine::AnsiPlainTextFromRange (prg)
 *
 *	@mfunc
 *		Retrieve an ANSI copy of the text in the range prg
 *
 *	@rdesc
 *		HRESULT
 */
HGLOBAL CLightDTEngine::AnsiPlainTextFromRange(
	CTxtRange *prg)				// @parm range to get text from
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::AnsiPlainTextFromRange");

	HGLOBAL hUnicode;
	HGLOBAL hAnsi;

	// FUTURE (alexgo): if we implement the option to store text as 8-bit
	// chars, then we can make this routine more efficient

	hUnicode = UnicodePlainTextFromRange(prg);
	hAnsi = TextHGlobalWtoA(hUnicode);

	GlobalFree(hUnicode);
	return hAnsi;
}

/*
 *	CLightDTEngine::RtfFromRange (prg, lStreamFormat)
 *
 *	@mfunc
 *		Fetch RTF text from a range and put it in an hglobal
 *
 *	@rdesc
 *		an allocated HGLOBAL.  
 */
HGLOBAL CLightDTEngine::RtfFromRange(
	CTxtRange *	prg,			// @parm Range to get RTF from
	LONG 		lStreamFormat)	// @parm stream format to use for loading
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::RtfFromRange");

	WRITEHGLOBAL whg;
	EDITSTREAM	 es = {(DWORD_PTR)&whg, NOERROR, WriteHGlobal};
	DWORD		 cb	= 2*abs(prg->GetCch()) + 100;	// Rough estimate
 
	whg.cb			= cb;
	whg.hglobal		= GlobalAlloc(GMEM_FIXED, cb);
	if(!whg.hglobal)
		return NULL;		
	whg.cch			= 0;					// Nothing written yet
	SaveToEs(prg, lStreamFormat & ~SF_TEXT, &es);
	if(es.dwError)
	{
		GlobalFree(whg.hglobal);
		return NULL;
	}
	
	HGLOBAL	hTemp = GlobalReAlloc(whg.hglobal, whg.cch, GMEM_MOVEABLE);
	
	if (!hTemp)		
		GlobalFree(whg.hglobal);			// Fail ReAlloc... 

	return hTemp;
}


//
// PROTECTED METHODS
//

#define READSIZE 	4096 - 2
#define WRITESIZE	2048

/*
 *	CLightDTEngine::ReadPlainText (prg, pes, publdr, lStreamFormat)
 *
 *	@mfunc
 *		Replaces contents of the range prg with the data given in the edit
 *		stream pes. Handles multibyte sequences that overlap stream buffers.
 *
 *	@rdesc
 *		Count of bytes read (to be compatible with RichEdit 1.0)
 *
 *	@devnote
 *		prg is modified; at the return of the call, it will be a degenerate
 *		range at the end of the read in text.
 *
 *		Three kinds of multibyte/char sequences can overlap stream buffers:
 *		DBCS, UTF-8, and CRLF/CRCRLF combinations. DBCS and UTF-8 streams are
 *		converted by MultiByteToWideChar(), which cannot convert a lead byte
 *		(DBCS and UTF-8) that occurs at the end of the buffer, since the
 *		corresponding trail byte(s) will be in the next buffer.  Similarly,
 *		in RichEdit 2.0 mode, we convert CRLFs to CRs and CRCRLFs to blanks,
 *		so one or two CRs at the end of the buffer require knowledge of the
 *		following char to determine if they are part of a CRLF or CRCRLF.
 *
 *		To handle these overlapped buffer cases, we move the ambiguous chars
 *		to the start of the next buffer, rather than keeping them as part of
 *		the current buffer.  At the start of the buffer, the extra char(s)
 *		needed for translation follow immediately.
 */
LONG CLightDTEngine::ReadPlainText(
	CTxtRange *	  prg, 			// @parm range to read to
	EDITSTREAM *  pes,			// @parm edit stream to read from
	BOOL		  fTestLimit,	// @parm whether limit testing is needed
	IUndoBuilder *publdr,		// @parm undo builder to receive antievents
	LONG		  lStreamFormat)// @parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::ReadPlainText");

	CTxtEdit *ped = _ped;
	LONG	  cbRead;
	LONG 	  cbReadTotal = 0;	// No bytes read yet
	LONG	  cchConv;
	LONG	  cchMove = 0;
	LONG	  cCR = 0;			// Count of CRs from preceding buffer
	LONG	  cCRPrev = 0;		// Count used while calc'ing new cCR
	LONG	  cpMin;
	BOOL	  fContinue = TRUE;	// Keep reading so long as TRUE
	BYTE *	  pb;				// Byte ptr to szBuf or wszBuf
	CCallMgr *pCallMgr = ped->GetCallMgr();
	WCHAR *	  pch;				// Ptr to wszBuf
	UINT	  uCpg = GetStreamCodePage(lStreamFormat);
	CFreezeDisplay	fd(ped->_pdp);

	// Just put a big buffer on the stack.  Thankfully, we only
	// run on 32bit OS's.  4K is a good read size for NT file caching.
	char 	szBuf[READSIZE];
	WCHAR	wszBuf[READSIZE+2];	// Allow for moving end CRs to start

	// Empty the range
	prg->DeleteWithTRDCheck(publdr, SELRR_REMEMBERRANGE, &cchMove, 0);

	cpMin = prg->GetCp();							// Save initial cp for
													//  BreakRuns() at end
	pb = (IsUnicodeCP(uCpg)) ? (BYTE *)(wszBuf + 2)	// Setup Unicode or MBCS
						: (BYTE *)szBuf;
	LONG j = 0;										// Haven't read anything,
													//  so no lead byte left
	while(fContinue)								//  from previous read
	{
		LONG jPrev = j;								// Save byte(s) left over
		LONG cbSkip = 0;							//  from previous read

		pes->dwError = (*pes->pfnCallback)(			// Read next bufferful,
				pes->dwCookie, pb + j, 				//  bypassing any lead
				READSIZE - j, &cbRead);				//  bytes

		if(pes->dwError || !cbRead && !cCR)
			break;									// Error or done

		if(!cbReadTotal && cbRead >= 3 && W32->IsUTF8BOM(pb))
		{
			uCpg = CP_UTF8;
			cbSkip = 3;								// Bypass 3 bytes
		}
		// Adjust cbRead with previous leading byte(s)
		cbRead += j;
		j = 0;										
		
		cchConv = cbRead/2;							// Default Unicode cch
		if(uCpg == CP_UBE)							// Big Endian Unicode
		{
			WORD *pch = &wszBuf[2];

			for(LONG j = 0; j < cchConv; j++)		// Convert to little endian
				*pch++ = (*pch >> 8) + (*pch << 8); 
		}
		else if(uCpg != CP_ULE && cbRead)			// Multibyte of some kind
		{
			Assert(pb == (BYTE *)szBuf && !j);		// Just in case...

			// Check if last byte is a leading byte
			if(uCpg == CP_UTF8)
			{
				// Note: Unlike UTF-8, UTF-7 can be in the middle of a long
				// sequence, so it can't be converted effectively in chunks
				// and we don't handle it
				LONG cb = cbRead - 1;
				BYTE b;
				BYTE bLeadMax = 0xDF;

				// Find UTF-8 lead byte
				while((b = (BYTE)szBuf[cb - j]) >= 0x80)
				{
					j++;
					if(b >= 0xC0)					// Break on UTF-8 lead
					{								//  byte
						if(j > 1 && (b <= bLeadMax || b >= 0xF8))
							j = 0;					// Full UTF-8 char or
						break;						//  illegal sequence
					}
					if(j > 1)
					{
						if(j == 5)					// Illegal UTF-8
						{
							j = 0;
							break;
						}
						*(char *)&bLeadMax >>= 1;
					}
				}
			}
			else 
			{
				LONG temp = cbRead - 1; 

				// GetTrailBytesCount() can return 1 for some trail bytes
				// esp. for GBX.  So, we need to keep on checking until
				// we hit a non-lead byte character.  Then, based on
				// how many bytes we went back, we can determine if the
				// last byte is really a Lead byte.
				while (temp && GetTrailBytesCount((BYTE)szBuf[temp], uCpg))
					temp--;

				if(temp && ((cbRead-1-temp) & 1))
					j = 1;
			}

			// We don't want to pass the lead byte or partial UTF-8 to
			// MultiByteToWideChar() because it will return bad char.
		    cchConv = MBTWC(uCpg, 0, szBuf + cbSkip, cbRead - j - cbSkip,
							&wszBuf[2], READSIZE, NULL);

			for(LONG i = j; i; i--)					// Copy down partial
				szBuf[j - i] = szBuf[cbRead - i];	//  multibyte sequence
		}
		cbReadTotal += cbRead - j - jPrev;

		// Cleanse (CRLFs -> CRs, etc.), limit, and insert the data. Have
		// to handle CRLFs and CRCRLFs that overlap two successive buffers.
		Assert(cCR <= 2);
		pch = &wszBuf[2 - cCR];						// Include CRs from prev

		if(!ped->_pdp->IsMultiLine())				// Single-line control
		{
			Assert(!cCR);
		}
		else
		{								
			wszBuf[0] = wszBuf[1] = CR;				// Store CRs for cchCR > 0
			cCRPrev = cCR;							// Save prev cchCR
			cCR = 0;								// Default no CR this buf

			Assert(ARRAY_SIZE(wszBuf) >= cchConv + 2);

			// Need to +2 since we are moving data into wszBuf[2]
			if(cchConv && wszBuf[cchConv + 2 - 1] == CR)
			{										// There's at least one
				cCR++;								// Set it up for next buf
				if (cchConv > 1 &&					//  in case CR of CRLF
					wszBuf[cchConv + 2 - 2] == CR)	// Got 2nd CR; might be
				{									//  first CR of CRCRLF so
					cCR++;							//  setup for next buffer
				}
			}										
			cchConv += cCRPrev - cCR;				// Add in count from prev
		}											//  next
		Assert(!prg->GetCch());						// Range is IP
		prg->CleanseAndReplaceRange(cchConv, pch, fTestLimit, publdr, pch, NULL, RR_ITMZ_NONE);

		if(pCallMgr->GetMaxText() || pCallMgr->GetOutOfMemory())
		{
			// Out of memory or reached the max size of our text control.
			// In either case, return STG_E_MEDIUMFULL (for compatibility
			// with RichEdit 1.0)
			pes->dwError = (DWORD)STG_E_MEDIUMFULL;
			break;
		}
	}
	prg->ItemizeReplaceRange(prg->GetCp() - cpMin, cchMove, publdr, TRUE);

	return cbReadTotal;
}

/*
 *	CLightDTEngine::WritePlainText (prg, pes, lStreamFormat)
 *
 *	@mfunc
 *		Writes plain text from the range into the given edit stream
 *
 *	@rdesc
 *		Count of bytes written
 */
LONG CLightDTEngine::WritePlainText(
	CTxtRange *	prg,			// @parm range to write from
	EDITSTREAM *pes,			// @parm edit stream to write to
	LONG		lStreamFormat)	// @parm Stream format
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::WritePlainText");

	LONG		cbConverted;		// Bytes for output stream
	LONG		cbWrite;			// Incremental byte count
	LONG		cbWriteTotal = 0;	// No chars written yet
	LONG		cpMin, cpMost;
	LONG		cch = prg->GetRange(cpMin, cpMost);
	BOOL		fTextize = lStreamFormat & SF_TEXTIZED;
	LPBYTE		pb;					// Byte ptr to szBuf or wszBuf
	COleObject *pobj;				// Ptr to embedded object
	CRchTxtPtr	rtp(*prg);			// rtp to walk prg with
	UINT		uCpg = GetStreamCodePage(lStreamFormat);

	// DBCS has up to 2 times as many chars as WCHARs. UTF-8 has 3 BYTES for
	// all codes above 0x7ff. UTF-7 has even more due to shift in/out codes.
	// We don't support UTF-7, since can't use WCTMB with UTF-7 chunks

	char		szBuf[3*WRITESIZE];	// Factor of 2 works with DBCS, 3 with UTF-8
	WCHAR		wszBuf[WRITESIZE];

	pes->dwError = NOERROR;							// No error yet

	pb = IsUnicodeCP(uCpg) ? (BYTE *)wszBuf			// Setup Unicode or MBCS
						: (BYTE *)szBuf;

	LONG cchText = _ped->GetAdjustedTextLength();
	cpMost = min(cpMost, cchText);					// Don't write final CR
	rtp.SetCp(cpMin);
	while(rtp.GetCp() < cpMost)
	{
		if (fTextize && rtp.GetChar() == WCH_EMBEDDING)
		{
			Assert(_ped->GetObjectCount());

			pobj = _ped->GetObjectMgr()->GetObjectFromCp(rtp.GetCp());
			rtp.Move(1);							// Move past object
			if(pobj)
			{
				cbWriteTotal += pobj->WriteTextInfoToEditStream(pes, uCpg);
				continue;							// If no object at cp,
			}										//  just ignore char
		}											
		cch	= rtp.GetPlainText(WRITESIZE, wszBuf, cpMost, fTextize, TRUE);
		if(!cch)
			break;									// No more to do

		cbConverted = 2*cch;						// Default Unicode byte ct
		if(uCpg == CP_UBE)							// Big Endian Unicode
		{
			WORD *pch = &wszBuf[0];

			for(LONG j = 0; j < cch; j++)			// Convert to little endian
				*pch++ = (*pch >> 8) + (*pch << 8); 
		}
		else if(uCpg != CP_ULE)						// Multibyte of some kind
		{
			cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
								UN_CONVERT_WCH_EMBEDDING);

			// FUTURE: report some kind of error if default char used,
			// i.e., data lost in conversion
		
			// Did the conversion completely fail? As a fallback, we might try 
			// the system code page, or just plain ANSI...
			if (!cbConverted)
			{
				uCpg = CodePageFromCharRep(GetLocaleCharRep());
				cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
												UN_CONVERT_WCH_EMBEDDING);
			}
			if (!cbConverted)
			{
				uCpg = CP_ACP;
				cbConverted = MbcsFromUnicode(szBuf, 3*WRITESIZE, wszBuf, cch, uCpg,
												UN_CONVERT_WCH_EMBEDDING);
			}
		}

		pes->dwError = (*pes->pfnCallback)(pes->dwCookie, pb,
							cbConverted,  &cbWrite);
		if(!pes->dwError && cbConverted != cbWrite)	// Error or ran out of
			pes->dwError = (DWORD)STG_E_MEDIUMFULL;	//  target storage

		if(pes->dwError)
			break;
		cbWriteTotal += cbWrite;
	}

	AssertSz(rtp.GetCp() >= cpMost,
		"CLightDTEngine::WritePlainText: not all text written");

	return cbWriteTotal;
}

/* 
 *	CLightDTEngine::GetStreamCodePage (lStreamFormat)
 *
 *	@mfunc
 *		Returns code page given by lStreamFormat or CTxtEdit::_pDocInfo
 *
 *	@rdesc
 *		HRESULT
 */
LONG CLightDTEngine::GetStreamCodePage(
	LONG lStreamFormat)
{
	if(lStreamFormat & SF_UNICODE)
		return CP_ULE;

	if(lStreamFormat & SF_USECODEPAGE)
		return HIWORD(lStreamFormat);

	if (W32->IsFESystem())
		return GetACP();

	return CP_ACP;
}

/* 
 *	CLightDTEngine::CreateOleObjFromDataObj ( pdo, prg, rps, iformatetc, pubdlr )
 *
 *	@mfunc
 *		Creates an ole object based on the data object pdo, and
 *		pastes the object into the range prg. Any text that already
 *		existed in the range is replaced.
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CLightDTEngine::CreateOleObjFromDataObj(
	IDataObject *	pdo,		// @parm Data object from which to create
	CTxtRange *		prg,		// @parm Range in which to place
	REPASTESPECIAL *rps,		// @parm Special paste info
	INT				iformatetc,	// @parm Index in g_rgFETC 
	IUndoBuilder *	publdr)		// @parm Undo builder to receive antievents
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CLightDTEngine::CreateOleObjFromDataObj");

	HRESULT			hr = NOERROR;
	REOBJECT		reobj;
	SIZEL			sizel;
	FORMATETC		formatetc;
	DWORD			dwDrawAspect = 0;
	HGLOBAL			hMetaPict = NULL;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();
	LPOBJECTDESCRIPTOR lpod = NULL;
	STGMEDIUM		medObjDesc;
	BOOL			fStatic = (iformatetc == iMfPict || iformatetc == iDIB ||
							   iformatetc == iBitmap);
	BOOL			fFilename = (iformatetc == iFilename);
    DUAL_FORMATETC	tmpFormatEtc;

	if(!precall)
		return E_NOINTERFACE;

	ZeroMemory(&medObjDesc, sizeof(STGMEDIUM));
	ZeroMemory(&sizel, sizeof(SIZEL));
	ZeroMemory(&reobj, sizeof(REOBJECT));

	if(fStatic)
		dwDrawAspect = DVASPECT_CONTENT;

	if(fFilename)
		dwDrawAspect = DVASPECT_ICON;

	if(rps && !dwDrawAspect)
	{
		dwDrawAspect = rps->dwAspect;
		if(rps->dwAspect == DVASPECT_ICON)
			hMetaPict = (HGLOBAL)rps->dwParam;
	}

	// If no aspect was specified, pick up the object descriptor hints
	if(!dwDrawAspect)
	{
		// Define ObjectDescriptor data
		formatetc.cfFormat = cf_OBJECTDESCRIPTOR;
		formatetc.ptd = NULL;
		formatetc.dwAspect = DVASPECT_CONTENT;
		formatetc.lindex = -1;
		formatetc.tymed = TYMED_HGLOBAL;

		if(pdo->GetData(&formatetc, &medObjDesc) == NOERROR)
		{
			HANDLE	hGlobal = medObjDesc.hGlobal;

			lpod = (LPOBJECTDESCRIPTOR)GlobalLock(hGlobal);
			if(lpod)
			{
				dwDrawAspect = lpod->dwDrawAspect;
			}
			GlobalUnlock(hGlobal);
			ReleaseStgMedium(&medObjDesc);
		}
	}

	if(!dwDrawAspect)
		dwDrawAspect = DVASPECT_CONTENT;

	if(fStatic)
	{
		reobj.clsid	= ((iformatetc == iMfPict) ?
			CLSID_StaticMetafile : CLSID_StaticDib);
	}

	// COMPATIBILITY ISSUE: Compatibility Issue from Richedit 1.0 - Raid 16456: 
	// Don't call GetData(CF_EMBEDSOURCE)
	// on 32-bit Excel. Also clsidPictPub.
	//	if(iformatetc == iformatetcEmbSrc && (ObFIsExcel(&clsid) || 
	//		IsEqualCLSID(&clsid, &clsidPictPub)))
	//	else
	//		ObGetStgFromDataObj(pdataobj, &medEmbed, iformatetc);

	// Get storage for the object from the application
	hr = precall->GetNewStorage(&reobj.pstg);
	if(hr)
	{
		TRACEERRORSZ("GetNewStorage() failed.");
		goto err;
	}

	// Create an object site for the new object
	hr = _ped->GetClientSite(&reobj.polesite);
	if(!reobj.polesite)
	{
		TRACEERRORSZ("GetClientSite() failed.");
		goto err;
	}


	ZeroMemory(&tmpFormatEtc, sizeof(DUAL_FORMATETC));
	tmpFormatEtc.ptd = NULL;
	tmpFormatEtc.dwAspect = dwDrawAspect;
	tmpFormatEtc.lindex = -1;

	//Create the object
	if(fStatic)
	{
		hr = OleCreateStaticFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}
	else if(iformatetc == iLnkSrc || (_ped->Get10Mode() && iformatetc == iFilename))
	{
		hr = OleCreateLinkFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}
	else
	{
		hr = OleCreateFromData(pdo, IID_IOleObject, OLERENDER_DRAW,
				&tmpFormatEtc, NULL, reobj.pstg, (LPVOID*)&reobj.poleobj);
	}

	if(hr)
	{
		TRACEERRORSZ("Failure creating object.");
		goto err;
	}


	//Get the clsid of the object.
	if(!fStatic)
	{
		hr = reobj.poleobj->GetUserClassID(&reobj.clsid);
		if(hr)
		{
			TRACEERRORSZ("GetUserClassID() failed.");
			goto err;
		}
	}

	//Deal with iconic aspect if specified.
	if(hMetaPict)
	{
		BOOL fUpdate;

		hr = OleStdSwitchDisplayAspect(reobj.poleobj, &dwDrawAspect,
										DVASPECT_ICON, hMetaPict, FALSE,
										FALSE, NULL, &fUpdate);
		if(hr)
		{
			TRACEERRORSZ("OleStdSwitchDisplayAspect() failed.");
			goto err;
		}

		// If we successully changed the aspect, recompute the size.
		hr = reobj.poleobj->GetExtent(dwDrawAspect, &sizel);

		if(hr)
		{
			TRACEERRORSZ("GetExtent() failed.");
			goto err;
		}
	}

	// Try to retrieve the previous saved RichEdit site flags.
	if( ObjectReadSiteFlags(&reobj) != NOERROR )
	{
		// Set default for site flags
		reobj.dwFlags = REO_RESIZABLE;
	}

	// First, clear the range
	prg->Delete(publdr, SELRR_REMEMBERRANGE);

	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = prg->GetCp();
	reobj.dvaspect = dwDrawAspect;
	reobj.sizel = sizel;

	//COMPATIBILITY ISSUE: from Richedit 1.0 - don't Set the Extent,
	//instead Get the Extent below in ObFAddObjectSite
	//hr = reobj.poleobj->SetExtent(dwDrawAspect, &sizel);

	hr = reobj.poleobj->SetClientSite(reobj.polesite);
	if(hr)
	{
		TRACEERRORSZ("SetClientSite() failed.");
		goto err;
	}

	if(hr = _ped->InsertObject(&reobj))
	{
		TRACEERRORSZ("InsertObject() failed.");
	}

err:
	if(reobj.poleobj)
		reobj.poleobj->Release();

	if(reobj.polesite)
		reobj.polesite->Release();

	if(reobj.pstg)
		reobj.pstg->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\magellan.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module magellan.cpp -- Handle magellan mouse. |
 *	
 *	Magellan mouse can roll scroll and mButtonDown drag scroll.
 *
 *	History: <nl>
 *		Jon Matousek - 1996
 *		4/1/2000 KeithCu - Cleanup, coding convention, support for textflows
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */								 

#include "_common.h"

#if !defined(NOMAGELLAN)

#include "_edit.h"
#include "_disp.h"
#include "_magelln.h"

ASSERTDATA

const SHORT scrollCursors[] = 
{												// Cursor for various
	0,											//  directions.
	IDC_SCROLLNORTH,
	IDC_SCROLLSOUTH,
	IDC_SCROLLEAST,
	IDC_SCROLLNE,
	IDC_SCROLLSE,
	IDC_SCROLLWEST,
	IDC_SCROLLNW,
	IDC_SCROLLSW
};

const SHORT mDownBMPs[] =
{												// mButtonDown origin BMPs.
	0,
	IDB_1DVSCROL,
	IDB_1DHSCROL,
	IDB_2DSCROL
};

const SHORT noScrollCursors[] =
{
	0,
	IDC_NOSCROLLV,
	IDC_NOSCROLLH,
	IDC_NOSCROLLVH
};

//Convert the compass from logical to visual
const BYTE mapCursorTflowSW[] =
{
	0, 3, 6, 2, 5, 8, 1, 4, 7
};

const BYTE mapCursorTflowWN[] = 
{
	0, 2, 1, 6, 8, 7, 3, 5, 4
};

const BYTE mapCursorTflowNE[] = 
{
	0, 6, 3, 1, 7, 4, 2, 8, 5
};



BOOL CMagellan::ContinueMButtonScroll(CTxtEdit *ped, INT x, INT y)
{
	POINTUV ptuv;
	POINT ptxy = {x,y};

	ped->_pdp->PointuvFromPoint(ptuv, ptxy);

	return (_ptStart.u == ptuv.u && _ptStart.v == ptuv.v);
}

/*
 *	CMagellan::MagellanStartMButtonScroll
 *
 *	@mfunc
 *		Called when we get an mButtonDown message. Initiates tracking
 *		of the mouse which in turn will scroll at various speeds based
 *		on how far the user moves the mouse from the mDownPt.
 *
 *	@rdesc
 *		TRUE if the caller should capture the mouse.
 *
 */
BOOL CMagellan::MagellanStartMButtonScroll(CTxtEdit &ed, POINT ptxy)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanStartMButtonScroll");

	RECTUV	rc;
	BOOL	fCapture = FALSE;
	CDisplay *pdp = ed._pdp;
	POINTUV	pt;

	pdp->PointuvFromPoint(pt, ptxy);

	pdp->GetViewRect(rc);						// skip scroll bars, etc.
	if (PtInRect(&rc, pt) && !_fMButtonScroll)
	{
		fCapture				= TRUE;
		_ID_currMDownBMP		= 0;
		_fMButtonScroll			= TRUE;			// Now tracking...
		_ptStart				= pt;
		_fLastScrollWasRoll		= FALSE;		// Differentiate type.

		CheckInstallMagellanTrackTimer(ed);		// Fire up timer...
	}

	return fCapture;
}

/*
 *	CMagellan::MagellanEndMButtonScroll
 *
 *	@mfunc
 *		Finished tracking mButtonDown magellan scroll, finish up state.
 *
 */
VOID CMagellan::MagellanEndMButtonScroll(CTxtEdit &ed)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanEndMButtonScroll");

	CDisplay *pdp = ed._pdp;

	_fMButtonScroll = FALSE;
	CheckRemoveMagellanUpdaterTimer(ed);			// Remove timer...

	pdp->FinishSmoothVScroll();						// So smooth scroll stops.
	InvertMagellanDownBMP(pdp, FALSE, NULL);		// Turn it off.

	if (_MagellanMDownBMP)							// Release bitmap.
	{
		DeleteObject(_MagellanMDownBMP);
		_MagellanMDownBMP = NULL;
		_ID_currMDownBMP = 0;
	}
}

/*
 *	CMagellan::MagellanRollScroll
 *
 *	@mfunc
 *		Handle the Magellan WM_MOUSEROLLER message. This routine has global, internal
 *		state that allows the number of lines scrolled to increase if the user continues
 *		to roll the wheel in rapid succession.
 *
 */
VOID CMagellan::MagellanRollScroll (CDisplay *pdp, int direction, WORD cLines, 
			int speedNum, int speedDenom, BOOL fAdditive)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::MagellanRollScroll");

	static DWORD	lastFastRollTime;
	static int		lastDirection;
	static INT		cFastRolls;
	DWORD			tickCount = GetTickCount();

	if (!_fMButtonScroll)
	{
														// start/continue fast
		if (tickCount - lastFastRollTime <	FAST_ROLL_SCROLL_TRANSITION_TICKS			
			|| ((lastDirection ^ (direction < 0 ? -1 : 1)) == 0	// or, same sign
					&& _fLastScrollWasRoll				// and in slow.
					&& pdp->IsSmoothVScolling()))
		{
			cFastRolls++;
			if (cFastRolls > FASTER_ROLL2_COUNT)		// make faster.
				cLines <<= 1;
			else if (cFastRolls > FASTER_ROLL1_COUNT)	// make fast
				cLines += 1;
			speedNum = cLines;							// Cancel smooth
														// effect.
			lastFastRollTime = tickCount;
		}
		else
			cFastRolls = 0;

		pdp->SmoothVScroll(direction, cLines, speedNum, speedDenom, TRUE);

		_fLastScrollWasRoll = TRUE;
		lastDirection = (direction < 0) ? -1 : 1;
	}
}

/*
 *	CMagellan::CheckInstallMagellanTrackTimer
 *
 *	@mfunc
 *		Install a timing task that will allow TrackUpdateMagellanMButtonDown
 *		To be periodically called.
 *
 *	@devnote
 *		The CTxtEdit class handles all WM_TIMER dispatches, so there's glue there
 *		to call our magellan routine.
 *
 */
VOID CMagellan::CheckInstallMagellanTrackTimer (CTxtEdit &ed)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::CheckInstallMagellanTrackTimer");

	ed.TxSetTimer(RETID_MAGELLANTRACK, cmsecScrollInterval);
}

/*
 *	CMagellan::CheckRemoveMagellanUpdaterTimer
 *
 *	@mfunc
 *		Remove the timing task that dispatches to TrackUpdateMagellanMButtonDown.
 *
 */
VOID CMagellan::CheckRemoveMagellanUpdaterTimer (CTxtEdit &ed)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::CheckRemoveMagellanUpdaterTimer");

	ed.TxKillTimer(RETID_MAGELLANTRACK);
}

/*
 *	CMagellan::TrackUpdateMagellanMButtonDown
 *
 *	@mfunc
 *		After mButtonDown capture, a periodic WM_TIMER calls this from OnTxTimer(). The cursor
 *		is tracked to determine direction, speed, and in dead zone (not moving).
 *		Movement is dispacted to CDisplay. The cursor is set to the appropriate
 *		direction cusor, and the mButtonDown point BMP is drawn.
 */
VOID CMagellan::TrackUpdateMagellanMButtonDown (CTxtEdit &ed, POINT ptxy)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::TrackUpdateMagellanMButtonDown");

	RECTUV	deadZone;
	POINTUV	pt;

	LONG	inflate;

	SHORT	IDC_mScrollCursor = 0, IDC_mDeadScrollCursor = 0;

	BOOL	fDoUScroll = FALSE, fDoVScroll = FALSE;

	CDisplay *pdp = ed._pdp;
	pdp->PointuvFromPoint(pt, ptxy);

	Assert (_fMButtonScroll);

	deadZone.top = deadZone.bottom = _ptStart.v;
	deadZone.left = deadZone.right = _ptStart.u;
	inflate = pdp->LYtoDY(DEAD_ZONE_TWIPS);
	InflateRect(&deadZone, inflate, inflate);

	//
	//	Calculate direction to scroll and what cusor to display. 
	//
	//	By numbering a compass like the following, we can easily calc the index into
	//	the scrollCursors array to get the proper cursor:
	//
	//							North = 1
	//					NW = 7				NE = 4
	//				West = 6					East = 3
	//					SW = 8				SE = 5
	//							South = 2
	//
	if (pdp->IsVScrollEnabled())					// Can scroll vertically?
	{
		IDC_mDeadScrollCursor = 1;
		if (pt.v < deadZone.top || pt.v > deadZone.bottom)
		{
			fDoVScroll = TRUE;
			IDC_mScrollCursor = (pt.v < _ptStart.v) ? 1 : 2;
		}
	}

	// FUTURE (alexgo): allow magellan scrolling when no scrollbar?
	if(pdp->IsUScrollEnabled() && ed.TxGetScrollBars() & WS_HSCROLL)	// Can scroll horizontally?
	{
		IDC_mDeadScrollCursor |= 2;
		if (pt.u < deadZone.left || pt.u > deadZone.right)
		{
			fDoUScroll = TRUE;
			IDC_mScrollCursor += (pt.u < _ptStart.u) ? 6 : 3;
		}
	}

	//Convert cursors from logical to visual
	switch(pdp->GetTflow())
	{
	case tflowSW:
		IDC_mScrollCursor = mapCursorTflowSW[IDC_mScrollCursor];
		break;
	case tflowWN:
		IDC_mScrollCursor = mapCursorTflowWN[IDC_mScrollCursor];
		break;
	case tflowNE:
		IDC_mScrollCursor = mapCursorTflowNE[IDC_mScrollCursor];
		break;
	}

	if (IsUVerticalTflow(pdp->GetTflow()))
	{
		if (IDC_mDeadScrollCursor == 2)
			IDC_mDeadScrollCursor = 1;
		else if (IDC_mDeadScrollCursor == 1)
			IDC_mDeadScrollCursor = 2;
	}
		

	//Review (keithcu) A little goofy...
	IDC_mScrollCursor = scrollCursors[IDC_mScrollCursor];

	if (mDownBMPs[IDC_mDeadScrollCursor] != _ID_currMDownBMP)
	{
		if (_MagellanMDownBMP)						// Undraw old BMP.
		{
			InvertMagellanDownBMP(pdp, FALSE, NULL);
			DeleteObject (_MagellanMDownBMP);
			_MagellanMDownBMP = NULL;
		}
													// Draw new BMP.
		_ID_currMDownBMP = mDownBMPs[IDC_mDeadScrollCursor];
		_MagellanMDownBMP = LoadBitmap (hinstRE, MAKEINTRESOURCE (_ID_currMDownBMP));
		InvertMagellanDownBMP(pdp, TRUE, NULL);
	}

													// Moved out of dead zone?
	if (fDoVScroll || fDoUScroll)					//  time to scroll...
	{				
		RECTUV rcClient;
		POINTUV ptCenter, ptAuto;
		ed.TxGetClientRect(&rcClient);				// Get our client rect.
		LONG dupClient = rcClient.right - rcClient.left;
		LONG dvpClient = rcClient.bottom - rcClient.top;

		ptCenter.u = rcClient.left + (dupClient >> 1);
		ptCenter.v = rcClient.top + (dvpClient >> 1);

		LONG uInset = (dupClient >> 1) - 2;			// Get inset to center

													// Map origin to rcClient.
		LONG dup = pt.u - _ptStart.u;
		LONG dvp = pt.v - _ptStart.v;

		ptAuto.u = ptCenter.u + dup;
		ptAuto.v = ptCenter.v + dvp;

		// This formula is a bit magical, but here goes.  What
		// we want is the sub-linear part of an exponential function.
		// In other words, smallish distances should produce pixel
		// by pixel scrolling.
		//
		// So the formula we use is (x^2) / dvpClient, where x is dvpClient scaled
		// to be in units of dvpClient (i.e. 5yDiff/2).   The final 10* 
		// multiplier is to shift all the values leftward so we can
		// do this in integer arithmetic.
		LONG num = MulDiv(10 * 25 * dvp, dvp, dvpClient * 4);

		if(!num)
			num = 1;

		if (fDoVScroll)
			pdp->SmoothVScroll(_ptStart.v - pt.v, 0, num, 10 * dvpClient, FALSE);
												
		if (fDoUScroll)								// u direction scrolling?
		{										
			ptAuto.v = ptCenter.v;					// Prevent v dir scrolling.
													// Do u dir scroll.
			pdp->AutoScroll(ptAuto, uInset, 0);
		}

		// notify through the messagefilter that we scrolled
		if ((ed._dwEventMask & ENM_SCROLLEVENTS) && (fDoUScroll || fDoVScroll))
		{
			MSGFILTER msgfltr;
			ZeroMemory(&msgfltr, sizeof(MSGFILTER));

			if (fDoUScroll)
			{
				msgfltr.msg = WM_HSCROLL;
				msgfltr.wParam = (dup > 0 ? SB_LINERIGHT : SB_LINELEFT);
				ed._phost->TxNotify(EN_MSGFILTER, &msgfltr);			

			}
			if (fDoVScroll)
			{
				msgfltr.msg = WM_VSCROLL;
				msgfltr.wParam = (dvp > 0 ? SB_LINEDOWN : SB_LINEUP);
				ed._phost->TxNotify(EN_MSGFILTER, &msgfltr);			
			}

		}
	}
	else									// No scroll in dead zone.
	{												
		IDC_mScrollCursor = noScrollCursors[IDC_mDeadScrollCursor];
		pdp->FinishSmoothVScroll();			// Finish up last line.
	}

	ed._phost->TxSetCursor(IDC_mScrollCursor ? 
		LoadCursor(hinstRE, MAKEINTRESOURCE(IDC_mScrollCursor)) : ed._hcurArrow, FALSE);
}



/*
 *	BOOL CMagellan::InvertMagellanDownBMP
 *
 *	@mfunc
 *		Magellan mouse UI requires that the mouse down point draw
 *		and maintain a bitmap in order to help the user control scroll speed.
 *
 *	@devnote
 *		This routine is designed to be nested. It also handles WM_PAINT updates
 *		when the repaintDC is passed in. Because there is no support for multiple
 *		cursors in the operating system, all WM_PAINT and ScrollWindow redraws
 *		must temporarily turn off the BMP and then redraw it. This gives the
 *		BMAP a flicker.
 *
 *	@rdesc
 *		TRUE if the bitmap was previously drawn.
 */
BOOL CMagellan::InvertMagellanDownBMP(CDisplay *pdp, BOOL fTurnOn, HDC repaintDC)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellan::InvertMagellanDownBMP");

	BOOL	fOldState = _fMagellanBitMapOn;

	Assert (pdp);

	if (fOldState != fTurnOn)
	{
		if (_MagellanMDownBMP)
		{
			BITMAP	bm;
			HDC		hdcMem, screenDC;
			POINT	ptSize, ptOrg;

			screenDC = (repaintDC != NULL) ? repaintDC : pdp->GetDC();
			if (screenDC)
			{
				hdcMem = CreateCompatibleDC(screenDC);
				if (hdcMem)
				{
					SelectObject(hdcMem, _MagellanMDownBMP);

					if (W32->GetObject(_MagellanMDownBMP, sizeof(BITMAP), &bm))
					{
						ptSize.x = bm.bmWidth;
						ptSize.y = bm.bmHeight;
						DPtoLP(screenDC, &ptSize, 1);
						ptOrg.x = 0;
						ptOrg.y = 0;
						DPtoLP(hdcMem, &ptOrg, 1);

						POINT ptBitmap;
						pdp->PointFromPointuv(ptBitmap, _ptStart);
						BitBlt(screenDC,
							ptBitmap.x - (ptSize.x >> 1) - 1,
							ptBitmap.y - (ptSize.y >> 1) + 1,
							ptSize.x, ptSize.y,
							hdcMem, ptOrg.x, ptOrg.y, 0x00990066 /* NOTXOR */);
							
						_fMagellanBitMapOn = !fOldState;
					}
					DeleteDC(hdcMem);
				}
				if (repaintDC == NULL) 
					pdp->ReleaseDC(screenDC);
			}
		}
	}

	return fOldState;
}

////////////////////////// 	CMagellanBMPStateWrap class.

/*
 *	CMagellanBMPStateWrap:: CMagellanBMPStateWrap
 *
 *	@mfunc
 *		Handles the state of whether to redraw the Magellan BMP as well as
 *		repaints due to WM_PAINT.
 *
 *	@devnote
 *		This class is akin to smart pointer wrapper class idioms, in that
 *		no matter how a routine exits the correct state of whether the
 *		BMP is drawn will be maintined.
 */
CMagellanBMPStateWrap:: CMagellanBMPStateWrap(CTxtEdit &ed, HDC repaintDC)
	: _ed(ed), _repaintDC(repaintDC)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellanBMPStateWrap:: CMagellanBMPStateWrap");

	BOOL fRepaint;

	fRepaint = repaintDC != NULL && _ed.mouse._fMagellanBitMapOn != 0;
	_fMagellanState = fRepaint || _ed.mouse.InvertMagellanDownBMP(_ed._pdp, FALSE, NULL);
	_ed.mouse._fMagellanBitMapOn = FALSE;
}

CMagellanBMPStateWrap::~CMagellanBMPStateWrap()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CMagellanBMPStateWrap::~CMagellanBMPStateWrap");

	_ed.mouse.InvertMagellanDownBMP(_ed._pdp, _fMagellanState, _repaintDC);
}

#endif // !defined(NOMAGELLAN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\measure.cpp ===
/*
 *	@doc
 *
 *	@module - MEASURE.CPP
 *	
 *		CMeasurer class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini, Murray Sargent, Rick Sailor
 *
 *		History: <nl>
 *		KeithCu: Fixed zoom, restructured WYSIWYG, performance/cleanup
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_measure.h"
#include "_font.h"
#include "_disp.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_layout.h"
#include "_uspi.h"

ASSERTDATA

void CMeasurer::Init(const CDisplay *pdp)
{
	CTxtEdit *	ped = GetPed();

	_pdp = pdp;
	_pddReference = pdp;
	_pccs = NULL;
	_pPF = NULL;
	_plo = NULL;
	_dxBorderWidths = 0;
	_chPassword = ped->TxGetPasswordChar();
	_wNumber = 0;
	_cchLine = 0;
	_ihyphPrev = 0;
	_fRenderer = FALSE;
	_fGlyphing = _fFallback = _fTarget = FALSE;
	_fMeasure = FALSE;

	_dvpWrapLeftRemaining = _dvpWrapRightRemaining = -1;

	if(pdp->GetWordWrap())
	{
		const CDevDesc *pddTarget = pdp->GetTargetDev();
		if(pddTarget)
			_pddReference = pddTarget;
	}

	_dvpInch = pdp->GetDypInch();
	_dupInch = pdp->GetDxpInch();

	if (pdp->IsMain())
	{
		_dvpInch = MulDiv(_dvpInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
		_dupInch = MulDiv(_dupInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
	}
	if (pdp->SameDevice(_pddReference))
	{
		_dvrInch = _dvpInch;
		_durInch = _dupInch;
	}
	else
	{
		_dvrInch = _pddReference->GetDypInch();
		_durInch = _pddReference->GetDxpInch();
	}

	//Set _dulLayout by default to be width for measuring;
	//In the table scenario, it will be set elsewhere.
	if(!_pdp->GetWordWrap())
		_dulLayout = duMax;
	else if (_pdp->GetDulForTargetWrap())
		_dulLayout = _pdp->GetDulForTargetWrap();
	else
		_dulLayout = DUtoLU(_pdp->GetDupView());
}

CMeasurer::CMeasurer (const CDisplay* const pdp) : CRchTxtPtr (pdp->GetPed())	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::CMeasurer");
	Init(pdp);
}

CMeasurer::CMeasurer (const CDisplay* const pdp, const CRchTxtPtr &tp) : CRchTxtPtr (tp)	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::CMeasurer");
	Init(pdp);
}

CMeasurer::~CMeasurer()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::~CMeasurer");

	if(_pccs)
		_pccs->Release();
}

/*
 *	CMeasurer::SetGlyphing(fGlyphing)
 *
 *	@mfunc
 *		A state flag inside the measurer to record whether or not you
 *		are in the process of doing glyphing. If we are in a situation
 *		where the _pddReference and the _pdp have different DCs, then we
 *		need to throw away the pccs.
 */
void CMeasurer::SetGlyphing(
	BOOL fGlyphing)		//@parm Currently doing glyphing
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::SetGlyphing");
	Assert(fGlyphing == TRUE || fGlyphing == FALSE);

	if (fGlyphing != _fGlyphing)
	{
		if (_pddReference->_hdc != _pdp->_hdc)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = NULL;
		}
		_fGlyphing = fGlyphing;
	}
}

/*
 *	CMeasurer::SetUseTargetDevice(fUseTargetDevice)
 *
 *	@mfunc
 *		Sets whether you want to use the target device or not
 *		for getting metrics
 *		FUTURE (keithcu) Make this a parameter
 */
void CMeasurer::SetUseTargetDevice(
	BOOL fUseTargetDevice)		//@parm Use target device metrics?
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::SetUseTargetDevice");
	Assert(fUseTargetDevice == TRUE || fUseTargetDevice == FALSE);

	if (fUseTargetDevice != _fTarget)
	{
		if (_dvpInch != _dvrInch || _dupInch != _durInch)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = NULL;
		}
		_fTarget = fUseTargetDevice;
	}
}

/*
 *	CMeasurer::NewLine (fFirstInPara)
 *
 *	@mfunc
 *		Initialize this measurer at the start of a new line
 */
void CMeasurer::NewLine(
	BOOL fFirstInPara)		//@parm Flag for setting up _fFirstInPara
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::NewLine");

	_li.Init();							// Zero all members
	if(fFirstInPara)
		_li._fFirstInPara = TRUE;		// Need to know if first in para
	_cchLine = 0;
}

/*
 *	CMeasurer::NewLine(&li)
 *
 *	@mfunc
 *		Initialize this measurer at the start of a given line
 */
void CMeasurer::NewLine(
	const CLine &li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::NewLine");

	_li				= li;
	_li._cch		= 0;
	_li._dup		= 0;

	// Can't calculate upStart till we get an HDC
	_li._upStart	= 0;
	_wNumber	= _li._bNumber;
	_cchLine = li._cch;
}

/*
 *	CMeasurer::MeasureText (cch)
 *
 *	@mfunc
 *		Measure a stretch of text from current running position.
 *
 *		If the user requests us to measure n characters, we measure n + 1.
 *		and then subtract off the width of the last character. This gives
 *		us proper value in _dupAddLast.

 *		REVIEW (keithcu) This looks ugly. Think about it some more.
 *
 *	@rdesc
 *		width of text (in device units), < 0 if failed
 */
LONG CMeasurer::MeasureText(
	LONG cch)		//@parm Number of characters to measure
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureText");

	if(Measure(duMax, min(cch + 1, _cchLine), 0) == MRET_FAILED)
		return -1;

	if (cch < _cchLine)
	{
		_li._dup -= _dupAddLast;
		_li._cch--;
	}

	return _li._dup;
}

/*
 *	CMeasurer::MeasureLine (dulMax, uiFlags, pliTarget)
 *
 *	@mfunc
 *		Measure a line of text from current cp and determine line break.
 *		On return *this contains line metrics for _pddReference device.
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL CMeasurer::MeasureLine(
	UINT uiFlags,  		//@parm Flags controlling the process (see Measure())
	CLine *pliTarget)	//@parm Returns target-device line metrics (optional)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLine");

	// This state must be preserved across the two possible line width
	// calculations so we save it here.
	BYTE bNumberSave = _li._bNumber;

	const CDevDesc *pddTarget = NULL;

	if(_pdp->GetWordWrap())
	{
		// Target devices are only interesting if word wrap is on because the 
		// only really interesting thing a target device can tell us is where
		// the word breaks will occur.
		pddTarget = _pdp->GetTargetDev();
		if(pddTarget)
			SetUseTargetDevice(TRUE);
	}

	// Compute line break
	LONG lRet = Measure(-1, -1, uiFlags);

	// Stop here if failed
	if(lRet == MRET_FAILED)
		return FALSE;

	// Return target metrics if requested
	if(pliTarget)
		*pliTarget = _li;

	SetUseTargetDevice(FALSE);

	// Recompute to get metrics on rendering device
	if(pddTarget || lRet == MRET_NOWIDTH)
	{
		long cch = _li._cch;
		Move(-cch);				// move back to BOL
		NewLine(uiFlags & MEASURE_FIRSTINPARA);

		// Restore the line number 
		_li._bNumber = bNumberSave;
	
		lRet = Measure(duMax, cch, uiFlags);
		if(lRet)
		{
			Assert(lRet != MRET_NOWIDTH);
			return FALSE;
		}
	}
	
	// Now that we know the line width, compute line shift due
	// to alignment, and add it to the left position 
	_li._upStart += MeasureLineShift();

	return TRUE;
}

/*
 *	CMeasurer::RecalcLineHeight (pccs, pCF)
 *
 *	@mfunc
 *		Reset height of line we are measuring if new run of text is taller
 *		than current maximum in line.
 */
void CMeasurer::RecalcLineHeight(
	CCcs *pccs,
	const CCharFormat * const pCF)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::RecalcLineHeight");

	// Compute line height
	LONG vpOffset, vpAdjust;
	pccs->GetOffset(pCF, _fTarget ? _dvrInch : _dvpInch, &vpOffset, &vpAdjust);

	if (GetPF()->_bLineSpacingRule == tomLineSpaceExactly)
		vpOffset = 0;

	LONG vpHeight = pccs->_yHeight;
	LONG vpDescent = pccs->_yDescent;

	SHORT	yFEAdjust = pccs->AdjustFEHeight(FAdjustFELineHt());
	
	if (yFEAdjust)
	{
		vpHeight += (yFEAdjust << 1);
		vpDescent += yFEAdjust;
	}

	LONG vpAscent = vpHeight - vpDescent;

	LONG vpAboveBase = max(vpAscent,  vpAscent + vpOffset);
	LONG vpBelowBase = max(vpDescent, vpDescent - vpOffset);

	_li._dvpHeight  = (SHORT)(max(vpAboveBase, _li._dvpHeight - _li._dvpDescent) +
					   max(vpBelowBase, _li._dvpDescent));
	_li._dvpDescent = (SHORT)max(vpBelowBase, _li._dvpDescent);
}

/*
 *	CMeasurer::Measure (dulMax, cchMax, uiFlags)
 *
 *	@mfunc
 *		Measure given amount of text, start at current running position
 *		and storing # chars measured in _cch. 
 *		Can optionally determine line break based on a dulMax and 
 *		break out at that point.
 *
 *	@rdesc
 *		0 success
 *		MRET_FAILED	 if failed 
 *		MRET_NOWIDTH if second pass is needed to compute correct width
 *
 *	@devnote
 *		The uiFlags parameter has the following meanings:
 *			MEASURE_FIRSTINPARA			this is first line of paragraph
 *			MEASURE_BREAKATWORD			break out on a word break
 *			MEASURE_BREAKBEFOREWIDTH	break before dulMax
 *
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
LONG CMeasurer::Measure(
	LONG dulMax,			//@parm Max width of line in logical units (-1 uses CDisplay width)
	LONG cchMax,			//@parm Max chars to process (-1 if no limit)
	UINT uiFlags)			//@parm Flags controlling the process (see above)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::Measure");

	LONG		cch;				// cchChunk count down
	LONG		cchChunk;			// cch of cst-format contiguous run
	LONG		cchNonWhite;		// cch of last nonwhite char in line
	LONG		cchText = GetTextLength();
	WCHAR		ch;					// Temporary char
	BOOL		fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
	BOOL        fLastChObj = FALSE;
	LONG		lRet = 0;
	const WCHAR*pch;
	CTxtEdit *	ped = GetPed();
	COleObject *pobj;
	LONG		dupMax;
	LONG		uAdd = 0;			// Character width
	LONG		dupSoftHyphen = 0;	// Most recent soft hyphen width
	LONG		dupNonWhite;		// dup for last nonwhite char in line

	// This variable is used to keep track of whether there is a height change
	// so that we know whether we need to recalc the line in certain line break cases.
	BOOL		fHeightChange = FALSE;

	const INT	MAX_SAVED_WIDTHS = 31;	// power of 2 - 1
	INT			i, index, iSavedWidths = 0;
	struct {
		SHORT	width;
		SHORT	vpHeight;
		SHORT	vpDescent;
	} savedWidths[MAX_SAVED_WIDTHS+1];

	_pPF = GetPF();							// Be sure current CParaFormat
											// ptr is up to date
	Assert(_li._cch == 0);

	// Init fliFirstInPara flag for new line
	if(fFirstInPara)
	{
		_li._fFirstInPara = TRUE;

		if(IsInOutlineView() && IsHeadingStyle(_pPF->_sStyle))
			_li._dvpHeight = (short)max(_li._dvpHeight, BITMAP_HEIGHT_HEADING + 1);
	}

	AssertSz(!_pPF->IsListNumbered() && !_wNumber ||
			 (uiFlags & MEASURE_BREAKBEFOREWIDTH) || !_pdp->IsMultiLine() ||
			 _wNumber > 20 || _wNumber == (i = GetParaNumber()),
		"CMeasurer::Measure: incorrect list number");

	_li._upStart = MeasureLeftIndent();		// Set left indent

	// Compute width to break out at
	if(dulMax < 0)
		dupMax = LUtoDU(_dulLayout);
	else if (dulMax != duMax)
		dupMax = LUtoDU(dulMax);
	else
		dupMax = duMax;

	//If we are told to measure a fixed width (as in CchFromUp) then ignore 
	//affect of left and right indent.
	if (dulMax < 0)
	{
		LONG uCaretT = (_pdp->IsMain() && !GetPed()->TxGetReadOnly()) ? 
							ped->GetCaretWidth() : 0;
		dupMax -= (MeasureRightIndent() + _li._upStart + uCaretT);
	}

	dupMax = max(dupMax, 0);

	// Compute max count of characters to process
	cch = cchText - GetCp();
	if(cchMax < 0 || cchMax > cch)
		cchMax = cch;

	cchNonWhite		= _li._cch;						// Default nonwhite parms
	dupNonWhite	= _li._dup;

	for( ; cchMax > 0;							// Measure up to cchMax
		cchMax -= cchChunk, Move(cchChunk))		//  chars
	{
		pch = GetPch(cch);
		cch = min(cch, cchMax);					// Compute constant-format
		cchChunk = GetCchLeftRunCF();
		cch = min(cch, cchChunk);				// Counter for next while
		cchChunk = cch;							// Save chunk size

		const CCharFormat *pCF = GetCF();

		DWORD dwEffects = pCF->_dwEffects;

		if(dwEffects & CFE_HIDDEN)				// Ignore hidden text
		{
			uAdd = 0;
			_li._cch += cchChunk;
			continue;
		}

		if(!Check_pccs())						// Be sure _pccs is current
			return MRET_FAILED;

		// Adjust line height for new format run
		if(cch > 0 && *pch && (IsRich() || ped->HasObjects()))
		{
			// Note: the EOP only contributes to the height calculation for the
			// line if there are no non-white space characters on the line or 
			// the paragraph is a bullet paragraph. The bullet paragraph 
			// contribution to the line height is done in AdjustLineHeight.

			// REVIEW (Victork) 
			// Another, similar topic is height of spaces.
			// They don't (normally) influence line height in LS, 
			// they do in CMeasurer::Measure code. 
			// Proposed ways to solve it:
			//		- have fSpacesOnly flag in run
			//		- move current (line height) logic down after next character-scanning loop


			if(!cchNonWhite || *pch != CR && *pch != LF)
			{
				// Determine if the current run is the tallest text on this
				// line and if so, increase the height of the line.
				LONG vpHeightOld = _li._dvpHeight;
				RecalcLineHeight(_pccs, pCF);

				// Test for a change in line height. This only happens when
				// this is not the first character in the line and (surprise)
				// the height changes.
				if (vpHeightOld && vpHeightOld != _li._dvpHeight)
					fHeightChange = TRUE;
			}
		}

		while(cch > 0)
		{											// Process next char
			uAdd = 0;								// Default zero width
			ch = *pch;
			if(_chPassword && !IN_RANGE(LF, ch, CR))
				ch = _chPassword;

			if(dwEffects & CFE_ALLCAPS)
				CharUpperBuff(&ch, 1);

			if(ch == WCH_EMBEDDING)
			{
				_li._fHasSpecialChars = TRUE;
				pobj = GetObjectFromCp(GetCp() + cchChunk - cch);
				if(pobj)
				{
					LONG vpAscent, vpDescent;
					pobj->MeasureObj(_fTarget ? _dvrInch : _dvpInch, 
									 _fTarget ? _durInch : _dupInch,
									 uAdd, vpAscent, vpDescent, _li._dvpDescent, GetTflow());

					// Only update height for line if the object is going
					// to be on this line.
					if(!_li._cch || _li._dup + uAdd <= dupMax)
					{
						if (vpAscent > _li._dvpHeight - _li._dvpDescent)
							_li._dvpHeight = vpAscent + _li._dvpDescent;
					}
				}
				if(_li._dup + uAdd > dupMax)
					fLastChObj = TRUE;
			}
			// The following if succeeds if ch isn't a CELL, BS, TAB, LF,
			// VT, FF, or CR
			else if(!IN_RANGE(CELL, ch, CR))		// Not TAB or EOP
			{
				// Get char width
				if (!_pccs->Include(ch, uAdd))
				{
					AssertSz(FALSE, "CMeasurer::Measure char not in font");
					return MRET_FAILED;
				}
				if(IN_RANGE(NBSPACE, ch, EURO))		// Rules out ASCII, CJK
				{
					switch(ch)						//  char for NBSPACE &
					{								//  special hyphens
					case EURO:
					case NBHYPHEN:
					case SOFTHYPHEN:
					case NBSPACE:
					case EMSPACE:
					case ENSPACE:
						_li._fHasSpecialChars = TRUE;

						if (ch == SOFTHYPHEN && (_li._dup + uAdd < dupMax || !_li._cch))
						{
							dupSoftHyphen = uAdd;	// Save soft hyphen width
							uAdd = 0;				// Use 0 unless at EOL
						}
						break;
					}
				}
				else if(_chPassword && IN_RANGE(0xDC00, *pch, 0xDFFF))
					uAdd = 0;
			}

			else if(ch == TAB)
			{
				_li._fHasSpecialChars = TRUE;
				uAdd = MeasureTab(ch);
			}
			else if(ch == FF && ped->Get10Mode())	// RichEdit 1.0 treats
				_pccs->Include(ch, uAdd);			//  FFs as normal chars
			else									// Done with line
				goto eop;							// Go process EOP chars

			index = iSavedWidths++ & MAX_SAVED_WIDTHS;
			savedWidths[index].width		 = (SHORT)uAdd;
			savedWidths[index].vpHeight		 = _li._dvpHeight;
			savedWidths[index].vpDescent	 = _li._dvpDescent;
			_li._dup += uAdd;

			if(_li._dup > dupMax &&
				(uiFlags & MEASURE_BREAKBEFOREWIDTH || _li._cch > 0))
				goto overflow;

			_li._cch++;
			pch++;
			cch--;
			if(ch != ' ')							// If not whitespace char,
			{
				cchNonWhite	= _li._cch;				//  update nonwhitespace
				dupNonWhite	= _li._dup;				//  count and width
			}
		}											// while(cch > 0)
	}												// for(;cchMax > 0;...)
	goto eol;										// All text exhausted 


// End Of Paragraph	char encountered (CR, LF, VT, or FF, but mostly CR)
eop:
	Move(cchChunk - cch);					// Position tp at EOP
	cch = AdvanceCRLF();					// Bypass possibly multibyte EOP
	_li._cchEOP = (BYTE)cch;				// Store EOP cch
	_li._cch   += cch;						// Increment line count
	if(ch == CR || ped->fUseCRLF() && ch == LF || ch == CELL)
		_li._fHasEOP = TRUE;
	
	AssertSz(ped->fUseCRLF() || cch == 1,
		"CMeasurer::Measure: EOP isn't a single char");
	AssertSz(_pdp->IsMultiLine() || GetCp() == cchText,
		"CMeasurer::Measure: EOP in single-line control");

eol:										// End of current line
	if(uiFlags & MEASURE_BREAKATWORD)		// Compute count of whitespace
		_li._dup = dupNonWhite;				//  chars at EOL

	goto done;

overflow:									// Went past max width for line
	_li._dup -= uAdd;
	--iSavedWidths;
	Move(cchChunk - cch);					// Position *this at overflow
											//  position
	if(uiFlags & MEASURE_BREAKATWORD)		// If required, adjust break on
	{										//  word boundary
		// We should not have the EOP flag set here.  The case to watch out
		// for is when we reuse a line that used to have an EOP.  It is the
		// responsibility of the measurer to clear this flag as appropriate.
	
		Assert(_li._cchEOP == 0);
		_li._cchEOP = 0;					// Just in case

		if(ch == TAB)
		{
			// If the last character measured is a tab,	leave it on the
			// next line to allow tabbing off the end of line as in Word
			goto done;
		}

		LONG cpStop = GetCp();					// Remember current cp

		cch = -FindWordBreak(WB_LEFTBREAK, _li._cch+1);

		if(cch == 0 && fLastChObj)				// If preceding char is an
			goto done;							//  object,	put current char
												//  on next line
		Assert(cch >= 0);
		if(cch + 1 < _li._cch)					// Break char not at BOL
		{
			ch = _rpTX.GetPrevChar();
			if (ch == TAB)						// If break char is a TAB,
			{									//  put it on the next line
				cch++;							//  as in Word
				Move(-1);					
			}
			else if(ch == SOFTHYPHEN)
				_li._dup += dupSoftHyphen;
			_li._cch -= cch;
		}
		else if(cch == _li._cch && cch > 1 &&
			_rpTX.GetChar() == ' ')				// Blanks all the way back to
		{										//  BOL. Bypass first blank
			Move(1);
			cch--;
			_li._cch = 1;
		}
		else									// Advance forward to end of
			SetCp(cpStop);						//  measurement

		Assert(_li._cch > 0);

		// Now search at start of word to figure how many white chars at EOL
		LONG cchWhite = 0;
		if(GetCp() < cchText)
		{
			pch = GetPch(cch);
			cch = 0;

			if(ped->TxWordBreakProc((WCHAR *)pch, 0, sizeof(WCHAR), WB_ISDELIMITER, GetCp()))
			{
				cch = FindWordBreak(WB_RIGHT);
				Assert(cch >= 0);
			}

			cchWhite = cch;
			_li._cch += cch;

			ch = GetChar();
			if(IN_RANGE(CELL, ch, CR) && !IN_RANGE(8, ch, TAB))	// skip *only* 1 EOP -jOn
			{
				if(ch == CR || ch == CELL)
					_li._fHasEOP = TRUE;
				_li._cchEOP = (BYTE)AdvanceCRLF();
				_li._cch += _li._cchEOP;
				goto done;
			}
		}

		i = cpStop - GetCp();
		if(i)
		{
			if(i > 0)
				i += cchWhite;
			if(i > 0 && i < iSavedWidths && i < MAX_SAVED_WIDTHS)
			{
				while (i-- > 0)
				{
					iSavedWidths = (iSavedWidths - 1) & MAX_SAVED_WIDTHS;
					_li._dup -= savedWidths[iSavedWidths].width;
				}
				iSavedWidths = (iSavedWidths - 1) & MAX_SAVED_WIDTHS;
				_li._dvpHeight	   = savedWidths[iSavedWidths].vpHeight;
				_li._dvpDescent	   = savedWidths[iSavedWidths].vpDescent;
			}
			else
			{
				// Need to recompute width from scratch.
				lRet = MRET_NOWIDTH;
			}
		}
		else
		{
			// i == 0 means that we are breaking on the first letter in a word.
			// Therefore, we want to set the width to the total non-white space
			// calculated so far because that does not include the size of the
			// character that caused the break nor any of the white space 
			// preceeding the character that caused the break.
			if(!fHeightChange)
				_li._dup = dupNonWhite;
			else
			{
				// Need to recompute from scratch so that we can get the 
				// correct height for the control
				lRet = MRET_NOWIDTH;
			}
		}
	}

done:
	_dupAddLast = uAdd;
	if(!_li._dvpHeight)						// If no height yet, use
		CheckLineHeight();					//  default height

	AdjustLineHeight();
	return lRet;
}

/*
 *	CMeasurer::UpdateWrapState(dvpLine, dvpDescent, fLeft)
 *
 *	@mfunc
 *		After formatting a line, update the current state of wrapped objects
 */
void CMeasurer::UpdateWrapState(
	USHORT &dvpLine, 
	USHORT &dvpDescent, 
	BOOL	fLeft)
{
	if (fLeft && _li._cObjectWrapLeft || !fLeft && _li._cObjectWrapRight)
	{
		COleObject *pobj = FindFirstWrapObj(fLeft);

		LONG & dvpWrapRemaining = fLeft ? _dvpWrapLeftRemaining : _dvpWrapRightRemaining;

		if (dvpWrapRemaining == -1)
		{
			if (fLeft)
				_li._fFirstWrapLeft = 1;
			else
				_li._fFirstWrapRight = 1;

			LONG dup, dvpAscent, dvpDescent;
			pobj->MeasureObj(_dvpInch, _dupInch, dup, dvpAscent, dvpDescent, 0, GetTflow());

			dvpWrapRemaining = dvpAscent + dvpDescent;
		}

		if (_li._fHasEOP && (_pPF->_wEffects & PFE_TEXTWRAPPINGBREAK))
		{
			LONG dvpRemaining = dvpWrapRemaining - dvpLine;
			if (dvpRemaining > 0)
			{
				dvpLine += dvpRemaining;
				dvpDescent += dvpRemaining;
			}
		}

		dvpWrapRemaining -= dvpLine;

		if (dvpWrapRemaining <= 0)
		{
			dvpWrapRemaining = -1;
			RemoveFirstWrap(fLeft);
		}
	}
}

/*
 *	CMeasurer::UpdateWrapState (&dvpLine, &dvpDescent)
 *
 *	@mfunc
 *		Update object wrap state
 */
void CMeasurer::UpdateWrapState(
	USHORT &dvpLine, 
	USHORT &dvpDescent)
{
	//If we are wrapping around an object, update dvpWrapUsed values
	//and remove objects from queue if they have been used up.
	if (IsMeasure() && _rgpobjWrap.Count())
	{
		UpdateWrapState(dvpLine, dvpDescent, TRUE);
		UpdateWrapState(dvpLine, dvpDescent, FALSE);
	}
}

/*
 *	CMeasurer::GetCcsFontFallback (pCF)
 *
 *	@mfunc
 *		Create the fallback font cache for given CF
 *
 *	@rdesc
 *		CCcs corresponding to font fallback given by pCF
 */
CCcs* CMeasurer::GetCcsFontFallback (
	const CCharFormat *pCF,
	WORD wScript)
{
	CCharFormat	CF = *pCF;
	CCcs*		pccs = NULL;
	SHORT		iDefHeight;
	CTxtEdit*	ped = GetPed();
	BYTE		bCharRep = CF._iCharRep;

#ifndef NOCOMPLEXSCRIPTS
	CUniscribe *pusp = ped->Getusp();
	if (pusp && wScript != 0)
	{
		pusp->GetComplexCharRep(pusp->GeteProp(wScript),
			ped->GetCharFormat(-1)->_iCharRep, bCharRep);
	}
#endif

	bool	fr = W32->GetPreferredFontInfo(bCharRep, 
									ped->fUseUIFont() ? true : false, CF._iFont, 
									(BYTE&)iDefHeight, CF._bPitchAndFamily);
	if (fr)
	{
		CF._iCharRep = bCharRep;
		pccs = GetCcs(&CF);				// Create fallback font cache entry
	}

	return pccs;
}

/*
 * 	CMeasurer::ApplyFontCache (fFallback, wScript)
 *
 *	@mfunc
 *		Apply a new font cache on the fly (leave backing store intact)
 *
 *	@rdesc
 *		CCcs corresponding to font fallback if fFallback; else to GetCF()
 */
CCcs* CMeasurer::ApplyFontCache (
	BOOL	fFallback,
	WORD	wScript)
{
	if (_fFallback ^ fFallback)
	{
		CCcs*	pccs = fFallback ? GetCcsFontFallback(GetCF(), wScript) : GetCcs(GetCF());
		
		if (pccs)
		{
			if (_pccs)
				_pccs->Release();
			_pccs = pccs;
	
			_fFallback = fFallback;
		}
	}
	return _pccs;
}

/*
 *	CMeasurer::GetCcs (pCF)
 *
 *	@mfunc
 *		Wrapper around font cache's GetCCcs function
 *		We use a NULL DC unless the device is a printer.
 *
 *	@rdesc
 *		CCcs corresponding to pCF
 */
CCcs* CMeasurer::GetCcs(
	const CCharFormat *pCF)
{
	HDC hdc = NULL;

	if (_fTarget)
	{
		if (_pddReference->_hdc && GetDeviceCaps(_pddReference->_hdc, TECHNOLOGY) == DT_RASPRINTER)
			hdc = _pddReference->_hdc;
	}
	else if (_pdp->_hdc && GetDeviceCaps(_pdp->_hdc, TECHNOLOGY) == DT_RASPRINTER)
		hdc = _pdp->_hdc;

	DWORD dwFlags = GetTflow();
	if (_fGlyphing && _pdp->_hdc != _pddReference->_hdc)
		dwFlags |= FGCCSUSETRUETYPE;

	if(GetPasswordChar())
		pCF = GetPed()->GetCharFormat(-1);
	return GetPed()->GetCcs(pCF, _fTarget ? _dvrInch : _dvpInch, dwFlags, hdc);
}

/*
 *	CMeasurer::CheckLineHeight()
 *
 *	@mfunc
 *		If no height yet, use default height
 */
void CMeasurer::CheckLineHeight()
{
	CCcs *pccs = GetCcs(GetPed()->GetCharFormat(-1));
	_li._dvpHeight  = pccs->_yHeight;
	_li._dvpDescent = pccs->_yDescent;

	SHORT	yFEAdjust = pccs->AdjustFEHeight(FAdjustFELineHt());

	if (yFEAdjust)
	{
		_li._dvpHeight += (yFEAdjust << 1);
		_li._dvpDescent += yFEAdjust;
	}
	pccs->Release();
}

/*
 *	CMeasurer::Check_pccs(fBullet)
 *
 *	@mfunc
 *		Check if new character format run or whether we don't yet have a font
 *
 *	@rdesc
 *		Current CCcs *
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs *CMeasurer::Check_pccs(
	BOOL fBullet)
{
	if(fBullet)
	{
		if(_pccs)							// Release old Format cache
			_pccs->Release();

		_pccs = GetCcsBullet(NULL);
		_iFormat = -10;						// Be sure to reset font next time
		return _pccs;
	}

	const CCharFormat *pCF = GetCF();

	if(FormatIsChanged())
	{
		// New CF run or format for this line not yet initialized
		ResetCachediFormat();
		if(_pccs)							// Release old Format cache
			_pccs->Release();
			
		_pccs = GetCcs(pCF);
		_fFallback = 0;

		if(!_pccs)
		{
			//FUTURE (keithcu) If this fails, just dig up the first pccs you can find
			AssertSz(FALSE, "CMeasurer::Measure could not get _pccs");
			return NULL;
		}
	}

	return _pccs;
}

/*
 *	CMeasurer::AdjustLineHeight()
 *
 *	@mfunc
 *		Adjust for space before/after and line spacing rules.
 *		No effect for plain text.
 *
 *	@future
 *		Base multiple line height calculations on largest font height rather
 *		than on line height (_vpHeight), since the latter may be unduly large
 *		due to embedded objects.  Word does this correctly.
 */
void CMeasurer::AdjustLineHeight()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::AdjustLineHeight");

	if(!IsRich() || IsInOutlineView())			// Plain text and outline mode
		return;									//  don't use special line
												//  spacings
	const CParaFormat * pPF = _pPF;
	DWORD	dwRule	  = pPF->_bLineSpacingRule;
	LONG	dvpAfter	  = 0;						// Default no space after
	LONG	dvpBefore  = 0;						// Default no space before
	LONG	dvpSpacing = pPF->_dyLineSpacing;
	LONG	vpHeight  = LVtoDV(dvpSpacing);
	LONG	vpAscent = _li._dvpHeight - _li._dvpDescent;

	if(_li._fFirstInPara)
		dvpBefore = LVtoDV(pPF->_dySpaceBefore);	// Space before paragraph

	AssertSz(dvpBefore >= 0, "CMeasurer::AdjustLineHeight - bogus value for dvpBefore");

	if(vpHeight < 0)								// Negative heights mean use
		_li._dvpHeight = (SHORT)(-vpHeight);		//  the magnitude exactly

	else if(dwRule)								// Line spacing rule is active
	{
		switch (dwRule)
		{
		case tomLineSpace1pt5:
			dvpAfter = _li._dvpHeight >> 1;		// Half-line space after
			break;								//  (per line)
	
		case tomLineSpaceDouble:
			dvpAfter = _li._dvpHeight;			// Full-line space after
			break;								//  (per line)
	
		case tomLineSpaceAtLeast:
			if(_li._dvpHeight >= vpHeight)
				break;
												// Fall thru to space exactly
		case tomLineSpaceExactly:
			_li._dvpHeight = (SHORT)max(vpHeight, 1);
			break;
	
		case tomLineSpaceMultiple:				// Multiple-line space after
			// Prevent dvpAfter from being negative because dvpSpacing is small - a-rsail
			if (dvpSpacing < 20)
				dvpSpacing = 20;

			dvpAfter = (_li._dvpHeight*dvpSpacing)/20 // (20 units per line)
						- _li._dvpHeight;
		}
	}

	if(_li._fHasEOP)	
		dvpAfter += LVtoDV(pPF->_dySpaceAfter);	// Space after paragraph end
												// Add in space before/after
	if (dvpAfter < 0)
	{
		// Overflow - since we forced dvpSpacing to 20 above, the
		// only reason for a negative is overflow. In case of overflow,
		// we simply force the value to the max and then fix the
		// other resulting overflows.
		dvpAfter = LONG_MAX;
	}

	AssertSz((dvpBefore >= 0), "CMeasurer::AdjustLineHeight - invalid before");

	_li._dvpHeight  = (SHORT)(_li._dvpHeight + dvpBefore + dvpAfter);	

	if (_li._dvpHeight < 0)
	{
		// Overflow!
		// The reason for the -2 is then we don't have to worry about
		// overflow in the table check.
		_li._dvpHeight = SHRT_MAX - 2;
	}

	_li._dvpDescent = (SHORT)(_li._dvpDescent + dvpAfter);

	if (_li._dvpDescent < 0)
	{
		// Overflow in descent
		AssertSz(_li._dvpHeight == SHRT_MAX - 2, "Descent overflowed when height didn't");

		// Allow old ascent
		_li._dvpDescent = SHRT_MAX - 2 - vpAscent;

		AssertSz(_li._dvpDescent >= 0, "descent adjustment < 0");		
	}

	AssertSz((_li._dvpHeight >= 0) && (_li._dvpDescent >= 0),
		"CMeasurer::AdjustLineHeight - invalid line heights");
}

/*
 *	CMeasurer::GetPBorderWidth (dxlLine)
 *
 *	@mfunc
 *		Convert logical width to device width and ensure that
 *		device width is at least 1 pixel if logical width is nonzero.
 *	
 *	@rdesc
 *		Device width of border
 */
LONG CMeasurer::GetPBorderWidth(
	LONG dxlLine) 		//@parm Logical border width
{
	dxlLine &= 0xFF;
	LONG dxpLine = LUtoDU(dxlLine);
	if(dxlLine)
		dxpLine = max(dxpLine, 1);
	return dxpLine;
}

/*
 *	CMeasurer::MeasureLeftIndent()
 *
 *	@mfunc
 *		Compute and return left indent of line in device units
 *
 *	@rdesc
 *		Left indent of line in device units
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureLeftIndent()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLeftIndent");

	AssertSz(_pPF != NULL, "CMeasurer::MeasureLeftIndent _pPF not set!");

	LONG ulLeft = _pPF->_dxStartIndent;				// Use logical units
													//  up to return
	if(IsRich())
	{
		LONG dulOffset = _pPF->_dxOffset;
		BOOL fFirstInPara = _li._fFirstInPara;

		if(IsInOutlineView())
		{
			ulLeft = lDefaultTab/2 * (_pPF->_bOutlineLevel + 1);
			if(!fFirstInPara)
				dulOffset = 0;
		}
		if(fFirstInPara)
		{
			if(_pPF->_wNumbering && !_pPF->IsNumberSuppressed())
			{
				// Add offset to text on first line	 
				if(_pPF->_wNumberingTab)			// If _wNumberingTab != 0,
					dulOffset = _pPF->_wNumberingTab;//  use it
				LONG Alignment = _pPF->_wNumberingStyle & 3;
				if(Alignment != tomAlignRight)
				{
					LONG du = DUtoLU(MeasureBullet());
					if(Alignment == tomAlignCenter)
						du /= 2;
					dulOffset = max(du, dulOffset);	// Use max of bullet and
				}
			}										//  offset
			else
				dulOffset = 0;
		}
		ulLeft += dulOffset;								
	}

	return (ulLeft <= 0) ? 0 : LUtoDU(ulLeft);
}

/*
 *	CMeasurer::HitTest(x)
 *
 *	@mfunc
 *		Return HITTEST for displacement x in this line. Can't be specific
 *		about text area (_upStart to _upStart + _dupLineMax), since need to measure
 *		to get appropriate cp (done elsewhere)
 *
 *	@rdesc
 *		HITTEST for a displacement x in this line
 */
HITTEST CMeasurer::HitTest(
	LONG x)			//@parm Displacement to test hit
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::HitTest");

	UpdatePF();
	LONG u = UFromX(x);
	if(u < 0)
		return HT_LeftOfText;

	// For RightOfText, allow for a little "hit space" of _li.GetHeight() to
	// allow user to select EOP at end of line
	if (u > _li._upStart + _li._dup + _li.GetHeight() &&
		GetPed()->GetSelMin() == GetCp() + _li._cch - _li._cchEOP)
	{
		return HT_RightOfText;
	}

	if(u >= _li._upStart)						// Caller can refine this
		return HT_Text;							//  with CLine::CchFromUp()

	if(IsRich() && _li._fFirstInPara)
	{
		LONG dup;
	
		if(_pPF->_wNumbering)
		{
			// Doesn't handle case where Bullet is wider than following dx
			dup = LUtoDU(max(_pPF->_dxOffset, _pPF->_wNumberingTab));
			if(u >= _li._upStart - dup)
				return HT_BulletArea;
		}
		if(IsInOutlineView())
		{
			dup = LUtoDU(lDefaultTab/2 * _pPF->_bOutlineLevel);
			if(u >= dup && u < dup + (_pPF->_bOutlineLevel & 1
				? LUtoDU(lDefaultTab/2) : _pdp->Zoom(BITMAP_WIDTH_HEADING)))
			{
				return HT_OutlineSymbol;
			}
		}
	}
	return HT_LeftOfText;
}

/*
 *	CMeasurer::MeasureRightIndent()
 *
 *	@mfunc
 *		Compute and return right indent of line in device units
 *
 *	@rdesc
 *		Right indent of line in device units
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureRightIndent()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureRightIndent");

	LONG dulRight = _pPF->_dxRightIndent;

	_upRight = LUtoDU(max(dulRight, 0));
	return _upRight;
}

/*
 *	CMeasurer::MeasureTab()
 *
 *	@mfunc
 *		Computes and returns the width from the current position to the
 *		next tab stop (in device units).
 *
 *	@rdesc
 *		Width from current position to next tab stop
 */
LONG CMeasurer::MeasureTab(
	unsigned ch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureTab");

	LONG			uCur = _li._dup + MeasureLeftIndent();
	const CParaFormat *	pPF = _pPF;
 	LONG			cTab = pPF->_bTabCount;
	LONG			duDefaultTab = lDefaultTab;
	LONG			duIndent = LUtoDU(pPF->_dxStartIndent + pPF->_dxOffset);
	LONG			duOffset = pPF->_dxOffset;
	LONG			duOutline = 0;
	LONG			h = 0;
	LONG			uT;
	LONG			uTab;

	AssertSz(cTab >= 0 || cTab <= MAX_TAB_STOPS, "Illegal tab count");

	if(IsInOutlineView())
		duOutline = lDefaultTab/2 * (pPF->_bOutlineLevel + 1);

	if(cTab)
	{										
		const LONG *pl = pPF->GetTabs();
		for(uTab = 0; cTab--; pl++)				// Try explicit tab stops 1st
		{
			uT = GetTabPos(*pl) + duOutline;	// (2 most significant nibbles
			if(uT > _dulLayout)					// Ignore tabs wider than layout area
				break;

			//REVIEW (keithcu) This is not proper hungarian
			uT = LUtoDU(uT);					//  are for type/style)

			if(uT + h > uCur)					// Allow text in table cell to
			{									//  move into cell gap (h > 0)									
				if(duOffset > 0 && uT < duIndent)// Explicit tab in a hanging
					return uT - uCur;			//  indent takes precedence
				uTab = uT;
				break;
			}
		}
		if(duOffset > 0 && uCur < duIndent)		// If no tab before hanging
			return duIndent - uCur;				//  indent, tab to indent

		if(uTab)								// Else use tab position
			return uTab - uCur;
	}

	duDefaultTab = GetTabPos(GetPed()->GetDefaultTab());
	AssertSz(duDefaultTab > 0, "CMeasurer::MeasureTab: Default tab is bad");

	duDefaultTab = LUtoDU(duDefaultTab);
	duDefaultTab = max(duDefaultTab, 1);		// Don't ever divide by 0
	return duDefaultTab - uCur%duDefaultTab;	// Round up to nearest
}

/*
 *	CMeasurer::MeasureLineShift ()
 *
 *	@mfunc
 *		Computes and returns the line u shift due to alignment
 *
 *	@rdesc
 *		Line u shift due to alignment
 *
 *	@comm
 *		Plain text is sensitive to StartIndent and RightIndent settings,
 *		but usually these are zero for plain text. 
 */
LONG CMeasurer::MeasureLineShift()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureLineShift");

	WORD wAlignment = _pPF->_bAlignment;
	LONG uShift;
	LONG dup;
	CTxtEdit *	ped = GetPed();

	if(IsInOutlineView() || !IN_RANGE(PFA_RIGHT, wAlignment, PFA_CENTER))
		return 0;

	if(!_pdp->GetWordWrap())
		dup = _pdp->GetDupView();
	else
		dup = LUtoDU(_dulLayout);

	// Normal view with center or flush-right para. Move right accordingly
	uShift = dup - _li._upStart - MeasureRightIndent() - _li._dup;

	uShift -= ped->GetCaretWidth();

	uShift = max(uShift, 0);			// Don't allow alignment to go < 0
										// Can happen with a target device
	if(wAlignment == PFA_CENTER)
		uShift /= 2;

	return uShift;
}

/*
 *	CMeasurer::MeasureBullet()
 *
 *	@mfunc
 *		Computes bullet/numbering dimensions
 *
 *	@rdesc
 *		Return bullet/numbering string width
 */
LONG CMeasurer::MeasureBullet()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::MeasureBullet");

	CCharFormat CF;
	CCcs *pccs = GetCcsBullet(&CF);
	LONG dup = 0;

	if(pccs)
	{										
		WCHAR szBullet[CCHMAXNUMTOSTR];
		GetBullet(szBullet, pccs, &dup);
		RecalcLineHeight(pccs, &CF);
		pccs->Release();
	}
	return dup;
}

/*
 *	CMeasurer::GetBullet(pch, pccs, pdup)
 *
 *	@mfunc
 *		Computes bullet/numbering string, string length, and width
 *
 *	@rdesc
 *		Return bullet/numbering string length
 */
LONG CMeasurer::GetBullet(
	WCHAR *pch,			//@parm Bullet string to receive bullet text
	CCcs  *pccs,		//@parm CCcs to use
	LONG  *pdup)		//@parm Out parm for bullet width
{
	Assert(pccs && pch);

	LONG cch = _pPF->NumToStr(pch, _li._bNumber);
	LONG dupChar;
	LONG i;
	LONG dup = 0;

	pch[cch++] = ' ';					// Ensure a little extra space
	for(i = cch; i--; dup += dupChar)
	{
		if(!pccs->Include(*pch++, dupChar))
		{
			TRACEERRSZSC("CMeasurer::GetBullet(): Error filling CCcs", E_FAIL);
		}
	}

	if(pdup)
		*pdup = dup;

	return cch;
}

/*
 *	CMeasurer::GetCcsBullet(pCFRet)
 *
 *	@mfunc
 *		Get CCcs for numbering/bullet font. If bullet is suppressed because
 *		this isn't the beginning of a paragraph (e.g., previous character is
 *		VT or if GetCcs() fails, it returns NULL.
 *
 *	@rdesc
 *		ptr to bullet CCcs, or NULL (GetCcs() failed or not start of para)
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
CCcs * CMeasurer::GetCcsBullet(
	CCharFormat *pCFRet)	//@parm option character format to return
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CMeasurer::GetCcsBullet");

	if(!_li._fFirstInPara)
		return NULL;					// Number/bullet suppressed

	CCharFormat			CF;
	CCcs *			    pccs;
	const CCharFormat *	pCF;
	CCharFormat *		pCFUsed = pCFRet ? pCFRet : &CF;

	// Bullet CF is given by that for EOP in bullet's paragraph.

	CTxtPtr		  tp(_rpTX);
	CFormatRunPtr rpCF(_rpCF);
	rpCF.Move(tp.FindEOP(tomForward));
	rpCF.AdjustBackward();
	pCF = GetPed()->GetCharFormat(rpCF.GetFormat());

	// Construct bullet (or numbering) CCharFormat
	*pCFUsed = *pCF;
	if(_pPF->_wNumbering == PFN_BULLET)			// Traditional bullet uses
	{											//  Symbol font bullet, but...
		pCFUsed->_iCharRep		  = SYMBOL_INDEX,
		pCFUsed->_bPitchAndFamily = FF_DONTCARE;
		pCFUsed->_iFont			  = IFONT_SYMBOL;
	}

	// Since we always cook up bullet character format, no need to cache it
	pccs = GetCcs(pCFUsed);

#if DEBUG
	if(!pccs)
	{
		TRACEERRSZSC("CMeasurer::GetCcsBullet(): no CCcs", E_FAIL);
	}
#endif // DEBUG

	return pccs;
}

/*
 *	CMeasurer::SetNumber(wNumber)
 *
 *	@mfunc
 *		Store number if numbered paragraph
 */
void CMeasurer::SetNumber(
	WORD wNumber)
{
	_pPF = GetPF();
	if(!_pPF->IsListNumbered())
		wNumber = 0;

	else if (!wNumber && !_pPF->IsNumberSuppressed())
		wNumber = 1;

	_wNumber = wNumber;
}

/*
 *	CMeasurer::FindCpDraw(cpStart, cobjectPrev, fLeft)
 *
 *	@mfunc
 *		Find the cp corresponding to the nth previous object to be placed.
 *		(If a line stores a 2 in the _cObjectWrapLeft for example, it means
 *		you need to walk backwards 2 objects to find the object to be drawn
 *		on this line.)
 *
 *	@rdesc	
 *		cp corresponding to the nth previous object 
 */
LONG CMeasurer::FindCpDraw(
	LONG cpStart, 
	int  cobjectPrev, 
	BOOL fLeft)
{
	LONG cch = 0;
	LONG cObjects = -1;

	while (cobjectPrev > 0)
	{
		// BUGBUG: this test should really be after the CountObjects() call,
		//  but we are making a change with minimal impact just before
		//  a major release.
		if (!cObjects)
		    return tomForward;

		cch += GetPed()->GetObjectMgr()->CountObjects(cObjects, cpStart + cch);
		COleObject *pobj = GetObjectFromCp(cpStart + cch);
		if (!pobj)
			return tomForward;
		if (pobj->FWrapTextAround() && pobj->FAlignToRight() == !fLeft)
			cobjectPrev--;
	}
	
	return cpStart + cch;
}

/*
 *	CMeasurer::AddObjectToQueue(pobjAdd)
 *
 *	@mfunc
 *		After formatting a line, update the current state of wrapped objects
 */
void CMeasurer::AddObjectToQueue(
	COleObject *pobjAdd)
{
	if (!IsMeasure())
		return;

	for (int iobj = 0; iobj < _rgpobjWrap.Count(); iobj++)
	{
		COleObject *pobj = _rgpobjWrap.GetAt(iobj);
		if (pobj == pobjAdd)
			return;
	}

	COleObject **ppobj = _rgpobjWrap.Add(1, 0);
	*ppobj = pobjAdd;
}

/*
 *	CMeasurer::CountQueueEntries(fLeft)
 *
 *	@mfunc
 *		Return count of objects queued up
 *
 *	@rdesc
 *		Count of objects queued up
 */
int CMeasurer::CountQueueEntries(
	BOOL fLeft)
{
	int cEntries = 0;
	for (int iobj = 0; iobj < _rgpobjWrap.Count(); iobj++)
	{
		COleObject *pobj = _rgpobjWrap.GetAt(iobj);
		if (!pobj->FAlignToRight() == fLeft)
			cEntries++;
	}
	return cEntries;
}

/*
 *	CMeasurer::RemoveFirstWrap(fLeft)
 *
 *	@mfunc
 *		Remove the object from the queue--after it
 *		has been been placed.
 */
void CMeasurer::RemoveFirstWrap(
	BOOL fLeft)
{
	for (int iobj = 0; iobj < _rgpobjWrap.Count(); iobj++)
	{
		COleObject *pobj = _rgpobjWrap.GetAt(iobj);
		if (!pobj->FAlignToRight() == fLeft)
		{
			_rgpobjWrap.Remove(iobj, 1);
			return;
		}
	}
}

/*
 *	CMeasurer::FindFirstWrapObj(fLeft)
 *
 *	@mfunc
 *		Find the first object queued up to be wrapped.
 *
 *	@rdesc
 *		First object queued up to be wrapped.
 */
COleObject* CMeasurer::FindFirstWrapObj(
	BOOL fLeft)
{
	for (int iobj = 0; iobj < _rgpobjWrap.Count(); iobj++)
	{
		COleObject *pobj = _rgpobjWrap.GetAt(iobj);
		if (!pobj->FAlignToRight() == fLeft)
			return pobj;
	}
	return 0;
}

/*
 *	CMeasurer::XFromU(u)
 *
 *	@mfunc
 *		Given a U position on a line, convert it to X. In
 *		RTL paragraphs, the U position of 0 on a line is
 *		on the right edge of the control.
 *
 *	@rdesc
 *		x coordinate corresponding to u in current rotation
 */
LONG CMeasurer::XFromU(LONG u)
{
	if (_pPF->IsRtlPara())
	{
		CTxtEdit *	ped = GetPed();
		LONG uCaret = _pdp->IsMain() ? ped->GetCaretWidth() : 0;
		LONG dupLayout = LUtoDU(_dulLayout);

		if (_plo && _plo->IsNestedLayout())
			;
		else if(!_pdp->GetWordWrap())
			dupLayout = max(_pdp->GetDupLineMax(), _pdp->GetDupView());

		return dupLayout - u - uCaret;
	}
	return u;
}

LONG CMeasurer::UFromX(LONG x)
{
	if (_pPF->IsRtlPara())
		return XFromU(x);
	return x;
}

#ifndef NOLINESERVICES
extern BOOL g_fNoLS;
extern BOOL g_OLSBusy;

/*
 *	CMeasurer::GetPols()
 *
 *	@mfunc
 *		Get ptr to LineServices object. If LineServices not enabled,
 *		return NULL.
 *
 *	@rdesc
 *		POLS
 */
COls *CMeasurer::GetPols()
{
	CTxtEdit *ped = GetPed();

	if(g_fNoLS || !ped->fUseLineServices())			// Not using LineServices
		return NULL;

	if(!g_pols)								// Starting up LS:
		g_pols = new COls();				//  create new COls

	if(g_pols)								// Have the COls
	{
		if(g_pols->Init(this) != NOERROR)	// Switch to new one
		{
			delete g_pols;
			g_pols = NULL;
		}
		g_OLSBusy = TRUE;
		UpdatePF();
	}
	return g_pols;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\msctf.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for msctf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msctf_h__
#define __msctf_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfThreadMgr_FWD_DEFINED__
#define __ITfThreadMgr_FWD_DEFINED__
typedef interface ITfThreadMgr ITfThreadMgr;
#endif 	/* __ITfThreadMgr_FWD_DEFINED__ */


#ifndef __ITfThreadMgrEventSink_FWD_DEFINED__
#define __ITfThreadMgrEventSink_FWD_DEFINED__
typedef interface ITfThreadMgrEventSink ITfThreadMgrEventSink;
#endif 	/* __ITfThreadMgrEventSink_FWD_DEFINED__ */


#ifndef __ITfConfigureSystemKeystrokeFeed_FWD_DEFINED__
#define __ITfConfigureSystemKeystrokeFeed_FWD_DEFINED__
typedef interface ITfConfigureSystemKeystrokeFeed ITfConfigureSystemKeystrokeFeed;
#endif 	/* __ITfConfigureSystemKeystrokeFeed_FWD_DEFINED__ */


#ifndef __IEnumTfDocumentMgrs_FWD_DEFINED__
#define __IEnumTfDocumentMgrs_FWD_DEFINED__
typedef interface IEnumTfDocumentMgrs IEnumTfDocumentMgrs;
#endif 	/* __IEnumTfDocumentMgrs_FWD_DEFINED__ */


#ifndef __ITfDocumentMgr_FWD_DEFINED__
#define __ITfDocumentMgr_FWD_DEFINED__
typedef interface ITfDocumentMgr ITfDocumentMgr;
#endif 	/* __ITfDocumentMgr_FWD_DEFINED__ */


#ifndef __IEnumTfContexts_FWD_DEFINED__
#define __IEnumTfContexts_FWD_DEFINED__
typedef interface IEnumTfContexts IEnumTfContexts;
#endif 	/* __IEnumTfContexts_FWD_DEFINED__ */


#ifndef __ITfCompositionView_FWD_DEFINED__
#define __ITfCompositionView_FWD_DEFINED__
typedef interface ITfCompositionView ITfCompositionView;
#endif 	/* __ITfCompositionView_FWD_DEFINED__ */


#ifndef __IEnumITfCompositionView_FWD_DEFINED__
#define __IEnumITfCompositionView_FWD_DEFINED__
typedef interface IEnumITfCompositionView IEnumITfCompositionView;
#endif 	/* __IEnumITfCompositionView_FWD_DEFINED__ */


#ifndef __ITfComposition_FWD_DEFINED__
#define __ITfComposition_FWD_DEFINED__
typedef interface ITfComposition ITfComposition;
#endif 	/* __ITfComposition_FWD_DEFINED__ */


#ifndef __ITfCompositionSink_FWD_DEFINED__
#define __ITfCompositionSink_FWD_DEFINED__
typedef interface ITfCompositionSink ITfCompositionSink;
#endif 	/* __ITfCompositionSink_FWD_DEFINED__ */


#ifndef __ITfContextComposition_FWD_DEFINED__
#define __ITfContextComposition_FWD_DEFINED__
typedef interface ITfContextComposition ITfContextComposition;
#endif 	/* __ITfContextComposition_FWD_DEFINED__ */


#ifndef __ITfContextOwnerCompositionServices_FWD_DEFINED__
#define __ITfContextOwnerCompositionServices_FWD_DEFINED__
typedef interface ITfContextOwnerCompositionServices ITfContextOwnerCompositionServices;
#endif 	/* __ITfContextOwnerCompositionServices_FWD_DEFINED__ */


#ifndef __ITfContextOwnerCompositionSink_FWD_DEFINED__
#define __ITfContextOwnerCompositionSink_FWD_DEFINED__
typedef interface ITfContextOwnerCompositionSink ITfContextOwnerCompositionSink;
#endif 	/* __ITfContextOwnerCompositionSink_FWD_DEFINED__ */


#ifndef __ITfContextView_FWD_DEFINED__
#define __ITfContextView_FWD_DEFINED__
typedef interface ITfContextView ITfContextView;
#endif 	/* __ITfContextView_FWD_DEFINED__ */


#ifndef __IEnumTfContextViews_FWD_DEFINED__
#define __IEnumTfContextViews_FWD_DEFINED__
typedef interface IEnumTfContextViews IEnumTfContextViews;
#endif 	/* __IEnumTfContextViews_FWD_DEFINED__ */


#ifndef __ITfContext_FWD_DEFINED__
#define __ITfContext_FWD_DEFINED__
typedef interface ITfContext ITfContext;
#endif 	/* __ITfContext_FWD_DEFINED__ */


#ifndef __ITfQueryEmbedded_FWD_DEFINED__
#define __ITfQueryEmbedded_FWD_DEFINED__
typedef interface ITfQueryEmbedded ITfQueryEmbedded;
#endif 	/* __ITfQueryEmbedded_FWD_DEFINED__ */


#ifndef __ITfInsertAtSelection_FWD_DEFINED__
#define __ITfInsertAtSelection_FWD_DEFINED__
typedef interface ITfInsertAtSelection ITfInsertAtSelection;
#endif 	/* __ITfInsertAtSelection_FWD_DEFINED__ */


#ifndef __ITfCleanupContextSink_FWD_DEFINED__
#define __ITfCleanupContextSink_FWD_DEFINED__
typedef interface ITfCleanupContextSink ITfCleanupContextSink;
#endif 	/* __ITfCleanupContextSink_FWD_DEFINED__ */


#ifndef __ITfCleanupContextDurationSink_FWD_DEFINED__
#define __ITfCleanupContextDurationSink_FWD_DEFINED__
typedef interface ITfCleanupContextDurationSink ITfCleanupContextDurationSink;
#endif 	/* __ITfCleanupContextDurationSink_FWD_DEFINED__ */


#ifndef __ITfReadOnlyProperty_FWD_DEFINED__
#define __ITfReadOnlyProperty_FWD_DEFINED__
typedef interface ITfReadOnlyProperty ITfReadOnlyProperty;
#endif 	/* __ITfReadOnlyProperty_FWD_DEFINED__ */


#ifndef __IEnumTfPropertyValue_FWD_DEFINED__
#define __IEnumTfPropertyValue_FWD_DEFINED__
typedef interface IEnumTfPropertyValue IEnumTfPropertyValue;
#endif 	/* __IEnumTfPropertyValue_FWD_DEFINED__ */


#ifndef __ITfMouseTracker_FWD_DEFINED__
#define __ITfMouseTracker_FWD_DEFINED__
typedef interface ITfMouseTracker ITfMouseTracker;
#endif 	/* __ITfMouseTracker_FWD_DEFINED__ */


#ifndef __ITfMouseTrackerACP_FWD_DEFINED__
#define __ITfMouseTrackerACP_FWD_DEFINED__
typedef interface ITfMouseTrackerACP ITfMouseTrackerACP;
#endif 	/* __ITfMouseTrackerACP_FWD_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_FWD_DEFINED__
#define __ITfMouseTrackerAnchor_FWD_DEFINED__
typedef interface ITfMouseTrackerAnchor ITfMouseTrackerAnchor;
#endif 	/* __ITfMouseTrackerAnchor_FWD_DEFINED__ */


#ifndef __ITfMouseSink_FWD_DEFINED__
#define __ITfMouseSink_FWD_DEFINED__
typedef interface ITfMouseSink ITfMouseSink;
#endif 	/* __ITfMouseSink_FWD_DEFINED__ */


#ifndef __ITfEditRecord_FWD_DEFINED__
#define __ITfEditRecord_FWD_DEFINED__
typedef interface ITfEditRecord ITfEditRecord;
#endif 	/* __ITfEditRecord_FWD_DEFINED__ */


#ifndef __ITfTextEditSink_FWD_DEFINED__
#define __ITfTextEditSink_FWD_DEFINED__
typedef interface ITfTextEditSink ITfTextEditSink;
#endif 	/* __ITfTextEditSink_FWD_DEFINED__ */


#ifndef __ITfTextLayoutSink_FWD_DEFINED__
#define __ITfTextLayoutSink_FWD_DEFINED__
typedef interface ITfTextLayoutSink ITfTextLayoutSink;
#endif 	/* __ITfTextLayoutSink_FWD_DEFINED__ */


#ifndef __ITfStatusSink_FWD_DEFINED__
#define __ITfStatusSink_FWD_DEFINED__
typedef interface ITfStatusSink ITfStatusSink;
#endif 	/* __ITfStatusSink_FWD_DEFINED__ */


#ifndef __ITfEditTransactionSink_FWD_DEFINED__
#define __ITfEditTransactionSink_FWD_DEFINED__
typedef interface ITfEditTransactionSink ITfEditTransactionSink;
#endif 	/* __ITfEditTransactionSink_FWD_DEFINED__ */


#ifndef __ITfContextOwner_FWD_DEFINED__
#define __ITfContextOwner_FWD_DEFINED__
typedef interface ITfContextOwner ITfContextOwner;
#endif 	/* __ITfContextOwner_FWD_DEFINED__ */


#ifndef __ITfContextOwnerServices_FWD_DEFINED__
#define __ITfContextOwnerServices_FWD_DEFINED__
typedef interface ITfContextOwnerServices ITfContextOwnerServices;
#endif 	/* __ITfContextOwnerServices_FWD_DEFINED__ */


#ifndef __ITfContextKeyEventSink_FWD_DEFINED__
#define __ITfContextKeyEventSink_FWD_DEFINED__
typedef interface ITfContextKeyEventSink ITfContextKeyEventSink;
#endif 	/* __ITfContextKeyEventSink_FWD_DEFINED__ */


#ifndef __ITfEditSession_FWD_DEFINED__
#define __ITfEditSession_FWD_DEFINED__
typedef interface ITfEditSession ITfEditSession;
#endif 	/* __ITfEditSession_FWD_DEFINED__ */


#ifndef __IEnumTfTextDeltas_FWD_DEFINED__
#define __IEnumTfTextDeltas_FWD_DEFINED__
typedef interface IEnumTfTextDeltas IEnumTfTextDeltas;
#endif 	/* __IEnumTfTextDeltas_FWD_DEFINED__ */


#ifndef __ITfRange_FWD_DEFINED__
#define __ITfRange_FWD_DEFINED__
typedef interface ITfRange ITfRange;
#endif 	/* __ITfRange_FWD_DEFINED__ */


#ifndef __ITfRangeACP_FWD_DEFINED__
#define __ITfRangeACP_FWD_DEFINED__
typedef interface ITfRangeACP ITfRangeACP;
#endif 	/* __ITfRangeACP_FWD_DEFINED__ */


#ifndef __ITfRangeAnchor_FWD_DEFINED__
#define __ITfRangeAnchor_FWD_DEFINED__
typedef interface ITfRangeAnchor ITfRangeAnchor;
#endif 	/* __ITfRangeAnchor_FWD_DEFINED__ */


#ifndef __ITextStoreACPServices_FWD_DEFINED__
#define __ITextStoreACPServices_FWD_DEFINED__
typedef interface ITextStoreACPServices ITextStoreACPServices;
#endif 	/* __ITextStoreACPServices_FWD_DEFINED__ */


#ifndef __ITextStoreAnchorServices_FWD_DEFINED__
#define __ITextStoreAnchorServices_FWD_DEFINED__
typedef interface ITextStoreAnchorServices ITextStoreAnchorServices;
#endif 	/* __ITextStoreAnchorServices_FWD_DEFINED__ */


#ifndef __ITfRangeBackup_FWD_DEFINED__
#define __ITfRangeBackup_FWD_DEFINED__
typedef interface ITfRangeBackup ITfRangeBackup;
#endif 	/* __ITfRangeBackup_FWD_DEFINED__ */


#ifndef __ITfPropertyStore_FWD_DEFINED__
#define __ITfPropertyStore_FWD_DEFINED__
typedef interface ITfPropertyStore ITfPropertyStore;
#endif 	/* __ITfPropertyStore_FWD_DEFINED__ */


#ifndef __IEnumTfRanges_FWD_DEFINED__
#define __IEnumTfRanges_FWD_DEFINED__
typedef interface IEnumTfRanges IEnumTfRanges;
#endif 	/* __IEnumTfRanges_FWD_DEFINED__ */


#ifndef __ITfCreatePropertyStore_FWD_DEFINED__
#define __ITfCreatePropertyStore_FWD_DEFINED__
typedef interface ITfCreatePropertyStore ITfCreatePropertyStore;
#endif 	/* __ITfCreatePropertyStore_FWD_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderACP_FWD_DEFINED__
#define __ITfPersistentPropertyLoaderACP_FWD_DEFINED__
typedef interface ITfPersistentPropertyLoaderACP ITfPersistentPropertyLoaderACP;
#endif 	/* __ITfPersistentPropertyLoaderACP_FWD_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
typedef interface ITfPersistentPropertyLoaderAnchor ITfPersistentPropertyLoaderAnchor;
#endif 	/* __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__ */


#ifndef __ITfProperty_FWD_DEFINED__
#define __ITfProperty_FWD_DEFINED__
typedef interface ITfProperty ITfProperty;
#endif 	/* __ITfProperty_FWD_DEFINED__ */


#ifndef __IEnumTfProperties_FWD_DEFINED__
#define __IEnumTfProperties_FWD_DEFINED__
typedef interface IEnumTfProperties IEnumTfProperties;
#endif 	/* __IEnumTfProperties_FWD_DEFINED__ */


#ifndef __ITfCompartment_FWD_DEFINED__
#define __ITfCompartment_FWD_DEFINED__
typedef interface ITfCompartment ITfCompartment;
#endif 	/* __ITfCompartment_FWD_DEFINED__ */


#ifndef __ITfCompartmentEventSink_FWD_DEFINED__
#define __ITfCompartmentEventSink_FWD_DEFINED__
typedef interface ITfCompartmentEventSink ITfCompartmentEventSink;
#endif 	/* __ITfCompartmentEventSink_FWD_DEFINED__ */


#ifndef __ITfCompartmentMgr_FWD_DEFINED__
#define __ITfCompartmentMgr_FWD_DEFINED__
typedef interface ITfCompartmentMgr ITfCompartmentMgr;
#endif 	/* __ITfCompartmentMgr_FWD_DEFINED__ */


#ifndef __ITfFunction_FWD_DEFINED__
#define __ITfFunction_FWD_DEFINED__
typedef interface ITfFunction ITfFunction;
#endif 	/* __ITfFunction_FWD_DEFINED__ */


#ifndef __ITfFunctionProvider_FWD_DEFINED__
#define __ITfFunctionProvider_FWD_DEFINED__
typedef interface ITfFunctionProvider ITfFunctionProvider;
#endif 	/* __ITfFunctionProvider_FWD_DEFINED__ */


#ifndef __IEnumTfFunctionProviders_FWD_DEFINED__
#define __IEnumTfFunctionProviders_FWD_DEFINED__
typedef interface IEnumTfFunctionProviders IEnumTfFunctionProviders;
#endif 	/* __IEnumTfFunctionProviders_FWD_DEFINED__ */


#ifndef __ITfInputProcessorProfiles_FWD_DEFINED__
#define __ITfInputProcessorProfiles_FWD_DEFINED__
typedef interface ITfInputProcessorProfiles ITfInputProcessorProfiles;
#endif 	/* __ITfInputProcessorProfiles_FWD_DEFINED__ */


#ifndef __ITfActiveLanguageProfileNotifySink_FWD_DEFINED__
#define __ITfActiveLanguageProfileNotifySink_FWD_DEFINED__
typedef interface ITfActiveLanguageProfileNotifySink ITfActiveLanguageProfileNotifySink;
#endif 	/* __ITfActiveLanguageProfileNotifySink_FWD_DEFINED__ */


#ifndef __IEnumTfLanguageProfiles_FWD_DEFINED__
#define __IEnumTfLanguageProfiles_FWD_DEFINED__
typedef interface IEnumTfLanguageProfiles IEnumTfLanguageProfiles;
#endif 	/* __IEnumTfLanguageProfiles_FWD_DEFINED__ */


#ifndef __ITfLanguageProfileNotifySink_FWD_DEFINED__
#define __ITfLanguageProfileNotifySink_FWD_DEFINED__
typedef interface ITfLanguageProfileNotifySink ITfLanguageProfileNotifySink;
#endif 	/* __ITfLanguageProfileNotifySink_FWD_DEFINED__ */


#ifndef __ITfKeystrokeMgr_FWD_DEFINED__
#define __ITfKeystrokeMgr_FWD_DEFINED__
typedef interface ITfKeystrokeMgr ITfKeystrokeMgr;
#endif 	/* __ITfKeystrokeMgr_FWD_DEFINED__ */


#ifndef __ITfKeyEventSink_FWD_DEFINED__
#define __ITfKeyEventSink_FWD_DEFINED__
typedef interface ITfKeyEventSink ITfKeyEventSink;
#endif 	/* __ITfKeyEventSink_FWD_DEFINED__ */


#ifndef __ITfKeyTraceEventSink_FWD_DEFINED__
#define __ITfKeyTraceEventSink_FWD_DEFINED__
typedef interface ITfKeyTraceEventSink ITfKeyTraceEventSink;
#endif 	/* __ITfKeyTraceEventSink_FWD_DEFINED__ */


#ifndef __ITfPreservedKeyNotifySink_FWD_DEFINED__
#define __ITfPreservedKeyNotifySink_FWD_DEFINED__
typedef interface ITfPreservedKeyNotifySink ITfPreservedKeyNotifySink;
#endif 	/* __ITfPreservedKeyNotifySink_FWD_DEFINED__ */


#ifndef __ITfMessagePump_FWD_DEFINED__
#define __ITfMessagePump_FWD_DEFINED__
typedef interface ITfMessagePump ITfMessagePump;
#endif 	/* __ITfMessagePump_FWD_DEFINED__ */


#ifndef __ITfThreadFocusSink_FWD_DEFINED__
#define __ITfThreadFocusSink_FWD_DEFINED__
typedef interface ITfThreadFocusSink ITfThreadFocusSink;
#endif 	/* __ITfThreadFocusSink_FWD_DEFINED__ */


#ifndef __ITfTextInputProcessor_FWD_DEFINED__
#define __ITfTextInputProcessor_FWD_DEFINED__
typedef interface ITfTextInputProcessor ITfTextInputProcessor;
#endif 	/* __ITfTextInputProcessor_FWD_DEFINED__ */


#ifndef __ITfClientId_FWD_DEFINED__
#define __ITfClientId_FWD_DEFINED__
typedef interface ITfClientId ITfClientId;
#endif 	/* __ITfClientId_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeInfo_FWD_DEFINED__
#define __ITfDisplayAttributeInfo_FWD_DEFINED__
typedef interface ITfDisplayAttributeInfo ITfDisplayAttributeInfo;
#endif 	/* __ITfDisplayAttributeInfo_FWD_DEFINED__ */


#ifndef __IEnumTfDisplayAttributeInfo_FWD_DEFINED__
#define __IEnumTfDisplayAttributeInfo_FWD_DEFINED__
typedef interface IEnumTfDisplayAttributeInfo IEnumTfDisplayAttributeInfo;
#endif 	/* __IEnumTfDisplayAttributeInfo_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeProvider_FWD_DEFINED__
#define __ITfDisplayAttributeProvider_FWD_DEFINED__
typedef interface ITfDisplayAttributeProvider ITfDisplayAttributeProvider;
#endif 	/* __ITfDisplayAttributeProvider_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeMgr_FWD_DEFINED__
#define __ITfDisplayAttributeMgr_FWD_DEFINED__
typedef interface ITfDisplayAttributeMgr ITfDisplayAttributeMgr;
#endif 	/* __ITfDisplayAttributeMgr_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeNotifySink_FWD_DEFINED__
#define __ITfDisplayAttributeNotifySink_FWD_DEFINED__
typedef interface ITfDisplayAttributeNotifySink ITfDisplayAttributeNotifySink;
#endif 	/* __ITfDisplayAttributeNotifySink_FWD_DEFINED__ */


#ifndef __ITfCategoryMgr_FWD_DEFINED__
#define __ITfCategoryMgr_FWD_DEFINED__
typedef interface ITfCategoryMgr ITfCategoryMgr;
#endif 	/* __ITfCategoryMgr_FWD_DEFINED__ */


#ifndef __ITfSource_FWD_DEFINED__
#define __ITfSource_FWD_DEFINED__
typedef interface ITfSource ITfSource;
#endif 	/* __ITfSource_FWD_DEFINED__ */


#ifndef __ITfSourceSingle_FWD_DEFINED__
#define __ITfSourceSingle_FWD_DEFINED__
typedef interface ITfSourceSingle ITfSourceSingle;
#endif 	/* __ITfSourceSingle_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "comcat.h"
#include "textstor.h"
#include "ctfutb.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msctf_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// msctf.h


// CTF declarations.

//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#ifndef MSCTF_DEFINED
#define MSCTF_DEFINED

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define TF_E_LOCKED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0500)
#define TF_E_STACKFULL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0501)
#define TF_E_NOTOWNEDRANGE   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0502)
#define TF_E_NOPROVIDER      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0503)
#define TF_E_DISCONNECTED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0504)
#define TF_E_INVALIDVIEW     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0505)
#define TF_E_ALREADY_EXISTS  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0506)
#define TF_E_RANGE_NOT_COVERED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0507)
#define TF_E_COMPOSITION_REJECTED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0508)
#define TF_E_INVALIDPOS      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0200)
#define TF_E_NOLOCK          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0201)
#define TF_E_NOOBJECT        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0202)
#define TF_E_NOSERVICE       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0203)
#define TF_E_NOINTERFACE     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0204)
#define TF_E_NOSELECTION     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0205)
#define TF_E_NOLAYOUT        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0206)
#define TF_E_INVALIDPOINT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0207)
#define TF_E_SYNCHRONOUS     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0208)
#define TF_E_READONLY        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0209)
#define TF_E_FORMAT          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x020a)
#define TF_E_EMPTYCONTEXT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x020a)
#define TF_S_ASYNC           MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x0300)

HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim);
HRESULT WINAPI TF_CreateInputProcessorProfiles(ITfInputProcessorProfiles **ppipr);
HRESULT WINAPI TF_CreateDisplayAttributeMgr(ITfDisplayAttributeMgr **ppdam);
HRESULT WINAPI TF_CreateLangBarMgr(ITfLangBarMgr **pppbm);
HRESULT WINAPI TF_CreateLangBarItemMgr(ITfLangBarItemMgr **pplbim);

EXTERN_C const GUID GUID_PROP_TEXTOWNER;
EXTERN_C const GUID GUID_PROP_ATTRIBUTE;
EXTERN_C const GUID GUID_PROP_LANGID;
EXTERN_C const GUID GUID_PROP_READING;
EXTERN_C const GUID GUID_PROP_COMPOSING;

EXTERN_C const CLSID CLSID_TF_ThreadMgr;
EXTERN_C const CLSID CLSID_TF_InputProcessorProfiles;
EXTERN_C const CLSID CLSID_TF_LangBarMgr;
EXTERN_C const CLSID CLSID_TF_DisplayAttributeMgr;
EXTERN_C const CLSID CLSID_TF_CategoryMgr;
EXTERN_C const CLSID CLSID_TF_LangBarItemMgr;
EXTERN_C const GUID GUID_SYSTEM_FUNCTIONPROVIDER;
EXTERN_C const GUID GUID_APP_FUNCTIONPROVIDER;

EXTERN_C const GUID GUID_SERVICE_CTF;

EXTERN_C const GUID GUID_COMPARTMENT_KEYBOARD_DISABLED;
EXTERN_C const GUID GUID_COMPARTMENT_KEYBOARD_OPENCLOSE;
EXTERN_C const GUID GUID_COMPARTMENT_HANDWRITING_OPENCLOSE;
EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_DISABLED;
EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_OPENCLOSE;
EXTERN_C const GUID GUID_COMPARTMENT_PERSISTMENUENABLED;
EXTERN_C const GUID GUID_COMPARTMENT_EMPTYCONTEXT;
EXTERN_C const GUID GUID_COMPARTMENT_TIPUISTATUS;

EXTERN_C const GUID GUID_PROP_MODEBIAS;

EXTERN_C const GUID GUID_MODEBIAS_NONE;
EXTERN_C const GUID GUID_MODEBIAS_FILENAME;
EXTERN_C const GUID GUID_MODEBIAS_READING;
EXTERN_C const GUID GUID_MODEBIAS_DATETIME;
EXTERN_C const GUID GUID_MODEBIAS_NAME;
EXTERN_C const GUID GUID_MODEBIAS_CONVERSATION;
EXTERN_C const GUID GUID_MODEBIAS_NUMERIC;
EXTERN_C const GUID GUID_MODEBIAS_HIRAGANA;
EXTERN_C const GUID GUID_MODEBIAS_KATAKANA;
EXTERN_C const GUID GUID_MODEBIAS_HANGUL;
EXTERN_C const GUID GUID_MODEBIAS_CHINESE;
EXTERN_C const GUID GUID_MODEBIAS_HALFWIDTHKATAKANA;
EXTERN_C const GUID GUID_MODEBIAS_FULLWIDTHALPHANUMERIC;
EXTERN_C const GUID GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
EXTERN_C const GUID GUID_MODEBIAS_FULLWIDTHHANGUL;
EXTERN_C const GUID GUID_TFCAT_CATEGORY_OF_TIP;
EXTERN_C const GUID GUID_TFCAT_TIP_KEYBOARD;
EXTERN_C const GUID GUID_TFCAT_TIP_SPEECH;
EXTERN_C const GUID GUID_TFCAT_TIP_HANDWRITING;
EXTERN_C const GUID GUID_TFCAT_TIP_LOOKUP;
EXTERN_C const GUID GUID_TFCAT_PROP_AUDIODATA;
EXTERN_C const GUID GUID_TFCAT_PROP_INKDATA;

EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_CUSTOM;
EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_STATIC;
EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_STATICCOMPACT;

EXTERN_C const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER;
EXTERN_C const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY;

#define TF_INVALID_GUIDATOM ((TfGuidAtom)0)
#define TF_CLIENTID_NULL    ((TfClientId)0)

#define TF_MOD_ALT                         0x0001
#define TF_MOD_CONTROL                     0x0002
#define TF_MOD_SHIFT                       0x0004
#define TF_MOD_RALT                        0x0008
#define TF_MOD_RCONTROL                    0x0010
#define TF_MOD_RSHIFT                      0x0020
#define TF_MOD_LALT                        0x0040
#define TF_MOD_LCONTROL                    0x0080
#define TF_MOD_LSHIFT                      0x0100
#define TF_MOD_ON_KEYUP                    0x0200
#define TF_MOD_IGNORE_ALL_MODIFIER         0x0400

#define TF_US_HIDETIPUI         0x00000001

#define TF_DISABLE_SPEECH         0x00000001
#define TF_DISABLE_DICTATION      0x00000002
#define TF_DISABLE_COMMANDING     0x00000004

#define CTF_PROCESS_ATOM             TEXT("_CTF_PROCESS_ATOM_")
#define CTF_ENABLE_PROCESS_ATOM      TEXT("_CTF_ENABLE_PROCESS_ATOM_")
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if 0
typedef /* [uuid] */  DECLSPEC_UUID("4f5d560f-5ab5-4dde-8c4d-404592857ab0") UINT_PTR HKL;

#endif



























typedef /* [uuid] */  DECLSPEC_UUID("7213778c-7bb0-4270-b050-6189ee594e97") DWORD TfEditCookie;

#define	TF_INVALID_EDIT_COOKIE	( 0 )

typedef /* [uuid] */  DECLSPEC_UUID("88a9c478-f3ec-4763-8345-cd9250443f8d") DWORD TfGuidAtom;

typedef /* [uuid] */  DECLSPEC_UUID("de403c21-89fd-4f85-8b87-64584d063fbc") DWORD TfClientId;

typedef /* [public][public][uuid] */  DECLSPEC_UUID("01f46108-9d8a-4aef-94dd-1c4df6acd4eb") 
enum __MIDL___MIDL_itf_msctf_0000_0001
    {	TF_PT_NONE	= 0,
	TF_PT_UNKNOWN	= 1,
	TF_PT_DWORD	= 2,
	TF_PT_GUID	= 3,
	TF_PT_BSTR	= 4
    } 	TfPropertyType;

typedef /* [uuid] */  DECLSPEC_UUID("e26d9e1d-691e-4f29-90d7-338dcf1f8cef") struct TF_PERSISTENT_PROPERTY_HEADER_ACP
    {
    GUID guidType;
    LONG ichStart;
    LONG cch;
    ULONG cb;
    DWORD dwPrivate;
    CLSID clsidTIP;
    } 	TF_PERSISTENT_PROPERTY_HEADER_ACP;

typedef /* [uuid] */  DECLSPEC_UUID("af9f076f-4937-4285-8600-81dca5c31eb6") struct TF_PERSISTENT_PROPERTY_HEADER_ANCHOR
    {
    GUID guidType;
    IAnchor *paStart;
    IAnchor *paEnd;
    ULONG cb;
    DWORD dwPrivate;
    CLSID clsidTIP;
    } 	TF_PERSISTENT_PROPERTY_HEADER_ANCHOR;

typedef /* [uuid] */  DECLSPEC_UUID("e1b5808d-1e46-4c19-84dc-68c5f5978cc8") struct TF_LANGUAGEPROFILE
    {
    CLSID clsid;
    LANGID langid;
    GUID catid;
    BOOL fActive;
    GUID guidProfile;
    } 	TF_LANGUAGEPROFILE;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][uuid] */  DECLSPEC_UUID("5a886226-ae9a-489b-b991-2b1e25ee59a9") 
enum __MIDL___MIDL_itf_msctf_0000_0002
    {	TF_ANCHOR_START	= 0,
	TF_ANCHOR_END	= 1
    } 	TfAnchor;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0000_v0_0_s_ifspec;

#ifndef __ITfThreadMgr_INTERFACE_DEFINED__
#define __ITfThreadMgr_INTERFACE_DEFINED__

/* interface ITfThreadMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfThreadMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e801-2021-11d2-93e0-0060b067b86e")
    ITfThreadMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [out] */ TfClientId *ptid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDocumentMgr( 
            /* [out] */ ITfDocumentMgr **ppdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDocumentMgrs( 
            /* [out] */ IEnumTfDocumentMgrs **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFocus( 
            /* [out] */ ITfDocumentMgr **ppdimFocus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( 
            /* [in] */ ITfDocumentMgr *pdimFocus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateFocus( 
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsThreadFocus( 
            /* [out] */ BOOL *pfThreadFocus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionProvider( 
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFunctionProviders( 
            /* [out] */ IEnumTfFunctionProviders **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlobalCompartment( 
            /* [out] */ ITfCompartmentMgr **ppCompMgr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfThreadMgr * This,
            /* [out] */ TfClientId *ptid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentMgr )( 
            ITfThreadMgr * This,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDocumentMgrs )( 
            ITfThreadMgr * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            ITfThreadMgr * This,
            /* [out] */ ITfDocumentMgr **ppdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            ITfThreadMgr * This,
            /* [in] */ ITfDocumentMgr *pdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateFocus )( 
            ITfThreadMgr * This,
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev);
        
        HRESULT ( STDMETHODCALLTYPE *IsThreadFocus )( 
            ITfThreadMgr * This,
            /* [out] */ BOOL *pfThreadFocus);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionProvider )( 
            ITfThreadMgr * This,
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFunctionProviders )( 
            ITfThreadMgr * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalCompartment )( 
            ITfThreadMgr * This,
            /* [out] */ ITfCompartmentMgr **ppCompMgr);
        
        END_INTERFACE
    } ITfThreadMgrVtbl;

    interface ITfThreadMgr
    {
        CONST_VTBL struct ITfThreadMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgr_Activate(This,ptid)	\
    (This)->lpVtbl -> Activate(This,ptid)

#define ITfThreadMgr_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ITfThreadMgr_CreateDocumentMgr(This,ppdim)	\
    (This)->lpVtbl -> CreateDocumentMgr(This,ppdim)

#define ITfThreadMgr_EnumDocumentMgrs(This,ppEnum)	\
    (This)->lpVtbl -> EnumDocumentMgrs(This,ppEnum)

#define ITfThreadMgr_GetFocus(This,ppdimFocus)	\
    (This)->lpVtbl -> GetFocus(This,ppdimFocus)

#define ITfThreadMgr_SetFocus(This,pdimFocus)	\
    (This)->lpVtbl -> SetFocus(This,pdimFocus)

#define ITfThreadMgr_AssociateFocus(This,hwnd,pdimNew,ppdimPrev)	\
    (This)->lpVtbl -> AssociateFocus(This,hwnd,pdimNew,ppdimPrev)

#define ITfThreadMgr_IsThreadFocus(This,pfThreadFocus)	\
    (This)->lpVtbl -> IsThreadFocus(This,pfThreadFocus)

#define ITfThreadMgr_GetFunctionProvider(This,clsid,ppFuncProv)	\
    (This)->lpVtbl -> GetFunctionProvider(This,clsid,ppFuncProv)

#define ITfThreadMgr_EnumFunctionProviders(This,ppEnum)	\
    (This)->lpVtbl -> EnumFunctionProviders(This,ppEnum)

#define ITfThreadMgr_GetGlobalCompartment(This,ppCompMgr)	\
    (This)->lpVtbl -> GetGlobalCompartment(This,ppCompMgr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgr_Activate_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ TfClientId *ptid);


void __RPC_STUB ITfThreadMgr_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_Deactivate_Proxy( 
    ITfThreadMgr * This);


void __RPC_STUB ITfThreadMgr_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_CreateDocumentMgr_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ ITfDocumentMgr **ppdim);


void __RPC_STUB ITfThreadMgr_CreateDocumentMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_EnumDocumentMgrs_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ IEnumTfDocumentMgrs **ppEnum);


void __RPC_STUB ITfThreadMgr_EnumDocumentMgrs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_GetFocus_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ ITfDocumentMgr **ppdimFocus);


void __RPC_STUB ITfThreadMgr_GetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_SetFocus_Proxy( 
    ITfThreadMgr * This,
    /* [in] */ ITfDocumentMgr *pdimFocus);


void __RPC_STUB ITfThreadMgr_SetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_AssociateFocus_Proxy( 
    ITfThreadMgr * This,
    /* [in] */ HWND hwnd,
    /* [unique][in] */ ITfDocumentMgr *pdimNew,
    /* [out] */ ITfDocumentMgr **ppdimPrev);


void __RPC_STUB ITfThreadMgr_AssociateFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_IsThreadFocus_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ BOOL *pfThreadFocus);


void __RPC_STUB ITfThreadMgr_IsThreadFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_GetFunctionProvider_Proxy( 
    ITfThreadMgr * This,
    /* [in] */ REFCLSID clsid,
    /* [out] */ ITfFunctionProvider **ppFuncProv);


void __RPC_STUB ITfThreadMgr_GetFunctionProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_EnumFunctionProviders_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ IEnumTfFunctionProviders **ppEnum);


void __RPC_STUB ITfThreadMgr_EnumFunctionProviders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_GetGlobalCompartment_Proxy( 
    ITfThreadMgr * This,
    /* [out] */ ITfCompartmentMgr **ppCompMgr);


void __RPC_STUB ITfThreadMgr_GetGlobalCompartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgr_INTERFACE_DEFINED__ */


#ifndef __ITfThreadMgrEventSink_INTERFACE_DEFINED__
#define __ITfThreadMgrEventSink_INTERFACE_DEFINED__

/* interface ITfThreadMgrEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfThreadMgrEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e80e-2021-11d2-93e0-0060b067b86e")
    ITfThreadMgrEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnInitDocumentMgr( 
            /* [in] */ ITfDocumentMgr *pdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUninitDocumentMgr( 
            /* [in] */ ITfDocumentMgr *pdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetFocus( 
            /* [in] */ ITfDocumentMgr *pdimFocus,
            /* [in] */ ITfDocumentMgr *pdimPrevFocus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPushContext( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPopContext( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgrEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgrEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgrEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnInitDocumentMgr )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfDocumentMgr *pdim);
        
        HRESULT ( STDMETHODCALLTYPE *OnUninitDocumentMgr )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfDocumentMgr *pdim);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetFocus )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfDocumentMgr *pdimFocus,
            /* [in] */ ITfDocumentMgr *pdimPrevFocus);
        
        HRESULT ( STDMETHODCALLTYPE *OnPushContext )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *OnPopContext )( 
            ITfThreadMgrEventSink * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfThreadMgrEventSinkVtbl;

    interface ITfThreadMgrEventSink
    {
        CONST_VTBL struct ITfThreadMgrEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgrEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgrEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgrEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgrEventSink_OnInitDocumentMgr(This,pdim)	\
    (This)->lpVtbl -> OnInitDocumentMgr(This,pdim)

#define ITfThreadMgrEventSink_OnUninitDocumentMgr(This,pdim)	\
    (This)->lpVtbl -> OnUninitDocumentMgr(This,pdim)

#define ITfThreadMgrEventSink_OnSetFocus(This,pdimFocus,pdimPrevFocus)	\
    (This)->lpVtbl -> OnSetFocus(This,pdimFocus,pdimPrevFocus)

#define ITfThreadMgrEventSink_OnPushContext(This,pic)	\
    (This)->lpVtbl -> OnPushContext(This,pic)

#define ITfThreadMgrEventSink_OnPopContext(This,pic)	\
    (This)->lpVtbl -> OnPopContext(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnInitDocumentMgr_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfDocumentMgr *pdim);


void __RPC_STUB ITfThreadMgrEventSink_OnInitDocumentMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnUninitDocumentMgr_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfDocumentMgr *pdim);


void __RPC_STUB ITfThreadMgrEventSink_OnUninitDocumentMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnSetFocus_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfDocumentMgr *pdimFocus,
    /* [in] */ ITfDocumentMgr *pdimPrevFocus);


void __RPC_STUB ITfThreadMgrEventSink_OnSetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnPushContext_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfThreadMgrEventSink_OnPushContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgrEventSink_OnPopContext_Proxy( 
    ITfThreadMgrEventSink * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfThreadMgrEventSink_OnPopContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgrEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfConfigureSystemKeystrokeFeed_INTERFACE_DEFINED__
#define __ITfConfigureSystemKeystrokeFeed_INTERFACE_DEFINED__

/* interface ITfConfigureSystemKeystrokeFeed */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfConfigureSystemKeystrokeFeed;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d2c969a-bc9c-437c-84ee-951c49b1a764")
    ITfConfigureSystemKeystrokeFeed : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisableSystemKeystrokeFeed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableSystemKeystrokeFeed( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfConfigureSystemKeystrokeFeedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfConfigureSystemKeystrokeFeed * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfConfigureSystemKeystrokeFeed * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfConfigureSystemKeystrokeFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *DisableSystemKeystrokeFeed )( 
            ITfConfigureSystemKeystrokeFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableSystemKeystrokeFeed )( 
            ITfConfigureSystemKeystrokeFeed * This);
        
        END_INTERFACE
    } ITfConfigureSystemKeystrokeFeedVtbl;

    interface ITfConfigureSystemKeystrokeFeed
    {
        CONST_VTBL struct ITfConfigureSystemKeystrokeFeedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfConfigureSystemKeystrokeFeed_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfConfigureSystemKeystrokeFeed_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfConfigureSystemKeystrokeFeed_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfConfigureSystemKeystrokeFeed_DisableSystemKeystrokeFeed(This)	\
    (This)->lpVtbl -> DisableSystemKeystrokeFeed(This)

#define ITfConfigureSystemKeystrokeFeed_EnableSystemKeystrokeFeed(This)	\
    (This)->lpVtbl -> EnableSystemKeystrokeFeed(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfConfigureSystemKeystrokeFeed_DisableSystemKeystrokeFeed_Proxy( 
    ITfConfigureSystemKeystrokeFeed * This);


void __RPC_STUB ITfConfigureSystemKeystrokeFeed_DisableSystemKeystrokeFeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfConfigureSystemKeystrokeFeed_EnableSystemKeystrokeFeed_Proxy( 
    ITfConfigureSystemKeystrokeFeed * This);


void __RPC_STUB ITfConfigureSystemKeystrokeFeed_EnableSystemKeystrokeFeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfConfigureSystemKeystrokeFeed_INTERFACE_DEFINED__ */


#ifndef __IEnumTfDocumentMgrs_INTERFACE_DEFINED__
#define __IEnumTfDocumentMgrs_INTERFACE_DEFINED__

/* interface IEnumTfDocumentMgrs */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfDocumentMgrs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e808-2021-11d2-93e0-0060b067b86e")
    IEnumTfDocumentMgrs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfDocumentMgrs **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfDocumentMgr **rgDocumentMgr,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfDocumentMgrsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfDocumentMgrs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfDocumentMgrs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfDocumentMgrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfDocumentMgrs * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfDocumentMgrs * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfDocumentMgr **rgDocumentMgr,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfDocumentMgrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfDocumentMgrs * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfDocumentMgrsVtbl;

    interface IEnumTfDocumentMgrs
    {
        CONST_VTBL struct IEnumTfDocumentMgrsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfDocumentMgrs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfDocumentMgrs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfDocumentMgrs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfDocumentMgrs_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfDocumentMgrs_Next(This,ulCount,rgDocumentMgr,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgDocumentMgr,pcFetched)

#define IEnumTfDocumentMgrs_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfDocumentMgrs_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfDocumentMgrs_Clone_Proxy( 
    IEnumTfDocumentMgrs * This,
    /* [out] */ IEnumTfDocumentMgrs **ppEnum);


void __RPC_STUB IEnumTfDocumentMgrs_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDocumentMgrs_Next_Proxy( 
    IEnumTfDocumentMgrs * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfDocumentMgr **rgDocumentMgr,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfDocumentMgrs_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDocumentMgrs_Reset_Proxy( 
    IEnumTfDocumentMgrs * This);


void __RPC_STUB IEnumTfDocumentMgrs_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDocumentMgrs_Skip_Proxy( 
    IEnumTfDocumentMgrs * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfDocumentMgrs_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfDocumentMgrs_INTERFACE_DEFINED__ */


#ifndef __ITfDocumentMgr_INTERFACE_DEFINED__
#define __ITfDocumentMgr_INTERFACE_DEFINED__

/* interface ITfDocumentMgr */
/* [unique][uuid][object] */ 

#define	TF_PLAINTEXTTSI	( 0x1 )

#define	TF_POPF_ALL	( 0x1 )


EXTERN_C const IID IID_ITfDocumentMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7f4-2021-11d2-93e0-0060b067b86e")
    ITfDocumentMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [in] */ TfClientId tidOwner,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ IUnknown *punk,
            /* [out] */ ITfContext **ppic,
            /* [out] */ TfEditCookie *pecTextStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Push( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pop( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTop( 
            /* [out] */ ITfContext **ppic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBase( 
            /* [out] */ ITfContext **ppic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumContexts( 
            /* [out] */ IEnumTfContexts **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDocumentMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDocumentMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDocumentMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDocumentMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            ITfDocumentMgr * This,
            /* [in] */ TfClientId tidOwner,
            /* [in] */ DWORD dwFlags,
            /* [unique][in] */ IUnknown *punk,
            /* [out] */ ITfContext **ppic,
            /* [out] */ TfEditCookie *pecTextStore);
        
        HRESULT ( STDMETHODCALLTYPE *Push )( 
            ITfDocumentMgr * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *Pop )( 
            ITfDocumentMgr * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetTop )( 
            ITfDocumentMgr * This,
            /* [out] */ ITfContext **ppic);
        
        HRESULT ( STDMETHODCALLTYPE *GetBase )( 
            ITfDocumentMgr * This,
            /* [out] */ ITfContext **ppic);
        
        HRESULT ( STDMETHODCALLTYPE *EnumContexts )( 
            ITfDocumentMgr * This,
            /* [out] */ IEnumTfContexts **ppEnum);
        
        END_INTERFACE
    } ITfDocumentMgrVtbl;

    interface ITfDocumentMgr
    {
        CONST_VTBL struct ITfDocumentMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDocumentMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDocumentMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDocumentMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDocumentMgr_CreateContext(This,tidOwner,dwFlags,punk,ppic,pecTextStore)	\
    (This)->lpVtbl -> CreateContext(This,tidOwner,dwFlags,punk,ppic,pecTextStore)

#define ITfDocumentMgr_Push(This,pic)	\
    (This)->lpVtbl -> Push(This,pic)

#define ITfDocumentMgr_Pop(This,dwFlags)	\
    (This)->lpVtbl -> Pop(This,dwFlags)

#define ITfDocumentMgr_GetTop(This,ppic)	\
    (This)->lpVtbl -> GetTop(This,ppic)

#define ITfDocumentMgr_GetBase(This,ppic)	\
    (This)->lpVtbl -> GetBase(This,ppic)

#define ITfDocumentMgr_EnumContexts(This,ppEnum)	\
    (This)->lpVtbl -> EnumContexts(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDocumentMgr_CreateContext_Proxy( 
    ITfDocumentMgr * This,
    /* [in] */ TfClientId tidOwner,
    /* [in] */ DWORD dwFlags,
    /* [unique][in] */ IUnknown *punk,
    /* [out] */ ITfContext **ppic,
    /* [out] */ TfEditCookie *pecTextStore);


void __RPC_STUB ITfDocumentMgr_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_Push_Proxy( 
    ITfDocumentMgr * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfDocumentMgr_Push_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_Pop_Proxy( 
    ITfDocumentMgr * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfDocumentMgr_Pop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_GetTop_Proxy( 
    ITfDocumentMgr * This,
    /* [out] */ ITfContext **ppic);


void __RPC_STUB ITfDocumentMgr_GetTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_GetBase_Proxy( 
    ITfDocumentMgr * This,
    /* [out] */ ITfContext **ppic);


void __RPC_STUB ITfDocumentMgr_GetBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDocumentMgr_EnumContexts_Proxy( 
    ITfDocumentMgr * This,
    /* [out] */ IEnumTfContexts **ppEnum);


void __RPC_STUB ITfDocumentMgr_EnumContexts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDocumentMgr_INTERFACE_DEFINED__ */


#ifndef __IEnumTfContexts_INTERFACE_DEFINED__
#define __IEnumTfContexts_INTERFACE_DEFINED__

/* interface IEnumTfContexts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfContexts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8f1a7ea6-1654-4502-a86e-b2902344d507")
    IEnumTfContexts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfContexts **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfContext **rgContext,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfContextsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfContexts * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfContexts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfContexts * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfContexts * This,
            /* [out] */ IEnumTfContexts **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfContexts * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfContext **rgContext,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfContexts * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfContexts * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfContextsVtbl;

    interface IEnumTfContexts
    {
        CONST_VTBL struct IEnumTfContextsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfContexts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfContexts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfContexts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfContexts_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfContexts_Next(This,ulCount,rgContext,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgContext,pcFetched)

#define IEnumTfContexts_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfContexts_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfContexts_Clone_Proxy( 
    IEnumTfContexts * This,
    /* [out] */ IEnumTfContexts **ppEnum);


void __RPC_STUB IEnumTfContexts_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContexts_Next_Proxy( 
    IEnumTfContexts * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfContext **rgContext,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfContexts_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContexts_Reset_Proxy( 
    IEnumTfContexts * This);


void __RPC_STUB IEnumTfContexts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContexts_Skip_Proxy( 
    IEnumTfContexts * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfContexts_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfContexts_INTERFACE_DEFINED__ */


#ifndef __ITfCompositionView_INTERFACE_DEFINED__
#define __ITfCompositionView_INTERFACE_DEFINED__

/* interface ITfCompositionView */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompositionView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7540241-F9A1-4364-BEFC-DBCD2C4395B7")
    ITfCompositionView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwnerClsid( 
            /* [out] */ CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [out] */ ITfRange **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompositionViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompositionView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompositionView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompositionView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwnerClsid )( 
            ITfCompositionView * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            ITfCompositionView * This,
            /* [out] */ ITfRange **ppRange);
        
        END_INTERFACE
    } ITfCompositionViewVtbl;

    interface ITfCompositionView
    {
        CONST_VTBL struct ITfCompositionViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompositionView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompositionView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompositionView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompositionView_GetOwnerClsid(This,pclsid)	\
    (This)->lpVtbl -> GetOwnerClsid(This,pclsid)

#define ITfCompositionView_GetRange(This,ppRange)	\
    (This)->lpVtbl -> GetRange(This,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompositionView_GetOwnerClsid_Proxy( 
    ITfCompositionView * This,
    /* [out] */ CLSID *pclsid);


void __RPC_STUB ITfCompositionView_GetOwnerClsid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCompositionView_GetRange_Proxy( 
    ITfCompositionView * This,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfCompositionView_GetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompositionView_INTERFACE_DEFINED__ */


#ifndef __IEnumITfCompositionView_INTERFACE_DEFINED__
#define __IEnumITfCompositionView_INTERFACE_DEFINED__

/* interface IEnumITfCompositionView */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumITfCompositionView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5EFD22BA-7838-46CB-88E2-CADB14124F8F")
    IEnumITfCompositionView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumITfCompositionView **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfCompositionView **rgCompositionView,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumITfCompositionViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumITfCompositionView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumITfCompositionView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumITfCompositionView * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumITfCompositionView * This,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumITfCompositionView * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfCompositionView **rgCompositionView,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumITfCompositionView * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumITfCompositionView * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumITfCompositionViewVtbl;

    interface IEnumITfCompositionView
    {
        CONST_VTBL struct IEnumITfCompositionViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumITfCompositionView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumITfCompositionView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumITfCompositionView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumITfCompositionView_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumITfCompositionView_Next(This,ulCount,rgCompositionView,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgCompositionView,pcFetched)

#define IEnumITfCompositionView_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumITfCompositionView_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumITfCompositionView_Clone_Proxy( 
    IEnumITfCompositionView * This,
    /* [out] */ IEnumITfCompositionView **ppEnum);


void __RPC_STUB IEnumITfCompositionView_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumITfCompositionView_Next_Proxy( 
    IEnumITfCompositionView * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfCompositionView **rgCompositionView,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumITfCompositionView_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumITfCompositionView_Reset_Proxy( 
    IEnumITfCompositionView * This);


void __RPC_STUB IEnumITfCompositionView_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumITfCompositionView_Skip_Proxy( 
    IEnumITfCompositionView * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumITfCompositionView_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumITfCompositionView_INTERFACE_DEFINED__ */


#ifndef __ITfComposition_INTERFACE_DEFINED__
#define __ITfComposition_INTERFACE_DEFINED__

/* interface ITfComposition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfComposition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20168D64-5A8F-4A5A-B7BD-CFA29F4D0FD9")
    ITfComposition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [out] */ ITfRange **ppRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftStart( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pNewStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftEnd( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pNewEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndComposition( 
            /* [in] */ TfEditCookie ecWrite) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfComposition * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfComposition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfComposition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRange )( 
            ITfComposition * This,
            /* [out] */ ITfRange **ppRange);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfComposition * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pNewStart);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfComposition * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pNewEnd);
        
        HRESULT ( STDMETHODCALLTYPE *EndComposition )( 
            ITfComposition * This,
            /* [in] */ TfEditCookie ecWrite);
        
        END_INTERFACE
    } ITfCompositionVtbl;

    interface ITfComposition
    {
        CONST_VTBL struct ITfCompositionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfComposition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfComposition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfComposition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfComposition_GetRange(This,ppRange)	\
    (This)->lpVtbl -> GetRange(This,ppRange)

#define ITfComposition_ShiftStart(This,ecWrite,pNewStart)	\
    (This)->lpVtbl -> ShiftStart(This,ecWrite,pNewStart)

#define ITfComposition_ShiftEnd(This,ecWrite,pNewEnd)	\
    (This)->lpVtbl -> ShiftEnd(This,ecWrite,pNewEnd)

#define ITfComposition_EndComposition(This,ecWrite)	\
    (This)->lpVtbl -> EndComposition(This,ecWrite)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfComposition_GetRange_Proxy( 
    ITfComposition * This,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfComposition_GetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfComposition_ShiftStart_Proxy( 
    ITfComposition * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfRange *pNewStart);


void __RPC_STUB ITfComposition_ShiftStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfComposition_ShiftEnd_Proxy( 
    ITfComposition * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfRange *pNewEnd);


void __RPC_STUB ITfComposition_ShiftEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfComposition_EndComposition_Proxy( 
    ITfComposition * This,
    /* [in] */ TfEditCookie ecWrite);


void __RPC_STUB ITfComposition_EndComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfComposition_INTERFACE_DEFINED__ */


#ifndef __ITfCompositionSink_INTERFACE_DEFINED__
#define __ITfCompositionSink_INTERFACE_DEFINED__

/* interface ITfCompositionSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompositionSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A781718C-579A-4B15-A280-32B8577ACC5E")
    ITfCompositionSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCompositionTerminated( 
            /* [in] */ TfEditCookie ecWrite,
            ITfComposition *pComposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompositionSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompositionSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompositionSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompositionSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCompositionTerminated )( 
            ITfCompositionSink * This,
            /* [in] */ TfEditCookie ecWrite,
            ITfComposition *pComposition);
        
        END_INTERFACE
    } ITfCompositionSinkVtbl;

    interface ITfCompositionSink
    {
        CONST_VTBL struct ITfCompositionSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompositionSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompositionSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompositionSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompositionSink_OnCompositionTerminated(This,ecWrite,pComposition)	\
    (This)->lpVtbl -> OnCompositionTerminated(This,ecWrite,pComposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompositionSink_OnCompositionTerminated_Proxy( 
    ITfCompositionSink * This,
    /* [in] */ TfEditCookie ecWrite,
    ITfComposition *pComposition);


void __RPC_STUB ITfCompositionSink_OnCompositionTerminated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompositionSink_INTERFACE_DEFINED__ */


#ifndef __ITfContextComposition_INTERFACE_DEFINED__
#define __ITfContextComposition_INTERFACE_DEFINED__

/* interface ITfContextComposition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextComposition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D40C8AAE-AC92-4FC7-9A11-0EE0E23AA39B")
    ITfContextComposition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartComposition( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pCompositionRange,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCompositions( 
            /* [out] */ IEnumITfCompositionView **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindComposition( 
            /* [in] */ TfEditCookie ecRead,
            /* [in] */ ITfRange *pTestRange,
            /* [out] */ IEnumITfCompositionView **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TakeOwnerShip( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextCompositionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextComposition * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextComposition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextComposition * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartComposition )( 
            ITfContextComposition * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pCompositionRange,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCompositions )( 
            ITfContextComposition * This,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindComposition )( 
            ITfContextComposition * This,
            /* [in] */ TfEditCookie ecRead,
            /* [in] */ ITfRange *pTestRange,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *TakeOwnerShip )( 
            ITfContextComposition * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition);
        
        END_INTERFACE
    } ITfContextCompositionVtbl;

    interface ITfContextComposition
    {
        CONST_VTBL struct ITfContextCompositionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextComposition_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextComposition_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextComposition_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextComposition_StartComposition(This,ecWrite,pCompositionRange,pSink,ppComposition)	\
    (This)->lpVtbl -> StartComposition(This,ecWrite,pCompositionRange,pSink,ppComposition)

#define ITfContextComposition_EnumCompositions(This,ppEnum)	\
    (This)->lpVtbl -> EnumCompositions(This,ppEnum)

#define ITfContextComposition_FindComposition(This,ecRead,pTestRange,ppEnum)	\
    (This)->lpVtbl -> FindComposition(This,ecRead,pTestRange,ppEnum)

#define ITfContextComposition_TakeOwnerShip(This,ecWrite,pComposition,pSink,ppComposition)	\
    (This)->lpVtbl -> TakeOwnerShip(This,ecWrite,pComposition,pSink,ppComposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextComposition_StartComposition_Proxy( 
    ITfContextComposition * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfRange *pCompositionRange,
    /* [in] */ ITfCompositionSink *pSink,
    /* [out] */ ITfComposition **ppComposition);


void __RPC_STUB ITfContextComposition_StartComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextComposition_EnumCompositions_Proxy( 
    ITfContextComposition * This,
    /* [out] */ IEnumITfCompositionView **ppEnum);


void __RPC_STUB ITfContextComposition_EnumCompositions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextComposition_FindComposition_Proxy( 
    ITfContextComposition * This,
    /* [in] */ TfEditCookie ecRead,
    /* [in] */ ITfRange *pTestRange,
    /* [out] */ IEnumITfCompositionView **ppEnum);


void __RPC_STUB ITfContextComposition_FindComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextComposition_TakeOwnerShip_Proxy( 
    ITfContextComposition * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfCompositionView *pComposition,
    /* [in] */ ITfCompositionSink *pSink,
    /* [out] */ ITfComposition **ppComposition);


void __RPC_STUB ITfContextComposition_TakeOwnerShip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextComposition_INTERFACE_DEFINED__ */


#ifndef __ITfContextOwnerCompositionServices_INTERFACE_DEFINED__
#define __ITfContextOwnerCompositionServices_INTERFACE_DEFINED__

/* interface ITfContextOwnerCompositionServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextOwnerCompositionServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86462810-593B-4916-9764-19C08E9CE110")
    ITfContextOwnerCompositionServices : public ITfContextComposition
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TerminateComposition( 
            /* [in] */ ITfCompositionView *pComposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextOwnerCompositionServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextOwnerCompositionServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextOwnerCompositionServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartComposition )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfRange *pCompositionRange,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCompositions )( 
            ITfContextOwnerCompositionServices * This,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindComposition )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ TfEditCookie ecRead,
            /* [in] */ ITfRange *pTestRange,
            /* [out] */ IEnumITfCompositionView **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *TakeOwnerShip )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfCompositionSink *pSink,
            /* [out] */ ITfComposition **ppComposition);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateComposition )( 
            ITfContextOwnerCompositionServices * This,
            /* [in] */ ITfCompositionView *pComposition);
        
        END_INTERFACE
    } ITfContextOwnerCompositionServicesVtbl;

    interface ITfContextOwnerCompositionServices
    {
        CONST_VTBL struct ITfContextOwnerCompositionServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextOwnerCompositionServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextOwnerCompositionServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextOwnerCompositionServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextOwnerCompositionServices_StartComposition(This,ecWrite,pCompositionRange,pSink,ppComposition)	\
    (This)->lpVtbl -> StartComposition(This,ecWrite,pCompositionRange,pSink,ppComposition)

#define ITfContextOwnerCompositionServices_EnumCompositions(This,ppEnum)	\
    (This)->lpVtbl -> EnumCompositions(This,ppEnum)

#define ITfContextOwnerCompositionServices_FindComposition(This,ecRead,pTestRange,ppEnum)	\
    (This)->lpVtbl -> FindComposition(This,ecRead,pTestRange,ppEnum)

#define ITfContextOwnerCompositionServices_TakeOwnerShip(This,ecWrite,pComposition,pSink,ppComposition)	\
    (This)->lpVtbl -> TakeOwnerShip(This,ecWrite,pComposition,pSink,ppComposition)


#define ITfContextOwnerCompositionServices_TerminateComposition(This,pComposition)	\
    (This)->lpVtbl -> TerminateComposition(This,pComposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextOwnerCompositionServices_TerminateComposition_Proxy( 
    ITfContextOwnerCompositionServices * This,
    /* [in] */ ITfCompositionView *pComposition);


void __RPC_STUB ITfContextOwnerCompositionServices_TerminateComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextOwnerCompositionServices_INTERFACE_DEFINED__ */


#ifndef __ITfContextOwnerCompositionSink_INTERFACE_DEFINED__
#define __ITfContextOwnerCompositionSink_INTERFACE_DEFINED__

/* interface ITfContextOwnerCompositionSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextOwnerCompositionSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F20AA40-B57A-4F34-96AB-3576F377CC79")
    ITfContextOwnerCompositionSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartComposition( 
            /* [in] */ ITfCompositionView *pComposition,
            /* [out] */ BOOL *pfOk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdateComposition( 
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfRange *pRangeNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndComposition( 
            /* [in] */ ITfCompositionView *pComposition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextOwnerCompositionSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextOwnerCompositionSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextOwnerCompositionSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextOwnerCompositionSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartComposition )( 
            ITfContextOwnerCompositionSink * This,
            /* [in] */ ITfCompositionView *pComposition,
            /* [out] */ BOOL *pfOk);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateComposition )( 
            ITfContextOwnerCompositionSink * This,
            /* [in] */ ITfCompositionView *pComposition,
            /* [in] */ ITfRange *pRangeNew);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndComposition )( 
            ITfContextOwnerCompositionSink * This,
            /* [in] */ ITfCompositionView *pComposition);
        
        END_INTERFACE
    } ITfContextOwnerCompositionSinkVtbl;

    interface ITfContextOwnerCompositionSink
    {
        CONST_VTBL struct ITfContextOwnerCompositionSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextOwnerCompositionSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextOwnerCompositionSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextOwnerCompositionSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextOwnerCompositionSink_OnStartComposition(This,pComposition,pfOk)	\
    (This)->lpVtbl -> OnStartComposition(This,pComposition,pfOk)

#define ITfContextOwnerCompositionSink_OnUpdateComposition(This,pComposition,pRangeNew)	\
    (This)->lpVtbl -> OnUpdateComposition(This,pComposition,pRangeNew)

#define ITfContextOwnerCompositionSink_OnEndComposition(This,pComposition)	\
    (This)->lpVtbl -> OnEndComposition(This,pComposition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextOwnerCompositionSink_OnStartComposition_Proxy( 
    ITfContextOwnerCompositionSink * This,
    /* [in] */ ITfCompositionView *pComposition,
    /* [out] */ BOOL *pfOk);


void __RPC_STUB ITfContextOwnerCompositionSink_OnStartComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerCompositionSink_OnUpdateComposition_Proxy( 
    ITfContextOwnerCompositionSink * This,
    /* [in] */ ITfCompositionView *pComposition,
    /* [in] */ ITfRange *pRangeNew);


void __RPC_STUB ITfContextOwnerCompositionSink_OnUpdateComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerCompositionSink_OnEndComposition_Proxy( 
    ITfContextOwnerCompositionSink * This,
    /* [in] */ ITfCompositionView *pComposition);


void __RPC_STUB ITfContextOwnerCompositionSink_OnEndComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextOwnerCompositionSink_INTERFACE_DEFINED__ */


#ifndef __ITfContextView_INTERFACE_DEFINED__
#define __ITfContextView_INTERFACE_DEFINED__

/* interface ITfContextView */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2433bf8e-0f9b-435c-ba2c-180611978c30")
    ITfContextView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRangeFromPoint( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ const POINT *ppt,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITfRange **ppRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextExt( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScreenExt( 
            /* [out] */ RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWnd( 
            /* [out] */ HWND *phwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeFromPoint )( 
            ITfContextView * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ const POINT *ppt,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITfRange **ppRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextExt )( 
            ITfContextView * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped);
        
        HRESULT ( STDMETHODCALLTYPE *GetScreenExt )( 
            ITfContextView * This,
            /* [out] */ RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetWnd )( 
            ITfContextView * This,
            /* [out] */ HWND *phwnd);
        
        END_INTERFACE
    } ITfContextViewVtbl;

    interface ITfContextView
    {
        CONST_VTBL struct ITfContextViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextView_GetRangeFromPoint(This,ec,ppt,dwFlags,ppRange)	\
    (This)->lpVtbl -> GetRangeFromPoint(This,ec,ppt,dwFlags,ppRange)

#define ITfContextView_GetTextExt(This,ec,pRange,prc,pfClipped)	\
    (This)->lpVtbl -> GetTextExt(This,ec,pRange,prc,pfClipped)

#define ITfContextView_GetScreenExt(This,prc)	\
    (This)->lpVtbl -> GetScreenExt(This,prc)

#define ITfContextView_GetWnd(This,phwnd)	\
    (This)->lpVtbl -> GetWnd(This,phwnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextView_GetRangeFromPoint_Proxy( 
    ITfContextView * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ const POINT *ppt,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfContextView_GetRangeFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextView_GetTextExt_Proxy( 
    ITfContextView * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [out] */ RECT *prc,
    /* [out] */ BOOL *pfClipped);


void __RPC_STUB ITfContextView_GetTextExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextView_GetScreenExt_Proxy( 
    ITfContextView * This,
    /* [out] */ RECT *prc);


void __RPC_STUB ITfContextView_GetScreenExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextView_GetWnd_Proxy( 
    ITfContextView * This,
    /* [out] */ HWND *phwnd);


void __RPC_STUB ITfContextView_GetWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextView_INTERFACE_DEFINED__ */


#ifndef __IEnumTfContextViews_INTERFACE_DEFINED__
#define __IEnumTfContextViews_INTERFACE_DEFINED__

/* interface IEnumTfContextViews */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfContextViews;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0C0F8DD-CF38-44E1-BB0F-68CF0D551C78")
    IEnumTfContextViews : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfContextViews **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfContextView **rgViews,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfContextViewsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfContextViews * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfContextViews * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfContextViews * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfContextViews * This,
            /* [out] */ IEnumTfContextViews **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfContextViews * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfContextView **rgViews,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfContextViews * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfContextViews * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfContextViewsVtbl;

    interface IEnumTfContextViews
    {
        CONST_VTBL struct IEnumTfContextViewsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfContextViews_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfContextViews_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfContextViews_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfContextViews_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfContextViews_Next(This,ulCount,rgViews,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgViews,pcFetched)

#define IEnumTfContextViews_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfContextViews_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfContextViews_Clone_Proxy( 
    IEnumTfContextViews * This,
    /* [out] */ IEnumTfContextViews **ppEnum);


void __RPC_STUB IEnumTfContextViews_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContextViews_Next_Proxy( 
    IEnumTfContextViews * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfContextView **rgViews,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfContextViews_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContextViews_Reset_Proxy( 
    IEnumTfContextViews * This);


void __RPC_STUB IEnumTfContextViews_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfContextViews_Skip_Proxy( 
    IEnumTfContextViews * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfContextViews_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfContextViews_INTERFACE_DEFINED__ */


#ifndef __ITfContext_INTERFACE_DEFINED__
#define __ITfContext_INTERFACE_DEFINED__

/* interface ITfContext */
/* [unique][uuid][object] */ 

#define	TF_ES_ASYNCDONTCARE	( 0 )

#define	TF_ES_SYNC	( 0x1 )

#define	TF_ES_READ	( 0x2 )

#define	TF_ES_READWRITE	( 0x6 )

#define	TF_ES_ASYNC	( 0x8 )

typedef /* [public][public][public][public][public][uuid] */  DECLSPEC_UUID("1690be9b-d3e9-49f6-8d8b-51b905af4c43") 
enum __MIDL_ITfContext_0001
    {	TF_AE_NONE	= 0,
	TF_AE_START	= 1,
	TF_AE_END	= 2
    } 	TfActiveSelEnd;

typedef /* [uuid] */  DECLSPEC_UUID("36ae42a4-6989-4bdc-b48a-6137b7bf2e42") struct TF_SELECTIONSTYLE
    {
    TfActiveSelEnd ase;
    BOOL fInterimChar;
    } 	TF_SELECTIONSTYLE;

typedef /* [uuid] */  DECLSPEC_UUID("75eb22f2-b0bf-46a8-8006-975a3b6efcf1") struct TF_SELECTION
    {
    ITfRange *range;
    TF_SELECTIONSTYLE style;
    } 	TF_SELECTION;

#define	TF_DEFAULT_SELECTION	( TS_DEFAULT_SELECTION )

#define	TF_SD_READONLY	( TS_SD_READONLY )

#define	TF_SD_LOADING	( TS_SD_LOADING )

#define	TF_SS_DISJOINTSEL	( TS_SS_DISJOINTSEL )

#define	TF_SS_REGIONS	( TS_SS_REGIONS )

#define	TF_SS_TRANSITORY	( TS_SS_TRANSITORY )

typedef /* [uuid] */  DECLSPEC_UUID("bc7d979a-846a-444d-afef-0a9bfa82b961") TS_STATUS TF_STATUS;


EXTERN_C const IID IID_ITfContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7fd-2021-11d2-93e0-0060b067b86e")
    ITfContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EditSession( 
            /* [in] */ TfClientId tid,
            /* [in] */ ITfEditSession *pes,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HRESULT *phrSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InWriteSession( 
            /* [in] */ TfClientId tid,
            /* [out] */ BOOL *pfWriteSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelection( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulCount,
            /* [in] */ const TF_SELECTION *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStart( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnd( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveView( 
            /* [out] */ ITfContextView **ppView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumViews( 
            /* [out] */ IEnumTfContextViews **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ TF_STATUS *pdcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfProperty **ppProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppProperty( 
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfReadOnlyProperty **ppProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TrackProperties( 
            /* [size_is][in] */ const GUID **prgProp,
            /* [in] */ ULONG cProp,
            /* [size_is][in] */ const GUID **prgAppProp,
            /* [in] */ ULONG cAppProp,
            /* [out] */ ITfReadOnlyProperty **ppProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumProperties( 
            /* [out] */ IEnumTfProperties **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentMgr( 
            /* [out] */ ITfDocumentMgr **ppDm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRangeBackup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRangeBackup **ppBackup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *EditSession )( 
            ITfContext * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfEditSession *pes,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HRESULT *phrSession);
        
        HRESULT ( STDMETHODCALLTYPE *InWriteSession )( 
            ITfContext * This,
            /* [in] */ TfClientId tid,
            /* [out] */ BOOL *pfWriteSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulCount,
            /* [in] */ const TF_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetStart )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnd )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveView )( 
            ITfContext * This,
            /* [out] */ ITfContextView **ppView);
        
        HRESULT ( STDMETHODCALLTYPE *EnumViews )( 
            ITfContext * This,
            /* [out] */ IEnumTfContextViews **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfContext * This,
            /* [out] */ TF_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ITfContext * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppProperty )( 
            ITfContext * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfReadOnlyProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *TrackProperties )( 
            ITfContext * This,
            /* [size_is][in] */ const GUID **prgProp,
            /* [in] */ ULONG cProp,
            /* [size_is][in] */ const GUID **prgAppProp,
            /* [in] */ ULONG cAppProp,
            /* [out] */ ITfReadOnlyProperty **ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            ITfContext * This,
            /* [out] */ IEnumTfProperties **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentMgr )( 
            ITfContext * This,
            /* [out] */ ITfDocumentMgr **ppDm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRangeBackup )( 
            ITfContext * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRangeBackup **ppBackup);
        
        END_INTERFACE
    } ITfContextVtbl;

    interface ITfContext
    {
        CONST_VTBL struct ITfContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContext_EditSession(This,tid,pes,dwFlags,phrSession)	\
    (This)->lpVtbl -> EditSession(This,tid,pes,dwFlags,phrSession)

#define ITfContext_InWriteSession(This,tid,pfWriteSession)	\
    (This)->lpVtbl -> InWriteSession(This,tid,pfWriteSession)

#define ITfContext_GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)	\
    (This)->lpVtbl -> GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)

#define ITfContext_SetSelection(This,ec,ulCount,pSelection)	\
    (This)->lpVtbl -> SetSelection(This,ec,ulCount,pSelection)

#define ITfContext_GetStart(This,ec,ppStart)	\
    (This)->lpVtbl -> GetStart(This,ec,ppStart)

#define ITfContext_GetEnd(This,ec,ppEnd)	\
    (This)->lpVtbl -> GetEnd(This,ec,ppEnd)

#define ITfContext_GetActiveView(This,ppView)	\
    (This)->lpVtbl -> GetActiveView(This,ppView)

#define ITfContext_EnumViews(This,ppEnum)	\
    (This)->lpVtbl -> EnumViews(This,ppEnum)

#define ITfContext_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITfContext_GetProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetProperty(This,guidProp,ppProp)

#define ITfContext_GetAppProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetAppProperty(This,guidProp,ppProp)

#define ITfContext_TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)	\
    (This)->lpVtbl -> TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)

#define ITfContext_EnumProperties(This,ppEnum)	\
    (This)->lpVtbl -> EnumProperties(This,ppEnum)

#define ITfContext_GetDocumentMgr(This,ppDm)	\
    (This)->lpVtbl -> GetDocumentMgr(This,ppDm)

#define ITfContext_CreateRangeBackup(This,ec,pRange,ppBackup)	\
    (This)->lpVtbl -> CreateRangeBackup(This,ec,pRange,ppBackup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContext_EditSession_Proxy( 
    ITfContext * This,
    /* [in] */ TfClientId tid,
    /* [in] */ ITfEditSession *pes,
    /* [in] */ DWORD dwFlags,
    /* [out] */ HRESULT *phrSession);


void __RPC_STUB ITfContext_EditSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_InWriteSession_Proxy( 
    ITfContext * This,
    /* [in] */ TfClientId tid,
    /* [out] */ BOOL *pfWriteSession);


void __RPC_STUB ITfContext_InWriteSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetSelection_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ULONG ulIndex,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB ITfContext_GetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_SetSelection_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ULONG ulCount,
    /* [in] */ const TF_SELECTION *pSelection);


void __RPC_STUB ITfContext_SetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetStart_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ ITfRange **ppStart);


void __RPC_STUB ITfContext_GetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetEnd_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ ITfRange **ppEnd);


void __RPC_STUB ITfContext_GetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetActiveView_Proxy( 
    ITfContext * This,
    /* [out] */ ITfContextView **ppView);


void __RPC_STUB ITfContext_GetActiveView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_EnumViews_Proxy( 
    ITfContext * This,
    /* [out] */ IEnumTfContextViews **ppEnum);


void __RPC_STUB ITfContext_EnumViews_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetStatus_Proxy( 
    ITfContext * This,
    /* [out] */ TF_STATUS *pdcs);


void __RPC_STUB ITfContext_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetProperty_Proxy( 
    ITfContext * This,
    /* [in] */ REFGUID guidProp,
    /* [out] */ ITfProperty **ppProp);


void __RPC_STUB ITfContext_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetAppProperty_Proxy( 
    ITfContext * This,
    /* [in] */ REFGUID guidProp,
    /* [out] */ ITfReadOnlyProperty **ppProp);


void __RPC_STUB ITfContext_GetAppProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_TrackProperties_Proxy( 
    ITfContext * This,
    /* [size_is][in] */ const GUID **prgProp,
    /* [in] */ ULONG cProp,
    /* [size_is][in] */ const GUID **prgAppProp,
    /* [in] */ ULONG cAppProp,
    /* [out] */ ITfReadOnlyProperty **ppProperty);


void __RPC_STUB ITfContext_TrackProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_EnumProperties_Proxy( 
    ITfContext * This,
    /* [out] */ IEnumTfProperties **ppEnum);


void __RPC_STUB ITfContext_EnumProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_GetDocumentMgr_Proxy( 
    ITfContext * This,
    /* [out] */ ITfDocumentMgr **ppDm);


void __RPC_STUB ITfContext_GetDocumentMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_CreateRangeBackup_Proxy( 
    ITfContext * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfRangeBackup **ppBackup);


void __RPC_STUB ITfContext_CreateRangeBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContext_INTERFACE_DEFINED__ */


#ifndef __ITfQueryEmbedded_INTERFACE_DEFINED__
#define __ITfQueryEmbedded_INTERFACE_DEFINED__

/* interface ITfQueryEmbedded */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfQueryEmbedded;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0fab9bdb-d250-4169-84e5-6be118fdd7a8")
    ITfQueryEmbedded : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryInsertEmbedded( 
            /* [in] */ const GUID *pguidService,
            /* [in] */ const FORMATETC *pFormatEtc,
            /* [out] */ BOOL *pfInsertable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfQueryEmbeddedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfQueryEmbedded * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfQueryEmbedded * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfQueryEmbedded * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInsertEmbedded )( 
            ITfQueryEmbedded * This,
            /* [in] */ const GUID *pguidService,
            /* [in] */ const FORMATETC *pFormatEtc,
            /* [out] */ BOOL *pfInsertable);
        
        END_INTERFACE
    } ITfQueryEmbeddedVtbl;

    interface ITfQueryEmbedded
    {
        CONST_VTBL struct ITfQueryEmbeddedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfQueryEmbedded_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfQueryEmbedded_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfQueryEmbedded_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfQueryEmbedded_QueryInsertEmbedded(This,pguidService,pFormatEtc,pfInsertable)	\
    (This)->lpVtbl -> QueryInsertEmbedded(This,pguidService,pFormatEtc,pfInsertable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfQueryEmbedded_QueryInsertEmbedded_Proxy( 
    ITfQueryEmbedded * This,
    /* [in] */ const GUID *pguidService,
    /* [in] */ const FORMATETC *pFormatEtc,
    /* [out] */ BOOL *pfInsertable);


void __RPC_STUB ITfQueryEmbedded_QueryInsertEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfQueryEmbedded_INTERFACE_DEFINED__ */


#ifndef __ITfInsertAtSelection_INTERFACE_DEFINED__
#define __ITfInsertAtSelection_INTERFACE_DEFINED__

/* interface ITfInsertAtSelection */
/* [unique][uuid][object] */ 

#define	TF_IAS_NOQUERY	( 0x1 )

#define	TF_IAS_QUERYONLY	( 0x2 )

#define	TF_IAS_NO_DEFAULT_COMPOSITION	( 0x80000000 )


EXTERN_C const IID IID_ITfInsertAtSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55ce16ba-3014-41c1-9ceb-fade1446ac6c")
    ITfInsertAtSelection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertTextAtSelection( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch,
            /* [out] */ ITfRange **ppRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEmbeddedAtSelection( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ ITfRange **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfInsertAtSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfInsertAtSelection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfInsertAtSelection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfInsertAtSelection * This);
        
        HRESULT ( STDMETHODCALLTYPE *InsertTextAtSelection )( 
            ITfInsertAtSelection * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch,
            /* [out] */ ITfRange **ppRange);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbeddedAtSelection )( 
            ITfInsertAtSelection * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject,
            /* [out] */ ITfRange **ppRange);
        
        END_INTERFACE
    } ITfInsertAtSelectionVtbl;

    interface ITfInsertAtSelection
    {
        CONST_VTBL struct ITfInsertAtSelectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfInsertAtSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfInsertAtSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfInsertAtSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfInsertAtSelection_InsertTextAtSelection(This,ec,dwFlags,pchText,cch,ppRange)	\
    (This)->lpVtbl -> InsertTextAtSelection(This,ec,dwFlags,pchText,cch,ppRange)

#define ITfInsertAtSelection_InsertEmbeddedAtSelection(This,ec,dwFlags,pDataObject,ppRange)	\
    (This)->lpVtbl -> InsertEmbeddedAtSelection(This,ec,dwFlags,pDataObject,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfInsertAtSelection_InsertTextAtSelection_Proxy( 
    ITfInsertAtSelection * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ const WCHAR *pchText,
    /* [in] */ LONG cch,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfInsertAtSelection_InsertTextAtSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInsertAtSelection_InsertEmbeddedAtSelection_Proxy( 
    ITfInsertAtSelection * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDataObject *pDataObject,
    /* [out] */ ITfRange **ppRange);


void __RPC_STUB ITfInsertAtSelection_InsertEmbeddedAtSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfInsertAtSelection_INTERFACE_DEFINED__ */


#ifndef __ITfCleanupContextSink_INTERFACE_DEFINED__
#define __ITfCleanupContextSink_INTERFACE_DEFINED__

/* interface ITfCleanupContextSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCleanupContextSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01689689-7acb-4e9b-ab7c-7ea46b12b522")
    ITfCleanupContextSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCleanupContext( 
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCleanupContextSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCleanupContextSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCleanupContextSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCleanupContextSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnCleanupContext )( 
            ITfCleanupContextSink * This,
            /* [in] */ TfEditCookie ecWrite,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfCleanupContextSinkVtbl;

    interface ITfCleanupContextSink
    {
        CONST_VTBL struct ITfCleanupContextSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCleanupContextSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCleanupContextSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCleanupContextSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCleanupContextSink_OnCleanupContext(This,ecWrite,pic)	\
    (This)->lpVtbl -> OnCleanupContext(This,ecWrite,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCleanupContextSink_OnCleanupContext_Proxy( 
    ITfCleanupContextSink * This,
    /* [in] */ TfEditCookie ecWrite,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfCleanupContextSink_OnCleanupContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCleanupContextSink_INTERFACE_DEFINED__ */


#ifndef __ITfCleanupContextDurationSink_INTERFACE_DEFINED__
#define __ITfCleanupContextDurationSink_INTERFACE_DEFINED__

/* interface ITfCleanupContextDurationSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCleanupContextDurationSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45c35144-154e-4797-bed8-d33ae7bf8794")
    ITfCleanupContextDurationSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartCleanupContext( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndCleanupContext( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCleanupContextDurationSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCleanupContextDurationSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCleanupContextDurationSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCleanupContextDurationSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartCleanupContext )( 
            ITfCleanupContextDurationSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndCleanupContext )( 
            ITfCleanupContextDurationSink * This);
        
        END_INTERFACE
    } ITfCleanupContextDurationSinkVtbl;

    interface ITfCleanupContextDurationSink
    {
        CONST_VTBL struct ITfCleanupContextDurationSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCleanupContextDurationSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCleanupContextDurationSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCleanupContextDurationSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCleanupContextDurationSink_OnStartCleanupContext(This)	\
    (This)->lpVtbl -> OnStartCleanupContext(This)

#define ITfCleanupContextDurationSink_OnEndCleanupContext(This)	\
    (This)->lpVtbl -> OnEndCleanupContext(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCleanupContextDurationSink_OnStartCleanupContext_Proxy( 
    ITfCleanupContextDurationSink * This);


void __RPC_STUB ITfCleanupContextDurationSink_OnStartCleanupContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCleanupContextDurationSink_OnEndCleanupContext_Proxy( 
    ITfCleanupContextDurationSink * This);


void __RPC_STUB ITfCleanupContextDurationSink_OnEndCleanupContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCleanupContextDurationSink_INTERFACE_DEFINED__ */


#ifndef __ITfReadOnlyProperty_INTERFACE_DEFINED__
#define __ITfReadOnlyProperty_INTERFACE_DEFINED__

/* interface ITfReadOnlyProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfReadOnlyProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17d49a3d-f8b8-4b2f-b254-52319dd64c53")
    ITfReadOnlyProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRanges( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ITfContext **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfReadOnlyPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfReadOnlyProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfReadOnlyProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfReadOnlyProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfReadOnlyProperty * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRanges )( 
            ITfReadOnlyProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfReadOnlyProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfReadOnlyProperty * This,
            /* [out] */ ITfContext **ppContext);
        
        END_INTERFACE
    } ITfReadOnlyPropertyVtbl;

    interface ITfReadOnlyProperty
    {
        CONST_VTBL struct ITfReadOnlyPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfReadOnlyProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfReadOnlyProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfReadOnlyProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfReadOnlyProperty_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfReadOnlyProperty_EnumRanges(This,ec,ppEnum,pTargetRange)	\
    (This)->lpVtbl -> EnumRanges(This,ec,ppEnum,pTargetRange)

#define ITfReadOnlyProperty_GetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,ec,pRange,pvarValue)

#define ITfReadOnlyProperty_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfReadOnlyProperty_GetType_Proxy( 
    ITfReadOnlyProperty * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfReadOnlyProperty_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfReadOnlyProperty_EnumRanges_Proxy( 
    ITfReadOnlyProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ IEnumTfRanges **ppEnum,
    /* [in] */ ITfRange *pTargetRange);


void __RPC_STUB ITfReadOnlyProperty_EnumRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfReadOnlyProperty_GetValue_Proxy( 
    ITfReadOnlyProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ITfReadOnlyProperty_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfReadOnlyProperty_GetContext_Proxy( 
    ITfReadOnlyProperty * This,
    /* [out] */ ITfContext **ppContext);


void __RPC_STUB ITfReadOnlyProperty_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfReadOnlyProperty_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0158 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("d678c645-eb6a-45c9-b4ee-0f3e3a991348") struct TF_PROPERTYVAL
    {
    GUID guidId;
    VARIANT varValue;
    } 	TF_PROPERTYVAL;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0158_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0158_v0_0_s_ifspec;

#ifndef __IEnumTfPropertyValue_INTERFACE_DEFINED__
#define __IEnumTfPropertyValue_INTERFACE_DEFINED__

/* interface IEnumTfPropertyValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfPropertyValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ed8981b-7c10-4d7d-9fb3-ab72e9c75f72")
    IEnumTfPropertyValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfPropertyValue **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_PROPERTYVAL *rgValues,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfPropertyValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfPropertyValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfPropertyValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfPropertyValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfPropertyValue * This,
            /* [out] */ IEnumTfPropertyValue **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfPropertyValue * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_PROPERTYVAL *rgValues,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfPropertyValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfPropertyValue * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfPropertyValueVtbl;

    interface IEnumTfPropertyValue
    {
        CONST_VTBL struct IEnumTfPropertyValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfPropertyValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfPropertyValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfPropertyValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfPropertyValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfPropertyValue_Next(This,ulCount,rgValues,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgValues,pcFetched)

#define IEnumTfPropertyValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfPropertyValue_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfPropertyValue_Clone_Proxy( 
    IEnumTfPropertyValue * This,
    /* [out] */ IEnumTfPropertyValue **ppEnum);


void __RPC_STUB IEnumTfPropertyValue_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfPropertyValue_Next_Proxy( 
    IEnumTfPropertyValue * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_PROPERTYVAL *rgValues,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfPropertyValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfPropertyValue_Reset_Proxy( 
    IEnumTfPropertyValue * This);


void __RPC_STUB IEnumTfPropertyValue_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfPropertyValue_Skip_Proxy( 
    IEnumTfPropertyValue * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfPropertyValue_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfPropertyValue_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTracker_INTERFACE_DEFINED__
#define __ITfMouseTracker_INTERFACE_DEFINED__

/* interface ITfMouseTracker */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTracker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09d146cd-a544-4132-925b-7afa8ef322d0")
    ITfMouseTracker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ ITfRange *range,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTracker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTracker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTracker * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTracker * This,
            /* [in] */ ITfRange *range,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTracker * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerVtbl;

    interface ITfMouseTracker
    {
        CONST_VTBL struct ITfMouseTrackerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTracker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTracker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTracker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTracker_AdviseMouseSink(This,range,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,range,pSink,pdwCookie)

#define ITfMouseTracker_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTracker_AdviseMouseSink_Proxy( 
    ITfMouseTracker * This,
    /* [in] */ ITfRange *range,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTracker_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTracker_UnadviseMouseSink_Proxy( 
    ITfMouseTracker * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTracker_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTracker_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTrackerACP_INTERFACE_DEFINED__
#define __ITfMouseTrackerACP_INTERFACE_DEFINED__

/* interface ITfMouseTrackerACP */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTrackerACP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3bdd78e2-c16e-47fd-b883-ce6facc1a208")
    ITfMouseTrackerACP : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ ITfRangeACP *range,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerACPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTrackerACP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTrackerACP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTrackerACP * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTrackerACP * This,
            /* [in] */ ITfRangeACP *range,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTrackerACP * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerACPVtbl;

    interface ITfMouseTrackerACP
    {
        CONST_VTBL struct ITfMouseTrackerACPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTrackerACP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTrackerACP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTrackerACP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTrackerACP_AdviseMouseSink(This,range,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,range,pSink,pdwCookie)

#define ITfMouseTrackerACP_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTrackerACP_AdviseMouseSink_Proxy( 
    ITfMouseTrackerACP * This,
    /* [in] */ ITfRangeACP *range,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTrackerACP_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTrackerACP_UnadviseMouseSink_Proxy( 
    ITfMouseTrackerACP * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTrackerACP_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTrackerACP_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_INTERFACE_DEFINED__
#define __ITfMouseTrackerAnchor_INTERFACE_DEFINED__

/* interface ITfMouseTrackerAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTrackerAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f9f4e0f2-d600-4a4c-b144-77e201ebd1b0")
    ITfMouseTrackerAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTrackerAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTrackerAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerAnchorVtbl;

    interface ITfMouseTrackerAnchor
    {
        CONST_VTBL struct ITfMouseTrackerAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTrackerAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTrackerAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTrackerAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTrackerAnchor_AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)

#define ITfMouseTrackerAnchor_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_AdviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_UnadviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTrackerAnchor_INTERFACE_DEFINED__ */


#ifndef __ITfMouseSink_INTERFACE_DEFINED__
#define __ITfMouseSink_INTERFACE_DEFINED__

/* interface ITfMouseSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfMouseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a1adaaa2-3a24-449d-ac96-5183e7f5c217")
    ITfMouseSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnMouseEvent( 
            /* [in] */ ULONG uEdge,
            /* [in] */ ULONG uQuadrant,
            /* [in] */ DWORD dwBtnStatus,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnMouseEvent )( 
            ITfMouseSink * This,
            /* [in] */ ULONG uEdge,
            /* [in] */ ULONG uQuadrant,
            /* [in] */ DWORD dwBtnStatus,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfMouseSinkVtbl;

    interface ITfMouseSink
    {
        CONST_VTBL struct ITfMouseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseSink_OnMouseEvent(This,uEdge,uQuadrant,dwBtnStatus,pfEaten)	\
    (This)->lpVtbl -> OnMouseEvent(This,uEdge,uQuadrant,dwBtnStatus,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseSink_OnMouseEvent_Proxy( 
    ITfMouseSink * This,
    /* [in] */ ULONG uEdge,
    /* [in] */ ULONG uQuadrant,
    /* [in] */ DWORD dwBtnStatus,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfMouseSink_OnMouseEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseSink_INTERFACE_DEFINED__ */


#ifndef __ITfEditRecord_INTERFACE_DEFINED__
#define __ITfEditRecord_INTERFACE_DEFINED__

/* interface ITfEditRecord */
/* [unique][uuid][object] */ 

#define	TF_GTP_INCL_TEXT	( 0x1 )


EXTERN_C const IID IID_ITfEditRecord;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("42d4d099-7c1a-4a89-b836-6c6f22160df0")
    ITfEditRecord : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSelectionStatus( 
            /* [out] */ BOOL *pfChanged) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextAndPropertyUpdates( 
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const GUID **prgProperties,
            /* [in] */ ULONG cProperties,
            /* [out] */ IEnumTfRanges **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfEditRecordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfEditRecord * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfEditRecord * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfEditRecord * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectionStatus )( 
            ITfEditRecord * This,
            /* [out] */ BOOL *pfChanged);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextAndPropertyUpdates )( 
            ITfEditRecord * This,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ const GUID **prgProperties,
            /* [in] */ ULONG cProperties,
            /* [out] */ IEnumTfRanges **ppEnum);
        
        END_INTERFACE
    } ITfEditRecordVtbl;

    interface ITfEditRecord
    {
        CONST_VTBL struct ITfEditRecordVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfEditRecord_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfEditRecord_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfEditRecord_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfEditRecord_GetSelectionStatus(This,pfChanged)	\
    (This)->lpVtbl -> GetSelectionStatus(This,pfChanged)

#define ITfEditRecord_GetTextAndPropertyUpdates(This,dwFlags,prgProperties,cProperties,ppEnum)	\
    (This)->lpVtbl -> GetTextAndPropertyUpdates(This,dwFlags,prgProperties,cProperties,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfEditRecord_GetSelectionStatus_Proxy( 
    ITfEditRecord * This,
    /* [out] */ BOOL *pfChanged);


void __RPC_STUB ITfEditRecord_GetSelectionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfEditRecord_GetTextAndPropertyUpdates_Proxy( 
    ITfEditRecord * This,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ const GUID **prgProperties,
    /* [in] */ ULONG cProperties,
    /* [out] */ IEnumTfRanges **ppEnum);


void __RPC_STUB ITfEditRecord_GetTextAndPropertyUpdates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfEditRecord_INTERFACE_DEFINED__ */


#ifndef __ITfTextEditSink_INTERFACE_DEFINED__
#define __ITfTextEditSink_INTERFACE_DEFINED__

/* interface ITfTextEditSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfTextEditSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8127d409-ccd3-4683-967a-b43d5b482bf7")
    ITfTextEditSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEndEdit( 
            /* [in] */ ITfContext *pic,
            /* [in] */ TfEditCookie ecReadOnly,
            /* [in] */ ITfEditRecord *pEditRecord) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfTextEditSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfTextEditSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfTextEditSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfTextEditSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndEdit )( 
            ITfTextEditSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ TfEditCookie ecReadOnly,
            /* [in] */ ITfEditRecord *pEditRecord);
        
        END_INTERFACE
    } ITfTextEditSinkVtbl;

    interface ITfTextEditSink
    {
        CONST_VTBL struct ITfTextEditSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfTextEditSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfTextEditSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfTextEditSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfTextEditSink_OnEndEdit(This,pic,ecReadOnly,pEditRecord)	\
    (This)->lpVtbl -> OnEndEdit(This,pic,ecReadOnly,pEditRecord)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfTextEditSink_OnEndEdit_Proxy( 
    ITfTextEditSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ TfEditCookie ecReadOnly,
    /* [in] */ ITfEditRecord *pEditRecord);


void __RPC_STUB ITfTextEditSink_OnEndEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfTextEditSink_INTERFACE_DEFINED__ */


#ifndef __ITfTextLayoutSink_INTERFACE_DEFINED__
#define __ITfTextLayoutSink_INTERFACE_DEFINED__

/* interface ITfTextLayoutSink */
/* [unique][uuid][object] */ 

typedef /* [public][public][uuid] */  DECLSPEC_UUID("603553cf-9edd-4cc1-9ecc-069e4a427734") 
enum __MIDL_ITfTextLayoutSink_0001
    {	TF_LC_CREATE	= 0,
	TF_LC_CHANGE	= 1,
	TF_LC_DESTROY	= 2
    } 	TfLayoutCode;


EXTERN_C const IID IID_ITfTextLayoutSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2af2d06a-dd5b-4927-a0b4-54f19c91fade")
    ITfTextLayoutSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLayoutChange( 
            /* [in] */ ITfContext *pic,
            /* [in] */ TfLayoutCode lcode,
            /* [in] */ ITfContextView *pView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfTextLayoutSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfTextLayoutSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfTextLayoutSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfTextLayoutSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLayoutChange )( 
            ITfTextLayoutSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ TfLayoutCode lcode,
            /* [in] */ ITfContextView *pView);
        
        END_INTERFACE
    } ITfTextLayoutSinkVtbl;

    interface ITfTextLayoutSink
    {
        CONST_VTBL struct ITfTextLayoutSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfTextLayoutSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfTextLayoutSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfTextLayoutSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfTextLayoutSink_OnLayoutChange(This,pic,lcode,pView)	\
    (This)->lpVtbl -> OnLayoutChange(This,pic,lcode,pView)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfTextLayoutSink_OnLayoutChange_Proxy( 
    ITfTextLayoutSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ TfLayoutCode lcode,
    /* [in] */ ITfContextView *pView);


void __RPC_STUB ITfTextLayoutSink_OnLayoutChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfTextLayoutSink_INTERFACE_DEFINED__ */


#ifndef __ITfStatusSink_INTERFACE_DEFINED__
#define __ITfStatusSink_INTERFACE_DEFINED__

/* interface ITfStatusSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfStatusSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6b7d8d73-b267-4f69-b32e-1ca321ce4f45")
    ITfStatusSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatusChange( 
            /* [in] */ ITfContext *pic,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfStatusSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfStatusSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfStatusSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfStatusSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatusChange )( 
            ITfStatusSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ITfStatusSinkVtbl;

    interface ITfStatusSink
    {
        CONST_VTBL struct ITfStatusSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfStatusSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfStatusSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfStatusSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfStatusSink_OnStatusChange(This,pic,dwFlags)	\
    (This)->lpVtbl -> OnStatusChange(This,pic,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfStatusSink_OnStatusChange_Proxy( 
    ITfStatusSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfStatusSink_OnStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfStatusSink_INTERFACE_DEFINED__ */


#ifndef __ITfEditTransactionSink_INTERFACE_DEFINED__
#define __ITfEditTransactionSink_INTERFACE_DEFINED__

/* interface ITfEditTransactionSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfEditTransactionSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("708fbf70-b520-416b-b06c-2c41ab44f8ba")
    ITfEditTransactionSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartEditTransaction( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndEditTransaction( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfEditTransactionSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfEditTransactionSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfEditTransactionSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfEditTransactionSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartEditTransaction )( 
            ITfEditTransactionSink * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndEditTransaction )( 
            ITfEditTransactionSink * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfEditTransactionSinkVtbl;

    interface ITfEditTransactionSink
    {
        CONST_VTBL struct ITfEditTransactionSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfEditTransactionSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfEditTransactionSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfEditTransactionSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfEditTransactionSink_OnStartEditTransaction(This,pic)	\
    (This)->lpVtbl -> OnStartEditTransaction(This,pic)

#define ITfEditTransactionSink_OnEndEditTransaction(This,pic)	\
    (This)->lpVtbl -> OnEndEditTransaction(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfEditTransactionSink_OnStartEditTransaction_Proxy( 
    ITfEditTransactionSink * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfEditTransactionSink_OnStartEditTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfEditTransactionSink_OnEndEditTransaction_Proxy( 
    ITfEditTransactionSink * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfEditTransactionSink_OnEndEditTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfEditTransactionSink_INTERFACE_DEFINED__ */


#ifndef __ITfContextOwner_INTERFACE_DEFINED__
#define __ITfContextOwner_INTERFACE_DEFINED__

/* interface ITfContextOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e80c-2021-11d2-93e0-0060b067b86e")
    ITfContextOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetACPFromPoint( 
            /* [in] */ const POINT *ptScreen,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LONG *pacp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextExt( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScreenExt( 
            /* [out] */ RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ TF_STATUS *pdcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWnd( 
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ REFGUID rguidAttribute,
            /* [out] */ VARIANT *pvarValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextOwner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextOwner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetACPFromPoint )( 
            ITfContextOwner * This,
            /* [in] */ const POINT *ptScreen,
            /* [in] */ DWORD dwFlags,
            /* [out] */ LONG *pacp);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextExt )( 
            ITfContextOwner * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ RECT *prc,
            /* [out] */ BOOL *pfClipped);
        
        HRESULT ( STDMETHODCALLTYPE *GetScreenExt )( 
            ITfContextOwner * This,
            /* [out] */ RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfContextOwner * This,
            /* [out] */ TF_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *GetWnd )( 
            ITfContextOwner * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            ITfContextOwner * This,
            /* [in] */ REFGUID rguidAttribute,
            /* [out] */ VARIANT *pvarValue);
        
        END_INTERFACE
    } ITfContextOwnerVtbl;

    interface ITfContextOwner
    {
        CONST_VTBL struct ITfContextOwnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextOwner_GetACPFromPoint(This,ptScreen,dwFlags,pacp)	\
    (This)->lpVtbl -> GetACPFromPoint(This,ptScreen,dwFlags,pacp)

#define ITfContextOwner_GetTextExt(This,acpStart,acpEnd,prc,pfClipped)	\
    (This)->lpVtbl -> GetTextExt(This,acpStart,acpEnd,prc,pfClipped)

#define ITfContextOwner_GetScreenExt(This,prc)	\
    (This)->lpVtbl -> GetScreenExt(This,prc)

#define ITfContextOwner_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITfContextOwner_GetWnd(This,phwnd)	\
    (This)->lpVtbl -> GetWnd(This,phwnd)

#define ITfContextOwner_GetAttribute(This,rguidAttribute,pvarValue)	\
    (This)->lpVtbl -> GetAttribute(This,rguidAttribute,pvarValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextOwner_GetACPFromPoint_Proxy( 
    ITfContextOwner * This,
    /* [in] */ const POINT *ptScreen,
    /* [in] */ DWORD dwFlags,
    /* [out] */ LONG *pacp);


void __RPC_STUB ITfContextOwner_GetACPFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetTextExt_Proxy( 
    ITfContextOwner * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [out] */ RECT *prc,
    /* [out] */ BOOL *pfClipped);


void __RPC_STUB ITfContextOwner_GetTextExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetScreenExt_Proxy( 
    ITfContextOwner * This,
    /* [out] */ RECT *prc);


void __RPC_STUB ITfContextOwner_GetScreenExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetStatus_Proxy( 
    ITfContextOwner * This,
    /* [out] */ TF_STATUS *pdcs);


void __RPC_STUB ITfContextOwner_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetWnd_Proxy( 
    ITfContextOwner * This,
    /* [out] */ HWND *phwnd);


void __RPC_STUB ITfContextOwner_GetWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwner_GetAttribute_Proxy( 
    ITfContextOwner * This,
    /* [in] */ REFGUID rguidAttribute,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ITfContextOwner_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextOwner_INTERFACE_DEFINED__ */


#ifndef __ITfContextOwnerServices_INTERFACE_DEFINED__
#define __ITfContextOwnerServices_INTERFACE_DEFINED__

/* interface ITfContextOwnerServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContextOwnerServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b23eb630-3e1c-11d3-a745-0050040ab407")
    ITfContextOwnerServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLayoutChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatusChange( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAttributeChange( 
            /* [in] */ REFGUID rguidAttribute) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderACP *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ ITfRangeACP **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextOwnerServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextOwnerServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextOwnerServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextOwnerServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLayoutChange )( 
            ITfContextOwnerServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatusChange )( 
            ITfContextOwnerServices * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OnAttributeChange )( 
            ITfContextOwnerServices * This,
            /* [in] */ REFGUID rguidAttribute);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITfContextOwnerServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITfContextOwnerServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderACP *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITfContextOwnerServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITfContextOwnerServices * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ ITfRangeACP **ppRange);
        
        END_INTERFACE
    } ITfContextOwnerServicesVtbl;

    interface ITfContextOwnerServices
    {
        CONST_VTBL struct ITfContextOwnerServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextOwnerServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextOwnerServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextOwnerServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextOwnerServices_OnLayoutChange(This)	\
    (This)->lpVtbl -> OnLayoutChange(This)

#define ITfContextOwnerServices_OnStatusChange(This,dwFlags)	\
    (This)->lpVtbl -> OnStatusChange(This,dwFlags)

#define ITfContextOwnerServices_OnAttributeChange(This,rguidAttribute)	\
    (This)->lpVtbl -> OnAttributeChange(This,rguidAttribute)

#define ITfContextOwnerServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITfContextOwnerServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITfContextOwnerServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITfContextOwnerServices_CreateRange(This,acpStart,acpEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,acpStart,acpEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_OnLayoutChange_Proxy( 
    ITfContextOwnerServices * This);


void __RPC_STUB ITfContextOwnerServices_OnLayoutChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_OnStatusChange_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfContextOwnerServices_OnStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_OnAttributeChange_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ REFGUID rguidAttribute);


void __RPC_STUB ITfContextOwnerServices_OnAttributeChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_Serialize_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITfContextOwnerServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_Unserialize_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderACP *pLoader);


void __RPC_STUB ITfContextOwnerServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_ForceLoadProperty_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITfContextOwnerServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextOwnerServices_CreateRange_Proxy( 
    ITfContextOwnerServices * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [out] */ ITfRangeACP **ppRange);


void __RPC_STUB ITfContextOwnerServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextOwnerServices_INTERFACE_DEFINED__ */


#ifndef __ITfContextKeyEventSink_INTERFACE_DEFINED__
#define __ITfContextKeyEventSink_INTERFACE_DEFINED__

/* interface ITfContextKeyEventSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfContextKeyEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0552ba5d-c835-4934-bf50-846aaa67432f")
    ITfContextKeyEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnKeyDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTestKeyDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTestKeyUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextKeyEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextKeyEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextKeyEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextKeyEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyDown )( 
            ITfContextKeyEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyUp )( 
            ITfContextKeyEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnTestKeyDown )( 
            ITfContextKeyEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnTestKeyUp )( 
            ITfContextKeyEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfContextKeyEventSinkVtbl;

    interface ITfContextKeyEventSink
    {
        CONST_VTBL struct ITfContextKeyEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextKeyEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextKeyEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextKeyEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextKeyEventSink_OnKeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnKeyDown(This,wParam,lParam,pfEaten)

#define ITfContextKeyEventSink_OnKeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnKeyUp(This,wParam,lParam,pfEaten)

#define ITfContextKeyEventSink_OnTestKeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnTestKeyDown(This,wParam,lParam,pfEaten)

#define ITfContextKeyEventSink_OnTestKeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnTestKeyUp(This,wParam,lParam,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextKeyEventSink_OnKeyDown_Proxy( 
    ITfContextKeyEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfContextKeyEventSink_OnKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextKeyEventSink_OnKeyUp_Proxy( 
    ITfContextKeyEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfContextKeyEventSink_OnKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextKeyEventSink_OnTestKeyDown_Proxy( 
    ITfContextKeyEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfContextKeyEventSink_OnTestKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextKeyEventSink_OnTestKeyUp_Proxy( 
    ITfContextKeyEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfContextKeyEventSink_OnTestKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextKeyEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfEditSession_INTERFACE_DEFINED__
#define __ITfEditSession_INTERFACE_DEFINED__

/* interface ITfEditSession */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfEditSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e803-2021-11d2-93e0-0060b067b86e")
    ITfEditSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EditSession( 
            /* [in] */ TfEditCookie ec) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfEditSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfEditSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfEditSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfEditSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *EditSession )( 
            ITfEditSession * This,
            /* [in] */ TfEditCookie ec);
        
        END_INTERFACE
    } ITfEditSessionVtbl;

    interface ITfEditSession
    {
        CONST_VTBL struct ITfEditSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfEditSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfEditSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfEditSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfEditSession_EditSession(This,ec)	\
    (This)->lpVtbl -> EditSession(This,ec)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfEditSession_EditSession_Proxy( 
    ITfEditSession * This,
    /* [in] */ TfEditCookie ec);


void __RPC_STUB ITfEditSession_EditSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfEditSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0172 */
/* [local] */ 

#define	TF_TD_CORRECTION	( 1 )

typedef /* [uuid] */  DECLSPEC_UUID("2b9f8421-ea29-4904-8668-2eca2083ca61") struct TF_TEXTDELTA
    {
    ITfRange *pRange;
    DWORD dwFlags;
    LONG lOldLen;
    } 	TF_TEXTDELTA;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0172_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0172_v0_0_s_ifspec;

#ifndef __IEnumTfTextDeltas_INTERFACE_DEFINED__
#define __IEnumTfTextDeltas_INTERFACE_DEFINED__

/* interface IEnumTfTextDeltas */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfTextDeltas;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e807-2021-11d2-93e0-0060b067b86e")
    IEnumTfTextDeltas : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfTextDeltas **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_TEXTDELTA *rgTextDelta,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfTextDeltasVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfTextDeltas * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfTextDeltas * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfTextDeltas * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfTextDeltas * This,
            /* [out] */ IEnumTfTextDeltas **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfTextDeltas * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_TEXTDELTA *rgTextDelta,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfTextDeltas * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfTextDeltas * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfTextDeltasVtbl;

    interface IEnumTfTextDeltas
    {
        CONST_VTBL struct IEnumTfTextDeltasVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfTextDeltas_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfTextDeltas_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfTextDeltas_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfTextDeltas_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfTextDeltas_Next(This,ulCount,rgTextDelta,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgTextDelta,pcFetched)

#define IEnumTfTextDeltas_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfTextDeltas_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfTextDeltas_Clone_Proxy( 
    IEnumTfTextDeltas * This,
    /* [out] */ IEnumTfTextDeltas **ppEnum);


void __RPC_STUB IEnumTfTextDeltas_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfTextDeltas_Next_Proxy( 
    IEnumTfTextDeltas * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_TEXTDELTA *rgTextDelta,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfTextDeltas_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfTextDeltas_Reset_Proxy( 
    IEnumTfTextDeltas * This);


void __RPC_STUB IEnumTfTextDeltas_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfTextDeltas_Skip_Proxy( 
    IEnumTfTextDeltas * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfTextDeltas_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfTextDeltas_INTERFACE_DEFINED__ */


#ifndef __ITfRange_INTERFACE_DEFINED__
#define __ITfRange_INTERFACE_DEFINED__

/* interface ITfRange */
/* [unique][uuid][object] */ 

#define	TF_CHAR_EMBEDDED	( TS_CHAR_EMBEDDED )

typedef /* [public][public][public][public][public][uuid] */  DECLSPEC_UUID("cf610f06-2882-46f6-abe5-298568b664c4") 
enum __MIDL_ITfRange_0001
    {	TF_GRAVITY_BACKWARD	= 0,
	TF_GRAVITY_FORWARD	= 1
    } 	TfGravity;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("1e512533-bbdc-4530-9a8e-a1dc0af67468") 
enum __MIDL_ITfRange_0002
    {	TF_SD_BACKWARD	= 0,
	TF_SD_FORWARD	= 1
    } 	TfShiftDir;

#define	TF_HF_OBJECT	( 1 )

#define	TF_TF_MOVESTART	( 1 )

#define	TF_TF_IGNOREEND	( 2 )

#define	TF_ST_CORRECTION	( 1 )

#define	TF_IE_CORRECTION	( 1 )

typedef /* [uuid] */  DECLSPEC_UUID("49930d51-7d93-448c-a48c-fea5dac192b1") struct TF_HALTCOND
    {
    ITfRange *pHaltRange;
    TfAnchor aHaltPos;
    DWORD dwFlags;
    } 	TF_HALTCOND;


EXTERN_C const IID IID_ITfRange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7ff-2021-11d2-93e0-0060b067b86e")
    ITfRange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormattedText( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbedded( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEmbedded( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftStart( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftEnd( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftStartToRange( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftEndToRange( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftStartRegion( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShiftEndRegion( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEmpty( 
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Collapse( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqualStart( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqualEnd( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareStart( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareEnd( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdjustForInsert( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGravity( 
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGravity( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ITfRange **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ITfContext **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRange * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRange * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRange * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRange * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRange * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRange * This,
            /* [out] */ ITfContext **ppContext);
        
        END_INTERFACE
    } ITfRangeVtbl;

    interface ITfRange
    {
        CONST_VTBL struct ITfRangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRange_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRange_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRange_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRange_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRange_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRange_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRange_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRange_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRange_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRange_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRange_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRange_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRange_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRange_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRange_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRange_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRange_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRange_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRange_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRange_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRange_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRange_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRange_GetText_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [length_is][size_is][out] */ WCHAR *pchText,
    /* [in] */ ULONG cchMax,
    /* [out] */ ULONG *pcch);


void __RPC_STUB ITfRange_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_SetText_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [unique][size_is][in] */ const WCHAR *pchText,
    /* [in] */ LONG cch);


void __RPC_STUB ITfRange_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_GetFormattedText_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ IDataObject **ppDataObject);


void __RPC_STUB ITfRange_GetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_GetEmbedded_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ REFGUID rguidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppunk);


void __RPC_STUB ITfRange_GetEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_InsertEmbedded_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDataObject *pDataObject);


void __RPC_STUB ITfRange_InsertEmbedded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftStart_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ LONG cchReq,
    /* [out] */ LONG *pcch,
    /* [unique][in] */ const TF_HALTCOND *pHalt);


void __RPC_STUB ITfRange_ShiftStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftEnd_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ LONG cchReq,
    /* [out] */ LONG *pcch,
    /* [unique][in] */ const TF_HALTCOND *pHalt);


void __RPC_STUB ITfRange_ShiftEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftStartToRange_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [in] */ TfAnchor aPos);


void __RPC_STUB ITfRange_ShiftStartToRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftEndToRange_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [in] */ TfAnchor aPos);


void __RPC_STUB ITfRange_ShiftEndToRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftStartRegion_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ TfShiftDir dir,
    /* [out] */ BOOL *pfNoRegion);


void __RPC_STUB ITfRange_ShiftStartRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_ShiftEndRegion_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ TfShiftDir dir,
    /* [out] */ BOOL *pfNoRegion);


void __RPC_STUB ITfRange_ShiftEndRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_IsEmpty_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [out] */ BOOL *pfEmpty);


void __RPC_STUB ITfRange_IsEmpty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_Collapse_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ TfAnchor aPos);


void __RPC_STUB ITfRange_Collapse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_IsEqualStart_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pWith,
    /* [in] */ TfAnchor aPos,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB ITfRange_IsEqualStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_IsEqualEnd_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pWith,
    /* [in] */ TfAnchor aPos,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB ITfRange_IsEqualEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_CompareStart_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pWith,
    /* [in] */ TfAnchor aPos,
    /* [out] */ LONG *plResult);


void __RPC_STUB ITfRange_CompareStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_CompareEnd_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pWith,
    /* [in] */ TfAnchor aPos,
    /* [out] */ LONG *plResult);


void __RPC_STUB ITfRange_CompareEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_AdjustForInsert_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ULONG cchInsert,
    /* [out] */ BOOL *pfInsertOk);


void __RPC_STUB ITfRange_AdjustForInsert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_GetGravity_Proxy( 
    ITfRange * This,
    /* [out] */ TfGravity *pgStart,
    /* [out] */ TfGravity *pgEnd);


void __RPC_STUB ITfRange_GetGravity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_SetGravity_Proxy( 
    ITfRange * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ TfGravity gStart,
    /* [in] */ TfGravity gEnd);


void __RPC_STUB ITfRange_SetGravity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_Clone_Proxy( 
    ITfRange * This,
    /* [out] */ ITfRange **ppClone);


void __RPC_STUB ITfRange_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRange_GetContext_Proxy( 
    ITfRange * This,
    /* [out] */ ITfContext **ppContext);


void __RPC_STUB ITfRange_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRange_INTERFACE_DEFINED__ */


#ifndef __ITfRangeACP_INTERFACE_DEFINED__
#define __ITfRangeACP_INTERFACE_DEFINED__

/* interface ITfRangeACP */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeACP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("057a6296-029b-4154-b79a-0d461d4ea94c")
    ITfRangeACP : public ITfRange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtent( 
            /* [out] */ LONG *pacpAnchor,
            /* [out] */ LONG *pcch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtent( 
            /* [in] */ LONG acpAnchor,
            /* [in] */ LONG cch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeACPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeACP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeACP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeACP * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRangeACP * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRangeACP * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRangeACP * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRangeACP * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtent )( 
            ITfRangeACP * This,
            /* [out] */ LONG *pacpAnchor,
            /* [out] */ LONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtent )( 
            ITfRangeACP * This,
            /* [in] */ LONG acpAnchor,
            /* [in] */ LONG cch);
        
        END_INTERFACE
    } ITfRangeACPVtbl;

    interface ITfRangeACP
    {
        CONST_VTBL struct ITfRangeACPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeACP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeACP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeACP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeACP_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRangeACP_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRangeACP_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRangeACP_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRangeACP_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRangeACP_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRangeACP_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRangeACP_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRangeACP_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRangeACP_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRangeACP_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRangeACP_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRangeACP_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRangeACP_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRangeACP_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRangeACP_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRangeACP_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRangeACP_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRangeACP_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRangeACP_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRangeACP_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRangeACP_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfRangeACP_GetExtent(This,pacpAnchor,pcch)	\
    (This)->lpVtbl -> GetExtent(This,pacpAnchor,pcch)

#define ITfRangeACP_SetExtent(This,acpAnchor,cch)	\
    (This)->lpVtbl -> SetExtent(This,acpAnchor,cch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeACP_GetExtent_Proxy( 
    ITfRangeACP * This,
    /* [out] */ LONG *pacpAnchor,
    /* [out] */ LONG *pcch);


void __RPC_STUB ITfRangeACP_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRangeACP_SetExtent_Proxy( 
    ITfRangeACP * This,
    /* [in] */ LONG acpAnchor,
    /* [in] */ LONG cch);


void __RPC_STUB ITfRangeACP_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeACP_INTERFACE_DEFINED__ */


#ifndef __ITfRangeAnchor_INTERFACE_DEFINED__
#define __ITfRangeAnchor_INTERFACE_DEFINED__

/* interface ITfRangeAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8b99712b-5815-4bcc-b9a9-53db1c8d6755")
    ITfRangeAnchor : public ITfRange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtent( 
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtent( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRangeAnchor * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtent )( 
            ITfRangeAnchor * This,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtent )( 
            ITfRangeAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd);
        
        END_INTERFACE
    } ITfRangeAnchorVtbl;

    interface ITfRangeAnchor
    {
        CONST_VTBL struct ITfRangeAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeAnchor_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRangeAnchor_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRangeAnchor_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRangeAnchor_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRangeAnchor_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRangeAnchor_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRangeAnchor_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRangeAnchor_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRangeAnchor_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRangeAnchor_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRangeAnchor_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRangeAnchor_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfRangeAnchor_GetExtent(This,ppaStart,ppaEnd)	\
    (This)->lpVtbl -> GetExtent(This,ppaStart,ppaEnd)

#define ITfRangeAnchor_SetExtent(This,paStart,paEnd)	\
    (This)->lpVtbl -> SetExtent(This,paStart,paEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeAnchor_GetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [out] */ IAnchor **ppaStart,
    /* [out] */ IAnchor **ppaEnd);


void __RPC_STUB ITfRangeAnchor_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRangeAnchor_SetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd);


void __RPC_STUB ITfRangeAnchor_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeAnchor_INTERFACE_DEFINED__ */


#ifndef __ITextStoreACPServices_INTERFACE_DEFINED__
#define __ITextStoreACPServices_INTERFACE_DEFINED__

/* interface ITextStoreACPServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreACPServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e901-2021-11d2-93e0-0060b067b86e")
    ITextStoreACPServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderACP *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ ITfRangeACP **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreACPServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreACPServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreACPServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreACPServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITextStoreACPServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITextStoreACPServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderACP *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITextStoreACPServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITextStoreACPServices * This,
            /* [in] */ LONG acpStart,
            /* [in] */ LONG acpEnd,
            /* [out] */ ITfRangeACP **ppRange);
        
        END_INTERFACE
    } ITextStoreACPServicesVtbl;

    interface ITextStoreACPServices
    {
        CONST_VTBL struct ITextStoreACPServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreACPServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreACPServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreACPServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreACPServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITextStoreACPServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITextStoreACPServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITextStoreACPServices_CreateRange(This,acpStart,acpEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,acpStart,acpEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreACPServices_Serialize_Proxy( 
    ITextStoreACPServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITextStoreACPServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPServices_Unserialize_Proxy( 
    ITextStoreACPServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderACP *pLoader);


void __RPC_STUB ITextStoreACPServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPServices_ForceLoadProperty_Proxy( 
    ITextStoreACPServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITextStoreACPServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreACPServices_CreateRange_Proxy( 
    ITextStoreACPServices * This,
    /* [in] */ LONG acpStart,
    /* [in] */ LONG acpEnd,
    /* [out] */ ITfRangeACP **ppRange);


void __RPC_STUB ITextStoreACPServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreACPServices_INTERFACE_DEFINED__ */


#ifndef __ITextStoreAnchorServices_INTERFACE_DEFINED__
#define __ITextStoreAnchorServices_INTERFACE_DEFINED__

/* interface ITextStoreAnchorServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreAnchorServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e9fe-2021-11d2-93e0-0060b067b86e")
    ITextStoreAnchorServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreAnchorServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreAnchorServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreAnchorServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreAnchorServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITextStoreAnchorServices * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange);
        
        END_INTERFACE
    } ITextStoreAnchorServicesVtbl;

    interface ITextStoreAnchorServices
    {
        CONST_VTBL struct ITextStoreAnchorServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreAnchorServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreAnchorServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreAnchorServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreAnchorServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITextStoreAnchorServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITextStoreAnchorServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITextStoreAnchorServices_CreateRange(This,paStart,paEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,paStart,paEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Serialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITextStoreAnchorServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Unserialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);


void __RPC_STUB ITextStoreAnchorServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_ForceLoadProperty_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITextStoreAnchorServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_CreateRange_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [out] */ ITfRangeAnchor **ppRange);


void __RPC_STUB ITextStoreAnchorServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreAnchorServices_INTERFACE_DEFINED__ */


#ifndef __ITfRangeBackup_INTERFACE_DEFINED__
#define __ITfRangeBackup_INTERFACE_DEFINED__

/* interface ITfRangeBackup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("463a506d-6992-49d2-9b88-93d55e70bb16")
    ITfRangeBackup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeBackup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeBackup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeBackup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            ITfRangeBackup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfRangeBackupVtbl;

    interface ITfRangeBackup
    {
        CONST_VTBL struct ITfRangeBackupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeBackup_Restore(This,ec,pRange)	\
    (This)->lpVtbl -> Restore(This,ec,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeBackup_Restore_Proxy( 
    ITfRangeBackup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfRangeBackup_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeBackup_INTERFACE_DEFINED__ */


#ifndef __ITfPropertyStore_INTERFACE_DEFINED__
#define __ITfPropertyStore_INTERFACE_DEFINED__

/* interface ITfPropertyStore */
/* [unique][uuid][object] */ 

#define	TF_TU_CORRECTION	( 0x1 )


EXTERN_C const IID IID_ITfPropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6834b120-88cb-11d2-bf45-00105a2799b5")
    ITfPropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataType( 
            /* [out] */ TfPropertyType *ptype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTextUpdated( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ BOOL *pfAccept) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ BOOL *pfFree) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Divide( 
            /* [in] */ ITfRange *pRangeThis,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ ITfPropertyStore **ppPropStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ITfPropertyStore **pPropStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyRangeCreator( 
            /* [out] */ CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ IStream *pStream,
            /* [out] */ ULONG *pcb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPropertyStore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfPropertyStore * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataType )( 
            ITfPropertyStore * This,
            /* [out] */ TfPropertyType *ptype);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            ITfPropertyStore * This,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *OnTextUpdated )( 
            ITfPropertyStore * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ BOOL *pfAccept);
        
        HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            ITfPropertyStore * This,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ BOOL *pfFree);
        
        HRESULT ( STDMETHODCALLTYPE *Divide )( 
            ITfPropertyStore * This,
            /* [in] */ ITfRange *pRangeThis,
            /* [in] */ ITfRange *pRangeNew,
            /* [out] */ ITfPropertyStore **ppPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfPropertyStore * This,
            /* [out] */ ITfPropertyStore **pPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyRangeCreator )( 
            ITfPropertyStore * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITfPropertyStore * This,
            /* [in] */ IStream *pStream,
            /* [out] */ ULONG *pcb);
        
        END_INTERFACE
    } ITfPropertyStoreVtbl;

    interface ITfPropertyStore
    {
        CONST_VTBL struct ITfPropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPropertyStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPropertyStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPropertyStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPropertyStore_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfPropertyStore_GetDataType(This,ptype)	\
    (This)->lpVtbl -> GetDataType(This,ptype)

#define ITfPropertyStore_GetData(This,pvarValue)	\
    (This)->lpVtbl -> GetData(This,pvarValue)

#define ITfPropertyStore_OnTextUpdated(This,dwFlags,pRangeNew,pfAccept)	\
    (This)->lpVtbl -> OnTextUpdated(This,dwFlags,pRangeNew,pfAccept)

#define ITfPropertyStore_Shrink(This,pRangeNew,pfFree)	\
    (This)->lpVtbl -> Shrink(This,pRangeNew,pfFree)

#define ITfPropertyStore_Divide(This,pRangeThis,pRangeNew,ppPropStore)	\
    (This)->lpVtbl -> Divide(This,pRangeThis,pRangeNew,ppPropStore)

#define ITfPropertyStore_Clone(This,pPropStore)	\
    (This)->lpVtbl -> Clone(This,pPropStore)

#define ITfPropertyStore_GetPropertyRangeCreator(This,pclsid)	\
    (This)->lpVtbl -> GetPropertyRangeCreator(This,pclsid)

#define ITfPropertyStore_Serialize(This,pStream,pcb)	\
    (This)->lpVtbl -> Serialize(This,pStream,pcb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPropertyStore_GetType_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfPropertyStore_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_GetDataType_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ TfPropertyType *ptype);


void __RPC_STUB ITfPropertyStore_GetDataType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_GetData_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ITfPropertyStore_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_OnTextUpdated_Proxy( 
    ITfPropertyStore * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeNew,
    /* [out] */ BOOL *pfAccept);


void __RPC_STUB ITfPropertyStore_OnTextUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_Shrink_Proxy( 
    ITfPropertyStore * This,
    /* [in] */ ITfRange *pRangeNew,
    /* [out] */ BOOL *pfFree);


void __RPC_STUB ITfPropertyStore_Shrink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_Divide_Proxy( 
    ITfPropertyStore * This,
    /* [in] */ ITfRange *pRangeThis,
    /* [in] */ ITfRange *pRangeNew,
    /* [out] */ ITfPropertyStore **ppPropStore);


void __RPC_STUB ITfPropertyStore_Divide_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_Clone_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ ITfPropertyStore **pPropStore);


void __RPC_STUB ITfPropertyStore_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_GetPropertyRangeCreator_Proxy( 
    ITfPropertyStore * This,
    /* [out] */ CLSID *pclsid);


void __RPC_STUB ITfPropertyStore_GetPropertyRangeCreator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfPropertyStore_Serialize_Proxy( 
    ITfPropertyStore * This,
    /* [in] */ IStream *pStream,
    /* [out] */ ULONG *pcb);


void __RPC_STUB ITfPropertyStore_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPropertyStore_INTERFACE_DEFINED__ */


#ifndef __IEnumTfRanges_INTERFACE_DEFINED__
#define __IEnumTfRanges_INTERFACE_DEFINED__

/* interface IEnumTfRanges */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfRanges;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f99d3f40-8e32-11d2-bf46-00105a2799b5")
    IEnumTfRanges : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfRanges **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfRange **ppRange,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfRangesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfRanges * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfRanges * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfRanges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfRanges * This,
            /* [out] */ IEnumTfRanges **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfRanges * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfRange **ppRange,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfRanges * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfRanges * This,
            ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfRangesVtbl;

    interface IEnumTfRanges
    {
        CONST_VTBL struct IEnumTfRangesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfRanges_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfRanges_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfRanges_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfRanges_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfRanges_Next(This,ulCount,ppRange,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,ppRange,pcFetched)

#define IEnumTfRanges_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfRanges_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfRanges_Clone_Proxy( 
    IEnumTfRanges * This,
    /* [out] */ IEnumTfRanges **ppEnum);


void __RPC_STUB IEnumTfRanges_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRanges_Next_Proxy( 
    IEnumTfRanges * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfRange **ppRange,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfRanges_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRanges_Reset_Proxy( 
    IEnumTfRanges * This);


void __RPC_STUB IEnumTfRanges_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRanges_Skip_Proxy( 
    IEnumTfRanges * This,
    ULONG ulCount);


void __RPC_STUB IEnumTfRanges_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfRanges_INTERFACE_DEFINED__ */


#ifndef __ITfCreatePropertyStore_INTERFACE_DEFINED__
#define __ITfCreatePropertyStore_INTERFACE_DEFINED__

/* interface ITfCreatePropertyStore */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCreatePropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2463fbf0-b0af-11d2-afc5-00105a2799b5")
    ITfCreatePropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsStoreSerializable( 
            /* [in] */ REFGUID guidProp,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore,
            /* [out] */ BOOL *pfSerializable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyStore( 
            /* [in] */ REFGUID guidProp,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ULONG cb,
            /* [in] */ IStream *pStream,
            /* [out] */ ITfPropertyStore **ppStore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCreatePropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCreatePropertyStore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCreatePropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCreatePropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsStoreSerializable )( 
            ITfCreatePropertyStore * This,
            /* [in] */ REFGUID guidProp,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore,
            /* [out] */ BOOL *pfSerializable);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertyStore )( 
            ITfCreatePropertyStore * This,
            /* [in] */ REFGUID guidProp,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ULONG cb,
            /* [in] */ IStream *pStream,
            /* [out] */ ITfPropertyStore **ppStore);
        
        END_INTERFACE
    } ITfCreatePropertyStoreVtbl;

    interface ITfCreatePropertyStore
    {
        CONST_VTBL struct ITfCreatePropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCreatePropertyStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCreatePropertyStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCreatePropertyStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCreatePropertyStore_IsStoreSerializable(This,guidProp,pRange,pPropStore,pfSerializable)	\
    (This)->lpVtbl -> IsStoreSerializable(This,guidProp,pRange,pPropStore,pfSerializable)

#define ITfCreatePropertyStore_CreatePropertyStore(This,guidProp,pRange,cb,pStream,ppStore)	\
    (This)->lpVtbl -> CreatePropertyStore(This,guidProp,pRange,cb,pStream,ppStore)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCreatePropertyStore_IsStoreSerializable_Proxy( 
    ITfCreatePropertyStore * This,
    /* [in] */ REFGUID guidProp,
    /* [in] */ ITfRange *pRange,
    /* [in] */ ITfPropertyStore *pPropStore,
    /* [out] */ BOOL *pfSerializable);


void __RPC_STUB ITfCreatePropertyStore_IsStoreSerializable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCreatePropertyStore_CreatePropertyStore_Proxy( 
    ITfCreatePropertyStore * This,
    /* [in] */ REFGUID guidProp,
    /* [in] */ ITfRange *pRange,
    /* [in] */ ULONG cb,
    /* [in] */ IStream *pStream,
    /* [out] */ ITfPropertyStore **ppStore);


void __RPC_STUB ITfCreatePropertyStore_CreatePropertyStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCreatePropertyStore_INTERFACE_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderACP_INTERFACE_DEFINED__
#define __ITfPersistentPropertyLoaderACP_INTERFACE_DEFINED__

/* interface ITfPersistentPropertyLoaderACP */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPersistentPropertyLoaderACP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4ef89150-0807-11d3-8df0-00105a2799b5")
    ITfPersistentPropertyLoaderACP : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadProperty( 
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [out] */ IStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPersistentPropertyLoaderACPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPersistentPropertyLoaderACP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPersistentPropertyLoaderACP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPersistentPropertyLoaderACP * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProperty )( 
            ITfPersistentPropertyLoaderACP * This,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
            /* [out] */ IStream **ppStream);
        
        END_INTERFACE
    } ITfPersistentPropertyLoaderACPVtbl;

    interface ITfPersistentPropertyLoaderACP
    {
        CONST_VTBL struct ITfPersistentPropertyLoaderACPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPersistentPropertyLoaderACP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPersistentPropertyLoaderACP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPersistentPropertyLoaderACP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPersistentPropertyLoaderACP_LoadProperty(This,pHdr,ppStream)	\
    (This)->lpVtbl -> LoadProperty(This,pHdr,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPersistentPropertyLoaderACP_LoadProperty_Proxy( 
    ITfPersistentPropertyLoaderACP * This,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ACP *pHdr,
    /* [out] */ IStream **ppStream);


void __RPC_STUB ITfPersistentPropertyLoaderACP_LoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPersistentPropertyLoaderACP_INTERFACE_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__

/* interface ITfPersistentPropertyLoaderAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPersistentPropertyLoaderAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2133f790-34c2-11d3-a745-0050040ab407")
    ITfPersistentPropertyLoaderAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadProperty( 
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPersistentPropertyLoaderAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProperty )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream);
        
        END_INTERFACE
    } ITfPersistentPropertyLoaderAnchorVtbl;

    interface ITfPersistentPropertyLoaderAnchor
    {
        CONST_VTBL struct ITfPersistentPropertyLoaderAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPersistentPropertyLoaderAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPersistentPropertyLoaderAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPersistentPropertyLoaderAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPersistentPropertyLoaderAnchor_LoadProperty(This,pHdr,ppStream)	\
    (This)->lpVtbl -> LoadProperty(This,pHdr,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPersistentPropertyLoaderAnchor_LoadProperty_Proxy( 
    ITfPersistentPropertyLoaderAnchor * This,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [out] */ IStream **ppStream);


void __RPC_STUB ITfPersistentPropertyLoaderAnchor_LoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__ */


#ifndef __ITfProperty_INTERFACE_DEFINED__
#define __ITfProperty_INTERFACE_DEFINED__

/* interface ITfProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e2449660-9542-11d2-bf46-00105a2799b5")
    ITfProperty : public ITfReadOnlyProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindRange( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppRange,
            /* [in] */ TfAnchor aPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueStore( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfProperty * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRanges )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfProperty * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *FindRange )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueStore )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITfProperty * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfPropertyVtbl;

    interface ITfProperty
    {
        CONST_VTBL struct ITfPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfProperty_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfProperty_EnumRanges(This,ec,ppEnum,pTargetRange)	\
    (This)->lpVtbl -> EnumRanges(This,ec,ppEnum,pTargetRange)

#define ITfProperty_GetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,ec,pRange,pvarValue)

#define ITfProperty_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfProperty_FindRange(This,ec,pRange,ppRange,aPos)	\
    (This)->lpVtbl -> FindRange(This,ec,pRange,ppRange,aPos)

#define ITfProperty_SetValueStore(This,ec,pRange,pPropStore)	\
    (This)->lpVtbl -> SetValueStore(This,ec,pRange,pPropStore)

#define ITfProperty_SetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,ec,pRange,pvarValue)

#define ITfProperty_Clear(This,ec,pRange)	\
    (This)->lpVtbl -> Clear(This,ec,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfProperty_FindRange_Proxy( 
    ITfProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfRange **ppRange,
    /* [in] */ TfAnchor aPos);


void __RPC_STUB ITfProperty_FindRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfProperty_SetValueStore_Proxy( 
    ITfProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [in] */ ITfPropertyStore *pPropStore);


void __RPC_STUB ITfProperty_SetValueStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfProperty_SetValue_Proxy( 
    ITfProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange,
    /* [in] */ VARIANT *pvarValue);


void __RPC_STUB ITfProperty_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfProperty_Clear_Proxy( 
    ITfProperty * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfProperty_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumTfProperties_INTERFACE_DEFINED__
#define __IEnumTfProperties_INTERFACE_DEFINED__

/* interface IEnumTfProperties */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19188cb0-aca9-11d2-afc5-00105a2799b5")
    IEnumTfProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfProperties **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfProperty **ppProp,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfProperties * This,
            /* [out] */ IEnumTfProperties **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfProperties * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfProperty **ppProp,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfProperties * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfPropertiesVtbl;

    interface IEnumTfProperties
    {
        CONST_VTBL struct IEnumTfPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfProperties_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfProperties_Next(This,ulCount,ppProp,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,ppProp,pcFetched)

#define IEnumTfProperties_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfProperties_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfProperties_Clone_Proxy( 
    IEnumTfProperties * This,
    /* [out] */ IEnumTfProperties **ppEnum);


void __RPC_STUB IEnumTfProperties_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfProperties_Next_Proxy( 
    IEnumTfProperties * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfProperty **ppProp,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfProperties_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfProperties_Reset_Proxy( 
    IEnumTfProperties * This);


void __RPC_STUB IEnumTfProperties_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfProperties_Skip_Proxy( 
    IEnumTfProperties * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfProperties_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfProperties_INTERFACE_DEFINED__ */


#ifndef __ITfCompartment_INTERFACE_DEFINED__
#define __ITfCompartment_INTERFACE_DEFINED__

/* interface ITfCompartment */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bb08f7a9-607a-4384-8623-056892b64371")
    ITfCompartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ TfClientId tid,
            /* [in] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ VARIANT *pvarValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompartment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompartment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompartment * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ITfCompartment * This,
            /* [in] */ TfClientId tid,
            /* [in] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfCompartment * This,
            /* [out] */ VARIANT *pvarValue);
        
        END_INTERFACE
    } ITfCompartmentVtbl;

    interface ITfCompartment
    {
        CONST_VTBL struct ITfCompartmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompartment_SetValue(This,tid,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,tid,pvarValue)

#define ITfCompartment_GetValue(This,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,pvarValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompartment_SetValue_Proxy( 
    ITfCompartment * This,
    /* [in] */ TfClientId tid,
    /* [in] */ VARIANT *pvarValue);


void __RPC_STUB ITfCompartment_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCompartment_GetValue_Proxy( 
    ITfCompartment * This,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ITfCompartment_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompartment_INTERFACE_DEFINED__ */


#ifndef __ITfCompartmentEventSink_INTERFACE_DEFINED__
#define __ITfCompartmentEventSink_INTERFACE_DEFINED__

/* interface ITfCompartmentEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompartmentEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("743abd5f-f26d-48df-8cc5-238492419b64")
    ITfCompartmentEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnChange( 
            /* [in] */ REFGUID rguid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompartmentEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompartmentEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompartmentEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompartmentEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            ITfCompartmentEventSink * This,
            /* [in] */ REFGUID rguid);
        
        END_INTERFACE
    } ITfCompartmentEventSinkVtbl;

    interface ITfCompartmentEventSink
    {
        CONST_VTBL struct ITfCompartmentEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompartmentEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompartmentEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompartmentEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompartmentEventSink_OnChange(This,rguid)	\
    (This)->lpVtbl -> OnChange(This,rguid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompartmentEventSink_OnChange_Proxy( 
    ITfCompartmentEventSink * This,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCompartmentEventSink_OnChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompartmentEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfCompartmentMgr_INTERFACE_DEFINED__
#define __ITfCompartmentMgr_INTERFACE_DEFINED__

/* interface ITfCompartmentMgr */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCompartmentMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7dcf57ac-18ad-438b-824d-979bffb74b7c")
    ITfCompartmentMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCompartment( 
            /* [in] */ REFGUID rguid,
            /* [out] */ ITfCompartment **ppcomp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearCompartment( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCompartments( 
            /* [out] */ IEnumGUID **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCompartmentMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCompartmentMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCompartmentMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCompartmentMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompartment )( 
            ITfCompartmentMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ ITfCompartment **ppcomp);
        
        HRESULT ( STDMETHODCALLTYPE *ClearCompartment )( 
            ITfCompartmentMgr * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCompartments )( 
            ITfCompartmentMgr * This,
            /* [out] */ IEnumGUID **ppEnum);
        
        END_INTERFACE
    } ITfCompartmentMgrVtbl;

    interface ITfCompartmentMgr
    {
        CONST_VTBL struct ITfCompartmentMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCompartmentMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCompartmentMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCompartmentMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCompartmentMgr_GetCompartment(This,rguid,ppcomp)	\
    (This)->lpVtbl -> GetCompartment(This,rguid,ppcomp)

#define ITfCompartmentMgr_ClearCompartment(This,tid,rguid)	\
    (This)->lpVtbl -> ClearCompartment(This,tid,rguid)

#define ITfCompartmentMgr_EnumCompartments(This,ppEnum)	\
    (This)->lpVtbl -> EnumCompartments(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCompartmentMgr_GetCompartment_Proxy( 
    ITfCompartmentMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ ITfCompartment **ppcomp);


void __RPC_STUB ITfCompartmentMgr_GetCompartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCompartmentMgr_ClearCompartment_Proxy( 
    ITfCompartmentMgr * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCompartmentMgr_ClearCompartment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCompartmentMgr_EnumCompartments_Proxy( 
    ITfCompartmentMgr * This,
    /* [out] */ IEnumGUID **ppEnum);


void __RPC_STUB ITfCompartmentMgr_EnumCompartments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCompartmentMgr_INTERFACE_DEFINED__ */


#ifndef __ITfFunction_INTERFACE_DEFINED__
#define __ITfFunction_INTERFACE_DEFINED__

/* interface ITfFunction */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFunction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("db593490-098f-11d3-8df0-00105a2799b5")
    ITfFunction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFunctionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFunction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFunction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFunction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFunction * This,
            /* [out] */ BSTR *pbstrName);
        
        END_INTERFACE
    } ITfFunctionVtbl;

    interface ITfFunction
    {
        CONST_VTBL struct ITfFunctionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFunction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFunction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFunction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFunction_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFunction_GetDisplayName_Proxy( 
    ITfFunction * This,
    /* [out] */ BSTR *pbstrName);


void __RPC_STUB ITfFunction_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFunction_INTERFACE_DEFINED__ */


#ifndef __ITfFunctionProvider_INTERFACE_DEFINED__
#define __ITfFunctionProvider_INTERFACE_DEFINED__

/* interface ITfFunctionProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFunctionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("101d6610-0990-11d3-8df0-00105a2799b5")
    ITfFunctionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ BSTR *pbstrDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [in] */ REFGUID rguid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFunctionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFunctionProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFunctionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFunctionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfFunctionProvider * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ITfFunctionProvider * This,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ITfFunctionProvider * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        END_INTERFACE
    } ITfFunctionProviderVtbl;

    interface ITfFunctionProvider
    {
        CONST_VTBL struct ITfFunctionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFunctionProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFunctionProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFunctionProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFunctionProvider_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfFunctionProvider_GetDescription(This,pbstrDesc)	\
    (This)->lpVtbl -> GetDescription(This,pbstrDesc)

#define ITfFunctionProvider_GetFunction(This,rguid,riid,ppunk)	\
    (This)->lpVtbl -> GetFunction(This,rguid,riid,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFunctionProvider_GetType_Proxy( 
    ITfFunctionProvider * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfFunctionProvider_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFunctionProvider_GetDescription_Proxy( 
    ITfFunctionProvider * This,
    /* [out] */ BSTR *pbstrDesc);


void __RPC_STUB ITfFunctionProvider_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFunctionProvider_GetFunction_Proxy( 
    ITfFunctionProvider * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppunk);


void __RPC_STUB ITfFunctionProvider_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFunctionProvider_INTERFACE_DEFINED__ */


#ifndef __IEnumTfFunctionProviders_INTERFACE_DEFINED__
#define __IEnumTfFunctionProviders_INTERFACE_DEFINED__

/* interface IEnumTfFunctionProviders */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfFunctionProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e4b24db0-0990-11d3-8df0-00105a2799b5")
    IEnumTfFunctionProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfFunctionProviders **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfFunctionProvider **ppCmdobj,
            /* [out] */ ULONG *pcFetch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfFunctionProvidersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfFunctionProviders * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfFunctionProviders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfFunctionProviders * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfFunctionProviders * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfFunctionProviders * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfFunctionProvider **ppCmdobj,
            /* [out] */ ULONG *pcFetch);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfFunctionProviders * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfFunctionProviders * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfFunctionProvidersVtbl;

    interface IEnumTfFunctionProviders
    {
        CONST_VTBL struct IEnumTfFunctionProvidersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfFunctionProviders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfFunctionProviders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfFunctionProviders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfFunctionProviders_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfFunctionProviders_Next(This,ulCount,ppCmdobj,pcFetch)	\
    (This)->lpVtbl -> Next(This,ulCount,ppCmdobj,pcFetch)

#define IEnumTfFunctionProviders_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfFunctionProviders_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfFunctionProviders_Clone_Proxy( 
    IEnumTfFunctionProviders * This,
    /* [out] */ IEnumTfFunctionProviders **ppEnum);


void __RPC_STUB IEnumTfFunctionProviders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfFunctionProviders_Next_Proxy( 
    IEnumTfFunctionProviders * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfFunctionProvider **ppCmdobj,
    /* [out] */ ULONG *pcFetch);


void __RPC_STUB IEnumTfFunctionProviders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfFunctionProviders_Reset_Proxy( 
    IEnumTfFunctionProviders * This);


void __RPC_STUB IEnumTfFunctionProviders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfFunctionProviders_Skip_Proxy( 
    IEnumTfFunctionProviders * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfFunctionProviders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfFunctionProviders_INTERFACE_DEFINED__ */


#ifndef __ITfInputProcessorProfiles_INTERFACE_DEFINED__
#define __ITfInputProcessorProfiles_INTERFACE_DEFINED__

/* interface ITfInputProcessorProfiles */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfInputProcessorProfiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1F02B6C5-7842-4EE6-8A0B-9A24183A95CA")
    ITfInputProcessorProfiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unregister( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc,
            /* [size_is][in] */ const WCHAR *pchIconFile,
            /* [in] */ ULONG cchFile,
            /* [in] */ ULONG uIconIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputProcessorInfo( 
            /* [out] */ IEnumGUID **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultLanguageProfile( 
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID catid,
            /* [out] */ CLSID *pclsid,
            /* [out] */ GUID *pguidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultLanguageProfile( 
            /* [in] */ LANGID langid,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID guidProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ LANGID *plangid,
            /* [out] */ GUID *pguidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageProfileDescription( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ BSTR *pbstrProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLanguage( 
            /* [out] */ LANGID *plangid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeCurrentLanguage( 
            /* [in] */ LANGID langid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageList( 
            /* [out] */ LANGID **ppLangId,
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumLanguageProfiles( 
            /* [in] */ LANGID langid,
            /* [out] */ IEnumTfLanguageProfiles **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEnabledLanguageProfile( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ BOOL *pfEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableLanguageProfileByDefault( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubstituteKeyboardLayout( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ HKL hKL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfInputProcessorProfilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfInputProcessorProfiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfInputProcessorProfiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *Unregister )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *AddLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc,
            /* [size_is][in] */ const WCHAR *pchIconFile,
            /* [in] */ ULONG cchFile,
            /* [in] */ ULONG uIconIndex);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputProcessorInfo )( 
            ITfInputProcessorProfiles * This,
            /* [out] */ IEnumGUID **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID catid,
            /* [out] */ CLSID *pclsid,
            /* [out] */ GUID *pguidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ LANGID langid,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID guidProfiles);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfiles);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ LANGID *plangid,
            /* [out] */ GUID *pguidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageProfileDescription )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ BSTR *pbstrProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLanguage )( 
            ITfInputProcessorProfiles * This,
            /* [out] */ LANGID *plangid);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeCurrentLanguage )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ LANGID langid);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageList )( 
            ITfInputProcessorProfiles * This,
            /* [out] */ LANGID **ppLangId,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *EnumLanguageProfiles )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ LANGID langid,
            /* [out] */ IEnumTfLanguageProfiles **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnableLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabledLanguageProfile )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ BOOL *pfEnable);
        
        HRESULT ( STDMETHODCALLTYPE *EnableLanguageProfileByDefault )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *SubstituteKeyboardLayout )( 
            ITfInputProcessorProfiles * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ HKL hKL);
        
        END_INTERFACE
    } ITfInputProcessorProfilesVtbl;

    interface ITfInputProcessorProfiles
    {
        CONST_VTBL struct ITfInputProcessorProfilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfInputProcessorProfiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfInputProcessorProfiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfInputProcessorProfiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfInputProcessorProfiles_Register(This,rclsid)	\
    (This)->lpVtbl -> Register(This,rclsid)

#define ITfInputProcessorProfiles_Unregister(This,rclsid)	\
    (This)->lpVtbl -> Unregister(This,rclsid)

#define ITfInputProcessorProfiles_AddLanguageProfile(This,rclsid,langid,guidProfile,pchDesc,cchDesc,pchIconFile,cchFile,uIconIndex)	\
    (This)->lpVtbl -> AddLanguageProfile(This,rclsid,langid,guidProfile,pchDesc,cchDesc,pchIconFile,cchFile,uIconIndex)

#define ITfInputProcessorProfiles_RemoveLanguageProfile(This,rclsid,langid,guidProfile)	\
    (This)->lpVtbl -> RemoveLanguageProfile(This,rclsid,langid,guidProfile)

#define ITfInputProcessorProfiles_EnumInputProcessorInfo(This,ppEnum)	\
    (This)->lpVtbl -> EnumInputProcessorInfo(This,ppEnum)

#define ITfInputProcessorProfiles_GetDefaultLanguageProfile(This,langid,catid,pclsid,pguidProfile)	\
    (This)->lpVtbl -> GetDefaultLanguageProfile(This,langid,catid,pclsid,pguidProfile)

#define ITfInputProcessorProfiles_SetDefaultLanguageProfile(This,langid,rclsid,guidProfiles)	\
    (This)->lpVtbl -> SetDefaultLanguageProfile(This,langid,rclsid,guidProfiles)

#define ITfInputProcessorProfiles_ActivateLanguageProfile(This,rclsid,langid,guidProfiles)	\
    (This)->lpVtbl -> ActivateLanguageProfile(This,rclsid,langid,guidProfiles)

#define ITfInputProcessorProfiles_GetActiveLanguageProfile(This,rclsid,plangid,pguidProfile)	\
    (This)->lpVtbl -> GetActiveLanguageProfile(This,rclsid,plangid,pguidProfile)

#define ITfInputProcessorProfiles_GetLanguageProfileDescription(This,rclsid,langid,guidProfile,pbstrProfile)	\
    (This)->lpVtbl -> GetLanguageProfileDescription(This,rclsid,langid,guidProfile,pbstrProfile)

#define ITfInputProcessorProfiles_GetCurrentLanguage(This,plangid)	\
    (This)->lpVtbl -> GetCurrentLanguage(This,plangid)

#define ITfInputProcessorProfiles_ChangeCurrentLanguage(This,langid)	\
    (This)->lpVtbl -> ChangeCurrentLanguage(This,langid)

#define ITfInputProcessorProfiles_GetLanguageList(This,ppLangId,pulCount)	\
    (This)->lpVtbl -> GetLanguageList(This,ppLangId,pulCount)

#define ITfInputProcessorProfiles_EnumLanguageProfiles(This,langid,ppEnum)	\
    (This)->lpVtbl -> EnumLanguageProfiles(This,langid,ppEnum)

#define ITfInputProcessorProfiles_EnableLanguageProfile(This,rclsid,langid,guidProfile,fEnable)	\
    (This)->lpVtbl -> EnableLanguageProfile(This,rclsid,langid,guidProfile,fEnable)

#define ITfInputProcessorProfiles_IsEnabledLanguageProfile(This,rclsid,langid,guidProfile,pfEnable)	\
    (This)->lpVtbl -> IsEnabledLanguageProfile(This,rclsid,langid,guidProfile,pfEnable)

#define ITfInputProcessorProfiles_EnableLanguageProfileByDefault(This,rclsid,langid,guidProfile,fEnable)	\
    (This)->lpVtbl -> EnableLanguageProfileByDefault(This,rclsid,langid,guidProfile,fEnable)

#define ITfInputProcessorProfiles_SubstituteKeyboardLayout(This,rclsid,langid,guidProfile,hKL)	\
    (This)->lpVtbl -> SubstituteKeyboardLayout(This,rclsid,langid,guidProfile,hKL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_Register_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ITfInputProcessorProfiles_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_Unregister_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB ITfInputProcessorProfiles_Unregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_AddLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cchDesc,
    /* [size_is][in] */ const WCHAR *pchIconFile,
    /* [in] */ ULONG cchFile,
    /* [in] */ ULONG uIconIndex);


void __RPC_STUB ITfInputProcessorProfiles_AddLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_RemoveLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB ITfInputProcessorProfiles_RemoveLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_EnumInputProcessorInfo_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [out] */ IEnumGUID **ppEnum);


void __RPC_STUB ITfInputProcessorProfiles_EnumInputProcessorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetDefaultLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID catid,
    /* [out] */ CLSID *pclsid,
    /* [out] */ GUID *pguidProfile);


void __RPC_STUB ITfInputProcessorProfiles_GetDefaultLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_SetDefaultLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ LANGID langid,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID guidProfiles);


void __RPC_STUB ITfInputProcessorProfiles_SetDefaultLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_ActivateLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfiles);


void __RPC_STUB ITfInputProcessorProfiles_ActivateLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetActiveLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ LANGID *plangid,
    /* [out] */ GUID *pguidProfile);


void __RPC_STUB ITfInputProcessorProfiles_GetActiveLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetLanguageProfileDescription_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [out] */ BSTR *pbstrProfile);


void __RPC_STUB ITfInputProcessorProfiles_GetLanguageProfileDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetCurrentLanguage_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [out] */ LANGID *plangid);


void __RPC_STUB ITfInputProcessorProfiles_GetCurrentLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_ChangeCurrentLanguage_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ LANGID langid);


void __RPC_STUB ITfInputProcessorProfiles_ChangeCurrentLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_GetLanguageList_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [out] */ LANGID **ppLangId,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB ITfInputProcessorProfiles_GetLanguageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_EnumLanguageProfiles_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ LANGID langid,
    /* [out] */ IEnumTfLanguageProfiles **ppEnum);


void __RPC_STUB ITfInputProcessorProfiles_EnumLanguageProfiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_EnableLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [in] */ BOOL fEnable);


void __RPC_STUB ITfInputProcessorProfiles_EnableLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_IsEnabledLanguageProfile_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [out] */ BOOL *pfEnable);


void __RPC_STUB ITfInputProcessorProfiles_IsEnabledLanguageProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_EnableLanguageProfileByDefault_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [in] */ BOOL fEnable);


void __RPC_STUB ITfInputProcessorProfiles_EnableLanguageProfileByDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfInputProcessorProfiles_SubstituteKeyboardLayout_Proxy( 
    ITfInputProcessorProfiles * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID guidProfile,
    /* [in] */ HKL hKL);


void __RPC_STUB ITfInputProcessorProfiles_SubstituteKeyboardLayout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfInputProcessorProfiles_INTERFACE_DEFINED__ */


#ifndef __ITfActiveLanguageProfileNotifySink_INTERFACE_DEFINED__
#define __ITfActiveLanguageProfileNotifySink_INTERFACE_DEFINED__

/* interface ITfActiveLanguageProfileNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfActiveLanguageProfileNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b246cb75-a93e-4652-bf8c-b3fe0cfd7e57")
    ITfActiveLanguageProfileNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnActivated( 
            /* [in] */ REFCLSID clsid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fActivated) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfActiveLanguageProfileNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfActiveLanguageProfileNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfActiveLanguageProfileNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfActiveLanguageProfileNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnActivated )( 
            ITfActiveLanguageProfileNotifySink * This,
            /* [in] */ REFCLSID clsid,
            /* [in] */ REFGUID guidProfile,
            /* [in] */ BOOL fActivated);
        
        END_INTERFACE
    } ITfActiveLanguageProfileNotifySinkVtbl;

    interface ITfActiveLanguageProfileNotifySink
    {
        CONST_VTBL struct ITfActiveLanguageProfileNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfActiveLanguageProfileNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfActiveLanguageProfileNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfActiveLanguageProfileNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfActiveLanguageProfileNotifySink_OnActivated(This,clsid,guidProfile,fActivated)	\
    (This)->lpVtbl -> OnActivated(This,clsid,guidProfile,fActivated)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfActiveLanguageProfileNotifySink_OnActivated_Proxy( 
    ITfActiveLanguageProfileNotifySink * This,
    /* [in] */ REFCLSID clsid,
    /* [in] */ REFGUID guidProfile,
    /* [in] */ BOOL fActivated);


void __RPC_STUB ITfActiveLanguageProfileNotifySink_OnActivated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfActiveLanguageProfileNotifySink_INTERFACE_DEFINED__ */


#ifndef __IEnumTfLanguageProfiles_INTERFACE_DEFINED__
#define __IEnumTfLanguageProfiles_INTERFACE_DEFINED__

/* interface IEnumTfLanguageProfiles */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfLanguageProfiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d61bf11-ac5f-42c8-a4cb-931bcc28c744")
    IEnumTfLanguageProfiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfLanguageProfiles **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_LANGUAGEPROFILE *pProfile,
            /* [out] */ ULONG *pcFetch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfLanguageProfilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfLanguageProfiles * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfLanguageProfiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfLanguageProfiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfLanguageProfiles * This,
            /* [out] */ IEnumTfLanguageProfiles **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfLanguageProfiles * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_LANGUAGEPROFILE *pProfile,
            /* [out] */ ULONG *pcFetch);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfLanguageProfiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfLanguageProfiles * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfLanguageProfilesVtbl;

    interface IEnumTfLanguageProfiles
    {
        CONST_VTBL struct IEnumTfLanguageProfilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfLanguageProfiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfLanguageProfiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfLanguageProfiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfLanguageProfiles_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfLanguageProfiles_Next(This,ulCount,pProfile,pcFetch)	\
    (This)->lpVtbl -> Next(This,ulCount,pProfile,pcFetch)

#define IEnumTfLanguageProfiles_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfLanguageProfiles_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfLanguageProfiles_Clone_Proxy( 
    IEnumTfLanguageProfiles * This,
    /* [out] */ IEnumTfLanguageProfiles **ppEnum);


void __RPC_STUB IEnumTfLanguageProfiles_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLanguageProfiles_Next_Proxy( 
    IEnumTfLanguageProfiles * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_LANGUAGEPROFILE *pProfile,
    /* [out] */ ULONG *pcFetch);


void __RPC_STUB IEnumTfLanguageProfiles_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLanguageProfiles_Reset_Proxy( 
    IEnumTfLanguageProfiles * This);


void __RPC_STUB IEnumTfLanguageProfiles_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLanguageProfiles_Skip_Proxy( 
    IEnumTfLanguageProfiles * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfLanguageProfiles_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfLanguageProfiles_INTERFACE_DEFINED__ */


#ifndef __ITfLanguageProfileNotifySink_INTERFACE_DEFINED__
#define __ITfLanguageProfileNotifySink_INTERFACE_DEFINED__

/* interface ITfLanguageProfileNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLanguageProfileNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43c9fe15-f494-4c17-9de2-b8a4ac350aa8")
    ITfLanguageProfileNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLanguageChange( 
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccept) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLanguageChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLanguageProfileNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLanguageProfileNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLanguageProfileNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLanguageProfileNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLanguageChange )( 
            ITfLanguageProfileNotifySink * This,
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccept);
        
        HRESULT ( STDMETHODCALLTYPE *OnLanguageChanged )( 
            ITfLanguageProfileNotifySink * This);
        
        END_INTERFACE
    } ITfLanguageProfileNotifySinkVtbl;

    interface ITfLanguageProfileNotifySink
    {
        CONST_VTBL struct ITfLanguageProfileNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLanguageProfileNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLanguageProfileNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLanguageProfileNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLanguageProfileNotifySink_OnLanguageChange(This,langid,pfAccept)	\
    (This)->lpVtbl -> OnLanguageChange(This,langid,pfAccept)

#define ITfLanguageProfileNotifySink_OnLanguageChanged(This)	\
    (This)->lpVtbl -> OnLanguageChanged(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLanguageProfileNotifySink_OnLanguageChange_Proxy( 
    ITfLanguageProfileNotifySink * This,
    /* [in] */ LANGID langid,
    /* [out] */ BOOL *pfAccept);


void __RPC_STUB ITfLanguageProfileNotifySink_OnLanguageChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLanguageProfileNotifySink_OnLanguageChanged_Proxy( 
    ITfLanguageProfileNotifySink * This);


void __RPC_STUB ITfLanguageProfileNotifySink_OnLanguageChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLanguageProfileNotifySink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0196 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("77c12f95-b783-450d-879f-1cd2362c6521") struct TF_PRESERVEDKEY
    {
    UINT uVKey;
    UINT uModifiers;
    } 	TF_PRESERVEDKEY;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0196_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0196_v0_0_s_ifspec;

#ifndef __ITfKeystrokeMgr_INTERFACE_DEFINED__
#define __ITfKeystrokeMgr_INTERFACE_DEFINED__

/* interface ITfKeystrokeMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfKeystrokeMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7f0-2021-11d2-93e0-0060b067b86e")
    ITfKeystrokeMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseKeyEventSink( 
            /* [in] */ TfClientId tid,
            /* [in] */ ITfKeyEventSink *pSink,
            /* [in] */ BOOL fForeground) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseKeyEventSink( 
            /* [in] */ TfClientId tid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForeground( 
            /* [out] */ CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestKeyDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestKeyUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreservedKey( 
            /* [in] */ ITfContext *pic,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPreservedKey( 
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ BOOL *pfRegistered) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreserveKey( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnpreserveKey( 
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPreservedKeyDescription( 
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreservedKeyDescription( 
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulatePreservedKey( 
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfKeystrokeMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfKeystrokeMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfKeystrokeMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseKeyEventSink )( 
            ITfKeystrokeMgr * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfKeyEventSink *pSink,
            /* [in] */ BOOL fForeground);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseKeyEventSink )( 
            ITfKeystrokeMgr * This,
            /* [in] */ TfClientId tid);
        
        HRESULT ( STDMETHODCALLTYPE *GetForeground )( 
            ITfKeystrokeMgr * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *TestKeyDown )( 
            ITfKeystrokeMgr * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *TestKeyUp )( 
            ITfKeystrokeMgr * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *KeyDown )( 
            ITfKeystrokeMgr * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *KeyUp )( 
            ITfKeystrokeMgr * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreservedKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreservedKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ BOOL *pfRegistered);
        
        HRESULT ( STDMETHODCALLTYPE *PreserveKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc);
        
        HRESULT ( STDMETHODCALLTYPE *UnpreserveKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreservedKeyDescription )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreservedKeyDescription )( 
            ITfKeystrokeMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *SimulatePreservedKey )( 
            ITfKeystrokeMgr * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfKeystrokeMgrVtbl;

    interface ITfKeystrokeMgr
    {
        CONST_VTBL struct ITfKeystrokeMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfKeystrokeMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfKeystrokeMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfKeystrokeMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfKeystrokeMgr_AdviseKeyEventSink(This,tid,pSink,fForeground)	\
    (This)->lpVtbl -> AdviseKeyEventSink(This,tid,pSink,fForeground)

#define ITfKeystrokeMgr_UnadviseKeyEventSink(This,tid)	\
    (This)->lpVtbl -> UnadviseKeyEventSink(This,tid)

#define ITfKeystrokeMgr_GetForeground(This,pclsid)	\
    (This)->lpVtbl -> GetForeground(This,pclsid)

#define ITfKeystrokeMgr_TestKeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> TestKeyDown(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_TestKeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> TestKeyUp(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_KeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> KeyDown(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_KeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> KeyUp(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_GetPreservedKey(This,pic,pprekey,pguid)	\
    (This)->lpVtbl -> GetPreservedKey(This,pic,pprekey,pguid)

#define ITfKeystrokeMgr_IsPreservedKey(This,rguid,pprekey,pfRegistered)	\
    (This)->lpVtbl -> IsPreservedKey(This,rguid,pprekey,pfRegistered)

#define ITfKeystrokeMgr_PreserveKey(This,tid,rguid,prekey,pchDesc,cchDesc)	\
    (This)->lpVtbl -> PreserveKey(This,tid,rguid,prekey,pchDesc,cchDesc)

#define ITfKeystrokeMgr_UnpreserveKey(This,rguid,pprekey)	\
    (This)->lpVtbl -> UnpreserveKey(This,rguid,pprekey)

#define ITfKeystrokeMgr_SetPreservedKeyDescription(This,rguid,pchDesc,cchDesc)	\
    (This)->lpVtbl -> SetPreservedKeyDescription(This,rguid,pchDesc,cchDesc)

#define ITfKeystrokeMgr_GetPreservedKeyDescription(This,rguid,pbstrDesc)	\
    (This)->lpVtbl -> GetPreservedKeyDescription(This,rguid,pbstrDesc)

#define ITfKeystrokeMgr_SimulatePreservedKey(This,pic,rguid,pfEaten)	\
    (This)->lpVtbl -> SimulatePreservedKey(This,pic,rguid,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_AdviseKeyEventSink_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ TfClientId tid,
    /* [in] */ ITfKeyEventSink *pSink,
    /* [in] */ BOOL fForeground);


void __RPC_STUB ITfKeystrokeMgr_AdviseKeyEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_UnadviseKeyEventSink_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ TfClientId tid);


void __RPC_STUB ITfKeystrokeMgr_UnadviseKeyEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_GetForeground_Proxy( 
    ITfKeystrokeMgr * This,
    /* [out] */ CLSID *pclsid);


void __RPC_STUB ITfKeystrokeMgr_GetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_TestKeyDown_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_TestKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_TestKeyUp_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_TestKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_KeyDown_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_KeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_KeyUp_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_KeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_GetPreservedKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ const TF_PRESERVEDKEY *pprekey,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfKeystrokeMgr_GetPreservedKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_IsPreservedKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ const TF_PRESERVEDKEY *pprekey,
    /* [out] */ BOOL *pfRegistered);


void __RPC_STUB ITfKeystrokeMgr_IsPreservedKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_PreserveKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFGUID rguid,
    /* [in] */ const TF_PRESERVEDKEY *prekey,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cchDesc);


void __RPC_STUB ITfKeystrokeMgr_PreserveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_UnpreserveKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ const TF_PRESERVEDKEY *pprekey);


void __RPC_STUB ITfKeystrokeMgr_UnpreserveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_SetPreservedKeyDescription_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ REFGUID rguid,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cchDesc);


void __RPC_STUB ITfKeystrokeMgr_SetPreservedKeyDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_GetPreservedKeyDescription_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ BSTR *pbstrDesc);


void __RPC_STUB ITfKeystrokeMgr_GetPreservedKeyDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_SimulatePreservedKey_Proxy( 
    ITfKeystrokeMgr * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ REFGUID rguid,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_SimulatePreservedKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfKeystrokeMgr_INTERFACE_DEFINED__ */


#ifndef __ITfKeyEventSink_INTERFACE_DEFINED__
#define __ITfKeyEventSink_INTERFACE_DEFINED__

/* interface ITfKeyEventSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfKeyEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7f5-2021-11d2-93e0-0060b067b86e")
    ITfKeyEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSetFocus( 
            /* [in] */ BOOL fForeground) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTestKeyDown( 
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTestKeyUp( 
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyDown( 
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyUp( 
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPreservedKey( 
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfKeyEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfKeyEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfKeyEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfKeyEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetFocus )( 
            ITfKeyEventSink * This,
            /* [in] */ BOOL fForeground);
        
        HRESULT ( STDMETHODCALLTYPE *OnTestKeyDown )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnTestKeyUp )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyDown )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyUp )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *OnPreservedKey )( 
            ITfKeyEventSink * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfKeyEventSinkVtbl;

    interface ITfKeyEventSink
    {
        CONST_VTBL struct ITfKeyEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfKeyEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfKeyEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfKeyEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfKeyEventSink_OnSetFocus(This,fForeground)	\
    (This)->lpVtbl -> OnSetFocus(This,fForeground)

#define ITfKeyEventSink_OnTestKeyDown(This,pic,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnTestKeyDown(This,pic,wParam,lParam,pfEaten)

#define ITfKeyEventSink_OnTestKeyUp(This,pic,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnTestKeyUp(This,pic,wParam,lParam,pfEaten)

#define ITfKeyEventSink_OnKeyDown(This,pic,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnKeyDown(This,pic,wParam,lParam,pfEaten)

#define ITfKeyEventSink_OnKeyUp(This,pic,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> OnKeyUp(This,pic,wParam,lParam,pfEaten)

#define ITfKeyEventSink_OnPreservedKey(This,pic,rguid,pfEaten)	\
    (This)->lpVtbl -> OnPreservedKey(This,pic,rguid,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnSetFocus_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ BOOL fForeground);


void __RPC_STUB ITfKeyEventSink_OnSetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnTestKeyDown_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnTestKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnTestKeyUp_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnTestKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnKeyDown_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnKeyUp_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnKeyUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyEventSink_OnPreservedKey_Proxy( 
    ITfKeyEventSink * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ REFGUID rguid,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeyEventSink_OnPreservedKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfKeyEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfKeyTraceEventSink_INTERFACE_DEFINED__
#define __ITfKeyTraceEventSink_INTERFACE_DEFINED__

/* interface ITfKeyTraceEventSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfKeyTraceEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1cd4c13b-1c36-4191-a70a-7f3e611f367d")
    ITfKeyTraceEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnKeyTraceDown( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyTraceUp( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfKeyTraceEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfKeyTraceEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfKeyTraceEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfKeyTraceEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyTraceDown )( 
            ITfKeyTraceEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyTraceUp )( 
            ITfKeyTraceEventSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfKeyTraceEventSinkVtbl;

    interface ITfKeyTraceEventSink
    {
        CONST_VTBL struct ITfKeyTraceEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfKeyTraceEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfKeyTraceEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfKeyTraceEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfKeyTraceEventSink_OnKeyTraceDown(This,wParam,lParam)	\
    (This)->lpVtbl -> OnKeyTraceDown(This,wParam,lParam)

#define ITfKeyTraceEventSink_OnKeyTraceUp(This,wParam,lParam)	\
    (This)->lpVtbl -> OnKeyTraceUp(This,wParam,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfKeyTraceEventSink_OnKeyTraceDown_Proxy( 
    ITfKeyTraceEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfKeyTraceEventSink_OnKeyTraceDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeyTraceEventSink_OnKeyTraceUp_Proxy( 
    ITfKeyTraceEventSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfKeyTraceEventSink_OnKeyTraceUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfKeyTraceEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfPreservedKeyNotifySink_INTERFACE_DEFINED__
#define __ITfPreservedKeyNotifySink_INTERFACE_DEFINED__

/* interface ITfPreservedKeyNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPreservedKeyNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6f77c993-d2b1-446e-853e-5912efc8a286")
    ITfPreservedKeyNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdated( 
            /* [in] */ const TF_PRESERVEDKEY *pprekey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPreservedKeyNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPreservedKeyNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPreservedKeyNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPreservedKeyNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdated )( 
            ITfPreservedKeyNotifySink * This,
            /* [in] */ const TF_PRESERVEDKEY *pprekey);
        
        END_INTERFACE
    } ITfPreservedKeyNotifySinkVtbl;

    interface ITfPreservedKeyNotifySink
    {
        CONST_VTBL struct ITfPreservedKeyNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPreservedKeyNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPreservedKeyNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPreservedKeyNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPreservedKeyNotifySink_OnUpdated(This,pprekey)	\
    (This)->lpVtbl -> OnUpdated(This,pprekey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPreservedKeyNotifySink_OnUpdated_Proxy( 
    ITfPreservedKeyNotifySink * This,
    /* [in] */ const TF_PRESERVEDKEY *pprekey);


void __RPC_STUB ITfPreservedKeyNotifySink_OnUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPreservedKeyNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITfMessagePump_INTERFACE_DEFINED__
#define __ITfMessagePump_INTERFACE_DEFINED__

/* interface ITfMessagePump */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfMessagePump;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8f1b8ad8-0b6b-4874-90c5-bd76011e8f7c")
    ITfMessagePump : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PeekMessageA( 
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [in] */ UINT wRemoveMsg,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMessageA( 
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PeekMessageW( 
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [in] */ UINT wRemoveMsg,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMessageW( 
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [out] */ BOOL *pfResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMessagePumpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMessagePump * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMessagePump * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMessagePump * This);
        
        HRESULT ( STDMETHODCALLTYPE *PeekMessageA )( 
            ITfMessagePump * This,
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [in] */ UINT wRemoveMsg,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetMessageA )( 
            ITfMessagePump * This,
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *PeekMessageW )( 
            ITfMessagePump * This,
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [in] */ UINT wRemoveMsg,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetMessageW )( 
            ITfMessagePump * This,
            /* [out] */ LPMSG pMsg,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsgFilterMin,
            /* [in] */ UINT wMsgFilterMax,
            /* [out] */ BOOL *pfResult);
        
        END_INTERFACE
    } ITfMessagePumpVtbl;

    interface ITfMessagePump
    {
        CONST_VTBL struct ITfMessagePumpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMessagePump_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMessagePump_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMessagePump_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMessagePump_PeekMessageA(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,wRemoveMsg,pfResult)	\
    (This)->lpVtbl -> PeekMessageA(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,wRemoveMsg,pfResult)

#define ITfMessagePump_GetMessageA(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,pfResult)	\
    (This)->lpVtbl -> GetMessageA(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,pfResult)

#define ITfMessagePump_PeekMessageW(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,wRemoveMsg,pfResult)	\
    (This)->lpVtbl -> PeekMessageW(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,wRemoveMsg,pfResult)

#define ITfMessagePump_GetMessageW(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,pfResult)	\
    (This)->lpVtbl -> GetMessageW(This,pMsg,hwnd,wMsgFilterMin,wMsgFilterMax,pfResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMessagePump_PeekMessageA_Proxy( 
    ITfMessagePump * This,
    /* [out] */ LPMSG pMsg,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsgFilterMin,
    /* [in] */ UINT wMsgFilterMax,
    /* [in] */ UINT wRemoveMsg,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB ITfMessagePump_PeekMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMessagePump_GetMessageA_Proxy( 
    ITfMessagePump * This,
    /* [out] */ LPMSG pMsg,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsgFilterMin,
    /* [in] */ UINT wMsgFilterMax,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB ITfMessagePump_GetMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMessagePump_PeekMessageW_Proxy( 
    ITfMessagePump * This,
    /* [out] */ LPMSG pMsg,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsgFilterMin,
    /* [in] */ UINT wMsgFilterMax,
    /* [in] */ UINT wRemoveMsg,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB ITfMessagePump_PeekMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMessagePump_GetMessageW_Proxy( 
    ITfMessagePump * This,
    /* [out] */ LPMSG pMsg,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsgFilterMin,
    /* [in] */ UINT wMsgFilterMax,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB ITfMessagePump_GetMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMessagePump_INTERFACE_DEFINED__ */


#ifndef __ITfThreadFocusSink_INTERFACE_DEFINED__
#define __ITfThreadFocusSink_INTERFACE_DEFINED__

/* interface ITfThreadFocusSink */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfThreadFocusSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c0f1db0c-3a20-405c-a303-96b6010a885f")
    ITfThreadFocusSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSetThreadFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKillThreadFocus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadFocusSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadFocusSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadFocusSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadFocusSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetThreadFocus )( 
            ITfThreadFocusSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnKillThreadFocus )( 
            ITfThreadFocusSink * This);
        
        END_INTERFACE
    } ITfThreadFocusSinkVtbl;

    interface ITfThreadFocusSink
    {
        CONST_VTBL struct ITfThreadFocusSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadFocusSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadFocusSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadFocusSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadFocusSink_OnSetThreadFocus(This)	\
    (This)->lpVtbl -> OnSetThreadFocus(This)

#define ITfThreadFocusSink_OnKillThreadFocus(This)	\
    (This)->lpVtbl -> OnKillThreadFocus(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadFocusSink_OnSetThreadFocus_Proxy( 
    ITfThreadFocusSink * This);


void __RPC_STUB ITfThreadFocusSink_OnSetThreadFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadFocusSink_OnKillThreadFocus_Proxy( 
    ITfThreadFocusSink * This);


void __RPC_STUB ITfThreadFocusSink_OnKillThreadFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadFocusSink_INTERFACE_DEFINED__ */


#ifndef __ITfTextInputProcessor_INTERFACE_DEFINED__
#define __ITfTextInputProcessor_INTERFACE_DEFINED__

/* interface ITfTextInputProcessor */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfTextInputProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e7f7-2021-11d2-93e0-0060b067b86e")
    ITfTextInputProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ITfThreadMgr *ptim,
            /* [in] */ TfClientId tid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfTextInputProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfTextInputProcessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfTextInputProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfTextInputProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfTextInputProcessor * This,
            /* [in] */ ITfThreadMgr *ptim,
            /* [in] */ TfClientId tid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfTextInputProcessor * This);
        
        END_INTERFACE
    } ITfTextInputProcessorVtbl;

    interface ITfTextInputProcessor
    {
        CONST_VTBL struct ITfTextInputProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfTextInputProcessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfTextInputProcessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfTextInputProcessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfTextInputProcessor_Activate(This,ptim,tid)	\
    (This)->lpVtbl -> Activate(This,ptim,tid)

#define ITfTextInputProcessor_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfTextInputProcessor_Activate_Proxy( 
    ITfTextInputProcessor * This,
    /* [in] */ ITfThreadMgr *ptim,
    /* [in] */ TfClientId tid);


void __RPC_STUB ITfTextInputProcessor_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfTextInputProcessor_Deactivate_Proxy( 
    ITfTextInputProcessor * This);


void __RPC_STUB ITfTextInputProcessor_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfTextInputProcessor_INTERFACE_DEFINED__ */


#ifndef __ITfClientId_INTERFACE_DEFINED__
#define __ITfClientId_INTERFACE_DEFINED__

/* interface ITfClientId */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfClientId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d60a7b49-1b9f-4be2-b702-47e9dc05dec3")
    ITfClientId : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientId( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ TfClientId *ptid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfClientIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfClientId * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfClientId * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfClientId * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientId )( 
            ITfClientId * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ TfClientId *ptid);
        
        END_INTERFACE
    } ITfClientIdVtbl;

    interface ITfClientId
    {
        CONST_VTBL struct ITfClientIdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfClientId_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfClientId_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfClientId_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfClientId_GetClientId(This,rclsid,ptid)	\
    (This)->lpVtbl -> GetClientId(This,rclsid,ptid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfClientId_GetClientId_Proxy( 
    ITfClientId * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ TfClientId *ptid);


void __RPC_STUB ITfClientId_GetClientId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfClientId_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0204 */
/* [local] */ 

typedef /* [public][public][public][public][uuid] */  DECLSPEC_UUID("c4cc07f1-80cc-4a7b-bc54-98512782cbe3") 
enum __MIDL___MIDL_itf_msctf_0204_0001
    {	TF_LS_NONE	= 0,
	TF_LS_SOLID	= 1,
	TF_LS_DOT	= 2,
	TF_LS_DASH	= 3,
	TF_LS_SQUIGGLE	= 4
    } 	TF_DA_LINESTYLE;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][uuid] */  DECLSPEC_UUID("d9b92e21-084a-401b-9c64-1e6dad91a1ab") 
enum __MIDL___MIDL_itf_msctf_0204_0002
    {	TF_CT_NONE	= 0,
	TF_CT_SYSCOLOR	= 1,
	TF_CT_COLORREF	= 2
    } 	TF_DA_COLORTYPE;

typedef /* [uuid] */  DECLSPEC_UUID("90d0cb5e-6520-4a0f-b47c-c39bd955f0d6") struct TF_DA_COLOR
    {
    TF_DA_COLORTYPE type;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ int nIndex;
        /* [case()] */ COLORREF cr;
        } 	;
    } 	TF_DA_COLOR;

typedef /* [public][public][public][public][uuid] */  DECLSPEC_UUID("33d2fe4b-6c24-4f67-8d75-3bc1819e4126") 
enum __MIDL___MIDL_itf_msctf_0204_0004
    {	TF_ATTR_INPUT	= 0,
	TF_ATTR_TARGET_CONVERTED	= 1,
	TF_ATTR_CONVERTED	= 2,
	TF_ATTR_TARGET_NOTCONVERTED	= 3,
	TF_ATTR_INPUT_ERROR	= 4,
	TF_ATTR_FIXEDCONVERTED	= 5,
	TF_ATTR_OTHER	= -1
    } 	TF_DA_ATTR_INFO;

typedef /* [uuid] */  DECLSPEC_UUID("1bf1c305-419b-4182-a4d2-9bfadc3f021f") struct TF_DISPLAYATTRIBUTE
    {
    TF_DA_COLOR crText;
    TF_DA_COLOR crBk;
    TF_DA_LINESTYLE lsStyle;
    BOOL fBoldLine;
    TF_DA_COLOR crLine;
    TF_DA_ATTR_INFO bAttr;
    } 	TF_DISPLAYATTRIBUTE;



extern RPC_IF_HANDLE __MIDL_itf_msctf_0204_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0204_v0_0_s_ifspec;

#ifndef __ITfDisplayAttributeInfo_INTERFACE_DEFINED__
#define __ITfDisplayAttributeInfo_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70528852-2f26-4aea-8c96-215150578932")
    ITfDisplayAttributeInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGUID( 
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ BSTR *pbstrDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeInfo( 
            /* [out] */ TF_DISPLAYATTRIBUTE *pda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttributeInfo( 
            /* [in] */ TF_DISPLAYATTRIBUTE *pda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            ITfDisplayAttributeInfo * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ITfDisplayAttributeInfo * This,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeInfo )( 
            ITfDisplayAttributeInfo * This,
            /* [out] */ TF_DISPLAYATTRIBUTE *pda);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttributeInfo )( 
            ITfDisplayAttributeInfo * This,
            /* [in] */ TF_DISPLAYATTRIBUTE *pda);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ITfDisplayAttributeInfo * This);
        
        END_INTERFACE
    } ITfDisplayAttributeInfoVtbl;

    interface ITfDisplayAttributeInfo
    {
        CONST_VTBL struct ITfDisplayAttributeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeInfo_GetGUID(This,pguid)	\
    (This)->lpVtbl -> GetGUID(This,pguid)

#define ITfDisplayAttributeInfo_GetDescription(This,pbstrDesc)	\
    (This)->lpVtbl -> GetDescription(This,pbstrDesc)

#define ITfDisplayAttributeInfo_GetAttributeInfo(This,pda)	\
    (This)->lpVtbl -> GetAttributeInfo(This,pda)

#define ITfDisplayAttributeInfo_SetAttributeInfo(This,pda)	\
    (This)->lpVtbl -> SetAttributeInfo(This,pda)

#define ITfDisplayAttributeInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_GetGUID_Proxy( 
    ITfDisplayAttributeInfo * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfDisplayAttributeInfo_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_GetDescription_Proxy( 
    ITfDisplayAttributeInfo * This,
    /* [out] */ BSTR *pbstrDesc);


void __RPC_STUB ITfDisplayAttributeInfo_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_GetAttributeInfo_Proxy( 
    ITfDisplayAttributeInfo * This,
    /* [out] */ TF_DISPLAYATTRIBUTE *pda);


void __RPC_STUB ITfDisplayAttributeInfo_GetAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_SetAttributeInfo_Proxy( 
    ITfDisplayAttributeInfo * This,
    /* [in] */ TF_DISPLAYATTRIBUTE *pda);


void __RPC_STUB ITfDisplayAttributeInfo_SetAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeInfo_Reset_Proxy( 
    ITfDisplayAttributeInfo * This);


void __RPC_STUB ITfDisplayAttributeInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumTfDisplayAttributeInfo_INTERFACE_DEFINED__
#define __IEnumTfDisplayAttributeInfo_INTERFACE_DEFINED__

/* interface IEnumTfDisplayAttributeInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfDisplayAttributeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7cef04d7-cb75-4e80-a7ab-5f5bc7d332de")
    IEnumTfDisplayAttributeInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfDisplayAttributeInfo **rgInfo,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfDisplayAttributeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfDisplayAttributeInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfDisplayAttributeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfDisplayAttributeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfDisplayAttributeInfo * This,
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfDisplayAttributeInfo * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfDisplayAttributeInfo **rgInfo,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfDisplayAttributeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfDisplayAttributeInfo * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfDisplayAttributeInfoVtbl;

    interface IEnumTfDisplayAttributeInfo
    {
        CONST_VTBL struct IEnumTfDisplayAttributeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfDisplayAttributeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfDisplayAttributeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfDisplayAttributeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfDisplayAttributeInfo_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfDisplayAttributeInfo_Next(This,ulCount,rgInfo,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgInfo,pcFetched)

#define IEnumTfDisplayAttributeInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfDisplayAttributeInfo_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfDisplayAttributeInfo_Clone_Proxy( 
    IEnumTfDisplayAttributeInfo * This,
    /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);


void __RPC_STUB IEnumTfDisplayAttributeInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDisplayAttributeInfo_Next_Proxy( 
    IEnumTfDisplayAttributeInfo * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfDisplayAttributeInfo **rgInfo,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfDisplayAttributeInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDisplayAttributeInfo_Reset_Proxy( 
    IEnumTfDisplayAttributeInfo * This);


void __RPC_STUB IEnumTfDisplayAttributeInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfDisplayAttributeInfo_Skip_Proxy( 
    IEnumTfDisplayAttributeInfo * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfDisplayAttributeInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfDisplayAttributeInfo_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeProvider_INTERFACE_DEFINED__
#define __ITfDisplayAttributeProvider_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fee47777-163c-4769-996a-6e9c50ad8f54")
    ITfDisplayAttributeProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumDisplayAttributeInfo( 
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayAttributeInfo( 
            /* [in] */ REFGUID guid,
            /* [out] */ ITfDisplayAttributeInfo **ppInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDisplayAttributeInfo )( 
            ITfDisplayAttributeProvider * This,
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayAttributeInfo )( 
            ITfDisplayAttributeProvider * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ITfDisplayAttributeInfo **ppInfo);
        
        END_INTERFACE
    } ITfDisplayAttributeProviderVtbl;

    interface ITfDisplayAttributeProvider
    {
        CONST_VTBL struct ITfDisplayAttributeProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeProvider_EnumDisplayAttributeInfo(This,ppEnum)	\
    (This)->lpVtbl -> EnumDisplayAttributeInfo(This,ppEnum)

#define ITfDisplayAttributeProvider_GetDisplayAttributeInfo(This,guid,ppInfo)	\
    (This)->lpVtbl -> GetDisplayAttributeInfo(This,guid,ppInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeProvider_EnumDisplayAttributeInfo_Proxy( 
    ITfDisplayAttributeProvider * This,
    /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);


void __RPC_STUB ITfDisplayAttributeProvider_EnumDisplayAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeProvider_GetDisplayAttributeInfo_Proxy( 
    ITfDisplayAttributeProvider * This,
    /* [in] */ REFGUID guid,
    /* [out] */ ITfDisplayAttributeInfo **ppInfo);


void __RPC_STUB ITfDisplayAttributeProvider_GetDisplayAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeProvider_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeMgr_INTERFACE_DEFINED__
#define __ITfDisplayAttributeMgr_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ded7393-5db1-475c-9e71-a39111b0ff67")
    ITfDisplayAttributeMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdateInfo( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDisplayAttributeInfo( 
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayAttributeInfo( 
            /* [in] */ REFGUID guid,
            /* [out] */ ITfDisplayAttributeInfo **ppInfo,
            /* [out] */ CLSID *pclsidOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateInfo )( 
            ITfDisplayAttributeMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDisplayAttributeInfo )( 
            ITfDisplayAttributeMgr * This,
            /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayAttributeInfo )( 
            ITfDisplayAttributeMgr * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ITfDisplayAttributeInfo **ppInfo,
            /* [out] */ CLSID *pclsidOwner);
        
        END_INTERFACE
    } ITfDisplayAttributeMgrVtbl;

    interface ITfDisplayAttributeMgr
    {
        CONST_VTBL struct ITfDisplayAttributeMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeMgr_OnUpdateInfo(This)	\
    (This)->lpVtbl -> OnUpdateInfo(This)

#define ITfDisplayAttributeMgr_EnumDisplayAttributeInfo(This,ppEnum)	\
    (This)->lpVtbl -> EnumDisplayAttributeInfo(This,ppEnum)

#define ITfDisplayAttributeMgr_GetDisplayAttributeInfo(This,guid,ppInfo,pclsidOwner)	\
    (This)->lpVtbl -> GetDisplayAttributeInfo(This,guid,ppInfo,pclsidOwner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeMgr_OnUpdateInfo_Proxy( 
    ITfDisplayAttributeMgr * This);


void __RPC_STUB ITfDisplayAttributeMgr_OnUpdateInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeMgr_EnumDisplayAttributeInfo_Proxy( 
    ITfDisplayAttributeMgr * This,
    /* [out] */ IEnumTfDisplayAttributeInfo **ppEnum);


void __RPC_STUB ITfDisplayAttributeMgr_EnumDisplayAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeMgr_GetDisplayAttributeInfo_Proxy( 
    ITfDisplayAttributeMgr * This,
    /* [in] */ REFGUID guid,
    /* [out] */ ITfDisplayAttributeInfo **ppInfo,
    /* [out] */ CLSID *pclsidOwner);


void __RPC_STUB ITfDisplayAttributeMgr_GetDisplayAttributeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeMgr_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeNotifySink_INTERFACE_DEFINED__
#define __ITfDisplayAttributeNotifySink_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ad56f402-e162-4f25-908f-7d577cf9bda9")
    ITfDisplayAttributeNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdateInfo( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateInfo )( 
            ITfDisplayAttributeNotifySink * This);
        
        END_INTERFACE
    } ITfDisplayAttributeNotifySinkVtbl;

    interface ITfDisplayAttributeNotifySink
    {
        CONST_VTBL struct ITfDisplayAttributeNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeNotifySink_OnUpdateInfo(This)	\
    (This)->lpVtbl -> OnUpdateInfo(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeNotifySink_OnUpdateInfo_Proxy( 
    ITfDisplayAttributeNotifySink * This);


void __RPC_STUB ITfDisplayAttributeNotifySink_OnUpdateInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITfCategoryMgr_INTERFACE_DEFINED__
#define __ITfCategoryMgr_INTERFACE_DEFINED__

/* interface ITfCategoryMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfCategoryMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c3acefb5-f69d-4905-938f-fcadcf4be830")
    ITfCategoryMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCategory( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rcatid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterCategory( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rcatid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCategoriesInItem( 
            /* [in] */ REFGUID rguid,
            /* [out] */ IEnumGUID **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumItemsInCategory( 
            /* [in] */ REFGUID rcatid,
            /* [out] */ IEnumGUID **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClosestCategory( 
            /* [in] */ REFGUID rguid,
            /* [out] */ GUID *pcatid,
            /* [size_is][in] */ const GUID **ppcatidList,
            /* [in] */ ULONG ulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterGUIDDescription( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterGUIDDescription( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGUIDDescription( 
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterGUIDDWORD( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterGUIDDWORD( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGUIDDWORD( 
            /* [in] */ REFGUID rguid,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterGUID( 
            /* [in] */ REFGUID rguid,
            /* [out] */ TfGuidAtom *pguidatom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGUID( 
            /* [in] */ TfGuidAtom guidatom,
            /* [out] */ GUID *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqualTfGuidAtom( 
            /* [in] */ TfGuidAtom guidatom,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEqual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCategoryMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCategoryMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCategoryMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCategoryMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterCategory )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rcatid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterCategory )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rcatid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCategoriesInItem )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ IEnumGUID **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumItemsInCategory )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rcatid,
            /* [out] */ IEnumGUID **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindClosestCategory )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ GUID *pcatid,
            /* [size_is][in] */ const GUID **ppcatidList,
            /* [in] */ ULONG ulCount);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterGUIDDescription )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterGUIDDescription )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUIDDescription )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterGUIDDWORD )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterGUIDDWORD )( 
            ITfCategoryMgr * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUIDDWORD )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterGUID )( 
            ITfCategoryMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ TfGuidAtom *pguidatom);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            ITfCategoryMgr * This,
            /* [in] */ TfGuidAtom guidatom,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualTfGuidAtom )( 
            ITfCategoryMgr * This,
            /* [in] */ TfGuidAtom guidatom,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEqual);
        
        END_INTERFACE
    } ITfCategoryMgrVtbl;

    interface ITfCategoryMgr
    {
        CONST_VTBL struct ITfCategoryMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCategoryMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCategoryMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCategoryMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCategoryMgr_RegisterCategory(This,rclsid,rcatid,rguid)	\
    (This)->lpVtbl -> RegisterCategory(This,rclsid,rcatid,rguid)

#define ITfCategoryMgr_UnregisterCategory(This,rclsid,rcatid,rguid)	\
    (This)->lpVtbl -> UnregisterCategory(This,rclsid,rcatid,rguid)

#define ITfCategoryMgr_EnumCategoriesInItem(This,rguid,ppEnum)	\
    (This)->lpVtbl -> EnumCategoriesInItem(This,rguid,ppEnum)

#define ITfCategoryMgr_EnumItemsInCategory(This,rcatid,ppEnum)	\
    (This)->lpVtbl -> EnumItemsInCategory(This,rcatid,ppEnum)

#define ITfCategoryMgr_FindClosestCategory(This,rguid,pcatid,ppcatidList,ulCount)	\
    (This)->lpVtbl -> FindClosestCategory(This,rguid,pcatid,ppcatidList,ulCount)

#define ITfCategoryMgr_RegisterGUIDDescription(This,rclsid,rguid,pchDesc,cch)	\
    (This)->lpVtbl -> RegisterGUIDDescription(This,rclsid,rguid,pchDesc,cch)

#define ITfCategoryMgr_UnregisterGUIDDescription(This,rclsid,rguid)	\
    (This)->lpVtbl -> UnregisterGUIDDescription(This,rclsid,rguid)

#define ITfCategoryMgr_GetGUIDDescription(This,rguid,pbstrDesc)	\
    (This)->lpVtbl -> GetGUIDDescription(This,rguid,pbstrDesc)

#define ITfCategoryMgr_RegisterGUIDDWORD(This,rclsid,rguid,dw)	\
    (This)->lpVtbl -> RegisterGUIDDWORD(This,rclsid,rguid,dw)

#define ITfCategoryMgr_UnregisterGUIDDWORD(This,rclsid,rguid)	\
    (This)->lpVtbl -> UnregisterGUIDDWORD(This,rclsid,rguid)

#define ITfCategoryMgr_GetGUIDDWORD(This,rguid,pdw)	\
    (This)->lpVtbl -> GetGUIDDWORD(This,rguid,pdw)

#define ITfCategoryMgr_RegisterGUID(This,rguid,pguidatom)	\
    (This)->lpVtbl -> RegisterGUID(This,rguid,pguidatom)

#define ITfCategoryMgr_GetGUID(This,guidatom,pguid)	\
    (This)->lpVtbl -> GetGUID(This,guidatom,pguid)

#define ITfCategoryMgr_IsEqualTfGuidAtom(This,guidatom,rguid,pfEqual)	\
    (This)->lpVtbl -> IsEqualTfGuidAtom(This,guidatom,rguid,pfEqual)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCategoryMgr_RegisterCategory_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rcatid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCategoryMgr_RegisterCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_UnregisterCategory_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rcatid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCategoryMgr_UnregisterCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_EnumCategoriesInItem_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ IEnumGUID **ppEnum);


void __RPC_STUB ITfCategoryMgr_EnumCategoriesInItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_EnumItemsInCategory_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rcatid,
    /* [out] */ IEnumGUID **ppEnum);


void __RPC_STUB ITfCategoryMgr_EnumItemsInCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_FindClosestCategory_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ GUID *pcatid,
    /* [size_is][in] */ const GUID **ppcatidList,
    /* [in] */ ULONG ulCount);


void __RPC_STUB ITfCategoryMgr_FindClosestCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_RegisterGUIDDescription_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rguid,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cch);


void __RPC_STUB ITfCategoryMgr_RegisterGUIDDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_UnregisterGUIDDescription_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCategoryMgr_UnregisterGUIDDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_GetGUIDDescription_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ BSTR *pbstrDesc);


void __RPC_STUB ITfCategoryMgr_GetGUIDDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_RegisterGUIDDWORD_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rguid,
    /* [in] */ DWORD dw);


void __RPC_STUB ITfCategoryMgr_RegisterGUIDDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_UnregisterGUIDDWORD_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ITfCategoryMgr_UnregisterGUIDDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_GetGUIDDWORD_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ DWORD *pdw);


void __RPC_STUB ITfCategoryMgr_GetGUIDDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_RegisterGUID_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ TfGuidAtom *pguidatom);


void __RPC_STUB ITfCategoryMgr_RegisterGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_GetGUID_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ TfGuidAtom guidatom,
    /* [out] */ GUID *pguid);


void __RPC_STUB ITfCategoryMgr_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCategoryMgr_IsEqualTfGuidAtom_Proxy( 
    ITfCategoryMgr * This,
    /* [in] */ TfGuidAtom guidatom,
    /* [in] */ REFGUID rguid,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB ITfCategoryMgr_IsEqualTfGuidAtom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCategoryMgr_INTERFACE_DEFINED__ */


#ifndef __ITfSource_INTERFACE_DEFINED__
#define __ITfSource_INTERFACE_DEFINED__

/* interface ITfSource */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4ea48a35-60ae-446f-8fd6-e6a8d82459f7")
    ITfSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSink( 
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSink )( 
            ITfSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseSink )( 
            ITfSource * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfSourceVtbl;

    interface ITfSource
    {
        CONST_VTBL struct ITfSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSource_AdviseSink(This,riid,punk,pdwCookie)	\
    (This)->lpVtbl -> AdviseSink(This,riid,punk,pdwCookie)

#define ITfSource_UnadviseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSource_AdviseSink_Proxy( 
    ITfSource * This,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ IUnknown *punk,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfSource_AdviseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSource_UnadviseSink_Proxy( 
    ITfSource * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfSource_UnadviseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSource_INTERFACE_DEFINED__ */


#ifndef __ITfSourceSingle_INTERFACE_DEFINED__
#define __ITfSourceSingle_INTERFACE_DEFINED__

/* interface ITfSourceSingle */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSourceSingle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73131f9c-56a9-49dd-b0ee-d046633f7528")
    ITfSourceSingle : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSingleSink( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseSingleSink( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFIID riid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSourceSingleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSourceSingle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSourceSingle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSourceSingle * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSingleSink )( 
            ITfSourceSingle * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseSingleSink )( 
            ITfSourceSingle * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFIID riid);
        
        END_INTERFACE
    } ITfSourceSingleVtbl;

    interface ITfSourceSingle
    {
        CONST_VTBL struct ITfSourceSingleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSourceSingle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSourceSingle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSourceSingle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSourceSingle_AdviseSingleSink(This,tid,riid,punk)	\
    (This)->lpVtbl -> AdviseSingleSink(This,tid,riid,punk)

#define ITfSourceSingle_UnadviseSingleSink(This,tid,riid)	\
    (This)->lpVtbl -> UnadviseSingleSink(This,tid,riid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSourceSingle_AdviseSingleSink_Proxy( 
    ITfSourceSingle * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ IUnknown *punk);


void __RPC_STUB ITfSourceSingle_AdviseSingleSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSourceSingle_UnadviseSingleSink_Proxy( 
    ITfSourceSingle * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFIID riid);


void __RPC_STUB ITfSourceSingle_UnadviseSingleSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSourceSingle_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctf_0212 */
/* [local] */ 

#endif // MSCTF_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_msctf_0212_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctf_0212_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  CLIPFORMAT_UserSize(     unsigned long *, unsigned long            , CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserMarshal(  unsigned long *, unsigned char *, CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserUnmarshal(unsigned long *, unsigned char *, CLIPFORMAT * ); 
void                      __RPC_USER  CLIPFORMAT_UserFree(     unsigned long *, CLIPFORMAT * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\msctfp_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

/* c6debc0a-f2b2-4f17-930e-ca9faff4cd04 */
const GUID GUID_TFCAT_TIP_REFERENCE = { 
    0xc6debc0a,
    0xf2b2,
    0x4f17,
    {0x93, 0x0e, 0xca, 0x9f, 0xaf, 0xf4, 0xcd, 0x04}
  };

/* 5130a009-5540-4fcf-97eb-aad33fc0ee09 */
const GUID GUID_TFCAT_TIP_PROOFING = { 
    0x5130a009,
    0x5540,
    0x4fcf,
    {0x97, 0xeb, 0xaa, 0xd3, 0x3f, 0xc0, 0xee, 0x09}
  };

/* 7ae86bb7-262c-431e-9111-c974b6b7cac3 */
const GUID GUID_TFCAT_TIP_SMARTTAG = { 
    0x7ae86bb7,
    0x262c,
    0x431e,
    {0x91, 0x11, 0xc9, 0x74, 0xb6, 0xb7, 0xca, 0xc3}
  };

/* cc33ce20-13c6-4e88-a4b4-78f1b685c762 */
const GUID GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT = { 
    0xcc33ce20,
    0x13c6,
    0x4e88,
    {0xa4, 0xb4, 0x78, 0xf1, 0xb6, 0x85, 0xc7, 0x62}
  };

/* c0db7b30-7b78-4dac-b52a-5fd61e7b58fa */
const GUID GUID_SERVICE_TEXTSTORE = { 
    0xc0db7b30,
    0x7b78,
    0x4dac,
    {0xb5, 0x2a, 0x5f, 0xd6, 0x1e, 0x7b, 0x58, 0xfa}
  };

/* aabf7f9a-4487-4b2e-8164-e54c5fe19204 */
const GUID GUID_SERVICE_TF = { 
    0xaabf7f9a,
    0x4487,
    0x4b2e,
    {0x81, 0x64, 0xe5, 0x4c, 0x5f, 0xe1, 0x92, 0x04}
  };

/* c0eb60fe-473e-4a0c-be36-52f0bc985473 */
const GUID GUID_COMPARTMENT_ENABLESTATE = { 
    0xc0eb60fe,
    0x473e,
    0x4a0c,
    {0xbe, 0x36, 0x52, 0xf0, 0xbc, 0x98, 0x54, 0x73}
  };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\msctfp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for msctfp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msctfp_h__
#define __msctfp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfThreadMgr_P_FWD_DEFINED__
#define __ITfThreadMgr_P_FWD_DEFINED__
typedef interface ITfThreadMgr_P ITfThreadMgr_P;
#endif 	/* __ITfThreadMgr_P_FWD_DEFINED__ */


#ifndef __ITfSysHookSink_FWD_DEFINED__
#define __ITfSysHookSink_FWD_DEFINED__
typedef interface ITfSysHookSink ITfSysHookSink;
#endif 	/* __ITfSysHookSink_FWD_DEFINED__ */


#ifndef __ITfStartReconversionNotifySink_FWD_DEFINED__
#define __ITfStartReconversionNotifySink_FWD_DEFINED__
typedef interface ITfStartReconversionNotifySink ITfStartReconversionNotifySink;
#endif 	/* __ITfStartReconversionNotifySink_FWD_DEFINED__ */


#ifndef __ITfLangBarEventSink_P_FWD_DEFINED__
#define __ITfLangBarEventSink_P_FWD_DEFINED__
typedef interface ITfLangBarEventSink_P ITfLangBarEventSink_P;
#endif 	/* __ITfLangBarEventSink_P_FWD_DEFINED__ */


#ifndef __ITfLangBarMgr_P_FWD_DEFINED__
#define __ITfLangBarMgr_P_FWD_DEFINED__
typedef interface ITfLangBarMgr_P ITfLangBarMgr_P;
#endif 	/* __ITfLangBarMgr_P_FWD_DEFINED__ */


#ifndef __ITfContext_P_FWD_DEFINED__
#define __ITfContext_P_FWD_DEFINED__
typedef interface ITfContext_P ITfContext_P;
#endif 	/* __ITfContext_P_FWD_DEFINED__ */


#ifndef __ITfRangeChangeSink_FWD_DEFINED__
#define __ITfRangeChangeSink_FWD_DEFINED__
typedef interface ITfRangeChangeSink ITfRangeChangeSink;
#endif 	/* __ITfRangeChangeSink_FWD_DEFINED__ */


#ifndef __ITfFnAbort_FWD_DEFINED__
#define __ITfFnAbort_FWD_DEFINED__
typedef interface ITfFnAbort ITfFnAbort;
#endif 	/* __ITfFnAbort_FWD_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_FWD_DEFINED__
#define __ITfMouseTrackerAnchor_FWD_DEFINED__
typedef interface ITfMouseTrackerAnchor ITfMouseTrackerAnchor;
#endif 	/* __ITfMouseTrackerAnchor_FWD_DEFINED__ */


#ifndef __ITfRangeAnchor_FWD_DEFINED__
#define __ITfRangeAnchor_FWD_DEFINED__
typedef interface ITfRangeAnchor ITfRangeAnchor;
#endif 	/* __ITfRangeAnchor_FWD_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
typedef interface ITfPersistentPropertyLoaderAnchor ITfPersistentPropertyLoaderAnchor;
#endif 	/* __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__ */


#ifndef __ITextStoreAnchorServices_FWD_DEFINED__
#define __ITextStoreAnchorServices_FWD_DEFINED__
typedef interface ITextStoreAnchorServices ITextStoreAnchorServices;
#endif 	/* __ITextStoreAnchorServices_FWD_DEFINED__ */


#ifndef __ITfProperty2_FWD_DEFINED__
#define __ITfProperty2_FWD_DEFINED__
typedef interface ITfProperty2 ITfProperty2;
#endif 	/* __ITfProperty2_FWD_DEFINED__ */


#ifndef __IEnumTfCollection_FWD_DEFINED__
#define __IEnumTfCollection_FWD_DEFINED__
typedef interface IEnumTfCollection IEnumTfCollection;
#endif 	/* __IEnumTfCollection_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__
#define __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__
typedef interface ITfDisplayAttributeCollectionMgr ITfDisplayAttributeCollectionMgr;
#endif 	/* __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__
#define __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__
typedef interface ITfDisplayAttributeCollectionProvider ITfDisplayAttributeCollectionProvider;
#endif 	/* __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__ */


#ifndef __IEnumTfRenderingMarkup_FWD_DEFINED__
#define __IEnumTfRenderingMarkup_FWD_DEFINED__
typedef interface IEnumTfRenderingMarkup IEnumTfRenderingMarkup;
#endif 	/* __IEnumTfRenderingMarkup_FWD_DEFINED__ */


#ifndef __ITfContextRenderingMarkup_FWD_DEFINED__
#define __ITfContextRenderingMarkup_FWD_DEFINED__
typedef interface ITfContextRenderingMarkup ITfContextRenderingMarkup;
#endif 	/* __ITfContextRenderingMarkup_FWD_DEFINED__ */


#ifndef __ITfBackgroundThreadMgr_FWD_DEFINED__
#define __ITfBackgroundThreadMgr_FWD_DEFINED__
typedef interface ITfBackgroundThreadMgr ITfBackgroundThreadMgr;
#endif 	/* __ITfBackgroundThreadMgr_FWD_DEFINED__ */


#ifndef __ITfEnableService_FWD_DEFINED__
#define __ITfEnableService_FWD_DEFINED__
typedef interface ITfEnableService ITfEnableService;
#endif 	/* __ITfEnableService_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msctfp_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// msctfp.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// MSCTF Private Interfaces.

#ifndef MSCTFP_DEFINED
#define MSCTFP_DEFINED

#include <windows.h>

EXTERN_C const GUID GUID_TFCAT_TIP_REFERENCE;
EXTERN_C const GUID GUID_TFCAT_TIP_PROOFING;
EXTERN_C const GUID GUID_TFCAT_TIP_SMARTTAG;
EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT;
EXTERN_C const GUID GUID_SERVICE_TEXTSTORE;
EXTERN_C const GUID GUID_SERVICE_TF;

#define TF_LBU_CAPSKANAKEY               1
#define TF_LBU_NTCONSOLELANGCHANGE       2
#define TF_LBUF_CAPS        0x0001
#define TF_LBUF_KANA        0x0002
#define	TF_ES_READ_PROPERTY_WRITE	( 0x12 )



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0000_v0_0_s_ifspec;

#ifndef __ITfThreadMgr_P_INTERFACE_DEFINED__
#define __ITfThreadMgr_P_INTERFACE_DEFINED__

/* interface ITfThreadMgr_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfThreadMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f65567a7-34a1-46f4-b5dd-8804aeb06ff7")
    ITfThreadMgr_P : public ITfThreadMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssociated( 
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSysHookSink( 
            /* [in] */ ITfSysHookSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestPostponedLock( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsKeystrokeFeedEnabled( 
            /* [out] */ BOOL *pfEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfThreadMgr_P * This,
            /* [out] */ TfClientId *ptid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfThreadMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentMgr )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDocumentMgrs )( 
            ITfThreadMgr_P * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfDocumentMgr **ppdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfDocumentMgr *pdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateFocus )( 
            ITfThreadMgr_P * This,
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev);
        
        HRESULT ( STDMETHODCALLTYPE *IsThreadFocus )( 
            ITfThreadMgr_P * This,
            /* [out] */ BOOL *pfThreadFocus);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionProvider )( 
            ITfThreadMgr_P * This,
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFunctionProviders )( 
            ITfThreadMgr_P * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalCompartment )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfCompartmentMgr **ppCompMgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssociated )( 
            ITfThreadMgr_P * This,
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *SetSysHookSink )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfSysHookSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RequestPostponedLock )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *IsKeystrokeFeedEnabled )( 
            ITfThreadMgr_P * This,
            /* [out] */ BOOL *pfEnabled);
        
        END_INTERFACE
    } ITfThreadMgr_PVtbl;

    interface ITfThreadMgr_P
    {
        CONST_VTBL struct ITfThreadMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgr_P_Activate(This,ptid)	\
    (This)->lpVtbl -> Activate(This,ptid)

#define ITfThreadMgr_P_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ITfThreadMgr_P_CreateDocumentMgr(This,ppdim)	\
    (This)->lpVtbl -> CreateDocumentMgr(This,ppdim)

#define ITfThreadMgr_P_EnumDocumentMgrs(This,ppEnum)	\
    (This)->lpVtbl -> EnumDocumentMgrs(This,ppEnum)

#define ITfThreadMgr_P_GetFocus(This,ppdimFocus)	\
    (This)->lpVtbl -> GetFocus(This,ppdimFocus)

#define ITfThreadMgr_P_SetFocus(This,pdimFocus)	\
    (This)->lpVtbl -> SetFocus(This,pdimFocus)

#define ITfThreadMgr_P_AssociateFocus(This,hwnd,pdimNew,ppdimPrev)	\
    (This)->lpVtbl -> AssociateFocus(This,hwnd,pdimNew,ppdimPrev)

#define ITfThreadMgr_P_IsThreadFocus(This,pfThreadFocus)	\
    (This)->lpVtbl -> IsThreadFocus(This,pfThreadFocus)

#define ITfThreadMgr_P_GetFunctionProvider(This,clsid,ppFuncProv)	\
    (This)->lpVtbl -> GetFunctionProvider(This,clsid,ppFuncProv)

#define ITfThreadMgr_P_EnumFunctionProviders(This,ppEnum)	\
    (This)->lpVtbl -> EnumFunctionProviders(This,ppEnum)

#define ITfThreadMgr_P_GetGlobalCompartment(This,ppCompMgr)	\
    (This)->lpVtbl -> GetGlobalCompartment(This,ppCompMgr)


#define ITfThreadMgr_P_GetAssociated(This,hWnd,ppdim)	\
    (This)->lpVtbl -> GetAssociated(This,hWnd,ppdim)

#define ITfThreadMgr_P_SetSysHookSink(This,pSink)	\
    (This)->lpVtbl -> SetSysHookSink(This,pSink)

#define ITfThreadMgr_P_RequestPostponedLock(This,pic)	\
    (This)->lpVtbl -> RequestPostponedLock(This,pic)

#define ITfThreadMgr_P_IsKeystrokeFeedEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsKeystrokeFeedEnabled(This,pfEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_GetAssociated_Proxy( 
    ITfThreadMgr_P * This,
    /* [in] */ HWND hWnd,
    /* [out] */ ITfDocumentMgr **ppdim);


void __RPC_STUB ITfThreadMgr_P_GetAssociated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_SetSysHookSink_Proxy( 
    ITfThreadMgr_P * This,
    /* [in] */ ITfSysHookSink *pSink);


void __RPC_STUB ITfThreadMgr_P_SetSysHookSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_RequestPostponedLock_Proxy( 
    ITfThreadMgr_P * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfThreadMgr_P_RequestPostponedLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_IsKeystrokeFeedEnabled_Proxy( 
    ITfThreadMgr_P * This,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB ITfThreadMgr_P_IsKeystrokeFeedEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfSysHookSink_INTERFACE_DEFINED__
#define __ITfSysHookSink_INTERFACE_DEFINED__

/* interface ITfSysHookSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSysHookSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("495388DA-21A5-4852-8BB1-ED2F29DA8D60")
    ITfSysHookSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPreFocusDIM( 
            /* [in] */ HWND hWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSysKeyboardProc( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSysShellProc( 
            /* [in] */ int nCode,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSysHookSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSysHookSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSysHookSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSysHookSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnPreFocusDIM )( 
            ITfSysHookSink * This,
            /* [in] */ HWND hWnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSysKeyboardProc )( 
            ITfSysHookSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *OnSysShellProc )( 
            ITfSysHookSink * This,
            /* [in] */ int nCode,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfSysHookSinkVtbl;

    interface ITfSysHookSink
    {
        CONST_VTBL struct ITfSysHookSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSysHookSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSysHookSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSysHookSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSysHookSink_OnPreFocusDIM(This,hWnd)	\
    (This)->lpVtbl -> OnPreFocusDIM(This,hWnd)

#define ITfSysHookSink_OnSysKeyboardProc(This,wParam,lParam)	\
    (This)->lpVtbl -> OnSysKeyboardProc(This,wParam,lParam)

#define ITfSysHookSink_OnSysShellProc(This,nCode,wParam,lParam)	\
    (This)->lpVtbl -> OnSysShellProc(This,nCode,wParam,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnPreFocusDIM_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ HWND hWnd);


void __RPC_STUB ITfSysHookSink_OnPreFocusDIM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnSysKeyboardProc_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfSysHookSink_OnSysKeyboardProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnSysShellProc_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ int nCode,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfSysHookSink_OnSysShellProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSysHookSink_INTERFACE_DEFINED__ */


#ifndef __ITfStartReconversionNotifySink_INTERFACE_DEFINED__
#define __ITfStartReconversionNotifySink_INTERFACE_DEFINED__

/* interface ITfStartReconversionNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfStartReconversionNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b9cd19cb-2919-4935-8768-ef30bae9a0cc")
    ITfStartReconversionNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartReconversion( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndReconversion( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfStartReconversionNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfStartReconversionNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfStartReconversionNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfStartReconversionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartReconversion )( 
            ITfStartReconversionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndReconversion )( 
            ITfStartReconversionNotifySink * This);
        
        END_INTERFACE
    } ITfStartReconversionNotifySinkVtbl;

    interface ITfStartReconversionNotifySink
    {
        CONST_VTBL struct ITfStartReconversionNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfStartReconversionNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfStartReconversionNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfStartReconversionNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfStartReconversionNotifySink_StartReconversion(This)	\
    (This)->lpVtbl -> StartReconversion(This)

#define ITfStartReconversionNotifySink_EndReconversion(This)	\
    (This)->lpVtbl -> EndReconversion(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfStartReconversionNotifySink_StartReconversion_Proxy( 
    ITfStartReconversionNotifySink * This);


void __RPC_STUB ITfStartReconversionNotifySink_StartReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfStartReconversionNotifySink_EndReconversion_Proxy( 
    ITfStartReconversionNotifySink * This);


void __RPC_STUB ITfStartReconversionNotifySink_EndReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfStartReconversionNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarEventSink_P_INTERFACE_DEFINED__
#define __ITfLangBarEventSink_P_INTERFACE_DEFINED__

/* interface ITfLangBarEventSink_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarEventSink_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a460360-da21-4b09-a8a0-8a69e728d893")
    ITfLangBarEventSink_P : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLangBarUpdate( 
            /* [in] */ UINT uPdate,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarEventSink_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarEventSink_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarEventSink_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarEventSink_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLangBarUpdate )( 
            ITfLangBarEventSink_P * This,
            /* [in] */ UINT uPdate,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfLangBarEventSink_PVtbl;

    interface ITfLangBarEventSink_P
    {
        CONST_VTBL struct ITfLangBarEventSink_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarEventSink_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarEventSink_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarEventSink_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarEventSink_P_OnLangBarUpdate(This,uPdate,lParam)	\
    (This)->lpVtbl -> OnLangBarUpdate(This,uPdate,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_P_OnLangBarUpdate_Proxy( 
    ITfLangBarEventSink_P * This,
    /* [in] */ UINT uPdate,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfLangBarEventSink_P_OnLangBarUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarEventSink_P_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarMgr_P_INTERFACE_DEFINED__
#define __ITfLangBarMgr_P_INTERFACE_DEFINED__

/* interface ITfLangBarMgr_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d72c0fa9-add5-4af0-8706-4fa9ae3e2eff")
    ITfLangBarMgr_P : public ITfLangBarMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPrevShowFloatingStatus( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventSink )( 
            ITfLangBarMgr_P * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseEventSink )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadMarshalInterface )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadLangBarItemMgr )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfLangBarItemMgr **pplbi,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputProcessorProfiles )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfInputProcessorProfiles **ppaip,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreLastFocus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwThreadId,
            /* [in] */ BOOL fPrev);
        
        HRESULT ( STDMETHODCALLTYPE *SetModalInput )( 
            ITfLangBarMgr_P * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ShowFloating )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowFloatingStatus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrevShowFloatingStatus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } ITfLangBarMgr_PVtbl;

    interface ITfLangBarMgr_P
    {
        CONST_VTBL struct ITfLangBarMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarMgr_P_AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)	\
    (This)->lpVtbl -> AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)

#define ITfLangBarMgr_P_UnadviseEventSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseEventSink(This,dwCookie)

#define ITfLangBarMgr_P_GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)	\
    (This)->lpVtbl -> GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)

#define ITfLangBarMgr_P_GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)	\
    (This)->lpVtbl -> GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)

#define ITfLangBarMgr_P_GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)	\
    (This)->lpVtbl -> GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)

#define ITfLangBarMgr_P_RestoreLastFocus(This,pdwThreadId,fPrev)	\
    (This)->lpVtbl -> RestoreLastFocus(This,pdwThreadId,fPrev)

#define ITfLangBarMgr_P_SetModalInput(This,pSink,dwThreadId,dwFlags)	\
    (This)->lpVtbl -> SetModalInput(This,pSink,dwThreadId,dwFlags)

#define ITfLangBarMgr_P_ShowFloating(This,dwFlags)	\
    (This)->lpVtbl -> ShowFloating(This,dwFlags)

#define ITfLangBarMgr_P_GetShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetShowFloatingStatus(This,pdwFlags)


#define ITfLangBarMgr_P_GetPrevShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetPrevShowFloatingStatus(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarMgr_P_GetPrevShowFloatingStatus_Proxy( 
    ITfLangBarMgr_P * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ITfLangBarMgr_P_GetPrevShowFloatingStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfContext_P_INTERFACE_DEFINED__
#define __ITfContext_P_INTERFACE_DEFINED__

/* interface ITfContext_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContext_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2dee47c8-704d-42a0-9983-ffeed659b64d")
    ITfContext_P : public ITfContext
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapAppProperty( 
            /* [in] */ REFGUID guidAppProp,
            /* [in] */ REFGUID guidProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContext_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContext_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContext_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContext_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestEditSession )( 
            ITfContext_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfEditSession *pes,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HRESULT *phrSession);
        
        HRESULT ( STDMETHODCALLTYPE *InWriteSession )( 
            ITfContext_P * This,
            /* [in] */ TfClientId tid,
            /* [out] */ BOOL *pfWriteSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const TF_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetStart )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnd )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveView )( 
            ITfContext_P * This,
            /* [out] */ ITfContextView **ppView);
        
        HRESULT ( STDMETHODCALLTYPE *EnumViews )( 
            ITfContext_P * This,
            /* [out] */ IEnumTfContextViews **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfContext_P * This,
            /* [out] */ TF_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfReadOnlyProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *TrackProperties )( 
            ITfContext_P * This,
            /* [size_is][in] */ const GUID **prgProp,
            /* [in] */ ULONG cProp,
            /* [size_is][in] */ const GUID **prgAppProp,
            /* [in] */ ULONG cAppProp,
            /* [out] */ ITfReadOnlyProperty **ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            ITfContext_P * This,
            /* [out] */ IEnumTfProperties **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentMgr )( 
            ITfContext_P * This,
            /* [out] */ ITfDocumentMgr **ppDm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRangeBackup )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRangeBackup **ppBackup);
        
        HRESULT ( STDMETHODCALLTYPE *MapAppProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidAppProp,
            /* [in] */ REFGUID guidProp);
        
        END_INTERFACE
    } ITfContext_PVtbl;

    interface ITfContext_P
    {
        CONST_VTBL struct ITfContext_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContext_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContext_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContext_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContext_P_RequestEditSession(This,tid,pes,dwFlags,phrSession)	\
    (This)->lpVtbl -> RequestEditSession(This,tid,pes,dwFlags,phrSession)

#define ITfContext_P_InWriteSession(This,tid,pfWriteSession)	\
    (This)->lpVtbl -> InWriteSession(This,tid,pfWriteSession)

#define ITfContext_P_GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)	\
    (This)->lpVtbl -> GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)

#define ITfContext_P_SetSelection(This,ec,ulCount,pSelection)	\
    (This)->lpVtbl -> SetSelection(This,ec,ulCount,pSelection)

#define ITfContext_P_GetStart(This,ec,ppStart)	\
    (This)->lpVtbl -> GetStart(This,ec,ppStart)

#define ITfContext_P_GetEnd(This,ec,ppEnd)	\
    (This)->lpVtbl -> GetEnd(This,ec,ppEnd)

#define ITfContext_P_GetActiveView(This,ppView)	\
    (This)->lpVtbl -> GetActiveView(This,ppView)

#define ITfContext_P_EnumViews(This,ppEnum)	\
    (This)->lpVtbl -> EnumViews(This,ppEnum)

#define ITfContext_P_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITfContext_P_GetProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetProperty(This,guidProp,ppProp)

#define ITfContext_P_GetAppProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetAppProperty(This,guidProp,ppProp)

#define ITfContext_P_TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)	\
    (This)->lpVtbl -> TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)

#define ITfContext_P_EnumProperties(This,ppEnum)	\
    (This)->lpVtbl -> EnumProperties(This,ppEnum)

#define ITfContext_P_GetDocumentMgr(This,ppDm)	\
    (This)->lpVtbl -> GetDocumentMgr(This,ppDm)

#define ITfContext_P_CreateRangeBackup(This,ec,pRange,ppBackup)	\
    (This)->lpVtbl -> CreateRangeBackup(This,ec,pRange,ppBackup)


#define ITfContext_P_MapAppProperty(This,guidAppProp,guidProp)	\
    (This)->lpVtbl -> MapAppProperty(This,guidAppProp,guidProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContext_P_MapAppProperty_Proxy( 
    ITfContext_P * This,
    /* [in] */ REFGUID guidAppProp,
    /* [in] */ REFGUID guidProp);


void __RPC_STUB ITfContext_P_MapAppProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContext_P_INTERFACE_DEFINED__ */


#ifndef __ITfRangeChangeSink_INTERFACE_DEFINED__
#define __ITfRangeChangeSink_INTERFACE_DEFINED__

/* interface ITfRangeChangeSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeChangeSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1a0e6af-0d60-4800-9796-1fe8e85c0cca")
    ITfRangeChangeSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnChange( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeChangeSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeChangeSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeChangeSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeChangeSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            ITfRangeChangeSink * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfRangeChangeSinkVtbl;

    interface ITfRangeChangeSink
    {
        CONST_VTBL struct ITfRangeChangeSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeChangeSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeChangeSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeChangeSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeChangeSink_OnChange(This,pRange)	\
    (This)->lpVtbl -> OnChange(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeChangeSink_OnChange_Proxy( 
    ITfRangeChangeSink * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfRangeChangeSink_OnChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeChangeSink_INTERFACE_DEFINED__ */


#ifndef __ITfFnAbort_INTERFACE_DEFINED__
#define __ITfFnAbort_INTERFACE_DEFINED__

/* interface ITfFnAbort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnAbort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17f2317f-addb-49df-870e-66227bc51d1a")
    ITfFnAbort : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnAbortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnAbort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnAbort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnAbort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnAbort * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ITfFnAbort * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfFnAbortVtbl;

    interface ITfFnAbort
    {
        CONST_VTBL struct ITfFnAbortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnAbort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnAbort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnAbort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnAbort_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnAbort_Abort(This,pic)	\
    (This)->lpVtbl -> Abort(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnAbort_Abort_Proxy( 
    ITfFnAbort * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfFnAbort_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnAbort_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_INTERFACE_DEFINED__
#define __ITfMouseTrackerAnchor_INTERFACE_DEFINED__

/* interface ITfMouseTrackerAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTrackerAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f9f4e0f2-d600-4a4c-b144-77e201ebd1b0")
    ITfMouseTrackerAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTrackerAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTrackerAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerAnchorVtbl;

    interface ITfMouseTrackerAnchor
    {
        CONST_VTBL struct ITfMouseTrackerAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTrackerAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTrackerAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTrackerAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTrackerAnchor_AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)

#define ITfMouseTrackerAnchor_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_AdviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_UnadviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTrackerAnchor_INTERFACE_DEFINED__ */


#ifndef __ITfRangeAnchor_INTERFACE_DEFINED__
#define __ITfRangeAnchor_INTERFACE_DEFINED__

/* interface ITfRangeAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8b99712b-5815-4bcc-b9a9-53db1c8d6755")
    ITfRangeAnchor : public ITfRange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtent( 
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtent( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRangeAnchor * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtent )( 
            ITfRangeAnchor * This,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtent )( 
            ITfRangeAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd);
        
        END_INTERFACE
    } ITfRangeAnchorVtbl;

    interface ITfRangeAnchor
    {
        CONST_VTBL struct ITfRangeAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeAnchor_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRangeAnchor_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRangeAnchor_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRangeAnchor_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRangeAnchor_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRangeAnchor_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRangeAnchor_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRangeAnchor_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRangeAnchor_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRangeAnchor_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRangeAnchor_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRangeAnchor_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfRangeAnchor_GetExtent(This,ppaStart,ppaEnd)	\
    (This)->lpVtbl -> GetExtent(This,ppaStart,ppaEnd)

#define ITfRangeAnchor_SetExtent(This,paStart,paEnd)	\
    (This)->lpVtbl -> SetExtent(This,paStart,paEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeAnchor_GetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [out] */ IAnchor **ppaStart,
    /* [out] */ IAnchor **ppaEnd);


void __RPC_STUB ITfRangeAnchor_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRangeAnchor_SetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd);


void __RPC_STUB ITfRangeAnchor_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);






/* interface __MIDL_itf_msctfp_0222 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("af9f076f-4937-4285-8600-81dca5c31eb6") struct TF_PERSISTENT_PROPERTY_HEADER_ANCHOR
    {
    GUID guidType;
    IAnchor *paStart;
    IAnchor *paEnd;
    ULONG cb;
    DWORD dwPrivate;
    CLSID clsidTIP;
    } 	TF_PERSISTENT_PROPERTY_HEADER_ANCHOR;

#endif 	/* __ITfRangeAnchor_INTERFACE_DEFINED__ */

extern RPC_IF_HANDLE __MIDL_itf_msctfp_0222_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0222_v0_0_s_ifspec;

#ifndef __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__

/* interface ITfPersistentPropertyLoaderAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPersistentPropertyLoaderAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2133f790-34c2-11d3-a745-0050040ab407")
    ITfPersistentPropertyLoaderAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadProperty( 
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPersistentPropertyLoaderAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProperty )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream);
        
        END_INTERFACE
    } ITfPersistentPropertyLoaderAnchorVtbl;

    interface ITfPersistentPropertyLoaderAnchor
    {
        CONST_VTBL struct ITfPersistentPropertyLoaderAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPersistentPropertyLoaderAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPersistentPropertyLoaderAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPersistentPropertyLoaderAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPersistentPropertyLoaderAnchor_LoadProperty(This,pHdr,ppStream)	\
    (This)->lpVtbl -> LoadProperty(This,pHdr,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPersistentPropertyLoaderAnchor_LoadProperty_Proxy( 
    ITfPersistentPropertyLoaderAnchor * This,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [out] */ IStream **ppStream);


void __RPC_STUB ITfPersistentPropertyLoaderAnchor_LoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__ */


#ifndef __ITextStoreAnchorServices_INTERFACE_DEFINED__
#define __ITextStoreAnchorServices_INTERFACE_DEFINED__

/* interface ITextStoreAnchorServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreAnchorServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e9fe-2021-11d2-93e0-0060b067b86e")
    ITextStoreAnchorServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreAnchorServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreAnchorServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreAnchorServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreAnchorServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITextStoreAnchorServices * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange);
        
        END_INTERFACE
    } ITextStoreAnchorServicesVtbl;

    interface ITextStoreAnchorServices
    {
        CONST_VTBL struct ITextStoreAnchorServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreAnchorServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreAnchorServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreAnchorServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreAnchorServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITextStoreAnchorServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITextStoreAnchorServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITextStoreAnchorServices_CreateRange(This,paStart,paEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,paStart,paEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Serialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITextStoreAnchorServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Unserialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);


void __RPC_STUB ITextStoreAnchorServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_ForceLoadProperty_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITextStoreAnchorServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_CreateRange_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [out] */ ITfRangeAnchor **ppRange);


void __RPC_STUB ITextStoreAnchorServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreAnchorServices_INTERFACE_DEFINED__ */


#ifndef __ITfProperty2_INTERFACE_DEFINED__
#define __ITfProperty2_INTERFACE_DEFINED__

/* interface ITfProperty2 */
/* [unique][uuid][object] */ 

#define	TF_FNV_BACKWARD	( 0x1 )

#define	TF_FNV_NO_CONTAINED	( 0x2 )


EXTERN_C const IID IID_ITfProperty2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("db261faa-2142-486a-b5c6-d2101bc03d2e")
    ITfProperty2 : public ITfProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindNextValue( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfContained,
            /* [out] */ ITfRange **ppRangeNextValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfProperty2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfProperty2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfProperty2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfProperty2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfProperty2 * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRanges )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfProperty2 * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *FindRange )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueStore )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ const VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfContained,
            /* [out] */ ITfRange **ppRangeNextValue);
        
        END_INTERFACE
    } ITfProperty2Vtbl;

    interface ITfProperty2
    {
        CONST_VTBL struct ITfProperty2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfProperty2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfProperty2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfProperty2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfProperty2_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfProperty2_EnumRanges(This,ec,ppEnum,pTargetRange)	\
    (This)->lpVtbl -> EnumRanges(This,ec,ppEnum,pTargetRange)

#define ITfProperty2_GetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,ec,pRange,pvarValue)

#define ITfProperty2_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfProperty2_FindRange(This,ec,pRange,ppRange,aPos)	\
    (This)->lpVtbl -> FindRange(This,ec,pRange,ppRange,aPos)

#define ITfProperty2_SetValueStore(This,ec,pRange,pPropStore)	\
    (This)->lpVtbl -> SetValueStore(This,ec,pRange,pPropStore)

#define ITfProperty2_SetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,ec,pRange,pvarValue)

#define ITfProperty2_Clear(This,ec,pRange)	\
    (This)->lpVtbl -> Clear(This,ec,pRange)


#define ITfProperty2_FindNextValue(This,ec,pRangeQuery,tfAnchorQuery,dwFlags,pfContained,ppRangeNextValue)	\
    (This)->lpVtbl -> FindNextValue(This,ec,pRangeQuery,tfAnchorQuery,dwFlags,pfContained,ppRangeNextValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfProperty2_FindNextValue_Proxy( 
    ITfProperty2 * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRangeQuery,
    /* [in] */ TfAnchor tfAnchorQuery,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BOOL *pfContained,
    /* [out] */ ITfRange **ppRangeNextValue);


void __RPC_STUB ITfProperty2_FindNextValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfProperty2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0225 */
/* [local] */ 

#define	TF_DA_PRIORITY_HIGHEST	( 0 )

#define	TF_DA_PRIORITY_DEFAULT_SPELLING	( 8 )

#define	TF_DA_PRIORITY_DEFAULT_GRAMMAR	( 16 )

#define	TF_DA_PRIORITY_DEFAULT	( 24 )

#define	TF_DA_PRIORITY_LOWEST	( 31 )

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_msctfp_0225_0001
    {
    ULONG uPriority;
    GUID guidProperty;
    } 	TF_DA_PROPERTY;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0225_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0225_v0_0_s_ifspec;

#ifndef __IEnumTfCollection_INTERFACE_DEFINED__
#define __IEnumTfCollection_INTERFACE_DEFINED__

/* interface IEnumTfCollection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c760b20-ed66-4dbd-9ff1-68fc21c02922")
    IEnumTfCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfCollection **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfCollection * This,
            /* [out] */ IEnumTfCollection **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfCollection * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfCollection * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfCollectionVtbl;

    interface IEnumTfCollection
    {
        CONST_VTBL struct IEnumTfCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfCollection_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define IEnumTfCollection_Next(This,ulCount,rgCollection,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgCollection,pcFetched)

#define IEnumTfCollection_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfCollection_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfCollection_Clone_Proxy( 
    IEnumTfCollection * This,
    /* [out] */ IEnumTfCollection **ppClone);


void __RPC_STUB IEnumTfCollection_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Next_Proxy( 
    IEnumTfCollection * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfCollection_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Reset_Proxy( 
    IEnumTfCollection * This);


void __RPC_STUB IEnumTfCollection_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Skip_Proxy( 
    IEnumTfCollection * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfCollection_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfCollection_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__
#define __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeCollectionMgr */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeCollectionMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4e3d2d48-3c17-457d-84a1-f209476de897")
    ITfDisplayAttributeCollectionMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCollections( 
            /* [out] */ IEnumTfCollection **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeCollectionMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeCollectionMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeCollectionMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeCollectionMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCollections )( 
            ITfDisplayAttributeCollectionMgr * This,
            /* [out] */ IEnumTfCollection **ppEnum);
        
        END_INTERFACE
    } ITfDisplayAttributeCollectionMgrVtbl;

    interface ITfDisplayAttributeCollectionMgr
    {
        CONST_VTBL struct ITfDisplayAttributeCollectionMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeCollectionMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeCollectionMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeCollectionMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeCollectionMgr_EnumCollections(This,ppEnum)	\
    (This)->lpVtbl -> EnumCollections(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionMgr_EnumCollections_Proxy( 
    ITfDisplayAttributeCollectionMgr * This,
    /* [out] */ IEnumTfCollection **ppEnum);


void __RPC_STUB ITfDisplayAttributeCollectionMgr_EnumCollections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__
#define __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeCollectionProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeCollectionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3977526d-1a0a-435a-8d06-ecc9516b484f")
    ITfDisplayAttributeCollectionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCollectionCount( 
            /* [out] */ ULONG *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
            /* [out] */ ULONG *pcGUIDsOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeCollectionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeCollectionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeCollectionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCollectionCount )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [out] */ ULONG *puCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetCollection )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
            /* [out] */ ULONG *pcGUIDsOut);
        
        END_INTERFACE
    } ITfDisplayAttributeCollectionProviderVtbl;

    interface ITfDisplayAttributeCollectionProvider
    {
        CONST_VTBL struct ITfDisplayAttributeCollectionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeCollectionProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeCollectionProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeCollectionProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeCollectionProvider_GetCollectionCount(This,puCount)	\
    (This)->lpVtbl -> GetCollectionCount(This,puCount)

#define ITfDisplayAttributeCollectionProvider_GetCollection(This,uCount,prgProperty,pcGUIDsOut)	\
    (This)->lpVtbl -> GetCollection(This,uCount,prgProperty,pcGUIDsOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionProvider_GetCollectionCount_Proxy( 
    ITfDisplayAttributeCollectionProvider * This,
    /* [out] */ ULONG *puCount);


void __RPC_STUB ITfDisplayAttributeCollectionProvider_GetCollectionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionProvider_GetCollection_Proxy( 
    ITfDisplayAttributeCollectionProvider * This,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
    /* [out] */ ULONG *pcGUIDsOut);


void __RPC_STUB ITfDisplayAttributeCollectionProvider_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0228 */
/* [local] */ 

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_msctfp_0228_0001
    {
    ITfRange *pRange;
    TF_DISPLAYATTRIBUTE tfDisplayAttr;
    } 	TF_RENDERINGMARKUP;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0228_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0228_v0_0_s_ifspec;

#ifndef __IEnumTfRenderingMarkup_INTERFACE_DEFINED__
#define __IEnumTfRenderingMarkup_INTERFACE_DEFINED__

/* interface IEnumTfRenderingMarkup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfRenderingMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c03d21b-95a7-4ba0-ae1b-7fce12a72930")
    IEnumTfRenderingMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfRenderingMarkup **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfRenderingMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfRenderingMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfRenderingMarkup * This,
            /* [out] */ IEnumTfRenderingMarkup **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfRenderingMarkupVtbl;

    interface IEnumTfRenderingMarkup
    {
        CONST_VTBL struct IEnumTfRenderingMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfRenderingMarkup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfRenderingMarkup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfRenderingMarkup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfRenderingMarkup_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define IEnumTfRenderingMarkup_Next(This,ulCount,rgMarkup,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgMarkup,pcFetched)

#define IEnumTfRenderingMarkup_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfRenderingMarkup_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Clone_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [out] */ IEnumTfRenderingMarkup **ppClone);


void __RPC_STUB IEnumTfRenderingMarkup_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Next_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfRenderingMarkup_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Reset_Proxy( 
    IEnumTfRenderingMarkup * This);


void __RPC_STUB IEnumTfRenderingMarkup_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Skip_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfRenderingMarkup_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfRenderingMarkup_INTERFACE_DEFINED__ */


#ifndef __ITfContextRenderingMarkup_INTERFACE_DEFINED__
#define __ITfContextRenderingMarkup_INTERFACE_DEFINED__

/* interface ITfContextRenderingMarkup */
/* [unique][uuid][object] */ 

#define	TF_GRM_INCLUDE_PROPERTY	( 0x1 )

#define	TF_FRM_INCLUDE_PROPERTY	( 0x1 )

#define	TF_FRM_BACKWARD	( 0x2 )

#define	TF_FRM_NO_CONTAINED	( 0x4 )

#define	TF_FRM_NO_RANGE	( 0x8 )


EXTERN_C const IID IID_ITfContextRenderingMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a305b1c0-c776-4523-bda0-7c5a2e0fef10")
    ITfContextRenderingMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRenderingMarkup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeCover,
            /* [out] */ IEnumTfRenderingMarkup **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextRenderingMarkup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [out] */ ITfRange **ppRangeFound,
            /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextRenderingMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextRenderingMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingMarkup )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeCover,
            /* [out] */ IEnumTfRenderingMarkup **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextRenderingMarkup )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [out] */ ITfRange **ppRangeFound,
            /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup);
        
        END_INTERFACE
    } ITfContextRenderingMarkupVtbl;

    interface ITfContextRenderingMarkup
    {
        CONST_VTBL struct ITfContextRenderingMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextRenderingMarkup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextRenderingMarkup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextRenderingMarkup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextRenderingMarkup_GetRenderingMarkup(This,ec,dwFlags,pRangeCover,ppEnum)	\
    (This)->lpVtbl -> GetRenderingMarkup(This,ec,dwFlags,pRangeCover,ppEnum)

#define ITfContextRenderingMarkup_FindNextRenderingMarkup(This,ec,dwFlags,pRangeQuery,tfAnchorQuery,ppRangeFound,ptfRenderingMarkup)	\
    (This)->lpVtbl -> FindNextRenderingMarkup(This,ec,dwFlags,pRangeQuery,tfAnchorQuery,ppRangeFound,ptfRenderingMarkup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextRenderingMarkup_GetRenderingMarkup_Proxy( 
    ITfContextRenderingMarkup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeCover,
    /* [out] */ IEnumTfRenderingMarkup **ppEnum);


void __RPC_STUB ITfContextRenderingMarkup_GetRenderingMarkup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextRenderingMarkup_FindNextRenderingMarkup_Proxy( 
    ITfContextRenderingMarkup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeQuery,
    /* [in] */ TfAnchor tfAnchorQuery,
    /* [out] */ ITfRange **ppRangeFound,
    /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup);


void __RPC_STUB ITfContextRenderingMarkup_FindNextRenderingMarkup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextRenderingMarkup_INTERFACE_DEFINED__ */


#ifndef __ITfBackgroundThreadMgr_INTERFACE_DEFINED__
#define __ITfBackgroundThreadMgr_INTERFACE_DEFINED__

/* interface ITfBackgroundThreadMgr */
/* [unique][uuid][local][object] */ 

typedef BOOL ( *TfBackgroundThreadCallback )( 
    /* [in] */ BOOL fCleanup,
    /* [in] */ void *pvPrivate);

typedef BOOL ( *TfWakeAppBackgroundThreadProc )( void);


EXTERN_C const IID IID_ITfBackgroundThreadMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38462b47-6127-4464-bd2f-46957c31ad0e")
    ITfBackgroundThreadMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AppInitBackgroundThread( 
            /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
            /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
            /* [out] */ void **ppvPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppUninitBackgroundThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseBackgroundCallback( 
            /* [in] */ TfBackgroundThreadCallback pfnCallback,
            /* [in] */ void *pvPrivate,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseBackgroundCallback( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WakeBackgroundThread( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfBackgroundThreadMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfBackgroundThreadMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfBackgroundThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppInitBackgroundThread )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
            /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
            /* [out] */ void **ppvPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *AppUninitBackgroundThread )( 
            ITfBackgroundThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseBackgroundCallback )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ TfBackgroundThreadCallback pfnCallback,
            /* [in] */ void *pvPrivate,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseBackgroundCallback )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *WakeBackgroundThread )( 
            ITfBackgroundThreadMgr * This);
        
        END_INTERFACE
    } ITfBackgroundThreadMgrVtbl;

    interface ITfBackgroundThreadMgr
    {
        CONST_VTBL struct ITfBackgroundThreadMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfBackgroundThreadMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfBackgroundThreadMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfBackgroundThreadMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfBackgroundThreadMgr_AppInitBackgroundThread(This,pfnWakeThread,ppfnCallback,ppvPrivate)	\
    (This)->lpVtbl -> AppInitBackgroundThread(This,pfnWakeThread,ppfnCallback,ppvPrivate)

#define ITfBackgroundThreadMgr_AppUninitBackgroundThread(This)	\
    (This)->lpVtbl -> AppUninitBackgroundThread(This)

#define ITfBackgroundThreadMgr_AdviseBackgroundCallback(This,pfnCallback,pvPrivate,pdwCookie)	\
    (This)->lpVtbl -> AdviseBackgroundCallback(This,pfnCallback,pvPrivate,pdwCookie)

#define ITfBackgroundThreadMgr_UnadviseBackgroundCallback(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseBackgroundCallback(This,dwCookie)

#define ITfBackgroundThreadMgr_WakeBackgroundThread(This)	\
    (This)->lpVtbl -> WakeBackgroundThread(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AppInitBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
    /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
    /* [out] */ void **ppvPrivate);


void __RPC_STUB ITfBackgroundThreadMgr_AppInitBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AppUninitBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This);


void __RPC_STUB ITfBackgroundThreadMgr_AppUninitBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AdviseBackgroundCallback_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ TfBackgroundThreadCallback pfnCallback,
    /* [in] */ void *pvPrivate,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfBackgroundThreadMgr_AdviseBackgroundCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_UnadviseBackgroundCallback_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfBackgroundThreadMgr_UnadviseBackgroundCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_WakeBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This);


void __RPC_STUB ITfBackgroundThreadMgr_WakeBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfBackgroundThreadMgr_INTERFACE_DEFINED__ */


#ifndef __ITfEnableService_INTERFACE_DEFINED__
#define __ITfEnableService_INTERFACE_DEFINED__

/* interface ITfEnableService */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfEnableService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3035d250-43b4-4253-81e6-ea87fd3eed43")
    ITfEnableService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEnabled( 
            /* [in] */ REFGUID rguidServiceCategory,
            /* [in] */ CLSID clsidService,
            /* [in] */ IUnknown *punkService,
            /* [out] */ BOOL *pfOkToRun) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ GUID *pguidId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfEnableServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfEnableService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfEnableService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfEnableService * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabled )( 
            ITfEnableService * This,
            /* [in] */ REFGUID rguidServiceCategory,
            /* [in] */ CLSID clsidService,
            /* [in] */ IUnknown *punkService,
            /* [out] */ BOOL *pfOkToRun);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            ITfEnableService * This,
            /* [out] */ GUID *pguidId);
        
        END_INTERFACE
    } ITfEnableServiceVtbl;

    interface ITfEnableService
    {
        CONST_VTBL struct ITfEnableServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfEnableService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfEnableService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfEnableService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfEnableService_IsEnabled(This,rguidServiceCategory,clsidService,punkService,pfOkToRun)	\
    (This)->lpVtbl -> IsEnabled(This,rguidServiceCategory,clsidService,punkService,pfOkToRun)

#define ITfEnableService_GetId(This,pguidId)	\
    (This)->lpVtbl -> GetId(This,pguidId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfEnableService_IsEnabled_Proxy( 
    ITfEnableService * This,
    /* [in] */ REFGUID rguidServiceCategory,
    /* [in] */ CLSID clsidService,
    /* [in] */ IUnknown *punkService,
    /* [out] */ BOOL *pfOkToRun);


void __RPC_STUB ITfEnableService_IsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfEnableService_GetId_Proxy( 
    ITfEnableService * This,
    /* [out] */ GUID *pguidId);


void __RPC_STUB ITfEnableService_GetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfEnableService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0232 */
/* [local] */ 

EXTERN_C const GUID GUID_COMPARTMENT_ENABLESTATE;
#endif // MSCTFP_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_msctfp_0232_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0232_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\msctf_g.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#include "cicclsid.c"

/* f1e2d520-0969-11d3-8df0-00105a2799b5 */
const GUID GUID_PROP_TEXTOWNER = { 
    0xf1e2d520,
    0x0969,
    0x11d3,
    {0x8d, 0xf0, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 34b45670-7526-11d2-a147-00105a2799b5 */
const GUID GUID_PROP_ATTRIBUTE = { 
    0x34b45670,
    0x7526,
    0x11d2,
    {0xa1, 0x47, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };


/* 3280ce20-8032-11d2-b603-00105a2799b5 */
const GUID GUID_PROP_LANGID = { 
    0x3280ce20,
    0x8032,
    0x11d2,
    {0xb6, 0x03, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 5463f7c0-8e31-11d2-bf46-00105a2799b5 */
const GUID GUID_PROP_READING = { 
    0x5463f7c0,
    0x8e31,
    0x11d2,
    {0xbf, 0x46, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* e12ac060-af15-11d2-afc5-00105a2799b5 */
const GUID GUID_PROP_COMPOSING = {
    0xe12ac060,
    0xaf15,
    0x11d2,
    {0xaf, 0xc5, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 9a698bb0-0f21-11d3-8df1-00105a2799b5 */
const GUID GUID_SYSTEM_FUNCTIONPROVIDER = { 
    0x9a698bb0,
    0x0f21,
    0x11d3,
    {0x8d, 0xf1, 0x00, 0x10, 0x5a, 0x27, 0x99, 0xb5}
  };

/* 4caef01e-12af-4b0e-9db1-a6ec5b881208 */
const GUID GUID_APP_FUNCTIONPROVIDER = { 
    0x4caef01e,
    0x12af,
    0x4b0e,
    {0x9d, 0xb1, 0xa6, 0xec, 0x5b, 0x88, 0x12, 0x08}
  };


/* 534c48c1-0607-4098-a521-4fc899c73e90 */
const GUID GUID_TFCAT_CATEGORY_OF_TIP = { 
    0x534c48c1,
    0x0607,
    0x4098,
    {0xa5, 0x21, 0x4f, 0xc8, 0x99, 0xc7, 0x3e, 0x90}
  };

/* 34745c63-b2f0-4784-8b67-5e12c8701a31 */
const GUID GUID_TFCAT_TIP_KEYBOARD = { 
    0x34745c63,
    0xb2f0,
    0x4784,
    {0x8b, 0x67, 0x5e, 0x12, 0xc8, 0x70, 0x1a, 0x31}
  };

/* b5a73cd1-8355-426b-a161-259808f26b14 */
const GUID GUID_TFCAT_TIP_SPEECH = { 
    0xb5a73cd1,
    0x8355,
    0x426b,
    {0xa1, 0x61, 0x25, 0x98, 0x08, 0xf2, 0x6b, 0x14}
  };

/* 246ecb87-c2f2-4abe-905b-c8b38add2c43 */
const GUID GUID_TFCAT_TIP_HANDWRITING = { 
    0x246ecb87,
    0xc2f2,
    0x4abe,
    {0x90, 0x5b, 0xc8, 0xb3, 0x8a, 0xdd, 0x2c, 0x43}
  };

/* c6debc0a-f2b2-4f17-930e-ca9faff4cd04 */
const GUID GUID_TFCAT_TIP_LOOKUP = { 
    0xc6debc0a,
    0xf2b2,
    0x4f17,
    {0x93, 0x0e, 0xca, 0x9f, 0xaf, 0xf4, 0xcd, 0x04}
  };

/* 9b7be3a9-e8ab-4d47-a8fe-254fa423436d */
const GUID GUID_TFCAT_PROP_AUDIODATA = { 
    0x9b7be3a9,
    0xe8ab,
    0x4d47,
    {0xa8, 0xfe, 0x25, 0x4f, 0xa4, 0x23, 0x43, 0x6d}
  };

/* 7c6a82ae-b0d7-4f14-a745-14f28b009d61 */
const GUID GUID_TFCAT_PROP_INKDATA = { 
    0x7c6a82ae,
    0xb0d7,
    0x4f14,
    {0xa7, 0x45, 0x14, 0xf2, 0x8b, 0x00, 0x9d, 0x61}
  };

/* 51af2086-cc6b-457d-b5aa-8b19dc290ab4 */
const GUID GUID_COMPARTMENT_SAPI_AUDIO= {
    0x51af2086,
    0xcc6b,
    0x457d,
    {0xb5, 0xaa, 0x8b, 0x19, 0xdc, 0x29, 0x0a, 0xb4}
};

/* 71a5b253-1951-466b-9fbc-9c8808fa84f2 */
const GUID GUID_COMPARTMENT_KEYBOARD_DISABLED = { 
    0x71a5b253,
    0x1951,
    0x466b,
    {0x9f, 0xbc, 0x9c, 0x88, 0x08, 0xfa, 0x84, 0xf2}
  };

/* 58273aad-01bb-4164-95c6-755ba0b5162d */
const GUID GUID_COMPARTMENT_KEYBOARD_OPENCLOSE = { 
    0x58273aad,
    0x01bb,
    0x4164,
    {0x95, 0xc6, 0x75, 0x5b, 0xa0, 0xb5, 0x16, 0x2d}
  };

/* f9ae2c6b-1866-4361-af72-7aa30948890e */
const GUID GUID_COMPARTMENT_HANDWRITING_OPENCLOSE = { 
    0xf9ae2c6b,
    0x1866,
    0x4361,
    {0xaf, 0x72, 0x7a, 0xa3, 0x09, 0x48, 0x89, 0x0e}
  };

/* 56c5c607-0703-4e59-8e52-cbc84e8bbe35 */
const GUID GUID_COMPARTMENT_SPEECH_DISABLED = { 
    0x56c5c607,
    0x0703,
    0x4e59,
    {0x8e, 0x52, 0xcb, 0xc8, 0x4e, 0x8b, 0xbe, 0x35}
  };

/* 544d6a63-e2e8-4752-bbd1-000960bca083 */
const GUID GUID_COMPARTMENT_SPEECH_OPENCLOSE = { 
    0x544d6a63,
    0xe2e8,
    0x4752,
    {0xbb, 0xd1, 0x00, 0x09, 0x60, 0xbc, 0xa0, 0x83}
  };

/* 5497f516-ee91-436e-b946-aa2c05f1ac5b */
const GUID GUID_COMPARTMENT_CONVERSIONMODEBIAS = {
    0x5497f516,
    0xee91,
    0x436e,
    {0xb9, 0x46, 0xaa, 0x2c, 0x05, 0xf1, 0xac, 0x5b}
  };

/* 372E0716-974F-40AC-A088-08CDC92EBFBC */
const GUID GUID_PROP_MODEBIAS = {
    0x372E0716,
    0x974F,
    0x40AC,
    {0xA0, 0x88, 0x08, 0xCD, 0xC9, 0x2E, 0xBF, 0xBC}
  };

/* b6592511-bcee-4122-a7c4-09f4b3fa4396 */
const GUID GUID_COMPARTMENT_KEYBOARD_INPUTMODE = {
    0xb6592511,
    0xbcee,
    0x4122,
    {0xa7, 0xc4, 0x09, 0xf4, 0xb3, 0xfa, 0x43, 0x96}
  };


/* GUID_NULL */
const GUID GUID_MODEBIAS_NONE = {
    0x00000000,
    0x0000,
    0x0000,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  };

/* d7f707fe-44c6-4fca-8e76-86ab50c7931b */
const GUID GUID_MODEBIAS_FILENAME = {
    0xd7f707fe,
    0x44c6,
    0x4fca,
    {0x8e, 0x76, 0x86, 0xab, 0x50, 0xc7, 0x93, 0x1b}
  };


/* e31643a3-6466-4cbf-8d8b-0bd4d8545461 */
const GUID GUID_MODEBIAS_READING = {
    0xe31643a3,
    0x6466,
    0x4cbf,
    {0x8d, 0x8b, 0x0b, 0xd4, 0xd8, 0x54, 0x54, 0x61}
  };


/* f2bdb372-7f61-4039-92ef-1c35599f0222 */
const GUID GUID_MODEBIAS_DATETIME = {
    0xf2bdb372,
    0x7f61,
    0x4039,
    {0x92, 0xef, 0x1c, 0x35, 0x59, 0x9f, 0x02, 0x22}
  };

/* fddc10f0-d239-49bf-b8fc-5410caaa427e */
const GUID GUID_MODEBIAS_NAME = {
    0xfddc10f0,
    0xd239,
    0x49bf,
    {0xb8, 0xfc, 0x54, 0x10, 0xca, 0xaa, 0x42, 0x7e}
  };

/* 0f4ec104-1790-443b-95f1-e10f939d6546 */
const GUID GUID_MODEBIAS_CONVERSATION = {
    0x0f4ec104,
    0x1790,
    0x443b,
    {0x95, 0xf1, 0xe1, 0x0f, 0x93, 0x9d, 0x65, 0x46}
  };

/* 4021766c-e872-48fd-9cee-4ec5c75e16c3 */
const GUID GUID_MODEBIAS_NUMERIC = {
    0x4021766c,
    0xe872,
    0x48fd,
    {0x9c, 0xee, 0x4e, 0xc5, 0xc7, 0x5e, 0x16, 0xc3}
  };

/* d73d316e-9b91-46f1-a280-31597f52c694 */
const GUID GUID_MODEBIAS_HIRAGANA = {
    0xd73d316e,
    0x9b91,
    0x46f1,
    {0xa2, 0x80, 0x31, 0x59, 0x7f, 0x52, 0xc6, 0x94}
  };

/* 2e0eeddd-3a1a-499e-8543-3c7ee7949811 */
const GUID GUID_MODEBIAS_KATAKANA = {
    0x2e0eeddd,
    0x3a1a,
    0x499e,
    {0x85, 0x43, 0x3c, 0x7e, 0xe7, 0x94, 0x98, 0x11}
  };


/* 76ef0541-23b3-4d77-a074-691801ccea17 */
const GUID GUID_MODEBIAS_HANGUL = {
    0x76ef0541,
    0x23b3,
    0x4d77,
    {0xa0, 0x74, 0x69, 0x18, 0x01, 0xcc, 0xea, 0x17}
  };

/* 7add26de-4328-489b-83ae-6493750cad5c */
const GUID GUID_MODEBIAS_CHINESE = { 
    0x7add26de,
    0x4328,
    0x489b,
    {0x83, 0xae, 0x64, 0x93, 0x75, 0x0c, 0xad, 0x5c}
  };

/* 005f6b63-78d4-41cc-8859-485ca821a795 */
const GUID GUID_MODEBIAS_HALFWIDTHKATAKANA = {
    0x005f6b63,
    0x78d4,
    0x41cc,
    {0x88, 0x59, 0x48, 0x5c, 0xa8, 0x21, 0xa7, 0x95}
  };

/* 81489fb8-b36a-473d-8146-e4a2258b24ae */
const GUID GUID_MODEBIAS_FULLWIDTHALPHANUMERIC = {
    0x81489fb8,
    0xb36a,
    0x473d,
    {0x81, 0x46, 0xe4, 0xa2, 0x25, 0x8b, 0x24, 0xae}
  };

/* c6f24fc0-4479-46ed-938a-6052b1653d3b */
const GUID GUID_MODEBIAS_HALFWIDTHALPHANUMERIC = {
    0xc6f24fc0,
    0x4479,
    0x46ed,
    {0x93, 0x8a, 0x60, 0x52, 0xb1, 0x65, 0x3d, 0x3b}
  };

/* c01ae6c9-45b5-4fd0-9cb1-9f4cebc39fea */
const GUID GUID_MODEBIAS_FULLWIDTHHANGUL = { 
    0xc01ae6c9,
    0x45b5,
    0x4fd0,
    {0x9c, 0xb1, 0x9f, 0x4c, 0xeb, 0xc3, 0x9f, 0xea}
  };


/* 24af3031-852d-40a2-bc09-8992898ce722 */
const GUID GUID_TFCAT_PROPSTYLE_CUSTOM = { 
    0x24af3031,
    0x852d,
    0x40a2,
    {0xbc, 0x09, 0x89, 0x92, 0x89, 0x8c, 0xe7, 0x22}
  };

/* 565fb8d8-6bd4-4ca1-b223-0f2ccb8f4f96 */
const GUID GUID_TFCAT_PROPSTYLE_STATIC = { 
    0x565fb8d8,
    0x6bd4,
    0x4ca1,
    {0xb2, 0x23, 0x0f, 0x2c, 0xcb, 0x8f, 0x4f, 0x96}
  };

/* 85f9794b-4d19-40d8-8864-4e747371a66d */
const GUID GUID_TFCAT_PROPSTYLE_STATICCOMPACT = { 
    0x85f9794b,
    0x4d19,
    0x40d8,
    {0x88, 0x64, 0x4e, 0x74, 0x73, 0x71, 0xa6, 0x6d}
  };


/* aabf7f9a-4487-4b2e-8164-e54c5fe19204 */
const GUID GUID_SERVICE_CTF = { 
    0xaabf7f9a,
    0x4487,
    0x4b2e,
    {0x81, 0x64, 0xe5, 0x4c, 0x5f, 0xe1, 0x92, 0x04}
  };

/* 046b8c80-1647-40f7-9b21-b93b81aabc1b */
const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER = { 
    0x046b8c80,
    0x1647,
    0x40f7,
    {0x9b, 0x21, 0xb9, 0x3b, 0x81, 0xaa, 0xbc, 0x1b}
  };

/* b95f181b-ea4c-4af1-8056-7c321abbb091 */
const GUID GUID_TFCAT_DISPLAYATTRIBUTEPROPERTY = { 
    0xb95f181b,
    0xea4c,
    0x4af1,
    {0x80, 0x56, 0x7c, 0x32, 0x1a, 0xbb, 0xb0, 0x91}
  };

/* 1edb55cc-58f0-4592-aae1-fe51f43b95c5 */
const GUID GUID_COMPARTMENT_SPEECH_DICTATIONSTAT = {
    0x1edb55cc,
    0x58f0,
    0x4592,
    {0xaa, 0xe1, 0xfe, 0x51, 0xf4, 0x3b, 0x95, 0xc5 }
  };
/* 575F3783-70C8-47C8-AE5D-91A01A1F7592 */
const GUID GUID_COMPARTMENT_PERSISTMENUENABLED = {
    0x575F3783,
    0x70C8,
    0x47C8,
    {0xAE, 0x5D, 0x91, 0xA0, 0x1A, 0x1F, 0x75, 0x92 }
  };

/* D92016F0-9367-4FE7-9ABF-BC59DACBE0E3 */
const GUID GUID_COMPARTMENT_SPEECH_UI_STATUS = {
    0xD92016F0,
    0x9367,
    0x4FE7,
    {0x9A, 0xBF, 0xBC, 0x59, 0xDA, 0xCB, 0xE0, 0xE3 }
  };

/* d7487dbf-804e-41c5-894d-ad96fd4eea13 */
const GUID GUID_COMPARTMENT_EMPTYCONTEXT = { 
    0xd7487dbf,
    0x804e,
    0x41c5,
    {0x89, 0x4d, 0xad, 0x96, 0xfd, 0x4e, 0xea, 0x13}
  };

/* 148ca3ec-0366-401c-8d75-ed978d85fbc9 */
const GUID GUID_COMPARTMENT_TIPUISTATUS = {
    0x148ca3ec,
    0x0366,
    0x401c,
    {0x8d, 0x75, 0xed, 0x97, 0x8d, 0x85, 0xfb, 0xc9}
  };

/* fb6c5c2d-4e83-4bb6-91a2-e019bff6762d */
const GUID GUID_COMPARTMENT_SPEECH_CFGMENU = { 
    0xfb6c5c2d,
    0x4e83,
    0x4bb6,
    {0x91, 0xa2, 0xe0, 0x19, 0xbf, 0xf6, 0x76, 0x2d}
  };

/* D02F24A1-942D-422E-8D99-B4F2ADDEE999 */
const GUID GUID_LBI_SAPILAYR_CFGMENUBUTTON = {
    0xD02F24A1,
    0x942D,
    0x422E,
    {0x8D, 0x99, 0xB4, 0xF2, 0xAD, 0xDE, 0xE9, 0x99}
  };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\msctf_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for msctf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITfThreadMgr,0xaa80e801,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfThreadMgrEventSink,0xaa80e80e,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfConfigureSystemKeystrokeFeed,0x0d2c969a,0xbc9c,0x437c,0x84,0xee,0x95,0x1c,0x49,0xb1,0xa7,0x64);


MIDL_DEFINE_GUID(IID, IID_IEnumTfDocumentMgrs,0xaa80e808,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfDocumentMgr,0xaa80e7f4,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_IEnumTfContexts,0x8f1a7ea6,0x1654,0x4502,0xa8,0x6e,0xb2,0x90,0x23,0x44,0xd5,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfCompositionView,0xD7540241,0xF9A1,0x4364,0xBE,0xFC,0xDB,0xCD,0x2C,0x43,0x95,0xB7);


MIDL_DEFINE_GUID(IID, IID_IEnumITfCompositionView,0x5EFD22BA,0x7838,0x46CB,0x88,0xE2,0xCA,0xDB,0x14,0x12,0x4F,0x8F);


MIDL_DEFINE_GUID(IID, IID_ITfComposition,0x20168D64,0x5A8F,0x4A5A,0xB7,0xBD,0xCF,0xA2,0x9F,0x4D,0x0F,0xD9);


MIDL_DEFINE_GUID(IID, IID_ITfCompositionSink,0xA781718C,0x579A,0x4B15,0xA2,0x80,0x32,0xB8,0x57,0x7A,0xCC,0x5E);


MIDL_DEFINE_GUID(IID, IID_ITfContextComposition,0xD40C8AAE,0xAC92,0x4FC7,0x9A,0x11,0x0E,0xE0,0xE2,0x3A,0xA3,0x9B);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerCompositionServices,0x86462810,0x593B,0x4916,0x97,0x64,0x19,0xC0,0x8E,0x9C,0xE1,0x10);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerCompositionSink,0x5F20AA40,0xB57A,0x4F34,0x96,0xAB,0x35,0x76,0xF3,0x77,0xCC,0x79);


MIDL_DEFINE_GUID(IID, IID_ITfContextView,0x2433bf8e,0x0f9b,0x435c,0xba,0x2c,0x18,0x06,0x11,0x97,0x8c,0x30);


MIDL_DEFINE_GUID(IID, IID_IEnumTfContextViews,0xF0C0F8DD,0xCF38,0x44E1,0xBB,0x0F,0x68,0xCF,0x0D,0x55,0x1C,0x78);


MIDL_DEFINE_GUID(IID, IID_ITfContext,0xaa80e7fd,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfQueryEmbedded,0x0fab9bdb,0xd250,0x4169,0x84,0xe5,0x6b,0xe1,0x18,0xfd,0xd7,0xa8);


MIDL_DEFINE_GUID(IID, IID_ITfInsertAtSelection,0x55ce16ba,0x3014,0x41c1,0x9c,0xeb,0xfa,0xde,0x14,0x46,0xac,0x6c);


MIDL_DEFINE_GUID(IID, IID_ITfCleanupContextSink,0x01689689,0x7acb,0x4e9b,0xab,0x7c,0x7e,0xa4,0x6b,0x12,0xb5,0x22);


MIDL_DEFINE_GUID(IID, IID_ITfCleanupContextDurationSink,0x45c35144,0x154e,0x4797,0xbe,0xd8,0xd3,0x3a,0xe7,0xbf,0x87,0x94);


MIDL_DEFINE_GUID(IID, IID_ITfReadOnlyProperty,0x17d49a3d,0xf8b8,0x4b2f,0xb2,0x54,0x52,0x31,0x9d,0xd6,0x4c,0x53);


MIDL_DEFINE_GUID(IID, IID_IEnumTfPropertyValue,0x8ed8981b,0x7c10,0x4d7d,0x9f,0xb3,0xab,0x72,0xe9,0xc7,0x5f,0x72);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTracker,0x09d146cd,0xa544,0x4132,0x92,0x5b,0x7a,0xfa,0x8e,0xf3,0x22,0xd0);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTrackerACP,0x3bdd78e2,0xc16e,0x47fd,0xb8,0x83,0xce,0x6f,0xac,0xc1,0xa2,0x08);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTrackerAnchor,0xf9f4e0f2,0xd600,0x4a4c,0xb1,0x44,0x77,0xe2,0x01,0xeb,0xd1,0xb0);


MIDL_DEFINE_GUID(IID, IID_ITfMouseSink,0xa1adaaa2,0x3a24,0x449d,0xac,0x96,0x51,0x83,0xe7,0xf5,0xc2,0x17);


MIDL_DEFINE_GUID(IID, IID_ITfEditRecord,0x42d4d099,0x7c1a,0x4a89,0xb8,0x36,0x6c,0x6f,0x22,0x16,0x0d,0xf0);


MIDL_DEFINE_GUID(IID, IID_ITfTextEditSink,0x8127d409,0xccd3,0x4683,0x96,0x7a,0xb4,0x3d,0x5b,0x48,0x2b,0xf7);


MIDL_DEFINE_GUID(IID, IID_ITfTextLayoutSink,0x2af2d06a,0xdd5b,0x4927,0xa0,0xb4,0x54,0xf1,0x9c,0x91,0xfa,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfStatusSink,0x6b7d8d73,0xb267,0x4f69,0xb3,0x2e,0x1c,0xa3,0x21,0xce,0x4f,0x45);


MIDL_DEFINE_GUID(IID, IID_ITfEditTransactionSink,0x708fbf70,0xb520,0x416b,0xb0,0x6c,0x2c,0x41,0xab,0x44,0xf8,0xba);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwner,0xaa80e80c,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerServices,0xb23eb630,0x3e1c,0x11d3,0xa7,0x45,0x00,0x50,0x04,0x0a,0xb4,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfContextKeyEventSink,0x0552ba5d,0xc835,0x4934,0xbf,0x50,0x84,0x6a,0xaa,0x67,0x43,0x2f);


MIDL_DEFINE_GUID(IID, IID_ITfEditSession,0xaa80e803,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_IEnumTfTextDeltas,0xaa80e807,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRange,0xaa80e7ff,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRangeACP,0x057a6296,0x029b,0x4154,0xb7,0x9a,0x0d,0x46,0x1d,0x4e,0xa9,0x4c);


MIDL_DEFINE_GUID(IID, IID_ITfRangeAnchor,0x8b99712b,0x5815,0x4bcc,0xb9,0xa9,0x53,0xdb,0x1c,0x8d,0x67,0x55);


MIDL_DEFINE_GUID(IID, IID_ITextStoreACPServices,0xaa80e901,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITextStoreAnchorServices,0xaa80e9fe,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRangeBackup,0x463a506d,0x6992,0x49d2,0x9b,0x88,0x93,0xd5,0x5e,0x70,0xbb,0x16);


MIDL_DEFINE_GUID(IID, IID_ITfPropertyStore,0x6834b120,0x88cb,0x11d2,0xbf,0x45,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfRanges,0xf99d3f40,0x8e32,0x11d2,0xbf,0x46,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfCreatePropertyStore,0x2463fbf0,0xb0af,0x11d2,0xaf,0xc5,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfPersistentPropertyLoaderACP,0x4ef89150,0x0807,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfPersistentPropertyLoaderAnchor,0x2133f790,0x34c2,0x11d3,0xa7,0x45,0x00,0x50,0x04,0x0a,0xb4,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfProperty,0xe2449660,0x9542,0x11d2,0xbf,0x46,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfProperties,0x19188cb0,0xaca9,0x11d2,0xaf,0xc5,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfCompartment,0xbb08f7a9,0x607a,0x4384,0x86,0x23,0x05,0x68,0x92,0xb6,0x43,0x71);


MIDL_DEFINE_GUID(IID, IID_ITfCompartmentEventSink,0x743abd5f,0xf26d,0x48df,0x8c,0xc5,0x23,0x84,0x92,0x41,0x9b,0x64);


MIDL_DEFINE_GUID(IID, IID_ITfCompartmentMgr,0x7dcf57ac,0x18ad,0x438b,0x82,0x4d,0x97,0x9b,0xff,0xb7,0x4b,0x7c);


MIDL_DEFINE_GUID(IID, IID_ITfFunction,0xdb593490,0x098f,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfFunctionProvider,0x101d6610,0x0990,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfFunctionProviders,0xe4b24db0,0x0990,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfInputProcessorProfiles,0x1F02B6C5,0x7842,0x4EE6,0x8A,0x0B,0x9A,0x24,0x18,0x3A,0x95,0xCA);


MIDL_DEFINE_GUID(IID, IID_ITfActiveLanguageProfileNotifySink,0xb246cb75,0xa93e,0x4652,0xbf,0x8c,0xb3,0xfe,0x0c,0xfd,0x7e,0x57);


MIDL_DEFINE_GUID(IID, IID_IEnumTfLanguageProfiles,0x3d61bf11,0xac5f,0x42c8,0xa4,0xcb,0x93,0x1b,0xcc,0x28,0xc7,0x44);


MIDL_DEFINE_GUID(IID, IID_ITfLanguageProfileNotifySink,0x43c9fe15,0xf494,0x4c17,0x9d,0xe2,0xb8,0xa4,0xac,0x35,0x0a,0xa8);


MIDL_DEFINE_GUID(IID, IID_ITfKeystrokeMgr,0xaa80e7f0,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfKeyEventSink,0xaa80e7f5,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfKeyTraceEventSink,0x1cd4c13b,0x1c36,0x4191,0xa7,0x0a,0x7f,0x3e,0x61,0x1f,0x36,0x7d);


MIDL_DEFINE_GUID(IID, IID_ITfPreservedKeyNotifySink,0x6f77c993,0xd2b1,0x446e,0x85,0x3e,0x59,0x12,0xef,0xc8,0xa2,0x86);


MIDL_DEFINE_GUID(IID, IID_ITfMessagePump,0x8f1b8ad8,0x0b6b,0x4874,0x90,0xc5,0xbd,0x76,0x01,0x1e,0x8f,0x7c);


MIDL_DEFINE_GUID(IID, IID_ITfThreadFocusSink,0xc0f1db0c,0x3a20,0x405c,0xa3,0x03,0x96,0xb6,0x01,0x0a,0x88,0x5f);


MIDL_DEFINE_GUID(IID, IID_ITfTextInputProcessor,0xaa80e7f7,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfClientId,0xd60a7b49,0x1b9f,0x4be2,0xb7,0x02,0x47,0xe9,0xdc,0x05,0xde,0xc3);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeInfo,0x70528852,0x2f26,0x4aea,0x8c,0x96,0x21,0x51,0x50,0x57,0x89,0x32);


MIDL_DEFINE_GUID(IID, IID_IEnumTfDisplayAttributeInfo,0x7cef04d7,0xcb75,0x4e80,0xa7,0xab,0x5f,0x5b,0xc7,0xd3,0x32,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeProvider,0xfee47777,0x163c,0x4769,0x99,0x6a,0x6e,0x9c,0x50,0xad,0x8f,0x54);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeMgr,0x8ded7393,0x5db1,0x475c,0x9e,0x71,0xa3,0x91,0x11,0xb0,0xff,0x67);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeNotifySink,0xad56f402,0xe162,0x4f25,0x90,0x8f,0x7d,0x57,0x7c,0xf9,0xbd,0xa9);


MIDL_DEFINE_GUID(IID, IID_ITfCategoryMgr,0xc3acefb5,0xf69d,0x4905,0x93,0x8f,0xfc,0xad,0xcf,0x4b,0xe8,0x30);


MIDL_DEFINE_GUID(IID, IID_ITfSource,0x4ea48a35,0x60ae,0x446f,0x8f,0xd6,0xe6,0xa8,0xd8,0x24,0x59,0xf7);


MIDL_DEFINE_GUID(IID, IID_ITfSourceSingle,0x73131f9c,0x56a9,0x49dd,0xb0,0xee,0xd0,0x46,0x63,0x3f,0x75,0x28);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for msctf.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITfThreadMgr,0xaa80e801,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfThreadMgrEventSink,0xaa80e80e,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfConfigureSystemKeystrokeFeed,0x0d2c969a,0xbc9c,0x437c,0x84,0xee,0x95,0x1c,0x49,0xb1,0xa7,0x64);


MIDL_DEFINE_GUID(IID, IID_IEnumTfDocumentMgrs,0xaa80e808,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfDocumentMgr,0xaa80e7f4,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_IEnumTfContexts,0x8f1a7ea6,0x1654,0x4502,0xa8,0x6e,0xb2,0x90,0x23,0x44,0xd5,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfCompositionView,0xD7540241,0xF9A1,0x4364,0xBE,0xFC,0xDB,0xCD,0x2C,0x43,0x95,0xB7);


MIDL_DEFINE_GUID(IID, IID_IEnumITfCompositionView,0x5EFD22BA,0x7838,0x46CB,0x88,0xE2,0xCA,0xDB,0x14,0x12,0x4F,0x8F);


MIDL_DEFINE_GUID(IID, IID_ITfComposition,0x20168D64,0x5A8F,0x4A5A,0xB7,0xBD,0xCF,0xA2,0x9F,0x4D,0x0F,0xD9);


MIDL_DEFINE_GUID(IID, IID_ITfCompositionSink,0xA781718C,0x579A,0x4B15,0xA2,0x80,0x32,0xB8,0x57,0x7A,0xCC,0x5E);


MIDL_DEFINE_GUID(IID, IID_ITfContextComposition,0xD40C8AAE,0xAC92,0x4FC7,0x9A,0x11,0x0E,0xE0,0xE2,0x3A,0xA3,0x9B);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerCompositionServices,0x86462810,0x593B,0x4916,0x97,0x64,0x19,0xC0,0x8E,0x9C,0xE1,0x10);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerCompositionSink,0x5F20AA40,0xB57A,0x4F34,0x96,0xAB,0x35,0x76,0xF3,0x77,0xCC,0x79);


MIDL_DEFINE_GUID(IID, IID_ITfContextView,0x2433bf8e,0x0f9b,0x435c,0xba,0x2c,0x18,0x06,0x11,0x97,0x8c,0x30);


MIDL_DEFINE_GUID(IID, IID_IEnumTfContextViews,0xF0C0F8DD,0xCF38,0x44E1,0xBB,0x0F,0x68,0xCF,0x0D,0x55,0x1C,0x78);


MIDL_DEFINE_GUID(IID, IID_ITfContext,0xaa80e7fd,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfQueryEmbedded,0x0fab9bdb,0xd250,0x4169,0x84,0xe5,0x6b,0xe1,0x18,0xfd,0xd7,0xa8);


MIDL_DEFINE_GUID(IID, IID_ITfInsertAtSelection,0x55ce16ba,0x3014,0x41c1,0x9c,0xeb,0xfa,0xde,0x14,0x46,0xac,0x6c);


MIDL_DEFINE_GUID(IID, IID_ITfCleanupContextSink,0x01689689,0x7acb,0x4e9b,0xab,0x7c,0x7e,0xa4,0x6b,0x12,0xb5,0x22);


MIDL_DEFINE_GUID(IID, IID_ITfCleanupContextDurationSink,0x45c35144,0x154e,0x4797,0xbe,0xd8,0xd3,0x3a,0xe7,0xbf,0x87,0x94);


MIDL_DEFINE_GUID(IID, IID_ITfReadOnlyProperty,0x17d49a3d,0xf8b8,0x4b2f,0xb2,0x54,0x52,0x31,0x9d,0xd6,0x4c,0x53);


MIDL_DEFINE_GUID(IID, IID_IEnumTfPropertyValue,0x8ed8981b,0x7c10,0x4d7d,0x9f,0xb3,0xab,0x72,0xe9,0xc7,0x5f,0x72);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTracker,0x09d146cd,0xa544,0x4132,0x92,0x5b,0x7a,0xfa,0x8e,0xf3,0x22,0xd0);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTrackerACP,0x3bdd78e2,0xc16e,0x47fd,0xb8,0x83,0xce,0x6f,0xac,0xc1,0xa2,0x08);


MIDL_DEFINE_GUID(IID, IID_ITfMouseTrackerAnchor,0xf9f4e0f2,0xd600,0x4a4c,0xb1,0x44,0x77,0xe2,0x01,0xeb,0xd1,0xb0);


MIDL_DEFINE_GUID(IID, IID_ITfMouseSink,0xa1adaaa2,0x3a24,0x449d,0xac,0x96,0x51,0x83,0xe7,0xf5,0xc2,0x17);


MIDL_DEFINE_GUID(IID, IID_ITfEditRecord,0x42d4d099,0x7c1a,0x4a89,0xb8,0x36,0x6c,0x6f,0x22,0x16,0x0d,0xf0);


MIDL_DEFINE_GUID(IID, IID_ITfTextEditSink,0x8127d409,0xccd3,0x4683,0x96,0x7a,0xb4,0x3d,0x5b,0x48,0x2b,0xf7);


MIDL_DEFINE_GUID(IID, IID_ITfTextLayoutSink,0x2af2d06a,0xdd5b,0x4927,0xa0,0xb4,0x54,0xf1,0x9c,0x91,0xfa,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfStatusSink,0x6b7d8d73,0xb267,0x4f69,0xb3,0x2e,0x1c,0xa3,0x21,0xce,0x4f,0x45);


MIDL_DEFINE_GUID(IID, IID_ITfEditTransactionSink,0x708fbf70,0xb520,0x416b,0xb0,0x6c,0x2c,0x41,0xab,0x44,0xf8,0xba);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwner,0xaa80e80c,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfContextOwnerServices,0xb23eb630,0x3e1c,0x11d3,0xa7,0x45,0x00,0x50,0x04,0x0a,0xb4,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfContextKeyEventSink,0x0552ba5d,0xc835,0x4934,0xbf,0x50,0x84,0x6a,0xaa,0x67,0x43,0x2f);


MIDL_DEFINE_GUID(IID, IID_ITfEditSession,0xaa80e803,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_IEnumTfTextDeltas,0xaa80e807,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRange,0xaa80e7ff,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRangeACP,0x057a6296,0x029b,0x4154,0xb7,0x9a,0x0d,0x46,0x1d,0x4e,0xa9,0x4c);


MIDL_DEFINE_GUID(IID, IID_ITfRangeAnchor,0x8b99712b,0x5815,0x4bcc,0xb9,0xa9,0x53,0xdb,0x1c,0x8d,0x67,0x55);


MIDL_DEFINE_GUID(IID, IID_ITextStoreACPServices,0xaa80e901,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITextStoreAnchorServices,0xaa80e9fe,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfRangeBackup,0x463a506d,0x6992,0x49d2,0x9b,0x88,0x93,0xd5,0x5e,0x70,0xbb,0x16);


MIDL_DEFINE_GUID(IID, IID_ITfPropertyStore,0x6834b120,0x88cb,0x11d2,0xbf,0x45,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfRanges,0xf99d3f40,0x8e32,0x11d2,0xbf,0x46,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfCreatePropertyStore,0x2463fbf0,0xb0af,0x11d2,0xaf,0xc5,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfPersistentPropertyLoaderACP,0x4ef89150,0x0807,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfPersistentPropertyLoaderAnchor,0x2133f790,0x34c2,0x11d3,0xa7,0x45,0x00,0x50,0x04,0x0a,0xb4,0x07);


MIDL_DEFINE_GUID(IID, IID_ITfProperty,0xe2449660,0x9542,0x11d2,0xbf,0x46,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfProperties,0x19188cb0,0xaca9,0x11d2,0xaf,0xc5,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfCompartment,0xbb08f7a9,0x607a,0x4384,0x86,0x23,0x05,0x68,0x92,0xb6,0x43,0x71);


MIDL_DEFINE_GUID(IID, IID_ITfCompartmentEventSink,0x743abd5f,0xf26d,0x48df,0x8c,0xc5,0x23,0x84,0x92,0x41,0x9b,0x64);


MIDL_DEFINE_GUID(IID, IID_ITfCompartmentMgr,0x7dcf57ac,0x18ad,0x438b,0x82,0x4d,0x97,0x9b,0xff,0xb7,0x4b,0x7c);


MIDL_DEFINE_GUID(IID, IID_ITfFunction,0xdb593490,0x098f,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfFunctionProvider,0x101d6610,0x0990,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_IEnumTfFunctionProviders,0xe4b24db0,0x0990,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfInputProcessorProfiles,0x1F02B6C5,0x7842,0x4EE6,0x8A,0x0B,0x9A,0x24,0x18,0x3A,0x95,0xCA);


MIDL_DEFINE_GUID(IID, IID_ITfActiveLanguageProfileNotifySink,0xb246cb75,0xa93e,0x4652,0xbf,0x8c,0xb3,0xfe,0x0c,0xfd,0x7e,0x57);


MIDL_DEFINE_GUID(IID, IID_IEnumTfLanguageProfiles,0x3d61bf11,0xac5f,0x42c8,0xa4,0xcb,0x93,0x1b,0xcc,0x28,0xc7,0x44);


MIDL_DEFINE_GUID(IID, IID_ITfLanguageProfileNotifySink,0x43c9fe15,0xf494,0x4c17,0x9d,0xe2,0xb8,0xa4,0xac,0x35,0x0a,0xa8);


MIDL_DEFINE_GUID(IID, IID_ITfKeystrokeMgr,0xaa80e7f0,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfKeyEventSink,0xaa80e7f5,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfKeyTraceEventSink,0x1cd4c13b,0x1c36,0x4191,0xa7,0x0a,0x7f,0x3e,0x61,0x1f,0x36,0x7d);


MIDL_DEFINE_GUID(IID, IID_ITfPreservedKeyNotifySink,0x6f77c993,0xd2b1,0x446e,0x85,0x3e,0x59,0x12,0xef,0xc8,0xa2,0x86);


MIDL_DEFINE_GUID(IID, IID_ITfMessagePump,0x8f1b8ad8,0x0b6b,0x4874,0x90,0xc5,0xbd,0x76,0x01,0x1e,0x8f,0x7c);


MIDL_DEFINE_GUID(IID, IID_ITfThreadFocusSink,0xc0f1db0c,0x3a20,0x405c,0xa3,0x03,0x96,0xb6,0x01,0x0a,0x88,0x5f);


MIDL_DEFINE_GUID(IID, IID_ITfTextInputProcessor,0xaa80e7f7,0x2021,0x11d2,0x93,0xe0,0x00,0x60,0xb0,0x67,0xb8,0x6e);


MIDL_DEFINE_GUID(IID, IID_ITfClientId,0xd60a7b49,0x1b9f,0x4be2,0xb7,0x02,0x47,0xe9,0xdc,0x05,0xde,0xc3);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeInfo,0x70528852,0x2f26,0x4aea,0x8c,0x96,0x21,0x51,0x50,0x57,0x89,0x32);


MIDL_DEFINE_GUID(IID, IID_IEnumTfDisplayAttributeInfo,0x7cef04d7,0xcb75,0x4e80,0xa7,0xab,0x5f,0x5b,0xc7,0xd3,0x32,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeProvider,0xfee47777,0x163c,0x4769,0x99,0x6a,0x6e,0x9c,0x50,0xad,0x8f,0x54);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeMgr,0x8ded7393,0x5db1,0x475c,0x9e,0x71,0xa3,0x91,0x11,0xb0,0xff,0x67);


MIDL_DEFINE_GUID(IID, IID_ITfDisplayAttributeNotifySink,0xad56f402,0xe162,0x4f25,0x90,0x8f,0x7d,0x57,0x7c,0xf9,0xbd,0xa9);


MIDL_DEFINE_GUID(IID, IID_ITfCategoryMgr,0xc3acefb5,0xf69d,0x4905,0x93,0x8f,0xfc,0xad,0xcf,0x4b,0xe8,0x30);


MIDL_DEFINE_GUID(IID, IID_ITfSource,0x4ea48a35,0x60ae,0x446f,0x8f,0xd6,0xe6,0xa8,0xd8,0x24,0x59,0xf7);


MIDL_DEFINE_GUID(IID, IID_ITfSourceSingle,0x73131f9c,0x56a9,0x49dd,0xb0,0xee,0xd0,0x46,0x63,0x3f,0x75,0x28);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\object.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	object.cpp	IRichEditOle implementation |
 *
 *	Author: alexgo 8/15/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_rtext.h"
#include "_select.h"
#include "_m_undo.h"
#include "_disp.h"


// 	IUnknown is implemented elsewhere

/*
 *	CTxtEdit::GetClientSite (lplpolesite)
 *
 *	@mfunc	returns the client site 
 */
STDMETHODIMP CTxtEdit::GetClientSite(
	LPOLECLIENTSITE FAR * lplpolesite)		//@parm where to return 
											//the client site
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetClientSite");

	if(!lplpolesite)
		return E_INVALIDARG;

	COleObject *pobj = new COleObject(this);
	// should start with a ref count of 1.
	if(pobj)
	{
		*lplpolesite = (IOleClientSite *)pobj;
		return NOERROR;
	}
	*lplpolesite = NULL;
	return E_OUTOFMEMORY;
}

/* 
 *	CTxtEdit::GetObjectCount
 *
 *	@mfunc	return the number of objects in this edit instance
 */
STDMETHODIMP_(LONG) CTxtEdit::GetObjectCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetObjectCount");
	
	return _pobjmgr ? _pobjmgr->GetObjectCount() : 0;
}

/*
 *	CTxtEdit::GetLinkCount
 *
 *	@mfunc	return the number of likns in this edit instance
 */
STDMETHODIMP_(LONG) CTxtEdit::GetLinkCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetLinkCount");

	CObjectMgr *pobjmgr = GetObjectMgr();
	return pobjmgr ? pobjmgr->GetLinkCount() : 0;
}

/*
 *	CTxtEdit::GetObject(iob, preobj, dwFlags)
 *
 *	@mfunc	returns an object structure for the indicated object
 */
STDMETHODIMP CTxtEdit::GetObject(
	LONG iob, 					//@parm index of the object
	REOBJECT * preobj,			//@parm where to put object info
	DWORD dwFlags)				//@parm flags
{
	COleObject *pobj = NULL;
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetObject");
	if(!preobj || preobj->cbStruct != sizeof(REOBJECT))
		return E_INVALIDARG;

	CObjectMgr *pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	// There are three cases of intestest; get the object at
	// an index, at a given cp, or at the selection.

	if(iob == REO_IOB_USE_CP || iob == REO_IOB_SELECTION)
	{
		if((Get10Mode() && preobj->cp == REO_CP_SELECTION) || iob == REO_IOB_SELECTION)
		{
			// Use selection cp
			CTxtSelection *psel = GetSel();
			if(psel)
				pobj = pobjmgr->GetObjectFromCp(psel->GetCpMin());
		}
		else
			pobj = pobjmgr->GetObjectFromCp(Get10Mode() ? GetCpFromAcp(preobj->cp): preobj->cp);
	}
	else if (iob >= 0)
		pobj = pobjmgr->GetObjectFromIndex(iob);

	if(pobj)
	{
		HRESULT hResult = pobj->GetObjectData(preobj, dwFlags);

		if (Get10Mode())
			preobj->cp = GetAcpFromCp(preobj->cp);

		return hResult;
	}

	// This return code is a bit of stretch, but basially 
	return E_INVALIDARG;
}

/*
 *	CTxtEdit::InsertObject (preobj)
 *
 *	@mfunc	inserts a new object
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtEdit::InsertObject(
	REOBJECT * preobj)		//@parm object info
{
	CCallMgr		callmgr(this);
	CTxtRange		rg(this, 0);
	IUndoBuilder *	publdr;
	CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::InsertObject");

	// Do some boundary case checking

	if(!preobj)
		return E_INVALIDARG;

	CTxtSelection *psel = GetSel();
	if(!psel)
		return E_OUTOFMEMORY;

	// The following code gives Outlook major fits if you click on a name in
	// the To:, Cc:, or Bcc: fields, so I've commented it out. In principle,
	// Outlook's EN_PROTECTION handler should say it's OK to insert in this case.
	//
	//	if(!IsntProtectedOrReadOnly(0, 0, 0))
	//		return E_ACCESSDENIED;

	// If the insertion of this character would cause
	// us to exceed the text limit, fail
	if((DWORD)(GetAdjustedTextLength() + 1) > TxGetMaxLength())
	{
		// If we're not replacing a selection (or the
		// selection is degenerate, then we will have  exceeded
		// our limit
		if(preobj->cp != REO_CP_SELECTION || psel->GetCch() == 0)
		{
			GetCallMgr()->SetMaxText();
			return E_OUTOFMEMORY;
		}
	}
	
	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr)
	{
		LONG cch = 0;
		LONG cp;

		undobldr.StopGroupTyping();

		if(preobj->cp == REO_CP_SELECTION)
		{
			LONG cpFormat;
			LONG cpMost;
			psel->AdjustEndEOP(NEWCHARS);
			cch = psel->GetRange(cp, cpMost);

			// Get cp of active end of selection from which we
			// will obtain CF for object.
			cpFormat = psel->GetCp();
			if(publdr)
				HandleSelectionAEInfo(this, publdr, cpFormat, cch, 
						cp + 1, 0, SELAE_FORCEREPLACE);

			// Get format for ReplaceRange: for cp semantics, use format
			// at the cp; for selection semantics, use the format at the
			// active end of the selection.
			rg.SetCp(cpFormat, FALSE);
			LONG iFormat = rg.Get_iCF();
			rg.Set(cp, -cch);
			rg.Set_iCF(iFormat);		// Use _iFormat at sel active end
			rg.SetUseiFormat(TRUE);
			ReleaseFormats(iFormat, -1);
		}
		else
		{
			cp = Get10Mode() ? GetCpFromAcp(preobj->cp): preobj->cp;
			rg.SetCp(cp, FALSE);			// Updates rg._iFormat
		}

		if(preobj->dwFlags & REO_USEASBACKGROUND)
		{
			CDocInfo *pDocInfo = GetDocInfo();
			if(pDocInfo)
				pDocInfo->InitBackground();
		}
		HRESULT		hr = pobjmgr->InsertObject(&rg, preobj, publdr);
		CNotifyMgr *pnm = GetNotifyMgr();	// Get notification mgr
		if(pnm)								// Notify interested parties
			pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, cp, cp + 1);

		// Don't want object selected
		psel->SetSelection(cp + 1, cp + 1);
		if(preobj->dwFlags & REO_USEASBACKGROUND)
			_pdp->UpdateView();

		TxUpdateWindow();
		return hr;
	}
	return E_OUTOFMEMORY;		
}

/*
 *	CTxtEdit::ConvertObject(iob, rclsidNew, lpstrUserTypeNew)
 *
 *	@mfunc	Converts the specified object to the specified class.  Does reload
 *		the object but does NOT force an update (caller must do this).
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ConvertObject(
	LONG iob, 					//@parm index of the object
	REFCLSID rclsidNew,			//@parm the destination clsid
	LPCSTR lpstrUserTypeNew)	//@parm the new user type name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ConvertObject");
	CCallMgr callmgr(this);

	// If iob was invalid return
	COleObject * pobj = ObjectFromIOB(iob);
	if(!pobj)
		return E_INVALIDARG;

	//Delegate to the object.
	return pobj->Convert(rclsidNew, lpstrUserTypeNew);
}

/*
 *	CTxtEdit::ActivateAs(rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a
 *		particular class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ActivateAs(
	REFCLSID rclsid, 			//@parm clsid which we're going to change
	REFCLSID rclsidAs)			//@parm clsid to activate as
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ActivateAs");
	CCallMgr callmgr(this);

	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	return pobjmgr->ActivateObjectsAs(rclsid, rclsidAs);
}

/* 
 *	CTxtEdit::SetHostNames(lpstrContainerApp, lpstrContainerDoc)
 *
 *	@mfunc	Sets the host names for this instance
 */
STDMETHODIMP CTxtEdit::SetHostNames(
	LPCSTR lpstrContainerApp, 	//@parm App name
	LPCSTR lpstrContainerDoc)	//@parm	Container Object (doc) name
{
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetHostNames");
	
 	WCHAR *pwsContainerApp = W32->ConvertToWideChar(lpstrContainerApp);
	WCHAR *pwsContainerDoc = W32->ConvertToWideChar(lpstrContainerDoc);

	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr && pwsContainerApp && pwsContainerDoc)
	{
		HRESULT hr = pobjmgr->SetHostNames(pwsContainerApp, pwsContainerDoc);
		delete pwsContainerApp;
		delete pwsContainerDoc;
		return hr;
	}
	return E_OUTOFMEMORY;
}

/*
 *	CTxtEdit::SetLinkAvailable(iob, fAvailable)
 *
 *	@mfunc
 *		Allows client to tell us whether the link is available or not.
 */
STDMETHODIMP CTxtEdit::SetLinkAvailable(
	LONG iob, 					//@parm index of the object
	BOOL fAvailable)			//@parm if TRUE, make object linkable
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetLinkAvailable");

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	return pobj->SetLinkAvailable(fAvailable);
}

/*
 *	CTxtEdit::SetDvaspect(iob, dvaspect)
 *
 *	@mfunc	Allows client to tell us which aspect to use and force us
 *		to recompute positioning and redraw.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::SetDvaspect(
	LONG iob, 					//@parm index of the object
	DWORD dvaspect)				//@parm	the aspect to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SetDvaspect");
	CCallMgr callmgr(this);
	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->SetDvaspect(dvaspect);
	return NOERROR;
}

/*
 *	CTxtEdit::HandsOffStorage(iob)
 *
 *	@mfunc	see IPersistStorage::HandsOffStorage
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::HandsOffStorage(
	LONG iob)					//@parm index of the object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::HandsOffStorage");
	CCallMgr callmgr(this);

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->HandsOffStorage();
	return NOERROR;
}

/*
 *	CTxtEdit::SaveCompleted(iob, lpstg)
 *
 *	@mfunc	see IPersistStorage::SaveCompleted
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::SaveCompleted(
	LONG iob, 					//@parm index of the object
	LPSTORAGE lpstg)			//@parm new storage
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::SaveCompleted");
	CCallMgr callmgr(this);

	COleObject * pobj = ObjectFromIOB(iob);

	// If iob was invalid, return
	if (!pobj)
		return E_INVALIDARG;

	// Delegate this to the object.
	pobj->SaveCompleted(lpstg);
	return NOERROR;
}

/*
 *	CTxtEdit::InPlaceDeactivate()
 *
 *	@mfunc	Deactivate 
 */
STDMETHODIMP CTxtEdit::InPlaceDeactivate()
{
	COleObject *pobj;
	HRESULT hr = NOERROR;
	CCallMgr callmgr(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::InPlaceDeactivate");
	
	CObjectMgr *pobjmgr = GetObjectMgr();
	if(pobjmgr)
	{
		pobj = pobjmgr->GetInPlaceActiveObject();
		if(pobj)
			hr = pobj->DeActivateObj();
	}

	return hr;
}

/*
 *	CTxtEdit::ContextSensitiveHelp(fEnterMode)
 *
 *	@mfunc enter/leave ContextSensitiveHelp mode
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ContextSensitiveHelp(
	BOOL fEnterMode)			//@parm enter/exit mode
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ContextSensitiveHelp");

	HRESULT hr = NOERROR;
	CCallMgr callmgr(this);

	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	// If the mode changes
	if(pobjmgr->GetHelpMode() != fEnterMode)
	{
		pobjmgr->SetHelpMode(fEnterMode);
		COleObject * pobj = pobjmgr->GetInPlaceActiveObject();
		if(pobj)
		{
			IOleWindow *pow;
			hr = pobj->GetIUnknown()->QueryInterface(IID_IOleWindow,
				(void **)&pow);
			if(hr == NOERROR)
			{
				hr = pow->ContextSensitiveHelp(fEnterMode);
				pow->Release();
			}
		}
	}
	return hr;
}

/*
 *	CTxtEdit::GetClipboardData(lpchrg, reco, lplpdataobj)
 *
 *	@mfunc	return an data transfer object for the indicated
 *	range
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::GetClipboardData(
	CHARRANGE *lpchrg, 			//@parm the range of text to use
	DWORD reco,					//@parm operation the data is for
	LPDATAOBJECT *lplpdataobj)	//@parm where to put the data object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::GetClipboardData");

	CCallMgr callmgr(this);
	HRESULT hr;
	LONG cpMin, cpMost;
	CLightDTEngine * pldte = GetDTE();

	//Make sure cpMin and cpMost are within the current text limits.
	//Interpret neg. value for cpMin as the beginning of the text,
	//and neg. value for cpMax as the end of the text.  If a char range
	//is not given use the current selection.
	if(lpchrg)
	{
		LONG cchText = GetTextLength();
		cpMin = max(0, lpchrg->cpMin);
		cpMin = min(cchText, lpchrg->cpMin);
		cpMost = lpchrg->cpMost;
		if(lpchrg->cpMost < 0 || lpchrg->cpMost > cchText)
			cpMost = cchText;
	}
	else
	{
		CTxtSelection * psel = GetSel();
		psel->GetRange(cpMin, cpMost);
	}

	//Make sure this is a valid range.
	if(cpMin >= cpMost)
	{
		*lplpdataobj = NULL;
		return cpMin == cpMost
					? NOERROR
					: ResultFromScode(E_INVALIDARG);
	}

	CTxtRange rg(this, cpMin, cpMin-cpMost);

	//We don't use reco for anything.
	hr = pldte->RangeToDataObject(&rg, SF_RTF, lplpdataobj);

#if !defined(NOFULLDEBUG) && defined(DEBUG)
	if(hr != NOERROR)
		TRACEERRSZSC("GetClipboardData", E_OUTOFMEMORY);
#endif

	return hr;
}

/*
 *	CTxtEdit::ImportDataObject(lpdataobj, cf, hMetaPict)
 *
 *	@mfunc	morally equivalent to paste, but with a data object
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
STDMETHODIMP CTxtEdit::ImportDataObject(
	LPDATAOBJECT lpdataobj,		//@parm Data object to use
	CLIPFORMAT	 cf, 			//@parm Clibpoard format to use
	HGLOBAL		 hMetaPict)		//@parm Metafile to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CTxtEdit::ImportDataObject");

	CCallMgr		callmgr(this);
	IUndoBuilder *	publdr;
	REPASTESPECIAL	rps = {DVASPECT_CONTENT, NULL};
	CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

	if(hMetaPict)
	{
		rps.dwAspect = DVASPECT_ICON;
		rps.dwParam = (DWORD_PTR) hMetaPict;
	}

	return PasteDataObjectToRange(lpdataobj, GetSel(), cf,
								  &rps, publdr, PDOR_NOQUERY);
}

/*
 *	CTxtEdit::ObjectFromIOB(iob)
 *
 *	@mfunc	Gets an object based on an IOB type index.
 *
 *	@rdesc:
 *		pointer to COleObject or NULL if none.
 */
COleObject * CTxtEdit::ObjectFromIOB(
	LONG iob)
{
	CObjectMgr * pobjmgr = GetObjectMgr();
	if(!pobjmgr)
		return NULL;

	COleObject * pobj = NULL;

	// Figure out the index of the selection
	if (iob == REO_IOB_SELECTION)
	{
		CTxtSelection * psel = GetSel();

		pobj = pobjmgr->GetFirstObjectInRange(psel->GetCpMin(),
			psel->GetCpMost());
	}
	else
	{
		// Make sure the IOB is in range
		if(0 <= iob && iob < GetObjectCount())
			pobj = pobjmgr->GetObjectFromIndex(iob);
	}
	return pobj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\notmgr.cpp ===
/*
 *	NOTMGR.C
 *
 *	Purpose:
 *		Notification Manager implemenation
 *
 *	Author:
 *		AlexGo	6/5/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_notmgr.h"

ASSERTDATA

/*
 *	CNotifyMgr::CNotifyMgr ()
 */
CNotifyMgr::CNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::CNotifyMgr");

	_pitnlist = NULL;
}

/*
 *	CNotifyMgr::~CNotifyMgr ()
 *
 */
CNotifyMgr::~CNotifyMgr()
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::~CNotifyMgr");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		plist->Zombie();
	}

	TRACEERRSZSC("CNotifyMgr::~CNotifyMgr(): zombie(s) exist", _pitnlist != 0);
}

/*
 *	CNotifyMgr::Add (pITN)
 *
 *	@mfunc
 *		Adds a notification sink to the list
 *
 *	Algorithm:
 *		puts the entry at the *front* of the notification list, so
 *		that high frequency entries (like ranges and text pointers
 *		existing on the stack) can be added and removed efficiently
 */
void CNotifyMgr::Add(
	ITxNotify *pITN )
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::Add");

		pITN->_pnext = _pitnlist;
		_pitnlist = pITN;
}

/*
 *	CNotifyMgr::Remove (pITN)
 *
 *	@mfunc
 *		removes a notification sink from the list
 */
void CNotifyMgr::Remove(
	ITxNotify *pITN )
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::Remove");

	ITxNotify *plist = _pitnlist;
	ITxNotify **ppprev = &_pitnlist;

	while(plist)
	{
		if( plist == pITN )
		{
			*ppprev = plist->_pnext;
			break;
		}
		ppprev = &(plist->_pnext);
		plist = plist->_pnext;
	}
}

/*
 *	CNotifyMgr::NotifyPreReplaceRange (pITNignore, cp, cchDel, cchNew, cpFormatMin, cpFormatMax, dwFlags)
 *
 *	@mfunc
 *		send an OnReplaceRange notification to all sinks (except pITNignore)
 */
void CNotifyMgr::NotifyPreReplaceRange(
	ITxNotify *	pITNignore,		//@parm Notification sink to ignore
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::NotifyPreReplaceRange");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		if( plist != pITNignore )
		{
			plist->OnPreReplaceRange( cp, cchDel, cchNew, cpFormatMin, 
				cpFormatMax, pNotifyData );
		}
	}
}

/*
 *	CNotifyMgr::NotifyPostReplaceRange (pITNignore, cp, cchDel, cchNew, cpFormatMin, cpFormatMax, dwFlags)
 *
 *	@mfunc
 *		send an OnReplaceRange notification to all sinks (except pITNignore)
 *
 *	@comm
 *		pITNignore typically is the TxtPtr/etc that is actually making the
 *		ReplaceRange modification
 */
void CNotifyMgr::NotifyPostReplaceRange(
	ITxNotify *	pITNignore,		//@parm Notification sink to ignore
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSNOTM, TRCSCOPEINTERN, "CNotifyMgr::NotifyPostReplaceRange");

	ITxNotify *plist;

	for( plist = _pitnlist; plist != NULL; plist = plist->_pnext )
	{
		if( plist != pITNignore )
		{
			plist->OnPostReplaceRange( cp, cchDel, cchNew, cpFormatMin,
				cpFormatMax, pNotifyData );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\m_undo.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	M_UNDO.C	|
 *
 *	Purpose:
 *		Implementation of the global mutli-undo stack
 *
 * 	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_m_undo.h"
#include "_edit.h"
#include "_disp.h"
#include "_urlsup.h"
#include "_antievt.h"

ASSERTDATA

//
// PUBLIC METHODS
//

/*
 *	CUndoStack::CUndoStack (ped, cUndoLim, flags)
 *
 *	@mfunc	Constructor
 */
CUndoStack::CUndoStack(
	CTxtEdit *ped,		//@parm	CTxtEdit parent
	LONG &	  cUndoLim,	//@parm Initial limit
	USFlags	  flags)	//@parm Flags for this undo stack
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::CUndoStack");

	_ped = ped;
	_prgActions = NULL;
	_index = 0;
	_cUndoLim = 0;

	// We should be creating an undo stack if there's nothing to put in it!
	Assert(cUndoLim);
	SetUndoLimit(cUndoLim);

	if(flags & US_REDO)
		_fRedo = TRUE;
}

/*
 *	CUndoStack::~CUndoStack()
 *
 *	@mfunc Destructor
 *
 *	@comm
 *		Deletes any remaining antievents.  The antievent dispenser
 *		should *not* clean up because of this!!
 */
CUndoStack::~CUndoStack()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::~CUndoStack");

	// Clear out any remaining antievents
	ClearAll();

	delete _prgActions;
}

/*
 *	CUndoStack::Destroy ()
 *
 *	@mfunc
 *		Deletes this instance
 */
void CUndoStack::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Destroy");

	delete this;
}

/*
 * 	CUndoStack::SetUndoLimit (cUndoLim)
 *
 *	@mfunc
 *		Allows the undo stack to be enlarged or reduced
 *
 *	@rdesc
 *		Size to which the stack is actually set.
 *
 *	@comm
 *		The algorithm we use is the following:	 <nl>
 *
 *		Try to allocate space for the requested size.
 *		If there's insufficient memory, try to recover
 *		with the largest block possible.
 *
 *		If the requested size is bigger than the default,
 *		and the current size is less than the default, go 
 *		ahead and try to allocate the default.
 *
 *		If that fails then just stick with the existing stack
 */
LONG CUndoStack::SetUndoLimit(
	LONG cUndoLim)			//@parm	New undo limit.  May not be zero
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::SetUndoLimit");

	// If the undo limit is zero, we should get rid of the entire
	// undo stack instead.
	Assert(cUndoLim);

	if(_fSingleLevelMode)
	{
		// If fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		if(cUndoLim != 1)
		{
			TRACEERRORSZ("Trying to grow/shrink the undo buffer while in"
				"single level mode");
			
			cUndoLim = 1;
		}
	}

	UndoAction *prgnew = new UndoAction[cUndoLim];
	if(prgnew)
		TransferToNewBuffer(prgnew, cUndoLim);

	else if(cUndoLim > DEFAULT_UNDO_SIZE && _cUndoLim < DEFAULT_UNDO_SIZE)
	{
		// We are trying to grow past the default but failed.  So
		// try to allocate the default
		prgnew = new UndoAction[DEFAULT_UNDO_SIZE];

		if(prgnew)
			TransferToNewBuffer(prgnew, DEFAULT_UNDO_SIZE);
	}
	
	// In either success or failure, _cUndoLim will be set correctly.	
	return _cUndoLim;
}

/*
 *	CUndoStack::GetUndoLimit() 
 *
 *	@mfunc
 *		Get current limit size
 *
 *	@rdesc	
 *		Current undo limit
 */
LONG CUndoStack::GetUndoLimit()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetUndoLimit");

	return _cUndoLim;
}

/*
 *	CUndoStack::PushAntiEvent (idName, pae)
 *
 *	@mfunc
 *		Adds an undoable event to the event stack
 *
 *	@rdesc	HRESULT
 *
 *	@comm
 *		Algorithm: if merging is set, then we merge the given antievent
 *		list *into* the current list (assuming it's a typing undo action).
 */
HRESULT CUndoStack::PushAntiEvent(
	UNDONAMEID idName,		//@parm	Name for this AE collection
	IAntiEvent *pae)		//@parm AE collection
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::PushAntiEvent");

	// _index should be at next available position
	if(!_fMerge)
	{
		// clear out any existing event	
		if(_prgActions[_index].pae != NULL)
		{
			DestroyAEList(_prgActions[_index].pae);
			_prgActions[_index].pae = NULL;
		}

		if(_fRedo)
			_ped->GetCallMgr()->SetNewRedo();
		else
			_ped->GetCallMgr()->SetNewUndo();
	}

	if(_fMerge)
	{
		IAntiEvent *paetemp = pae, *paeNext;
		DWORD i = GetPrev();

		// If these asserts fail, then somebody did not call 
		// StopGroupTyping
		Assert(_prgActions[i].id == idName);
		Assert(idName == UID_TYPING);

		// Put existing antievent chain onto *end* of current one
		while((paeNext = paetemp->GetNext()) != NULL)
			paetemp = paeNext;

		paetemp->SetNext(_prgActions[i].pae);
		_index = i;
	}
	else if(_fGroupTyping)
	{
		// In this case, we are *starting* a group typing session.
		// Any subsequent push'es of anti events should be merged
		_fMerge = TRUE;
	}

	_prgActions[_index].pae = pae;
	_prgActions[_index].id = idName;
	
	Next();
	return NOERROR;
}

/*
 *	CUndoStack::PopAndExecuteAntiEvent(pAE)
 *
 *	@mfunc
 *		Undo!  Takes the most recent antievent and executes it
 *
 *	@rdesc
 *		HRESULT from invoking the antievents (AEs)
 */
HRESULT CUndoStack::PopAndExecuteAntiEvent(
	void *pAE)		//@parm If non-NULL, undo up to this point.
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::PopAndExecuteAntiEvent");

	HRESULT		hresult = NOERROR;
	IAntiEvent *pae, *paeDoTo;
	LONG		i, j;
	CCallMgr *	pcallmgr = _ped->GetCallMgr();

	// We need to check to see if there are any non-empty undo builders
	// higher on the stack.  In this case, we have been reentered
	if(pcallmgr->IsReEntered())
	{
		// There are two cases to handle: we are invoking redo or we
		// are invoking undo.  If we are invoking undo and there are 
		// existing undo actions in the undo builder, then simply commit
		// those actions and undo them.  We can assert in this case
		// that the redo stack is empty.
		//
		// In the second case if we are invoking redo while there are
		// undo actions in progress, simply cancel the call.  When the
		// undo actions are added, they will clear the redo stack.
		// 
		// We never need to check for a redo builder as that _only_
		// gets created in this routine and it's use is carefully guarded.
		
		// Commit the antievents to this undo stack, so that we will simply
		// undo them first.
		IUndoBuilder *publdr = (CGenUndoBuilder *)pcallmgr->GetComponent(COMP_UNDOBUILDER);
		if(publdr)
		{			
			TRACEWARNSZ("Undo/Redo Invoked with uncommitted antievents");
			TRACEWARNSZ("		Recovering....");

			if(_fRedo)
			{
				// If we are the redo stack, simply fail the redo call
				return NOERROR;
			}
			// Just commit the antievents; the routine below takes care of the rest
			publdr->Done();
		}
	}

	// If we are in single level mode, check to see if our current buffer is
	// empty.  If so, simply delegate to the redo stack if it exists.  We only
	// support this mode for dwDoToCookies being NULL.  Note that we can't call
	// CanUndo here as it will consider the redo stack as well
	if(_fSingleLevelMode && !_prgActions[GetPrev()].pae)
	{
		Assert(_fRedo == FALSE);
		Assert(pAE == 0);

		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->PopAndExecuteAntiEvent(0);

		// Nothing to redo && nothing to do here; don't bother continuing	
		return NOERROR;
	}

	// This next bit of logic is tricky.  What is says is create
	// an undo builder for the stack *opposite* of the current one
	// (namely, undo actions go on the redo stack and vice versa).
	// Also, if we are the redo stack, then we don't want to flush
	// the redo stack as antievents are added to the undo stack.
	CGenUndoBuilder undobldr(_ped, 
					(!_fRedo ? UB_REDO : UB_DONTFLUSHREDO) | UB_AUTOCOMMIT);
					
	// Obviously, we can't be grouping typing if we're undoing!
	StopGroupTyping();

	// _index by default points to the next available slot
	// so we need to back up to the previous one.
	Prev();

	// Do some verification on the cookie--make sure it's one of ours
	paeDoTo = (IAntiEvent *)pAE;
	if(paeDoTo)
	{
		for(i = 0, j = _index; i < _cUndoLim; i++)
		{
			if(IsCookieInList(_prgActions[j].pae, (IAntiEvent *)paeDoTo))
			{
				paeDoTo = _prgActions[j].pae;
				break;
			}
			// Go backwards through ring buffer; typically
			// paeDoTo will be "close" to the top
			j--;
			if(j < 0)
				j = _cUndoLim - 1;
		}
		
		if(i == _cUndoLim)
		{
			TRACEERRORSZ("Invalid Cookie passed into Undo; cookie ignored");
			hresult = E_INVALIDARG;
			paeDoTo = NULL;
		}
	}
	else
		paeDoTo = _prgActions[_index].pae;

	undobldr.SetNameID(_prgActions[_index].id);

	while(paeDoTo)
	{
		CUndoStackGuard guard(_ped);

		pae = _prgActions[_index].pae;
		Assert(pae);

		// Fixup our state _before_ calling Undo, so 
		// that we can handle being reentered.
		_prgActions[_index].pae = NULL;

		hresult = guard.SafeUndo(pae, &undobldr);

		DestroyAEList(pae);

		if(pae == paeDoTo || guard.WasReEntered())
			paeDoTo = NULL;
		Prev();
	}

	// Put _index at the next unused slot
	Next();
	return hresult;
}

/* 
 *	CUndoStack::GetNameIDFromTopAE(pAE)
 *
 *	@mfunc
 *		Retrieve the name of the most recent undo-able operation
 *
 *	@rdesc	the name ID of the most recent collection of antievents
 */
UNDONAMEID CUndoStack::GetNameIDFromAE(
	void *pAE)		//@parm Antievent whose name is desired;
					//		0 for the top
{
	IAntiEvent *pae = (IAntiEvent *)pAE;
	LONG	i, j = GetPrev();	// _index by default points to next 
								// available slot

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetNameIDFromTopAE");

	if(pae == NULL)
		pae = _prgActions[j].pae;

	if(_fSingleLevelMode && !pae)
	{
		// If fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		// If pae is NULL, our answer may be on the redo stack.  Note that
		// if somebody tries to pass in a cookie while in SingleLevelMode,
		// they won't be able to get actions off the redo stack.
		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->GetNameIDFromAE(0);
	}		

	for(i = 0; i < _cUndoLim; i++)
	{
		if(_prgActions[j].pae == pae)
			return _prgActions[j].id;
		j--;
		if(j < 0)
			j = _cUndoLim - 1;
	}
	return UID_UNKNOWN;
}

/*
 *	CUndoStack::GetMergeAntiEvent ()
 *
 *	@mfunc	If we are in merge typing mode, then return the topmost
 *			antievent
 *
 *	@rdesc	NULL or the current antievent if in merge mode
 */
IAntiEvent *CUndoStack::GetMergeAntiEvent()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetMergeAntiEvent");

	if(_fMerge)
	{
		LONG i = GetPrev();				// _index by default points to
										//  next available slot
		Assert(_prgActions[i].pae);		// Can't be in merge-antievent mode
		return _prgActions[i].pae;		//  if no antievent to merge with!!
	}
	return NULL;
}

/*
 *	CUndoStack::GetTopAECookie()
 *
 *	@mfunc	Returns a cookie to the topmost antievent.
 *
 *	@rdesc	A cookie value. Note that this cookie is just the antievent
 *			pointer, but clients shouldn't really know that.
 */		
void* CUndoStack::GetTopAECookie()
{
 	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetTopAECookie");

	return _prgActions[GetPrev()].pae;
}

/*
 *	CUndoStack::ClearAll ()
 *
 *	@mfunc
 *		Removes any antievents that are currently in the undo stack
 */
void CUndoStack::ClearAll()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::ClearAll");

 	for(LONG i = 0; i < _cUndoLim; i++)
	{
		if(_prgActions[i].pae)
		{
			DestroyAEList(_prgActions[i].pae);
			_prgActions[i].pae = NULL;
		}
	}

	// Just in case we've been grouping typing; clear the state.
	StopGroupTyping();
}

/*
 *	CUndoStack::CanUndo()
 *
 *	@mfunc
 *		Indicates whether or not can undo operation can be performed
 *		(in other words, are there any antievents in our buffer)
 *
 *	@rdesc
 *		TRUE	-- antievents exist 	<nl>
 *		FALSE 	-- no antievents		<nl>
 */
BOOL CUndoStack::CanUndo()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::CanUndo");

	if(_prgActions[GetPrev()].pae)		// _index by default points
		return TRUE;					//  to next available slot

	if(_fSingleLevelMode)
	{
		// If fSingleLevelMode is on, we can't be the redo stack
		Assert(_fRedo == FALSE);

		// If we are in single level mode, we are the undo stack.
		// Check to see if the redo stack can do something here.
		if(_ped->GetRedoMgr())
			return _ped->GetRedoMgr()->CanUndo();
	}
	return FALSE;
}

/*
 *	CUndoStack::StartGroupTyping ()
 *
 *	@mfunc
 *		TOGGLES the group typing flag on.  If fGroupTyping is set, then
 *		all *typing* events will be merged together
 *
 *	@comm
 *	Algorithm:
 *
 *		There are three interesting states:	<nl>
 *			-no group merge; every action just gets pushed onto the stack <nl>
 *			-group merge started; the first action is pushed onto the stack<nl>
 *			-group merge in progress; every action (as long as it's "typing")
 *			is merged into the prior state	<nl>
 *
 *		See the state diagram in the implemenation doc for more details
 */
void CUndoStack::StartGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::StartGroupTyping");

	if(_fGroupTyping)
		_fMerge = TRUE;
	else
	{
		Assert(_fMerge == FALSE);
		_fGroupTyping = TRUE;
	}
}

/*
 *	CUndoStack::StopGroupTyping	()
 *
 *	@mfunc
 *		TOGGLES the group typing flag off.  If fGroupTyping is not set,
 *		then no merging of typing antievents will be done
 */
void CUndoStack::StopGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::StopGroupTyping");

	_fGroupTyping = FALSE;
	_fMerge = FALSE;
}

/*
 *	CUndoStack::EnableSingleLevelMode()
 *
 *	@mfunc	Turns on single level undo mode; in this mode, we behave just like
 *			RichEdit 1.0 w.r.t. to Undo.
 *
 *	@rdesc
 *			HRESULT
 *
 *	@comm	This special mode means that undo is 1 level deep and everything 
 *			is accessed via UNDO messages.  Thus, instead of redo to undo an 
 *			undo action, you simply use another undo message. 
 *
 *	@devnote	This call is _ONLY_ allowed for the UndoStack; the redo 
 *			stack simply tags along.  Note that caller is responsible for
 *			ensuring that we are in an empty state.
 */
HRESULT CUndoStack::EnableSingleLevelMode()
{
	Assert(_ped->GetRedoMgr() == NULL || 
		_ped->GetRedoMgr()->CanUndo() == FALSE);
	Assert(CanUndo() == FALSE && _fRedo == FALSE);

	_fSingleLevelMode = TRUE;

	// For single level undo mode, it is very important to get
	// just 1 entry in the undo stack.  If we can't do that,
	// then we better just fail.
	if(SetUndoLimit(1) != 1)
	{
		_fSingleLevelMode = FALSE;
		return E_OUTOFMEMORY;
	}
	if(_ped->GetRedoMgr())
	{
		// Doesn't matter if the redo manager fails to reset
		_ped->GetRedoMgr()->SetUndoLimit(1);
	}
	return NOERROR;
}

/*
 *	CUndoStack::DisableSingleLevelMode()
 *
 *	@mfunc	This turns off the 1.0 undo compatibility mode and restores us 
 *			to the RichEdit 2.0 default undo state
 */
void CUndoStack::DisableSingleLevelMode()
{
	Assert(_ped->GetRedoMgr() == NULL || 
		_ped->GetRedoMgr()->CanUndo() == FALSE);
	Assert(CanUndo() == FALSE && _fRedo == FALSE);

	// We don't care about failures here; multi-level undo mode
	// can handle any sized undo stack
	_fSingleLevelMode = FALSE;
	SetUndoLimit(DEFAULT_UNDO_SIZE);

	if(_ped->GetRedoMgr())
	{
		// Doesn't matter if the redo manager can't grow back in
		// size; it just means that we won't have full redo capability.
		_ped->GetRedoMgr()->SetUndoLimit(DEFAULT_UNDO_SIZE);
	}
}

//
// PRIVATE METHODS
//

/*
 *	CUndoStack::Next()
 *
 *	@mfunc
 *		Sets _index to the next available slot
 */
void CUndoStack::Next()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Next");

	_index++;
	if(_index == _cUndoLim)
		_index = 0;
}

/*
 *	CUndoStack::Prev()
 *
 *	@mfunc
 *		Sets _index to the previous slot
 */
void CUndoStack::Prev()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::Prev");

	_index = GetPrev();
}

/*
 *	CUndoStack::GetPrev()
 *
 *	@mfunc
 *		Figures out what the index to the previous slot
 *		*should* be (but does not set it)
 *
 *	@rdesc
 *		Index of what the previous slot would be
 */
LONG CUndoStack::GetPrev()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::GetPrev");

	LONG i = _index - 1;

	if(i < 0)
		i = _cUndoLim - 1;

	return i;
}

/*
 *	CUndoStack::IsCookieInList (pae, paeCookie)
 *
 *	@mfunc	
 *		Determines whether or not the given DoTo cookie is in
 *		the list of antievents.
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL CUndoStack::IsCookieInList(
	IAntiEvent *pae,		//@parm	List to check
	IAntiEvent *paeCookie)	//@parm Cookie to check
{
	while(pae)
	{
		if(pae == paeCookie)
			return TRUE;

		pae = pae->GetNext();
	}
	return FALSE;
}

/*
 *	CUndoStack::TransferToNewBuffer	(prgnew, cUndoLim)
 *
 *	@mfunc	
 *		Transfers existing antievents to the given buffer and
 *		swaps this undo stack to use the new buffer
 *
 *	@comm
 *		The algorithm is very straightforward; go backwards in
 *		the ring buffer copying antievents over until either there
 *		are no more antievents or the new buffer is full.  Discard
 *		any remaining antievents.
 */
void CUndoStack::TransferToNewBuffer(
	UndoAction *prgnew,
	LONG		cUndoLim)
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CUndoStack::TransferToNewBuffer");

	LONG 	iOld = 0, 
			iNew = 0,
			iCopyStart = 0;

	// First clear new buffer.
	FillMemory(prgnew, 0, cUndoLim * sizeof(UndoAction));

	// If there is nothing to copy, don't bother
	if(!_prgActions || !_prgActions[GetPrev()].pae)
		goto SetState;

	// This is a bit counter-intuitive, but since the stack is really
	// a ring buffer, go *forwards* until you hit a non-NULL slot.
	// This will be the _end_ of the existing antievents.
	//
	// However, we need to make sure that if cUndoLim is 
	// _smaller_ than _cUndoLim we only copy the final cUndoLim
	// antievents.  We'll set iCopyStart to indicate when
	// we can start copying stuff.
	if(cUndoLim < _cUndoLim)
		iCopyStart = _cUndoLim - cUndoLim;

	for(; iOld < _cUndoLim; iOld++, Next())
	{
		if(!_prgActions[_index].pae)
			continue;

		if(iOld >= iCopyStart)
		{
			Assert(iNew < cUndoLim);

			prgnew[iNew] = _prgActions[_index]; // Copy over antievents
			iNew++;
		}
		else
		{
			// Otherwise, get rid of them
			DestroyAEList(_prgActions[_index].pae);
			_prgActions[_index].pae = NULL;
		}
	}

SetState:
	// Start at index iNew
	_index = (iNew == cUndoLim) ? 0 : iNew;
	Assert(iNew <= cUndoLim);

	_cUndoLim = cUndoLim;
	
	if(_prgActions)
		delete _prgActions;

	_prgActions = prgnew;
}	

//
//	CGenUndoBuilder implementation
//

//
//	Public methods
//

/*
 *	CGenUndoBuilder::CGenUndoBuilder (ped, flags, ppubldr)
 *
 *	@mfunc	Constructor
 *
 *	@comm
 *		This is a *PUBLIC* constructor
 */
CGenUndoBuilder::CGenUndoBuilder(
	CTxtEdit *		ped,		//@parm	Edit context
	DWORD			flags,		//@parm flags (usually UB_AUTOCOMMIT)
	IUndoBuilder **	ppubldr)	//@parm Ptr to undobldr interface
{
	// Set everthing to NULL because instances can go on the stack.
	// _pundo is set below
	_publdrPrev			= NULL;
	_idName				= UID_UNKNOWN;
	_pfirstae			= NULL;
	_fAutoCommit		= (flags & UB_AUTOCOMMIT) != 0;
	_fStartGroupTyping	= FALSE;
	_fDontFlushRedo		= FALSE;
	_fInactive			= FALSE;
	_ped				= ped;

	CompName name;
	if(flags & UB_REDO)
	{
		_fRedo = TRUE;
		name   = COMP_REDOBUILDER;
		_pundo = ped->GetRedoMgr();
	}
	else
	{
		_fRedo = FALSE;
		name   = COMP_UNDOBUILDER;
		_pundo = ped->GetUndoMgr();
	}

	// If undo is on, set *ppubldr to be this undo builder; else NULL
	// TODO: do we need to link in inactive undo builders?
	if(ppubldr)
	{
		if(!ped->_fUseUndo)				// Undo is disabled or suspended
		{								// Still have undobldrs since stack
			*ppubldr = NULL;			//  alloc is efficient. Flag this
			_fInactive = TRUE;			//  one as inactive
			return;
		}
		*ppubldr = this;
	}

	if(flags & UB_DONTFLUSHREDO)
		_fDontFlushRedo = TRUE;

	// Now link ourselves to any undobuilders that are higher up on
	// the stack.  Note that is is legal for multiple undo builders
	// to live within the same call context.
	_publdrPrev = (CGenUndoBuilder *)_ped->GetCallMgr()->GetComponent(name);

	// If we are in the middle of an undo, then we'll have two undo stacks
	// active, the undo stack and the redo stack.  Don't like the two
	// together.
	if(_fDontFlushRedo)
		_publdrPrev = NULL;

	_ped->GetCallMgr()->RegisterComponent((IReEntrantComponent *)this,
							name);
}

/*
 *	CGenUndoBuilder::~CGenUndoBuilder()
 *
 *	@mfunc	Destructor
 *
 *	@comm
 *		This is a *PUBLIC* destructor
 *
 *	Algorithm:
 *		If this builder hasn't been committed to an undo stack
 *		via ::Done, then we must be sure to free up any resources
 *		(antievents) we may be hanging onto
 */
CGenUndoBuilder::~CGenUndoBuilder()
{
	if(!_fInactive)
		_ped->GetCallMgr()->RevokeComponent((IReEntrantComponent *)this);

	if(_fAutoCommit)
	{
		Done();
		return;
	}

	// Free resources
	if(_pfirstae)
		DestroyAEList(_pfirstae);
}

/*
 *	CGenUndoBuilder::SetNameID (idName)
 *
 *	@mfunc
 *		Allows a name to be assigned to this antievent collection.
 *		The ID should be an index that can be used to retrieve a
 *		language specific string (like "Paste").  This string is
 *		typically composed into undo menu items (i.e. "Undo Paste").
 */
void CGenUndoBuilder::SetNameID(
	UNDONAMEID idName)			//@parm	the name ID for this undo operation
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::SetNameID");

	// Don't delegate to the higher undobuilder, even if it exists. The
	// original name should win in reentrancy cases.
	_idName = idName;
}

/*
 *	CGenUndoBuilder::AddAntiEvent (pae)
 *
 *	@mfunc
 *		Adds an antievent to the end of the list
 *
 *	@rdesc 	NOERROR
 */
HRESULT CGenUndoBuilder::AddAntiEvent(
	IAntiEvent *pae)		//@parm	Antievent to add
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::AddAntiEvent");

	if(_publdrPrev)
		return _publdrPrev->AddAntiEvent(pae);

	pae->SetNext(_pfirstae);
	_pfirstae = pae;

	return NOERROR;
}

/*
 *	CGenUndoBuilder::GetTopAntiEvent()
 *
 *	@mfunc	Gets the top antievent for this context.
 *
 *	@comm	The current context can be either the current
 *			operation *or* to a previous operation if we are in
 *			merge typing mode.
 *
 *	@rdesc	top antievent
 */
IAntiEvent *CGenUndoBuilder::GetTopAntiEvent()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::GetTopAntiEvent");

	if(_publdrPrev)
	{
		Assert(_pfirstae == NULL);
		return _publdrPrev->GetTopAntiEvent();
	}

	if(!_pfirstae && _pundo)
		return _pundo->GetMergeAntiEvent();

	return _pfirstae;
}

/*
 *	CGenUndoBuilder::Done ()
 *
 *	@mfunc
 *		Puts the combined antievents (if any) into the undo stack
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT CGenUndoBuilder::Done()
{
	HRESULT		hr = NOERROR;

	if(_publdrPrev)
	{
		Assert(_pfirstae == NULL);
		return NOERROR;
	}

	// If nothing changed, discard any selection antievents
	// or other no-op actions.
	if(!_ped->GetCallMgr()->GetChangeEvent())
	{
		Discard();
		return NOERROR;
	}

	if(_ped->GetDetectURL())
		_ped->GetDetectURL()->ScanAndUpdate(_pundo && _ped->_fUseUndo ? this : NULL);

	if(_pfirstae)
	{
		if(!_pundo)
		{
			// Yikes!  There's no undo stack; better create one.
			// If we are a redo guy, we should create a redo
			// stack the size of the undo stack
			LONG cUndoLim = DEFAULT_UNDO_SIZE;
			if(_fRedo)
			{
				Assert(_ped->GetUndoMgr());

				cUndoLim = _ped->GetUndoMgr()->GetUndoLimit();
			}

			// FUTURE:  A NULL ptr returned from CreateUndoMgr means either
			// 	we are out of memory, or the undo limit is set to 0.  For the
			// 	latter case, we have collected AE's to push onto a non-existent
			// 	undo stack.  It may be more efficient to not generate
			// 	the AE's at all when the undo limit is 0.
			_pundo = _ped->CreateUndoMgr(cUndoLim,	_fRedo ? US_REDO : US_UNDO);
			if(!_pundo)
				goto CleanUp;
		}

		// We may need to flush the redo stack if we are adding
		// more antievents to the undo stack *AND* we haven't been
		// told not to flush the redo stack.  The only time we won't
		// flush the redo stack is if it's the redo stack itself
		// adding antievents to undo.
		if(!_fRedo)
		{
			// If our destination is the undo stack, then check
			// to see if we should flush
			if(!_fDontFlushRedo)
			{
				IUndoMgr *predo = _ped->GetRedoMgr();
				if(predo)
					predo->ClearAll();
			}
		}
		else
			Assert(!_fDontFlushRedo);

		// If we should enter into the group typing state, inform
		// the undo manager.  Note that we only do this *iff* 
		// there is actually some antievent to put in the undo
		// manager.  This makes the undo manager easier to implement.
		if(_fStartGroupTyping)
			_pundo->StartGroupTyping();
		
		hr = _pundo->PushAntiEvent(_idName, _pfirstae);

		// The change event flag should be set if we're adding
		// undo items!  If this test is true, it probably means
		// the somebody earlier in the call stack sent change
		// notifications, e.g., via SendAllNotifications _before_
		// this undo context was committed _or_ it means that we
		// were reentered in some way that was not handled properly.
		// Needless to say, this is not an ideal state.

CleanUp:
		Assert(_ped->GetCallMgr()->GetChangeEvent());

		IAntiEvent *paetemp = _pfirstae;
		_pfirstae = NULL;
		CommitAEList(_ped, paetemp);

		if(!_pundo || hr != NOERROR)
		{
			// Either we failed to add the AE's to the undo stack
			// or the undo limit is 0 in which case there won't be
			// an undo stack to push the AE's onto.
			DestroyAEList(paetemp);
		}
	}
	return hr;
}

/*
 *	CGenUndoBuilder::Discard ()
 *
 *	@mfunc
 *		Gets rid of any antievents that we may be hanging onto without
 *		executing or committing them.  Typically used for recovering
 *		from certain failure or reentrancy scenarios.  Note that
 *		an _entire_ antievent chain will be removed in this fashion.
 */
void CGenUndoBuilder::Discard()
{
	if(_pfirstae)
	{
		DestroyAEList(_pfirstae);
		_pfirstae = NULL;
	}
	else if(_publdrPrev)
		_publdrPrev->Discard();
}

/*
 *	CGenUndoBuilder::StartGroupTyping ()
 *
 *	@mfunc
 *		Hangs onto the the fact that group typing should start.
 *		We'll forward the the state transition to the undo manager
 *		only if an antievent is actually added to the undo manager.
 *
 *	@devnote
 *		Group typing is disabled for redo stacks.
 */
void CGenUndoBuilder::StartGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::StartGroupTyping");

	_fStartGroupTyping = TRUE;
}

/*
 *	CGenUndoBuilder::StopGroupTyping ()
 *
 *	@mfunc
 *		Forwards a stop grouped typing to the undo manager
 */
void CGenUndoBuilder::StopGroupTyping()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CGenUndoBuilder::StopGroupTyping");

	if(_pundo)
		_pundo->StopGroupTyping();
}

//
//	CUndoStackGuard IMPLEMENTATION
//

/*
 *	CUndoStackGuard::CUndoStackGuard(ped)
 *
 *	@mfunc	Constructor.  Registers this object with the call manager
 */
CUndoStackGuard::CUndoStackGuard(
	CTxtEdit *ped)			//@parm the edit context
{
	_ped = ped;
	_fReEntered = FALSE;
	_hr = NOERROR;
	ped->GetCallMgr()->RegisterComponent(this, COMP_UNDOGUARD);
}

/*
 *	CUndoStackGuard::~CUndoStackGuard()
 *
 *	@mfunc	Destructor.  Revokes the registration of this object
 *			with the call manager
 */
CUndoStackGuard::~CUndoStackGuard()
{
	_ped->GetCallMgr()->RevokeComponent(this);
}

/*
 *	CUndoStackGuard::SafeUndo (pae, publdr)
 *
 *	@mfunc	Loops through the given list of antievents, invoking
 *			undo on each.  
 *
 *	@rdesc	HRESULT, from the undo actions
 *
 *	@devnote	This routine is coded so that OnEnterContext can pick up
 *			and continue the undo operation should we become reentered
 */
HRESULT CUndoStackGuard::SafeUndo(
	IAntiEvent *  pae,		//@parm Start of antievent list
	IUndoBuilder *publdr)	//@parm Undo builder to use
{
	_publdr = publdr;
	while(pae)
	{
		_paeNext = pae->GetNext();
		HRESULT hr = pae->Undo(_ped, publdr);

		// Save first returned error
		if(hr != NOERROR && _hr == NOERROR)
			_hr = hr;

		pae = (IAntiEvent *)_paeNext;
	}
	return _hr;
}

/*
 *	CUndoStackGuard::OnEnterContext
 *
 *	@mfunc	Handle reentrancy during undo operations.
 *
 *	@devnote If this method is called, it's pretty serious.  In general,
 *			we shoud never be reentered while processing undo stuff.
 *			However, to ensure that, block the incoming call and process
 *			the remaining actions.
 */
void CUndoStackGuard::OnEnterContext()
{
	TRACEWARNSZ("ReEntered while processing undo.  Blocking call and");
	TRACEWARNSZ("	attempting to recover.");

	_fReEntered = TRUE;
	SafeUndo((IAntiEvent *)_paeNext, _publdr);
}	

//
//	PUBLIC helper functions
//

/*
 *	DestroyAEList(pae)
 *
 *	@func
 *		Destroys a list of antievents
 */
void DestroyAEList(
	IAntiEvent *pae)	//@parm Antievent from which to start
{
	IAntiEvent *pnext;

	while(pae)
	{
		pnext = pae->GetNext();
		pae->Destroy();
		pae = pnext;
	}
}

/*
 *	CommitAEList(ped, pae)
 *
 *	@func 
 *		Calls OnCommit to commit the given list of antievents
 */
void CommitAEList(
	CTxtEdit *	ped,	//@parm Edit context
	IAntiEvent *pae)	//@parm Antievent from which to start
{
	IAntiEvent *pnext;
	while(pae)
	{
		pnext = pae->GetNext();
		pae->OnCommit(ped);
		pae = pnext;
	}
}

/*
 *	HandleSelectionAEInfo(ped, publdr, cp, cch, cpNext, cchNext, flags)
 *
 *	@func	HandleSelectionAEInfo | Tries to merge the given info with 
 *			the existing undo context; if that fails, then it allocates 
 *			a new selection antievent to handle the info
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT HandleSelectionAEInfo(
	CTxtEdit *	  ped,		//@parm Edit context
	IUndoBuilder *publdr,	//@parm Undo context
	LONG		  cp,		//@parm cp to use for the sel ae
	LONG		  cch,		//@parm Signed selection extension
	LONG		  cpNext,	//@parm cp to use for the AE of the AE
	LONG		  cchNext,	//@parm cch to use for the AE of the AE
	SELAE		  flags)	//@parm Controls how to interpret the info
{
	Assert(publdr);

	// First see if we can merge the selection info into any existing
	// antievents.  Note that the selection antievent may be anywhere
	// in the list, so go through them all
	IAntiEvent *pae = publdr->GetTopAntiEvent();
	if(pae)
	{
		SelRange sr;

		sr.cp		= cp;
		sr.cch		= cch;
		sr.cpNext	= cpNext;
		sr.cchNext	= cchNext;
		sr.flags	= flags;

		while(pae)
		{
			if(pae->MergeData(MD_SELECTIONRANGE, (void *)&sr) == NOERROR)
				break;
			pae = pae->GetNext();
		}
		if(pae)
			return NOERROR;
	}

	// Oops; can't do a merge.  Go ahead and create a new antievent.
	Assert(!pae);
	pae = gAEDispenser.CreateSelectionAE(ped, cp, cch, cpNext, cchNext);
	if(pae)
	{
		publdr->AddAntiEvent(pae);
		return NOERROR;
	}
	return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\olsole.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OLSOLE.CPP -- OlsOle LineServices object class
 *	
 *	Author:
 *		Murray Sargent (with lots of help from RickSa's ols code)
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

#ifndef NOLINESERVICES

#include "_font.h"
#include "_edit.h"
#include "_disp.h"
#include "_ols.h"
#include "_render.h"
extern "C" {
#include "objdim.h"
#include "pobjdim.h"
#include "plsdnode.h"
#include "dispi.h"
#include "pdispi.h"
#include "fmti.h"
#include "lsdnset.h"
#include "lsdnfin.h"
#include "brko.h"
#include "pbrko.h"
#include "locchnk.h"
#include "lsqout.h"
#include "lsqin.h"
#include "lsimeth.h"
}

extern BOOL g_OLSBusy;

/*
 *	OlsOleCreateILSObj(pols, plsc, pclscbk, dword, ppilsobj)
 *
 *	@func
 *		Create LS Ole object handler. We don't have any need for
 *		this, so just set it to 0.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleCreateILSObj(
	POLS	 pols,		//[IN]: COls * 
	PLSC	 plsc,  	//[IN]: LineServices context
	PCLSCBK,
	DWORD,
	PILSOBJ *ppilsobj)	//[OUT]: ptr to ilsobj
{
	*ppilsobj = 0;
	return lserrNone;
}

/*
 *	OlsOleDestroyILSObj(pilsobj)
 *
 *	@func
 *		Destroy LS Ole handler object. Nothing to do, since we don't
 *		use the ILSObj.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyILSObj(
	PILSOBJ pilsobj)
{
	return lserrNone;
}

/*
 *	OlsOleSetDoc(pilsobj, pclsdocinf)
 *
 *	@func
 *		Set doc info. Nothing to do for Ole objects
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleSetDoc(
	PILSOBJ, 
	PCLSDOCINF)
{
	// Ole objects don't care about this
	return lserrNone;
}

/*
 *	OlsOleCreateLNObj(pilsobj, pplnobj)
 *
 *	@func
 *		Create the line object. Nothing needed in addition to the ped,
 *		so just return the ped as the LN object.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleCreateLNObj(
	PCILSOBJ pilsobj, 
	PLNOBJ * pplnobj)
{
	*pplnobj = (PLNOBJ)g_pols->_pme->GetPed();			// Just the ped
	return lserrNone;
}

/*
 *	OlsOleDestroyLNObj(plnobj)
 *
 *	@func
 *		Destroy LN object. Nothing to do, since ped is destroyed
 *		elsewhere
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyLNObj(
	PLNOBJ plnobj)
{
	return lserrNone;
}

/*
 *	OlsOleFmt(plnobj, pcfmtin, pfmres)
 *
 *	@func
 *		Compute dimensions of a particular Ole object
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleFmt(
	PLNOBJ	plnobj, 
	PCFMTIN pcfmtin, 
	FMTRES *pfmres)
{
	const LONG		cp = pcfmtin->lsfrun.plsrun->_cp; //Cannot trust LS cps
	LONG			dup = 0;
	LSERR			lserr;
	OBJDIM			objdim;
	CMeasurer *		pme = g_pols->_pme;
	COleObject *	pobj = pme->GetObjectFromCp(cp);
	Assert(pobj);

	ZeroMemory(&objdim, sizeof(objdim));

	pobj->MeasureObj(pme->_dvrInch, pme->_durInch, objdim.dur, objdim.heightsRef.dvAscent,
					 objdim.heightsRef.dvDescent, pcfmtin->lstxmRef.dvDescent, pme->GetTflow());
	
	pobj->MeasureObj(pme->_dvpInch, pme->_dupInch, dup, objdim.heightsPres.dvAscent,
					 objdim.heightsPres.dvDescent, pcfmtin->lstxmPres.dvDescent, pme->GetTflow());

	pobj->_plsdnTop = pcfmtin->plsdnTop;

	lserr = g_plsc->dnFinishRegular(1, pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, (PDOBJ)pobj, &objdim);
	if(lserrNone == lserr) 
	{
		lserr = g_plsc->dnSetRigidDup(pcfmtin->plsdnTop, dup);
		if(lserrNone == lserr) 
		{
			*pfmres = fmtrCompletedRun;

			if (pcfmtin->lsfgi.urPen + objdim.dur > pcfmtin->lsfgi.urColumnMax 
				&& !pcfmtin->lsfgi.fFirstOnLine)
			{
				*pfmres = fmtrExceededMargin;
			}
		}
	}
	return lserr;
}


/*
 *	OlsOleTruncateChunk(plocchnk, posichnk)
 *
 *	@func
 *		Truncate chunk plocchnk at the point posichnk
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleTruncateChunk(
	PCLOCCHNK plocchnk,		// (IN): locchnk to truncate
	PPOSICHNK posichnk)		// (OUT): truncation point
{
	LSERR			lserr;
	OBJDIM			objdim;
	PLSCHNK 		plschnk = plocchnk->plschnk;
	COleObject *	pobj;
	long			ur	 = plocchnk->lsfgi.urPen;
	long			urColumnMax = plocchnk->lsfgi.urColumnMax;

	for(DWORD i = 0; ur <= urColumnMax; i++)
	{
		AssertSz(i < plocchnk->clschnk,	"OlsOleTruncateChunk: exceeded group of chunks");

		pobj = (COleObject *)plschnk[i].pdobj;
		Assert(pobj);

		lserr = g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &objdim);
		if(lserr != lserrNone)
			return lserr;

		ur += objdim.dur;
	}
	posichnk->ichnk = i - 1;
	posichnk->dcp	= 1;
	return lserrNone;
}
/*
 *	OlsOleFindPrevBreakChunk(plocchnk, pposichnk, brkcond, pbrkout)
 *
 *	@func
 *		Find previous break in chunk
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleFindPrevBreakChunk(
	PCLOCCHNK	plocchnk, 
	PCPOSICHNK	pposichnk, 
	BRKCOND		brkcond,	//(IN): recommendation about break after chunk
	PBRKOUT		pbrkout)
{
	ZeroMemory(pbrkout, sizeof(*pbrkout));

	if (pposichnk->ichnk == ichnkOutside && (brkcond == brkcondPlease || brkcond == brkcondCan))
		{
		pbrkout->fSuccessful = fTrue;
		pbrkout->posichnk.ichnk = plocchnk->clschnk - 1;
		pbrkout->posichnk.dcp = plocchnk->plschnk[plocchnk->clschnk - 1].dcp;
		COleObject *pobj = (COleObject *)plocchnk->plschnk[plocchnk->clschnk - 1].pdobj;
		Assert(pobj);

		g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &pbrkout->objdim);
	}
	else
		pbrkout->brkcond = brkcondPlease;

	return lserrNone;
}


/*
 *	OlsOleForceBreakChunk(plocchnk, pposichnk, pbrkout)
 *
 *	@func
 *		Called when forced to break a line.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleForceBreakChunk(
	PCLOCCHNK	plocchnk, 
	PCPOSICHNK	pposichnk, 
	PBRKOUT		pbrkout)
{
	ZeroMemory(pbrkout, sizeof(*pbrkout));
	pbrkout->fSuccessful = fTrue;

	if (plocchnk->lsfgi.fFirstOnLine && pposichnk->ichnk == 0 || pposichnk->ichnk == ichnkOutside)
		{
		pbrkout->posichnk.dcp = 1;
		COleObject *pobj = (COleObject *)plocchnk->plschnk[0].pdobj;
		Assert(pobj);

		g_plsc->dnQueryObjDimRange(pobj->_plsdnTop, pobj->_plsdnTop, &pbrkout->objdim);
		}
	else
		{
		pbrkout->posichnk.ichnk = pposichnk->ichnk;
		pbrkout->posichnk.dcp = 0;
		}

	return lserrNone;
}

/*
 *	OlsOleSetBreak(pdobj, brkkind, nBreakRecord, rgBreakRecord, nActualBreakRecord)
 *
 *	@func
 *		Set break
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleSetBreak(
	 PDOBJ pdobj,				// (IN): dobj which is broken
	 BRKKIND  brkkind,			// (IN): Previous/Next/Force/Imposed was chosen
	 DWORD	nBreakRecord,		// (IN): size of array
	 BREAKREC* rgBreakRecord,	// (OUT): array of break records
	 DWORD* nActualBreakRecord)	// (OUT): actual number of used elements in array
{
	return lserrNone;
}

LSERR WINAPI OlsOleGetSpecialEffectsInside(
	PDOBJ pdobj,			// (IN): dobj
	UINT *pEffectsFlags)	// (OUT): Special effects for this object
{
	*pEffectsFlags = 0;
	return lserrNone;
}

LSERR WINAPI OlsOleCalcPresentation(
	PDOBJ,					// (IN): dobj
	long,					// (IN): dup of dobj
	LSKJUST,				// (IN): LSKJUST
	BOOL fLastVisibleOnLine)// (IN): this object is last visible object on line
{
	return lserrNone;
}

/*
 *	OlsOleQueryPointPcp(pdobj, ppointuvQuery, plsqin, plsqout)
 *
 *	@func
 *		Query Ole object PointFromCp.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleQueryPointPcp(
	PDOBJ	  pdobj,			//(IN): dobj to query
	PCPOINTUV ppointuvQuery,	//(IN): query point (uQuery,vQuery)
    PCLSQIN	  plsqin,			//(IN): query input
    PLSQOUT	  plsqout)			//(OUT): query output
{
	ZeroMemory(plsqout, sizeof(LSQOUT));

	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	return lserrNone;
}
	
/*
 *	OlsOleQueryCpPpoint(pdobj, dcp, plsqin, plsqout)
 *
 *	@func
 *		Query Ole object CpFromPoint.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleQueryCpPpoint(
	PDOBJ	pdobj,		//(IN): dobj to query
	LSDCP	dcp,		//(IN):  dcp for query
    PCLSQIN	plsqin,		//(IN): query input
    PLSQOUT	plsqout)	//(OUT): query output
{
	ZeroMemory(plsqout, sizeof(LSQOUT));

	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	return lserrNone;
}

/*
 *	OlsOleDisplay(pdobj, pcdispin)
 *
 *	@func
 *		Display object
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDisplay(
	PDOBJ	 pdobj,			//(IN): dobj to query
	PCDISPIN pcdispin)		//(IN): display info
{
	COleObject *pobj = (COleObject *)pdobj;
	Assert(pobj);

	CRenderer  *pre = g_pols->GetRenderer();
	const CDisplay *pdp = pre->GetPdp();
	
	POINTUV ptuv = {pcdispin->ptPen.x, pcdispin->ptPen.y - pre->GetLine().GetDescent()};

	if (pcdispin->lstflow == lstflowWS)
		ptuv.u -= pcdispin->dup - 1;

	pre->SetSelected(pcdispin->plsrun->IsSelected());
	pre->Check_pccs();
	pre->SetFontAndColor(pcdispin->plsrun->_pCF);

	if (pre->_fEraseOnFirstDraw)
		pre->EraseLine();

	pre->SetCurPoint(ptuv);
	pre->SetClipLeftRight(pcdispin->dup);

	if (!pobj->FWrapTextAround())
	{
		COls			*polsOld = g_pols;
		CLineServices	*plscOld = g_plsc;
		BOOL			fOLSBusyOld = g_OLSBusy;

		BOOL	fRestore = FALSE;

		if (g_plsc && g_pols)
		{
			// This is to fix a re-entrance problem.  
			// We first NULL out the two globals.  If the OleObject is using Richedit, it will
			// create a new LineService context.  By the time it get back to here, we will free that
			// context and restore the current context.  This is necessary since LineService will returns
			// error when we are using the same context in the Parent and then in the Ole Object using RE.
			g_plsc = NULL;
			g_pols = NULL;
			g_OLSBusy = FALSE;
			fRestore = TRUE;
		}
		pobj->DrawObj(pdp, pre->_dvpInch, pre->_dupInch, pre->GetDC(), &pre->GetClipRect(), pdp->IsMetafile(), 
					 &ptuv, pcdispin->ptPen.y - ptuv.v, pre->GetLine().GetDescent(), pre->GetTflow());

		if (fRestore)
		{
			// Time to delete the new context created within the DrawObject.
			if (g_pols)
				delete g_pols;

			// Restore old globals
			g_pols = polsOld;
			g_plsc = plscOld;
			g_OLSBusy = fOLSBusyOld;
		}
	}
	return lserrNone;
}

/*
 *	OlsOleDistroyDObj(pdobj)
 *
 *	@func
 *		Destroy object: nothing to do since object is destroyed elsewhere
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsOleDestroyDObj(
	PDOBJ pdobj)
{
	return lserrNone;
}


extern const LSIMETHODS vlsimethodsOle =
{
	OlsOleCreateILSObj,
	OlsOleDestroyILSObj,
    OlsOleSetDoc,
    OlsOleCreateLNObj,
    OlsOleDestroyLNObj,
	OlsOleFmt,
	0,//OlsOleFmtResume
	0,//OlsOleGetModWidthPrecedingChar
	0,//OlsOleGetModWidthFollowingChar
    OlsOleTruncateChunk,
    OlsOleFindPrevBreakChunk,
    0,//OlsOleFindNextBreakChunk
    OlsOleForceBreakChunk,
    OlsOleSetBreak,
	OlsOleGetSpecialEffectsInside,
	0,//OlsOleFExpandWithPrecedingChar
	0,//OlsOleFExpandWithFollowingChar
	OlsOleCalcPresentation,
	OlsOleQueryPointPcp,
	OlsOleQueryCpPpoint,
	0,//pfnEnum
    OlsOleDisplay,
    OlsOleDestroyDObj
};
#endif		// NOLINESERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\osdc.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OSDC.CPP -- Off Screen DC class |
 *
 *		This contains method used to implement the off screen
 *		DC class
 *	
 *	Owner:<nl>
 *		Rick Sailor
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#include	"_common.h"
#include	"_osdc.h"

ASSERTDATA

/*
 *	COffscreenDC::GetDimensions(pdx, pdy)
 *
 *	@mfunc	
 *		return the current height of the osdc
 *
 *	@rdesc
 *		height of the osdc
 */
void COffscreenDC::GetDimensions(long *pdx, long *pdy)
{
	Assert(_hbmp);
	BITMAP bitmap;
	W32->GetObject(_hbmp, sizeof(BITMAP), &bitmap);
	*pdx = bitmap.bmWidth;
	*pdy = bitmap.bmHeight;
}

/*
 *	COffscreenDC::Init(hdc, xWidth, yHeight, crBackground)
 *
 *	@mfunc	
 *		Initialize off screen DC with compatible bitmap
 *
 *	@rdesc
 *		HDC created
 */
HDC	COffscreenDC::Init(
	HDC		 hdc,			//@parm DC to be compatible with
	LONG	 xWidth,		//@parm Width of compatible bitmap
	LONG	 yHeight,		//@parm Height of compatible bitmap
	COLORREF crBackground)	//@parm Default background for bitmap
{
	if (_hdc)
		return _hdc;

	HDC hdcRet	= NULL;					// HDC to return to caller
	_hbmpOld	= NULL;					// Assume failure
	_hbmp		= NULL;
	_hpalOld	= NULL;

	// Create memory DC
	_hdc = CreateCompatibleDC(hdc);
	if(_hdc)
	{
		// Create bitmap based on size of client rectangle
		_hbmp = CreateCompatibleBitmap(hdc, xWidth, yHeight);
		if(_hbmp)
		{
			// Select bitmap into hdc
			_hbmpOld = (HBITMAP)SelectObject(_hdc, _hbmp);
			if(_hbmpOld && SetBkColor(_hdc, crBackground) != CLR_INVALID)
				hdcRet = _hdc;
		}
	}
	if(!hdcRet)
		FreeData();

	return hdcRet;
}

/*
 *	COffscreenDC::SelectPalette(hpal)
 *
 *	@mfunc	
 *		Set a new palette into the hdc
 */
void COffscreenDC::SelectPalette(
	HPALETTE hpal)			//@parm Handle to palette to set
{
#ifndef NOPALETTE
	if(hpal)
	{
		_hpalOld = ::SelectPalette(_hdc, hpal, TRUE);
		RealizePalette(_hdc);
	}
#endif
}

/*
 *	COffscreenDC::FreeData()
 *
 *	@mfunc	
 *		Free resources associated with bitmap
 */
void COffscreenDC::FreeData()
{
	if(_hdc)
	{
#ifndef NOPALETTE
		if(_hpalOld)
			::SelectPalette(_hdc, _hpalOld, TRUE);
#endif
		if(_hbmpOld)
			SelectObject(_hdc, _hbmpOld);

		if(_hbmp)
		{
			DeleteObject(_hbmp);
			_hbmp = NULL;
		}

		DeleteDC(_hdc);

		_hdc = NULL;
	}
}

/*
 *	COffscreenDC::Realloc(xWidth, yHeight)
 *
 *	@mfunc	
 *		Reallocate bitmap
 *
 *	@rdesc
 *		TRUE - succeeded 
 *		FALSE - failed
 */
BOOL COffscreenDC::Realloc(
	LONG xWidth,			//@parm Width of new bitmap
	LONG yHeight)			//@parm Height of new bitmap
{
	// Create bitmap based on size of client rectangle
	HBITMAP hbmpNew = CreateCompatibleBitmap(_hdc, xWidth, yHeight);

	if(!hbmpNew)
	{
		AssertSz(FALSE,	"COffscreenDC::Realloc CreateCompatibleBitmap failed"); 
		return FALSE;
	}

	SelectObject(_hdc, hbmpNew);

	// Delete old bitmap
	DeleteObject(_hbmp);

	// Put in new bitmap
	_hbmp = hbmpNew;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\ols.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	OLS.CPP -- COls LineServices object class
 *	
 *	Authors:
 *		Murray Sargent: initial coding up to nonLS RichEdit functionality
 *			(with lots of help from RickSa's ols code)
 *		Keith Curtis and Worachai Chaoweeraprasit: complex script support,
 *			etc.
 *
 *	@todo
 *		LSCHP.dcpMaxContext is never set for complex scripts!
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

#ifndef NOLINESERVICES

#include "_edit.h"
#include "_font.h"
#include "_render.h"
#include "_osdc.h"
#include "_tomfmt.h"
#include "_ols.h"
#include "_clasfyc.h"
#include "_uspi.h"
#include "_txtbrk.h"
#include "_hyph.h"

ASSERTDATA

// Guess at the number of characters on the line
const int cchLineHint = 66;

#define OBJID_OLE			0
#define OBJID_REVERSE		1
#define	OBJID_COUNT			2

const WCHAR wchObjectEnd = 0x9F;
const WCHAR rgchObjectEnd[]	= {wchObjectEnd};

#define	MAX_OBJ_DEPTH		3

extern const LSCBK lscbk;

// Kinsoku break pair information
extern const INT g_cKinsokuCategories;

CLineServices *g_plsc = NULL;		// LineServices Context
COls*		   g_pols = NULL;		// COls ptr

const LSBRK rglsbrkDefault[] =
{
	0,0,	// Always prohibited
	0,1,	// OK across blanks
	1,1		// Always allowed
};

// prototypes
void 	EmitBrace(COls* pols, PLSCHP pchp, BOOL* pfHid, DWORD* pcch, PLSRUN* pprun, LPCWSTR* plpwch, int id, LPCWSTR str);
void	DupShapeState(PLSRUN prun, LONG cch);


// public inline functions
//

// Emitting fake brace to LS
inline void EmitBrace(
	COls*		pols,
	PLSCHP		pchp,
	BOOL*		pfHid,
	DWORD*		pcch,
	PLSRUN*		pprun,
	LPCWSTR*	plpwch,
	int			id,
	LPCWSTR		str)
{
	ZeroMemory(pchp, sizeof(*pchp));								
	pchp->idObj = (WORD)id;												
	*pfHid 		= 0;												
	*pcch 		= 1;												
	*pprun 		= pols->GetPlsrun(0, pols->_pme->GetCF(), FALSE);
	*plpwch		= str;												
}

#ifndef NOCOMPLEXSCRIPTS
// Duplicate shaping state to each runs in the chain
// note: this macro used only by GetGlyph and GetGlyphPosition
inline void DupShapeState(
	PLSRUN		prun,
	LONG		cch)
{
	PLSRUN	pnext = prun->_pNext;										
	LONG	cpEnd = prun->_cp + cch;									
	while (pnext && pnext->_cp < cpEnd)
	{
		CopyMemory(&pnext->_a, &prun->_a, sizeof(SCRIPT_ANALYSIS));
		pnext->SetFallback(prun->IsFallback());
		prun = pnext;
		pnext = prun->_pNext;
	}																
	Assert(!pnext && prun->_cp < cpEnd);
}
#endif




LONG COls::GetCpLsFromCpRe(
	LONG cpRe)
{
	if (_rgcp.Count() == 0)
		return cpRe;

	LONG *pcp = _rgcp.Elem(0);

	for(LONG cpLs = cpRe; cpLs >= *pcp; pcp++)
		 cpLs++;

	return cpLs;
}

LONG COls::GetCpReFromCpLs(
	LONG cpLs)
{
	if (_rgcp.Count() == 0)
		return cpLs;

	LONG *pcp = _rgcp.Elem(0);

	for(int dcp = 0; cpLs > *pcp; pcp++)
		dcp--;

	return cpLs + dcp;
}

#ifdef DEBUG
//#define DEBUG_BRACE
#endif
// return TRUE if braces added
BOOL COls::AddBraceCp(long cpLs)
{
	if (_rgcp.Count() == 0)
	{
		long *pcp = _rgcp.Insert(0, 1);
		*pcp = tomForward;
	}

	long *pcp = _rgcp.Elem(0);
	long iel = 0;

	while (cpLs > pcp[iel])
		iel++;

	if (cpLs < pcp[iel])
	{
		pcp = _rgcp.Insert(iel, 1);
		*pcp = cpLs;
		return TRUE;
	}
	return FALSE;
}

// return number of braces before cp
//
LONG COls::BracesBeforeCp(
	LONG cpLs)
{
	LONG 	iel, cbr = 0;
	LONG*	pcp;

	if (!cpLs || (iel = _rgcp.Count()) < 2)
		return 0;

	iel -= 2;		// exclude the last tomForward one and make a count an index
	cpLs--;			// start with the cp preceding given cp

	pcp = _rgcp.Elem(0);

	while (iel > -1 && pcp[iel] > cpLs)		// search the first one
		iel--;

	while (iel > -1 && pcp[iel] == cpLs)	// continue counting
	{
		iel--;
		cpLs--;
		cbr++;
	}
	return cbr;
}

/*
 * 	COls::SetRun(plsrun)
 *
 *	@mfunc
 *		Do whatever is needed to initialize the measurer (pme) to the lsrun
 *		givin by plsrun and return whether the run is for autonumbering.
 *
 *	@rdesc
 *		TRUE if plsrun refers to an autonumbering run
 */
BOOL COls::SetRun(
	PLSRUN plsrun)
{
	LONG cp = plsrun->_cp;
	_pme->SetCp(cp & 0x7FFFFFFF);
	return plsrun->IsBullet();
}

/*
 * 	CLsrun::IsSelected()
 *
 *	@mfunc
 *		return whether or not the run should be drawn as selected.
 *
 *	@rdesc
 *		TRUE if run should be drawn with selection colors
 */
BOOL CLsrun::IsSelected()
{
	if (!_fSelected)
		return FALSE;
	CRenderer *pre = g_pols->GetRenderer();
	Assert(pre->IsRenderer());
	return pre->_fRenderSelection ? TRUE : FALSE;
}

/*
 * 	COls::CreatePlsrun ()
 *
 *	@mfunc
 *		Creates a PLSRUN. Is a little tricky because we allocate them
 *		in chunks.
 *
 *	@rdesc
 *		plsrun
 */
const int cplsrunAlloc = 8;
PLSRUN COls::CreatePlsrun()
{
	CLsrunChunk *plsrunChunk = 0;
	
	//First, find a chunk to use
	int cchunk = _rglsrunChunk.Count();
	for (int ichunk = 0; cchunk && ichunk < cchunk; ichunk++)
	{
		plsrunChunk = _rglsrunChunk.Elem(ichunk);
		if (plsrunChunk->_cel < cplsrunAlloc)
			break;
	}	

	if (!cchunk || ichunk == cchunk || plsrunChunk->_cel == cplsrunAlloc)
	{
		CLsrun *rglsrun = new CLsrun[cplsrunAlloc];
		if (rglsrun)
		{
			plsrunChunk = _rglsrunChunk.Add(1, 0);
			if (!plsrunChunk)
			{
				delete[] rglsrun;
				return 0;
			}
			plsrunChunk->_prglsrun = rglsrun;
		}
		else
			return 0;
	}
	return &plsrunChunk->_prglsrun[plsrunChunk->_cel++];
}

/*
 * 	GetPlsrun(cp, pCF, fAutoNumber)
 *
 *	@func
 *		Return plsrun for info in run. The structure contains the starting cp
 * 		of the run and the script analysis if Uniscribe is activated. The
 *		analysis information is needed by subsequent callbacks - GetGlyphs and
 *		GetGlyphPositions to be passed to Uniscribe in order to shape and
 *		position glyphs correctly for complex scripts.
 *
 *	@rdesc
 *		plsrun corresponding to info in arguments
 */
PLSRUN COls::GetPlsrun(
	LONG 		cp,
	const CCharFormat *pCF,
	BOOL 		fAutoNumber)
{
	if(fAutoNumber)
		cp |= CP_BULLET;

	CLsrun *plsrun = CreatePlsrun();

	if (plsrun)
	{
		ZeroMemory(plsrun, sizeof(CLsrun));

		plsrun->_pCF = pCF;
		plsrun->_cp = fAutoNumber ? _cp | CP_BULLET : cp;

		LONG 	cpSelMin, cpSelMost;
		_pme->GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);

		plsrun->SetSelected(!plsrun->IsBullet() && cp >= cpSelMin && cp < cpSelMost);

#ifndef NOCOMPLEXSCRIPTS
		if (pCF->_wScript && !_pme->GetPasswordChar())
		{
			CUniscribe*	pusp = _pme->Getusp();
			Assert(pusp);
			const SCRIPT_PROPERTIES* psp = pusp->GeteProp(pCF->_wScript);

			plsrun->_a.eScript = pCF->_wScript < SCRIPT_MAX_COUNT ? pCF->_wScript : 0;
			plsrun->_a.fRTL  = !psp->fNumeric && (IsBiDiCharRep(pCF->_iCharRep) || IsBiDiCharSet(psp->bCharSet));
			plsrun->_a.fLogicalOrder = TRUE;
		}
#endif
	}
	return plsrun;
}

/*
 *	COls::~COls()
 *
 *	@mfunc
 *		Destructor
 */
COls::~COls()
{
	for (int ichunk = 0, cchunk = _rglsrunChunk.Count(); ichunk < cchunk; ichunk++)
		delete []_rglsrunChunk.Elem(ichunk)->_prglsrun;
	DestroyLine(NULL);
	if (g_plsc)
		LsDestroyContext(g_plsc);
}


/*
 *	COls::Init(pme)
 *
 *	@mfunc
 *		Initialize this LineServices object
 *
 *	@rdesc
 *		HRESULT = (success) ? NOERROR : E_FAIL
 */
HRESULT COls::Init(
	CMeasurer *pme)
{
	_pme = pme;

	if(g_plsc)
		return NOERROR;

	// Build LS context to create
	LSCONTEXTINFO lsctxinf;

	// Setup object handlers
	LSIMETHODS vlsctxinf[OBJID_COUNT];
	vlsctxinf[OBJID_OLE] = vlsimethodsOle;
	if(LsGetReverseLsimethods(&vlsctxinf[OBJID_REVERSE]) != lserrNone)
		return E_FAIL;

	lsctxinf.cInstalledHandlers = OBJID_COUNT;
    lsctxinf.pInstalledHandlers = &vlsctxinf[0];

	// Set default and all other characters to 0xFFFF
    memset(&lsctxinf.lstxtcfg, 0xFF, sizeof(lsctxinf.lstxtcfg));

	lsctxinf.fDontReleaseRuns = TRUE;
	lsctxinf.lstxtcfg.cEstimatedCharsPerLine = cchLineHint;

	// Set the characters we handle
	// FUTURE (keithcu) Support more characters in RE 4.0.
	lsctxinf.lstxtcfg.wchNull			= 0;

	lsctxinf.lstxtcfg.wchSpace			= ' ';
	lsctxinf.lstxtcfg.wchNonBreakSpace	= NBSPACE;

	lsctxinf.lstxtcfg.wchNonBreakHyphen = NBHYPHEN;
	lsctxinf.lstxtcfg.wchNonReqHyphen	= SOFTHYPHEN;
	lsctxinf.lstxtcfg.wchHyphen			= '-';

	lsctxinf.lstxtcfg.wchEmDash			= EMDASH;
	lsctxinf.lstxtcfg.wchEnDash			= ENDASH;

	lsctxinf.lstxtcfg.wchEmSpace		= EMSPACE;
	lsctxinf.lstxtcfg.wchEnSpace		= ENSPACE;
	
	lsctxinf.lstxtcfg.wchTab			= '\t';
	lsctxinf.lstxtcfg.wchEndLineInPara	= '\v';
	lsctxinf.lstxtcfg.wchEndPara1		= '\r';
	lsctxinf.lstxtcfg.wchEndPara2		= '\n';

	lsctxinf.lstxtcfg.wchVisiAltEndPara	=
	lsctxinf.lstxtcfg.wchVisiEndPara	=
	lsctxinf.lstxtcfg.wchVisiEndLineInPara = ' ';
	

	// Auto number escape character
	lsctxinf.lstxtcfg.wchEscAnmRun = wchObjectEnd;

    lsctxinf.pols = this;
    lsctxinf.lscbk = lscbk;

	if(LsCreateContext(&lsctxinf, &g_plsc) != lserrNone)
		return E_FAIL;

	//REVIEW (keithcu) Quill seems to have a more mature kinsoku
	//table. For example, we don't allow breaking across space between
	//a word and the ending punctuation. French people want this behavior.
	BYTE  rgbrkpairsKinsoku[cKinsokuCategories][cKinsokuCategories];
	BYTE *prgbrkpairsKinsoku = &rgbrkpairsKinsoku[0][0];
	LCID lcid = pme->GetCF()->_lcid;
	for(LONG i = 0; i < cKinsokuCategories; i++)
	{
		for(LONG j = 0; j < cKinsokuCategories; j++)
		{
			LONG iBreak = 2*CanBreak(i, j);
			// If don't break, allow break across blanks unless first
			// char is open brace or second char is close brace
			if (!iBreak &&				
				GetKinsokuClass(i, 0xFFFF, lcid) != brkclsOpen &&
				GetKinsokuClass(j, 0xFFFF, lcid) != brkclsOpen)
			{
				iBreak = 1;
			}
			*prgbrkpairsKinsoku++ = iBreak;
		}
	}
	if(g_plsc->SetBreaking(ARRAY_SIZE(rglsbrkDefault), rglsbrkDefault,
					 cKinsokuCategories, &rgbrkpairsKinsoku[0][0]) != lserrNone)
	{
		return E_FAIL;
	}

	return NOERROR;
}

/*
 * 	COls::QueryLineInfo(&lslinfo, pupStart, pdupWidth)
 *
 *	@mfunc
 *		Wrapper for LsQueryLineDup which is not called with full-justified
 *		text because it's slow.
 */
void COls::QueryLineInfo(
	LSLINFO &lslinfo, 
	LONG *	 pupStart, 
	LONG *	 pdupWidth)
{
	const CParaFormat *pPF = _pme->Get_pPF();

	if (!lslinfo.fForcedBreak && /* lslinfo.endr <= endrHyphenated && */
		pPF->_bAlignment == PFA_FULL_INTERWORD && _pme->_pdp->GetWordWrap() &&
		pPF->_dxStartIndent == 0 && pPF->_dxOffset == 0 && pPF->_wNumbering == 0)
	{
		*pupStart = 0;
		*pdupWidth = _pme->LUtoDU(_pme->_dulLayout);
	}
	else
	{
		LONG upJunk, upStartTrailing;
		LsQueryLineDup(_plsline, &upJunk, &upJunk, pupStart, &upStartTrailing, &upJunk);
		*pdupWidth = upStartTrailing - *pupStart;
	}
}

/*
 * 	COls::MeasureLine(pliTarget)
 *
 *	@mfunc
 *		Wrapper for LsCreateLine
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL COls::MeasureLine(
	CLine *	pliTarget)		//@parm Returns target-device line metrics (optional)
{
	CMeasurer *pme = _pme;
	const CDisplay *pdp = pme->_pdp;
	
	LONG cp = pme->GetCp();
#ifdef DEBUG
	LONG cchText = pme->GetTextLength();	// For DEBUG...
	AssertSz(cp < cchText || !pme->IsRich() && cp == cchText, "COls::Measure: trying to measure past EOD");
#endif
	DestroyLine(NULL);

	_cp = cp;
	_pdp = pdp;
	pme->SetUseTargetDevice(FALSE);

	LSDEVRES lsdevres;
	if (IsUVerticalTflow(pme->GetTflow()))
	{
		lsdevres.dxpInch = pme->_dvpInch;
		lsdevres.dypInch = pme->_dupInch;
		lsdevres.dxrInch = pme->_dvrInch;
		lsdevres.dyrInch = pme->_durInch;
	}
	else
	{
		lsdevres.dxpInch = pme->_dupInch;
		lsdevres.dypInch = pme->_dvpInch;
		lsdevres.dxrInch = pme->_durInch;
		lsdevres.dyrInch = pme->_dvrInch;
	}

	g_plsc->SetDoc(TRUE, lsdevres.dyrInch == lsdevres.dypInch &&
					lsdevres.dxrInch == lsdevres.dxpInch, &lsdevres);

	DWORD cBreakRecOut;
	LSLINFO	 lslinfo;
	BREAKREC rgBreak[MAX_OBJ_DEPTH];

	//If the first character on the line is a wrapping OLE object, add it to the
	//the layout queue.
	{
		COleObject *pobj = pme->GetObjectFromCp(cp);
		if(pobj && pobj->FWrapTextAround())
			pme->AddObjectToQueue(pobj);
	}

	LONG dulLayout = pme->_dulLayout;

	if(!pdp->GetWordWrap())
	{
		dulLayout = pme->DUtoLU(pdp->GetDupView());
		const LONG *pl = pme->GetPF()->GetTabs();
		if(pl && GetTabPos(*pl) > dulLayout)// Fix for Access big TAB 7963
			dulLayout *= 4;					// dulLayout has to be larger
	}										//  than TAB
	
	dulLayout = max(dulLayout, 0);

	LSERR lserr = g_plsc->CreateLine(cp, dulLayout, NULL, 0, MAX_OBJ_DEPTH, rgBreak,
						 &cBreakRecOut, &lslinfo, &_plsline);

	//Line Services doesn't put the autonumbering dimensions into the line,
	//so we have to do it ourselves.
	lslinfo.dvpAscent = max(lslinfo.dvpAscent, lslinfo.dvpAscentAutoNumber);
	lslinfo.dvpDescent = max(lslinfo.dvpDescent, lslinfo.dvpDescentAutoNumber);

	pme->SetUseTargetDevice(FALSE);

	lslinfo.cpLim = GetCpReFromCpLs(lslinfo.cpLim);

	if (lserr != lserrNone)
	{
		AssertSz(lserr == lserrOutOfMemory, "Line format failed for invalid reason");
		pme->GetPed()->GetCallMgr()->SetOutOfMemory();
		return FALSE;
	}

	if(!pme->IsRenderer())
	{
		// Save some LineServices results in the measurer's CLine
		pme->_li._cch = lslinfo.cpLim - cp;
		AssertSz(pme->_li._cch > 0,	"no cps on line");

		LONG upStart, dupWidth;
		// Query for line width and indent.
		QueryLineInfo(lslinfo, &upStart, &dupWidth);
		pme->_li._upStart = upStart;
		pme->_li._dup = dupWidth;

		if(pme->IsRich())
		{
			pme->_li._dvpHeight  = lslinfo.dvpAscent + lslinfo.dvpDescent;
			pme->_li._dvpDescent = lslinfo.dvpDescent;
		}
		else
			pme->CheckLineHeight();				// Use default heights

		pme->_li._cchEOP = 0;

		pme->SetCp(lslinfo.cpLim);
		if(pme->_rpTX.IsAfterEOP())				// Line ends with an EOP
		{										// Store cch of EOP (1 or 2)
			pme->_rpTX.BackupCRLF(FALSE);
			UINT ch = pme->GetChar();
			if(ch == CR || pme->GetPed()->fUseCRLF() && ch == LF || ch == CELL)
				pme->_li._fHasEOP = TRUE;
			pme->_li._cchEOP = pme->_rpTX.AdvanceCRLF(FALSE);
		}
		if (lslinfo.cpLim > pme->GetTextLength() &&
			(!pme->IsRich() || pme->IsHidden()))
		{
			Assert(lslinfo.cpLim == pme->GetTextLength() + 1);
			pme->_li._cch--;
		}
		else
			pme->AdjustLineHeight();

		pme->UpdateWrapState(pme->_li._dvpHeight, pme->_li._dvpDescent);
	}

	//Setup pliTarget if caller requests it
	if (pliTarget)
	{
		CLine liSave = pme->_li;
		pme->_li._dvpHeight = max(lslinfo.dvrAscent, lslinfo.dvrAscentAutoNumber) +
							max(lslinfo.dvrDescent, lslinfo.dvrDescentAutoNumber);
		pme->_li._dvpDescent = lslinfo.dvrDescent;
		pme->SetUseTargetDevice(TRUE);
		pme->AdjustLineHeight();
		pme->SetUseTargetDevice(FALSE);
		*pliTarget = pme->_li;
		pme->_li = liSave;
	}
	return TRUE;
}

/*
 * 	COls::RenderLine(&li, fLastLine)
 *
 *	@mfunc
 *		Wrapper for LsDisplayLine
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 */
BOOL COls::RenderLine(
	CLine &	li,				//@parm Line to render
	BOOL	fLastLine)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "COls::RenderLine");

	LONG		cp = _pme->GetCp();
	CRenderer	*pre = GetRenderer();
	Assert(pre->_fRenderer);

	pre->SetNumber(li._bNumber);
	pre->NewLine(li);
	if(li._fCollapsed)				// Line is collapsed in Outline mode
	{
		pre->Move(li._cch);			// Bypass line
		return TRUE;				// Let dispml continue with next line
	}

	CreateOrGetLine();
	if(!_plsline)
		return FALSE;

	pre->SetCp(cp);						// Back to beginning of line
	pre->Check_pccs(FALSE);
	pre->_li._upStart = 0;
	Assert(pre->_fTarget == FALSE);

	LONG cpSelMin, cpSelMost;
	LONG dup, dvp;
	HDC hdcSave = pre->StartLine(li, fLastLine, cpSelMin, cpSelMost, dup, dvp);

	POINTUV pt = pre->GetCurPoint();			// Must follow offscreen setup
	POINT	ptStart;							//  since _ptCur, _rc change
	RECTUV  rcuv = pre->GetClipRect();

	pt.u += pre->XFromU(0);
	pt.v += li._dvpHeight - li._dvpDescent;
	memcpy(&ptStart, &pt, sizeof(ptStart));

	RECT rc;
	pre->GetPdp()->RectFromRectuv(rc, rcuv);
	LSERR lserr = LsDisplayLine(_plsline, &ptStart, pre->GetPdp()->IsMain() ? ETO_CLIPPED : 0, &rc);

	AssertSz(lserr == lserrNone, "COls::RenderLine: error in rendering line");

	pre->EndLine(hdcSave, dup, dvp);
	pre->SetCp(cp + li._cch);

	return lserr == lserrNone;
}

/*
 * 	COls::CreateOrGetLine()
 *
 *	@mfunc
 *		If _plsline is nonNull and _cp equals _pme->GetCp(), return.  Else
 *		create line with caching so that _plsline and _cp are correct for
 *		current line
 */
void COls::CreateOrGetLine()
{
	if(_plsline && _pme->GetCp() == _cp && _pme->_pdp == _pdp)
		return;

	MeasureLine(NULL);		// Define new _plsline
}

/*
 * 	COls::MeasureText(cch, taMode, pdispdim)
 *
 *	@mfunc
 *		Gets x offset to cp given by CMeasurer _pme + cch chars along with
 *		display dimensions.
 *
 *	@rdesc
 *		xwidth measured
 */
LONG COls::MeasureText(
	LONG	 cch,			//(IN): Max cch to measure
	UINT	 taMode,		//(IN): requested coordinate
	CDispDim *pdispdim)		//(OUT): display dimensions
{
	CMeasurer *	pme = _pme;				
	LONG		cp = pme->GetCp() + cch;	// Enter with me at start of line
	POINT		pt;							// Point at cp in client coords
	BOOL		fAtLogicalRightEdge = FALSE;

	CreateOrGetLine();
	if(!_plsline)
		return 0;
	Assert(pme->_fTarget == FALSE);

	// Query point from cp
	DWORD		cActualDepth;
	LSQSUBINFO	lsqSubInfo[MAX_OBJ_DEPTH];
	LSTEXTCELL	lsTextCell;

    memset(&lsTextCell, 0, sizeof(lsTextCell));

	LsQueryLineCpPpoint(_plsline, GetCpLsFromCpRe(cp), MAX_OBJ_DEPTH, &lsqSubInfo[0],
									  &cActualDepth, &lsTextCell);

	pdispdim->lstflow = lsqSubInfo[cActualDepth - 1].lstflowSubline;
	pdispdim->dup = lsTextCell.dupCell;

	LSTFLOW	 lstflowLine = lsqSubInfo[0].lstflowSubline;
	POINT ptStart = {pme->XFromU(0), pme->_li._dvpHeight - pme->_li._dvpDescent};

	POINTUV ptuv = lsTextCell.pointUvStartCell;

	if(taMode & (TA_STARTOFLINE | TA_ENDOFLINE) && cActualDepth > 1)
	{
		ptuv = lsqSubInfo[0].pointUvStartRun;
		if(taMode & TA_ENDOFLINE)
			ptuv.u += lsqSubInfo[0].dupRun;
	}

	//If they ask for position inside ligature or at lim of line, give right edge of cell
	else if (cp > GetCpReFromCpLs(lsTextCell.cpStartCell))
	{
		fAtLogicalRightEdge = TRUE;
		if (lstflowLine != pdispdim->lstflow)
			ptuv.u -= lsTextCell.dupCell;
		else
			ptuv.u += lsTextCell.dupCell;
	}

	LsPointXYFromPointUV(&ptStart, lstflowLine, &ptuv, &pt);

	if (pdispdim->lstflow == lstflowWS && !(taMode & (TA_LOGICAL | TA_STARTOFLINE)))
	{
		if (fAtLogicalRightEdge)
			return pt.x;
		else
			pt.x -= pdispdim->dup - 1;
	}

	if (fAtLogicalRightEdge)
		pdispdim->dup = 0;

	return pt.x;
}

/*
 * 	COls::CchFromUp(pt, pdispdim, pcpActual)
 *
 *	@mfunc
 *		Moves _pme to pt.x. Calls LsQueryLinePointPcp()
 */
void COls::CchFromUp(
	POINTUV pt,			//@parm Point to find cch for in line
	CDispDim *pdispdim,	//@parm dimensions of object
	LONG	*pcpActual) //@parm CP point
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "COls::CchFromUp");

	// Make point relative to LS coordinate system - (0,0) in LS is at the
	// baseline of the line.
	POINTUV ptuv = {_pme->UFromX(pt.u), -pt.v + _pme->_li._dvpHeight - _pme->_li._dvpDescent};

	LONG cpStart = _pme->GetCp();

	CreateOrGetLine();
	if(!_plsline)
		return;
	Assert(_pme->_fTarget == FALSE);

	DWORD		cActualDepth;
	LSQSUBINFO	lsqSubInfo[MAX_OBJ_DEPTH];
	LSTEXTCELL	lsTextCell;

	memset(&lsTextCell, 0, sizeof(lsTextCell));

	LsQueryLinePointPcp(_plsline, &ptuv, MAX_OBJ_DEPTH,	&lsqSubInfo[0], &cActualDepth, &lsTextCell);

	if (cActualDepth == 0) //If we got back empty textcell, let's just query cp explicitly to get information
	{
		LsQueryLineCpPpoint(_plsline, cpStart, MAX_OBJ_DEPTH, &lsqSubInfo[0], &cActualDepth, &lsTextCell);
		Assert(cActualDepth != 0);
	}

	pdispdim->dup = lsTextCell.dupCell;
	pdispdim->lstflow = lsqSubInfo[cActualDepth - 1].lstflowSubline;

    LONG cp = GetCpReFromCpLs(lsTextCell.cpStartCell);
	// The queries above can fail in BiDi hidden text. Would be best to suppress
	// BiDi itemization in hidden text, but for now, here's a simple patch
	if(!cp)
		cp = cpStart;
	Assert(cp >= cpStart);
	*pcpActual = cp;

	POINTUV ptuvCell;
	//Convert the hit-test point from u,v of line to u,v of cell
	LsPointUV2FromPointUV1(lsqSubInfo[0].lstflowSubline, &lsTextCell.pointUvStartCell, &ptuv,
		lsqSubInfo[cActualDepth - 1].lstflowSubline, &ptuvCell);

	_pme->SetCp(cp);
	if (ptuvCell.u > lsTextCell.dupCell/2 ||
		ptuvCell.u > W32->GetDupSystemFont()/2 && _pme->GetChar() == WCH_EMBEDDING)
	{
		cp += lsTextCell.cpEndCell - lsTextCell.cpStartCell + 1;
	}

#if !defined(NOCOMPLEXSCRIPTS)
	if (_pme->GetPed()->_pbrk)
	{
		// If text breaker is up, verify cluster before placing the caret
		CTxtBreaker* pbrk = _pme->GetPed()->_pbrk;
		LONG		 cpEnd = _pme->GetPed()->GetTextLength();
		while (cp < cpEnd && !pbrk->CanBreakCp(BRK_CLUSTER, cp))
			cp++;
	}
#endif

	_pme->_li._cch = cp - _cp;
	Assert(_pme->_li._cch >= 0);
	_pme->SetCp(cp);
}

/*
 * 	COls::DestroyLine(pdp)
 *
 *	@mfunc
 *		Destroys any line data structures.
 */
void COls::DestroyLine(CDisplay *pdp)
{
	CLock lock;
	if (pdp && pdp != _pdp)
		return;

	if(_plsline)
	{
		g_plsc->DestroyLine(_plsline);
		_plsline = NULL;
	}
	if (_rgcp.Count())
		_rgcp.Clear(AF_KEEPMEM);

	int cchunk = _rglsrunChunk.Count();
	for (int ichunk = 0; ichunk < cchunk; ichunk++)
		_rglsrunChunk.Elem(ichunk)->_cel = 0;
}

/*
 * 	LimitChunk(pch, &cchChunk, f10Mode)
 *
 *	@func
 *		Return object ID at *pch and shorten cchChunk to 1 if object isn't
 *		text and to the count of text chars up to a nontext object if one
 *		occurs within cchChunk and within the current paragraph.
 *
 *	@rdesc
 *		Object ID at *pch
 */
DWORD LimitChunk(
	const WCHAR *pch,
	LONG &		 cchChunk,
	BOOL		 f10Mode)
{
	for(LONG i = 0; i < cchChunk && *pch != CR; i++, pch++)
	{
		switch(*pch)
		{
		case WCH_EMBEDDING:
			if(i == 0)
			{
				cchChunk = 1;
				return OBJID_OLE;		// Entered at an OLE object
			}
			cchChunk = i;				// Will break before
		break;

		case EURO:
			if (i == 0)
			{
				for(; i < cchChunk && *pch == EURO; i++)
					pch++;
			}
			cchChunk = i;
		break;

		case FF:
			if(f10Mode)					// RichEdit 1.0 treats FFs as
				continue;				//  ordinary characters

		case CELL:
			cchChunk = i;				// Will break before
		break;
		}
	}

	return idObjTextChp;
}

/*
 * 	COls::SetLsChp(dwObjId, plsrun, plsChp)
 *
 *	@mfunc
 *		Helper function that initializes an LS chp from RE CCharFormat
 *
 *	@rdesc
 *		TRUE iff IsHidden()
 */
BOOL COls::SetLsChp(
	DWORD		dwObjId,	//(IN): Object id
	PLSRUN		plsrun,		//(IN): Current Run
	PLSCHP		plsChp)		//(OUT): LS chp
{
	ZeroMemory(plsChp, sizeof(*plsChp));
	plsChp->idObj = (WORD)dwObjId;

#ifndef NOCOMPLEXSCRIPTS
	if (_pme->GetPed()->IsComplexScript() && plsrun->_a.eScript && !plsrun->IsBullet())
	{
		CUniscribe*		pusp = _pme->Getusp();
		Assert (pusp);
		const SCRIPT_PROPERTIES *psp = pusp->GeteProp(plsrun->_a.eScript);

		if (psp->fComplex || plsrun->_a.fRTL ||
			psp->fNumeric && W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
		{
			// 1. Complex script
			// 2. RTL (internal direction) run (handle mirror glyph i.e.'?')
			// 3. Numeric run and substitution mode is either Native or Context

			plsChp->fGlyphBased	= TRUE;
		}
	}
#endif

	const CCharFormat *pCF = plsrun->_pCF;
	DWORD dwEffects = pCF->_dwEffects;
	const CDisplay *pdp = _pme->_pdp;
	HDC				hdc = pdp->GetDC();

	if((dwEffects & (CFE_UNDERLINE | CFE_LINK | CFE_REVISED)) ||
		GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY && GetTmpUnderline(pCF->_sTmpDisplayAttrIdx))
		plsChp->fUnderline = TRUE;
	pdp->ReleaseDC(hdc);

	if(dwEffects & CFE_STRIKEOUT && !plsrun->IsBullet())
		plsChp->fStrike = TRUE;

	if (pCF->_yOffset || dwEffects & (CFE_SUPERSCRIPT | CFE_SUBSCRIPT))
	{
		_pme->SetUseTargetDevice(FALSE);
		CCcs *pccs = _pme->Check_pccs(plsrun->IsBullet());
		LONG yOffset, yAdjust;
		pccs->GetOffset(pCF, _pme->_dvpInch, &yOffset, &yAdjust);

		plsChp->dvpPos += yOffset + yAdjust;
	}

	if (pCF->CanKern() && !plsChp->fGlyphBased)
	{
		CKernCache *pkc = fc().GetKernCache(pCF->_iFont, pCF->_wWeight, pCF->_dwEffects & CFE_ITALIC);
		CCcs *pccs = _pme->Check_pccs(plsrun->IsBullet());
		if (pkc && pkc->FInit(pccs->_hfont))
		{
			plsChp->fApplyKern = TRUE;
			plsChp->dcpMaxContext = max(plsChp->dcpMaxContext, 2);
		}
	}

	//If its an OLE object, but the Object doesn't exist yet, then hide it
	if (dwObjId == OBJID_OLE)
	{
		COleObject *pobj = _pme->GetObjectFromCp(_pme->GetCp());
		if (!pobj)
			return TRUE; //FUTURE (keithcu) Remove the need for this.

		if (pobj->FWrapTextAround())
		{
			_pme->AddObjectToQueue(pobj);
			return TRUE;
		}
	}
	return dwEffects & CFE_HIDDEN;
}

/*
 *	COls::FetchAnmRun(cp, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun)
 *
 *	@mfunc
 *		 LineServices fetch bullets/numbering callback
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI COls::FetchAnmRun(
	LSCP	 cp,		//@parm [IN]: RE cp
	LPCWSTR *plpwchRun, //@parm [OUT]: Run of characters
	DWORD *	 pcchRun, 	//@parm [OUT]: Count of characters in run
	BOOL *	 pfHidden, 	//@parm [OUT]: fHidden run?
	PLSCHP	 plsChp, 	//@parm [OUT]: Char properties of run
	PLSRUN * pplsrun)	//@parm [OUT]: Abstract representation of run properties
{
	if (cp == cpFirstAnm && _pme->Get_pPF()->IsRtl())
	{
		ZeroMemory(plsChp, sizeof(*plsChp));
		plsChp->idObj = OBJID_REVERSE;
		*pfHidden	= 0; *pcchRun = 1;
		*pplsrun	= GetPlsrun(_pme->GetCp(), &_CFBullet, TRUE);
		*plpwchRun	= &_szAnm[0];
		return lserrNone;
	}

	*plpwchRun = &_szAnm[cp - cpFirstAnm];
	*pcchRun = _cchAnm - (cp - cpFirstAnm);	
	*pplsrun  = GetPlsrun(_pme->GetCp(), &_CFBullet, TRUE);
	SetLsChp(idObjTextChp, *pplsrun, plsChp);
	*pfHidden = FALSE;

	if (!_pme->GetNumber())
		plsChp->fUnderline = FALSE;

	return lserrNone;	
}

/*
 *	OlsFetchRun(pols, cpLs, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun)
 *
 *	@func
 *		 LineServices fetch-run callback
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchRun(
	POLS	 pols,		//@parm [IN]: COls *
	LSCP	 cpLs,		//@parm [IN]: LS cp
	LPCWSTR *plpwchRun, //@parm [OUT]: Run of characters
	DWORD *	 pcchRun, 	//@parm [OUT]: Count of characters in run
	BOOL *	 pfHidden, 	//@parm [OUT]: Hidden run?
	PLSCHP	 plsChp, 	//@parm [OUT]: Char properties of run
	PLSRUN * pplsrun)	//@parm [OUT]: Abstract representation of run properties
{
	if(cpLs < 0)
		return pols->FetchAnmRun(cpLs, plpwchRun, pcchRun, pfHidden, plsChp, pplsrun);

	CMeasurer 	*pme = pols->GetMeasurer();
	CTxtEdit 	*ped = pme->GetPed();
	WCHAR		chPassword = pme->GetPasswordChar();
	LONG		cpAccelerator = ped->GetCpAccelerator();
	BOOL		fAccelerator = FALSE;
	BOOL		f10Mode = ped->Get10Mode();

	if (cpLs == pols->_cp)
	{
		// If we are formatting (or re-formatting) the line, cleanup
		if (pols->_rgcp.Count())
			pols->_rgcp.Clear(AF_KEEPMEM);
		pols->_cEmit = 0;
	}
	long cpRe = pols->GetCpReFromCpLs(cpLs);


	pme->SetCp(cpRe);						// Start fetching at given cp

#ifndef NOCOMPLEXSCRIPTS
	BOOL		fFetchBraces = ped->IsBiDi() && g_pusp && g_pusp->IsValid() &&
							!ped->_fItemizePending && ped->GetAdjustedTextLength();
	BOOL		fStart = FALSE;

	if (fFetchBraces && pme->_rpCF.IsValid())
	{
		// Consider emitting braces only at the run boundary or start of a fetched line
		if (cpRe == pols->_cp || !pme->GetIchRunCF() || !pme->GetCchLeftRunCF())
		{
			SHORT	cBrClose, cBrOpen;
			BYTE	bBaseLevel = pme->IsParaRTL() ? 1 : 0;
			BYTE	bLevel = bBaseLevel;
			BYTE	bLevelPrev = bBaseLevel;			// Assume base level
	
			if (cpRe < ped->GetTextLength())
			{
				CBiDiLevel level;

				bLevel = pme->_rpCF.GetLevel(&level);	// Got level of current run
				fStart = level._fStart;
			}
	
			if (cpRe > pols->_cp && pme->Move(-1))
			{
				if (pme->_rpPF.SameLevel(bBaseLevel))	// Preceding run may be hidden
					bLevelPrev = pme->_rpCF.GetLevel();	// Got level of preceding run
				pme->Move(1);							// Resume position
			}
	
			cBrOpen = cBrClose = bLevel - bLevelPrev;
	
			if (fStart)									// Start embedding at current run
				cBrClose = bBaseLevel - bLevelPrev;		// This means we must close all braces of preceding run
	
			cBrClose = max(0, -cBrClose);

			if (cBrClose > 0 && pols->BracesBeforeCp(cpLs) < cBrClose)
			{
				// Emit close braces
				if (pols->_cEmit > 0)
				{
					EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, idObjTextChp, rgchObjectEnd);
					if (pols->AddBraceCp(cpLs))
						pols->_cEmit--;
#ifdef DEBUG_BRACE
					Tracef(TRCSEVNONE, "CLOSE(%d) cpLs %d: emitted %d", cBrClose, cpLs, pols->_cEmit);
#endif
					return lserrNone;
				}
				else
				{
					// We assert. You can click "Ignore All" with no hang.
					AssertSz(FALSE, "Prevent emitting close brace (no open counterpart)");
				}
			}
	
			if (fStart)									// start embedding at the current run
				cBrOpen = bLevel - bBaseLevel;			// we begin openning braces
	
			if (cBrOpen > 0 && pols->BracesBeforeCp(cpLs) < cBrOpen + cBrClose)
			{
				// Emit open braces
				EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, OBJID_REVERSE, L" ");
				if (pols->AddBraceCp(cpLs))
					pols->_cEmit++;
#ifdef DEBUG_BRACE
				Tracef(TRCSEVNONE, "OPEN(%d) cpLs %d: emitted %d", cBrOpen, cpLs, pols->_cEmit);
#endif
				return lserrNone;
			}
		}
	}
#endif

	// Done fetching braces.
	// Begin getting real data...


#ifdef DEBUG_BRACE
	Tracef(TRCSEVNONE, "cpLs %d: emitted %d", cpLs, pols->_cEmit);
#endif

	// Initialized chunk to count of characters in format run
	LONG	cchChunk = pme->GetCchLeftRunCF();
	DWORD	dwObjId	 = idObjTextChp;
	const CCharFormat *pCF = pme->GetCF();

	if(!pme->IsHidden())					// Run isn't hidden
	{
		LONG cch;
		WCHAR ch;

		*plpwchRun = pme->GetPch(cch);		// Get text in run
		if(cch && **plpwchRun == NOTACHAR)
		{
			(*plpwchRun)++;					// Bypass NOTACHAR
			cch--;
		}

		cchChunk = min(cchChunk, cch);		// Maybe less than cchChunk
		if (!pme->GetPdp()->IsMetafile())
			cchChunk = min(cchChunk, 255);  // Prevent us from having runs which are TOO long

		// Support khyphChangeAfter
		if (pols->_cp == cpRe && pme->GetIhyphPrev())
		{
			UINT khyph;
			CHyphCache *phc = ped->GetHyphCache();
			Assert(phc);
			phc->GetAt(pme->GetIhyphPrev(), khyph, ch);
			if (khyph == khyphChangeAfter)
			{
				pols->_rgchTemp[0] = ch;
				*plpwchRun = pols->_rgchTemp;
				cchChunk = 1;
			}
		}

		if (chPassword)
		{
			cchChunk = min(cchChunk, (int)ARRAY_SIZE(pols->_rgchTemp));
			for (int i = 0; i < cchChunk; i++)
			{
				ch = (*plpwchRun)[i];
				if(IN_RANGE(0xDC00, ch, 0xDFFF))
				{							// Surrogate trail word
					if(i)					// Truncate current run at
						cchChunk = i;		//  trail word
					else					// Make trail word a hidden
					{						//  single-char run
						*pplsrun = pols->GetPlsrun(cpRe, pCF, FALSE);
						pols->SetLsChp(dwObjId, *pplsrun, plsChp);
						*pfHidden = TRUE;
						*pcchRun = 1;
						return lserrNone;
					}
				}
				else
					pols->_rgchTemp[i] = IsEOP(ch) ? ch : chPassword;
			}
			*plpwchRun = pols->_rgchTemp;
		}

		if(cpAccelerator != -1)
		{
			LONG cpCur = pme->GetCp();		// Get current cp

			// Does accelerator character fall in this chunk?
			if (cpCur < cpAccelerator &&
				cpCur + cchChunk > cpAccelerator)
			{
				// Yes. Reduce chunk to char just before accelerator
				cchChunk = cpAccelerator - cpCur;
			}
			// Is this character the accelerator?
			else if(cpCur == cpAccelerator)
			{							// Set chunk size to 1 since only
				cchChunk = 1;			//  want to output underlined char
				fAccelerator = TRUE;	// Tell downstream routines that
										//  we're handling accelerator
			}
		}
		if(pCF->_dwEffects & CFE_ALLCAPS)
		{
			cchChunk = min(cchChunk, (int)ARRAY_SIZE(pols->_rgchTemp));
			memcpy(pols->_rgchTemp, *plpwchRun, cchChunk * sizeof(WCHAR));
			CharUpperBuff(pols->_rgchTemp, cchChunk);
			*plpwchRun = pols->_rgchTemp;
		}

		//Line Services handles page breaks in a weird way, so lets just convert to a CR.
		if (*plpwchRun && (*(*plpwchRun) == FF && !f10Mode || *(*plpwchRun) == CELL))
		{
			pols->_szAnm[0] = CR;
			*plpwchRun = pols->_szAnm;
			cchChunk = 1;
		}

		AssertSz(cpRe < ped->GetTextLength() || !ped->IsRich(),	"0-length run at end of control");
		AssertSz(cch || !ped->IsRich(),	"0-length run at end of control");

		// Set run size appropriately for any objects that are in run
		dwObjId = LimitChunk(*plpwchRun, cchChunk, f10Mode);

		// Get regular highlighted positions
		LONG cpSelMin, cpSelMost;
		ped->GetSelRangeForRender(&cpSelMin, &cpSelMost);

		if(cpSelMin != cpSelMost)
		{
			if(cpRe >= cpSelMin)
			{
				if(cpRe < cpSelMost)
				{
					// Current text falls inside selection
					cch = cpSelMost - cpRe;
					cchChunk = min(cchChunk, cch);
				}
			}
			else if(cpRe + cchChunk >= cpSelMin)
			{
				// cp < cpSelMin - run starts outside of selection.
				// Limit text to start of selection.
				cchChunk = cpSelMin - cpRe;
			}
		}
	}

	*pplsrun  = pols->GetPlsrun(cpRe, pCF, FALSE);
	*pfHidden = pols->SetLsChp(dwObjId, *pplsrun, plsChp);

	if (fAccelerator)
		plsChp->fUnderline = TRUE;

	if(!cchChunk)							// Happens in plain-text controls
	{										//  and if hidden text to end of story
		if (!ped->IsRich() && pols->_cEmit > 0)
		{
			EmitBrace(pols, plsChp, pfHidden, pcchRun, pplsrun, plpwchRun, idObjTextChp, rgchObjectEnd);
			TRACEWARNSZ("(plain)Auto-emit a close brace to make balance");
			if (pols->AddBraceCp(cpLs))
				pols->_cEmit--;
			return lserrNone;
		}
		cchChunk = 1;
		*plpwchRun = szCR;
		*pfHidden = FALSE;
#ifndef NOCOMPLEXSCRIPTS
		//Paragraph marks should not have any script state associated with them,
		//even if the pCF that point to does.
		ZeroMemory(&(*pplsrun)->_a, sizeof((*pplsrun)->_a));
#endif
	}
	*pcchRun = cchChunk;

	return lserrNone;
}

/*
 *	OlsGetAutoNumberInfo (pols, plskalAnm, plschpAnm, pplsrunAnm, pwchAdd, plschp, 
 *						  pplsrun, pfWord95Model, pduaSpaceAnm, pduaWidthAnm)
 *	@func
 *		LineServices fetch autonumbering info callback. Return info needed
 *		by LS for auto numbering. Get the chp/run for last char from auto
 *		number run. Always say we are Word95 model Anm and get rest of info
 *		from paragraph properties.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetAutoNumberInfo(
	POLS	 pols,			//(IN): Client context
	LSKALIGN *plskalAnm,	//(OUT):Justification
	PLSCHP   plschpAnm,
	PLSRUN   *pplsrunAnm,
	WCHAR *	 pwchAdd,		//(OUT):char to add (Nil is treated as none)
	PLSCHP	 plsChp,		//(OUT):chp for bridge character
	PLSRUN * pplsrun,		//(OUT):Run for bridge character
	BOOL *	 pfWord95Model,	//(OUT):Type of autonumber run
	long *	 pduaSpaceAnm,	//(OUT):Relevant iff fWord95Model
	long *	 pduaWidthAnm)	//(OUT):Relevant iff fWord95Model
{
	CMeasurer *pme = pols->GetMeasurer();
	const CParaFormat *pPF = pme->Get_pPF();

	*pplsrunAnm = *pplsrun = pols->GetPlsrun(pme->GetCp(), &pols->_CFBullet, TRUE);
	pols->SetLsChp(idObjTextChp, *pplsrun, plsChp);

	if (!pme->GetNumber())
		plsChp->fUnderline = FALSE;

	*plschpAnm		= *plsChp;
	*pwchAdd		= '\t';
	*pfWord95Model	= TRUE;
	*pduaSpaceAnm	= 0;
	*pduaWidthAnm	= pPF->_wNumberingTab ? pPF->_wNumberingTab : pPF->_dxOffset;

	LONG Alignment	= pPF->_wNumberingStyle & 3;
	*plskalAnm		= (LSKALIGN)(lskalLeft + Alignment);
	if(Alignment != tomAlignLeft)
	{
		if(Alignment == tomAlignRight)
		{
			*pduaSpaceAnm = *pduaWidthAnm;	// End at pPF->_dxStartIndent
			*pduaWidthAnm += pPF->_dxStartIndent;
		}
		else
		{
			Assert(Alignment == tomAlignCenter);
			*pduaWidthAnm *= 2;				// Center at pPF->dxStartIndent
		}
	}

	return lserrNone;
}

/*
 *	OlsGetNumericSeparators (pols, plsrun, pwchDecimal, pwchThousands)
 *
 *	@func
 *		Get numeric separators needed, e.g., for decimal tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetNumericSeparators(
	POLS	pols,			//(IN): pols
	PLSRUN	plsrun,			//(IN): Run (cp here)
	WCHAR *	pwchDecimal,	//(OUT): Decimal separator for this run
	WCHAR *	pwchThousands)	//(OUT): Thousands separator for this run
{
	LCID	lcid = plsrun->_pCF->_lcid;
	WCHAR	ch = TEXT('.');

	// This may need to be virtualized for Win95/CE...
	::GetLocaleInfo(lcid, LOCALE_SDECIMAL, &ch, 1);
	*pwchDecimal = ch;
	ch = TEXT(',');
	::GetLocaleInfo(lcid, LOCALE_STHOUSAND, &ch, 1);
	*pwchThousands = ch;

	return lserrNone;
}

/*
 *	OlsFetchPap (pols, cpLS, plspap)
 *
 *	@func
 *		Fetch paragraph properties
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchPap(
	POLS	pols,		//(IN): pols
	LSCP	cpLs, 		//(IN):  an arbitrary cp value inside paragraph
	PLSPAP	plspap)		//(OUT): Paragraph properties.
{
	CMeasurer *pme = pols->GetMeasurer();
	pme->SetCp(pols->_cp);
	LONG	dvpJunk;

	const CParaFormat *pPF = pme->Get_pPF();
	CTxtEdit *		   ped = pme->GetPed();

	// Default all results to 0
	ZeroMemory(plspap, sizeof(*plspap));

	//LS doesn't really care where the paragraph starts
	plspap->cpFirst = pols->_cp;

	if(plspap->cpFirst && !pme->fFirstInPara())	// Not first in para: say para
		plspap->cpFirst--;						//  starts one char earlier

	plspap->cpFirstContent = plspap->cpFirst;

	if (pPF->IsRtl())
		plspap->lstflow = lstflowWS;

	// Alignment
	plspap->lskal = (LSKALIGN) g_rgREtoTOMAlign[pPF->_bAlignment];

	if (pPF->IsRtl())
	{	//For Line Services, left means near and right means far.
		if (plspap->lskal == lskalLeft)
			plspap->lskal = lskalRight;
		else if (plspap->lskal == lskalRight)
			plspap->lskal = lskalLeft;
	}

	if (pPF->_bAlignment == PFA_FULL_INTERWORD)
	{
		plspap->lskal = lskalLeft;
		plspap->lskj = lskjFullInterWord;
	}

	//Enable hyphenation?
	if (ped->_pfnHyphenate && !(pPF->_wEffects & PFE_DONOTHYPHEN))
	{
		plspap->grpf |= fFmiDoHyphenation;
		plspap->duaHyphenationZone = ped->_dulHyphenateZone;
	}

	// Kind of EOP
	CTxtPtr tp(pme->_rpTX);
	LONG	results;

	tp.FindEOP(tomForward, &results);
	plspap->lskeop = (results & 3) == 2 ? lskeopEndPara12 : lskeopEndPara1;

	// Line breaking
	if (pPF->_bAlignment > PFA_FULL_INTERWORD || !ped->fUseSimpleLineBreak() ||
		!pme->GetPdp()->GetWordWrap())		// No word wrap
	{
		plspap->grpf |= fFmiApplyBreakingRules | fFmiTreatHyphenAsRegular;
	}


	LONG dul = pPF->_dxRightIndent;

	if (pme->IsMeasure())
	{
		COleObject *pobj = pme->FindFirstWrapObj(FALSE);
		if (pobj && pobj->GetCp() <= pols->_cp)
		{
			LONG dulRight;
			pobj->MeasureObj(1440, 1440, dulRight, dvpJunk, dvpJunk, 0, pme->GetTflow());

			dul = max(dul, dulRight);
			pme->_li._cObjectWrapRight = pme->CountQueueEntries(FALSE);
		}
	}
	else if (pme->_li._cObjectWrapRight)
	{
		LONG cpObj = pme->FindCpDraw(pme->GetCp() + 1, pme->_li._cObjectWrapRight, FALSE);
		COleObject *pobj = pme->GetObjectFromCp(cpObj);

		LONG dulRight;
		pobj->MeasureObj(1440, 1440, dulRight, dvpJunk, dvpJunk, 0, pme->GetTflow());
		dul = max(dul, dulRight);
	}

	plspap->uaRightBreak   = dul;
	plspap->uaRightJustify = dul;
	pme->_upRight		   = pme->LUtoDU(dul);

	if (!pme->_pdp->GetWordWrap())
		plspap->uaRightBreak = uLsInfiniteRM;

	if(ped->IsInOutlineView())
	{
		plspap->uaLeft	   = lDefaultTab/2 * (pPF->_bOutlineLevel + 1);
		plspap->duaIndent  = 0;
	}
	else
	{
		LONG dulPicture = 0;

		if (pme->IsMeasure())
		{
			COleObject *pobj = pme->FindFirstWrapObj(TRUE);
			if (pobj && pobj->GetCp() <= pols->_cp)
			{
				pobj->MeasureObj(1440, 1440, dulPicture, dvpJunk, dvpJunk, 0, pme->GetTflow());

				pme->_li._cObjectWrapLeft = pme->CountQueueEntries(TRUE);
			}
		}
		else if (pme->_li._cObjectWrapLeft)
		{
			LONG cpObj = pme->FindCpDraw(pme->GetCp() + 1, pme->_li._cObjectWrapLeft, TRUE);
			COleObject *pobj = pme->GetObjectFromCp(cpObj);
			if(pobj)
			pobj->MeasureObj(1440, 1440, dulPicture, dvpJunk, dvpJunk, 0, pme->GetTflow());
		}

		plspap->uaLeft	  = pPF->_dxStartIndent + pPF->_dxOffset;
		plspap->duaIndent = -pPF->_dxOffset;

		LONG Alignment = pPF->_wNumberingStyle & 3;
		if(pPF->_wNumbering && Alignment != tomAlignLeft)
		{
			// Move back by amount added to duaWidth in OlsGetAutoNumberInfo()
			plspap->duaIndent -= (Alignment == tomAlignRight) ? pPF->_dxStartIndent
							   : pPF->_wNumberingTab ? pPF->_wNumberingTab
							   : pPF->_dxOffset;
		}
		if (dulPicture)
		{
			plspap->uaLeft = max(plspap->uaLeft, dulPicture);
			// if hanging indent causes first line to overlap picture, shift it further
			if (plspap->uaLeft + plspap->duaIndent < dulPicture)
				plspap->duaIndent = dulPicture - plspap->uaLeft;
		}
	}

	if(!pPF->InTable() && plspap->uaLeft < 0)
		plspap->uaLeft = 0;

	// Is this a bulleted paragraph? - ignore bullets in a password
	if(pPF->_wNumbering && pme->fFirstInPara() && !pme->GetPasswordChar() &&
	   !pPF->IsNumberSuppressed())
	{
		CCcs *pccs = pme->GetCcsBullet(&pols->_CFBullet);
		if (pccs)
			pccs->Release();

		plspap->grpf |= fFmiAnm;
		WCHAR *pchAnm = pols->_szAnm;
		pols->_cchAnm = 0;

		if (pPF->IsRtl())				// Open character
			*pchAnm++ = ' ';
		
		//FUTURE (KeithCu) we turn off Indic digits if there is any Hebrew,
		//which should be refined to do a better job with worldwide documents.
		pols->_cchAnm += pPF->NumToStr(pchAnm, pme->GetNumber(),
			(pme->GetPed()->GetCharFlags() & FHEBREW) ? 0 : fIndicDigits);
		pchAnm += pols->_cchAnm;
		
		if (pPF->IsRtl())				// End character for reverser
		{
			*pchAnm++ = wchObjectEnd;
			pols->_cchAnm += 2;			// Alloc space for open and close
		}
		*pchAnm++ = ' ';				// Ensure a little extra space
		*pchAnm++ = wchObjectEnd;		// End character for Anm
		pols->_cchAnm += 2;
	}

	return lserrNone;
}

/*
 *	OlsFetchTabs(pols, LSCP cp, plstabs, pfHangingTab, pduaHangingTab, pwchHangingTabLeader)
 *
 *	@func
 *		Fetch tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFetchTabs(
	POLS	pols,					//(IN):	(COls *)
	LSCP	cp,						//(IN): Arbitrary cp value inside para
	PLSTABS plstabs,				//(OUT): Tabs array
	BOOL *	pfHangingTab,			//(OUT): There is hanging tab
	long *	pduaHangingTab,			//(OUT): dua of hanging tab
	WCHAR *	pwchHangingTabLeader)	//(OUT): Leader of hanging tab
{
	CMeasurer *pme = pols->GetMeasurer();

	const CParaFormat *pPF = pme->Get_pPF();
	const char rgchTabLeader[] = {0, '.', '-', '_', '_', '='};

	LONG		cTabCount = pPF->_bTabCount;
	LONG		i, iActual;
	LSTBD *		prgTab	  = pols->_rgTab;
	const LONG *prgxTabs  = pPF->GetTabs();

	Assert(cTabCount <= MAX_TAB_STOPS && (prgxTabs || !cTabCount));

	plstabs->duaIncrementalTab = pme->GetPed()->GetDefaultTab();

	*pwchHangingTabLeader = 0;
	*pduaHangingTab = pPF->_dxStartIndent + pPF->_dxOffset;
	*pfHangingTab = pPF->_dxOffset > 0;

	for(i = 0, iActual = 0; i < cTabCount; i++)
	{
		LONG tbAlign, tbLeader;
		pPF->GetTab(i, &prgTab[iActual].ua, &tbAlign, &tbLeader, prgxTabs);

		pme->SetUseTargetDevice(FALSE);
		if (prgTab[iActual].ua > pme->_dulLayout)
			break;

		if(tbAlign <= tomAlignDecimal)		// Don't include tomAlignBar
		{
			prgTab[iActual].lskt = (lsktab) tbAlign;
			prgTab[iActual].wchTabLeader = rgchTabLeader[tbLeader];
			iActual++;
		}
	}

	plstabs->pTab = prgTab;
	plstabs->iTabUserDefMac = iActual;
	return lserrNone;
}

/*
 *	OlsCheckParaBoundaries (pols, cpOld, cpNew, pfChanged)
 *
 *	@func
 *		Determine if para formatting between para containing cpOld and
 *		that containing cpNew are incompatible and shouldn't be formatted
 *		on the same line when connected by hidden text.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCheckParaBoundaries(
	POLS	pols,		//(IN): Interface object
	LONG	cpOld,		//(IN): cp in one paragraph
	LONG	cpNew,		//(IN): cp in another paragraph
	BOOL *	pfChanged)	//(OUT): "Dangerous" change between para properties
{
	// It's easier (and safer) to allow LS decide which para properties to take.
	// Else we have to close objects (BiDi, for instance) before hidden EOP.

	*pfChanged = fFalse;			// they're always compatible

	return lserrNone;
}
		
/*
 *	OlsGetRunCharWidths (pols, plrun, deviceID, lpwchRun, cwchRun, du,
 *						 kTFlow, prgDu, pduRun, plimDu)
 *	@func
 *		Get run character widths
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunCharWidths(
	POLS	  pols,			//(IN): Interface object
	PLSRUN	  plsrun,		//(IN): Run (cp here)
	enum lsdevice deviceID, //(IN): Preview, reference, or absolute
	LPCWSTR	  lpwchRun,		//(IN): Run of characters
	DWORD	  cwchRun, 		//(IN): Count of characters in run
	long	  du, 			//(IN): Available space for characters
	LSTFLOW	  kTFlow,		//(IN): Text direction and orientation
	int *	  prgDu,		//(OUT): Widths of characters
	long *	  pduRun,		//(OUT): Sum of widths in rgDx[0] to rgDu[limDx-1]
	long *	  plimDu)		//(OUT): Number of widths fetched
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);
	DWORD i = 0;
	LONG  dup, dupAdjust, duCalc = 0;
	BOOL  fGlyphRun = FALSE;
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

#ifndef NOCOMPLEXSCRIPTS
	if (pme->GetPed()->IsComplexScript() &&
		plsrun->_a.eScript && !plsrun->IsBullet())
	{
		const SCRIPT_PROPERTIES *psp = pme->Getusp()->GeteProp(plsrun->_a.eScript);
		if (psp->fComplex)
			fGlyphRun = TRUE;
	}
#endif

	dupAdjust = pme->LUtoDU(plsrun->_pCF->_sSpacing);
	for(;i < cwchRun; i++, lpwchRun++)
	{
		if (!fGlyphRun)
		{
			if (IsZerowidthCharacter(*lpwchRun))
				dup = 0;
			else
			{
				pccs->Include(*lpwchRun, dup);
				dup =  max(dup + dupAdjust, 1);
			}
		}
		else
		{
			dup = 0;
			if (!IsDiacriticOrKashida(*lpwchRun, 0))
				dup = pccs->_xAveCharWidth;
		}

		duCalc += dup;				// Keep running total of width
		*prgDu++ = dup;				// Store width in output array
		if(dup + duCalc > du)		// Width exceeds width available
		{
			i++;						// Count this char as processed
			break;
		}
	}
	*plimDu = i;						// Store total chars processed
	*pduRun = duCalc;					// Store output total width
	return lserrNone;
}

/*
 *	OlsGetRunTextMetrics (pols, plsrun, deviceID, kTFlow, plsTxMet)
 *
 *	@func
 *		Get run text metrics
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunTextMetrics(
	POLS	  pols,			//(IN): interface object
	PLSRUN	  plsrun,		//(IN): run (cp here)
	enum lsdevice deviceID, //(IN): presentation or reference
	LSTFLOW	  kTFlow,		//(IN): text direction and orientation
	PLSTXM	  plsTxMet)		//(OUT): Text metrics
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);

	// Make sure right font is set for run
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	LONG yFEAdjust = pccs->AdjustFEHeight(pme->FAdjustFELineHt());

	LONG yDescent = pccs->_yDescent + yFEAdjust;

	// Fill in metric structure
	plsTxMet->dvAscent			= pccs->_yHeight + (yFEAdjust << 1) - yDescent;
    plsTxMet->dvDescent			= yDescent;
    plsTxMet->dvMultiLineHeight = plsTxMet->dvAscent + yDescent;
    plsTxMet->fMonospaced		= pccs->_fFixPitchFont;

	if (plsrun->_pCF->_yOffset && pme->GetPF()->_bLineSpacingRule != tomLineSpaceExactly)
	{
		LONG yOffset, yAdjust;
		pccs->GetOffset(plsrun->_pCF, deviceID == lsdevReference ? pme->_dvrInch :
					    pme->_dvpInch, &yOffset, &yAdjust);

		if (yOffset < 0)
			plsTxMet->dvDescent -= yOffset;
		else
			plsTxMet->dvAscent += yOffset;
	}

	return lserrNone;
}

/*
 *	OlsGetRunUnderlineInfo (pols, plsrun, pcheights, kTFlow, plsStInfo)
 *
 *	@func
 *		Get run underline info
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunUnderlineInfo(
	POLS	  pols,			//(IN): Interface object
	PLSRUN	  plsrun,		//(IN): Run (cp here)
	PCHEIGHTS pcheights,	//(IN): Height of line
	LSTFLOW	  kTFlow,		//(IN): Text direction and orientation
	PLSULINFO plsUlInfo)	//(OUT): Underline information
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL	   fBullet = pols->SetRun(plsrun);
	const CDisplay *pdp = pme->GetPdp();
	HDC				hdc = pdp->GetDC();

	// Initialize output buffer
	ZeroMemory(plsUlInfo, sizeof(*plsUlInfo));
	//REVIEW KeithCu

	// Make sure right font is set for run
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	long dvpUlOffset = pccs->_dyULOffset;

	plsUlInfo->cNumberOfLines = 1;

	// Set underline type
	if (plsrun->_pCF->_dwEffects & CFE_LINK)
		plsUlInfo->kulbase = CFU_UNDERLINE;
	else if (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY && GetTmpUnderline(plsrun->_pCF->_sTmpDisplayAttrIdx))
		plsUlInfo->kulbase	= GetTmpUnderline(plsrun->_pCF->_sTmpDisplayAttrIdx);
	else if (plsrun->_pCF->_dwEffects & (CFE_UNDERLINE | CFE_REVISED))
		plsUlInfo->kulbase	= plsrun->_pCF->_bUnderlineType;
	else
	{
		Assert(pme->GetPed()->GetCpAccelerator() == plsrun->_cp);
		plsUlInfo->kulbase = CFU_UNDERLINE;
	}
	pdp->ReleaseDC(hdc);

	LONG yDescent = pccs->_yDescent + pccs->AdjustFEHeight(pme->FAdjustFELineHt());

	// Some fonts report invalid offset so we fix it up here
	if(dvpUlOffset >= yDescent)
		dvpUlOffset = yDescent - 1;

	plsUlInfo->dvpFirstUnderlineOffset = dvpUlOffset;
	plsUlInfo->dvpFirstUnderlineSize   = pccs->_dyULWidth;

	return lserrNone;
}

/*
 *	OlsGetRunStrikethroughInfo (pols, plsrun, pcheights, kTFlow, plsStInfo)
 *
 *	@func
 *		Get run strikethrough info
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunStrikethroughInfo(
	POLS	  pols,			//(IN): interface object
	PLSRUN	  plsrun,		//(IN): run
	PCHEIGHTS pcheights,	//(IN): height of line
	LSTFLOW	  kTFlow,		//(IN): text direction and orientation
	PLSSTINFO plsStInfo)	//(OUT): Strikethrough information
{
	CMeasurer *pme = pols->GetMeasurer();
	BOOL fBullet = pols->SetRun(plsrun);

	AssertSz(plsrun->_pCF->_dwEffects & CFE_STRIKEOUT, "no strikeout");

	// Make sure right font is set for run
	CCcs *pccs = pme->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	// Default number of lines
	plsStInfo->cNumberOfLines = 1;
	plsStInfo->dvpLowerStrikethroughOffset = -pccs->_dySOOffset;
	plsStInfo->dvpLowerStrikethroughSize   = pccs->_dySOWidth;

	return lserrNone;
}

/*	OlsDrawUnderline (pols, plsrun, kUlbase, pptStart, dupUL, dvpUL,
 *					  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw underline
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawUnderline(
	POLS		pols,		//(IN): interface object
	PLSRUN		plsrun,		//(IN): run (cp) to use for underlining
	UINT		kUlbase,	//(IN): underline kind
	const POINT *pptStart,	//(IN): starting position (top left)
	DWORD		dupUL,		//(IN): underline width
	DWORD		dvpUL,		//(IN): underline thickness
	LSTFLOW		lstflow,	//(IN): text direction and orientation
	UINT		kDisp,		//(IN): display mode - opaque, transparent
	const RECT *prcClip)	//(IN): clipping rectangle
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pols->SetRun(plsrun);
	pre->Check_pccs();

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	if (pre->fDisplayDC() && GetTmpUnderline(plsrun->_pCF->_sTmpDisplayAttrIdx))
	{
		COLORREF	crTmpUnderline;

		GetTmpUnderlineColor(plsrun->_pCF->_sTmpDisplayAttrIdx, crTmpUnderline);
		pre->SetupUnderline(kUlbase, 0, crTmpUnderline);
	}
	else
		pre->SetupUnderline(kUlbase, plsrun->_pCF->_bUnderlineColor);

	pre->RenderUnderline(lstflow == lstflowWS ? pptStart->x - dupUL - 1:
						 pptStart->x, pptStart->y, dupUL, dvpUL);

	return lserrNone;
}

/*
 *	OlsDrawStrikethrough (pols, plsrun, kStbase, pptStart, dupSt, dvpSt,
 *						  kTFlow, kDisp, prcClip)
 *	@func
 *		Draw strikethrough
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawStrikethrough(
	POLS		pols,		//(IN): Interface object
	PLSRUN		plsrun,		//(IN): run (cp) for strikethrough
	UINT		kStbase,	//(IN): strikethrough kind
	const POINT *pptStart,	//(IN): starting position (top left)
	DWORD		dupSt,		//(IN): strikethrough width
	DWORD		dvpSt,		//(IN): strikethrough thickness
	LSTFLOW		lstflow,	//(IN): text direction and orientation
	UINT		kDisp,		//(IN): display mode - opaque, transparent
	const RECT *prcClip)	//(IN): clipping rectangle
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pols->SetRun(plsrun);
	pre->SetSelected(plsrun->IsSelected());

	pre->RenderStrikeOut(lstflow == lstflowWS ? pptStart->x - dupSt - 1:
						 pptStart->x, pptStart->y, dupSt, dvpSt);

	return lserrNone;
}


/*
 *	OlsFInterruptUnderline(pols, plsrunFirst, cpLastFirst, plsrunSecond,
 *						   cpStartSecond, pfInterruptUnderline)
 *	@func
 *		Says whether client wants to interrupt drawing of underline
 *		between the first and second runs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFInterruptUnderline(
	POLS   pols,				//(IN): Client context
	PLSRUN plsrunFirst,			//(IN): Run pointer for previous run
	LSCP   cpLastFirst,			//(IN): cp of last character of previous run
	PLSRUN plsrunSecond,		//(IN): Run pointer for current run
	LSCP   cpStartSecond,		//(IN): cp of first character of current run
	BOOL * pfInterruptUnderline)//(OUT): Interrupt underline between runs?
{
	CRenderer *pre = pols->GetRenderer();
	Assert(pre->IsRenderer());

	pre->SetSelected(FALSE); //Selection is handled below

	COLORREF cr = pre->GetTextColor(plsrunFirst->_pCF);

	// Interrupt underline if run text colors differ
	*pfInterruptUnderline = cr != pre->GetTextColor(plsrunSecond->_pCF) ||
							plsrunFirst->IsSelected() != plsrunSecond->IsSelected();
	return lserrNone;
}

/*
 *	OlsDrawTextRun (pols, plsrun, fStrikeoutOkay, fUnderlineOkay, ppt, pwchRun,
 *					rgDupRun, cwchRun, lstflow, kDisp, pptRun, pheightsPres,
 *					dupRun, dupUlLimRun, prcClip)
 *	@func
 *		Draw text run
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsDrawTextRun(
	POLS		pols,			//(IN): Interface object
	PLSRUN		plsrun,			//(IN): Run (cp) to use for text
	BOOL		fStrikeoutOkay, //(IN): TRUE <==> allow strikeout
	BOOL		fUnderlineOkay, //(IN): TRUE <==> allow underlining
	const POINT *ppt, 			//(IN): Starting position
	LPCWSTR		pwchRun, 		//(IN): Run of characters
	const int *	rgDupRun, 		//(IN): Character widths
	DWORD		cwchRun, 		//(IN): Count of chars in run
	LSTFLOW		lstflow,		//(IN): Text direction and orientation
	UINT		kDisp,			//(IN): Display mode - opaque, transparent
	const POINT *pptRun,		//(IN): Starting point of run
	PCHEIGHTS	pheightsPres, 	//(IN): Presentation heights for run
	long		dupRun, 		//(IN): Presentation width for run
	long		dupUlLimRun,	//(IN): Underlining limit
	const RECT *prcClip)		//(IN): Clipping rectangle
{
	CRenderer  *pre = pols->GetRenderer();
	RECT		rc = *prcClip;
	Assert(pre->IsRenderer());

	// Set up drawing point and options
	BOOL fBullet = pols->SetRun(plsrun);
	CCcs *pccs = pre->Check_pccs(fBullet);
	if(!pccs)
		return lserrOutOfMemory;

	// v needs to be moved from baseline to top of character
	POINTUV pt = {ppt->x, ppt->y - (pccs->_yHeight - pccs->_yDescent)};

	if (lstflow == lstflowWS)
		pt.u -= dupRun - 1;

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	if(!fBullet && pre->_fBackgroundColor)
	{
		if (pre->_fEraseOnFirstDraw)
			pre->EraseLine();

		kDisp = ETO_OPAQUE | ETO_CLIPPED;
		SetBkMode(pre->_hdc, OPAQUE);

		POINTUV ptCur = pre->GetCurPoint();
		ptCur.u = pt.u;
		pre->SetCurPoint(ptCur);
		pre->SetClipLeftRight(dupRun);
		RECTUV rcuv = pre->GetClipRect();
		pre->GetPdp()->RectFromRectuv(rc, rcuv);
	}
	else if (!pre->_fEraseOnFirstDraw && cwchRun == 1 && pwchRun[0] == ' ')
		return lserrNone; //Don't waste time drawing a space.

	if (pre->_fEraseOnFirstDraw)
	{
		SetBkMode(pre->_hdc, OPAQUE);
		pre->GetPdp()->RectFromRectuv(rc, pre->_rcErase);
		kDisp |= ETO_OPAQUE;
	}

	pre->RenderExtTextOut(pt, kDisp, &rc, pwchRun, cwchRun, rgDupRun);

	if (pre->_fEraseOnFirstDraw || !fBullet && pre->_fBackgroundColor)
	{
		SetBkMode(pre->_hdc, TRANSPARENT);
		pre->_fEraseOnFirstDraw = FALSE;
	}

	return lserrNone;
}

/*
 *	GetBreakingClasses (pols, plsrun, cpLS, ch, pbrkclsBefore, pbrkclsAfter)
 *
 *	@func
 *		Line services calls this callback for each run, to obtain the
 *		breaking classes (line breaking behaviors) for each character
 *
 *	    For Quill and RichEdit, the breaking class of a character is
 *		independent of whether it occurs Before or After a break opportunity.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetBreakingClasses(
	POLS	pols,			//(IN): Interface object
	PLSRUN	plsrun,			//(IN): Run (cp) to use for text
	LSCP	cpLs,				//(IN): cp of the character
	WCHAR	ch, 			//(IN): Char to return breaking classes for
	BRKCLS *pbrkclsBefore,	//(OUT): Breaking class if ch is lead char in pair
	BRKCLS *pbrkclsAfter)	//(OUT): Breaking class if ch is trail char in pair
{
	// Get line breaking class and report it twice
	LCID		lcid = 0;
	CMeasurer *	pme = pols->GetMeasurer();
	if(W32->OnWin9x())
		lcid = pme->GetCF()->_lcid;

#ifndef NOCOMPLEXSCRIPTS
	long 		cpRe = pols->GetCpReFromCpLs(cpLs);
	CTxtBreaker *pbrk = pme->GetPed()->_pbrk;
	*pbrkclsBefore = *pbrkclsAfter = (pbrk && pbrk->CanBreakCp(BRK_WORD, cpRe)) ?
									brkclsOpen :
									GetKinsokuClass(ch, 0xFFFF, lcid);
#else
	*pbrkclsBefore = *pbrkclsAfter = GetKinsokuClass(ch, 0xFFFF, lcid);
#endif
	return lserrNone;
}

/*
 *	OlsFTruncateBefore (pols, plsrunCur, cpCur, wchCur, durCur, cpPrev, wchPrev,
 *						durPrev, durCut, pfTruncateBefore)
 *	@func
 *		Line services support function. This should always return
 *		FALSE for best performance
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFTruncateBefore(
	POLS	pols,				// (IN): Client context
	PLSRUN  plsrunCur,			// (IN): PLSRUN of cp
	LSCP	cpCur,				// (IN): cp of truncation char
	WCHAR	wchCur,				// (IN): Truncation character
	long	durCur,				// (IN): Width of truncation char
	PLSRUN	plsrunPrev,			// (IN): PLSRUN of cpPrev
	LSCP	cpPrev,				// (IN): cp of truncation char
	WCHAR	wchPrev,			// (IN): Truncation character
	long	durPrev,			// (IN): Width of truncation character
	long	durCut,				// (IN): Width from RM until end of current char
	BOOL *	pfTruncateBefore)	// (OUT): Truncation point is before this char
{
	*pfTruncateBefore = FALSE;
	return lserrNone;
}

/*
 *	OlsCanBreakBeforeChar (pols, brkcls, pcond)
 *
 *	@func
 *		Line services calls this callback for a break candidate following an
 *		inline object, to determine whether breaks are prevented, possible or
 *		mandatory
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCanBreakBeforeChar(
	POLS	pols,		//(IN): Client context
	BRKCLS	brkcls,		//(IN): Breaking class
	BRKCOND *pcond) 	//(OUT): Corresponding break condition
{
	switch (brkcls)
	{
	default:
		*pcond = brkcondCan;
		break;

	case brkclsClose:
	case brkclsNoStartIdeo:
	case brkclsExclaInterr:
	case brkclsGlueA:
		*pcond = brkcondNever;
		break;

	case brkclsIdeographic:
	case brkclsSpaceN:
	case brkclsSlash:
		*pcond = brkcondPlease;	
		break;
	};
	return lserrNone;
}

/*
 *	OlsCanBreakAfterChar (pols, brkcls, pcond)
 *
 *	@func
 *		Line services calls this callback for a break candidate preceding an
 *		inline object, to determine whether breaks are prevented, possible or
 *		mandatory
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCanBreakAfterChar(
	POLS	pols,		//(IN): Client context
	BRKCLS	brkcls,		//(IN): Breaking class
	BRKCOND *pcond) 	//(OUT): Corresponding break condition
{
	switch (brkcls)
	{
	default:
		*pcond = brkcondCan;
		break;

	case brkclsOpen:
	case brkclsGlueA:
		*pcond = brkcondNever;
		break;

	case brkclsIdeographic:
	case brkclsSpaceN:
	case brkclsSlash:
		*pcond = brkcondPlease;	
		break;
	};
	return lserrNone;
}

#ifndef NOCOMPLEXSCRIPTS
// REVIEW FUTURE : JMO May want some version for non complex script ligatures.
/*
 *	OlsFInterruptShaping (pols, kTFlow, plsrunFirst, plsrunSecond, pfInterruptShaping)
 *
 *	@func
 *		Line services calls this callback to find out if you
 *		would like to ligate across these two runs.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFInterruptShaping(
	POLS	pols,					//(IN): Client context
	LSTFLOW	kTFlow,					//(IN): Text direction and orientation
	PLSRUN	plsrunFirst,			//(IN): Run #1
	PLSRUN	plsrunSecond,			//(IN): Run #2
	BOOL	*pfInterruptShaping)	//(OUT): Shape across these 2 runs?
{
	*pfInterruptShaping = FALSE;

	const CCharFormat* pCFFirst = plsrunFirst->_pCF;
	const CCharFormat* pCFSecond = plsrunSecond->_pCF;

	Assert (plsrunFirst->_a.eScript && plsrunSecond->_a.eScript);

	const DWORD dwMask = CFE_BOLD | CFE_ITALIC | CFM_SUBSCRIPT;

	if (pCFFirst == pCFSecond ||
		(plsrunFirst->_a.eScript == plsrunSecond->_a.eScript &&
		!((pCFFirst->_dwEffects ^ pCFSecond->_dwEffects) & dwMask) &&
		pCFFirst->_iFont == pCFSecond->_iFont &&
		pCFFirst->_yOffset == pCFSecond->_yOffset &&
		pCFFirst->_yHeight == pCFSecond->_yHeight))
	{
		// establish link
		plsrunFirst->_pNext = plsrunSecond;
		return lserrNone;
	}

	*pfInterruptShaping = TRUE;
	return lserrNone;
}

// LS calls this callback to shape the codepoint string to a glyph indices string
// for handling glyph based script such as Arabic, Hebrew and Thai.
//
LSERR OlsGetGlyphs(
	POLS 		pols,
	PLSRUN	 	plsrun,
	LPCWSTR		pwch,
	DWORD		cch,
	LSTFLOW		kTFlow,
	PGMAP		pgmap,				// OUT: array of logical cluster information
	PGINDEX*	ppgi, 				// OUT: array of output glyph indices
	PGPROP*		ppgprop, 			// OUT: array of glyph's properties
	DWORD*		pcgi)				// OUT: number of glyph generated
{
	pols->SetRun(plsrun);

	CMeasurer*		pme = pols->GetMeasurer();
	CUniscribe* 	pusp = pme->Getusp();
	Assert (pusp);

	WORD*			pwgi;
	SCRIPT_VISATTR *psva;
	int				cgi;

	pme->SetGlyphing(TRUE);

	// Glyphing doesn't care about the target device but always
	// using target device reduces creation of Cccs in general.
	pme->SetUseTargetDevice(TRUE);

	AssertSz(IN_RANGE(1, plsrun->_a.eScript, SCRIPT_MAX_COUNT - 1), "Bad script ID!");

	// Digit substitution
	pusp->SubstituteDigitShaper(plsrun, pme);

	if (!(cgi = (DWORD)pusp->ShapeString(plsrun, &plsrun->_a, pme, pwch, (int)cch, pwgi, pgmap, psva)))
	{
		const SCRIPT_ANALYSIS	saUndef = {SCRIPT_UNDEFINED,0,0,0,0,0,0,{0}};

		// Current font cant shape given string.
		// Try SCRIPT_UNDEF so it generates invalid glyphs
		if (!(cgi = (DWORD)pusp->ShapeString(plsrun, (SCRIPT_ANALYSIS*)&saUndef, pme, pwch, (int)cch, pwgi, pgmap, psva)))
		{
			// For whatever reason we still fails.
			// Abandon glyph processing.
			plsrun->_a.fNoGlyphIndex = TRUE;
			cgi = (DWORD)pusp->ShapeString(plsrun, &plsrun->_a, pme, pwch, (int)cch, pwgi, pgmap, psva);
		}
	}

	*pcgi = cgi;

	DupShapeState(plsrun, cch);

	*ppgi = (PGINDEX)pwgi;
	*ppgprop = (PGPROP)psva;
	pme->SetGlyphing(FALSE);
	return lserrNone;
}

// LS calls this callback to find out glyph positioning for complex scripts
//
LSERR OlsGetGlyphPositions(
	POLS		pols,
	PLSRUN		plsrun,
	LSDEVICE	deviceID,
	LPWSTR		pwch,
	PCGMAP		pgmap,
	DWORD		cch,
	PCGINDEX	pgi,
	PCGPROP		pgprop,
	DWORD		cgi,
	LSTFLOW		kTFlow,
	int*		pgdx,				// OUT: array of glyph advanced width
	PGOFFSET	pgduv)				// OUT: array of offset between glyphs
{
	pols->SetRun(plsrun);

	CMeasurer*		pme = pols->GetMeasurer();
	CUniscribe* 	pusp = pme->Getusp();
	Assert (pusp);

	Assert(pgduv);
	pme->SetGlyphing(TRUE);

	// zero out before passing to shaping engine
	ZeroMemory ((void*)pgduv, cgi*sizeof(GOFFSET));
	pme->SetUseTargetDevice(deviceID == lsdevReference);

	AssertSz(IN_RANGE(1, plsrun->_a.eScript, SCRIPT_MAX_COUNT - 1), "Bad script ID!");

	if (!pusp->PlaceString(plsrun, &plsrun->_a, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL))
	{
		SCRIPT_ANALYSIS	saUndef = {SCRIPT_UNDEFINED,0,0,0,0,0,0,{0}};

		if (!pusp->PlaceString(plsrun, &saUndef, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL))
		{
			plsrun->_a.fNoGlyphIndex = TRUE;
			pusp->PlaceString(plsrun, &plsrun->_a, pme, pgi, cgi, (const SCRIPT_VISATTR*)pgprop, pgdx, pgduv, NULL);
		}
	}

	//Support spacing for base glyphs. Note this spreads apart clusters and breaks the lines which connect
	//arabic text, but this might be okay.
	if (plsrun->_pCF->_sSpacing)
	{
		LONG dupAdjust = pme->LUtoDU(plsrun->_pCF->_sSpacing);
		for (DWORD gi = 0; gi < cgi; gi++)
			if (pgdx[gi])
				pgdx[gi] += dupAdjust;
	}

	DupShapeState(plsrun, cch);

	pme->SetGlyphing(FALSE);
	return lserrNone;
}

LSERR OlsDrawGlyphs(
	POLS			pols,
	PLSRUN			plsrun,
	BOOL			fStrikeOut,
	BOOL			fUnderline,
	PCGINDEX		pcgi,
	const int*		pgdx,			// array of glyph width
	const int*		pgdxo,			// array of original glyph width (before justification)
	PGOFFSET		pgduv,			// array of glyph offset
	PGPROP			pgprop,			// array of glyph's properties
	PCEXPTYPE		pgxtype,		// array of expansion type
	DWORD			cgi,
	LSTFLOW			kTFlow,
	UINT			kDisp,
	const POINT*	pptRun,
	PCHEIGHTS		pHeight,
	long			dupRun,
	long			dupLimUnderline,
	const RECT*		prectClip)
{
	BOOL			fBullet = pols->SetRun(plsrun);
	CRenderer*		pre = pols->GetRenderer();
	CUniscribe* 	pusp = pre->Getusp();
	Assert(pusp && pre->IsRenderer());
	pre->SetGlyphing(TRUE);

	RECT			rc = *prectClip;
	CCcs* 			pccs = pre->Check_pccs(fBullet);

	if (!pccs)
		return lserrOutOfMemory;

	// Apply fallback font if we need to
	if (!fBullet)
		pccs = pre->ApplyFontCache(plsrun->IsFallback(), plsrun->_a.eScript);

	pre->SetSelected(plsrun->IsSelected());
	pre->SetFontAndColor(plsrun->_pCF);

	// v needs to be moved from baseline to top of character
	POINTUV  pt = {pptRun->x, pptRun->y - (pccs->_yHeight - pccs->_yDescent)};

	if (kTFlow == lstflowWS)
		pt.u -= dupRun - 1;	
	
	if(!fBullet && pre->_fBackgroundColor)
	{
		if (pre->_fEraseOnFirstDraw)
			pre->EraseLine();

		kDisp = ETO_OPAQUE | ETO_CLIPPED;
		SetBkMode(pre->_hdc, OPAQUE);

		POINTUV ptCur = pre->GetCurPoint();
		ptCur.u = pt.u;
		pre->SetCurPoint(ptCur);
		pre->SetClipLeftRight(dupRun);
		RECTUV rcuv = pre->GetClipRect();
		pre->GetPdp()->RectFromRectuv(rc, rcuv);
	}

	if (rc.left >= rc.right || rc.top >= rc.bottom)
		goto Exit;

	if (pre->GetPdp()->IsMetafile() && !IsEnhancedMetafileDC(pre->GetDC()))
	{
		// -WMF metafile handling-
		//
		//     If the rendering device is WMF metafile. We metafile the codepoint array
		// instead of glyph indices. This requires that the target OS must know how to
		// playback complex script text (shaping, Bidi algorithm, etc.).
		//     Metafiling glyph indices only works for EMF since the WMF's META_EXTTEXTOUT
		// record stores the input string as an array of byte but a glyph index is 16-bit
		// word element.
		//     WMF also must NOT be used to record ExtTextOutW call otherwise the Unicode
		// string will be converted to mutlibyte text using system codepage. Anything
		// outside the codepage then becomes '?'.
		//     We have the workaround for such case in REExtTextOut to make sure we only
		// metafile ExtTextOutA to WMF. (wchao)
		//
	
		LONG			cch;
		const WCHAR*	pwch = pre->GetPch(cch);
		PINT			piDx;
	
		cch = min(cch, pre->GetCchLeftRunCF());
		cch = min(cch, pre->GetLine()._cch - plsrun->_cp + pols->_cp);

		// make sure that we record ETO with proper reading order.
		kDisp |= plsrun->_a.fRTL ? ETO_RTLREADING : 0;

		if (pusp->PlaceMetafileString(plsrun, pre, pwch, (int)cch, &piDx))
		{
			pre->RenderExtTextOut(pt, kDisp, &rc, pwch, cch, piDx);
			goto Exit;
		}

		TRACEERRORSZ("Recording metafile failed!");

		// Fall through... with unexpected error

		// Else, metafile glyph indices for EMF...
	}

	if (pre->_fEraseOnFirstDraw)
	{
		SetBkMode(pre->_hdc, OPAQUE);
		pre->GetPdp()->RectFromRectuv(rc, pre->_rcErase);
		kDisp |= ETO_OPAQUE;
	}

	//This is duplicated from RenderExtTextOut but the params are different so simplest solution
	//was to copy code.
	if(pre->_fDisabled)
	{
		if(pre->_crForeDisabled != pre->_crShadowDisabled)
		{
			// The shadow should be offset by a hairline point, namely
			// 3/4 of a point.  Calculate how big this is in device units,
			// but make sure it is at least 1 pixel.
			DWORD offset = MulDiv(3, pre->_dvpInch, 4*72);
			offset = max(offset, 1);

			// Draw shadow
			pre->SetTextColor(pre->_crShadowDisabled);

			POINTUV ptT = pt;
			ptT.u += offset;
			ptT.v += offset;

			POINT pt;
			pre->GetPdp()->PointFromPointuv(pt, ptT, TRUE);

			ScriptTextOut(pre->GetDC(), &pccs->_sc, pt.x, pt.y, kDisp, &rc, &plsrun->_a,
				NULL, 0, pcgi, (int)cgi, pgdx, NULL, pgduv);

			kDisp &= ~ETO_OPAQUE;
			SetBkMode(pre->_hdc, TRANSPARENT);
		}
		pre->SetTextColor(pre->_crForeDisabled);
	}

	POINT ptStart;
	pre->GetPdp()->PointFromPointuv(ptStart, pt, TRUE);

	ScriptTextOut(pre->GetDC(), &pccs->_sc, ptStart.x, ptStart.y, kDisp, &rc, &plsrun->_a,
				NULL, 0, pcgi, (int)cgi, pgdx, NULL, pgduv);

	if (pre->_fEraseOnFirstDraw || !fBullet && pre->_fBackgroundColor)
	{
		SetBkMode(pre->_hdc, TRANSPARENT);
		pre->_fEraseOnFirstDraw = FALSE;
	}

Exit:
	if (!fBullet)
		pre->ApplyFontCache(0, 0);		// reset font fallback if any

	pre->SetGlyphing(FALSE);
	return lserrNone;
}
#endif

/*
 *	OlsResetRunContents (pols, plsrun, cpFirstOld, dcpOld, cpFirstNew, dcpNew)
 *
 *	@func
 *		Line Services calls this routine when a ligature
 *		or kern pair extends across run boundaries.
 *
 *		We don't have to do anything special here if we are
 *		careful about how we use our PLSRUNs.
 *	@rdesc
 *		LSERR
 */
 LSERR WINAPI OlsResetRunContents(
 	POLS 	pols,		//(IN): Client context
 	PLSRUN 	plsrun,		//(IN): Run being combined
 	LSCP 	cpFirstOld, //(IN): cp of the first run being combined
 	LSDCP 	dcpOld,		//(IN):	dcp of the first run being combined
 	LSCP 	cpFirstNew, //(IN): new cp of the run
 	LSDCP 	dcpNew)		//(IN): new dcp of the run
{
	return lserrNone;
}

/*
 *	OlsCheckForDigit (pols, plsrun, wch, pfIsDigit)
 *
 *	@func
 *		Get numeric separators needed, e.g., for decimal tabs
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsCheckForDigit(
	POLS	pols,		//(IN): pols
	PLSRUN	plsrun,		//(IN): Run (cp here)
	WCHAR	wch,		//(IN): Character to check
	BOOL *	pfIsDigit)	//(OUT): This character is digit
{
	WORD	wType;

	// We could get the run LCID to use for the first parm in the following
	// call, but the digit property should be independent of LCID.
	W32->GetStringTypeEx(0, CT_CTYPE1, &wch, 1, &wType);
	*pfIsDigit = (wType & C1_DIGIT) != 0;

	return lserrNone;
}

/*
 *	OlsGetBreakThroughTab(pols, uaRightMargin, uaTabPos, puaRightMarginNew)
 *
 *	@func
 *		Just follow word95 behavior.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetBreakThroughTab(
	POLS	pols,				//(IN): client context
	long	uaRightMargin,		//(IN): right margin for breaking
	long	uaTabPos,			//(IN): breakthrough tab position
	long *	puaRightMarginNew)	//(OUT): new right margin
{
	*puaRightMarginNew = 20 * 1440;
	return lserrNone;
}

/*
 *	OlsFGetLastLineJustification(pols, lskj, lskal, endr, pfJustifyLastLine, plskalLine)
 *
 *	@func
 *		Just say no to justify last line.	
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsFGetLastLineJustification(
	POLS	pols,				//(IN): client context
	LSKJUST lskj,				//(IN): kind of justification
	LSKALIGN lskal,				//(IN): kind of alignment
	ENDRES	endr,				//(IN): result of formatting
	BOOL	*pfJustifyLastLine,	//(OUT): should last line be fully justified
	LSKALIGN *plskalLine)		//(OUT): kind of alignment for this line
{
	*pfJustifyLastLine = FALSE;
	*plskalLine = lskal;
	return lserrNone;
}

/*
 *	OlsGetHyphenInfo(pols, plsrun, pkysr, pwchYsr)
 *
 *	@func
 *		We don't support fancy YSR types, tell LS so.	
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetHyphenInfo(
	POLS	pols,				//(IN): client context
	PLSRUN	plsrun,				//(IN)
	DWORD*	pkysr,				//(OUT): Ysr type - see "lskysr.h"
	WCHAR*	pwchYsr)			//(OUT): Character code of YSR
{
	*pkysr = kysrNil;
	*pwchYsr = 0;	
	return lserrNone;
}

/*
 *	OlsHyphenate(pols, pclsHyphLast, cpBeginWord, cpExceed, plshyph)
 *
 *	@func
 *		Prepare the buffer, and then call the client and ask them to hyphenate the word.
 *
 *	Getting perfect word hyphenation is a complex topics which to do properly would
 *	require a lot of work. This code is simple and hopefully good enough. One difficulty
 *	for example is hidden text. The right thing to do here is to strip out hidden text and
 *	build up a cp mapping from the remaining text to it's cp in the backing store. Yuck.
 *
 *	@rdesc
 *		LSERR
 */
extern CHyphCache *g_phc;
LSERR WINAPI OlsHyphenate(
	POLS		pols,				//(IN): client context
	PCLSHYPH	pclsHyphLast,		//(IN): last seen hyphenation opportunity
	LSCP		cpBeginWord,		//(IN): First CP of last word on line
	LSCP		cpExceed,			//(IN): CP which exceeds column
	PLSHYPH		plsHyph)			//(OUT): Hyphenation opportunity found
{
	CMeasurer  *pme = pols->GetMeasurer();
	CTxtEdit   *ped = pme->GetPed();
	CHyphCache *phc = ped->GetHyphCache();
	if (!phc)
		return lserrOutOfMemory;

	if (!pme->IsMeasure())
	{
		phc->GetAt(pme->GetLine()._ihyph, plsHyph->kysr, plsHyph->wchYsr);
		plsHyph->cpYsr = pols->GetCpLsFromCpRe(pols->_cp + pme->GetCchLine()) - 1;

		// No break in the range LS expect...
		if (plsHyph->cpYsr < cpBeginWord || plsHyph->cpYsr >= cpExceed)
			plsHyph->kysr = kysrNil; 
		return lserrNone;
	}

	cpBeginWord = pols->GetCpReFromCpLs(cpBeginWord);
	cpExceed = pols->GetCpReFromCpLs(cpExceed);

	//Strip off leading junk
	pme->SetCp(cpBeginWord);
	for (; cpBeginWord < cpExceed; cpBeginWord++, pme->Move(1))
	{
		WCHAR ch = pme->GetChar();
		WORD type1;
		W32->GetStringTypeEx(pme->GetCF()->_lcid, CT_CTYPE1, &ch, 1, &type1);
		if (type1 & C1_ALPHA)
			break;
	}

	LONG cpEndWord = cpBeginWord + pme->FindWordBreak(WB_RIGHTBREAK, ped->GetAdjustedTextLength());

	//Strip off trailing junk
	pme->SetCp(cpEndWord);
	for (; cpEndWord > cpBeginWord; cpEndWord--, pme->Move(-1))
	{
		WCHAR ch = pme->GetPrevChar();
		WORD type1;
		W32->GetStringTypeEx(pme->GetCF()->_lcid, CT_CTYPE1, &ch, 1, &type1);
		if (type1 & C1_ALPHA)
			break;
	}

	int cchWord = cpEndWord - cpBeginWord;

	//Don't hyphenate unless at least 5 chars in word and can have 2 chars before
	if (cchWord >= 5 && cpExceed - cpBeginWord > 2)
	{
		CTempWcharBuf tb;
		WCHAR *pszWord = tb.GetBuf(cchWord + 1);

		pme->SetCp(cpBeginWord);
		pme->_rpTX.GetText(cchWord, pszWord);
		pszWord[cchWord] = 0;

		cpExceed = min(cpExceed, cpBeginWord + cchWord - 1);

		(*pme->GetPed()->_pfnHyphenate)(pszWord, pme->GetCF()->_lcid, cpExceed - cpBeginWord, (HYPHRESULT*)plsHyph);
		plsHyph->cpYsr += cpBeginWord; //The client gives us an ich, we turn it into a CP

		if (plsHyph->kysr != khyphNil && (plsHyph->cpYsr >= cpExceed || plsHyph->cpYsr < cpBeginWord) || 
			!IN_RANGE(khyphNil, plsHyph->kysr, khyphDelAndChange))
		{
			AssertSz(FALSE, "Bad results from hyphenation proc: ichHyph or khyph are invalid.");
			plsHyph->kysr = kysrNil;
		}
		else
			plsHyph->cpYsr = pols->GetCpLsFromCpRe(plsHyph->cpYsr);
	}
	else
		plsHyph->kysr = kysrNil;

	//Cache into CLine
	pme->GetLine()._ihyph = phc->Find(plsHyph->kysr, plsHyph->wchYsr);
	return lserrNone;
}

/*
 *	OlsCheckRunKernability (pols, plsrunFirst, plsrunSecond, pfKernable)
 *
 *	@func
 *		Return if you can kern across these two runs.
 *
 *	@rdesc
 *		lserrNone
 */
LSERR WINAPI OlsCheckRunKernability(
	POLS	pols, 
	PLSRUN	plsrunFirst, 
	PLSRUN	plsrunSecond, 
	BOOL *	pfKernable)
{
	*pfKernable = plsrunFirst->_pCF->CanKernWith(plsrunSecond->_pCF);

	return lserrNone;
}

/*
 *	OlsGetRunCharKerning(pols, plsrun, deviceID, pchRun, cchRun, ktflow, rgdu)
 *
 *	@func
 *		Fetch and return the kerning pairs to Line Services.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsGetRunCharKerning(
	POLS	 pols,
	PLSRUN	 plsrun,
	LSDEVICE deviceID,
	LPCWSTR	 pchRun,
	DWORD	 cchRun, 
	LSTFLOW	 ktflow,
	int *	 rgdu)
{
	CMeasurer *pme = pols->GetMeasurer();

	// Make sure right font is set for run
	pme->SetUseTargetDevice(deviceID == lsdevReference);
	pols->SetRun(plsrun);
	CCcs *pccs = pme->Check_pccs();
	const CCharFormat *pCF = plsrun->_pCF;

	if(!pccs)
		return lserrOutOfMemory;

	CKernCache *pkc = fc().GetKernCache(pCF->_iFont, pCF->_wWeight, pCF->_dwEffects & CFE_ITALIC);
	Assert(pkc); //SetLsChp ensures this exists AND kerning pairs exist.

	for (DWORD ich = 0; ich < cchRun - 1; ich++)
		rgdu[ich] = pkc->FetchDup(pchRun[ich], pchRun[ich + 1], pme->_pccs->_yHeightRequest);

	return lserrNone;
}

/*
 *	OlsReleaseRun (pols, plsrun)
 *
 *	@func
 *		We do nothing because the run is in an array and is
 *		released automatically.
 *
 *	@rdesc
 *		LSERR
 */
LSERR WINAPI OlsReleaseRun(
	POLS	pols,	//(IN): interface object
	PLSRUN	plsrun)	//(IN): run (cp) to use for underlining
{
	return lserrNone;
}

/*
 * 	OlsNewPtr(pols, cBytes)
 *
 *	@func
 *		Memory allocator.
 */
void* WINAPI OlsNewPtr(
	POLS	pols,		//@parm Not used
	DWORD	cBytes)		//@parm Count of bytes to alloc
{
	return PvAlloc(cBytes, 0);
}

/*
 * 	OlsDisposePtr(pols, pv)
 *
 *	@func
 *		Memory deallocator.
 */
void WINAPI OlsDisposePtr(
	POLS	pols,		//@parm Not used
	void *	pv)			//@parm [in]: ptr to free
{
	FreePv(pv);
}

/*
 * 	OlsDisposePtr(pols, pv, cBytes)
 *
 *	@func
 *		Memory reallocator.
 */
void* WINAPI OlsReallocPtr(
	POLS	pols,		//@parm Not used
	void *	pv, 		//@parm [in/out]: ptr to realloc
	DWORD	cBytes)		//@parm Count of bytes to realloc
{
	return PvReAlloc(pv, cBytes);
}

const REVERSEINIT reverseinit =
{
	REVERSE_VERSION,
	wchObjectEnd
};

LSERR WINAPI OlsGetObjectHandlerInfo(
	POLS	pols,
	DWORD	idObj, 
	void *	pObjectInfo)
{
	switch (idObj)
	{
	case OBJID_REVERSE:
		memcpy(pObjectInfo, (void *)&reverseinit, sizeof(REVERSEINIT));
		break;
	default:
		AssertSz(0, "Undefined Object handler. Add missing case.");
	}
	return lserrNone;
}

#ifdef DEBUG
/* Debugging APIs */
void WINAPI OlsAssertFailed(
	char *sz,
	char *szFile,
	int	  iLine)
{
	AssertSzFn(sz, szFile, iLine);
}
#endif


extern const LSCBK lscbk =
{
	OlsNewPtr,					// pfnNewPtr
	OlsDisposePtr,				// pfnDisposePtr
	OlsReallocPtr,				// pfnReallocPtr
	OlsFetchRun,				// pfnFetchRun
	OlsGetAutoNumberInfo,		// pfnGetAutoNumberInfo
	OlsGetNumericSeparators,	// pfnGetNumericSeparators
	OlsCheckForDigit,			// pfnCheckForDigit
	OlsFetchPap,				// pfnFetchPap
	OlsFetchTabs,				// pfnFetchTabs
	OlsGetBreakThroughTab,		// pfnGetBreakThroughTab
	OlsFGetLastLineJustification,// pfnFGetLastLineJustification
	OlsCheckParaBoundaries,		// pfnCheckParaBoundaries
	OlsGetRunCharWidths,		// pfnGetRunCharWidths
	OlsCheckRunKernability,		// pfnCheckRunKernability
	OlsGetRunCharKerning,		// pfnGetRunCharKerning
	OlsGetRunTextMetrics,		// pfnGetRunTextMetrics
	OlsGetRunUnderlineInfo,		// pfnGetRunUnderlineInfo
	OlsGetRunStrikethroughInfo,	// pfnGetRunStrikethroughInfo
	0,							// pfnGetBorderInfo
	OlsReleaseRun,				// pfnReleaseRun
	OlsHyphenate,				// pfnHyphenate
	OlsGetHyphenInfo,			// pfnGetHyphenInfo
	OlsDrawUnderline,			// pfnDrawUnderline
	OlsDrawStrikethrough,		// pfnDrawStrikethrough
	0,							// pfnDrawBorder
	0,							// pfnDrawUnderlineAsText //REVIEW (keithcu) Need to implement this??
	OlsFInterruptUnderline,		// pfnFInterruptUnderline
	0,							// pfnFInterruptShade
	0,							// pfnFInterruptBorder
	0,							// pfnShadeRectangle
	OlsDrawTextRun,				// pfnDrawTextRun
	0,							// pfnDrawSplatLine
#ifdef NOCOMPLEXSCRIPTS
	0,
	0,
	0,
	OlsResetRunContents,		// pfnResetRunContents
	0,
#else
	OlsFInterruptShaping,		// pfnFInterruptShaping
	OlsGetGlyphs,				// pfnGetGlyphs
	OlsGetGlyphPositions,		// pfnGetGlyphPositions
	OlsResetRunContents,		// pfnResetRunContents
	OlsDrawGlyphs,				// pfnDrawGlyphs
#endif
	0,							// pfnGetGlyphExpansionInfo
	0,							// pfnGetGlyphExpansionInkInfo
	0,							// pfnGetEms
	0,							// pfnPunctStartLine
	0,							// pfnModWidthOnRun
	0,							// pfnModWidthSpace
	0,							// pfnCompOnRun
	0,							// pfnCompWidthSpace
	0,							// pfnExpOnRun
	0,							// pfnExpWidthSpace
	0,							// pfnGetModWidthClasses
	OlsGetBreakingClasses,		// pfnGetBreakingClasses
	OlsFTruncateBefore,			// pfnFTruncateBefore
	OlsCanBreakBeforeChar,		// pfnCanBreakBeforeChar
	OlsCanBreakAfterChar,		// pfnCanBreakAfterChar
	0,							// pfnFHangingPunct
	0,							// pfnGetSnapGrid
	0,							// pfnDrawEffects
	0,							// pfnFCancelHangingPunct
	0,							// pfnModifyCompAtLastChar
	0,							// pfnEnumText
	0,							// pfnEnumTab
	0,							// pfnEnumPen
	OlsGetObjectHandlerInfo,	// pfnGetObjectHandlerInfo
#ifdef DEBUG
	OlsAssertFailed				// pfnAssertFailed
#else
	0							// pfnAssertFailed
#endif
};

#endif // NOLINESERVICES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\objmgr.cpp ===
/*
 *  @doc    INTERNAL
 *
 *  @module objmgr.cpp.  Object manager implementation | manages a
 *          collection of OLE embedded objects 
 *
 *  Author: alexgo 11/5/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_objmgr.h"
#include "_edit.h"
#include "_disp.h"
#include "_select.h"
#include "_rtext.h"

ASSERTDATA

//
//	PUBLIC methods
//

/*
 *	CObjectMgr::GetObjectCount
 *
 *	@mfunc	returns the number of embedded objects currently in
 *			the document.
 *
 *	@rdesc	LONG, the count
 */
LONG CObjectMgr::GetObjectCount()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetObjectCount");

	return _objarray.Count();
}

/*
 *	CObjectMgr::GetLinkCount()
 *
 *	@mfunc	returns the number of embedded objects which are links
 *
 *	@rdesc	LONG, the count
 */
LONG CObjectMgr::GetLinkCount()
{
	LONG count = 0;
	COleObject *pobj;
	LONG i;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetLinkCount");
		
	for(i = 0; i < _objarray.Count(); i++)
	{
		pobj = *_objarray.Elem(i);
		if(pobj && pobj->IsLink())
			count++;
	}
	return count;
}

/*
 *	CObjectMgr::GetObjectFromCp(cp)
 *
 *	@mfunc	fetches an object corresponding to the given cp
 *
 *	@rdesc	the object @ a cp; NULL if nothing found
 *
 *	@comm	the algorithm is a modified binary search.  Since the
 *			"typical" access pattern will be to linearly access the
 *			objects, we used the cached index to guess first.  If
 *			that doesn't work, we resort to a binary search.
 */
COleObject *CObjectMgr::GetObjectFromCp(
	LONG cp)		//@parm cp for the object
{
	COleObject *pobj = NULL;
	LONG i = 0;
	
	// No tracing on this method as it's too noisy.
		
	if(_objarray.Count() > 0)
	{
		if(_lastindex < _objarray.Count())
		{
			pobj = *_objarray.Elem(_lastindex);
			if(pobj && pobj->GetCp() == cp)
				return pobj;
		}
		
		// The quick lookup failed; try a binary search.
		i = FindIndexForCp(cp);

		// Because of the insert at end case, i may be equal 
		// to the count of objects().
		pobj = NULL;
		if(i < _objarray.Count())
			pobj = *_objarray.Elem(i);
	}

	// FindIndex will return a matching or _near_ index.
	// In this case, we only want a matching index
	if(pobj)
	{
		if(pobj->GetCp() != cp)
			pobj = NULL;
		else
		{
			// Set the cached index to be the next one,
			// so that somebody walking through objects in
			// cp order will always get immediate hits.
			_lastindex = i + 1;
		}
	}
	
#ifdef DEBUG
	// Make sure the binary search found the right thing

	for( i = 0 ; i < _objarray.Count();  i++ )
	{
		COleObject *pobj2 = *_objarray.Elem(i);
		if( pobj2 )
		{
			if(*_objarray.Elem(i) == pobj)
			{
				Assert((*_objarray.Elem(i))->GetCp() == cp);
			}
			else
				Assert((*_objarray.Elem(i))->GetCp() != cp);
		}
	}
#endif //DEBUG

	return pobj;
}

/*
 *	CObjectMgr::CountObjects (&cObjects, cp)
 *
 *	@mfunc	Count char counts upto <p cObjects> objects away The direction of
 *			counting is determined by the sign of <p cObjects>. 
 *
 *	@rdesc	Return the signed cch counted and set <p cObjects> to count of
 *			objects actually counted.  If <p cobject> <gt> 0 and cp is at
 *			the last object, no change is made and 0 is returned.
 *
 *	@devnote This is called from TOM, which uses LONGs for cp's (because VB
 *			can't use unsigned quantities)
 */
LONG CObjectMgr::CountObjects (
	LONG&	cObjects,		//@parm Count of objects to get cch for
	LONG	cp)				//@parm cp to start counting from
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::CountObjects");

	LONG		iStart, iEnd;
	LONG		iMaxEnd = (LONG)_objarray.Count() - 1;

	if(!cObjects || !_objarray.Count())
	{
		cObjects = 0;
		return 0;
	}

	iStart = (LONG)FindIndexForCp(cp);

	// if we are looking past either end, return 0

	if (iStart > iMaxEnd && cObjects > 0 ||
		iStart == 0 && cObjects < 0 )
	{
		cObjects = 0;
		return 0;
	}

	// If the index that we found is on an object and
	// we are looking forward, it should be skipped.

	if( iStart < (LONG)_objarray.Count() && 
		(LONG)(*_objarray.Elem(iStart))->GetCp() == cp &&
		cObjects > 0)
	{
		iStart++;
	}

	if(cObjects < 0)
	{
		if(-cObjects > iStart)	// Going past the beginning
		{
			iEnd = 0;
			cObjects = -iStart;
		}
		else
			iEnd = iStart + cObjects;
	}
	else
	{
		if(cObjects > iMaxEnd - iStart) //Going past the end
		{
			iEnd = iMaxEnd;
			cObjects = iMaxEnd - iStart + 1;
		}
		else
			iEnd = iStart + cObjects - 1;
	}

	Assert(iEnd >= 0 && iEnd < (LONG)_objarray.Count() );

	return (*_objarray.Elem(iEnd))->GetCp() - cp;
}

/*
 *	CObjectMgr::CountObjectsInRange (cpMin, cpMost)
 *
 *	@mfunc	Count the number of objects in the given range.
 *
 *	@rdesc	Return the number of objects.
 */
LONG CObjectMgr::CountObjectsInRange (
	LONG	cpMin,	//@parm Beginning of range
	LONG	cpMost)	//@parm End of range
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::CountObjectsInRange");

	//Get the indexes for the objects at or after cpMin and cpMost
	//respectively.

	return FindIndexForCp(cpMost) - FindIndexForCp(cpMin);
}

/*
 *	CObjectMgr::GetFirstObjectInRange (cpMin, cpMost)
 *
 *	@mfunc	Get the first object in the given range. 
 *
 *	@rdesc	Pointer to first object in range, or NULL if none.
 */
COleObject * CObjectMgr::GetFirstObjectInRange (
	LONG	cpMin,	//@parm Beginning of range
	LONG	cpMost)	//@parm End of range
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetFirstObjectInRange");

	if (cpMin == cpMost)
		// degenerate range no object selected
		return NULL;

	LONG	iLast = (LONG)_objarray.Count() - 1;	// Index for next object
	LONG	iObj = FindIndexForCp(cpMin);			//  at or after cpMin

	//Make sure this is an existing object.
	if(iObj <= iLast)
	{
		//Make sure it is within the range
		COleObject * pObj = *_objarray.Elem(iObj);

		if(pObj && pObj->GetCp() <= cpMost)
			return pObj;
	}
	return NULL;
}

/*
 *	CObjectMgr::GetObjectFromIndex(index)
 *
 *	@mfunc	retrieves the object at the indicated index
 *
 *	@rdesc	a pointer to the object, if found, NULL otherwise
 */
COleObject *CObjectMgr::GetObjectFromIndex(
	LONG index)		//@parm	Index to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::GetObjectFromIndex");

	if( index < _objarray.Count() )
		return *_objarray.Elem(index);

	return NULL;
}

/*
 *	CObjectMgr::InsertObject(prg, preobj, publdr)
 *
 *	@mfunc	inserts an object at the indicated index.  It is the
 *			caller's responsibility to handle inserting any data
 *			(such as WCH_EMBEDDING) into the text stream.
 *
 *	@rdesc	HRESULT
 */
HRESULT CObjectMgr::InsertObject(
	CTxtRange *   prg,		//@parm Where object is inserted
	REOBJECT *	  preobj,	//@parm Object to insert
	IUndoBuilder *publdr)	//@parm Undo context
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::InsertObject");

	WCHAR       ch = WCH_EMBEDDING;
	LONG		cp = prg->GetCp();
	HRESULT		hr;
	COleObject *pobj = (COleObject *)(preobj->polesite);

	if(preobj->dwFlags & REO_USEASBACKGROUND)
		publdr = NULL;

	if (prg->ReplaceRange(1, &ch, publdr, SELRR_IGNORE) != 1)	// Insert WCH_EMBEDDING
		return E_FAIL;
	
	// Let the client know what we're up to
	if (_precall)
	{
		hr = _precall->QueryInsertObject(&preobj->clsid, preobj->pstg,
			REO_CP_SELECTION);

		if( hr != NOERROR )
			return hr;
	}

	// Set some stuff up first; since we may make outgoing calls, don't
	// change our internal state yet.
	hr = pobj->InitFromREOBJECT(cp, preobj);
	if( hr != NOERROR )
		return hr;

	hr = RestoreObject(pobj);

	if(preobj->dwFlags & REO_USEASBACKGROUND)
	{
		CTxtEdit *ped = prg->GetPed();
		CDocInfo *pDocInfo = ped->GetDocInfo();
		HDC hdcBitmap = CreateCompatibleDC(W32->GetScreenDC());
		if(hdcBitmap)
		{
			if(pDocInfo->_nFillType == -1)
			{
				SIZEUV size;
				pobj->GetSize(size);
				pDocInfo->_nFillType = 3;
				pDocInfo->_xScale = 100;
				pDocInfo->_yScale = 100;
				pDocInfo->_xExtGoal = TwipsFromHimetric(size.du);
				pDocInfo->_yExtGoal = TwipsFromHimetric(size.dv);
			}
			LONG dxBitmap = ped->_pdp->LXtoDX(pDocInfo->_xExtGoal*pDocInfo->_xScale / 100);
			LONG dyBitmap = ped->_pdp->LYtoDY(pDocInfo->_yExtGoal*pDocInfo->_yScale / 100);
			RECT rc = {0, 0, dxBitmap, dyBitmap};
			HBITMAP hbitmap = CreateCompatibleBitmap(W32->GetScreenDC(), dxBitmap, dyBitmap);

			if(hbitmap)
			{
				HBITMAP hbitmapSave = (HBITMAP)SelectObject(hdcBitmap, hbitmap);
				HBRUSH hbrush = CreateSolidBrush(pDocInfo->_crColor);
				HBRUSH hbrushOld = (HBRUSH)SelectObject(hdcBitmap, hbrush);
				PatBlt(hdcBitmap, 0, 0, dxBitmap, dyBitmap, PATCOPY);
				SelectObject(hdcBitmap, hbrushOld);
				DeleteObject(hbrush);
				OleDraw(pobj->GetIUnknown(), pobj->GetDvaspect(), hdcBitmap, &rc);
				if(pDocInfo->_hBitmapBack)
					DeleteObject(pDocInfo->_hBitmapBack);
				pDocInfo->_hBitmapBack = hbitmap;
				SelectObject(hdcBitmap, hbitmapSave);
			}
			DeleteObject(hdcBitmap);
		}
		prg->Set(prg->GetCp(), 1);
		prg->ReplaceRange(0, NULL, NULL, SELRR_IGNORE, NULL, RR_NO_TRD_CHECK);
	}
	return hr;
}

/*
 *	CObjectMgr::RestoreObject(pobj)
 *
 *	@mfunc	[re-]inserts the given object into the list of objects
 *			in the backing store
 *
 *	@rdesc	HRESULT
 */
HRESULT CObjectMgr::RestoreObject(
	COleObject *pobj)		//@parm Object to insert
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::RestoreObject");

	COleObject **ppobj = _objarray.Insert(FindIndexForCp(pobj->GetCp()), 1);

	if( ppobj == NULL )
		return E_OUTOFMEMORY;

	*ppobj = pobj;
	pobj->AddRef();

	return NOERROR;
}

/*
 *	CObjectMgr::SetRECallback(precall)
 *
 *	@mfunc	sets the callback interface
 *
 *	@rdesc	void
 */
void CObjectMgr::SetRECallback(
	IRichEditOleCallback *precall) //@parm Callback interface pointer
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::SetRECallback");

	if( _precall )
        SafeReleaseAndNULL((IUnknown**)&_precall);

	_precall = precall;

	if( _precall )
		_precall->AddRef();
}

/*
 *	CObjectMgr::SetHostNames(pszApp, pszDoc)
 *
 *	@mfunc	set host names for this edit instance
 *
 *	@rdesc	NOERROR or E_OUTOFMEMORY
 */
HRESULT CObjectMgr::SetHostNames(
	LPWSTR	pszApp,	//@parm app name
	LPWSTR  pszDoc)	//@parm doc name
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::SetHostNames");
	HRESULT hr = NOERROR;

	if( _pszApp )
	{
		delete _pszApp;
		_pszApp = NULL;
	}
	if( _pszDoc )
	{
		delete _pszDoc;
		_pszDoc = NULL;
	}
	if( pszApp )
	{
		_pszApp = new WCHAR[wcslen(pszApp) + 1];
		if( _pszApp )
			wcscpy(_pszApp, pszApp);
		else
			hr = E_OUTOFMEMORY;
	}
	if( pszDoc )
	{
		_pszDoc = new WCHAR[wcslen(pszDoc) + 1];
		if( _pszDoc )
			wcscpy(_pszDoc, pszDoc);
		else
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

/*
 *	CObjectMgr::CObjectMgr
 *
 *	@mfunc constructor
 */
CObjectMgr::CObjectMgr()
{
	_pobjselect = NULL;
	_pobjactive = NULL;
}

/*
 *	CObjectMgr::~CObjectMgr
 *
 *	@mfunc	destructor
 */
CObjectMgr::~CObjectMgr()
{
	LONG i, count;
	COleObject *pobj;

 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::~CObjectMgr");

	count = _objarray.Count();

	for( i = 0; i < count; i++ )
	{
		pobj = *_objarray.Elem(i);
		// We NULL stuff here to try to protect ourselves
		// better in re-entrancy cases.
		*_objarray.Elem(i) = NULL;
		if( pobj )
		{
			pobj->Close(OLECLOSE_NOSAVE);
  			pobj->MakeZombie();
    		SafeReleaseAndNULL((IUnknown**)&pobj);
		}
	}

	if( _precall )
        SafeReleaseAndNULL((IUnknown**)&_precall);
		
	if( _pszApp )
		delete _pszApp;

	if( _pszDoc )
		delete _pszDoc;
}

/*
 *	CObjectMgr::ReplaceRange (cp, cchDel, publdr)
 *
 *	@mfunc	handles the deletion of objects from a given range.  This
 *			method _must_ be called before any floating range notifications
 *			are sent.
 */
void CObjectMgr::ReplaceRange(
	LONG cp,				//@parm cp starting the deletion
	LONG cchDel,			//@parm Count of characters deleted
	IUndoBuilder *publdr)	//@parm Undo builder for this actions
{
	LONG	i;
	LONG	iDel = -1, 
			cDel = 0;	// index at which to delete && number of objects
						// to delete.
	COleObject *pobj;

	// nothing deleted, don't bother doing anything.
	if( !cchDel )
		return;

	// Basically, we loop through all of the objects within the
	// range of deleted text and ask them to delete themselves.
	// We remember the range of objects deleted (the starting index
	// and # of objects deleted) so that we can remove them from
	// the array all at once.

	i = FindIndexForCp(cp);

	while( i < _objarray.Count() )
	{
		pobj = *_objarray.Elem(i);
		if( pobj && pobj->GetCp() >= cp)
		{
			if( pobj->GetCp() < (cp + cchDel) )
			{
				if( _pobjactive == pobj )
				{
					// Deactivate the object just to be on the safe side.
					_pobjactive->DeActivateObj();
					_pobjactive = NULL;
				}

				if(iDel == -1)
					iDel = i;

				cDel++;
				if (_precall)
				{
					IOleObject *poo;
					if (pobj->GetIUnknown()->QueryInterface(IID_IOleObject,
						(void **)&poo) == NOERROR)
					{
						_precall->DeleteObject(poo);
						poo->Release();
					}
				}

				// if the object was selected, then it obviously
				// can't be anymore!
				if( _pobjselect == pobj )
				{
					_pobjselect = NULL;
				}

				pobj->Delete(publdr);
				*_objarray.Elem(i) = NULL;
				pobj->Release();
			}
			else
				break;
		}
		i++;
	}
	if(cDel)
		_objarray.Remove(iDel, cDel);
	return;
}


//
//	PRIVATE methods
//

/*
 *	CObjectMgr::FindIndexForCp(cp)
 *
 *	@mfunc	does a binary search to find the index at which an object
 *			at the given cp exists or should be inserted.
 *
 *	@rdesc	LONG, an index
 */
LONG CObjectMgr::FindIndexForCp(
	LONG cp)
{
	LONG l, r;
	COleObject *pobj = NULL;
	LONG i = 0;
		
	l = 0; 
	r = _objarray.Count() - 1;
	
	while( r >= l )
	{
		i = (l + r)/2;
		pobj = *_objarray.Elem(i);
		if( !pobj )
		{
			TRACEWARNSZ("null entry in object table.  Recovering...");
			for( i = 0 ; i < _objarray.Count() -1; i++ )
			{
				pobj = *_objarray.Elem(i);
				if( pobj && pobj->GetCp() >= cp )
					return i;
			}
			return i;
		}
		if( pobj->GetCp() == cp )
			return i;

		else if( pobj->GetCp() < cp )
			l = i + 1;

		else
			r = i - 1;
	}

	// Yikes! nothing was found.  Fixup i so that
	// it points to the correct index for insertion.

	Assert(pobj || (!pobj && i == 0));

	if(pobj)
	{
		Assert(pobj->GetCp() != cp);
		if( pobj->GetCp() < cp )
			i++;
	}
	return i;
}
						
/*
 *	CObjectMgr::HandleDoubleClick(ped, &pt, flags)
 *	
 *	@mfunc		Handles a double click message, potentially activating
 *				an object.
 *
 *	@rdesc		BOOL-- TRUE if double click-processing is completely
 *				finished.
 */
BOOL CObjectMgr::HandleDoubleClick(
	CTxtEdit *ped,	//@parm edit context
	const POINTUV &pt,//@parm point of click (WM_LBUTTONDBLCLK wparam)
	DWORD flags)	//@parm flags (lparam)
{
	LONG cp;
	COleObject *pobj;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, 
						"CObjectMgr::HandleDoubleClick");

	ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, NULL, NULL, &cp);
	pobj = GetObjectFromCp(cp);

	if (!pobj)
		return FALSE;

	if (_pobjactive != pobj)
	{
		//Deactivate currently active object if any.
		if (_pobjactive)
			_pobjactive->DeActivateObj();

#ifndef NOINKOBJECT
		if (pobj->IsInkObject())
		{
			if (pobj->_pILineInfo)
			{
				CTxtSelection *	psel = ped->GetSel();

				if (psel && psel->GetCch() == 1)	// Only handle single Ink object being selected
				{
					BSTR		bstr = NULL;
					UINT		icch;
					HRESULT		hr = E_FAIL;
					ILineInfo	*pLineInfo = pobj->_pILineInfo;

					pLineInfo->AddRef();
					hr = pLineInfo->TopCandidates(0, &bstr, &icch, 1, 0);

					if (SUCCEEDED(hr) && bstr)
						psel->TypeText(bstr);

					if (bstr)
						SysFreeString(bstr);
					pLineInfo->Release();
				}
			}
			return TRUE;
		}
		else
#endif	// NOINKOBJECT
		{
			POINT ptxy;
			ped->_pdp->PointFromPointuv(ptxy, pt);
			return pobj->ActivateObj(WM_LBUTTONDBLCLK, flags, MAKELONG(ptxy.x, ptxy.y));
		}
	}
	return TRUE;
}

/*
 *	CObjectMgr::HandleClick(ped, &pt)
 *	
 *	@mfunc
 *		The position of the caret is changing.  We need to
 *		Deactivate the active object, if any.  If the change is
 *		because of a mouse click and there is an object at this
 *		cp, we set a new individually selected object. Otherwise
 *		we set the individually selected object to NULL.
 *
 *	@rdesc	returns TRUE if this method set the selection.  Otherwise,
 *		returns FALSE;
 */
ClickStatus CObjectMgr::HandleClick(
	CTxtEdit *ped,	//@parm the edit context
	const POINTUV &pt)//@parm the point of the mouse click 
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::HandleClick");

	COleObject *	pobjnew;//, * pobjold;
	CTxtSelection * psel;
	LONG			cp;
	LONG			cpMin, cpMost;
	
	if( _pobjactive )
	{
		_pobjactive->DeActivateObj();
		return CLICK_OBJDEACTIVATED;
	}

	ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE, NULL, NULL, &cp);
	pobjnew = GetObjectFromCp(cp);

	//If we clicked on an object, set the selection to this object.
	//CTxtSelection::UpdateSelection will be called as a result of this
	//and will determine the highlighting.
	if(pobjnew)
	{
		cp = pobjnew->GetCp();
		psel = ped->GetSel();
		if (psel->GetRange(cpMin, cpMost) > 1 && cpMin <= cp && cp <= cpMost)
		{
			// There is more than one character in the selection
			// And the object is part of the selection.
			// Do not change the selection
			return CLICK_SHOULDDRAG;
		}
		
		// don't reset the selection if the object is already selected
		if( pobjnew != _pobjselect )
		{
			// Freeze the Display while we handle this click
			CFreezeDisplay fd(ped->_pdp);

			psel->SetSelection(cp, cp+1);
			if (GetSingleSelect())
			{
				// Note thate the call to SetSelection may have set selected object to NULL !!!!
				// This can happen in some strange scenarios where our state is out of whack
				AssertSz(GetSingleSelect() == pobjnew, "Object NOT Selected!!");
				return CLICK_OBJSELECTED;
			}
			return CLICK_IGNORED;
		}
		return CLICK_OBJSELECTED;
	}
	return CLICK_IGNORED;
}

/*
 *	CObjectMgr::HandleSingleSelect(ped, cp, fHiLite)
 *	
 *	@mfunc
 *		When an object is selected and it is the only thing selected, we do
 *		not highlight it by inverting it.  We Draw a frame and handles around
 *		it.  This function is called either because an object has been
 *		selected and it is the only thing selected, or because we need to
 *		check for an object that used to be in this state but may no longer be.
 */
void CObjectMgr::HandleSingleSelect(
	CTxtEdit *ped,		//@parm edit context
	LONG	  cp,		//@parm cp of object
	BOOL	  fHiLite)	//@parm is this a call for hding the selection
{
 	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "CObjectMgr::HandleSingleSelect");

	COleObject* pobjnew = GetObjectFromCp(cp);

	//This should only be called when we know we have a singley selected
	//object.  However, there are boundary cases (such as inserting an object)
	//where WCH_EMBEDDING is the backing store yet no object exists.  These
	//cases are OK; thus, we check for NULL on pobjnew.
	
	if(pobjnew)
	{
		//The object is the same as the currently selected object (if any)
		//we are deselecting it.  This works like a toggle unless state is messed up.
		//If the object is different, we are replacing the current selected
		//object (if any).
		if(!fHiLite && _pobjselect)
		{
			// This covers _pobjselct == pobjnew  Normal case
			//  and _pobjselect != pobjnew  Degenerate case.
			_pobjselect->SetREOSELECTED(FALSE);
			_pobjselect = NULL;

			//Remove frame/handles from currently selected object.
			ped->_pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, cp, cp + 1, NULL);
		}
		else if(fHiLite && pobjnew != _pobjselect)
		{
			// Only do this if we are setting a new selection.
			_pobjselect = pobjnew;
			_pobjselect->SetREOSELECTED(TRUE);

			//Draw frame/handles on newly selected object.
			ped->_pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, cp, cp + 1, NULL);
		}
		else
		{
			// We want to hilite the selection but the object is already selected.
			// Or we want to undo hilite on the selection but the selected object is NULL.
			// Do nothing.
		}
	}
}


/*
 *	CObjectMgr::ActivateObjectsAs (rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a particular
 *		class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT CObjectMgr::ActivateObjectsAs(
	REFCLSID rclsid,
	REFCLSID rclsidAs)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CObjectMgr::ActivateObjectsAs");

	COleObject * pobj;
	HRESULT hr, hrLatest;

	// Tell the system to treat all rclsid objects as rclsidAs
	hr = CoTreatAsClass(rclsid, rclsidAs);
	if( hr != NOERROR )
		return hr;

	LONG cobj = GetObjectCount();

	// Go through objects, letting them decide if
	// they have anything to do for this.
	for (LONG iobj = 0; iobj < cobj; iobj++)
	{
		pobj = GetObjectFromIndex(iobj);
		hrLatest = pobj->ActivateAs(rclsid, rclsidAs);
		// Make hr the latest hresult unless we have previously had an error.
		if(hr == NOERROR)
			hr = hrLatest;
	}
	return hr;
}

#ifdef DEBUG
void CObjectMgr::DbgDump(void)
{
	Tracef(TRCSEVNONE, "Object Manager %d objects", _objarray.Count());

	for(LONG i = 0 ; i < _objarray.Count();  i++)
	{
		COleObject *pobj = *_objarray.Elem(i);
		if(pobj)
			pobj->DbgDump(i);
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\render.cpp ===
/*
 *	@doc INTERNAL
 *	
 *	@module - RENDER.CPP |
 *		CRenderer class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *		Keith Curtis (simplified, cleaned up, added support
 *		for non-western textflows.)
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_render.h"
#include "_font.h"
#include "_disp.h"
#include "_edit.h"
#include "_select.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_layout.h"

// Default colors for background and text on window's host printer
const COLORREF RGB_WHITE = RGB(255, 255, 255);
const COLORREF RGB_BLACK = RGB(0, 0, 0);
const COLORREF RGB_BLUE  = RGB(0, 0, 255);

ASSERTDATA

extern const COLORREF g_Colors[];
static HBITMAP g_hbitmapSubtext = 0;
static HBITMAP g_hbitmapExpandedHeading = 0;
static HBITMAP g_hbitmapCollapsedHeading = 0;
static HBITMAP g_hbitmapEmptyHeading = 0;

void ShiftRect(
	RECTUV &rc,		//@parm rectangle
	LONG	dup,	//@parm shift in u direction
	LONG	dvp)	//@parm shift in v direction
{
	rc.left		-= dup;
	rc.right	-= dup;
	rc.top		-= dvp;
	rc.bottom	-= dvp;
}

HRESULT InitializeOutlineBitmaps()
{
    g_hbitmapSubtext = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_SUBTEXT));
    g_hbitmapExpandedHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_EXPANDED_HEADING));
    g_hbitmapCollapsedHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_COLLAPSED_HEADING));
    g_hbitmapEmptyHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_EMPTY_HEADING));

    if (!g_hbitmapSubtext ||
        !g_hbitmapExpandedHeading ||
        !g_hbitmapCollapsedHeading ||
        !g_hbitmapEmptyHeading)
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

void ReleaseOutlineBitmaps()
{
    if (g_hbitmapSubtext)
	{
        DeleteObject(g_hbitmapSubtext);
		DeleteObject(g_hbitmapExpandedHeading);
		DeleteObject(g_hbitmapCollapsedHeading);		
		DeleteObject(g_hbitmapEmptyHeading);
	}
}

/*
 *	CBrush::~CBrush()
 */
CBrush::~CBrush()
{
	if(_hbrush)					// Is NULL if all line borders have 0 width
	{							//  in which case, _hbrushOld is undefined
		SelectObject(_pre->GetDC(), _hbrushOld);
		DeleteObject(_hbrush);
	}
}

/*
 *	CBrush::Draw(x1, y1, x2, y2, dxpLine, cr, fHideGridLines)
 *
 *	@mfunc
 *		Draw a line from (x1, y1) to (x2, y2) with the pen width dxpLine
 *		and color cr.
 */
void CBrush::Draw(
	LONG u1,			//@parm Line starting x coord 
	LONG v1,			//@parm Line starting y coord
	LONG u2,			//@parm Line ending x coord
	LONG v2,			//@parm Line ending y coord
	LONG dxpLine,		//@parm Width of line to draw
	COLORREF cr,		//@parm Color to use
	BOOL fHideGridLines)//@parm If TRUE, hide 0-width gridlines
{
	if(!dxpLine)
	{
		if(fHideGridLines)			// Hide 0-width grid lines
			return;
		cr = RGB(192, 192, 192);	// Display 0-width grid lines as 1-pixel
		dxpLine = 1;				//  gray lines as in Word
	}

	HDC hdc = _pre->GetDC();

	if(!_hbrush || _cr != cr)
	{
		HBRUSH hbrush = CreateSolidBrush(cr);
		HBRUSH hbrushOld = (HBRUSH)SelectObject(hdc, hbrush);

		if(!_hbrush)
			_hbrushOld = hbrushOld;	// Save original brush
		else
			DeleteObject(hbrushOld);

		_hbrush = hbrush;			// Update CPen state
		_cr = cr;
	}
	RECTUV rcuv;					// Convert to rcuv in case of rotation
	
	rcuv.left = u1;
	rcuv.top = v1;
	if(u1 == u2)					// Vertical line
	{								//  (in uv space)
		rcuv.right = rcuv.left + dxpLine;
		rcuv.bottom = v2;
	}
	else							// Horizontal line
	{								//  (in uv space)
		rcuv.right = u2;
		rcuv.bottom = rcuv.top + dxpLine;
	}

	RECT rc;						// Convert uv to xy space
	_pre->GetPdp()->RectFromRectuv(rc, rcuv);

	PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
		   rc.bottom - rc.top, PATCOPY);
}

/*
 * 	IsTooSimilar(cr1, cr2)
 *
 *	@mfunc
 *		Return TRUE if the colors cr1 and cr2 are so similar that they
 *		are hard to distinguish. Used for deciding to use reverse video
 *		selection instead of system selection colors.
 *
 *	@rdesc
 *		TRUE if cr1 is too similar to cr2 to be used for selection
 *
 *	@devnote
 *		The formula below uses RGB. It might be better to use some other
 *		color representation such as hue, saturation, and luminosity
 */
BOOL IsTooSimilar(
	COLORREF cr1,		//@parm First color for comparison
	COLORREF cr2)		//@parm Second color for comparison
{
	if((cr1 | cr2) & 0xFF000000)			// One color and/or the other
		return FALSE;						//  isn't RGB, so algorithm
											//  doesn't apply
	LONG DeltaR = abs(GetRValue(cr1) - GetRValue(cr2));
	LONG DeltaG = abs(GetGValue(cr1) - GetGValue(cr2));
	LONG DeltaB = abs(GetBValue(cr1) - GetBValue(cr2));

	return DeltaR + DeltaG + DeltaB < 80;
}

/*
 * 	GetShadedColor(crf, crb, iShading)
 *
 *	@mfunc
 *		Return shaded color given by a mixture of crf and crb as determined
 *		by iShading. Used for table cell coloration.
 *
 *	@rdesc
 *		Shaded color
 */
COLORREF GetShadedColor(
	COLORREF crf,
	COLORREF crb,
	LONG	 iShading)
{
	if ((crb | crf) & 0xFF000000 ||		// One or the other isn't an RGB
		!iShading)						//  or no shading:
	{
		return crb;						//  just use crb
	}

	DWORD red   = ((300 - iShading)*GetRValue(crb) + iShading*GetRValue(crf))/300; 
	DWORD green = ((300 - iShading)*GetGValue(crb) + iShading*GetGValue(crf))/300; 
	DWORD blue  = ((300 - iShading)*GetBValue(crb) + iShading*GetBValue(crf))/300;

	return RGB(red, green, blue);
}


// CRenderer class

CRenderer::CRenderer (const CDisplay * const pdp) :
	CMeasurer (pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::CRenderer");

	Init();
}	
 
CRenderer::CRenderer (const CDisplay * const pdp, const CRchTxtPtr &rtp) :
	CMeasurer (pdp, rtp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::CRenderer");

	Init();
}

CRenderer::~CRenderer()
{
	if(_hdcBitmap)
	{
		SelectObject(_hdcBitmap, _hbitmapSave);
		DeleteDC(_hdcBitmap);
	}
}

/*
 *	CRenderer::Init()
 *
 *	@mfunc
 *		Initialize most things to zero
 */
void CRenderer::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::Init");
	_fRenderer = TRUE;
	CTxtEdit *ped	= GetPed();
	_cpAccelerator = ped->GetCpAccelerator();

	static const RECTUV zrect = { 0, 0, 0, 0 };
	_rcView		= zrect;
	_rcRender	= zrect;	  
	_rc			= zrect;
	_dupLine	= 0;
	_dwFlags	= 0;
	_hdcBitmap	= NULL;
	_ptCur.u	= 0;
	_ptCur.v	= 0;
	_plogpalette   = NULL;

	CDocInfo *pDocInfo = ped->GetDocInfoNC();
	if(pDocInfo)
	{
		_dxBitmap = _pdp->LXtoDX(pDocInfo->_xExtGoal*pDocInfo->_xScale / 100);
		_dyBitmap = _pdp->LYtoDY(pDocInfo->_yExtGoal*pDocInfo->_yScale / 100);
	}
													 
	_crCurTextColor = CLR_INVALID;

	_fRenderSelection = ped->GetSel() && ped->GetSel()->GetShowSelection();
	_fErase = !_pdp->IsTransparent();

	if(!ped->fInOurHost() || !_pdp->IsPrinter())
	{
		// If we are displaying to a window, or we are not in the window's
		// host, we use the colors specified by the host. For text and
		// foreground.
		_crBackground = ped->TxGetBackColor();
		_crTextColor  = ped->TxGetForeColor();
	}
	else
	{
		// When the window's host is printing, the default colors are white
		// for the background and black for the text.
		_crBackground = RGB_WHITE;
		_crTextColor  = RGB_BLACK;
	}

	_hdc = _pdp->GetDC();

	::SetBkColor (_hdc, _crBackground);
	_crCurBackground = _crBackground;

	// For hack around ExtTextOutW OnWin9x EMF problems
	_fEnhancedMetafileDC = IsEnhancedMetafileDC(_hdc);

	_fDisplayDC = GetDeviceCaps(_hdc, TECHNOLOGY) == DT_RASDISPLAY;

	// Set text alignment
	// Its much faster to draw using top/left alignment than to draw
	// using baseline alignment.
	SetTextAlign(_hdc, TA_TOP | TA_LEFT);
	SetBkMode(_hdc, TRANSPARENT);
}
 
/*
 * 	CRenderer::StartRender (&rcView, &rcRender)
 *
 *	@mfunc
 *		Prepare this renderer for rendering operations
 *
 *	@rdesc
 *		FALSE if nothing to render, TRUE otherwise	
 */
BOOL CRenderer::StartRender (
	const RECTUV &rcView,		//@parm View rectangle
	const RECTUV &rcRender)		//@parm Rectangle to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::StartRender");

	// Set view and rendering rects
	_rcView   = rcView;
	_rcRender = rcRender;

	// If this isn't a metafile, we set a flag indicating whether we
	// can safely erase the background
	if(_pdp->IsMetafile() || !_pdp->IsMain())
	{
		// Since this isn't the main display or it is a metafile,
		// we want to ignore the logic to render selections
		_fRenderSelection = FALSE;

		if(_fErase)							// If control is not transparent,
			EraseTextOut(_hdc, &rcRender);	//  clear display

		// This is a metafile or a printer so clear the render rectangle 
		// and then pretend we are transparent.
		_fErase = FALSE;
	}

	return TRUE;
}

/*
 *	CRenderer::EraseLine()
 *
 *	@mfunc
 *		Erase the line
 */
void CRenderer::EraseLine()
{
	Assert(_fEraseOnFirstDraw);
	COLORREF crOld = SetBkColor(_hdc, _crBackground);

	EraseTextOut(_hdc, &_rcErase);
	SetBkColor(_hdc, crOld);
	_fEraseOnFirstDraw = FALSE;
}

/*
 *	CRenderer::EraseRect(prc, crBack)
 *
 *	@mfunc
 *		Erase a specific rectangle for special table cell background color
 *
 *	@rdesc
 *		Old value of _fErase
 */
BOOL CRenderer::EraseRect(
	const RECTUV *prc,		//@parm RECT to erase
	COLORREF	  crBack)	//@parm Background color to use
{
	SetDefaultBackColor(crBack);
	EraseTextOut(_hdc, prc, TRUE);
	BOOL fErase = _fErase;
	_fErase = FALSE;
	return fErase;
}

/*
 *	CRenderer::IsSimpleBackground()
 *
 *	@mfunc
 *		Return TRUE if the background is opaque
 */
BOOL CRenderer::IsSimpleBackground() const
{
	CDocInfo *pDocInfo = GetPed()->GetDocInfoNC();

	if (!pDocInfo || pDocInfo->_nFillType != 7 && !IN_RANGE(1, pDocInfo->_nFillType, 3))
		return TRUE;
	return FALSE;
}

/*
 *	CRenderer::EraseTextOut(hdc, prc, fSimple)
 *
 *	@mfunc
 *		Erase a specific area
 */
void CRenderer::EraseTextOut(
	HDC		hdc,
	const RECTUV *prc,
	BOOL	fSimple)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::EraseTextOut");

	CDocInfo *pDocInfo = GetPed()->GetDocInfoNC();
	RECT	  rc;

	_pdp->RectFromRectuv(rc, *prc);

	if (fSimple || IsSimpleBackground())	// No special background
	{
		W32->EraseTextOut(hdc, &rc);
		return;
	}

	// To do background gradients and bitmap fills with rotated coords, need
	// to use rc as above and translate calls to _pdp->GetUpScroll() and
	// _pdp->GetVpScroll().	For directions other than tflowES get rid of
	// screen width and height offsets used in PointFromPointuv(), but keep
	// the minus signs.
	LONG	uScroll = _pdp->GetUpScroll();
	LONG	vScroll = _pdp->GetVpScroll();
	POINT	ptScroll = {uScroll, vScroll};	// Default unrotated

	TFLOW tflow = _pdp->GetTflow();
	switch(tflow)
	{
		case tflowSW:						// Vertical
			ptScroll.x = -vScroll;		
			ptScroll.y = uScroll;
			break;

		case tflowWN:
			ptScroll.x = -uScroll;
			ptScroll.y = -vScroll;
			break;

		case tflowNE:
			ptScroll.x = vScroll;
			ptScroll.y = -uScroll;
			break;
	}

	if(IN_RANGE(1, pDocInfo->_nFillType, 3))
	{
		if(!pDocInfo->_hBitmapBack)
			return;

		if(!_hdcBitmap)
		{
			// Setup compatible DC to use for background BitBlts for
			// the lifetime of this renderer
			_hdcBitmap = CreateCompatibleDC(hdc);
			if(!_hdcBitmap)
				return;						// Out of memory
			_hbitmapSave = (HBITMAP)SelectObject(_hdcBitmap, pDocInfo->_hBitmapBack);
		}

		LONG wBitmap = _dxBitmap;
		LONG hBitmap = _dyBitmap;

		LONG yb = (ptScroll.y + rc.top) % hBitmap;
		if(yb < 0)							
			yb += hBitmap;
		LONG h = hBitmap - yb;
		LONG y = rc.top;

		while(y < rc.bottom)
		{
			if(y + h > rc.bottom)			// Don't overshoot bottom
				h = rc.bottom - y;
			LONG xb = (ptScroll.x + rc.left) % wBitmap;
			if(xb < 0)						// xb can be < 0 if ptScroll.x < 0
				xb += wBitmap;
			LONG w = wBitmap - xb;
			LONG x = rc.left;

			while(x < rc.right)
			{
				if(x + w > rc.right)		// Don't overshoot right
					w = rc.right - x;
				BitBlt(hdc, x, y, w, h, _hdcBitmap, xb, yb, SRCCOPY);
				x += w; 
				w = wBitmap;
				xb = 0;
			}
			y += h;
			h = hBitmap;
			yb = 0;
		}
		return;
	}

	// Gradient fill backgrounds
	LONG	 Angle = pDocInfo->_sFillAngle;
	COLORREF crb = pDocInfo->_crColor;
	COLORREF crf = pDocInfo->_crBackColor;
	LONG	 di = ptScroll.x;				// Default vertical values
	LONG	 h = 0;
	HPEN	 hpen = NULL;
	HPEN	 hpenEntry = NULL;
	LONG	 iFirst = rc.left;
	LONG	 iLim = rc.right;
	LONG	 iShading;

	switch(Angle)
	{
		case -45:							// Diagonal down
		case -135:							// Diagonal	up
			h = rc.bottom - rc.top;
			if(Angle == -45)
			{
				di -= ptScroll.y + rc.top;
				iFirst -= h;
				h = -h;
			}
			else
			{
				di += ptScroll.y + rc.top;
				iLim += h;
			}
			break;

		case 0:								// Horizontal
			iFirst = rc.top;
			iLim = rc.bottom;
			di = ptScroll.y;
			break;
	}

	if(!crf)								// Moderate black a bit (needs work)
		crf = RGB(100, 100, 100);

	for(LONG i = iFirst; i < iLim; i++)
	{
		iShading = (di + i) % 600;
		if(iShading < 0)					// Pattern moves up screen
			iShading += 600;
		if(iShading > 300)
			iShading = 600 - iShading;

		iShading = max(iShading, 30);
		iShading = min(iShading, 270);

		if(hpen)
			DeleteObject(hpen);
		hpen = CreatePen(PS_SOLID, 0, GetShadedColor(crf, crb, iShading));
		if(!hpenEntry)
			hpenEntry = (HPEN)SelectObject(hdc, hpen);
		else
			SelectObject(hdc, hpen);

		POINT rgpt[2];
		if(Angle)							// -90 (vertical) or
		{									//  -135 (diagonal)
			if(i > rc.right)				// Don't let diagonal overshoot
			{
				rgpt[0].x = rc.right;
				rgpt[0].y = rc.top + (i - rc.right);
			}
			else
			{
				rgpt[0].x = i;
				rgpt[0].y = rc.top;
			}
			if(i - h < iFirst)				// Don't let diagonal undershoot
			{
				rgpt[1].x = iFirst - 1;
				rgpt[1].y = rc.bottom - (iFirst - 1 - (i - h));
			}
			else
			{
				rgpt[1].x = i - h;
				rgpt[1].y = rc.bottom;
			}
		}
		else								// Horizontal (0 degrees)
		{
			rgpt[0].x = rc.left;
			rgpt[0].y = i;
			rgpt[1].x = rc.right;
			rgpt[1].y = i;
		}
		Polyline(hdc, rgpt, 2);				// Use Polyline() so as not to
	}										//  break WinCE
	if(hpen)
	{
		DeleteObject(hpen);
		SelectObject(hdc, hpenEntry);
	}
}

/*
 *	CRenderer::DrawWrappedObjects(pliFirst, pliLast, cpFisrt, ptFirst, fLeft)
 *
 *	@mfunc
 *		Draw all wrapped objects in the range on the left or right side.
 *
 */
void CRenderer::DrawWrappedObjects(CLine *pliFirst, CLine *pliLast, LONG cpFirst, const POINTUV &ptFirst)
{
	for (BOOL fLeft = 0; fLeft != 2; fLeft ++) //For left and right sides...
	{
		CLine *pli = pliFirst;
		LONG cp = cpFirst;
		POINTUV pt = ptFirst;

		//If the first line is part-way through an object, then back up to the beginning.
		if (fLeft && pli->_cObjectWrapLeft || !fLeft && pli->_cObjectWrapRight)
		{
			while (fLeft ? !pli->_fFirstWrapLeft : !pli->_fFirstWrapRight)
			{
				pli--;
				pt.v -= pli->GetHeight();
				cp -= pli->_cch;
			}
		}

		for (;pli <= pliLast; cp += pli->_cch, pt.v += pli->GetHeight(), pli++)
		{
			//Did we find an object which needs to be drawn?
			if (fLeft && pli->_fFirstWrapLeft || !fLeft && pli->_fFirstWrapRight)
			{
				LONG cpObj = FindCpDraw(cp + 1, fLeft ? pli->_cObjectWrapLeft : pli->_cObjectWrapRight, fLeft);
				COleObject *pobj = GetObjectFromCp(cpObj);
				if (!pobj)
					return;

				LONG dvpAscent, dvpDescent, dup;
				pobj->MeasureObj(_dvpInch, _dupInch, dup, dvpAscent, dvpDescent, 0, GetTflow());

				POINTUV ptDraw = pt;
				if (!fLeft) //Right align images
					ptDraw.u += _pdp->GetDupView() - dup;

				RECTUV rc = {_rcRender.left, _rcView.top, _rcRender.right, _rcView.bottom};

				pobj->DrawObj(_pdp, _dvpInch, _dupInch, _hdc, &rc, _pdp->IsMetafile(), 
							 &ptDraw, dvpAscent + dvpDescent, 0, GetTflow());
				
			}
		}
	}
}

/*
 *	CRenderer::EndRender(pliFirst, pliLast, cpFirst, &ptFirst)
 *
 *	@mfunc
 *		Any final operations which are to happen after we've drawn
 *		all of the lines.
 */
void CRenderer::EndRender(
	CLine *	pliFirst, 
	CLine *	pliLast, 
	LONG	cpFirst, 
	const POINTUV &ptFirst)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::EndRender");
	AssertSz(_hdc, "CRenderer::EndRender() - No rendering DC");

	if(_fErase && _ptCur.v < _rcRender.bottom)
	{
		RECTUV rc = _rcRender;
		rc.top = _ptCur.v;
		EraseTextOut(_hdc, &rc);
	}
	DrawWrappedObjects(pliFirst, pliLast, cpFirst, ptFirst);
}

/*
 *	CRenderer::NewLine (&li)
 *
 *	@mfunc
 *		Init this CRenderer for rendering the specified line
 */
void CRenderer::NewLine (
	const CLine &li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::NewLine");

	_li = li;

	Assert(GetCp() + _li._cch <= GetTextLength());

	_cchLine = li._cch;
	_dupLine = _li._dup;
	_li._dup = 0;
	_ptCur.u = _rcView.left;
	if(!_pPF->InTable())
		_ptCur.u -= _pdp->GetUpScroll();
	_fSelected = _fSelectedPrev = FALSE;
}

/*
 *	CRenderer::SetupOffscreenDC(dup, dvp)
 *
 *	@mfunc
 *		Setup renderer for using an offscreen DC
 *
 *	@rdesc
 *		NULL - an error occurred<nl>
 *		~NULL - DC to save 
 */
HDC CRenderer::SetupOffscreenDC(
	LONG&	dup,		//@parm Offset to u
	LONG&	dvp,		//@parm Offset to v 
	BOOL fLastLine)
{
	// Save render DC
	CTxtEdit *ped		   = GetPed();
	BOOL	  fInOurHost   = ped->fInOurHost();

	HDC		hdcSave = _hdc;

	//If we've already erased (can't prevent flicker now!)
	//or this is some weird textflow, then don't do offscreens.
	if (!_fErase || GetTflow() != tflowES || ped->GetBackgroundType() != -1)
		return NULL;

	RECTUV rc;
	RECT rcBitmap;
	rc.left = _rcRender.left;
	rc.right = _rcRender.right;
	rc.top = _rc.top;
	rc.bottom = _rc.bottom;
	_pdp->RectFromRectuv(rcBitmap, rc);

	if (_osdc.GetDC() == NULL)
	{
		if (!_osdc.Init(_hdc, rcBitmap.right - rcBitmap.left, rcBitmap.bottom - rcBitmap.top, _crBackground))
			return NULL;

		HPALETTE hpal = fInOurHost ? ped->TxGetPalette() : (HPALETTE) GetCurrentObject(_hdc, OBJ_PAL);
		_osdc.SelectPalette(hpal);
	}
	else
	{
		LONG dx, dy;
		_osdc.GetDimensions(&dx, &dy);
		//REVIEW (keithcu) Simplify?
		if (IsUVerticalTflow(GetTflow()))
		{
			if (dx < rcBitmap.bottom - rcBitmap.top)
			{
				if (_osdc.Realloc(_rc.bottom - _rc.top + dy / 16, dy)) //Resize the bitmap, plus a little room
					return NULL;
			}

		}
		else if (dy < rcBitmap.bottom - rcBitmap.top)
		{
			if (_osdc.Realloc(dx, _rc.bottom - _rc.top + dy / 16)) //Resize the bitmap, plus a little room
				return NULL;
		}
	}

	_hdc = _osdc.GetDC();
	_crCurTextColor = CLR_INVALID;
	if(_pccs)
	{
		// There is current a character format for the run so we need to
		// get in sync with that since the offscreen DC isn't necessarily
		// set to that font.
		// Get the character format and set up the font
		SetFontAndColor(GetCF());
	}

	// We are rendering to a transparent background
	_fErase = FALSE;

	// Clear bitmap
	::SetBkColor(_hdc, _crBackground);
	_osdc.FillBitmap(rcBitmap.right - rcBitmap.left, rcBitmap.bottom - rcBitmap.top);

	//If the first line, erase to edge of rcRender
	if (_rc.top <= _rcView.top)
	{
		//Clear top of rcRender if necessary
		RECTUV rcErase = _rcRender;

		rcErase.top = min(_rcView.top, _rcRender.top);
		rcErase.bottom = _rc.top;

		if (rcErase.bottom > rcErase.top)
			EraseTextOut(hdcSave, &rcErase);
	}

	// Restore background color if necessary
	if(_crBackground != _crCurBackground)
		::SetBkColor(_hdc, _crCurBackground);

	SetBkMode(_hdc, TRANSPARENT);

	// Store v adjustment to use in rendering off-screen bitmap
	dvp = _rc.top;

	// Store u adjustment to use in rendering off-screen bitmap
	dup = _rcRender.left;

	// Normalize _rc, _rcView, & _rcRender
	ShiftRect(		_rc, dup, dvp);
	ShiftRect(	_rcView, dup, dvp);
	ShiftRect(_rcRender, dup, dvp);

	// Normalize _ptCur for rendering to off-screen bitmap
	_ptCur.u	-= dup;
	_ptCur.v	-= dvp;

	return hdcSave;
}

/*
 *	CRenderer::RenderOffscreenBitmap(hdc, dup, yAdj)
 *
 *	@mfunc
 *		Render off screen bitmap and restore the state of the render.
 */
void CRenderer::RenderOffscreenBitmap(
	HDC		hdc,		//@parm DC to render to
	LONG	dup,		//@parm offset to real u base
	LONG	dvp)		//@parm offset to real v base 
{	
	// Palettes for rendering bitmap
	HPALETTE hpalOld = NULL;
	HPALETTE hpalNew = NULL;

	// Restore pt
	_ptCur.u	+= dup;
	_ptCur.v	+= dvp;

	// Restore rect
	LONG dupTemp = -dup;
	LONG dvpTemp = -dvp;
	ShiftRect(		_rc, dupTemp, dvpTemp);
	ShiftRect(	_rcView, dupTemp, dvpTemp);
	ShiftRect(_rcRender, dupTemp, dvpTemp);

	// Create a palette if one is needed
	if(_plogpalette)
		W32->ManagePalette(hdc, _plogpalette, hpalOld, hpalNew);

	RECTUV rcuv = {dup, dvp, dup + _rcRender.right - _rcRender.left, dvp + _rc.bottom - _rc.top};
	RECT   rc;
	_pdp->RectFromRectuv(rc, rcuv);
	// Render bitmap to real DC and restore _ptCur & _rc
	_osdc.RenderBitMap(hdc, rc.left, rc.top, _rcRender.right - _rcRender.left, _rc.bottom - _rc.top);

	// Restore palette after render if necessary
	if(_plogpalette)				
	{
		W32->ManagePalette(hdc, _plogpalette, hpalOld, hpalNew);
		CoTaskMemFree(_plogpalette);
		_plogpalette = NULL;
	}

	// Restore HDC to actual render DC
	_hdc = hdc;

	// Set this flag to what it should be for restored DC
	_fErase = TRUE;

	_crCurTextColor = CLR_INVALID;

	// Reset screen DC font 
	// Set up font on non-screen DC
	// Force color resynch
	if(!FormatIsChanged())				// Not on a new block,
		SetFontAndColor(GetCF());		//  so just set font and color
	else
	{									// On new block,
		ResetCachediFormat();			//  so reset everything
		SetNewFont();
	}
}

/*
 *	CRenderer::RenderLine (&li, fLastLine)
 *
 *	@mfunc
 *		Render visible part of current line
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 *
 *	@devnote
 *		Only call this from CLine::RenderLine()
 */
BOOL CRenderer::RenderLine (
	CLine &	li,				//@parm Line to render
	BOOL	fLastLine)		//@parm True if last line in layout
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderLine");

	BYTE	bUnderlineSave = 0;
	LONG 	cch;
	LONG 	cchChunk;
	LONG	cchInTextRun;
	BOOL	fAccelerator = FALSE;
	const WCHAR * pstrToRender;
	CTempWcharBuf twcb;
	WCHAR	chPassword = GetPasswordChar();

	UpdatePF();

	// This is used as a temporary buffer so that we can guarantee that we will
	// display an entire format run in one ExtTextOut.
	WCHAR *	pszTempBuffer = NULL;

	NewLine(li);							// Init render at start of line
	_fLastChunk = FALSE;
	_ptCur.u += _li._upStart;				// Add in line left indent 

	// Allow for special rendering at start of line
	LONG cpSelMin, cpSelMost;
	LONG dup, dvp;
	HDC	 hdcSave = StartLine(li, fLastLine, cpSelMin, cpSelMost, dup, dvp);

	cch = _li._cch;
	if(chPassword && IsRich())
	{
		// It is kind of stupid to allow rich text password edit controls.
		// However, it does make it that much easier to create a password
		// edit control since you don't have to know to change the box to
		// plain. Anyway, if there is such a thing, we don't want to put
		// out password characters for EOPs in general and the final EOP
		// specifically. Therefore, the following ...
		if(_pdp->IsMultiLine())
			cch -= _li._cchEOP;
		else
			cch = GetPed()->GetAdjustedTextLength();
	}

	for(; cch > 0; cch -= cchChunk)
	{
		// Initial chunk (number of characters to render in a single TextOut)
		// is min between CHARFORMAT run length and line length. Start with
		// count of characters left in current format run
		cchChunk = GetCchLeftRunCF();
		AssertSz(cchChunk != 0, "empty CHARFORMAT run");

		DWORD dwEffects = GetCF()->_dwEffects;
		if(dwEffects & CFE_HIDDEN)			// Don't display hidden text
		{										
			Move(cchChunk);
			continue;
		}
		if(GetChar() == NOTACHAR)			// Ignore NOTACHAR code
		{
			Move(1);
			continue;
		}

		// Limit chunk to count of characters we want to display.
		cchChunk = min(cch, cchChunk);

		// Get count of characters in text run
		pstrToRender = _rpTX.GetPch(cchInTextRun);
		AssertSz(cchInTextRun > 0, "empty text run");

		if (cchInTextRun < cchChunk || chPassword || dwEffects & CFE_ALLCAPS)
		{
			// The count of contiguous chars in the backing store run is
			// less than the count of characters we wish to display or this
			// is a password control or we want all caps. We copy the data
			// out of the backing store.
			if(!pszTempBuffer)
			{
				// Allocate buffer big enough to handle all future
				// requests in this loop.
				pszTempBuffer = twcb.GetBuf(cch);
				if (!pszTempBuffer)
				{
					CCallMgr *	pcallmgr = GetPed()->GetCallMgr();

					if (pcallmgr)
						pcallmgr->SetOutOfMemory();

					return FALSE;			// Fail to allocate memory
				}
			}
			_rpTX.GetText(cchChunk, pszTempBuffer);
			pstrToRender = pszTempBuffer;	// Point at buffer
			if(chPassword)
			{
				// Fill buffer with password characters
				for (int i = 0, j = 0; i < cchChunk; i++)
				{
					if(!IN_RANGE(0xDC00, pszTempBuffer[i], 0xDFFF))
						pszTempBuffer[j++] = chPassword;
				}
				cch -= cchChunk - j;
				Move(cchChunk - j);
				cchChunk = j;
			}
			else if(dwEffects & CFE_ALLCAPS)
				CharUpperBuff(pszTempBuffer, cchChunk);
		}

		if(_cpAccelerator != -1)
		{
			LONG cpCur = GetCp();		// Get current cp

			// Does accelerator character fall in this chunk?
			if (cpCur < _cpAccelerator &&
				cpCur + cchChunk > _cpAccelerator)
			{
				// Yes. Reduce chunk to char just before accelerator
				cchChunk = _cpAccelerator - cpCur;
			}
			// Is this character the accelerator?
			else if(cpCur == _cpAccelerator)
			{							// Set chunk size to 1 since only
				cchChunk = 1;			//  want to output underlined char
				fAccelerator = TRUE;	// Tell downstream routines that
										//  we're handling accelerator
				_cpAccelerator = -1;	// Only 1 accelerator per line
			}
		}
		
		// Reduce chunk to account for selection if we are rendering for a
		// display that cares about selections.
		if(_fRenderSelection && cpSelMin != cpSelMost)
		{
			LONG cchSel = cpSelMin - GetCp();
			if(cchSel > 0)
				cchChunk = min(cchChunk, cchSel);

			else if(GetCp() < cpSelMost)
			{
				cchSel = cpSelMost - GetCp();
				if(cchSel >= cch)
					_fSelectToEOL = TRUE;
				else
					cchChunk = min(cchChunk, cchSel);

				_fSelected = TRUE;		// cpSelMin <= GetCp() < cpSelMost
			}							//  so current run is selected
		}

		// If start of CCharFormat run, select font and color
		if(FormatIsChanged() || _fSelected != _fSelectedPrev)
		{
			ResetCachediFormat();
			_fSelectedPrev = _fSelected;
			if(!SetNewFont())
				return FALSE;					// Failed
		}

		if(fAccelerator)
		{
			bUnderlineSave = _bUnderlineType;
			SetupUnderline(CFU_UNDERLINE, 0);
		}

		// Allow for further reduction of the chunk and rendering of 
		// interleaved rich text elements
		if(_li._fHasSpecialChars && RenderChunk(cchChunk, pstrToRender, cch))
		{
			AssertSz(cchChunk > 0, "CRenderer::RenderLine(): cchChunk == 0");
			_fSelected = FALSE;
			continue;
		}

		AssertSz(cchChunk > 0,"CRenderer::RenderLine() - cchChunk == 0");

		_fLastChunk = (cchChunk == cch);
		RenderText(pstrToRender, cchChunk);	// Render the text

		if(fAccelerator)
		{
			_bUnderlineType = bUnderlineSave;
			fAccelerator = FALSE;			// Turn off special accelerator
		}						 			//  processing
		Move(cchChunk);

		// Break if we went past right of render rect.
		if(_ptCur.u >= _rcRender.right)
		{
			cch -= cchChunk;
			break;
		}
	}

	EndLine(hdcSave, dup, dvp);
	Move(cch);
	return TRUE;						// Success
}

/*
 *	CRenderer::EndLine (hdcSave, dup, dvp)
 *
 *	@mfunc
 *		Finish up rendering of line, drawing table borders, rendering
 *		offscreen DC, and erasing to right of render rect if necessary.
 */
void CRenderer::EndLine(
	HDC	 hdcSave,
	LONG dup,
	LONG dvp)
{
	if(hdcSave)
		RenderOffscreenBitmap(hdcSave, dup, dvp);

	// Handle setting background color. We need to do this for each line 
	// because we return the background color to the default after each
	// line so that opaquing will work correctly.
	if(_crBackground != _crCurBackground)
	{
		::SetBkColor(_hdc, _crBackground);	// Tell window background color
		_crCurBackground = _crBackground;
	}
}

/*
 *	CRenderer::GetColorFromIndex (icr, fForeColor, pPF)
 *
 *	@mfunc
 *		Returns COLORREF corresponding to color index icr
 *
 *	@rdesc
 *		Get COLORREF corresponding to color index icr as follows:
 *		icr = 1 to 16 is g_Colors[icr-1]
 *		icr = 17 is pCF->_crTextColor
 *		icr = 18 is pCF->_crBackColor
 *		else CRenderer autocolor corresponding to fForeColor
 */
COLORREF CRenderer::GetColorFromIndex(
	LONG  icr,						//@parm Color index
	BOOL  fForeColor,				//@parm TRUE if foreground color (for autocolor)
	const CParaFormat *pPF) const	//@parm PF for two custom colors
{
	icr &= 0x1F;							// Mask off other indices

	if(!IN_RANGE(1, icr, 18))
		return fForeColor ? _crTextColor : _crBackground;	// autocolor

	if(IN_RANGE(1, icr, 16))				// One of standard 16 colors
		return g_Colors[icr - 1];

	// Two custom colors
	return (icr == 17) ? pPF->_crCustom1 : pPF->_crCustom2;
}

/*
 *	CRenderer::GetShadedColorFromIndices (icrf, icrb, iShading, pPF)
 *
 *	@mfunc
 *		Returns COLORREF corresponding to color index icr
 *
 *	@rdesc
 *		Get COLORREF corresponding to foreground/background indices
 *		icrf and icrb according to shading iShading
 */
COLORREF CRenderer::GetShadedColorFromIndices(
	LONG  icrf,						//@parm Foreground color index
	LONG  icrb,						//@parm Background color index
	LONG  iShading,					//@parm Shading in .01 percent
	const CParaFormat *pPF) const	//@parm PF for two custom colors
{
	Assert(iShading <= 200);

	COLORREF crb = GetColorFromIndex (icrb, FALSE, pPF);
	COLORREF crf = GetColorFromIndex (icrf, TRUE,  pPF);

	return GetShadedColor(crf, crb, (iShading*3)/2);
}

/*
 *	CRenderer::DrawTableBorders (pPF, u, vHeightRow, iDrawBottomLine, dulRow, pPFAbove)
 *
 *	@mfunc
 *		Draws table borders.  If iDrawBottomLine is nonzero, draw bottom line
 *		as well as others.  If iDrawBottomLine & 1, width of bottom line is
 *		included in vHeightRow; else if iDrawBottomLine is nonzero, draw bottom
 *		line immediately below the row and return the extra height.
 *
 *	@rdesc
 *		Extra dvp if extra bottom line is drawn
 */
LONG CRenderer::DrawTableBorders(
	const CParaFormat *pPF,		//@parm PF with cell data
	LONG  u,					//@parm u position to start table row borders
	LONG  vHeightRow,			//@parm Height of row
	LONG  iDrawBottomLine,		//@parm Flags on drawing bottom line
	LONG  dulRow,				//@parm Length of row
	const CParaFormat *pPFAbove)//@parm PF for row above
{
	CBrush	 brush(this);
	LONG	 cCell = pPF->_bTabCount;
	LONG	 cCellAbove = 0;
	COLORREF cr;
	LONG	 dupRow = LUtoDU(dulRow);
	LONG	 dvp = 0;
	LONG	 dxlLine;
	LONG	 dxlLinePrevRight = 0;
	LONG	 dxpLine;
	BOOL	 fHideGridlines = GetPed()->fHideGridlines() || !fDisplayDC();
	BOOL	 fRTLRow = pPF->IsRtl();
	LONG	 iCell;
	LONG	 icr;
	const CELLPARMS *prgCellParms = pPF->GetCellParms();
	const CELLPARMS *prgCellParmsAbove = NULL;
	LONG	 vTop = _ptCur.v;
	LONG	 vBot = vTop + vHeightRow;
	LONG	 v = vBot;

	if(pPFAbove)
	{
		prgCellParmsAbove = pPFAbove->GetCellParms();
		cCellAbove = pPFAbove->_bTabCount;
	}
	if(_fErase)
	{
		//Erase left and right edges of table
		LONG	cpSelMin, cpSelMost;
		RECTUV	rc = {_rcRender.left, vTop, u, vBot};

		EraseTextOut(_hdc, &rc);

		rc.left = u + dupRow;
		rc.right = _rcRender.right;
		EraseTextOut(_hdc, &rc);

		//If first line, erase to edge of rcRender
		if (rc.top <= _rcView.top)
			rc.top = _rcRender.top;
		rc.left = 0;
		rc.bottom = vTop;
		EraseTextOut(_hdc, &rc);

		// Display row selection mark if row is selected
		GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);
		Assert(_rpTX.IsAfterTRD(ENDFIELD));
		if(GetCp() <= cpSelMost && GetCp() > cpSelMin)
		{									// Row is selected
			COLORREF crSave = _crBackground;
			LONG	 dup;
			if(!_pccs)
				_pccs = GetCcs(GetCF());
			if(_pccs && _pccs->Include(' ', dup))
			{
				rc.left  = u + dupRow + 
					GetPBorderWidth(prgCellParms[cCell-1].GetBrdrWidthRight()/2);
				rc.right = rc.left + dup;
				rc.top	 = vTop + GetPBorderWidth(prgCellParms->GetBrdrWidthTop());
				rc.top++;
				rc.bottom= vBot;
				if(iDrawBottomLine & 1)
					rc.bottom = vBot - GetPBorderWidth(prgCellParms->GetBrdrWidthBottom());
				SetBkColor(_hdc, GetPed()->TxGetSysColor(COLOR_HIGHLIGHT));
				EraseTextOut(_hdc, &rc, TRUE);
				SetBkColor(_hdc, crSave);
			}
		}
	}

	if(iDrawBottomLine)					// Row bottom border
	{
		LONG dxp = GetPBorderWidth(prgCellParms->GetBrdrWidthLeft())/2;						
		LONG u1 = u - dxp;
		LONG u2 = u + dupRow;
		dxpLine = GetPBorderWidth(prgCellParms->GetBrdrWidthBottom());
		cr = GetColorFromIndex(prgCellParms->GetColorIndexBottom(), TRUE, pPF);
		if(iDrawBottomLine & 1)			// Line width incl in cell height
		{								// Don't draw left vertical lines
			v -= dxpLine;				//  over bottom line
			if(!dxpLine && !fHideGridlines)
				v--;					// Overlay cell bottom with gray
		}								//  gridline
		else							// Line width not incl in cell height
		{
			dvp = dxpLine;				// Return extra width due to bottom line
			if(!dxpLine && !fHideGridlines)
				dvp = 1;
			vBot += dvp;				// Set up outside vertical lines
		}
		brush.Draw(u1, v, u2, v, dxpLine, cr, fHideGridlines);
	}
	LONG uPrev, uCur = u;
	LONG dul = 0;
	LONG dup;

	if(fRTLRow)
		uCur = u + dupRow;

	for(LONG i = cCell; i >= 0; i--)
	{									
		// Draw cell side border		
		if(i)							// Left border
		{
			icr		 = prgCellParms->GetColorIndexLeft();
			dxlLine  = prgCellParms->GetBrdrWidthLeft();
			dxlLine	 = max(dxlLine, dxlLinePrevRight);
			dxlLinePrevRight = prgCellParms->GetBrdrWidthRight();
		}
		else							// Right border
		{								
			prgCellParms--;
			icr		 = prgCellParms->GetColorIndexRight();
			dxlLine  = dxlLinePrevRight;
			v = vBot;					// Be sure bottom right corner is square
		}
		cr = GetColorFromIndex(icr, TRUE, pPF);
		dxpLine = GetPBorderWidth(dxlLine);
		brush.Draw(uCur - dxpLine/2, vTop, uCur - dxpLine/2, v, dxpLine, cr, fHideGridlines);

		if(i)
		{
			dul += GetCellWidth(prgCellParms->uCell);	// Stay logical to
			dup = LUtoDU(dul);							//  avoid roundoff
			uPrev = uCur;
			uCur = u + dup;
			if(fRTLRow)
				uCur = u + dupRow - dup;
			if(!IsLowCell(prgCellParms->uCell))
			{								// Cell top border
				dxlLine = prgCellParms->GetBrdrWidthTop();
				if(prgCellParmsAbove)		// Choose thicker of this row's top
				{							//  & above row's bottom borders  
					iCell = prgCellParmsAbove->ICellFromUCell(dul, cCellAbove);
					if(iCell >= 0)
					{
						LONG dxlAbove = prgCellParmsAbove[iCell].GetBrdrWidthBottom();
						dxlLine = max(dxlLine, dxlAbove);
					}
				}
				dxpLine = GetPBorderWidth(dxlLine);
				cr = GetColorFromIndex(prgCellParms->GetColorIndexTop(), TRUE, pPF);
				brush.Draw(uPrev, vTop, uCur, vTop, dxpLine, cr, fHideGridlines);
			}
			prgCellParms++;
		}
	}
	if(prgCellParmsAbove && !pPFAbove->IsRtl())
	{										// Draw more top borders if row
		LONG dulAbove = 0;					//  above extends beyond current
		for(i = cCellAbove; i > 0; i--)		//  row (LTR rows only for now)
		{
			dulAbove += GetCellWidth(prgCellParmsAbove->uCell);
			if(dulAbove > dul)
			{
				dup = LUtoDU(dulAbove);
				if(i == 1)
					dup += GetPBorderWidth((prgCellParmsAbove->GetBrdrWidthRight()+1)/2);
				uPrev = uCur;
				uCur = u + dup;
				dxpLine = GetPBorderWidth(prgCellParmsAbove->GetBrdrWidthBottom());
				cr = GetColorFromIndex(prgCellParmsAbove->GetColorIndexBottom(), TRUE, pPFAbove);
				brush.Draw(uPrev, vTop, uCur, vTop, dxpLine, cr, fHideGridlines);
			}
			prgCellParmsAbove++;
		}
	}
	return dvp;
}

/*
 *	CRenderer::UpdatePalette (pobj)
 *
 *	@mfunc
 *		Stores palette information so that we can render any OLE objects
 *		correctly in a bitmap.
 */
void CRenderer::UpdatePalette(
	COleObject *pobj)		//@parm OLE object wrapper.
{
#ifndef NOPALETTE
	LOGPALETTE *plogpalette = NULL;
	LOGPALETTE *plogpaletteMerged;
	IViewObject *pviewobj;

	// Get IViewObject interface information so we can build a palette
	// to render the object correctly.
	if (((pobj->GetIUnknown())->QueryInterface(IID_IViewObject, 
		(void **) &pviewobj)) != NOERROR)
	{
		// Couldn't get it, so pretend this didn't happen
		return;
	}

	// Get logical palette information from object
	if(pviewobj->GetColorSet(DVASPECT_CONTENT, -1, NULL, NULL, 
			NULL, &plogpalette) != NOERROR || !plogpalette)
	{
		// Couldn't get it, so pretend this didn't happen
		goto CleanUp;
	}

	if(!_plogpalette)				
	{								// No palette entries yet
		_plogpalette = plogpalette;	// Just use the one returned
		goto CleanUp;
	}

	// We have had other palette entries. We just reallocate the table
	// and put the newest entry on the end. This is crude, we might
	// sweep the table and actually merge it. However, this code
	// should be executed relatively infrequently and therefore, crude
	// should be good enough.

	// Allocate a new table - Note the " - 1" in the end has to do with
	// the fact that LOGPALETTE is defined to have one entry already.
	AssertSz(_plogpalette->palNumEntries + plogpalette->palNumEntries >= 1,
		"CRenderer::UpdatePalette - invalid palettes to merge");
	plogpaletteMerged = (LOGPALETTE *) CoTaskMemAlloc(sizeof(LOGPALETTE) + 
		((_plogpalette->palNumEntries + plogpalette->palNumEntries - 1) * sizeof(PALETTEENTRY)));

	if(!plogpaletteMerged)				// Memory allocation failed
		goto CleanTempPalette;			// Just pretend it didn't happen

	// Copy in original table.
	memcpy(&plogpaletteMerged->palPalEntry[0], &_plogpalette->palPalEntry[0],
		_plogpalette->palNumEntries * sizeof(PALETTEENTRY));

	// Put new data at end
	memcpy(&plogpaletteMerged->palPalEntry[_plogpalette->palNumEntries], 
		&plogpalette->palPalEntry[0],
		plogpalette->palNumEntries * sizeof(PALETTEENTRY));

	// Set the version number and count
	plogpaletteMerged->palVersion = plogpalette->palVersion;
	plogpaletteMerged->palNumEntries = _plogpalette->palNumEntries 
		+ plogpalette->palNumEntries;

	// Replace current palette table with merged table
	CoTaskMemFree(_plogpalette);
	_plogpalette = plogpaletteMerged;

CleanTempPalette:
	CoTaskMemFree(plogpalette);

CleanUp:

	// Release object we got since we don't need it any more
	pviewobj->Release();
#endif // NOPALETTE
}


/*
 *	CRenderer::RenderChunk (&cchChunk, pchRender, cch)
 *
 *	@mfunc
 *		Method reducing the length of the chunk (number of character
 *		rendered in one RenderText) and to render items interleaved in text.
 *
 *	@rdesc	
 *		TRUE if this method actually rendered the chunk, 
 * 		FALSE if it just updated cchChunk and rendering is still needed
 */
BOOL CRenderer::RenderChunk(
	LONG &		 cchChunk,		//@parm in: chunk cch; out: # chars rendered
								//  if return TRUE; else # chars yet to render
	const WCHAR *pchRender,		//@parm pchRender render up to cchChunk chars
	LONG		 cch) 			//@parm # chars left to render on line
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderChunk");

	LONG		cchValid = cchChunk;
	LONG		i;
	const WCHAR *pchT;

	// Search for object in chunk
	for(pchT = pchRender, i = 0; i < cchValid && *pchT != WCH_EMBEDDING; i++)
		pchT++;

	if(i == 0)
	{
		// First character is object so display object
		COleObject *pobj = GetObjectFromCp(GetCp());
		if(pobj)
		{
			LONG dvpAscent, dvpDescent, dupObject;
			pobj->MeasureObj(_dvpInch, _dupInch, dupObject, dvpAscent, dvpDescent, _li._dvpDescent, GetTflow());

			if (W32->FUsePalette() && _li._fUseOffscreenDC && _pdp->IsMain())
			{
				// Keep track of palette needed for rendering bitmap
				UpdatePalette(pobj);
			}

			SetClipLeftRight(dupObject);

			pobj->DrawObj(_pdp, _dvpInch, _dupInch, _hdc, &GetClipRect(), _pdp->IsMetafile(), &_ptCur, 
						  _li._dvpHeight - _li._dvpDescent, _li._dvpDescent, GetTflow());

			_ptCur.u	+= dupObject;
			_li._dup += dupObject;
		}
		cchChunk = 1;
		// Both tabs and object code need to advance the run pointer past
		// each character processed.
		Move(1);
		return TRUE;
	}
	cchChunk -= cchValid - i;				// Limit chunk to char before object

	// Handle other special characters
	LONG cchT = 0;
	for(pchT = pchRender; cchT < cchChunk; pchT++, cchT++)
	{
		switch(*pchT)
		{
		case EURO: //NOTE: (keithcu) Euro's need this special logic only for printing/metafiles
		case TAB:
		case NBSPACE:
		case SOFTHYPHEN:
		case NBHYPHEN:
		case EMSPACE:
		case ENSPACE:
			break;
		default:
			continue;
		}
		break;
	}
	if(!cchT)
	{
		// First char is a tab, render it and any that follow
		if(*pchT == TAB)
			cchChunk = RenderTabs(cchChunk);
		else
		{
			WCHAR chT = *pchT;

			if (*pchT == NBSPACE)
				chT = ' ';
			else if (*pchT == NBHYPHEN || *pchT == SOFTHYPHEN)
				chT = '-';

			if(*pchT != SOFTHYPHEN || cch == 1)	// Only render hyphens/blank at EOL
				RenderText(&chT, 1);

			Move(1);					// Skip those within line
			cchChunk = 1;
		}
		Assert (cchChunk > 0);
		return TRUE;
	}
	cchChunk = cchT;		// Update cchChunk not to incl trailing tabs

	return FALSE;
}		

/*
 *	CRenderer::SetClipRect()
 *
 *	@mfunc
 *		Helper to set clipping rect for the line
 */
void CRenderer::SetClipRect()
{
	_rc = _rcRender;

	_rc.top = _ptCur.v;
	_rc.bottom = _rc.top + _li._dvpHeight;

	_rc.top = max(_rc.top, _rcView.top);
	_rc.bottom = min(_rc.bottom, _rcView.bottom);
}

/*
 *	CRenderer::SetClipLeftRight (dup)
 *
 *	@mfunc
 *		Helper to sets left and right of clipping/erase rect.
 *	
 *	@rdesc
 *		Sets _rc left and right	
 */
void CRenderer::SetClipLeftRight(
	LONG dup)		//@parm	Width of chunk to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::SetClipLeftRight");

	//Nominal value
	_rc.left = _ptCur.u;
	_rc.right = _rc.left + dup;

	//Constrain left and right based on rcView, rcRender
	_rc.left = max(_rc.left, _rcRender.left);

	_rc.right = max(_rc.right, _rc.left);
	_rc.right = min(_rc.right, _rcRender.right);
}
	
/*
 *	CRenderer::GetConvertMode()
 *
 *	@mfunc
 *		Return the mode that should really be used in the RenderText call
 */
CONVERTMODE	CRenderer::GetConvertMode()
{
	CONVERTMODE cm = (CONVERTMODE)_pccs->_bConvertMode;

	// For hack around ExtTextOutW Win95 problems.
	if (cm != CVT_LOWBYTE && W32->OnWin9x() && (_pdp->IsMetafile() || _fEnhancedMetafileDC))
		return CVT_WCTMB;

	if (cm != CVT_LOWBYTE && _pdp->IsMetafile() && !_fEnhancedMetafileDC)
		return CVT_WCTMB;	// WMF cant store Unicode so we cant use ExtTextOutW

	return cm;
}		

/*
 *	CRenderer::RenderExtTextOut (ptuv, fuOptions, prc, pwchRun, cch, rgdxp)
 *
 *	@mfunc
 *		Calls ExtTextOut and handles disabled text. There is duplicate logic in OlsDrawGlyphs, but
 *		the params are different so that was simplest way.
 *
 */
extern ICustomTextOut *g_pcto;
void CRenderer::RenderExtTextOut(
	POINTUV ptuv,
	UINT fuOptions, 
	RECT *prc, 
	PCWSTR pch, 
	UINT cch, 
	const INT *rgdxp)
{
	CONVERTMODE cm = GetConvertMode();

	if (prc->left >= prc->right || prc->top >= prc->bottom)
		return;

	DWORD dwETOFlags = GetTflow();
	if (_fFEFontOnNonFEWin9x)
		dwETOFlags |= fETOFEFontOnNonFEWin9x;
	if (_pccs->_fCustomTextOut)
		dwETOFlags |= fETOCustomTextOut;

	if(_fDisabled)
	{
		if(_crForeDisabled != _crShadowDisabled)
		{
			// The shadow should be offset by a hairline point, namely
			// 3/4 of a point.  Calculate how big this is in device units,
			// but make sure it is at least 1 pixel.
			DWORD offset = MulDiv(3, _dvpInch, 4*72);
			offset = max(offset, 1);

			// Draw shadow
			SetTextColor(_crShadowDisabled);

			POINTUV ptuvT = ptuv;
			ptuvT.u += offset;
			ptuvT.v += offset;
			POINT pt;
			_pdp->PointFromPointuv(pt, ptuvT, TRUE);
			
			W32->REExtTextOut(cm, _pccs->_wCodePage, _hdc, pt.x, pt.y,
				fuOptions, prc, pch, cch, rgdxp, dwETOFlags);

			// Now set drawing mode to transparent
			fuOptions &= ~ETO_OPAQUE;
			SetBkMode(_hdc, TRANSPARENT);
		}
		SetTextColor(_crForeDisabled);
	}

	POINT pt;
	_pdp->PointFromPointuv(pt, ptuv, TRUE);

	W32->REExtTextOut(cm, _pccs->_wCodePage, _hdc, pt.x, pt.y, fuOptions, prc, pch, cch, rgdxp, dwETOFlags);
}

/*
 *	CRenderer::RenderText (pch, cch)
 *
 *	@mfunc
 *		Render text in the current context of this CRenderer
 *
 *	@devnote
 *		Renders text only: does not do tabs or OLE objects
 */
void CRenderer::RenderText(
	const WCHAR *pch,	//@parm Text to render
	LONG cch)			//@parm Length of text to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderText");

	LONG		dvp, cchT;

	// Variables used for calculating length of underline.
	LONG		dupSelPastEOL = 0;
	BOOL		fCell = FALSE;
	UINT		fuOptions = _pdp->IsMain() ? ETO_CLIPPED : 0;
	LONG		dup;
	LONG		dupT;
	CTempBuf	rgdu;

	//Reset clip rectangle to greater of view/render rectangle
	_rc.left = _rcRender.left;
	_rc.right = _rcRender.right;

	// Trim all nondisplayable linebreaking chars off end
	while(cch && IsASCIIEOP(pch[cch - 1]))
		cch--;

	if(cch && pch[cch-1] == CELL)
	{
		fCell = TRUE;
		cch--;
	}
	
	int *pdu = (int *)rgdu.GetBuf(cch * sizeof(int));

	// Measure width of text to write so next point to write can be
	// calculated.
	dup = 0;

	for(cchT = 0; 
		cchT < cch && dup < _rc.right - _ptCur.u; 
		cchT++)
	{
		dupT = 0;
		if (!_pccs->Include(*pch, dupT))
		{
			TRACEERRSZSC("CRenderer::RenderText(): Error filling CCcs", E_FAIL);
			return;
		}

		if (pdu)
			*pdu++ = dupT;
  		pch++;
		dup += dupT;
	}

	// Go back to start of chunk
	cch = cchT;
	pch -= cch;
	if (pdu)
		pdu -= cch;

	if(_fLastChunk && _fSelectToEOL && _li._cchEOP)
	{
		// Use the width of the current font's space to highlight
		if(!_pccs->Include(' ', dupT))
		{
			TRACEERRSZSC("CRenderer::RenderText(): Error no length of space", E_FAIL);
			return;
		}
		dupSelPastEOL = dupT;
		dup += dupSelPastEOL;
		_fSelectToEOL = FALSE;			// Reset the flag
	}

	_li._dup += dup;

	// Setup for drawing selections via ExtTextOut.
 	if(_fSelected || _crBackground != _crCurBackground)
	{
		SetClipLeftRight(dup);
		if(_fSelected && fCell)
		{
			// Needs work, but this is a start. _rcRender has the cell
			// boundaries, so we need to use them on the right calls.
			_rc.right = _rcRender.right;
		}
		fuOptions = ETO_CLIPPED | ETO_OPAQUE;
	}

	dvp = _ptCur.v + _li._dvpHeight - _li._dvpDescent + _pccs->_yDescent - _pccs->_yHeight;
		
	LONG dvpOffset, dvpAdjust;
	_pccs->GetOffset(GetCF(), _dvpInch, &dvpOffset, &dvpAdjust);
	dvp -= dvpOffset + dvpAdjust;

	POINTUV ptuv = {_ptCur.u, dvp};
	RECT rc;
	_pdp->RectFromRectuv(rc, _rc);

	//For 1 char runs, we may need to swap the character we output.
	WCHAR ch;
	if (cch == 1)
	{
		switch(*pch)
		{
		case EMSPACE:
		case ENSPACE:
			ch = ' ';
			pch = &ch;
			break;
		}
	}

	RenderExtTextOut(ptuv, fuOptions, &rc, pch, cch, pdu);

	// Calculate width to draw for underline/strikeout
	// FUTURE (keithcu) Don't underline trailing spaces?
	if(_bUnderlineType != CFU_UNDERLINENONE	|| _fStrikeOut)
	{
		LONG dupToDraw = dup - dupSelPastEOL;
		LONG upStart = _ptCur.u;
		LONG upEnd = upStart + dupToDraw;
		
		upStart = max(upStart, _rcRender.left);

		upEnd = min(upEnd, _rcRender.right);

		dupToDraw = upEnd - upStart;

		if(dupToDraw > 0)
		{
			LONG y = _ptCur.v + _li._dvpHeight - _li._dvpDescent;

			y -= dvpOffset + dvpAdjust;

			// Render underline if required
			if(_bUnderlineType != CFU_UNDERLINENONE)
				RenderUnderline(upStart, y + _pccs->_dyULOffset, dupToDraw, _pccs->_dyULWidth);

			// Render strikeout if required
			if(_fStrikeOut)
				RenderStrikeOut(upStart, y + _pccs->_dySOOffset, dupToDraw, _pccs->_dySOWidth);
		}
	}

	_fSelected = FALSE;
	_ptCur.u += dup;					// Update current point
}

/*
 *	CRenderer::RenderTabs (cchMax)
 *
 *	@mfunc
 *		Render a span of zero or more tab characters in chunk *this
 *
 *	@rdesc
 *		number of tabs rendered
 *
 *	@devnote
 *		*this is advanced by number of tabs rendered
 *		MS - tabs should be rendered using opaquing rect of adjacent string
 */
LONG CRenderer::RenderTabs(
	LONG cchMax)	//@parm Max cch to render (cch in chunk)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderTabs");

	LONG cch = cchMax;
	LONG ch = GetChar();
	LONG chPrev = 0;
	LONG upTab, upTabs;
	
	for(upTabs = 0; cch && ch == TAB; cch--)
	{
		upTab	= MeasureTab(ch);
		_li._dup += upTab;				// Advance internal width
		upTabs	+= upTab;				// Accumulate width of tabbed
		Move(1);						//  region
		chPrev = ch;
		ch = GetChar();					   
	}

	if(_li._dup > _dupLine)
	{
		upTabs = 0;
		_li._dup = _dupLine;
	}

	if(upTabs)
	{
		LONG dup = 0;
		LONG upGap = 0;

		if(_fSelected && chPrev == CELL && ch != CR && _pPF->InTable())
		{
			LONG cpSelMin, cpSelMost;
			GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);
			if(GetCp() == cpSelMin || GetCp() == cpSelMost)
			{
				upGap = LUtoDU(_pPF->_dxOffset);
				if(GetCp() == cpSelMost)
				{
					dup = upGap;
					upGap = 0;
				}
			}
		}
		SetClipLeftRight(upTabs - dup);
		if(_rc.left < _rc.right)			// Something to erase
		{
			if(_fSelected)					// Use selection background color
			{
			    COLORREF cr = GetPed()->TxGetSysColor(COLOR_HIGHLIGHT);
				if (!UseXOR(cr))

				{
				    ::SetBkColor (_hdc, cr);
    				_crCurTextColor = GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);    				
				}
    			else
    			{ 
    			    const CCharFormat* pCF = GetCF();
    			    ::SetBkColor (_hdc, (pCF->_dwEffects & CFE_AUTOBACKCOLOR) ? 
    			                  _crBackground ^ RGB_WHITE : pCF->_crBackColor ^ RGB_WHITE);    		            		        
    				_crCurTextColor =  (pCF->_dwEffects & CFE_AUTOCOLOR) ? 
    				              _crTextColor ^ RGB_WHITE : pCF->_crTextColor ^ RGB_WHITE;    				
    			}
			}

			// Paint background with appropriate color
			if(_fSelected || _crBackground != _crCurBackground)
				EraseTextOut(_hdc, &_rc, TRUE);

			// Render underline if required
			dup = _rc.right - _rc.left;
			LONG vp = _ptCur.v + _li._dvpHeight - _li._dvpDescent;
			
			LONG dvpOffset, dvpAdjust;
			_pccs->GetOffset(GetCF(), _dvpInch, &dvpOffset, &dvpAdjust);
			vp -= dvpOffset + dvpAdjust;

			if(_bUnderlineType != CFU_UNDERLINENONE)
				RenderUnderline(_rc.left, vp + _pccs->_dyULOffset, dup, _pccs->_dyULWidth);

			// Render strikeout if required
			if(_fStrikeOut)
				RenderStrikeOut(_rc.left, vp +  _pccs->_dySOOffset, dup, _pccs->_dySOWidth);

			if(_fSelected)					// Restore colors
				::SetBkColor(_hdc, _crCurBackground);
		}
		_ptCur.u += upTabs;					// Update current point
	}
	return cchMax - cch;					// Return # tabs rendered
}

/*
 * 	CRenderer::SetNewFont()
 *
 *	@mfunc
 *		Select appropriate font and color in the _hdc based on the 
 *		current character format. Also sets the background color 
 *		and mode.
 *
 *	@rdesc
 *		TRUE if it succeeds
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
BOOL CRenderer::SetNewFont()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::SetNewFont");

	const CCharFormat	*pCF = GetCF();
	DWORD				dwEffects = pCF->_dwEffects;
	BOOL				fDisplay = fDisplayDC();

	// Release previous font in use
	if(_pccs)
		_pccs->Release();

	Assert(_fTarget == FALSE);
	_pccs = GetCcs(pCF);

	if(!_pccs)
	{
		TRACEERRSZSC("CRenderer::SetNewFont(): no CCcs", E_FAIL);
		return FALSE;
	}

	// Select font in _hdc
	AssertSz(_pccs->_hfont, "CRenderer::SetNewFont _pccs->_hfont is NULL");

	SetFontAndColor(pCF);
	
	// Assume no underlining
	_bUnderlineType = CFU_UNDERLINENONE;

	// We want to draw revision marks and native hyperlinks with underlining,
	// so just fake out our font information.
	if((dwEffects & (CFE_UNDERLINE | CFE_REVISED)) ||
	   (dwEffects & (CFE_LINKPROTECTED | CFE_LINK)) == CFE_LINK ||
	   fDisplay && GetTmpUnderline(pCF->_sTmpDisplayAttrIdx))
	{
		if (dwEffects & CFE_LINK)
			SetupUnderline(CFU_UNDERLINE, 0);
		else
		{
			BYTE bTmpUnderlineIdx = 0;

			if (fDisplay)
				bTmpUnderlineIdx = GetTmpUnderline(pCF->_sTmpDisplayAttrIdx);

			if (bTmpUnderlineIdx)
			{
				COLORREF	crTmpUnderline;

				GetTmpUnderlineColor(pCF->_sTmpDisplayAttrIdx, crTmpUnderline);
				SetupUnderline(bTmpUnderlineIdx, 0, crTmpUnderline);
			}
			else
				SetupUnderline(pCF->_bUnderlineType, pCF->_bUnderlineColor);
		}
	}

	_fStrikeOut = (dwEffects & (CFE_STRIKEOUT | CFE_DELETED)) != 0;
	return TRUE;
}

/*
 * 	CRenderer::SetupUnderline (bULType, bULColorIdx, crULColor)
 *
 *	@mfunc
 *		Setup internal variables for underlining
 */
void CRenderer::SetupUnderline(
	BYTE		bULType,
	BYTE		bULColorIdx,
	COLORREF	crULColor)
{
	_bUnderlineType	= bULType;
	_crUnderlineClr = crULColor;

	if (bULColorIdx)
		GetPed()->GetEffectColor(bULColorIdx, &_crUnderlineClr);
}

/*
 * 	CRenderer::UseXOR (cr)
 *
 *	@mfunc
 *		Return if reverse video selection should be used for the nominal
 *		selection color cr. RichEdit 1.0 mode always uses reverse video
 *		selection. Else use it if cr is too close to the current window
 *		background.
 *
 *	@rdesc
 *		Return if caller should use reverse video for cr
 */
BOOL CRenderer::UseXOR(
	COLORREF cr)		//@parm Color to compare _crBackground to
{
	return GetPed()->Get10Mode() ||
		(_crBackground != GetPed()->TxGetSysColor(COLOR_WINDOW) &&
			IsTooSimilar(_crBackground, cr));
}

/*
 * 	CRenderer::SetFontAndColor (pCF)
 *
 *	@mfunc
 *		Select appropriate font and color in the _hdc based on the 
 *		current character format. Also sets the background color 
 *		and mode.
 */
void CRenderer::SetFontAndColor(
	const CCharFormat *pCF)			//@parm Character format for colors
{
	CTxtEdit *ped = GetPed();

	_fDisabled = FALSE;
	if((pCF->_dwEffects & (CFE_AUTOCOLOR | CFE_DISABLED))
					   == (CFE_AUTOCOLOR | CFE_DISABLED))
	{		
		_fDisabled = TRUE;
		
		_crForeDisabled   = ped->TxGetSysColor(COLOR_3DSHADOW);
		_crShadowDisabled = ped->TxGetSysColor(COLOR_3DHILIGHT);
	}

	_fFEFontOnNonFEWin9x = FALSE;
	if (IsFECharRep(pCF->_iCharRep) && W32->OnWin9x() && !W32->OnWin9xFE())
		_fFEFontOnNonFEWin9x = TRUE;

	SelectFont(_hdc, _pccs->_hfont);

	// Compute height and descent if not yet done
	if(_li._dvpHeight == -1)
	{
		SHORT	dvpAdjustFE = _pccs->AdjustFEHeight(!fUseUIFont() && ped->_pdp->IsMultiLine());
		// Note: this assumes plain text 
		// Should be used only for single line control
		_li._dvpHeight  = _pccs->_yHeight + (dvpAdjustFE << 1);
		_li._dvpDescent = _pccs->_yDescent + dvpAdjustFE;
	}
	SetTextColor(GetTextColor(pCF));	// Set current text color

	COLORREF  cr;

	if(_fSelected)						// Set current background color
	{
	    cr = GetPed()->TxGetSysColor(COLOR_HIGHLIGHT);
	    if (UseXOR(cr))
		{
		    // There are 2 cases to be concerned with
		    // 1) if the background color is the same as the selection color or
		    // 2) if 1.0 Window and the background color is NOT system default
		    cr = (pCF->_dwEffects & CFE_AUTOBACKCOLOR) ?
		          _crBackground ^ RGB_WHITE : pCF->_crBackColor ^ RGB_WHITE;	    
		}
	}
	else if(!fDisplayDC() ||
		!(GetTmpBackColor(pCF->_sTmpDisplayAttrIdx, cr)))	// Any temp. background color?
	{															//	No, use regular background color
		if(pCF->_dwEffects & CFE_AUTOBACKCOLOR)
			cr = _crBackground;
		else													// Text run has some kind of back color
			cr = pCF->_crBackColor;
	}

	if(cr != _crCurBackground)
	{
		::SetBkColor(_hdc, cr);			// Tell window background color
		_crCurBackground = cr;			// Remember current background color
		_fBackgroundColor = _crBackground != cr; // Change render settings so we
	}									//  won't fill with background color
}

/*
 * 	CRenderer::SetDefaultBackColor (cr)
 *
 *	@mfunc
 *		Select given background color in the _hdc. Used for	setting
 *		background color in table cells.
 */
void CRenderer::SetDefaultBackColor(
	COLORREF cr)		//@parm Background color to use
{
	if(cr == tomAutoColor)
		cr = GetPed()->TxGetBackColor();		// Printer needs work...

	if(_crBackground != cr)
	{
		_crCurBackground = _crBackground = cr;
		::SetBkColor(_hdc, cr);
	}
}

/*
 * 	CRenderer::SetDefaultTextColor (cr)
 *
 *	@mfunc
 *		Select given foreground color in the _hdc. Used for	setting
 *		text color in table cells.
 */
void CRenderer::SetDefaultTextColor(
	COLORREF cr)		//@parm Background color to use
{
	if(cr == tomAutoColor)
		cr = GetPed()->TxGetForeColor();		// Printer needs work...

	if(_crTextColor != cr)
	{
		_crCurTextColor = _crTextColor = cr;
		::SetTextColor(_hdc, cr);
	}
}

/*
 * 	CRenderer::SetTextColor (cr)
 *
 *	@mfunc
 *		Select given text color in the _hdc
 *		Used to maintain _crCurTextColor cache
 */
void CRenderer::SetTextColor(
	COLORREF cr)			//@parm color to set in the dc
{
	if(cr != _crCurTextColor)
	{
		_crCurTextColor = cr;
		::SetTextColor(_hdc, cr);
	}
}

/*
 *	CRenderer::GetTextColor(pCF)
 *
 *	@mfunc
 *		Return text color for pCF. Depends on _bRevAuthor, display tech
 *
 *  FUTURE (keithcu) It might be nice to have black or blue selected text be
 *  white, but to have all other colors stay their other colors. What do we
 *	do if the backcolor is blue??
 *
 *	@rdesc	
 *		text color
 */
COLORREF CRenderer::GetTextColor(
	const CCharFormat *pCF)	//@parm CCharFormat specifying text color
{
	if(_fSelected)
	{
	    // There are 2 cases where XOR for selection is needed
	    // 1) if the background is the same as the selection background
	    // 2) if 1.0 window and the background isn't the system default window
	    // background color

	    // if this doesn't match the above case just return the cr
	    if (!UseXOR(GetPed()->TxGetSysColor(COLOR_HIGHLIGHT)))
	        return GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);

	    // xor the current text color for the selected text color
		return (pCF->_dwEffects & CFE_AUTOCOLOR) ? _crTextColor ^ RGB_WHITE :
		    pCF->_crTextColor ^ RGB_WHITE;
    }

	// The following could be generalized to return a different color for
	// links that have been visited for this text instance (need to define
	// extra CCharFormat::_dwEffects internal flag to ID these links)
	if((pCF->_dwEffects & (CFE_LINK | CFE_LINKPROTECTED)) == CFE_LINK)
	{
		// Blue doesnt show up very well against dark backgrounds.
		// In these situations, use the system selected text color.
		COLORREF crBackground = (pCF->_dwEffects & CFE_AUTOBACKCOLOR)
							  ? _crBackground :	pCF->_crBackColor;

		if (IsTooSimilar(crBackground, RGB_BLACK) || IsTooSimilar(crBackground, RGB_BLUE))
		{
			COLORREF crHighlightText = GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);
			if (IsTooSimilar(crBackground, crHighlightText))
			{
				// Background is similar to highlight, use window text color
				return GetPed()->TxGetSysColor(COLOR_WINDOWTEXT);
			}
			else
			{
				return crHighlightText;
			}
		}
		// If not high contrast, fall through
	}

	BOOL fDisplay = fDisplayDC();
#ifndef NODRAFTMODE
	// Use draft mode text color only for displays
	if (GetPed()->_fDraftMode && (!_hdc || fDisplay))
	{
		SHORT iFont;
		SHORT yHeight;
		QWORD qwFontSig;
		COLORREF crColor;

		if (W32->GetDraftModeFontInfo(iFont, yHeight, qwFontSig, crColor))
			return crColor;
	}
#endif

	// If we did not return the URL color via draft mode or the high contrast check, do it now
	if((pCF->_dwEffects & (CFE_LINK | CFE_LINKPROTECTED)) == CFE_LINK)
		return RGB_BLUE;

	if(pCF->_bRevAuthor)				// Rev author
	{
		// Limit color of rev authors to 0 through 7.
		return rgcrRevisions[(pCF->_bRevAuthor - 1) & REVMASK];
	}

	COLORREF cr = (pCF->_dwEffects & CFE_AUTOCOLOR)	? _crTextColor : pCF->_crTextColor;
	COLORREF crTmpTextColor;

	if(fDisplay && GetTmpTextColor(pCF->_sTmpDisplayAttrIdx, crTmpTextColor))
		cr = crTmpTextColor;

	if(cr == RGB_WHITE)					// Text is white
	{
		COLORREF crBackground = (pCF->_dwEffects & CFE_AUTOBACKCOLOR)
							  ? _crBackground :	pCF->_crBackColor;

		COLORREF crTmpBackground;
		if(fDisplay && GetTmpBackColor(pCF->_sTmpDisplayAttrIdx, crTmpBackground))
			crBackground = crTmpBackground;

		if(crBackground != RGB_WHITE)
		{
			// Background color isn't white, so white text is probably
			// visible unless display device is only black/white. So we
			// switch to black text on such devices.
			if (GetDeviceCaps(_hdc, NUMCOLORS) == 2 ||
				GetDeviceCaps(_hdc, TECHNOLOGY) == DT_PLOTTER)
			{
				cr = RGB_BLACK;
			}
		}
	}
	return cr;
}

extern BOOL g_OLSBusy;

/*
 *	CRenderer::StartLine(&li, fLastLine, &cpSelMin, &cpSelMost, &dup, &dvp)
 *
 *	@mfunc
 *		Render possible outline symbol and bullet if at start of line
 *
 *	@rdesc	
 *		hdcSave if using offscreen DC
 */
HDC CRenderer::StartLine(
	CLine &	li,			//@parm Line to render
	BOOL	fLastLine,	//@parm True if last line in layout
	LONG &	cpSelMin,	//@parm Out parm for current selection cpMin
	LONG &	cpSelMost,	//@parm Out parm for current selection cpMost
	LONG &	dup,		//@parm Offset to u
	LONG &	dvp)		//@parm Offset to v
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::StartLine");
	BOOL fDrawBack = !(GetCF()->_dwEffects & CFE_AUTOBACKCOLOR) && GetPed()->_fExtendBackColor;
	RECTUV rcErase = _rcRender;
	_fEraseOnFirstDraw = FALSE;

	GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);
	if(cpSelMost != cpSelMin && cpSelMost == GetCp())
		_fSelectedPrev = TRUE;

	LONG	 cpMost = GetCp() + _li._cch;
	COLORREF crPrev = 0xFFFFFFFF;
	BOOL	 fUseSelColors = FALSE;

	if (cpMost <= cpSelMost && cpMost - 1 >= cpSelMin &&
		_pPF->InTable() && _fRenderSelection)
	{
		CTxtPtr tp(_rpTX);
		tp.SetCp(cpMost);
		if(tp.GetPrevChar() == CELL)
		{
			fUseSelColors = TRUE;
			crPrev = ::SetBkColor(GetDC(), GetPed()->TxGetSysColor(COLOR_HIGHLIGHT));
		}
	}
	SetClipRect();

	HDC hdcSave = NULL;
	dup = dvp = 0;
	if(li._cch > 0 && li._fUseOffscreenDC)
	{
		// Set up an off-screen DC if we can. Note that if this fails,
		// we just use the regular DC which won't look as nice but
		// will at least display something readable.
		hdcSave = SetupOffscreenDC(dup, dvp, fLastLine);
		if(li._fOffscreenOnce)
			li._fUseOffscreenDC = li._fOffscreenOnce = FALSE;
	}

	rcErase.top = _ptCur.v;
	rcErase.bottom = min(rcErase.top + _li._dvpHeight, _rcRender.bottom);

	//If first line, erase to edge of rcRender
	if (rcErase.top <= _rcView.top)
		rcErase.top = _rcRender.top;

	//If last line, erase to bottom edge of rcRender
	if (fLastLine)
		rcErase.bottom = _rcRender.bottom;

	if (_fErase && !fDrawBack)
	{
		if(g_OLSBusy && IsSimpleBackground() && !fUseSelColors)
		{
			_fEraseOnFirstDraw = TRUE;
			_rcErase = rcErase;
		}
		else
			EraseTextOut(GetDC(), &rcErase);
	}

	// Fill line with background color if we are in fExtendBackColor mode
	if (fDrawBack || fUseSelColors)
	{
		// Capture old color so we reset it to what it was when we're finished
		COLORREF crOld = 0;
		if(fDrawBack)
			crOld = ::SetBkColor(GetDC(), GetCF()->_crBackColor);
		EraseTextOut(GetDC(), &_rc);

		// Reset background color to old color
		if(fDrawBack)
			::SetBkColor(GetDC(), crOld);

		//Erase the remainder of the background area
		if (_fErase)
		{
			RECTUV rcTemp = rcErase;
			//Erase the top part if necessary
			if (rcErase.top < _rc.top)
			{
				rcTemp.bottom = _rc.top;
				EraseTextOut(GetDC(), &rcTemp);
			}

			//Erase the left and right parts if necessary
			rcTemp.top = _rc.top;
			rcTemp.bottom = _rc.bottom;
			if (rcErase.left < _rc.left)
			{
				rcTemp.right = _rc.left;
				EraseTextOut(GetDC(), &rcTemp);
			}
			if (rcErase.right > _rc.right)
			{
				rcTemp.left = _rc.right;
				rcTemp.right = rcErase.right;
				EraseTextOut(GetDC(), &rcTemp);
			}
		}
	}

	if(crPrev != 0xFFFFFFFF)
		::SetBkColor(GetDC(), crPrev);

	if(IsRich() && _li._fFirstInPara && _pPF)
	{
		if(IsInOutlineView())
			RenderOutlineSymbol();

		if(_pPF->_wNumbering && !fUseLineServices())
			RenderBullet();	
	}

	// Reset format if there is special background color for previous line.
	// Otherwise, current line with the same format will not re-paint with the
	// special background color
	if (_fBackgroundColor)
	{
		_iFormat = -10;					// Reset to invalid format

		// Assume that there is no special background color for the line
		_fBackgroundColor = FALSE;
	}

	// Handle setting background color. If the current background
	// color is different than the default, we need to set the background
	// to this because the end of line processing reset the color so
	// that opaquing would work.
	if(_crBackground != _crCurBackground)
	{
		// Tell the window the background color
		::SetBkColor(_hdc, _crCurBackground);
		_fBackgroundColor = TRUE;
	}

	return hdcSave;
}

/*
 *	CRenderer::EraseToBottom()
 *
 *	@mfunc
 *		Erase from current display position to bottom of render RECT.
 *		Used by tables for last line in a display
 */
void CRenderer::EraseToBottom()
{
	if(_ptCur.v < _rcRender.bottom)
	{
		RECTUV rcErase = _rcRender;
		rcErase.top = _ptCur.v;
		EraseTextOut(GetDC(), &rcErase);
	}
}

/*
 *	CRenderer::RenderOutlineSymbol()
 *
 *	@mfunc
 *		Render outline symbol for current paragraph
 *
 *	@rdesc
 *		TRUE if outline symbol rendered
 */
BOOL CRenderer::RenderOutlineSymbol()
{
	AssertSz(IsInOutlineView(), 
		"CRenderer::RenderOutlineSymbol called when not in outline view");

	HBITMAP	hbitmap;
	LONG	height;
	LONG	width;
	LONG	up = _ptCur.u - _li._upStart + LUtoDU(lDefaultTab/2 * _pPF->_bOutlineLevel);
	LONG	vp = _ptCur.v;

	if(!g_hbitmapSubtext && InitializeOutlineBitmaps() != NOERROR)
		return FALSE;

    HDC hMemDC = CreateCompatibleDC(_hdc); // REVIEW: performance

    if(!hMemDC)
        return FALSE; //REVIEW: out of memory

	if(_pPF->_bOutlineLevel & 1)			// Subtext
	{
		width	= BITMAP_WIDTH_SUBTEXT;
		height	= BITMAP_HEIGHT_SUBTEXT;
		hbitmap	= g_hbitmapSubtext;
	}
	else									// Heading
	{
		width	= BITMAP_WIDTH_HEADING;
		height	= BITMAP_HEIGHT_HEADING;
		hbitmap	= g_hbitmapEmptyHeading;

		CPFRunPtr rp(*this);				// Check next PF for other
		LONG	  cch = _li._cch;		 	//  outline symbols

		if(_li._cch < rp.GetCchLeft())		// Set cch = count to heading
		{									//  EOP
			CTxtPtr tp(_rpTX);
			cch = tp.FindEOP(tomForward);
		}
		rp.Move(cch);						// Go to next paragraph
		if(rp.IsCollapsed())
			hbitmap	= g_hbitmapCollapsedHeading;

		else if(_pPF->_bOutlineLevel < rp.GetOutlineLevel())
			hbitmap	= g_hbitmapExpandedHeading;
	}

	if(!hbitmap)
		return FALSE;

    HBITMAP hbitmapDefault = (HBITMAP)SelectObject(hMemDC, hbitmap);

    // REVIEW: what if the background color changes?  Also, use a TT font
	// for symbols
	LONG dvpSymbol = _pdp->Zoom(height);
	LONG dvp = _li._dvpHeight - _li._dvpDescent - dvpSymbol;

	if(dvp > 0)
		dvp /= 2;
	else
		dvp = -dvp;

	POINTUV ptuv = {up, vp + dvp};
	POINT pt;
	_pdp->PointFromPointuv(pt, ptuv);
    StretchBlt(_hdc, pt.x, pt.y, _pdp->Zoom(width), dvpSymbol, hMemDC, 0, 0, width, height, SRCCOPY);

    SelectObject(hMemDC, hbitmapDefault);
    DeleteDC(hMemDC);
	return TRUE;
}

/*
 *	CRenderer::RenderBullet()
 *
 *	@mfunc
 *		Render bullet at start of line
 *
 *	@rdesc	
 *		TRUE if this method succeeded
 */
BOOL CRenderer::RenderBullet()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderBullet");

	AssertSz(_pPF->_wNumbering, 
		"CRenderer::RenderBullet called for non-bullet");

	// Width of the bullet character
	LONG dup;

	// FUTURE: Unicode bullet is L'\x2022' We want to migrate to this and
	// other bullets
	LONG		cch;
	CCharFormat CF;
	WCHAR		szBullet[CCHMAXNUMTOSTR];

	CCcs *pccs = GetCcsBullet(&CF);

	if(!pccs)								// Bullet is suppressed because
		return TRUE;						//  preceding EOP is VT

	if(_pccs)
		_pccs->Release();

	_pccs = pccs;

	// Default to no underline
	_bUnderlineType = CFU_UNDERLINENONE;

	if(_pPF->IsListNumbered() && CF._dwEffects & CFE_UNDERLINE)
		SetupUnderline(CF._bUnderlineType, CF._bUnderlineColor);

	SetFontAndColor(&CF);

	LONG dupLineSave = _dupLine;
	LONG dupOffset = LUtoDU(_pPF->_wNumberingTab ? _pPF->_wNumberingTab : _pPF->_dxOffset);
	LONG upSave	   = _ptCur.u;

	// Set-up to render bullet in one chunk
	cch = GetBullet(szBullet, _pccs, &dup);
	dupOffset = max(dupOffset, dup);
	_dupLine = dupOffset;
	if(IsInOutlineView())
		dupOffset = _li._upStart - LUtoDU(lDefaultTab/2 * (_pPF->_bOutlineLevel + 1));
	_ptCur.u -= dupOffset;
	switch(_pPF->_wNumberingStyle & 3)
	{
		case tomAlignCenter:
			dup /= 2;						// Fall thru to tomAlignRight

		case tomAlignRight:
			_ptCur.u -= dup;
	}

	// Render bullet
	_fLastChunk = TRUE;
	RenderText(szBullet, cch);

	// Restore render vars to continue with remainder of line.
	_ptCur.u = upSave;
	_dupLine = dupLineSave;
	_li._dup = 0;

	// This releases the _pccs that we put in for the bullet
	SetNewFont();
	return TRUE;
}

/*
 *	CRenderer::DrawLine(ptStart, ptEnd)
 *
 *	@mfunc
 *		Rotate the points passed and then call the OS.
 */
void CRenderer::DrawLine(const POINTUV &ptStart, const POINTUV &ptEnd)
{
	POINT rgpt[2];
	_pdp->PointFromPointuv(rgpt[0], ptStart);
	_pdp->PointFromPointuv(rgpt[1], ptEnd);

	Polyline(_hdc, rgpt, 2);
}

/*
 *	CRenderer::RenderUnderline(upStart, vpStart, dup, dvp)
 *
 *	@mfunc
 *		Render underline
 */
void CRenderer::RenderUnderline(
	LONG upStart, 	//@parm Horizontal start of underline
	LONG vpStart,	//@parm Vertical start of underline
	LONG dup,		//@parm Length of underline
	LONG dvp)		//@parm Thickness of underline
{
	BOOL	 fUseLS = fUseLineServices();
	COLORREF crUnderline = _crUnderlineClr;
	RECTUV	 rcT, rcIntersection;

	rcT.top		= vpStart;
	rcT.bottom	= vpStart + dvp;
	rcT.left	= upStart;
	rcT.right	= upStart + dup;

	if (!IntersectRect((RECT*)&rcIntersection, (RECT*)&_rcRender, (RECT*)&rcT))
		return;		// Underline not inside rc, forget it.
	upStart = rcIntersection.left;
	dup = rcIntersection.right - rcIntersection.left;
	vpStart = rcIntersection.top;
	dvp = rcIntersection.bottom - rcIntersection.top;

	if (crUnderline == tomAutoColor || crUnderline == tomUndefined)
	{
		crUnderline = _crCurTextColor;
	}

	if (_bUnderlineType != CFU_INVERT &&
		!IN_RANGE(CFU_UNDERLINEDOTTED, _bUnderlineType, CFU_UNDERLINEWAVE) &&
		!IN_RANGE(CFU_UNDERLINEDOUBLEWAVE, _bUnderlineType, CFU_UNDERLINETHICKLONGDASH))
	{
		// Regular single underline case
		// Calculate where to put underline
		rcT.top = vpStart;

		if (CFU_UNDERLINETHICK == _bUnderlineType)
		{
			if (rcT.top > _rcRender.top + dvp)
			{
				rcT.top -= dvp;
				dvp += dvp;
			}
		}

		// There are some cases were the following can occur - particularly
		// with bullets on Japanese systems.
		if(!fUseLS && rcT.top >= _ptCur.v + _li._dvpHeight)
			rcT.top = _ptCur.v + _li._dvpHeight - dvp;

		rcT.bottom	= rcT.top + dvp;
		rcT.left	= upStart;
		rcT.right	= upStart + dup;
		FillRectWithColor(&rcT, crUnderline);
		return;
	}

	if(_bUnderlineType == CFU_INVERT)			// Fake selection.
	{											// NOTE, not really
		rcT.top	= _ptCur.v;						// how we should invert text!!
		rcT.left = upStart;						// check out IME invert.
		rcT.bottom = rcT.top + _li._dvpHeight - _li._dvpDescent + _pccs->_yDescent;
		rcT.right = rcT.left + dup;

		RECT rc;
		_pdp->RectFromRectuv(rc, rcT);
  		InvertRect(_hdc, &rc);
		return;
	}

	if(IN_RANGE(CFU_UNDERLINEDOTTED, _bUnderlineType, CFU_UNDERLINEWAVE) ||
	   IN_RANGE(CFU_UNDERLINEDOUBLEWAVE, _bUnderlineType, CFU_UNDERLINETHICKLONGDASH))
	{
		static const char pen[] = {PS_DOT, PS_DASH, PS_DASHDOT, PS_DASHDOTDOT, PS_SOLID, 
			                       PS_SOLID, PS_SOLID, PS_SOLID, PS_SOLID, PS_DASH, PS_DASH,
		                           PS_DASHDOT, PS_DASHDOTDOT, PS_DOT, PS_DASHDOT};

		HPEN hPen = CreatePen(pen[_bUnderlineType - CFU_UNDERLINEDOTTED], 1, crUnderline);	
		if(hPen)
		{
			HPEN hPenOld = SelectPen(_hdc, hPen);
			LONG upEnd = upStart + dup;
			POINTUV ptStart, ptEnd;

			ptStart.u = upStart;
			ptStart.v = vpStart;
			if((_bUnderlineType == CFU_UNDERLINEWAVE) || 
			   (_bUnderlineType == CFU_UNDERLINEDOUBLEWAVE) ||
			   (_bUnderlineType == CFU_UNDERLINEHEAVYWAVE))
			{
				LONG dv	= 1;					// Vertical displacement
				LONG u	= upStart + 1;			// u coordinate
				upEnd++;						// Round up rightmost u
				for( ; u < upEnd; dv = -dv, u += 2)
				{
					ptEnd.u = u;
					ptEnd.v = vpStart + dv;
					DrawLine(ptStart, ptEnd);
					ptStart = ptEnd;
				}
			}
			else
			{
				ptEnd.u = upEnd;
				ptEnd.v = vpStart;
				DrawLine(ptStart, ptEnd);
			}

			if(hPenOld)							// Restore original pen.
				SelectPen(_hdc, hPenOld);

			DeleteObject(hPen);
		}
	}
}

/*
 *	CRenderer::RenderStrikeOut(upStart, vpStart, dup, dvp)
 *
 *	@mfunc
 *		Render strikeout
 */
void CRenderer::RenderStrikeOut(
	LONG upStart, 	//@parm start of strikeout
	LONG vpStart,	//@parm start of strikeout
	LONG dup,		//@parm Length of strikeout
	LONG dvp)		//@parm Thickness of strikeout
{
	RECTUV rcT, rcIntersection;

	// Calculate where to put strikeout rectangle 
	rcT.top		= vpStart;
	rcT.bottom	= vpStart + dvp;
	rcT.left	= upStart;
	rcT.right	= upStart + dup;

	if (!IntersectRect((RECT*)&rcIntersection, (RECT*)&_rcRender, (RECT*)&rcT))
		return;		// Line not inside rc, forget it.

	FillRectWithColor(&rcIntersection, GetTextColor(GetCF()));
}

/*
 *	CRenderer::FillRectWithTextColor(prc, cr)
 *
 *	@mfunc
 *		Fill input rectangle with current color of text
 */
void CRenderer::FillRectWithColor(
	const RECTUV *	 prc,		//@parm Rectangle to fill with color
	COLORREF cr)		//@parm Color to use
{
	// Create a brush with the text color
	HBRUSH hbrush = CreateSolidBrush(_fDisabled ? _crForeDisabled : cr);

	// Note if the CreateSolidBrush fails we just ignore it since there
	// isn't anything we can do about it anyway.
	if(hbrush)
	{
		// Save old brush
		HBRUSH hbrushOld = (HBRUSH)SelectObject(_hdc, hbrush);

		// Fill rectangle for underline
		RECT rc;
		_pdp->RectFromRectuv(rc, *prc);
		PatBlt(_hdc, rc.left, rc.top, rc.right - rc.left,
			   rc.bottom - rc.top, PATCOPY);
		SelectObject(_hdc, hbrushOld);	// Put old brush back
		DeleteObject(hbrush);			// Free brush we created.
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\range.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	RANGE.C - Implement the CTxtRange Class |
 *	
 *		This module implements the internal CTxtRange methods.
 *		See tomrange.cpp for the ITextRange methods.
 *
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	Revisions: <nl>
 *		AlexGo: update to runptr text ptr; floating ranges, multilevel undo
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_edit.h"
#include "_text.h"
#include "_rtext.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_disp.h"
#include "_uspi.h"
#include "_rtfconv.h"
#include "_txtbrk.h"
#include "_font.h"

#ifndef NOLINESERVICES
#include "_ols.h"
#endif

ASSERTDATA

WCHAR	szEmbedding[] = {WCH_EMBEDDING, 0};

// ===========================  Invariant stuff  ======================================================

#define DEBUG_CLASSNAME CTxtRange
#include "_invar.h"

#ifdef DEBUG
BOOL
CTxtRange::Invariant( void ) const
{
	LONG cpMin, cpMost;
	GetRange(cpMin, cpMost);

	Assert ( cpMin >= 0 );
	Assert ( cpMin <= cpMost );
	Assert ( cpMost <= GetTextLength() );
	Assert ( cpMin != cpMost || cpMost <= GetAdjustedTextLength());

	static LONG	numTests = 0;
	numTests++;				// how many times we've been called.

	// make sure the selections are in range.

	return CRchTxtPtr::Invariant();
}

BOOL CTxtRange::IsOneEndUnHidden() const
{
	CCFRunPtr rp(*this);
	rp.AdjustBackward();
	if(!rp.IsHidden())
		return TRUE;
	rp.AdjustForward();
	if(!rp.IsHidden())
		return TRUE;
	if(!_cch)
		return FALSE;
	rp.Move(-_cch);
	if(!rp.IsHidden())
		return TRUE;
	rp.AdjustBackward();
	if(!rp.IsHidden())
		return TRUE;
	return FALSE;
}

#endif

void CTxtRange::RangeValidateCp(LONG cp, LONG cch)
{
	LONG cchText = GetAdjustedTextLength();
	LONG cpOther = cp - cch;			// Calculate cpOther with entry cp

	_wFlags = FALSE;					// This range isn't a selection
	_iFormat = -1;						// Set up the default format, which
										//  doesn't get AddRefFormat'd
	ValidateCp(cpOther);				// Validate requested other end
	cp = GetCp();						// Validated cp
	if(cp == cpOther && cp > cchText)	// IP cannot follow undeletable
		cp = cpOther = SetCp(cchText, FALSE);//  EOP at end of story

	_cch = cp - cpOther;				// Store valid length
}

CTxtRange::CTxtRange(CTxtEdit *ped, LONG cp, LONG cch) :
	CRchTxtPtr(ped, cp)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

	RangeValidateCp(cp, cch);
	Update_iFormat(-1);					// Choose _iFormat

	CNotifyMgr *pnm = ped->GetNotifyMgr();

    if(pnm)
        pnm->Add( (ITxNotify *)this );
}

CTxtRange::CTxtRange(CRchTxtPtr& rtp, LONG cch) :
	CRchTxtPtr(rtp)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

	RangeValidateCp(GetCp(), cch);
	Update_iFormat(-1);					// Choose _iFormat

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

    if(pnm)
        pnm->Add( (ITxNotify *)this );
}

CTxtRange::CTxtRange(const CTxtRange &rg) :
	CRchTxtPtr((CRchTxtPtr)rg)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CTxtRange");

	_cch = rg._cch;
	_wFlags = FALSE;				// This range isn't a selection
	_iFormat = -1;					// Set up the default format, which
									//  doesn't get AddRefFormat'd
	Set_iCF(rg._iFormat);

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

    if(pnm)
        pnm->Add((ITxNotify *)this);
}

CTxtRange::~CTxtRange()
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::~CTxtRange");

	if(!IsZombie())
	{
		CNotifyMgr *pnm = GetPed()->GetNotifyMgr();
		if(pnm )
			pnm->Remove((ITxNotify *)this);
	}
	ReleaseFormats(_iFormat, -1);
}

CRchTxtPtr& CTxtRange::operator =(const CRchTxtPtr &rtp)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::operator =");

	_TEST_INVARIANT_ON(rtp)

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()

	CRchTxtPtr::operator =(rtp);
	Assert(FALSE);
	CheckChange(cpSave, FALSE);
	return *this;
}

CTxtRange& CTxtRange::operator =(const CTxtRange &rg)
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::operator =");

	_TEST_INVARIANT_ON( rg );

	LONG cchSave = _cch;			// Save entry _cp, _cch for change check
	LONG cpSave  = GetCp();

	CRchTxtPtr::operator =(rg);
	_cch = rg._cch;

	Update_iFormat(-1);
	_TEST_INVARIANT_

	if( _fSel && (cpSave != GetCp() || cchSave != _cch) )
		GetPed()->GetCallMgr()->SetSelectionChanged();

	return *this;
}

/*
 *	CTxtRange::OnPreReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *									cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		called when the backing store changes
 *
 *	@devnote
 *		1) if this range is before the changes, do nothing
 *
 *		2) if the changes are before this range, simply
 *		add the delta change to GetCp()
 *
 *		3) if the changes overlap one end of the range, collapse
 *		that end to the edge of the modifications
 *
 *		4) if the changes are completely internal to the range,
 *		adjust _cch and/or GetCp() to reflect the new size.  Note
 *		that two overlapping insertion points will be viewed as
 *		a 'completely internal' change.
 *
 *		5) if the changes overlap *both* ends of the range, collapse
 *		the range to cp
 *
 *		Note that there is an ambiguous cp case; namely the changes
 *		occur *exactly* at a boundary.  In this case, the type of
 *		range matters.  If a range is normal, then the changes
 *		are assumed to fall within the range.  If the range is
 *		is protected (either in reality or via DragDrop), then
 *		the changes are assumed to be *outside* of the range.
 */
void CTxtRange::OnPreReplaceRange (
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::OnPreReplaceRange");

	if(CONVERT_TO_PLAIN == cp)
	{
		// We need to dump our formatting because it is gone
		_rpCF.SetToNull();
		_rpPF.SetToNull();

		if(_fSel)
			GetPed()->_fUpdateSelection = TRUE;	

		Update_iFormat(-1);
		return;
	}
}

/*
 *	CTxtRange::OnPostReplaceRange (cp, cchDel, cchNew, cpFormatMin,
 *									cpFormatMax, pNotifyData)
 *
 *	@mfunc
 *		called when the backing store changes
 *
 *	@devnote
 *		1) if this range is before the changes, do nothing
 *
 *		2) if the changes are before this range, simply
 *		add the delta change to GetCp()
 *
 *		3) if the changes overlap one end of the range, collapse
 *		that end to the edge of the modifications
 *
 *		4) if the changes are completely internal to the range,
 *		adjust _cch and/or GetCp() to reflect the new size.  Note
 *		that two overlapping insertion points will be viewed as
 *		a 'completely internal' change.
 *
 *		5) if the changes overlap *both* ends of the range, collapse
 *		the range to cp
 *
 *		Note that there is an ambiguous cp case; namely the changes
 *		occur *exactly* at a boundary.  In this case, the type of
 *		range matters.  If a range is normal, then the changes
 *		are assumed to fall within the range.  If the range is
 *		is protected (either in reality or via DragDrop), then
 *		the changes are assumed to be *outside* of the range.
 */
void CTxtRange::OnPostReplaceRange (
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::OnPostReplaceRange");

	// NB!! We can't do invariant testing here, because we could
	// be severely out of date!

	LONG cchtemp;
	LONG cpMin, cpMost;
	LONG cchAdjTextLen;
	LONG delta = cchNew - cchDel;

	Assert (CONVERT_TO_PLAIN != cp);
	GetRange(cpMin, cpMost);
	
	// This range is before the changes. Note: an insertion pt at cp
	// shouldn't be changed
	if( cp >= cpMost )
	{
		if (pNotifyData)
		{
			if (pNotifyData->id == NOTIFY_DATA_TEXT_ID && 
				(pNotifyData->dwFlags & TN_TX_CELL_SHRINK))	// Rebind TX cp if cell number decrease.
				_rpTX.BindToCp(GetCp());							//	or else we may be using the wrong cell.
		}

		// Double check to see if we need to fix up our format
		// run pointers.  If so, all we need to do is rebind
		// our inherited rich text pointer

		if(cpFormatMin <= cpMost || cpFormatMin == CP_INFINITE)
			InitRunPtrs();

		else
		{
		 	// It's possible that the format runs changed anyway,
			// e.g., they became allocated, deallocated, or otherwise
			// changed.  Normally, BindToCp takes care of this
			// situation, but we don't want to pay that cost all
			// the time.
			//
			// Note that starting up the rich text subsystem will
			// generate a notification with cpFormatMin == CP_INFINITE
			//
			// So here, call CheckFormatRuns.  This makes sure that
			// the runs are in sync with what CTxtStory has
			// (doing an InitRunPtrs() _only_ if absolutely necessary).
			CheckFormatRuns();
		}
		return;
	}


	// Anywhere in the following that we want to increment the current cp by a
	// delta, we are counting on the following invariant.
	Assert(GetCp() >= 0);

	// Changes are entirely before this range.  Specifically,
	// that's determined by looking at the incoming cp *plus* the number
	// of characters deleted
	if(cp + cchDel < cpMin || _fDragProtection && cp + cchDel <= cpMin)
	{
		cchtemp = _cch;
		BindToCp(GetCp() + delta);
		_cch = cchtemp;
	}	
	// The changes are internal to the range or start within the
	// range and go beyond.
	else if( cp >= cpMin && cp <= cpMost )
	{
		// Nobody should be modifying a drag-protected range.  Unfortunately,
		// Ren re-enters us with a SetText call during drag drop, so we need
		// to handle this case 'gracefully'.
		if( _fDragProtection )
		{
			TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
		}

		if( cp + cchDel <= cpMost )
		{
			// Changes are purely internal, so
			// be sure to preserve the active end.  Basically, if
			// GetCp() *is* cpMin, then we only need to update _cch.
			// Otherwise, GetCp() needs to be moved as well
			if( _cch >= 0 )
			{
				Assert(GetCp() == cpMost);
				cchtemp = _cch;
				BindToCp(GetCp() + delta);
				_cch = cchtemp + delta;
			}
			else
			{
				BindToCp(GetCp());
				_cch -= delta;
			}

			// Special case: the range is left with only the final EOP
			// selected. This means all the characters in the range were
			// deleted so we want to move the range back to an insertion
			// point at the end of the text.
			cchAdjTextLen = GetAdjustedTextLength();

			if(GetCpMin() >= cchAdjTextLen && !GetPed()->IsStreaming())
			{
				// Reduce the range to an insertion point
				_cch = 0;

				// Set the cp to the end of the document.
				SetCp(cchAdjTextLen, FALSE);
			}
		}
		else
		{
			// Changes extended beyond cpMost.  In this case,
			// we want to truncate cpMost to the *beginning* of
			// the changes (i.e. cp)

			if( _cch > 0 )
			{
				BindToCp(cp);
				_cch = cp - cpMin;
			}
			else
			{
				BindToCp(cpMin);
				_cch = cpMin - cp;
			}
		}
	}
	else if( cp + cchDel >= cpMost )
	{
		// Nobody should be modifying a drag-protected range.  Unfortunately,
		// Ren re-enters us with a SetText call during drag drop, so we need
		// to handle this case 'gracefully'.
		if( _fDragProtection )
		{
			TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
		}

		// Entire range was deleted, so collapse to an insertion point at cp
		BindToCp(cp);
		_cch = 0;
	}
	else
	{
		// Nobody should be modifying a drag-protected range.  Unfortunately,
		// Ren re-enters us with a SetText call during drag drop, so we need
		// to handle this case 'gracefully'.
		if( _fDragProtection )
		{
			TRACEWARNSZ("REENTERED during a DRAG DROP!! Trying to recover!");
		}

		// The change crossed over just cpMin.  In this case move cpMin
		// forward to the unchanged part
		LONG cchdiff = (cp + cchDel) - cpMin;

		Assert( cp + cchDel < cpMost );
		Assert( cp + cchDel >= cpMin );
		Assert( cp < cpMin );

		cchtemp = _cch;
		if( _cch > 0 )
		{
			BindToCp(GetCp() + delta);
			_cch = cchtemp - cchdiff;
		}
		else
		{
			BindToCp(cp + cchNew);
			_cch = cchtemp + cchdiff;
		}
	}

	if( _fSel )
	{
		GetPed()->_fUpdateSelection = TRUE;		
		GetPed()->GetCallMgr()->SetSelectionChanged();
	}

	Update_iFormat(-1);					// Make sure _iFormat is up to date

	_TEST_INVARIANT_
}	

/*
 *	CTxtRange::Zombie ()
 *
 *	@mfunc
 *		Turn this range into a zombie (_cp = _cch = 0, NULL ped, ptrs to
 *		backing store arrays.  CTxtRange methods like GetRange(),
 *		GetCpMost(), GetCpMin(), and GetTextLength() all work in zombie mode,
 *		returning zero values.
 */
void CTxtRange::Zombie()
{
	CRchTxtPtr::Zombie();
	_cch = 0;
}

/*
 *	CTxtRange::CheckChange(cpSave, fExtend)
 *
 *	@mfunc
 *		Set _cch according to fExtend and set selection-changed flag if
 *		this range is a CTxtSelection and the new _cp or _cch differ from
 *		cp and cch, respectively.
 *
 *	@devnote
 *		We can count on GetCp() and cpSave both being <= GetTextLength(),
 *		but we can't leave GetCp() equal to GetTextLength() unless _cch ends
 *		up > 0.
 */
LONG CTxtRange::CheckChange(
	LONG cpSave,		//@parm Original _cp for this range
	BOOL fExtend)		//@parm Extend range iff TRUE
{
	LONG cchAdj = GetAdjustedTextLength();
	LONG cchSave = _cch;

	if(fExtend)									// Wants to be nondegenerate
	{											//  and maybe it is
		LONG cp = GetCp();

		_cch = cp - (cpSave - cchSave);
		CheckIfSelHasEOP(cpSave, cchSave);
	}
	else
	{
		_cch = 0;								// Insertion point
		_fSelHasEOP = FALSE;					// Selection doesn't contain
		_fSelExpandCell = FALSE;				//  any char, let alone a CR
		_nSelExpandLevel = 0;					//  or table cell or row
	}											

	if(!_cch && GetCp() > cchAdj)				// If still IP and active end
		CRchTxtPtr::SetCp(cchAdj);				//  follows nondeletable EOP,
												//  backspace over that EOP
	LONG cch = GetCp() - cpSave;
	_fMoveBack = cch < 0;

	if(cch || cchSave != _cch)
	{
		Update_iFormat(-1);
		if(_fSel)
			GetPed()->GetCallMgr()->SetSelectionChanged();

		_TEST_INVARIANT_
	}

	return cch;
}

/*
 *	CTxtRange::CheckIfSelHasEOP(cpSave, cchSave, fDoRange)
 *	
 *	@mfunc
 *		Maintains _fSelHasEOP = TRUE iff selection contains one or more EOPs.
 *		When cpSave = -1, calculates _fSelHasEOP unconditionally and cchSave
 *		is ignored (it's only used for conditional execution). Else _fSelHasEOP
 *		is only calculated for cases that may change it, i.e., it's assumed
 *		be up to date before the change.
 *
 *	@rdesc
 *		TRUE iff (_fSel or fDoRange) and _cch
 *
 *	@devnote
 *		Call after updating range _cch
 */
BOOL CTxtRange::CheckIfSelHasEOP(
	LONG cpSave,	//@parm Previous active end cp or -1
	LONG cchSave,	//@parm Previous signed length if cpSave != -1
	BOOL fDoRange)	//@parm Do function even if !_fSel
{
	// _fSelHasEOP only maintained for the selection
	if(!_fSel && !fDoRange)
		return FALSE;

	_fSelExpandCell = FALSE;			// Default no need to expand
	_nSelExpandLevel = 0;				// to table row/cell
	if(!_cch)
	{
		_fSelHasEOP  = FALSE;			// Selection doesn't contain
		return FALSE;					// CR, CELL or table row delims
	}

	LONG cpMin, cpMost;					
	LONG cpMinPrev  = cpSave;
	LONG cpMostPrev = cpSave;
	LONG FEOP_Results;

	GetRange(cpMin, cpMost);

	if(cpSave != -1)					// Selection may have changed
	{									
		if(cchSave > 0)					// Calculate previous cpMin
			cpMinPrev  -= cchSave;		//  and cpMost
		else
			cpMostPrev -= cchSave;

		if(!_fSelHasEOP && cpMin >= cpMinPrev && cpMost <= cpMostPrev)
			return TRUE;				// _fSelHasEOP can't change
	}									//  nor can _fSelHasCell/Row
	
	CTxtPtr tp(_rpTX);					
	if (!_fSelHasEOP || cpSave == -1 ||	// If any of these conditions, scan
		cpMin > cpMinPrev ||			//  range for an EOP. Could be
		cpMost < cpMostPrev)			//  CELL or CR. Table row delims have
	{									//  CRs, so catch them too
		tp.SetCp(cpMin);				
		tp.FindEOP(cpMost - cpMin, &FEOP_Results);
		_fSelHasEOP = (FEOP_Results & FEOP_EOP) != 0;
	}

	if(_fSelHasEOP && _rpPF.IsValid())	// Might have CELL or unmatched table
		CalcTableExpandParms();			//  row delim at range table level
	return TRUE;
}

/*
 *	CTxtRange::CalcTableExpandParms()
 *	
 *	@mfunc
 *		Calculate _fSelExpandCell and _nSelExpandLevel for ensuring that
 *		range selects a valid table piece (fraction of single cell,
 *		multiple, but not all, cells in a table row, one or more table
 *		rows.
 */
void CTxtRange::CalcTableExpandParms()
{
	LONG cpMin, cpMost;
	LONG cch = GetRange(cpMin, cpMost);
	CPFRunPtr rp(*this);

	if(_cch > 0)
		rp.Move(-_cch);					// Start at cpMin
	_fSelExpandCell = FALSE;			// Default no need to expand
	_nSelExpandLevel = 0;				// to table row/cell

	LONG cchRun;
	LONG LevelCpMin  = rp.GetTableLevel();
	LONG LevelCpMost = LevelCpMin;
	LONG LevelMin	 = LevelCpMin;
	LONG LevelTRDMin = tomForward;

	while(cch > 0)						// Walk range fast using PF runs
	{									//  gathering table level info
		LevelCpMost = rp.GetTableLevel();
		LevelMin = min(LevelMin, LevelCpMost);
		if(rp.IsTableRowDelimiter())
			LevelTRDMin = min(LevelTRDMin, LevelCpMost);
		cchRun = rp.GetCchLeft();
		cch -= cchRun;
		rp.Move(cchRun);
	}
	if(!(LevelCpMin | LevelCpMost))		// If beginning & end are 0, we're done
		return;

	if(LevelCpMin  >= LevelTRDMin ||	// Crossed a table-row delimiter
	   LevelCpMost >= LevelTRDMin)		//  of minimum level
	{
		Assert(LevelTRDMin < 16);		// Only nibble is allocated
		_nSelExpandLevel = LevelTRDMin;
		if(LevelTRDMin == LevelMin)
			return;						// Expand to LevelTRDMin
	}

	// At least one end has a table level < minimum table row delim level.
	// May need to expand to row, but check if a CELL is included
	// at the minimum level, in which case, need to expand to Cell.
	if(cch < 0)
		rp.Move(cch);					// rp is at cpMost

	LONG	cp = cpMost;
	CTxtPtr tp(_rpTX);

	for(cch = cpMost - cpMin; cch > 0; )
	{
		rp.AdjustBackward();
		Assert(rp.GetIch() || rp._iRun);
		if(rp.GetTableLevel() == LevelMin)
		{								// Only look for CELLs at min level
			LONG cchFind;
			cchRun = rp.GetIch();
			cchRun = min(cchRun, cch);
			tp.SetCp(cp);
			while(cchRun > 0)
			{
				if(tp.GetPrevChar() == CELL)
				{
					_fSelExpandCell = TRUE;
					_nSelExpandLevel = 0;
					return;				// Found a CELL at min level, so need
				}						//  to expand to Cell at that level
				cchFind = tp.FindEOP(-cchRun, NULL);
				if(!cchFind)
					break;
				cchRun += cchFind;
			}
		}
		cch -= rp.GetIch();				// Go back to previous PF run
		cp -= rp.GetIch();				// Cheaper to move cp than tp
		rp.SetIch(0);					// (might be at/before cpMin)
	}
}

/*
 *	CTxtRange::CheckTableSelection(fUpdate, fEnableExpandCell, pfTRDsInvolved, dwFlags)
 *	
 *	@mfunc
 *		Select only the first cell if one or more CELLs are selected, but
 *		not the whole row, at the minimum table level.
 *
 *	@rdesc
 *		TRUE iff selected only contents of first cell in range without the
 *		CELL mark
 */
BOOL CTxtRange::CheckTableSelection (
	BOOL  fUpdate,			//@parm Call Update() if change occurs
	BOOL  fEnableExpandCell,//@parm If TRUE select only 1st cell of multiple
	BOOL *pfTRDsInvolved,	//@parm Out parm to say if TRDs at range ends
	DWORD dwFlags)			//@parm Flags for ReplaceRange()
{
	LONG cpMin, cpMost;
	BOOL fRet = FALSE;
	BOOL fTRDsInvolved = FALSE;

	AdjustCRLF(1);
	if(!_cch)
	{
		while(_rpTX.IsAtTRD(0))
			AdvanceCRLF(CSC_NORMAL, FALSE);
		goto checkLP;
	}

	if(!_fSel && _rpPF.IsValid())			// It's a range; find out if
	{										//  tables are involved
		CPFRunPtr rp(*this);
		LONG cch = _cch;

		if(_cch > 0)						// Active end at cpMost: will
			rp.AdjustBackward();			//  scan backward

		while(!rp.InTable())
		{
			if(_cch > 0)
			{
				cch -= rp.GetIch();
				if(!rp.PrevRun())
					goto checkLP;			// Done, since not in table
				cch -= rp.GetCchLeft();
				if(cch <= 0)
					goto checkLP;			// Ditto
			}
			else
			{
				cch += rp.GetCchLeft();
				if(cch >= 0 || !rp.NextRun())
					goto checkLP;			// Not in table
			}
		}
		// Range fiddling with tables: calc whether to expand to cell or row
		// NB: expand to cell/row includes contained nested tables.
		CalcTableExpandParms();
		if(!_fSelExpandCell && _nSelExpandLevel)
		{									// Expand to row (but not to cell)
			FindRow(&cpMin, &cpMost, _nSelExpandLevel);
			Set(cpMost, cpMost - cpMin);
			_nSelExpandLevel = 0;
			fTRDsInvolved = TRUE;
			goto checkLP;
		}
	}
	if(_fSelExpandCell && fEnableExpandCell)// Partial row selected
	{										// Reduce selection to contents
		Collapser(TRUE);					//  of first cell
		while(_rpTX.IsAtTRD(STARTFIELD))
			AdvanceCRLF(CSC_NORMAL, FALSE);
		FindCell(&cpMin, &cpMost);
		Assert(cpMost > cpMin || _rpTX.GetChar() == CELL && _rpTX.IsAtStartOfCell());
		cpMost--;
		Set(cpMost, cpMost - cpMin);
		Assert(!_fSelExpandCell);
		if(fUpdate)
			Update(TRUE);
		fRet = TRUE;
	}
	if(pfTRDsInvolved)						// Caller wants to know if table-
	{										//  row-delimiters are involved
		CPFRunPtr rp(*this);
		rp.AdjustForward();
		fTRDsInvolved = TRUE;				// Default TRUE
		if(!rp.IsTableRowDelimiter())		// Check both sides of one end
		{
			rp.AdjustBackward();
			if(!rp.IsTableRowDelimiter())
			{
				rp.Move(-_cch);				// Check both sides of other end
				if(!rp.IsTableRowDelimiter())
				{
					rp.AdjustBackward();
					if(!rp.IsTableRowDelimiter())
						fTRDsInvolved = FALSE;// Neither end has TRD
				}
			}
		}
	}

checkLP:
	LONG iFormat = _iFormat;
	if(CheckLinkProtection(dwFlags, iFormat))
		Set_iCF(iFormat);

	if(pfTRDsInvolved)
		*pfTRDsInvolved = fTRDsInvolved;
	return fRet;
}

/*
 *	CTxtRange::CheckLinkProtection(&dwFlags, &iFormat)
 *
 *	@mfunc
 *		If friendly part of link is selected, select hidden part too.
 *
 *	@rdesc
 *		TRUE iff change made
 */
BOOL CTxtRange::CheckLinkProtection(
	DWORD & dwFlags,
	LONG  & iFormat)
{
	if(dwFlags & RR_NO_LP_CHECK)
		return FALSE;

	LONG	  cpMin, cpMost;
	LONG	  cch = GetRange(cpMin, cpMost);
	CCFRunPtr rp(*this);

	if(_cch > 0)							// Ensure rp is positioned at
		rp.Move(-_cch);						//  cpMin

	rp.AdjustBackward();
	DWORD dw = rp.GetEffects();
	if((dw & (CFE_LINKPROTECTED | CFE_HIDDEN)) == (CFE_LINKPROTECTED | CFE_HIDDEN))
	{
		if(_cch)
		{
			if(!cpMin)						// Already at start of inst field
				return FALSE;
											// If deleting rest of friendly
			while(cch >= 0)					//  hyperlink name, need to
			{								//  delete instruction field too
				if(!rp.IsLinkProtected())
				{
					FindAttributes(&cpMin, NULL, CFE_LINKPROTECTED | 0x80000000);
					Set(cpMin, cpMin - cpMost);
					return TRUE;
				}
				cch -= rp.GetCchLeft();
				rp.NextRun();
			}
		}
		else
		{
			// Inserting new text between hidden and friendly part of hyperlink:
			// back up over hidden part
			FindAttributes(&cpMin, NULL, CFE_LINKPROTECTED | 0x80000000);
			SetCp(cpMin, FALSE);
			dwFlags |= RR_UNHIDE;
			_rpCF.AdjustBackward();
			iFormat = _rpCF.GetFormat();
			return TRUE;
		}
	}
	else if(!(dw & CFE_LINK) && GetPed()->GetCharFormat(iFormat)->_dwEffects & CFE_LINK)
	{
		iFormat = rp.GetFormat();
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtRange::GetRange(&cpMin, &cpMost)
 *	
 *	@mfunc
 *		set cpMin  = this range cpMin
 *		set cpMost = this range cpMost
 *		return cpMost - cpMin, i.e. abs(_cch)
 *	
 *	@rdesc
 *		abs(_cch)
 */
LONG CTxtRange::GetRange (
	LONG& cpMin,				//@parm Pass-by-ref cpMin
	LONG& cpMost) const			//@parm Pass-by-ref cpMost
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetRange");

	LONG cch = _cch;

	if(cch >= 0)
	{
		cpMost	= GetCp();
		cpMin	= cpMost - cch;
	}
	else
	{
		cch		= -cch;
		cpMin	= GetCp();
		cpMost	= cpMin + cch;
	}
	return cch;
}

/*
 *	CTxtRange::GetCpMin()
 *	
 *	@mfunc
 *		return this range's cpMin
 *	
 *	@rdesc
 *		cpMin
 *
 *	@devnote
 *		If you need cpMost and/or cpMost - cpMin, GetRange() is faster
 */
LONG CTxtRange::GetCpMin() const
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCpMin");

	LONG cp = GetCp();
	return _cch <= 0 ? cp : cp - _cch;
}

/*
 *	CTxtRange::GetCpMost()
 *	
 *	@mfunc
 *		return this range's cpMost
 *	
 *	@rdesc
 *		cpMost
 *
 *	@devnote
 *		If you need cpMin and/or cpMost - cpMin, GetRange() is faster
 */
LONG CTxtRange::GetCpMost() const
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCpMost");

	LONG cp = GetCp();
	return _cch >= 0 ? cp : cp - _cch;
}

/*
 *	CTxtRange::Update(fScrollIntoView)
 *
 *	@mfunc
 *		Virtual stub routine overruled by CTxtSelection::Update() when this
 *		text range is a text selection.  The purpose is to update the screen
 *		display of the caret or	selection to correspond to changed cp's.
 *
 *	@rdesc
 *		TRUE
 */
BOOL CTxtRange::Update (
	BOOL fScrollIntoView)		//@parm TRUE if should scroll caret into view
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Update");

	return TRUE;				// Simple range has no selection colors or
}								//  caret, so just return TRUE

/*
 * CTxtRange::SetCp(cp, fExtend)
 *
 *	@mfunc
 *		Set active end of this range to cp. Leave other end where it is or
 *		collapse range depending on fExtend (see CheckChange()).
 *
 *	@rdesc
 *		cp at new active end (may differ from cp, since cp may be invalid).
 */
LONG CTxtRange::SetCp(
	LONG cp,			//@parm new cp for active end of this range
	BOOL fExtend)		//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtRange::SetCp");

	LONG cpSave = GetCp();

	CRchTxtPtr::SetCp(cp);
	CheckChange(cpSave, fExtend);			// NB: this changes _cp if after
	return GetCp();							//  final CR and _cch = 0
}

/*
 *	CTxtRange::Set (cp, cch)
 *	
 *	@mfunc
 *		Set this range's active-end cp and signed cch
 *
 *	@rdesc
 *		TRUE if range cp or cch changed.
 */
BOOL CTxtRange::Set (
	LONG cp,					//@parm Desired active end cp
	LONG cch)					//@parm Desired signed count of chars
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Set");

	BOOL bRet	 = FALSE;
	LONG cchSave = _cch;			// Save entry _cp, _cch for change check
	LONG cchText = GetAdjustedTextLength();
	LONG cpSave  = GetCp();
	LONG cpOther = cp - cch;		// Desired "other" end

	ValidateCp(cp);							// Be absolutely sure to validate
	ValidateCp(cpOther);					//  both ends

	if(cp == cpOther && cp > cchText)		// IP cannot follow undeletable
		cp = cpOther = cchText;				//  EOP at end of story

	CRchTxtPtr::Move(cp - GetCp());
	AssertSz(cp == GetCp(),
		"CTxtRange::Set: inconsistent cp");

	if(GetPed()->fUseCRLF())
	{
		cch = _rpTX.AdjustCRLF();
		if(cch)
		{
			_rpCF.Move(cch);			// Keep all 3 runptrs in sync
			_rpPF.Move(cch);
			cp = GetCp();
		}
		if(cpOther != cp)
		{
			CTxtPtr tp(_rpTX);
			tp.Move(cpOther - cp);
			cpOther += tp.AdjustCRLF();
		}
	}

	_cch = cp - cpOther;					// Validated _cch value
	CheckIfSelHasEOP(cpSave, cchSave);		// Maintain _fSelHasEOP in
											//  outline mode
	_fMoveBack = GetCp() < cpSave;

	if(cpSave != GetCp() || cchSave != _cch)
	{
		if(_fSel)
			GetPed()->GetCallMgr()->SetSelectionChanged();

		Update_iFormat(-1);
		bRet = TRUE;
	}
	
	_TEST_INVARIANT_
	return bRet;
}

/*
 *	CTxtRange::Move(cch, fExtend)
 *
 *	@mfunc
 *		Advance active end of range by cch.
 *		Other end stays put iff fExtend
 *
 *	@rdesc
 *		cch active end actually moved
 */
LONG CTxtRange::Move (
	LONG cch,			//@parm Signed char count to move active end
	BOOL fExtend)		//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Move");

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()
		
	CRchTxtPtr::Move(cch);
	return CheckChange(cpSave, fExtend);
}	

/*
 *	CTxtRange::AdvanceCRLF(csc, fExtend)
 *
 *	@mfunc
 *		Advance active end of range one char, treating CRLF as a single char.
 *		Other end stays put iff fExtend is nonzero.
 *
 *	@rdesc
 *		cch active end actually moved
 */
LONG CTxtRange::AdvanceCRLF(
	CSCONTROL csc,		//@parm Complex Script Control
	BOOL	  fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::AdvanceCRLF");

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()

	CRchTxtPtr::AdvanceCRLF();
#ifndef NOCOMPLEXSCRIPTS
	if(csc == CSC_SNAPTOCLUSTER)
		SnapToCluster(1);			// Snap to cluster forward
#endif
	return CheckChange(cpSave, fExtend);
}

/*
 *	CTxtRange::BackupCRLF(csc, fExtend)
 *
 *	@mfunc
 *		Backup active end of range one char, treating CRLF as a single char.
 *		Other end stays put iff fExtend
 *
 *	@rdesc
 *		cch actually moved
 */
LONG CTxtRange::BackupCRLF(
	CSCONTROL csc,		//@parm Complex Script Control
	BOOL	  fExtend)	//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::BackupCRLF");

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()
	
	CRchTxtPtr::BackupCRLF(csc != CSC_NOMULTICHARBACKUP);

#ifndef NOCOMPLEXSCRIPTS
	if(csc == CSC_SNAPTOCLUSTER)
		SnapToCluster(-1);			// Snap to cluster backward
#endif

	return CheckChange(cpSave, fExtend);
}

/*
 *	CTxtRange::AdjustCRLF(iDir)
 *
 *	@mfunc
 *		Adjust the position of this range's ends to the beginning of a CRLF
 *		or CRCRLF combination, if it is in the middle of such a combination.
 *		Move range end to the end of a Unicode surrogate pair or a STARTFIELD/
 *		ENDFIELD pair if it is in the middle of such a pair. Similarly move
 *		the range start to the beginning of such a pair.
 *
 *	@rdesc
 *		TRUE iff change occurred
 */
BOOL CTxtRange::AdjustCRLF(
	LONG iDir)		//@parm Move forward/backward for iDir = 1/-1, respectively
{
	LONG cch;
	if(!_cch)								// Insertion point
	{
		cch = _rpTX.AdjustCRLF(iDir);
		if(cch)
		{
			_rpCF.Move(cch);
			_rpPF.Move(cch);
			return TRUE;
		}
		return FALSE;
	}

	CTxtPtr tp(_rpTX);						// Nondegenerate range
	cch = _cch + tp.AdjustCRLF(_cch);		// Adjust active end

	LONG cp = tp.GetCp();					// Possibly new active end
	tp.Move(-cch);							// Go to other end
	cch -= tp.AdjustCRLF(-cch); 			// Calc its adjustment
	if(cch != _cch || cp != GetCp())		// If adjustment occurred,
	{										//  set new values
		Set(cp, cch);							
		return TRUE;
	}
	return FALSE;
}

/*
 *	CTxtRange::FindWordBreak(action, fExtend)
 *
 *	@mfunc
 *		Move active end as determined by plain-text FindWordBreak().
 *		Other end stays put iff fExtend
 *
 *	@rdesc
 *		cch active end actually moved
 */
LONG CTxtRange::FindWordBreak (
	INT  action,		//@parm action defined by CTxtPtr::FindWordBreak()
	BOOL fExtend)		//@parm Extend range iff TRUE
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtPtr::FindWordBreak");

	LONG cpSave = GetCp();			// Save entry _cp for CheckChange()

	CRchTxtPtr::FindWordBreak(action);
	return CheckChange(cpSave, fExtend);
}

/*
 *	CTxtRange::FlipRange()
 *
 *	@mfunc
 *		Flip active and non active ends
 */
void CTxtRange::FlipRange()
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::FlipRange");

	_TEST_INVARIANT_

	CRchTxtPtr::Move(-_cch);
	_cch = -_cch;
}

/*
 *	CTxtRange::HexToUnicode(publdr)
 *	
 *	@mfunc
 *		Convert hex number ending at this range's cpMost to a Unicode
 *		character and replace the hex number by that character. Take into
 *		account	Unicode surrogates for hex values from 0x10000 up to 0x10FFFF.
 *	
 *	@rdesc
 *		HRESULT S_OK if conversion successful and hex number is replaced by
 *		the corresponding Unicode character
 */
HRESULT CTxtRange::HexToUnicode (
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive antievents
{
	LONG ch;								// Handy char value
	LONG cpMin, cpMost;						// This range's cpMin and cpMost
	LONG cch = GetRange(cpMin, cpMost);		// Count of chars in range
	LONG i;									//  = cpMost - cpMin
	LONG lch = 0;							// Collects hex into binary value
	LONG cchSave = _cch;					// Save this range's cch
	LONG cpSave = GetCp();					//	and cp so we can restore in case of error

	if(cch)									// Range has cch chars selected
	{										//  so only convert these chars
		if(cpMost > GetAdjustedTextLength() || cch > 6)
			return S_FALSE;
		Collapser(tomEnd);					// Collapse range to IP at cpMost
	}
	else									// Range is insertion point so
		cch = 6;							//  check up to 6 prev chars
											
	// Convert preceding span of up to cch hexadigits to binary number (lch)
	for(i = 0; cch--; i += 4)				// i is shift count for hex
	{
		ch = GetPrevChar();					// ch = previous char
		if(ch == '+')						// Check for U+xxxx notation
		{									// If it's there, set up to
			Move(-1, TRUE);					//  delete the U+ (or u+)
			Move((GetPrevChar() | 0x20) == 'u' ? -1 : 1, TRUE);
			break;							// Else leave the +
		}
		if(ch > 'f' || !IsXDigit(ch))		// Break on nonhex chars
			break;
		Move(-1, TRUE);						// Move back one char
		ch |= 0x20;							// Convert hex to lower case if
		ch -= (ch >= 'a') ? 'a' - 10 : '0';	//  upper case; then to binary
		lch += (ch << i);					// Shift left & add in binary hex
	}

	if(!lch)								// No number: convert preceding
		return UnicodeToHex(publdr);		//  char back to hex

	if (lch > 0x10FFFF ||					// Don't insert numbers beyond Unicode's 17 planes
		IN_RANGE(0xD800, lch, 0xDFFF) ||	//	nor Unicode surrogate lead/trail word,
		IN_RANGE(STARTFIELD, lch,NOTACHAR)||//  nor internal use chars
		lch == CELL ||
		IsEOP(GetPrevChar()) && IN_RANGE(0x300, lch, 0x36F))
	{										// Note: CleanseAndReplaceRange suppresses others					
		Set(cpSave, cchSave);				// Restore previous selection	
		return S_FALSE;	
	}

	WCHAR str[2] = {(WCHAR)lch};
	cch = 1;								// Default one 16-bit code
	if(lch > 0xFFFF)						// Beyond BMP: so use  
	{										//  Unicode surrogate pair
		lch -= 0x10000;
		str[0] = 0xD800 + (lch >> 10);
		str[1] = 0xDC00 + (lch & 0x3FF);
		cch = 2;
	}
	if(publdr)								// If undo enabled, stop
		publdr->StopGroupTyping();			//  collecting typing string

	_rpCF.AdjustBackward();					// Use format of run preceding
	Set_iCF(_rpCF.GetFormat());				//  hex number
	_fUseiFormat = TRUE;
	_rpCF.AdjustForward();

	// Replace hexadigits with corresponding Unicode character choosing an
	// appropriate font if font preceding hex can't support character
	CleanseAndReplaceRange(cch, str, FALSE, publdr, NULL);
	return S_OK;
}

/*
 *	CTxtRange::UnicodeToHex(publdr)
 *	
 *	@mfunc
 *		Convert Unicode character(s) preceeding cpMin to a hex number and
 *		select it. Translate Unicode surrogates into corresponding for hex
 *		values from 0x10000 up to 0x10FFFF.
 *	
 *	@rdesc
 *		HRESULT S_OK if conversion successful and Unicode character(s) is
 *		replaced by corresponding hex number.
 */
HRESULT CTxtRange::UnicodeToHex (
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive antievents
{
	if(_cch)							// If there's a selection,
	{									//  convert 1st char in sel
		Collapser(tomStart);
		AdvanceCRLF(CSC_NORMAL, FALSE);
	}
	LONG cp = GetCp();
	if(!cp || _rpTX.IsAfterTRD(0))
		return S_FALSE;					// No character to convert

	_cch = 1;							// Select previous char
	LONG n = GetPrevChar();				// Get it

	if(n == CELL || IN_RANGE(STARTFIELD, n, NOTACHAR))
		return S_FALSE;					// Don't convert CELL marks

	if(publdr)
		publdr->StopGroupTyping();

	if(IN_RANGE(0xDC00, n, 0xDFFF))		// Unicode surrogate trail word
	{
		if(cp <= 1)						// No lead word
			return S_FALSE;
		Move(-2, TRUE);
		LONG ch = CRchTxtPtr::GetChar();
		Assert(IN_RANGE(0xD800, ch, 0xDBFF));
		n = (n & 0x3FF) + ((ch & 0x3FF) << 10) + 0x10000;
		_cch = -2;
	}

	// Convert ch to str
	LONG	cch = 0;
	LONG	quot, rem;					// ldiv results
	WCHAR	str[6];
	WCHAR *	pch = &str[0];

	for(LONG d = 1; d < n; d <<= 4)		// d = smallest power of 16 > n
		;								
	if(n && d > n)
		d >>= 4;

	while(d)
	{
		quot = n / d;					// Avoid an ldiv
		rem = n % d;
		n = quot + '0';
		if(n > '9')
			n += 'A' - '9' - 1;
		*pch++ = (WCHAR)n;				// Store digit
		cch++;
		n = rem;						// Setup remainder
		d >>= 4;
	}

	CleanseAndReplaceRange(cch, str, FALSE, publdr, NULL);
	_cch = cch;							// Select number

	if(_fSel)
		Update(FALSE);

	return S_OK;
}

/*
 *	CTxtRange::IsInputSequenceValid(pch, cchIns, fOverType, pfBaseChar)
 *
 *	@mfunc
 *		Verify the sequence of incoming text. Return FALSE if invalid
 *		combination	is found. The criteria is to allow any combinations
 *		that are displayable on screen (the simplest approach used by system
 *		edit control).
 *
 *	@rdesc
 *		Return FALSE if invalid combination is found; else TRUE.
 *
 *  	FUTURE: We may consider to support bad sequence filter or text streaming.
 *  	The code below can be extended easily enough to do so.
 */
BOOL CTxtRange::IsInputSequenceValid(
	WCHAR*	pch,			// Inserting string
	LONG	cchIns,			// Character count
	BOOL	fOverType,		// Insert or Overwrite mode
	BOOL*	pfBaseChar)		// Is pwch[0] a cluster start (base char)?
{
#ifndef NOCOMPLEXSCRIPTS
	CTxtEdit*		ped = GetPed();
	CTxtPtr 		tp(_rpTX);
	HKL				hkl = GetKeyboardLayout(0);
	BOOL			fr = TRUE;

	if (ped->fUsePassword() || ped->_fNoInputSequenceChk)
		return TRUE;		// no check when editing password

	if (PRIMARYLANGID(hkl) == LANG_VIETNAMESE)
	{
		// No concern about overtyping or cluster since we look backward only
		// 1 char and dont care characters following the insertion point.
		if(_cch > 0)
			tp.Move(-_cch);
		fr = IsVietCdmSequenceValid(tp.GetPrevChar(), *pch);
	}
	else if (PRIMARYLANGID(hkl) == LANG_THAI ||
		W32->IsIndicLcid(LOWORD(hkl)))
	{
		// Do complex things for Thai and Indic
	
		WCHAR			rgchText[32];
		WCHAR*			pchText = rgchText;
		CUniscribe*		pusp = ped->Getusp();
		CTxtBreaker*	pbrk = ped->_pbrk;
		LONG			found = 0;
		LONG			cp, cpSave, cpLimMin, cpLimMax;
		LONG			cchDel = 0, cchText, ich;
		LONG			cpEnd = ped->GetAdjustedTextLength();
	
		if (_cch > 0)
			tp.Move(-_cch);
	
		cp = cpSave = cpLimMin = cpLimMax = tp.GetCp();

		if (_cch)
		{
			cchDel = abs(_cch);
		}
		else if (fOverType && !tp.IsAtEOP() && cp != cpEnd)
		{
			// Delete up to the next cluster in overtype mode
			cchDel++;
			if (pbrk)
				while (cp + cchDel < cpEnd && !pbrk->CanBreakCp(BRK_CLUSTER, cp + cchDel))
					cchDel++;
		}
		cpLimMax += cchDel;
	
		// Figure the min/max boundaries
		if (pbrk)
		{
			// Min boundary
			cpLimMin += tp.FindEOP(tomBackward, &found);
			if (!(found & FEOP_EOP))
				cpLimMin = 0;
	
			while (--cp > cpLimMin && !pbrk->CanBreakCp(BRK_CLUSTER, cp));
			cpLimMin = max(cp, cpLimMin);		// more precise boundary
	
			// Max boundary
			cp = cpLimMax;
			tp.SetCp(cpLimMax);
			cpLimMax += tp.FindEOP(tomForward, &found);
			if (!(found & FEOP_EOP))
				cpLimMax = ped->GetTextLength();
	
			while (cp < cpLimMax && !pbrk->CanBreakCp(BRK_CLUSTER, cp++));
			cpLimMax = min(cp, cpLimMax);		// more precise boundary
		}
		else
		{
			// No cluster info we statically bound to -1/+1 from selection range
			cpLimMin--;
			cpLimMin = max(0, cpLimMin);
	
			cpLimMax += cchDel + 1;
			cpLimMax = min(cpLimMax, ped->GetTextLength());
		}
	
		cp = cpSave + cchDel;
		cchText = cpSave - cpLimMin + cchIns + cpLimMax - cp;
	
		tp.SetCp(cpLimMin);
	
		if (cchText > 32)
			pchText = new WCHAR[cchText];
	
		if (pchText)
		{
			// prepare text
			cchText = tp.GetText (cpSave - cpLimMin, pchText);
			tp.Move (cchText + cchDel);
			ich = cchText;
			wcsncpy (&pchText[cchText], pch, cchIns);
			cchText += cchIns;
			cchText += tp.GetText (cpLimMax - cpSave - cchDel, &pchText[cchText]);
			Assert (cchText == cpLimMax - cpLimMin - cchDel + cchIns);

			if (pusp)
			{
				SCRIPT_STRING_ANALYSIS	ssa;
				HRESULT					hr;
				BOOL					fDecided = FALSE;
	
				hr = ScriptStringAnalyse(NULL, pchText, cchText, GLYPH_COUNT(cchText), -1,
									SSA_BREAK, -1, NULL, NULL, NULL, NULL, NULL, &ssa);
				if (S_OK == hr)
				{
					if (fOverType)
					{
						const SCRIPT_LOGATTR* psla = ScriptString_pLogAttr(ssa);
						BOOL	fBaseChar = !psla || psla[ich].fCharStop;

						if (!fBaseChar)
						{
							// In overtype mode, if the inserted char is not a cluster start.
							// We act like insert mode. Recursive call with fOvertype = FALSE.
							fr = IsInputSequenceValid(pch, cchIns, 0, NULL);
							fDecided = TRUE;
						}

						if (pfBaseChar)
							*pfBaseChar = fBaseChar;
					}
					if (!fDecided && S_FALSE == ScriptStringValidate(ssa))
						fr = FALSE;
	
					ScriptStringFree(&ssa);
				}
			}
			if (pchText != rgchText)
				delete[] pchText;
		}
	}
	return fr;
#else
	return TRUE;
#endif // NOCOMPLEXSCRIPTS
}

/*
 *	CTxtRange::CleanseAndReplaceRange(cch, *pch, fTestLimit, publdr,
 *									  pchD, pcchMove, dwFlags)
 *	@mfunc
 *		Cleanse the string pch (replace CRLFs by CRs, etc.) and substitute
 *		the resulting string for the text in this range using the CCharFormat
 *		_iFormat and updating other text runs as needed. For single-line
 *		controls, truncate on the first EOP and substitute the truncated
 *		string.  Also truncate if string would overflow the max text length.
 *	
 *	@rdesc
 *		Count of new characters added
 */
LONG CTxtRange::CleanseAndReplaceRange (
	LONG			cchS,		//@parm Length of replacement (Source) text
	const WCHAR *	pchS,		//@parm Replacement (Source) text
	BOOL			fTestLimit,	//@parm Whether to do limit test
	IUndoBuilder *	publdr,		//@parm UndoBuilder to receive antievents
	WCHAR *			pchD,		//@parm Destination string (multiline only)
	LONG*			pcchMove,	//@parm Count of chars moved in 1st replace
	DWORD			dwFlags)	//@parm ReplaceRange's flags
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::CleanseAndReplaceRange");

	CTxtEdit *	   ped = GetPed();
	BYTE		   iCharRepDefault;
	LONG		   cchM = 0;
	LONG		   cchMove = 0;
	LONG		   cchNew = 0;				// Collects total cch inserted
	LONG		   cch;						// Collects cch for cur charset
	DWORD		   ch, ch1;
	WCHAR		   chPassword = ped->TxGetPasswordChar();
	LONG		   cpFirst = GetCpMin();
	QWORD		   qw = 0;
	QWORD		   qwCharFlags = 0;
	QWORD		   qwCharMask = GetCharRepMask();
	DWORD		   dwCurrentFontUsed = 0;
	BOOL		   f10Mode = ped->Get10Mode();
	BOOL		   fCallerDestination = pchD != 0;	// Save if pchD enters as 0
	BOOL		   fDefFontHasASCII = FALSE;
	CFreezeDisplay fd(ped->_pdp);
	BOOL		   fDefFontSymbol = qwCharMask == FSYMBOL;
	BOOL		   fFEBaseFont;
	BOOL		   fMultiLine	= ped->_pdp->IsMultiLine();
	BOOL		   fSurrogate;
	bool		   fUIFont		= fUseUIFont();
	BOOL		   fUseCRLF		= ped->fUseCRLF();

	const WCHAR *  pch = pchS;
	CTempWcharBuf  twcb;					// Buffer needed for multiline if pchD = 0
	CCharFormat		CFCurrent;				// Current CF used during IME composition

	const	DWORD	fALPHA = 0x01;
	BOOL			fDeleteChar = !ped->_fIMEInProgress && !ped->IsRich() && _cch;

	DWORD			dwFlagsSave = dwFlags;
	LONG			iFormatCurrent = GetiFormat();

	dwFlags = (dwFlags & ~7) | RR_ITMZ_NONE;
	if (ped->_fIMEInProgress)
	{
		// Initialize data to handle alpha/ASCII dual font mode
		// during IME composition
		dwCurrentFontUsed = FFE;
		CFCurrent = *ped->GetCharFormat(iFormatCurrent);

		UINT	iCharRepKB = GetKeyboardCharRep(0);
		if (iCharRepKB != CFCurrent._iCharRep && IsFECharRep(iCharRepKB))
		{
			CCFRunPtr	rp(_rpCF, ped);
			int			iFormatFound = iFormatCurrent;
			CCharFormat	CFTemp;

			// Search the range for font that support this keyboard
			if(rp.GetPreferredFontInfo(iCharRepKB, CFTemp._iCharRep, CFTemp._iFont, CFTemp._yHeight,
				CFTemp._bPitchAndFamily, -1, MATCH_CURRENT_CHARSET, &iFormatFound) 
				&& iFormatFound != iFormatCurrent)
			{
				CFCurrent = *ped->GetCharFormat(iFormatFound);
			}
		}
	}

	// Check if default font supports full ASCII and Symbol
	if (fUIFont)
	{
		QWORD qwMaskDefFont = GetCharRepMask(TRUE);
		fDefFontHasASCII = (qwMaskDefFont & FASCII) == FASCII;
		fDefFontSymbol = qwMaskDefFont == FSYMBOL;
		iCharRepDefault = ped->GetCharFormat(-1)->_iCharRep;
	}
	else
		iCharRepDefault = ped->GetCharFormat(iFormatCurrent)->_iCharRep;

	fFEBaseFont	= IsFECharRep(iCharRepDefault);
	if(!pchS)
		cchS = 0;
	else if(fMultiLine)
	{
		if(cchS < 0)						// Calculate length for
			cchS = wcslen(pchS);			//  target buffer
		if(cchS && !pchD)
		{
			pchD = twcb.GetBuf(cchS);
			if(!pchD)						// Couldn't allocate buffer:
				return 0;					//  give up with no update
		}
		pch = pchD;
	}
	else if(cchS < 0)						// Calculate string length
		cchS = tomForward;					//  while looking for EOP

	WORD fDontUpdateFmt = _fDontUpdateFmt;
	_fDontUpdateFmt = TRUE;
	for(cch = 0; cchS; cchS--)
	{										
		ch = *pchS;							
		if(!ch && (!fMultiLine || !fCallerDestination))
			break;

		if(IN_RANGE(CELL, ch, CR))			// Handle CR and LF combos
		{
			if(!fMultiLine && !IN_RANGE(8, ch, 9))// Truncate at 1st EOP to
				break;						//  be compatible with user.exe SLE
											//  and for consistent behavior
			if(ch == CR && !f10Mode)
			{
				if(cchS > 1)
				{
					ch1 = *(pchS + 1);
					if(cchS > 2 && ch1 == CR && *(pchS+2) == LF)
					{
						if(fUseCRLF)
						{
							*pchD++ = ch;
							*pchD++ = ch1;
							ch = LF;
							cch += 2;
						}
						else
						{
							// Translate CRCRLF to CR or to ' '
							ch = ped->fXltCRCRLFtoCR() ? CR : ' ';	
						}
						pchS += 2;			// Bypass two chars
						cchS -= 2;
					}
					else if(ch1 == LF)
					{
						if(fUseCRLF)		// Copy over whole CRLF
						{
							*pchD++ = ch;	// Here we copy CR
							ch = ch1;		// Setup to copy LF
							cch++;
						}
						pchS++;
						cchS--;
					}
				}
			}
			else if(!fUseCRLF && ch == LF)	// Treat lone LFs as EOPs, i.e.,
				ch = CR;					//  be nice to Unix text files

			else if(ch == CELL)
				ch = ' ';
		}
		else if((ch | 1) == PS)				// Translate Unicode para/line
		{									//  separators into CR/VT
			if(!fMultiLine)
				break;
			ch = (ch == PS) ? CR : VT;
		}
		else if(IN_RANGE(STARTFIELD, ch, NOTACHAR))
			ch = ' ';
											
		qw = FSYMBOL;
		fSurrogate = FALSE;
		if(!fDefFontSymbol)
		{
			qw = GetCharFlags(pchS, cchS, iCharRepDefault);// Check for complex scripts
			if(qw & FSURROGATE && cchS > 1)
			{
				fSurrogate = TRUE;
				pchS++;
				cchS--;
				if (pchD)
					*pchD++ = ch;			// Copy lead surrogate
				ch = *pchS;					// Setup to copy trail surrogate
			}
		}
		if(chPassword)
			qw = GetCharFlags(&chPassword, 1, iCharRepDefault);
		qwCharFlags |= qw;					// FE, and charset changes
		qw &= ~0x2F;						// Exclude non-fontbind flags
		if(fMultiLine)						// In multiline controls, collect
		{									//  possibly translated chars
			if(qw & FSYMBOL)				// Convert 0xF000 thru 0xF0FF to
				ch &= 0xFF;					//  SYMBOL_CHARSET with 0x00 thru
			*pchD++ = ch;					//  0xFF. FUTURE: make work for
		}									//  single line too...
		pchS++;								// pchS points at next char
		if(ped->IsAutoFont() && !fDefFontSymbol)
		{
			BOOL fReplacedText = FALSE;

			if (fDeleteChar)
			{
				fDeleteChar = FALSE;
				ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, NULL, dwFlags);
				Set_iCF(-1);
				qwCharMask = GetCharRepMask(TRUE);
			}

			if (!ped->_fIMEInProgress)
			{
				// Simp. Chinese uses some of the Latin2 symbols
				if (fUIFont && (qw == FLATIN2 || IN_RANGE(0x0250, ch, 0x02FF) ||
					IN_RANGE(0xFE50, ch, 0xFE6F)))
				{
					if (iCharRepDefault == BIG5_INDEX || iCharRepDefault == GB2312_INDEX ||
						GetACP() == CP_CHINESE_SIM || GetACP() == CP_CHINESE_TRAD)
					{
						if (VerifyFEString(CP_CHINESE_SIM,  (const WCHAR *)&ch, 1, TRUE) == CP_CHINESE_SIM ||
							VerifyFEString(CP_CHINESE_TRAD, (const WCHAR *)&ch, 1, TRUE) == CP_CHINESE_TRAD)
							qw = FCHINESE;
					}
				}
				if (fUIFont && qw == FHILATIN1 && fFEBaseFont &&
					(iCharRepDefault == SHIFTJIS_INDEX || iCharRepDefault == HANGUL_INDEX || ch >= 0x100))	// Special characters that are classiied as HiAnsi
				{
					// Use Ansi font for HiAnsi
					if (dwCurrentFontUsed != FHILATIN1)
					{
						fReplacedText = TRUE;
						cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
							qw, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char
					}
					dwCurrentFontUsed = FHILATIN1;
				}
				else if (fUIFont && fDefFontHasASCII && _rpCF.IsValid() &&
					(qw & FASCII || IN_RANGE(0x2018, ch, 0x201D)))
				{				
					if (dwCurrentFontUsed != FASCII)
					{
						fReplacedText = TRUE;
						cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
							0, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char
						
						// Use the -1 font charset/face/size so the current font effect
						// will still be used.
						CCharFormat CFDefault = *ped->GetCharFormat(-1);
						SetCharFormat(&CFDefault, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
								 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
						dwCurrentFontUsed = FASCII;
					}
				}
				else if (!fUIFont && qwCharMask & FLATIN1 
					&& ((IN_RANGE(0x2018, ch, 0x201D) || ch == 0x2026))
					|| (qw & (FCHINESE | FBIG5) && qwCharMask & (FCHINESE | FKANA | FBIG5 | FHANGUL)))
				{										// Stay with current font
					;									//	and do Nothing
				}
				else if (qw && (qw & qwCharMask) != qw	// No match: need charset change
					 || dwCurrentFontUsed)				//  or change in classification
				{										
					fReplacedText = TRUE;
					dwCurrentFontUsed = 0;
					if(qw & (FCHINESE | FBIG5 | FFE2))	// If Han char, check next few
					{									//  chars for a Hangul or Kana
						Assert(cchS);
						const WCHAR *pchT = pchS;
						QWORD qw0;
						LONG i = min(10, cchS - 1);

						for (int j=0; j < 2; j++)
						{
							if (j)
							{
								// Check current text
								pchT = pch;
								i = min(6, cch);
							}

							for(; i > 0 && *pchT; i--)
							{
								qw0 = GetCharFlags(pchT++, i, iCharRepDefault);
								qw |= qw0 & ~FSURROGATE;
								if(qw0 & FSURROGATE && i > 1)
								{
									pchT++;
									i--;
								}
							}
						}

						i = CalcTextLenNotInRange();
						if(cchS < 6 && i)			// Get flags around range
						{
							CTxtPtr tp(_rpTX);
							i = min(i, 6);
							if(!_cch)				// For insertion point, backup
								tp.Move(-i/2);		//  half way
							else if(_cch < 0)		// Active end at cpMin, backup
								tp.Move(-i);		//  whole way
							qw |= tp.GetCharFlagsInRange(i, iCharRepDefault);
						}

						qw &= FFE | FFE2 | FSURROGATE;
					}
					else if(qw & (FHILATIN1 | FLATIN2) && qwCharMask & FLATIN)
					{
						LONG i = qwCharMask & FLATIN;
						qw = W32->GetCharFlags125x(ch) & FLATIN;
						if(!(qw & i))
							for(i = 0x100; i < 0x20000 && !(qw & i); i <<= 1)
								;
						qw &= i;
					}
					else if(qw & FMATH)
					{
						// Bind math fonts here (combos of ital, bold, script,
						// fraktur, open, sans, mono)
					}
					cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
						qw, &cchM, cpFirst, MATCH_FONT_SIG, dwFlags);	// Replace text up to previous char
				}			
			}
			else
			{				// IME in progress, only need to check ASCII cases
				BOOL fHandled = FALSE;
				if (ch <= 0x7F)
				{
					if (fUIFont)
					{
						// Use default font
						if (dwCurrentFontUsed != FASCII)
						{
							cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
								0, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char
							
							// Use the -1 font charset/face/size so the current font effect
							// will still be used.
							CCharFormat CFDefault = *ped->GetCharFormat(-1);
							SetCharFormat(&CFDefault, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
									 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
							
							fReplacedText = TRUE;
							dwCurrentFontUsed = FASCII;
						}
						fHandled = TRUE;
					}
					else if (ped->_fDualFont && IsASCIIAlpha(ch))
					{
						// Use English Font
						if (dwCurrentFontUsed != fALPHA)
						{
							cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
								qw, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char						
							fReplacedText = TRUE;
							dwCurrentFontUsed = fALPHA;
						}
						fHandled = TRUE;
					}
				}
				else if (qw & FSURROGATE ||
					(qw & FOTHER && 
					(IN_RANGE(0x03400, ch, 0x04DFF) || IN_RANGE(0xE000, ch, 0x0F8FF))))
				{
					// Try font binding for Surrogate, Extension-A, and Private Usage Area
					cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
						qw, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char						
					fReplacedText = TRUE;
					dwCurrentFontUsed = FSURROGATE;
					fHandled = TRUE;
				}

				// Use current FE font
				if(!fHandled && dwCurrentFontUsed != FFE)
				{
					cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr,
						0, &cchM, cpFirst, IGNORE_CURRENT_FONT, dwFlags);	// Replace text up to previous char
					SetCharFormat(&CFCurrent, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
						CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
					fReplacedText = TRUE;
					dwCurrentFontUsed = FFE;
				}
			}

			if (fReplacedText)
			{
				qwCharMask = (qw & FSYMBOL) ? FSYMBOL : GetCharRepMask();
				if(cchM)
					cchMove = cchM;			// Can only happen on 1st replace
				pch = fMultiLine ? pchD : pchS;
				pch--;
				if(fSurrogate)
					pch--;
				cch = 0;
			}
		}
		cch++;
		if(fSurrogate)
			cch++;
	}										
    ped->OrCharFlags(qwCharFlags, publdr);

	cchNew += CheckLimitReplaceRange(cch, pch, fTestLimit, publdr, (qw & (FOTHER | FSURROGATE)), &cchM, cpFirst,
									IGNORE_CURRENT_FONT, dwFlags);
	if(cchM)
		cchMove = cchM;						// Can only happen on 1st replace

	if (pcchMove)
		*pcchMove = cchMove;

	if (ped->IsComplexScript())
	{
		if (dwFlagsSave & RR_ITMZ_NONE || ped->IsStreaming())
			ped->_fItemizePending = TRUE;
		else
			ItemizeReplaceRange(cchNew, cchMove, publdr, dwFlagsSave & RR_ITMZ_UNICODEBIDI);
	}
	_fDontUpdateFmt = fDontUpdateFmt;
	Update_iFormat(-1);					// Choose _iFormat
	return cchNew;
}

/*
 *	CTxtRange::CheckLimitReplaceRange(cchNew, *pch, fTestLimit, publdr,
 *									  qwCharFlags, pcchMove, prp, iMatchCurrent, &dwFlags)
 *	@mfunc
 *		Replace the text in this range by pch using CCharFormat _iFormat
 *		and updating other text runs as needed.
 *	
 *	@rdesc
 *		Count of new characters added
 *	
 *	@devnote
 *		moves this text pointer to end of replaced text and
 *		may move text block and formatting arrays
 */
LONG CTxtRange::CheckLimitReplaceRange (
	LONG			cch,			//@parm Length of replacement text
	WCHAR const *	pch,			//@parm Replacement text
	BOOL			fTestLimit,		//@parm Whether to do limit test
	IUndoBuilder *	publdr,			//@parm UndoBuilder to receive antievents
	QWORD			qwCharFlags,	//@parm CharFlags following pch
	LONG *			pcchMove,		//@parm Count of chars moved in 1st replace
	LONG			cpFirst,		//@parm Starting cp for font binding
	int				iMatchCurrent,	//@parm Font matching method
	DWORD &			dwFlags)		//@parm ReplaceRange's flags
{
	CTxtEdit *ped = GetPed();

	if(cch || _cch)
	{
		if(fTestLimit)
		{
			LONG	cchLen = CalcTextLenNotInRange();
			DWORD	cchMax = ped->TxGetMaxLength();
			if((DWORD)(cch + cchLen) > cchMax)	// New plus old	count exceeds
			{									//  max allowed, so truncate
				cch = cchMax - cchLen;			//  down to what fits
				cch = max(cch, 0);				// Keep it positive
				ped->GetCallMgr()->SetMaxText(); // Report exceeded
			}
		}
		
		if (cch && ped->IsAutoFont() && !ped->_fIMEInProgress)
		{
			LONG iFormatTemp;
			if (fUseUIFont() && GetAdjustedTextLength() != _cch)
			{
				// Delete the old string first so _iFormat is defined
				ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, pcchMove, dwFlags);
				iFormatTemp = _iFormat;
			}
			else
				iFormatTemp = GetiFormat();

			BYTE iCharRepCurrent = ped->GetCharFormat(iFormatTemp)->_iCharRep;
			
			if (IsFECharRep(iCharRepCurrent) && !(qwCharFlags & (FOTHER | FSURROGATE)))
			{
				// Check if current font can handle this string.
				INT	cpgCurrent = CodePageFromCharRep(iCharRepCurrent);
				INT	cpgNew = VerifyFEString(cpgCurrent, pch, cch, FALSE);

				if (cpgCurrent != cpgNew)
				{
					// Setup the new CodePage to handle this string
					CCharFormat CF;
					BYTE		iCharRep = CharRepFromCodePage(cpgNew);
					CCFRunPtr	rp(_rpCF, ped);
					rp.Move(cpFirst - GetCp());

					CF._iCharRep = iCharRep;
					if(rp.GetPreferredFontInfo(iCharRep, CF._iCharRep, CF._iFont, CF._yHeight,
							CF._bPitchAndFamily, _iFormat, iMatchCurrent))
					{
						SetCharFormat(&CF, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
							 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
					}
				}
			}
		}
		cch = ReplaceRange(cch, pch, publdr, SELRR_REMEMBERRANGE, pcchMove, dwFlags);
		dwFlags |= RR_NO_LP_CHECK;
	}

	// If following string contains Hangul or Kana, use Korean or Japanese
	// font signatures, respectively. Else use incoming qwCharFlags
	if(!qwCharFlags)
		return cch;

	qwCharFlags &= ~0x2F;
	if(qwCharFlags & (FFE | FFE2))
	{
		BOOL fFE2 = (qwCharFlags & FSURROGATE) != 0;
		if(qwCharFlags & FHANGUL)
			qwCharFlags = fFE2 ? (FKOR2 | FSURROGATE) : FHANGUL;

		else if(qwCharFlags & FKANA)
			qwCharFlags = fFE2 ? (FJPN2 | FSURROGATE) : FKANA;

		else if(qwCharFlags & FBIG5)
			qwCharFlags = fFE2 ? (FCHT2 | FSURROGATE) : FBIG5;

		else if(fFE2)
			qwCharFlags = FCHS2 | FSURROGATE;
	}

	CCharFormat CF;
	bool		fCFDefined = FALSE;
	bool		fCFDefDefined = FALSE;
	bool		fUIFont = ped->fUseUIFont();

	CF._iCharRep = W32->CharRepFromFontSig(qwCharFlags);
	CF._iFont = 0;

	if (W32->IsExternalFontCheckActive() &&
		(qwCharFlags & (FOTHER | FSURROGATE) ||
		 !(fCFDefDefined = W32->IsDefaultFontDefined(CF._iCharRep, fUIFont, CF._iFont))))
	{
		// REMARK: Currently pch[cch] is the current char and others might
		// follow as well. We could get some text from _rpTX to provide more
		// context.
		fCFDefined = W32->GetExternalPreferredFontInfo(pch, 
				(qwCharFlags & FSURROGATE) ? cch + 2 : cch + 1,
				CF._iCharRep, CF._iFont, CF._bPitchAndFamily, fUIFont || ped->Get10Mode());
	}
	if(fCFDefined || fCFDefDefined || qwCharFlags != FOTHER)
	{
		SHORT iFontDummy = CF._iFont;
		CCFRunPtr rp(_rpCF, ped);
		rp.Move(cpFirst - GetCp());
		fCFDefined = rp.GetPreferredFontInfo(CF._iCharRep, CF._iCharRep, fCFDefined ? iFontDummy : CF._iFont, CF._yHeight,
			CF._bPitchAndFamily, (_cch ? -1 : _iFormat), fCFDefined ? GET_HEIGHT_ONLY : iMatchCurrent);
	}
	if(fCFDefined)
	{
		SetCharFormat(&CF, 0, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
			 CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK);
	}
	return cch;
}

/*
 *	CTxtRange::ReplaceRange(cchNew, *pch, publdr. selaemode, pcchMove)
 *	
 *	@mfunc
 *		Replace the text in this range by pch using CCharFormat _iFormat
 *		and updating other text runs as needed.
 *	
 *	@rdesc
 *		Count of new characters added
 *	
 *	@devnote
 *		moves this text pointer to end of replaced text and
 *		may move text block and formatting arrays
 */
LONG CTxtRange::ReplaceRange (
	LONG			cchNew,		//@parm Length of replacement text
	WCHAR const *	pch,		//@parm Replacement text
	IUndoBuilder *	publdr,		//@parm UndoBuilder to receive antievents
	SELRR			selaemode,	//@parm Controls how selection antievents are to be generated.
	LONG *			pcchMove,	//@parm Number of chars moved after replace
	DWORD			dwFlags)	//@parm Special flags
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::ReplaceRange");

	LONG lRet;
	LONG iFormat = _iFormat;
	BOOL fReleaseFormat = FALSE;
	ICharFormatCache * pcf = GetCharFormatCache();

	_TEST_INVARIANT_

	if(!(cchNew | _cch))					// Nothing to add or delete,
	{										//  so we're done
		if(pcchMove)
			*pcchMove = 0;
		return 0;
	}

	if(publdr && selaemode != SELRR_IGNORE)
	{
		Assert(selaemode == SELRR_REMEMBERRANGE);
		HandleSelectionAEInfo(GetPed(), publdr, GetCp(), _cch,
				GetCpMin() + cchNew, 0, SELAE_MERGE);
	}
	
	CFreezeDisplay fd(GetPed()->_pdp);
	if(_cch > 0)
		FlipRange();

	CheckLinkProtection(dwFlags, iFormat);

	// If we are replacing a non-degenerate selection, then the Word95
	// UI specifies that we should use the rightmost formatting at cpMin.
	if(_cch < 0 && _rpCF.IsValid() && !_fDualFontMode && !_fUseiFormat)
	{
		_rpCF.AdjustForward();
		iFormat = _rpCF.GetFormat();

		// This is a bit icky, but the idea is to stabilize the
		// reference count on iFormat.  When we get it above, it's
		// not addref'ed, so if we happen to delete the text in the
		// range and the range is the only one with that format,
		// then the format will go away.
		pcf->AddRef(iFormat);
		fReleaseFormat = TRUE;
	}
	const	CCharFormat *pCF = GetPed()->GetCharFormat(iFormat);
	BOOL	fTmpDispAttr = pCF->_sTmpDisplayAttrIdx != -1;

	if((fTmpDispAttr || dwFlags & (RR_UNHIDE | RR_UNLINK)) && cchNew)	// Don't hide or protect or apply temp. 
	{																	//	display attributes to inserted text
		BOOL fUnhide = dwFlags & RR_UNHIDE && pCF->_dwEffects & (CFE_HIDDEN | CFE_PROTECTED);
		BOOL fUnlink = dwFlags & RR_UNLINK && pCF->_dwEffects & CFE_LINK;
		if(fTmpDispAttr | fUnhide | fUnlink)	// Switch to unhidden/unlinked iFormat or
		{										//	turn of temp. display attribute
			CCharFormat CF = *pCF;
			if(fReleaseFormat)					// Need to release iFormat ref'd
				pcf->Release(iFormat);			//  above, since no longer need it
			if(fUnhide)
			{
				CF._dwEffects &= ~(CFE_HIDDEN | CFE_PROTECTED);
				if (CF._dwEffects & CFE_LINKPROTECTED)
					CF._dwEffects &= ~(CFE_LINKPROTECTED | CFE_LINK);
			}
			if(fUnlink)
				CF._dwEffects &= ~CFE_LINK;
			if(fTmpDispAttr)
				CF._sTmpDisplayAttrIdx = -1;
			pcf->Cache(&CF, &iFormat);
			fReleaseFormat = TRUE;				// Be sure to release new one
		}
	}
	_fUseiFormat = FALSE;
	
	LONG cchForReplace = -_cch;	
	_cch = 0;
	lRet = CRchTxtPtr::ReplaceRange(cchForReplace, cchNew, pch, publdr,
				iFormat, pcchMove, dwFlags);
	if(cchForReplace)
		CheckMergedCells(publdr);

	if(lRet)
		_fMoveBack = FALSE;

	Update_iFormat(fReleaseFormat ? iFormat : -1);

	if(fReleaseFormat)
	{
		Assert(pcf);
		pcf->Release(iFormat);
	}
	return lRet;
}

/*
 *	CTxtRange::DeleteWithTRDCheck(publdr. selaemode, pcchMove, dwFlags)
 *
 *	@mfunc
 *		Delete text in this range, inserting an EOP in place of the text
 *		if the range ends at a table-row start delimiter
 *
 *	@rdesc
 *		Count of new characters added
 *
 *	@devnote
 *		moves this text pointer to end of replaced text and
 *		may move text block and formatting arrays
 */
LONG CTxtRange::DeleteWithTRDCheck (
	IUndoBuilder *	publdr,		//@parm UndoBuilder to receive antievents
	SELRR			selaemode,	//@parm Controls how selection antievents are to be generated.
	LONG *			pcchMove,	//@parm Count of chars moved after replace
	DWORD			dwFlags)	//@parm ReplaceRange flags
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::ReplaceRange");

	LONG	cchEOP = 0;
	WCHAR	szEOP[] = {CR, LF, 0};

	if(IsRich())
	{
		CTxtPtr tp(_rpTX);					// If inserting before a table
		if(GetCch() < 0)					//  row, ReplaceRange with EOP,
			tp.Move(-GetCch());				//  which we delete after read
		if(tp.IsAtTRD(STARTFIELD))			//  if read ends with an EOP
			cchEOP = GetPed()->fUseCRLF() ? 2 : 1;
	}

	if(!(_cch | cchEOP))
		return 0;							// Nothing to do

	ReplaceRange(cchEOP, szEOP, publdr, selaemode, pcchMove, dwFlags);

	if(GetCch())
	{
		// Text deletion failed because range didn't collapse. Our work
		// here is done.
		return 0;
	}
	if(cchEOP)
	{
		_rpPF.AdjustBackward();
		const CParaFormat *pPF = GetPF();
		_rpPF.AdjustForward();
		if(pPF->_wEffects & PFE_TABLE)
		{
			CParaFormat PF = *GetPed()->GetParaFormat(-1);
			PF._bTableLevel = pPF->_bTableLevel - 1;
			Assert(PF._bTableLevel >= 0);
			_cch = cchEOP;					// Select EOP just inserted
			PF._wEffects &= ~PFE_TABLE;		// Default not in table
			if(PF._bTableLevel)
				PF._wEffects |= PFE_TABLE;	// It's in a table
			SetParaFormat(&PF, publdr, PFM_ALL2, PFM2_ALLOWTRDCHANGE);
			SetCp(GetCp() - cchEOP, FALSE);	// Collapse before EOP
		}
	}
	return cchEOP;
}

/*
 *	CTxtRange::Delete(publdr. selaemode)
 *	
 *	@mfunc
 *		Delete text in this range.
 */
void CTxtRange::Delete (
	IUndoBuilder *	publdr,		//@parm UndoBuilder to receive antievents
	SELRR			selaemode)	//@parm Controls generation of selection antievents
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::Delete");

	if(!_cch)
		return;							// Nothing to delete

	if(!GetPed()->IsBiDi())
	{
		ReplaceRange(0, NULL, publdr, selaemode, NULL);
		return;
	}

	CFreezeDisplay fd(GetPed()->_pdp);

	ReplaceRange(0, NULL, publdr, selaemode);
}

/*
 *	CTxtRange::BypassHiddenText(iDir, fExtend)
 *
 *	@mfunc
 *		Bypass hidden text forward/backward for iDir positive/negative
 *
 *	@rdesc
 *		TRUE if succeeded or no hidden text. FALSE if at document limit
 *		(end/start for Direction positive/negative) or if hidden text between
 *		cp and that limit.
 */
BOOL CTxtRange::BypassHiddenText(
	LONG iDir,
	BOOL fExtend)
{
	if (!_rpCF.IsValid())
		return TRUE;		// No format run, not hidden

	if(iDir > 0)
		_rpCF.AdjustForward();
	else
		_rpCF.AdjustBackward();

	if(!(GetPed()->GetCharFormat(_rpCF.GetFormat())->_dwEffects & CFE_HIDDEN))
		return TRUE;

	CCFRunPtr rp(*this);
	LONG cch = (iDir > 0)
			 ? rp.FindUnhiddenForward() : rp.FindUnhiddenBackward();

	BOOL bRet = !rp.IsHidden();				// Note whether still hidden
	if(bRet)								// It isn't:
		Move(cch, fExtend);					//  bypass hidden text
	return bRet;
}

/*
 *	CTxtRange::CheckMergedCells(publdr)
 *
 *	@mfunc
 *		If range is at a table-row start delimiter, ensure that cells
 *		that are vertically merged with cells above have a top cell.
 *
 *		If the text before this range is a row that contains top cells
 *		these cells have to be converted to nonmerged cells unless the
 *		text starting at this range contains corresponding low cells.
 *
 *		If the text starting at this range is a table row with low cells,
 *		they may have to be converted to top or nonmerged cells.
 */
void CTxtRange::CheckMergedCells (
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive antievents
{
	Assert(!_cch);						// Assumes this range is an IP

	unsigned ch = _rpTX.GetChar();

	if(ch != CR && ch != STARTFIELD)	// Early out
		return;

	if(ch == CR)						// CRchTxtPtr::ReplaceRange() may
	{									//  leave a CR at end before a table
		CTxtPtr tp(_rpTX);				//  row start delimiter, so check for
		LONG cch = tp.AdvanceCRLF(FALSE);// that case
		if(!tp.IsAtTRD(STARTFIELD))
			return;
		Move(cch, FALSE);				// Check that row
	}
	else if(!_rpTX.IsAtTRD(STARTFIELD))	// Allow top cells to remain w/o row
		return;							//  below so that complex tables can
										//  be inserted
	const CParaFormat *pPF0 = NULL;		// Default no row to compare to

	if(_rpTX.IsAfterTRD(ENDFIELD))		// Range is at table row, so do top
	{									//  cell check on previous row
		CheckTopCells(publdr);
		_rpPF.AdjustBackward();
		pPF0 = GetPF();					// Compare to preceding row
		_rpPF.AdjustForward();
	}

	const CParaFormat *	pPF1 = GetPF();	// Point at current row PF
	CELLPARMS			rgCellParms[MAX_TABLE_CELLS];

	if(CheckCells(&rgCellParms[0], pPF1, pPF0, fLowCell, fLowCell | fTopCell))
	{									// One or more cells need changes
		CTxtRange rg(*this);
		rg._rpPF.AdjustForward();
		rg.SetCellParms(&rgCellParms[0], pPF1->_bTabCount, TRUE, publdr);
		rg.CheckTopCells(publdr);		// Do top cell check on entry row
	}
	if(ch == CR)
		BackupCRLF(CSC_NORMAL, FALSE);	// Restore this range
}

/*
 *	CTxtRange::CheckTopCells(publdr)
 *
 *	@mfunc
 *		If this range follows a table-row end delimiter, normalize any top
 *		cells in the previous row that don't have corresponding low cells
 *		in the current row.
 */
void CTxtRange::CheckTopCells (
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive antievents
{
	Assert(_rpTX.IsAfterTRD(ENDFIELD));

	_rpPF.AdjustBackward();
	const CParaFormat *	pPF0 = GetPF();
	_rpPF.AdjustForward();
	const CParaFormat *	pPF1 = _rpTX.IsAtTRD(STARTFIELD) ? GetPF() : NULL;
	CELLPARMS			rgCellParms[MAX_TABLE_CELLS];

	if(CheckCells(&rgCellParms[0], pPF0, pPF1, fTopCell, fLowCell))
	{
		LONG	  cpMin;
		CTxtRange rg(*this);

		rg.Move(-2, FALSE);					// Back up before table row end delimiter
		rg.FindRow(&cpMin, NULL, rg.GetPF()->_bTableLevel);
		rg.Set(cpMin, 0);
		rg.SetCellParms(&rgCellParms[0], pPF0->_bTabCount, FALSE, publdr);
	}
}

/*
 *	CTxtRange::CheckCells(prgCellParms, pPF1, pPF0, dwMaskCell, dwMaskCellAssoc)
 *
 *	@mfunc
 *		Check cells with type dwMaskCell in row for pPF1 to see if their 
 *		associated cells in row for pPF0 are compatible and make appropriate
 *		changes in prgCellParms if a discrepancy is found.
 *
 *	@rdesc
 *		TRUE if prgCellParms contains changes from the cells in pPF1.
 */
BOOL CTxtRange::CheckCells (
	CELLPARMS *	prgCellParms,	//@parm	CellParms to update
	const CParaFormat *	pPF1,	//@parm PF for row to check cells on	
	const CParaFormat *	pPF0,	//@parm PF for row to compare cells to
	DWORD dwMaskCell,			//@parm Mask for cell type to check
	DWORD dwMaskCellAssoc)		//@parm Mask for desired associated type
{
	LONG			 cCell1 = pPF1->_bTabCount;
	BOOL			 fCellsChanged = FALSE;
	const CELLPARMS *prgCellParms1 = pPF1->GetCellParms();

	for(LONG iCell1 = 0, dul1 = 0; iCell1 < cCell1; iCell1++)
	{
		LONG uCell1 = prgCellParms1[iCell1].uCell;
		prgCellParms[iCell1] = prgCellParms1[iCell1];// Copy current cell parms
		dul1 += GetCellWidth(uCell1);
		if(uCell1 & dwMaskCell)				// Need to check cell: see if		
		{									//  associated cell is compatible
			BOOL fChangeCellParm = TRUE;	// Default that it isn't
			if(pPF0)						// Compare to associated row
			{
				LONG cCell0 = pPF0->_bTabCount;
				const CELLPARMS *prgCellParms0 = pPF0->GetCellParms();

				fChangeCellParm = FALSE;	// Maybe no change needed
				for(LONG iCell0 = 0, dul0 = 0; iCell0 < cCell0; iCell0++)
				{							// Find cell above
					LONG uCell0 = prgCellParms0[iCell0].uCell;
					dul0 += GetCellWidth(uCell0);
					if(dul0 == dul1)		// Found cell above
					{
						// Should check both ends of cell to be sure it
						// matches the present one
						if(!(uCell0 & dwMaskCellAssoc))
							fChangeCellParm = TRUE;	// Need cell parm change
						break;
					}
				}
			}
			if(fChangeCellParm)
			{
				uCell1 &= ~dwMaskCell;
				if(dwMaskCell == fLowCell)
				{
					// REMARK: it would be possible to get the pPF for the para
					// following this row and check to see if the current cell
					// should be a top cell. For now we assume it is and fix it
					// up by an additional pass in CheckMergeCells()
					uCell1 |= fTopCell;
				}
				prgCellParms[iCell1].uCell = uCell1;
				fCellsChanged = TRUE;
			}
		}
	}
	return fCellsChanged;
}

/*
 *	CTxtRange::SetCellParms(prgCellParms, cCell, fConvertLowCells, publdr)
 *
 *	@mfunc
 *		Set cell parms for row pointed to by this range equal to *prgCellParms.
 *		Return with this range pointing just after the row end delimiter.
 */
void CTxtRange::SetCellParms (
	CELLPARMS *	  prgCellParms,		//@parm New cell parms to use
	LONG		  cCell,			//@parm # cells
	BOOL		  fConvertLowCells,	//@parm TRUE if low cells are being converted
	IUndoBuilder *publdr)			//@parm UndoBuilder to receive antievents
{
	LONG		cpMost;
	LONG		Level = GetPF()->_bTableLevel;
	CParaFormat	PF;

	Assert(_rpTX.IsAtTRD(STARTFIELD) && Level > 0);

	PF._bTabCount = cCell;
	PF._iTabs = GetTabsCache()->Cache((LONG *)prgCellParms, cCell*(CELL_EXTRA+1));
	Move(2, TRUE);							// Select table-row-start delimiter
	SetParaFormat(&PF, publdr, PFM_TABSTOPS, PFM2_ALLOWTRDCHANGE);
	_cch = 0;
	FindRow(NULL, &cpMost, Level);
	if(fConvertLowCells)
	{
		while(GetCp() < cpMost - 2)			// Delete NOTACHARs
		{
			if(_rpTX.GetChar() == NOTACHAR && Level == GetPF()->_bTableLevel)
			{
				_cch = -1;
				ReplaceRange(0, NULL, publdr, SELRR_REMEMBERRANGE, NULL);
				cpMost--;
			}
			Move(1, FALSE);
		}
	}
	Set(cpMost, 2);						// Select table-row end delimiter
	Assert(_rpTX.IsAfterTRD(ENDFIELD));
	SetParaFormat(&PF, publdr, PFM_TABSTOPS, PFM2_ALLOWTRDCHANGE);
	GetTabsCache()->Release(PF._iTabs);
	_cch = 0;
}

/*
 *	CTxtRange::GetCharFormat(pCF, flags)
 *	
 *	@mfunc
 *		Set *pCF = CCharFormat for this range. If cbSize = sizeof(CHARFORMAT)
 *		only transfer CHARFORMAT data.
 *
 *	@rdesc
 *		Mask of unchanged properties over range (for CHARFORMAT::dwMask)
 *
 *	@devnote
 *		NINCH means No Input No CHange (a Microsoft Word term). Here used for
 *		properties that change during the range of cch characters.	NINCHed
 *		properties in a Word-Font dialog have grayed boxes. They are indicated
 *		by zero values in their respective dwMask bit positions. Note that
 *		a blank at the end of the range does not participate in the NINCH
 *		test, i.e., it can have a different CCharFormat without zeroing the
 *		corresponding dwMask bits.  This is done to be compatible with Word
 *		(see also CTxtSelection::SetCharFormat when _fWordSelMode is TRUE).
 */
DWORD CTxtRange::GetCharFormat (
	CCharFormat *pCF, 		//@parm CCharFormat to fill with results
	DWORD flags) const		//@parm flags
{
	TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CTxtRange::GetCharFormat");
	_TEST_INVARIANT_
	
	CTxtEdit * const ped = GetPed();

	if(!_cch || !_rpCF.IsValid())					// IP or invalid CF
	{												//	run ptr: use CF at
		*pCF = *ped->GetCharFormat(_iFormat);		//  this text ptr
		return CFM_ALL2;
	}

	LONG		  cpMin, cpMost;					// Nondegenerate range:
	LONG		  cch = GetRange(cpMin, cpMost);	//  need to scan
	LONG		  cchChunk;							// cch in CF run
	DWORD		  dwMask = CFM_ALL2;				// Initially all prop def'd
	LONG		  iDirection;						// Direction of scan
	CFormatRunPtr rp(_rpCF);						// Nondegenerate range

	/*
	 * The code below reads character formatting the way Word does it,
	 * that is, by not including the formatting of the last character in the
	 * range if that character is a blank.
	 *
	 * See also the corresponding code in CTxtSelection::SetCharFormat().
	 */

	if(cch > 1 && _fSel && (flags & SCF_USEUIRULES))// If more than one char,
	{												//  don't include trailing
		CTxtPtr tp(ped, cpMost - 1);				//  blank in NINCH test
		if(tp.GetChar() == ' ')
		{											// Have trailing blank:
			cch--;									//  one less char to check
			if(_cch > 0)							// Will scan backward, so
				rp.Move(-1);					//  backup before blank
		}
	}

	if(_cch < 0)									