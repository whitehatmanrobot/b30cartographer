TIMETICKS)
#define MIB_OPAQUE_NA(x)            MIB_ANY_NA(x,ASN_RFC1155_OPAQUE)
#define MIB_DISPSTRING_NA(x)        MIB_ANY_NA(x,ASN_RFC1213_DISPSTRING)
#define MIB_PHYSADDRESS_NA(x)       MIB_ANY_NA(x,ASN_OCTETSTRING)

#define MIB_INTEGER_AC(x)           MIB_ANY_AC(x,ASN_INTEGER)
#define MIB_OCTETSTRING_AC(x)       MIB_ANY_AC(x,ASN_OCTETSTRING)
#define MIB_OBJECTIDENTIFIER_AC(x)  MIB_ANY_AC(x,ASN_OBJECTIDENTIFIER)
#define MIB_IPADDRESS_AC(x)         MIB_ANY_AC(x,ASN_RFC1155_IPADDRESS)
#define MIB_COUNTER_AC(x)           MIB_ANY_AC(x,ASN_RFC1155_COUNTER)
#define MIB_GAUGE_AC(x)             MIB_ANY_AC(x,ASN_RFC1155_GAUGE)
#define MIB_TIMETICKS_AC(x)         MIB_ANY_AC(x,ASN_RFC1155_TIMETICKS)
#define MIB_OPAQUE_AC(x)            MIB_ANY_AC(x,ASN_RFC1155_OPAQUE)
#define MIB_DISPSTRING_AC(x)        MIB_ANY_AC(x,ASN_RFC1213_DISPSTRING)
#define MIB_PHYSADDRESS_AC(x)       MIB_ANY_AC(x,ASN_OCTETSTRING)

#define MIB_INTEGER_L(x,a,z)        MIB_ANY_RO_L(x,ASN_INTEGER,a,z)    
#define MIB_OCTETSTRING_L(x,a,z)    MIB_ANY_RO_L(x,ASN_OCTETSTRING,a,z)
#define MIB_OPAQUE_L(x,a,z)         MIB_ANY_RO_L(x,ASN_RFC1155_OPAQUE,a,z)
#define MIB_DISPSTRING_L(x,a,z)     MIB_ANY_RO_L(x,ASN_RFC1213_DISPSTRING,a,z)
#define MIB_PHYSADDRESS_L(x,a,z)    MIB_ANY_RO_L(x,ASN_OCTETSTRING,a,z)

#define MIB_INTEGER_RW_L(x,a,z)     MIB_ANY_RW_L(x,ASN_INTEGER,a,z)    
#define MIB_OCTETSTRING_RW_L(x,a,z) MIB_ANY_RW_L(x,ASN_OCTETSTRING,a,z)
#define MIB_OPAQUE_RW_L(x,a,z)      MIB_ANY_RW_L(x,ASN_RFC1155_OPAQUE,a,z)
#define MIB_DISPSTRING_RW_L(x,a,z)  MIB_ANY_RW_L(x,ASN_RFC1213_DISPSTRING,a,z)
#define MIB_PHYSADDRESS_RW_L(x,a,z) MIB_ANY_RW_L(x,ASN_OCTETSTRING,a,z)

#define MIB_INTEGER_NA_L(x,a,z)     MIB_ANY_NA_L(x,ASN_INTEGER,a,z)    
#define MIB_OCTETSTRING_NA_L(x,a,z) MIB_ANY_NA_L(x,ASN_OCTETSTRING,a,z)
#define MIB_OPAQUE_NA_L(x,a,z)      MIB_ANY_NA_L(x,ASN_RFC1155_OPAQUE,a,z)
#define MIB_DISPSTRING_NA_L(x,a,z)  MIB_ANY_NA_L(x,ASN_RFC1213_DISPSTRING,a,z)
#define MIB_PHYSADDRESS_NA_L(x,a,z) MIB_ANY_NA_L(x,ASN_OCTETSTRING,a,z)

#define MIB_INTEGER_AC_L(x,a,z)     MIB_ANY_AC_L(x,ASN_INTEGER,a,z)    
#define MIB_OCTETSTRING_AC_L(x,a,z) MIB_ANY_AC_L(x,ASN_OCTETSTRING,a,z)
#define MIB_OPAQUE_AC_L(x,a,z)      MIB_ANY_AC_L(x,ASN_RFC1155_OPAQUE,a,z)
#define MIB_DISPSTRING_AC_L(x,a,z)  MIB_ANY_AC_L(x,ASN_RFC1213_DISPSTRING,a,z)
#define MIB_PHYSADDRESS_AC_L(x,a,z) MIB_ANY_AC_L(x,ASN_OCTETSTRING,a,z)

#define MIB_ENTRY_PTR(x,y) \
        MIB_ADDR(MIB_ID(mib_ ## x)[MIB_ID(mi_ ## y)])

#define MIB_TABLE(x,y,z) \
        {MIB_ID(ne_ ## y), MIB_ID(ni_ ## y), MIB_ENTRY_PTR(x,y), z}

#define asn_t  asnType
#define asn_v  asnValue
#define asn_n  asnValue.number
#define asn_s  asnValue.string
#define asn_sl asnValue.string.length
#define asn_ss asnValue.string.stream
#define asn_sd asnValue.string.dynamic
#define asn_o  asnValue.object
#define asn_ol asnValue.object.idLength
#define asn_oi asnValue.object.ids
#define asn_l  asnValue.sequence
#define asn_a  asnValue.address
#define asn_c  asnValue.counter
#define asn_g  asnValue.gauge
#define asn_tt asnValue.timeticks
#define asn_x  asnValue.arbitrary

#endif // _INC_SNMPEXTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\stropts.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stropts.h

Abstract:

    This module defines the STREAMS ioctl message interface.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/*
 * Streams ioctl message interface
 *
 * @(#)stropts.h	1.19 (Spider) 91/11/27
 */

#ifndef _SYS_STROPTS_
#define _SYS_STROPTS_

#ifndef _NTDDSTRM_
#include <ntddstrm.h>
#endif


/*
 * Read options
 */

#define RNORM	0x00			/* Normal - bytes stream */
#define RMSGD	0x01			/* Message, non-discard mode */
#define RMSGN	0x02			/* Message, discard mode */

#define RMASK	0x0F			/* mask for read options */

/*
 * Protocol read options
 */

#define	RPROTNORM	0x00		/* Fail reads with EBADMSG */
#define RPROTDIS	0x10		/* Discard proto part */
#define RPROTDAT	0x20		/* Turn proto part into data */

#define RPROTMASK	0xF0		/* mask for protocol read options */

/*
 * Values for I_ATMARK argument
 */

#define	ANYMARK		0		/* check if message is marked */
#define	LASTMARK	1		/* check if last one marked */

/*
 * Value for I_SWROPT argument
 */

#define	NOSNDZERO	0		/* disallow zero length sends */
#define	SNDZERO		1		/* permit zero length sends */

/*
 * STREAMS ioctl defines
 */

#define STR             ('S'<<8)
#define I_NREAD         (STR|1)
#define I_PUSH          (STR|2)
#define I_POP           (STR|3)
#define I_LOOK          (STR|4)
#define I_FLUSH         (STR|5)
#define I_SRDOPT        (STR|6)
#define I_GRDOPT        (STR|7)
#define I_STR           (STR|8)
#define I_SETSIG        (STR|9)
#define I_GETSIG        (STR|10)
#define I_FIND          (STR|11)
#define I_LINK          (STR|12)
#define I_UNLINK        (STR|13)
#define I_PEEK          (STR|15)
#define I_FDINSERT      (STR|16)
#define I_SENDFD        (STR|17)
#define I_RECVFD        (STR|18)
#ifdef SVR2
#define I_GETMSG        (STR|19)
#define I_PUTMSG        (STR|20)
#define I_GETID		(STR|21)
#define I_POLL		(STR|22)
#endif /*SVR2*/
#define	I_SWROPT	(STR|23)
#define	I_GWROPT	(STR|24)
#define	I_LIST		(STR|25)
#define	I_ATMARK	(STR|26)
#define	I_SETCLTIME	(STR|27)
#define	I_GETCLTIME	(STR|28)
#define	I_PLINK		(STR|29)
#define	I_PUNLINK	(STR|30)
#define I_DEBUG         (STR|31)
#define	I_CLOSE		(STR|32)


#define MUXID_ALL	-1

/*
 * Structure for I_FDINSERT ioctl
 */

struct strfdinsert {
        struct strbuf ctlbuf;
        struct strbuf databuf;
        long          flags;
        HANDLE        fildes;
        int           offset;
};


/*
 * Structures for I_DEBUG ioctl
 */
typedef enum _str_trace_options {
    MSG_TRACE_PRINT =      0x00000001,
    MSG_TRACE_FLUSH =      0x00000002,
    MSG_TRACE_ON =         0x00000004,
    MSG_TRACE_OFF =        0x00000008,
    POOL_TRACE_PRINT =     0x00000010,
    POOL_TRACE_FLUSH =     0x00000020,
    POOL_TRACE_ON =        0x00000040,
    POOL_TRACE_OFF =       0x00000080,
    POOL_FAIL_ON =         0x00000100,
    POOL_FAIL_OFF =        0x00000200,
    LOCK_TRACE_ON =        0x00000400,
    LOCK_TRACE_OFF =       0x00000800,
    QUEUE_PRINT =          0x00001000,
    BUFFER_PRINT =         0x00002000,
    POOL_LOGGING_ON =      0x00004000,
    POOL_LOGGING_OFF =     0x00008000
} str_trace_options;


struct strdebug {
    ULONG  trace_cmd;
};


/*
 * stream I_PEEK ioctl format
 */

struct strpeek {
	struct strbuf ctlbuf;
	struct strbuf databuf;
	long          flags;
};

/*
 * receive file descriptor structure
 */
struct strrecvfd {
#ifdef INKERNEL
        union {
                struct file *fp;
                int fd;
        } f;
#else
        int fd;
#endif
        unsigned short uid;
        unsigned short gid;
        char fill[8];
};

#define FMNAMESZ	8

struct str_mlist {
	char l_name[FMNAMESZ+1];
};

struct str_list {
	int sl_nmods;
	struct str_mlist *sl_modlist;
};

/*
 * get/putmsg flags
 */

#define RS_HIPRI	1	/* High priority message */

#define MORECTL		1
#define MOREDATA	2


/*
 * M_SETSIG flags
 */

#define S_INPUT		1
#define S_HIPRI		2
#define S_OUTPUT	4
#define S_MSG		8
#define S_ERROR		16
#define S_HANGUP	32

/*
 * Flags for MFLUSH messages
 */
#define FLUSHW		01	/* flush downstream */
#define FLUSHR		02	/* flush upstream */
#define FLUSHRW		(FLUSHR | FLUSHW)

#endif /* _SYS_STROPTS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\tunuser.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    tunuser.h

Abstract:

    Constants and types to access the TUN driver.
    Users must also include ntddndis.h

Author:

Environment:

    User/Kernel mode.

Revision History:


--*/



#ifndef __TUNUSER__H
#define __TUNUSER__H


#define OID_CUSTOM_TUNMP_INSTANCE_ID            0xff54554e

#define IOCTL_TUN_GET_MEDIUM_TYPE \
        CTL_CODE (FILE_DEVICE_NETWORK, 0x301, METHOD_BUFFERED, FILE_WRITE_ACCESS | FILE_READ_ACCESS)

#define IOCTL_TUN_GET_MTU \
        CTL_CODE (FILE_DEVICE_NETWORK, 0x302, METHOD_BUFFERED, FILE_WRITE_ACCESS | FILE_READ_ACCESS)

#define IOCTL_TUN_GET_PACKET_FILTER \
        CTL_CODE (FILE_DEVICE_NETWORK, 0x303, METHOD_BUFFERED, FILE_WRITE_ACCESS | FILE_READ_ACCESS)

#define IOCTL_TUN_GET_MINIPORT_NAME \
        CTL_CODE (FILE_DEVICE_NETWORK, 0x304, METHOD_BUFFERED, FILE_WRITE_ACCESS | FILE_READ_ACCESS)

#define TUN_ETH_MAC_ADDR_LEN        6

#include <pshpack1.h>

typedef struct _TUN_ETH_HEADER
{
    UCHAR       DstAddr[TUN_ETH_MAC_ADDR_LEN];
    UCHAR       SrcAddr[TUN_ETH_MAC_ADDR_LEN];
    USHORT      EthType;

} TUN_ETH_HEADER;

typedef struct _TUN_ETH_HEADER UNALIGNED * PTUN_ETH_HEADER;

#include <poppack.h>


#endif // __TUNUSER__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\unixapis.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    uemul.h

Abstract:

    Prototypes for Unix emulation routines used by libstcp and the tcpcmd
    utilities.

Author:

    Mike Massa (mikemas)           Sept 20, 1991

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     10-29-91     created
    sampa       11-16-91     added getopt

Notes:

    Exports:

	getlogin
	getpass
    getopt

--*/


#define MAX_USERNAME_SIZE   256


int
getlogin(
    char *UserName,
    int   len
    );


char *
getpass(
    char *prompt
    );

char *
getusername(
    char *prompt
    );

int
getopt(
	int,
	char **,
	char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\unimdmp.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1996
//
// File: unimdmp.h
//
// This file contains private modem structures and defines shared
// between Unimodem components, and components that invoke the Unimodem
// class installer.
//
//---------------------------------------------------------------------------

#ifndef __UNIMDMP_H__
#define __UNIMDMP_H__

#include <unimodem.h>

#ifdef __cplusplus
extern "C" {
#endif


#ifndef __ROVCOMM_H__
#define MAX_BUF_SHORT               32
#endif // __ROVCOMM_H__

// Unattended install parameters
// This structure is published in
// sdk\inc\unimodem.h as UM_INSTALLPARAMS;
// do not alter it
typedef struct _tagInstallParams
{
    DWORD   Flags;
    TCHAR   szPort[MAX_BUF_SHORT];
    TCHAR   szInfName[MAX_PATH];
    TCHAR   szInfSect[LINE_LEN];
    
} INSTALLPARAMS, FAR *LPINSTALLPARAMS;
    
// Unattended install flags;
// published in sdk\inc\unimodem.h;
// keep sinchronized with sdk\inc\unimodem.h
#define MIPF_NT4_UNATTEND       0x1
    // Take the information about what modem to install
    // from the unattended.txt file
#define MIPF_DRIVER_SELECTED    0x2
    // The modem driver is selected, just register
    // and install it
#define MIPF_CLONE_MODEM        0x4
    // The (hdi, pdevinfo) the class installer is called for
    // has to be installed on aditional ports

// This structure may be specified in
// the SP_INSTALLWIZARD_DATA's PrivateData field.
// It is published in sdk\inc\unimodem.h as
// UM_INSTALL_WIZARD; do not alter it
typedef struct tagMODEM_INSTALL_WIZARD
{
    DWORD       cbSize;
    DWORD       Flags;              // MIWF_ bit field
    DWORD       ExitButton;         // PSBTN_ value
    LPARAM      PrivateData;
    INSTALLPARAMS InstallParams;
    
} MODEM_INSTALL_WIZARD, * PMODEM_INSTALL_WIZARD;

// 
// Private Exports from MODEMUI.DLL
//

DWORD
APIENTRY
UnimodemGetDefaultCommConfig(
    IN        HKEY  hKey,
    IN OUT    LPCOMMCONFIG pcc,
    IN OUT    LPDWORD pdwSize
    );

typedef DWORD
(*PFNUNIMODEMGETDEFAULTCOMMCONFIG)(
    IN        HKEY  hKey,
    IN OUT    LPCOMMCONFIG pcc,
    IN OUT    LPDWORD pdwSize
    );

DWORD
APIENTRY
UnimodemDevConfigDialog(
    IN     LPCTSTR pszFriendlyName,
    IN     HWND hwndOwner,
    IN     DWORD dwType,                          // One of UMDEVCFGTYPE_*
    IN     DWORD dwFlags,                         // Reserved, must be 0
    IN     void *pvConfigBlobIn,
    OUT    void *pvConfigBlobOut,
    IN     LPPROPSHEETPAGE pExtPages,     OPTIONAL   // PPages to add
    IN     DWORD cExtPages
    );

typedef DWORD
(*PFNUNIMODEMDEVCONFIGDIALOG)(
    IN     LPCTSTR,
    IN     HWND,
    IN     DWORD,
    IN     DWORD,
    IN     void *,
    OUT    void *,
    IN     LPPROPSHEETPAGE,   OPTIONAL
    IN     DWORD
    );

DWORD
APIENTRY
UnimodemGetExtendedCaps(
    IN        HKEY  hKey,
    IN OUT    LPDWORD pdwTotalSize,
    OUT    MODEM_CONFIG_HEADER *pFirstObj // OPTIONAL
    );

typedef DWORD
(*PFNUNIMODEMGETEXTENDEDCAPS)(
    IN        HKEY  hKey,
    IN OUT    MODEM_CONFIG_HEADER *pFirstObj,
    IN OUT    LPDWORD pdwTotalSize
    );


#define UMDEVCFGTYPE_COMM 0x1

//
// TAPI3 CSA TSP-MSP BLOB
//
typedef struct
{
    DWORD dwSig; // Set to SIG_CSAMSPTSPBLOB
    #define SIG_CSATSPMSPBLOB 0x840cb29c

    DWORD dwTotalSize;

    DWORD dwCmd;        // One of the CSATSPMSPCMD_ constants.
        #define CSATSPMSPCMD_CONNECTED        0x1
        #define CSATSPMSPCMD_DISCONNECTED     0x2

    GUID  PermanentGuid;

} CSATSPMSPBLOB;

#ifdef __cplusplus
}
#endif


#endif  // __UNIMDMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\winscnst.h ===
#ifndef _WINSCNST_H_
#define _WINSCNST_H_

/*
  macros
*/


//
// Default values for the various time intervals
//

#define FORTY_MTS                               2400
#define TWO_HOURS                               7200
#define TWO_DAYS                                (172800)
#define ONEDAY                                  (TWO_DAYS/2)
#define FOUR_DAYS                               (TWO_DAYS * 2)
#define SIX_DAYS                                (TWO_DAYS * 3)
#define EIGHT_DAYS                              (TWO_DAYS * 4)
#define TWELVE_DAYS                             (TWO_DAYS * 6)
#define TWENTY_FOUR_DAYS                        (TWO_DAYS * 12)


#define WINSCNF_TIME_INT_W_SELF_FND_PNRS              TWO_HOURS
//
// Minimum number of updates that must be there before a push notification is
// sent
//
#define  WINSCNF_MIN_VALID_UPDATE_CNT        20  //the minimum no of updates
                                             //after which a notification
                                             //can be sent. Adjustable
                                             //via the registry
//
// This is the minimum valid Rpl interval.  All the scavenging time intervals
// are derived from it.
//
// refer WAIT_TIME_BEFORE_EXITING in rplpush.c
//
#define WINSCNF_MIN_VALID_RPL_INTVL        (600)  // 10 mts

// this is the minimum valid consistency check interval between the last time
// consistency check finished and the next one starts.
#define WINSCNF_MIN_VALID_INTER_CC_INTVL    (3*60*60) // 3 hours.

//
// default name of the db file that will contain the name-address mappings
//
#define  WINSCNF_DB_NAME                        TEXT(".\\wins\\wins.mdb")


#define  WINSCNF_DB_NAME_ASCII                        ".\\wins\\wins.mdb"

//
// NOTE NOTE NOTE
//
// If you change this define to a string that does not have an unexpanded
// string of the form %<string>% make a corresponding change in
// GetNamesOfDataFiles() in winscnf.c.
//
#define  WINSCNF_STATIC_DATA_NAME                TEXT("%SystemRoot%\\system32\\drivers\\etc\\lmhosts")



//
// names of values stored under the Parameters key for WINS configuration
//
#if defined(DBGSVC) && !defined(WINS_INTERACTIVE)
#define  WINSCNF_DBGFLAGS_NM                TEXT("DBGFLAGS")
#endif
#define  WINSCNF_FILTER1BREQUESTS_NM        TEXT("Filter1BRequests")
#define  WINSCNF_ADD1BTO1CQUERIES_NM        TEXT("Prepend1BTo1CQueries")
#define  WINSCNF_LOG_DETAILED_EVTS_NM        TEXT("LogDetailedEvents")
#define  WINSCNF_REFRESH_INTVL_NM        TEXT("RefreshInterval")
#define  WINSCNF_INIT_CHL_RETRY_INTVL_NM        TEXT("InitChlRetryInterval")
#define  WINSCNF_CHL_MAX_RETRIES_NM        TEXT("ChlMaxNoOfRetries")
#define  WINSCNF_TOMBSTONE_INTVL_NM        TEXT("TombstoneInterval")
#define  WINSCNF_TOMBSTONE_TMOUT_NM        TEXT("TombstoneTimeout")
#define  WINSCNF_VERIFY_INTVL_NM        TEXT("VerifyInterval")
#define  WINSCNF_DB_FILE_NM                TEXT("DbFileNm")
#define  WINSCNF_DB_FILE_NM_ASCII        "DbFileNm"
#define  WINSCNF_STATIC_INIT_FLAG_NM        TEXT("DoStaticDataInit")
#define  WINSCNF_INIT_VERSNO_VAL_LW_NM        TEXT("VersCounterStartVal_LowWord")
#define  WINSCNF_INIT_VERSNO_VAL_HW_NM  TEXT("VersCounterStartVal_HighWord")
#define  WINSCNF_BACKUP_DIR_PATH_NM     TEXT("BackupDirPath")
#define  WINSCNF_PRIORITY_CLASS_HIGH_NM     TEXT("PriorityClassHigh")
#define  WINSCNF_MAX_NO_WRK_THDS_NM     TEXT("NoOfWrkThds")
#define  WINSCNF_INIT_TIME_PAUSE_NM     TEXT("InitTimePause")
#define  WINSCNF_CLUSTER_RESOURCE_NM    TEXT( "ClusterResourceName")

//
// To allow WINS to revert back to 351 jet and db
//
#define  WINSCNF_USE_351DB_NM           TEXT("Use351Db")
#define  WINSCNF_USE_4DB_NM           TEXT("Use4Db")

#if MCAST > 0
#define  WINSCNF_USE_SELF_FND_PNRS_NM    TEXT("UseSelfFndPnrs")
#define  WINSCNF_SELF_FND_NM             TEXT("SelfFnd")
#define  WINSCNF_MCAST_TTL_NM            TEXT("McastTtl")
#define  WINSCNF_MCAST_INTVL_NM          TEXT("McastIntvl")
#endif

#define  WINSCNF_WINS_PORT_NO_NM         TEXT("PortNo")

// persona grata/non-grata registry names have to be ASCII. The registry is queried
// through RegQueryValueExA() calls (see GetOwnerList() from winscnf.c)
#define  PERSMODE_NON_GRATA             0
#define  PERSMODE_GRATA                 1
#define  WINSCNF_PERSONA_MODE_NM        "PersonaMode"
#define  WINSCNF_PERSONA_NON_GRATA_NM   "PersonaNonGrata"
#define  WINSCNF_PERSONA_GRATA_NM       "PersonaGrata"

#if PRSCONN
#define WINSCNF_PRS_CONN_NM              TEXT("PersistentRplOn")
#endif

//
// Spoof reg/ref
//
#define  WINSCNF_BURST_HANDLING_NM    TEXT("BurstHandling")
#define  WINSCNF_BURST_QUE_SIZE_NM    TEXT("BurstQueSize")
// to enable round-robin list of 1C member addresses
#define  WINSCNF_RANDOMIZE_1C_LIST_NM TEXT("Randomize1CList")

//
//  NOTE NOTE NOTE
//
// This should never be set to FALSE in the registry unless we notice
// a major bug in WINS that is resulting in replication to stop. This
// parameter is a hatch door at best to get around an insidious bug
// that may escape us during our testing -- Good insurance policy
//
#define  WINSCNF_NO_RPL_ON_ERR_NM        TEXT("NoRplOnErr")

//
// FUTURES - remove when JetBackup is internationalized.  Also, update
// WinsCnfReadWinsInfo.
//
#define  WINSCNF_ASCII_BACKUP_DIR_PATH_NM   "BackupDirPath"
#define  WINSCNF_INT_VERSNO_NEXTTIME_LW_NM  TEXT("WinsInternalVersNoNextTime_LW")
#define  WINSCNF_INT_VERSNO_NEXTTIME_HW_NM  TEXT("WinsInternalVersNoNextTime_HW")
#define  WINSCNF_DO_BACKUP_ON_TERM_NM       TEXT("DoBackupOnTerm")
#define  WINSCNF_MIGRATION_ON_NM            TEXT("MigrateOn")
#define  WINSCNF_REG_QUE_MAX_LEN_NM         TEXT("RegQueMaxLen")

//
// Names to use in the registry for values of the PUSH/PULL sub-keys
//
#define  WINSCNF_ADDCHG_TRIGGER_NM          TEXT("RplOnAddressChg")
#define  WINSCNF_RETRY_COUNT_NM             TEXT("CommRetryCount")

//
// Under IP address of a Push pnr
//
#define  WINSCNF_SP_TIME_NM                 TEXT("SpTime")
#define  WINSCNF_RPL_INTERVAL_NM            TEXT("TimeInterval")
#define  WINSCNF_MEMBER_PREC_NM             TEXT("MemberPrecedence")

//
// Under IP address of a Pull pnr
//
#define  WINSCNF_UPDATE_COUNT_NM            TEXT("UpdateCount")

//
// Both pull/push pnr
//
#define  WINSCNF_ONLY_DYN_RECS_NM           TEXT("OnlyDynRecs")
//
// Value of the PULL/PUSH key
//
#define  WINSCNF_INIT_TIME_RPL_NM           TEXT("InitTimeReplication")

//
// Value of the PUSH key
//
#define  WINSCNF_PROP_NET_UPD_NTF          TEXT("PropNetUpdNtf")


//
// Indicate whether propagation is to be done or not
//
#define DO_PROP_NET_UPD_NTF    TRUE
#define DONT_PROP_NET_UPD_NTF    FALSE


//
// if "OnlyWithCnfPnrs" is set to TRUE, replication will be performed only
// with those partners that are listed under the Pull/Push key.  If not
// set to TRUE, replication can be initiated even with unlisted partners
// as a result of administrative action or as a result of receiving an
// update notification
//
#define  WINSCNF_RPL_ONLY_W_CNF_PNRS_NM TEXT("RplOnlyWCnfPnrs")

//
// This DWORD can be under the Partners, Partners\Pull,
// Partners\Push  keys or under a partner's ip address key.  If it is in more
// than in one place in the key heirarchy, the lower one overrides the upper
// one.
//
// Each bit indicates the kind of replication we want/don't want.
// If no bit is set or if this parameter is not defined, it means
// replicate everything (unless WINSCNF_ONLY_DYN_RECS_NM is defined - ideally
// that should be represented by a bit in this DWORD but that is river under
// the bridge and I don't want to get rid of that parameter since folks are
// used to it, it being in the doc set and all). Currently the following is
// defined

//
// All replication under the constraint of WINSCNF_ONLY_DYN_RECS_NM if defined
//
#define WINSCNF_RPL_DEFAULT_TYPE                 0x0

//
//  LSB - Replicate only the special group names (special groups - domains and
//  user defined special groups)
//
#define WINSCNF_RPL_SPEC_GRPS_N_PDC         0x1
#define WINSCNF_RPL_ONLY_DYN_RECS           0x80000000
#define WINSCNF_RPL_TYPE_NM                 TEXT("ReplicationType")

//
// Path to log file
//
#define  WINSCNF_LOG_FLAG_NM           TEXT("LoggingOn")
#define  WINSCNF_LOG_FILE_PATH_NM TEXT("LogFilePath")

#define  WINSCNF_MAX_CHL_RETRIES        3        //max. # of retries RFC 1002
                                                //page 83
#if 0
#define  WINSCNF_CHL_RETRY_INTERVAL        250        //Time interval (in msecs)
                                                //between retries -- RFC 1002
                                                //page 83
#endif
#define  WINSCNF_CHL_RETRY_INTERVAL        500        //Time interval (in msecs)

#define  WINSCNF_PROC_HIGH_PRIORITY_CLASS        HIGH_PRIORITY_CLASS
#define  WINSCNF_PROC_PRIORITY_CLASS        NORMAL_PRIORITY_CLASS
#define  WINSCNF_SCV_PRIORITY_LVL        THREAD_PRIORITY_BELOW_NORMAL




//
// The Retry timeout is kept as 10 secs.  It will be typically << the time
// interval for replication, allowing us to retry a number of times
// prior to the next replication cycle.
//
//
//  The Retry Time Interval is not used presently.  We are using the
//  replication time interval for retries.  This makes things simpler
//
#define         WINSCNF_RETRY_TIME_INT                10        //time interval for retries
                                                //if there is a comm failure
#define  WINSCNF_MAX_COMM_RETRIES         3     //max. number of retries before
                                               //giving up trying to set up
                                               //communications with a WINS

//
// Precedence of remote members (of special groups) registered by a WINS
// relative to the same registered by other WINS servers (used during
// pull replication)
//
// Locally registered members always have high precedence
//
// Make sure that WINSCNF_LOW_PREC < WINSCNF_HIGH_PREC (this fact is used in
// nmsnmh.c- UnionGrps())
//
//
#define    WINSCNF_LOW_PREC        0
#define    WINSCNF_HIGH_PREC        1


//
// After replication with a WINS has stopped because of persistent
// communication failure (i.e. after all retries have been exhausted),
// WINS will wait until the following number of replication time intervals
// have elapsed before starting the retries again.  If replication
// got stopped with more than one WINS partner with the same time interval
// (for pulling from it), then retry will be done for all these WINS when
// it is done for one (in other words, resumption of replication for a WINS
// may happen sooner than you think).
//
// We need to keep this number at least 2 since if we have not been able to
// communicate with the WINS server for WINSCNF_MAX_COMM_RETRIES times
// in the past WINSCNF_MAX_COMM_RETRIES * replication interval for the WINS,
// then it is highly probable that the WINS server is down for good.  We
// retry again after the 'backoff' time.  Hopefully, by then the admin would
// have corrected the problem. Now, it is possible (unlikely though) that
// the WINS server happened to be down only at the times this WINS tried to
// contact it. We have no way to determine that.
//
//
// This can be made a registry parameter. This can be called the sleep time
// between successive rounds of retries.
//
#define WINSCNF_RETRY_AFTER_THIS_MANY_RPL        2

//
// if the time interval for periodic replication with a partner with which
// a WINS server has had consecutive comm. failures is more than the
// following amount, we don't back off as explained above
//
//
#define WINSCNF_MAX_WAIT_BEFORE_RETRY_RPL       ONEDAY    //1 day

//
// The max. number of comcurrent static initializations that can be
// happening.  These may be due to commands from the admin. tool or
// due to registry notifications.
//
#define  WINSCNF_MAX_CNCRNT_STATIC_INITS        3

//
// No of records to handle at one time (used by the scavenger thread).  This
// number determines the size of the memory block that will be allocated
// by NmsDbGetDataRecs().
//
//#define  WINSCNF_SCV_CHUNK                1000
#define  WINSCNF_SCV_CHUNK                3000

//
// defines
//
//
// Refresh interval - time period after which the state of an ACTIVE entry in
//                            the db is set to NMSDB_E_RELEASED if it has not
//                      been refreshed
//

#define WINSCNF_MIN_REFRESH_INTERVAL            FORTY_MTS
#define WINSCNF_DEF_REFRESH_INTERVAL            SIX_DAYS   //FOUR_DAYS

#define REF_MULTIPLIER_FOR_ACTIVE           2

//
// The Tombstone Interval (the interval a record stays released) should be
// a multiple of the RefreshInterval by at least the following amount
//
// With 2 as the value and refresh time interval being 4 days, TombInterval
// is max(8 days, 2 * MaxRplInterval) i.e at least 8 days.
//
#define REF_MULTIPLIER_FOR_TOMB                   2

//
// Challenge Retry interval
//

#define WINSCNF_MIN_INIT_CHL_RETRY_INTVL        250
#define WINSCNF_DEF_INIT_CHL_RETRY_INTVL        500

//
// Challenge Max. No. of Retries
//

#define WINSCNF_MIN_CHL_MAX_RETRIES        1
#define WINSCNF_DEF_CHL_MAX_RETRIES        3

//
// Also the min. tombstone timeout should be
//  max(RefreshInterval, RPL_MULTIPLIER_FOR_TOMBTMOUT * MaxRplInterval)
//
// With Refresh Interval being 4 days, this will be atleast 4 days.
//
#define RPL_MULTIPLIER_FOR_TOMBTMOUT                4

//
// The verify interval should be a multiple of the tombstone time
// interval by at least the following amount.  Keep the total time high
//
// With with the min. tombstone interval being at least 8 days, it will be at
// least (3 * 8 = 24 days)
//
#define TOMB_MULTIPLIER_FOR_VERIFY         3

//
// Tombstone interval - time period after which the state of a released
//                         entry is changed to NMSDB_E_TOMBSTONE if it has not
//                     been refreshed
//
#define WINSCNF_MIN_TOMBSTONE_INTERVAL        (WINSCNF_MIN_REFRESH_INTERVAL * REF_MULTIPLIER_FOR_TOMB)

//
// Time period after which the tombstone should be deleted.  The min. value
// is 1 days.  This is to cut down on the possibility of a
// tombstone getting deleted prior to it getting replicated to another WINS.
//
#define WINSCNF_MIN_TOMBSTONE_TIMEOUT                max(WINSCNF_MIN_REFRESH_INTERVAL, ONEDAY)

//
// Minimum time period for doing verifications of the replicas in the db
//
// Should be atleast 24 days.
//
#define WINSCNF_MIN_VERIFY_INTERVAL                max(TWENTY_FOUR_DAYS, (WINSCNF_MIN_TOMBSTONE_INTERVAL * TOMB_MULTIPLIER_FOR_VERIFY))

#define  WINSCNF_CC_INTVL_NM            TEXT("TimeInterval")
#define  WINSCNF_CC_MAX_RECS_AAT_NM     TEXT("MaxRecsAtATime")
#define  WINSCNF_CC_USE_RPL_PNRS_NM     TEXT("UseRplPnrs")

#define WINSCNF_CC_DEF_INTERVAL               ONEDAY
#define WINSCNF_CC_MIN_INTERVAL               (ONEDAY/4)

#define WINSCNF_DEF_CC_SP_HR               2       //02 hrs - 2am


#define WINSCNF_CC_MIN_RECS_AAT        1000
#define WINSCNF_CC_DEF_RECS_AAT        30000

#define WINSCNF_CC_DEF_USE_RPL_PNRS    0

#if 0
//
// Make the refresh interval equal to twice the max. replication time interval
// if that is greater than the refresh interval.
//
#define  WINSCNF_MAKE_REF_INTVL_M(RefreshInterval, MaxRplIntvl)  max(REF_MULTIPLIER_FOR_ACTIVE * (MaxRplIntvl), RefreshInterval)
#endif

//
// The Tombstone interval should never be allowed to go over 4 days. We
// don't want a record to remain released for longer than that.  It should
// turn into a tombstone so that it gets replicated.
//
// The reason we change the state of a record to released is to avoid
// replication if the reason for the release is a temporary shutdown of
// the pc.  We have to consider a long weekend (3 days).  We however
// also need to consider the fact that if the refresh interval is 40 mts or
// some such low value, then we should not keep the record in the released
// state for more than a day at the most.  Consider a situation where
// a node registers with the backup because the primary is down and then
// goes back to the primary when it comes up.  The primary does not
// increment the version number because the record is stil active.  The
// record gets released at the backup and stays that way until it becomes
// a tombstone which results in replication and the backup again getting
// the active record from the primary.  For the above situaion, we should
// make sure of two things: first - the record does not have an overly large
// tombstone interval; second - the replication time interval is small. We
// don't want to change the replication time interval set by the admin. but
// we can do something about the former.
//
// As long as the user sticks with the default refresh interval, the tombstone
// interval will be the same as that.
//
// For the case where the user specifies a different refresh interval, we use
// a max. of the refresh interval and a multiple of the max. rpl. interval.
//
//

#define  WINSCNF_MAKE_TOMB_INTVL_M(RefreshInterval, MaxRplIntvl)  min(max(REF_MULTIPLIER_FOR_TOMB * (MaxRplIntvl), RefreshInterval), FOUR_DAYS)

#define  WINSCNF_MAKE_TOMB_INTVL_0_M(RefreshInterval)  min(RefreshInterval, FOUR_DAYS)

//
// macro to get the minimum tombstone timeout based on the maximum replication
// time interval.
//
#define  WINSCNF_MAKE_TOMBTMOUT_INTVL_M(MaxRplIntvl)  max(WINSCNF_MIN_TOMBSTONE_TIMEOUT,(RPL_MULTIPLIER_FOR_TOMBTMOUT * (MaxRplIntvl)))


//
// Macro to get the minimum verify interval based on tombstone interval
//
// Should be atleast 8 days.
//
#define  WINSCNF_MAKE_VERIFY_INTVL_M(TombstoneInterval)  max(TWENTY_FOUR_DAYS, (TOMB_MULTIPLIER_FOR_VERIFY * (TombstoneInterval)))


//
// Min. Mcast TTL
//
#define WINSCNF_MIN_MCAST_TTL              TTL_SUBNET_ONLY
#define WINSCNF_DEF_MCAST_TTL              TTL_REASONABLE_REACH
#define WINSCNF_MAX_MCAST_TTL              32
#define WINSCNF_MIN_MCAST_INTVL            FORTY_MTS
#define WINSCNF_DEF_MCAST_INTVL            FORTY_MTS

#define WINS_QUEUE_HWM        500
#define WINS_QUEUE_HWM_MAX      5000
#define WINS_QUEUE_HWM_MIN       50

#endif _WINSCNST_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\winipsec.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    winipsec.h

Abstract:

    Header file for IPSec WINAPIs.

Author:

    krishnaG    21-September-1999

Environment:

    User Level: Win32

Revision History:

    abhisheV    21-September-1999    Added the structures.

--*/


#ifndef _WINIPSEC_
#define _WINIPSEC_


#ifdef __cplusplus
extern "C" {
#endif


#define     PERSIST_SPD_OBJECT      (ULONG) 0x00000001

#define     IP_ADDRESS_ME           (ULONG) 0x00000000
#define     IP_ADDRESS_MASK_NONE    (ULONG) 0xFFFFFFFF
#define     SUBNET_ADDRESS_ANY      (ULONG) 0x00000000
#define     SUBNET_MASK_ANY         (ULONG) 0x00000000


#define     FILTER_NATURE_PASS_THRU     0x00000001
#define     FILTER_NATURE_BLOCKING      0x00000002
#define     FILTER_DIRECTION_INBOUND    0x00000004
#define     FILTER_DIRECTION_OUTBOUND   0x00000008


#define     ENUM_GENERIC_FILTERS           0x00000001
#define     ENUM_SELECT_SPECIFIC_FILTERS   0x00000002
#define     ENUM_SPECIFIC_FILTERS          0x00000004


//
// Policy flags.
//

#define IPSEC_MM_POLICY_ENABLE_DIAGNOSTICS  0x00000001
#define IPSEC_MM_POLICY_DEFAULT_POLICY      0x00000002
#define IPSEC_MM_POLICY_ON_NO_MATCH         0x00000004
#define IPSEC_MM_POLICY_DISABLE_CRL         0x00000008
#define IPSEC_MM_POLICY_DISABLE_NEGOTIATE   0x00000010


#define IPSEC_QM_POLICY_TRANSPORT_MODE  0x00000000
#define IPSEC_QM_POLICY_TUNNEL_MODE     0x00000001
#define IPSEC_QM_POLICY_DEFAULT_POLICY  0x00000002
#define IPSEC_QM_POLICY_ALLOW_SOFT      0x00000004
#define IPSEC_QM_POLICY_ON_NO_MATCH     0x00000008
#define IPSEC_QM_POLICY_DISABLE_NEGOTIATE 0x00000010


#define IPSEC_MM_AUTH_DEFAULT_AUTH      0x00000001
#define IPSEC_MM_AUTH_ON_NO_MATCH       0x00000002


#define RETURN_DEFAULTS_ON_NO_MATCH     0x00000001


//
// Delete MM SA flags.
//

#define IPSEC_MM_DELETE_ASSOCIATED_QMS  0x00000001


#define IPSEC_SA_TUNNEL         0x00000001
#define IPSEC_SA_REPLAY         0x00000002
#define IPSEC_SA_DELETE         0x00000004
#define IPSEC_SA_MANUAL         0x00000010

#define IPSEC_SA_MULTICAST_MIRROR 0x00000020
#define IPSEC_SA_INBOUND          0x00000040
#define IPSEC_SA_OUTBOUND         0x00000080
#define IPSEC_SA_DISABLE_IDLE_OUT 0x00000100

#define IPSEC_SA_DISABLE_ANTI_REPLAY_CHECK 0x00000200
#define IPSEC_SA_DISABLE_LIFETIME_CHECK    0x00000400






//
// Bounds for number of offers
//
#define IPSEC_MAX_MM_OFFERS	20
#define IPSEC_MAX_QM_OFFERS	50

typedef enum _ADDR_TYPE {
    IP_ADDR_UNIQUE = 1,
    IP_ADDR_SUBNET,
    IP_ADDR_INTERFACE,
} ADDR_TYPE, * PADDR_TYPE;


typedef struct _ADDR {
    ADDR_TYPE AddrType;
    ULONG uIpAddr;
    ULONG uSubNetMask;
    GUID gInterfaceID;
} ADDR, * PADDR;


typedef enum _PROTOCOL_TYPE {
    PROTOCOL_UNIQUE = 1,
} PROTOCOL_TYPE, * PPROTOCOL_TYPE;


typedef struct _PROTOCOL {
    PROTOCOL_TYPE ProtocolType;
    DWORD dwProtocol;
} PROTOCOL, * PPROTOCOL;


typedef enum _PORT_TYPE {
    PORT_UNIQUE = 1,
} PORT_TYPE, * PPORT_TYPE;


typedef struct _PORT {
    PORT_TYPE PortType;
    WORD wPort;
} PORT, * PPORT;


typedef enum _IF_TYPE {
    INTERFACE_TYPE_ALL = 1,
    INTERFACE_TYPE_LAN,
    INTERFACE_TYPE_DIALUP,
    INTERFACE_TYPE_MAX
} IF_TYPE, * PIF_TYPE;


typedef enum _FILTER_FLAG {
    PASS_THRU = 1,
    BLOCKING,
    NEGOTIATE_SECURITY,
    FILTER_FLAG_MAX
} FILTER_FLAG, * PFILTER_FLAG;


typedef struct _TRANSPORT_FILTER {
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    FILTER_FLAG InboundFilterFlag;
    FILTER_FLAG OutboundFilterFlag;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gPolicyID;
} TRANSPORT_FILTER, * PTRANSPORT_FILTER;


//
// Maximum number of transport filters that can be enumerated
// by SPD at a time.
//

#define MAX_TRANSPORTFILTER_ENUM_COUNT 1000


typedef struct _TUNNEL_FILTER {
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    ADDR SrcTunnelAddr;
    ADDR DesTunnelAddr;
    FILTER_FLAG InboundFilterFlag;
    FILTER_FLAG OutboundFilterFlag;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gPolicyID;
} TUNNEL_FILTER, * PTUNNEL_FILTER;


//
// Maximum number of tunnel filters that can be enumerated
// by SPD at a time.
//

#define MAX_TUNNELFILTER_ENUM_COUNT 1000


typedef struct _MM_FILTER {
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gMMAuthID;
    GUID gPolicyID;
} MM_FILTER, * PMM_FILTER;


//
// Maximum number of main mode filters that can be enumerated
// by SPD at a time.
//

#define MAX_MMFILTER_ENUM_COUNT 1000


//
//  Common Structures for Main Mode and Quick Mode Policies.
//


//
// IPSEC DOI ESP algorithms supported by SPD.
//

typedef enum _IPSEC_DOI_ESP_ALGO {
    IPSEC_DOI_ESP_NONE = 0,
    IPSEC_DOI_ESP_DES,
    IPSEC_DOI_ESP_3_DES = 3,
    IPSEC_DOI_ESP_MAX
} IPSEC_DOI_ESP_ALGO, * PIPSEC_DOI_ESP_ALGO;


//
// IPSEC DOI AH algorithms supported by SPD.
//

typedef enum _IPSEC_DOI_AH_ALGO {
    IPSEC_DOI_AH_NONE = 0,
    IPSEC_DOI_AH_MD5,
    IPSEC_DOI_AH_SHA1,
    IPSEC_DOI_AH_MAX
} IPSEC_DOI_AH_ALGO, * PIPSEC_DOI_AH_ALGO;


//
// Types of IPSEC Operations supported by SPD.
//

typedef enum _IPSEC_OPERATION {
    NONE = 0,
    AUTHENTICATION,
    ENCRYPTION,
    COMPRESSION,
    SA_DELETE
} IPSEC_OPERATION, * PIPSEC_OPERATION;


//
// HMAC authentication algorithm to use with IPSEC
// Encryption operation.
//

typedef enum _HMAC_AH_ALGO {
    HMAC_AH_NONE = 0,
    HMAC_AH_MD5,
    HMAC_AH_SHA1,
    HMAC_AH_MAX
} HMAC_AH_ALGO, * PHMAC_AH_ALGO;


//
// Key Lifetime structure.
//

typedef struct  _KEY_LIFETIME {
    ULONG uKeyExpirationTime;
    ULONG uKeyExpirationKBytes;
} KEY_LIFETIME, * PKEY_LIFETIME;


//
// Main mode policy structures.
//


//
// Main mode authentication algorithms supported by SPD.
//

typedef enum _MM_AUTH_ENUM {
    IKE_PRESHARED_KEY = 1,
    IKE_DSS_SIGNATURE,
    IKE_RSA_SIGNATURE,
    IKE_RSA_ENCRYPTION,
    IKE_SSPI
} MM_AUTH_ENUM, * PMM_AUTH_ENUM;


//
// Main mode authentication information structure.
//

typedef struct _IPSEC_MM_AUTH_INFO {
    MM_AUTH_ENUM AuthMethod;
    DWORD dwAuthInfoSize;
#ifdef __midl
    [size_is(dwAuthInfoSize)] LPBYTE pAuthInfo;
#else
    LPBYTE pAuthInfo;
#endif
} IPSEC_MM_AUTH_INFO, * PIPSEC_MM_AUTH_INFO;


//
// Main mode authentication methods.
//

typedef struct _MM_AUTH_METHODS {
    GUID gMMAuthID;
    DWORD dwFlags;
    DWORD dwNumAuthInfos;
#ifdef __midl
    [size_is(dwNumAuthInfos)] PIPSEC_MM_AUTH_INFO pAuthenticationInfo;
#else
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo;
#endif
} MM_AUTH_METHODS, * PMM_AUTH_METHODS;


//
// Maximum number of main mode auth methods that can be enumerated
// by SPD at a time.
//

#define MAX_MMAUTH_ENUM_COUNT 1000


//
// Main mode algorithm structure.
//

typedef struct _IPSEC_MM_ALGO {
    ULONG uAlgoIdentifier;
    ULONG uAlgoKeyLen;
    ULONG uAlgoRounds;
} IPSEC_MM_ALGO, * PIPSEC_MM_ALGO;


//
// Main mode policy offer structure.
//

typedef struct _IPSEC_MM_OFFER {
    KEY_LIFETIME Lifetime;
    DWORD dwFlags;
    DWORD dwQuickModeLimit;
    DWORD dwDHGroup;
    IPSEC_MM_ALGO EncryptionAlgorithm;
    IPSEC_MM_ALGO HashingAlgorithm;
} IPSEC_MM_OFFER, * PIPSEC_MM_OFFER;


//
// Defines for DH groups.
//

#define DH_GROUP_1 0x00000001   // For Diffe Hellman group 1.
#define DH_GROUP_2 0x00000002   // For Diffe Hellman group 2.


//
// Default Main Mode key expiration time.
//

#define DEFAULT_MM_KEY_EXPIRATION_TIME 480*60 // 8 hours expressed in seconds.


//
// Maximum number of main mode policies that can be enumerated
// by SPD at a time.
//

#define MAX_MMPOLICY_ENUM_COUNT 10


//
// Main mode policy structure.
//

typedef struct  _IPSEC_MM_POLICY {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD dwFlags;
    ULONG uSoftSAExpirationTime;
    DWORD dwOfferCount;
#ifdef __midl
    [size_is(dwOfferCount)] PIPSEC_MM_OFFER pOffers;
#else
    PIPSEC_MM_OFFER pOffers;
#endif
} IPSEC_MM_POLICY, * PIPSEC_MM_POLICY;


//
// Quick mode policy structures.
//


typedef DWORD IPSEC_QM_SPI, * PIPSEC_QM_SPI;


//
// Quick mode algorithm structure.
//

typedef struct  _IPSEC_QM_ALGO {
    IPSEC_OPERATION Operation;
    ULONG uAlgoIdentifier;
    HMAC_AH_ALGO uSecAlgoIdentifier;
    ULONG uAlgoKeyLen;
    ULONG uSecAlgoKeyLen;
    ULONG uAlgoRounds;
    IPSEC_QM_SPI MySpi;
    IPSEC_QM_SPI PeerSpi;
} IPSEC_QM_ALGO, * PIPSEC_QM_ALGO;


//
// Maximum number of quick mode algorithms in
// a quick mode policy offer.
//

#define QM_MAX_ALGOS    2


//
// Quick mode policy offer structure.
//

typedef struct _IPSEC_QM_OFFER {
    KEY_LIFETIME Lifetime;
    DWORD dwFlags;
    BOOL bPFSRequired;
    DWORD dwPFSGroup;
    DWORD dwNumAlgos;
    IPSEC_QM_ALGO Algos[QM_MAX_ALGOS];
} IPSEC_QM_OFFER, * PIPSEC_QM_OFFER;


//
// Defines for PFS groups.
//

#define PFS_GROUP_NONE 0x00000000   // If PFS is not required.
#define PFS_GROUP_1    0x00000001   // For Diffe Hellman group 1 PFS.
#define PFS_GROUP_2    0x00000002   // For Diffe Hellman group 2 PFS.
#define PFS_GROUP_MM   0x10000000   // Use group negotiated in MM


//
// Default Quick Mode key expiration time.
//

#define DEFAULT_QM_KEY_EXPIRATION_TIME 60*60 // 1 hour expressed in seconds.


//
// Default Quick Mode key expiration kbytes.
//

#define DEFAULT_QM_KEY_EXPIRATION_KBYTES 100*1000 // 100 MB expressed in KB.


//
// Maximum number of quick mode policies that can be enumerated
// by SPD at a time.
//

#define MAX_QMPOLICY_ENUM_COUNT 10


//
// Quick mode policy structure.
//

typedef struct _IPSEC_QM_POLICY {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD dwFlags;
    DWORD dwOfferCount;
#ifdef __midl
    [size_is(dwOfferCount)] PIPSEC_QM_OFFER pOffers;
#else
    PIPSEC_QM_OFFER pOffers;
#endif
} IPSEC_QM_POLICY, * PIPSEC_QM_POLICY;


//
// IKE structures.
//

typedef struct _IKE_STATISTICS {
    DWORD dwActiveAcquire;
    DWORD dwActiveReceive;
    DWORD dwAcquireFail;
    DWORD dwReceiveFail;
    DWORD dwSendFail;
    DWORD dwAcquireHeapSize;
    DWORD dwReceiveHeapSize;
    DWORD dwNegotiationFailures;
    DWORD dwAuthenticationFailures;
    DWORD dwInvalidCookiesReceived;
    DWORD dwTotalAcquire;
    DWORD dwTotalGetSpi;
    DWORD dwTotalKeyAdd;
    DWORD dwTotalKeyUpdate;
    DWORD dwGetSpiFail;
    DWORD dwKeyAddFail;
    DWORD dwKeyUpdateFail;
    DWORD dwIsadbListSize;
    DWORD dwConnListSize;
    DWORD dwOakleyMainModes;
    DWORD dwOakleyQuickModes;
    DWORD dwSoftAssociations;
    DWORD dwInvalidPacketsReceived;
} IKE_STATISTICS, * PIKE_STATISTICS;


typedef LARGE_INTEGER IKE_COOKIE, * PIKE_COOKIE;


typedef struct _IKE_COOKIE_PAIR {
    IKE_COOKIE Initiator;
    IKE_COOKIE Responder;
} IKE_COOKIE_PAIR, * PIKE_COOKIE_PAIR;


typedef struct _IPSEC_BYTE_BLOB {
    DWORD dwSize;
#ifdef __midl
    [size_is(dwSize)] LPBYTE pBlob;
#else
    LPBYTE pBlob;
#endif
} IPSEC_BYTE_BLOB, * PIPSEC_BYTE_BLOB;


typedef struct _IPSEC_MM_SA {
    GUID gMMPolicyID;
    IPSEC_MM_OFFER SelectedMMOffer;
    MM_AUTH_ENUM MMAuthEnum;
    IKE_COOKIE_PAIR MMSpi;
    ADDR Me;
    IPSEC_BYTE_BLOB MyId;
    IPSEC_BYTE_BLOB MyCertificateChain;
    ADDR Peer;
    IPSEC_BYTE_BLOB PeerId;
    IPSEC_BYTE_BLOB PeerCertificateChain;
    DWORD dwFlags;
} IPSEC_MM_SA, * PIPSEC_MM_SA;


typedef enum _QM_FILTER_TYPE {
      QM_TRANSPORT_FILTER = 1,
      QM_TUNNEL_FILTER
} QM_FILTER_TYPE, * PQM_FILTER_TYPE;


typedef struct _IPSEC_QM_FILTER {
    QM_FILTER_TYPE QMFilterType;
    ADDR SrcAddr;
    ADDR DesAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    ADDR MyTunnelEndpt;
    ADDR PeerTunnelEndpt;
    DWORD dwFlags;
} IPSEC_QM_FILTER, * PIPSEC_QM_FILTER;


typedef struct _IPSEC_QM_SA {
    GUID gQMPolicyID;
    IPSEC_QM_OFFER SelectedQMOffer;
    GUID gQMFilterID;
    IPSEC_QM_FILTER IpsecQMFilter;
    IKE_COOKIE_PAIR MMSpi;
} IPSEC_QM_SA, * PIPSEC_QM_SA;


#define MAX_QMSA_ENUM_COUNT 1000


typedef enum _SA_FAIL_MODE {
    MAIN_MODE = 1,
    QUICK_MODE,
} SA_FAIL_MODE, * PSA_FAIL_MODE;


typedef enum _SA_FAIL_POINT {
    FAIL_POINT_ME = 1,
    FAIL_POINT_PEER,
} SA_FAIL_POINT, * PSA_FAIL_POINT;


typedef struct _SA_NEGOTIATION_STATUS_INFO {
    SA_FAIL_MODE FailMode;
    SA_FAIL_POINT FailPoint;
    DWORD dwError;
} SA_NEGOTIATION_STATUS_INFO, * PSA_NEGOTIATION_STATUS_INFO;


//
// IPSec structures.
//

typedef struct _IPSEC_STATISTICS {
    DWORD dwNumActiveAssociations;
    DWORD dwNumOffloadedSAs;
    DWORD dwNumPendingKeyOps;
    DWORD dwNumKeyAdditions;
    DWORD dwNumKeyDeletions;
    DWORD dwNumReKeys;
    DWORD dwNumActiveTunnels;
    DWORD dwNumBadSPIPackets;
    DWORD dwNumPacketsNotDecrypted;
    DWORD dwNumPacketsNotAuthenticated;
    DWORD dwNumPacketsWithReplayDetection;
    ULARGE_INTEGER uConfidentialBytesSent;
    ULARGE_INTEGER uConfidentialBytesReceived;
    ULARGE_INTEGER uAuthenticatedBytesSent;
    ULARGE_INTEGER uAuthenticatedBytesReceived;
    ULARGE_INTEGER uTransportBytesSent;
    ULARGE_INTEGER uTransportBytesReceived;
    ULARGE_INTEGER uBytesSentInTunnels;
    ULARGE_INTEGER uBytesReceivedInTunnels;
    ULARGE_INTEGER uOffloadedBytesSent;
    ULARGE_INTEGER uOffloadedBytesReceived;
} IPSEC_STATISTICS, * PIPSEC_STATISTICS;


typedef struct _IPSEC_INTERFACE_INFO {

    GUID gInterfaceID;
    DWORD dwIndex;
    LPWSTR pszInterfaceName;
    LPWSTR pszDeviceName;
    DWORD dwInterfaceType;
    ULONG uIpAddr;

} IPSEC_INTERFACE_INFO, * PIPSEC_INTERFACE_INFO;

//
// If dwInterfaceType is MIB_IF_TYPE_ETHERNET or MIB_IF_TYPE_FDDI
// or MIB_IF_TYPE_TOKENRING then its a LAN interface.
// If dwInterfaceType is MIB_IF_TYPE_PPP or MIB_IF_TYPE_SLIP
// then its a WAN/DIALUP interface.
//

#define MAX_INTERFACE_ENUM_COUNT 100


typedef struct _Record {
    DWORD SrcIpAddress;
    DWORD DesIpAddress;
}RECORD, *PRECORD;

//
// IPSEC SPD APIs.
//


DWORD
WINAPI
SPDApiBufferAllocate(
    DWORD dwByteCount,
    LPVOID * ppBuffer
    );


VOID
WINAPI
SPDApiBufferFree(
    LPVOID pBuffer
    );


DWORD
WINAPI
AddTransportFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PTRANSPORT_FILTER pTransportFilter,
    PHANDLE phFilter
    );


DWORD
WINAPI
DeleteTransportFilter(
    HANDLE hFilter
    );


DWORD
WINAPI
EnumTransportFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PTRANSPORT_FILTER * ppTransportFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetTransportFilter(
    HANDLE hFilter,
    PTRANSPORT_FILTER pTransportFilter
    );


DWORD
WINAPI
GetTransportFilter(
    HANDLE hFilter,
    PTRANSPORT_FILTER * ppTransportFilter
    );


DWORD
WINAPI
AddQMPolicy(
    LPWSTR pServerName,
    DWORD dwFlags,
    PIPSEC_QM_POLICY pQMPolicy
    );


DWORD
WINAPI
DeleteQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName
    );


DWORD
WINAPI
EnumQMPolicies(
    LPWSTR pServerName,
    PIPSEC_QM_POLICY * ppQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY pQMPolicy
    );


DWORD
WINAPI
GetQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY * ppQMPolicy
    );


DWORD
WINAPI
AddMMPolicy(
    LPWSTR pServerName,
    DWORD dwFlags,
    PIPSEC_MM_POLICY pMMPolicy
    );


DWORD
WINAPI
DeleteMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName
    );


DWORD
WINAPI
EnumMMPolicies(
    LPWSTR pServerName,
    PIPSEC_MM_POLICY * ppMMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY pMMPolicy
    );


DWORD
WINAPI
GetMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY * ppMMPolicy
    );


DWORD
WINAPI
AddMMFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PMM_FILTER pMMFilter,
    PHANDLE phMMFilter
    );


DWORD
WINAPI
DeleteMMFilter(
    HANDLE hMMFilter
    );


DWORD
WINAPI
EnumMMFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PMM_FILTER * ppMMFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMMFilters,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetMMFilter(
    HANDLE hMMFilter,
    PMM_FILTER pMMFilter
    );


DWORD
WINAPI
GetMMFilter(
    HANDLE hMMFilter,
    PMM_FILTER * ppMMFilter
    );


DWORD
WINAPI
MatchMMFilter(
    LPWSTR pServerName,
    PMM_FILTER pMMFilter,
    DWORD dwFlags,
    PMM_FILTER * ppMatchedMMFilters,
    PIPSEC_MM_POLICY * ppMatchedMMPolicies,
    PMM_AUTH_METHODS * ppMatchedMMAuthMethods,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
MatchTransportFilter(
    LPWSTR pServerName,
    PTRANSPORT_FILTER pTxFilter,
    DWORD dwFlags,
    PTRANSPORT_FILTER * ppMatchedTxFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
GetQMPolicyByID(
    LPWSTR pServerName,
    GUID gQMPolicyID,
    PIPSEC_QM_POLICY * ppQMPolicy
    );


DWORD
WINAPI
GetMMPolicyByID(
    LPWSTR pServerName,
    GUID gMMPolicyID,
    PIPSEC_MM_POLICY * ppMMPolicy
    );


DWORD
WINAPI
AddMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwFlags,
    PMM_AUTH_METHODS pMMAuthMethods
    );


DWORD
WINAPI
DeleteMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID
    );


DWORD
WINAPI
EnumMMAuthMethods(
    LPWSTR pServerName,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumAuthMethods,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS pMMAuthMethods
    );


DWORD
WINAPI
GetMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS * ppMMAuthMethods
    );


DWORD
IPSecInitiateIKENegotiation(
    LPWSTR pServerName,
    PIPSEC_QM_FILTER pQMFilter,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    DWORD dwFlags,
    PHANDLE phNegotiation
    );


DWORD
IPSecQueryIKENegotiationStatus(
    HANDLE hNegotiation,
    PSA_NEGOTIATION_STATUS_INFO pNegotiationStatus
    );


DWORD
IPSecCloseIKENegotiationHandle(
    HANDLE hNegotiation
    );


DWORD
IPSecEnumMMSAs(
    LPWSTR pServerName,
    PIPSEC_MM_SA pMMTemplate,
    PIPSEC_MM_SA * ppMMSAs,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle,
    DWORD dwFlags
    );


DWORD
IPSecDeleteMMSAs(
    LPWSTR pServerName,
    PIPSEC_MM_SA pMMTemplate,
    DWORD dwFlags
    );


DWORD
IPSecDeleteQMSAs(
    LPWSTR pServerName,
    PIPSEC_QM_SA pIpsecQMSA,
    DWORD dwFlags
    );


DWORD
IPSecQueryIKEStatistics(
    LPWSTR pServerName,
    PIKE_STATISTICS pIKEStatistics
    );


DWORD
IPSecRegisterIKENotifyClient(
    LPWSTR pServerName,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    IPSEC_QM_SA QMTemplate,
    PHANDLE phNotifyHandle,
    DWORD dwFlags
    );

DWORD IPSecQueryNotifyData(
    HANDLE hNotifyHandle,
    PDWORD pdwNumEntries,
    PIPSEC_QM_SA *ppQMSAs,
    DWORD dwFlags
    );

DWORD IPSecCloseNotifyHandle(
    HANDLE hNotifyHandle
    );

DWORD
WINAPI
QueryIPSecStatistics(
    LPWSTR pServerName,
    PIPSEC_STATISTICS * ppIpsecStatistics
    );


DWORD
WINAPI
EnumQMSAs(
    LPWSTR pServerName,
    PIPSEC_QM_SA pQMSATemplate,
    PIPSEC_QM_SA * ppQMSAs,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumQMSAs,
    LPDWORD pdwNumTotalQMSAs,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    );


DWORD
WINAPI
AddTunnelFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PTUNNEL_FILTER pTunnelFilter,
    PHANDLE phFilter
    );


DWORD
WINAPI
DeleteTunnelFilter(
    HANDLE hFilter
    );


DWORD
WINAPI
EnumTunnelFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PTUNNEL_FILTER * ppTunnelFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
SetTunnelFilter(
    HANDLE hFilter,
    PTUNNEL_FILTER pTunnelFilter
    );


DWORD
WINAPI
GetTunnelFilter(
    HANDLE hFilter,
    PTUNNEL_FILTER * ppTunnelFilter
    );


DWORD
WINAPI
MatchTunnelFilter(
    LPWSTR pServerName,
    PTUNNEL_FILTER pTnFilter,
    DWORD dwFlags,
    PTUNNEL_FILTER * ppMatchedTnFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    );


DWORD
WINAPI
OpenMMFilterHandle(
    LPWSTR pServerName,
    PMM_FILTER pMMFilter,
    PHANDLE phMMFilter
    );

DWORD
WINAPI
CloseMMFilterHandle(
    HANDLE hMMFilter
    );

DWORD
WINAPI
OpenTransportFilterHandle(
    LPWSTR pServerName,
    PTRANSPORT_FILTER pTransportFilter,
    PHANDLE phTxFilter
    );

DWORD
WINAPI
CloseTransportFilterHandle(
    HANDLE hTxFilter
    );

DWORD
WINAPI
OpenTunnelFilterHandle(
    LPWSTR pServerName,
    PTUNNEL_FILTER pTunnelFilter,
    PHANDLE phTnFilter
    );

DWORD
WINAPI
CloseTunnelFilterHandle(
    HANDLE hTnFilter
    );


DWORD
WINAPI
EnumIPSecInterfaces(
    LPWSTR pServerName,
    PIPSEC_INTERFACE_INFO pIpsecIfTemplate,
    PIPSEC_INTERFACE_INFO * ppIpsecInterfaces,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumInterfaces,
    LPDWORD pdwNumTotalInterfaces,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    );

DWORD
WINAPI
IPSecAddSAs(
    LPWSTR pServerName,
    PIPSEC_QM_OFFER pQMOffer,
    PIPSEC_QM_FILTER pQMFilter,
    HANDLE *hLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE *pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *pOutboundKeyMat,
    BYTE *pContextInfo,
    DWORD dwFlags
    );


#ifdef __cplusplus
}
#endif


#endif // _WINIPSEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\wzcmon.h ===
#include <wzcsapi.h>

#pragma once
# ifdef     __cplusplus
extern "C" {
# endif


#define MAX_RECORD_ENUM_COUNT        100

#define MAX_RAW_DATA_SIZE       4096


//
// Component IDs
//

#define DBLOG_COMPID_WZCSVC 0x00000001
#define DBLOG_COMPID_EAPOL  0x00000002

//
// Categories
//

#define DBLOG_CATEG_INFO   0x00000000
#define DBLOG_CATEG_WARN   0x00000001
#define DBLOG_CATEG_ERR    0x00000002
#define DBLOG_CATEG_PACKET 0x00000003


typedef struct _Wzc_Db_Record {
    DWORD recordid;
    DWORD componentid;
    DWORD category;
    FILETIME timestamp;
    RAW_DATA message;
    RAW_DATA localmac;
    RAW_DATA remotemac;
    RAW_DATA ssid;
    RAW_DATA context;
} WZC_DB_RECORD, * PWZC_DB_RECORD;


DWORD
WINAPI
OpenWZCDbLogSession(
    LPWSTR pServerName,
    DWORD dwVersion,
    PHANDLE phSession
    );


DWORD
WINAPI
CloseWZCDbLogSession(
    HANDLE hSession
    );


DWORD
WINAPI
AddWZCDbLogRecord(
    LPWSTR pServerName,
    DWORD dwVersion,
    PWZC_DB_RECORD pWZCRecord,
    LPVOID pvReserved
    );


DWORD
WINAPI
EnumWZCDbLogRecords(
    HANDLE hSession,
    PWZC_DB_RECORD pTemplateRecord,
    PBOOL pbEnumFromStart,
    DWORD dwPreferredNumEntries,
    PWZC_DB_RECORD * ppWZCRecords,
    LPDWORD pdwNumRecords,
    LPVOID pvReserved
    );


DWORD
WINAPI
FlushWZCDbLog(
    HANDLE hSession
    );


DWORD WINAPI
GetSpecificLogRecord(HANDLE hSession,
                     PWZC_DB_RECORD pwzcTemplate,
                     PWZC_DB_RECORD *ppWZCRecords,
                     LPDWORD        pdwNumRecords,
                     LPVOID  pvReserved);

# ifdef     __cplusplus
}
# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\wlbsconfig.h ===
//+----------------------------------------------------------------------------
//
// File:	 wlbsconfig.h
//
// Module:	 Network Load Balancing 
//
// Description: Internal APIs for cluster configuration.  Thes APIs are internal 
//              to WLBS team only, and no plan backward compatability.
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:	 fengsun Created    3/2/00
//
//+----------------------------------------------------------------------------



#ifndef _WLBSCONFIG_H
#define _WLBSCONFIG_H

#ifdef __cplusplus
extern "C" {
#endif

#include "wlbsctrl.h"

/* Maximum lengths of parameter strings. */

#define WLBS_MAX_VIRTUAL_NIC     256
#define WLBS_MAX_CLUSTER_NIC     256
#define WLBS_MAX_NETWORK_ADDR    17
#define WLBS_MAX_CL_IP_ADDR      17
#define WLBS_MAX_CL_NET_MASK     17
#define WLBS_MAX_DED_IP_ADDR     17 
#define WLBS_MAX_DED_NET_MASK    17
#define WLBS_MAX_NETWORK_ADDR    17
#define WLBS_MAX_LICENSE_KEY     20
#define WLBS_MAX_DOMAIN_NAME     100
#define WLBS_MAX_BDA_TEAM_ID     40

/* Port group rule - used in registry parameters.
   NOTE! do not access value marked with I. These are for internal use only. */

#pragma pack(1)

typedef struct
{
    DWORD       start_port,             /* Starting port number. */
                end_port;               /* Ending port number. */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       code;                 /* I: Unique rule code. */
#else
    DWORD       Private1;               // Do not change these field directly
#endif

    DWORD       mode;                   /* Filtering mode. */
    DWORD       protocol;               /* WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       valid;                /* I: For rule management in user mode. */
#else
    DWORD       Private2;               // Do not change these field directly
#endif

    union
    {
        struct
        {
            DWORD       priority;       /* Mastership priority: 1..32 or 0 for
                                           not-specified. */
        }           single;             /* Data for single server mode. */
        struct
        {
            WORD        equal_load;     /* TRUE - Even load distribution. */
            WORD        affinity;       /* WLBS_AFFINITY_... */
            DWORD       load;           /* Percentage of load to handle
                                           locally 0..100. */
        }           multi;              /* Data for multi-server mode. */
    }           mode_data;              /* Data for appropriate port group mode. */
}
WLBS_OLD_PORT_RULE, * PWLBS_OLD_PORT_RULE;

/* Structure to hold the bi-directional affinity registry settings. */
typedef struct _CVY_BDA {
    WCHAR       team_id[WLBS_MAX_BDA_TEAM_ID + 1];  /* The team ID - MUST be a GUID. */
    ULONG       active;                             /* On write, this flag determines whether to create BDATeaming key - BDA on/off switch. */
    ULONG       master;                             /* Boolean indication of master status. */
    ULONG       reverse_hash;                       /* Sets direction of hashing - forward (normal) or reverse. */
} WLBS_BDA, PWLBS_BDA;

typedef struct
{
    TCHAR       virtual_ip_addr [WLBS_MAX_CL_IP_ADDR + 1]; /* Virtual IP Address */
    DWORD       start_port,             /* Starting port number. */
                end_port;               /* Ending port number. */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       code;                 /* I: Unique rule code. */
#else
    DWORD       Private1;               // Do not change these field directly
#endif

    DWORD       mode;                   /* Filtering mode. */
    DWORD       protocol;               /* WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP */

#ifdef WLBSAPI_INTERNAL_ONLY
    DWORD       valid;                /* I: For rule management in user mode. */
#else
    DWORD       Private2;               // Do not change these field directly
#endif

    union
    {
        struct
        {
            DWORD       priority;       /* Mastership priority: 1..32 or 0 for
                                           not-specified. */
        }           single;             /* Data for single server mode. */
        struct
        {
            WORD        equal_load;     /* TRUE - Even load distribution. */
            WORD        affinity;       /* WLBS_AFFINITY_... */
            DWORD       load;           /* Percentage of load to handle
                                           locally 0..100. */
        }           multi;              /* Data for multi-server mode. */
    }           mode_data;              /* Data for appropriate port group mode. */
}
WLBS_PORT_RULE, * PWLBS_PORT_RULE;

#pragma pack()


#ifdef __cplusplus
typedef struct __declspec(dllexport)
#else
typedef struct 
#endif
{
    /* public - can be modified by clients of this API */
    DWORD       host_priority;          /* Host priority ID. */
    DWORD       alive_period;           /* Period for sending "I am alive" messages
                                           in milliseconds. */
    DWORD       alive_tolerance;        /* How many "I am alive" messages can be
                                           missed from other servers before assuming
                                           that the host is dead. */
    DWORD       num_actions;            /* Number of actions per allocation. */
    DWORD       num_packets;            /* number of packets per allocation. */
    DWORD       num_send_msgs;          /* Number of heartbeats per allocation. */
    DWORD       install_date;           /* Install time stamp, used to create a unique code for the host. */
    DWORD       rct_port;               /* Remote control UDP port. */
    DWORD       rct_enabled;            /* TRUE - remote control enabled. */
    DWORD       cluster_mode;           /* TRUE - join cluster on boot. */
    DWORD       dscr_per_alloc;         /* Number of connection tracking
                                           descriptor per allocation. */
    DWORD       max_dscr_allocs;        /* Maximum number of connection tracking
                                           descriptor allocations. */
    DWORD       mcast_support;          /* TRUE - multicast mode,
                                           FALSE - unicast mode */
    DWORD       mask_src_mac;           /* TRUE - Mangle source MAC address to
                                           prevent switch learning. FALSE -
                                           cluster is on a hub, optimizes switch
                                           performance by re-enabling learning. */

    TCHAR       cl_mac_addr [WLBS_MAX_NETWORK_ADDR + 1];
                                        /* Cluster MAC address. */
    TCHAR       cl_ip_addr [WLBS_MAX_CL_IP_ADDR + 1];
                                        /* Cluster IP address. */
    TCHAR       cl_net_mask [WLBS_MAX_CL_NET_MASK + 1];
                                        /* Netmask for cluster IP. */
    TCHAR       ded_ip_addr [WLBS_MAX_DED_IP_ADDR + 1];
                                        /* Dedicated IP address or "" for none. */
    TCHAR       ded_net_mask [WLBS_MAX_DED_NET_MASK + 1];
                                        /* Netmask for dedicated IP address
                                           or "" for none */
    TCHAR       domain_name [WLBS_MAX_DOMAIN_NAME + 1];
                                        /* FQDN of the cluster. */

    //
    // IGMP support
    //
    BOOL        fIGMPSupport; // whether to send IGMP join periodically
    WCHAR       szMCastIpAddress[WLBS_MAX_CL_IP_ADDR + 1]; // multicast IP
    BOOL        fIpToMCastIp; // whether to generate multicast IP from cluster IP
    
    WLBS_BDA    bda_teaming;

#ifdef __cplusplus
#ifndef WLBSAPI_INTERNAL_ONLY

    //
    // private - should be treated as opaque 
    //
    // Do not change these field directly
    //
    private:

#endif
#endif


    /* obtained from the registry */

    DWORD       i_parms_ver;            /* I: Parameter structure version. */
    DWORD       i_verify_date;          /* I: Encoded install time stamp. */
    DWORD       i_rmt_password;         /* I: Remote maintenance password. */
    DWORD       i_rct_password;         /* I: Remote control password (use
                                            WlbsSetRemotePassword to set this
                                            value). */
    DWORD       i_num_rules;            /* I: # active port group rules (changed
                                            through WlbsAddPortRule and
                                            WlbsDelPortRule routines). */
    DWORD       i_cleanup_delay;        /* I: Dirty connection cleanup delay in
                                            milliseconds, 0 - delay. */
    DWORD       i_scale_client;         /* I: Legacy parameter. */
    DWORD       i_mcast_spoof;          /* I: TRUE - Provide ARP resolution in
                                            multicast mode. FALSE - clients
                                            will rely on static ARP entries. */
    DWORD       i_convert_mac;          /* I: TRUE - automatically generate MAC
                                            address based on cluster IP
                                            address in UI. */
    DWORD       i_ip_chg_delay;         /* I: Delay in milliseconds to block
                                            outgoing ARPs while IP address
                                            change is in process. */
    DWORD       i_nbt_support;          /* I: TRUE - NBT cluster name support
                                            enabled. */
    DWORD       i_netmon_alive;         /* I: TRUE - pass heartbeat messages
                                            to the protocols (netmon). */
    DWORD       i_effective_version;    /* I: Effective version of NLB */

    /* strings */

    TCHAR       i_virtual_nic_name [WLBS_MAX_VIRTUAL_NIC + 1];
                                        /* I: Virtual NIC name or GUID. */
//    TCHAR       cluster_nic_name [WLBS_MAX_CLUSTER_NIC + 1];
                                        /* I: Cluster NIC name or GUID. */
    TCHAR       i_license_key [WLBS_MAX_LICENSE_KEY + 1];
                                      /* I: Legacy parameter. */

    WLBS_PORT_RULE  i_port_rules [WLBS_MAX_RULES];
                                        /* I: Port rules (changed
                                              through WlbsAddPortRule and
                                              WlbsDelPortRule routines). */
    /* computed */

    DWORD       i_max_hosts;            /* Legacy parameter. */
    DWORD       i_max_rules;            /* Legacy parameter. */
//    DWORD       i_expiration;           /* Legacy parameter. */
//    DWORD       i_ft_rules_enabled;     /* Legacy parameter. */
//    DWORD       version;              /* Legacy parameter. */

    DWORD i_dwReserved;
}
WLBS_REG_PARAMS, * PWLBS_REG_PARAMS;



/* API commands for WlbsFormatMessage */
typedef enum
{
    CmdWlbsAddPortRule,
    CmdWlbsAddressToName,
    CmdWlbsAddressToString,
    CmdWlbsAdjust,
    CmdWlbsCommitChanges,
    CmdWlbsDeletePortRule,
    CmdWlbsDestinationSet,
    CmdWlbsDisable,
    CmdWlbsDrain,
    CmdWlbsDrainStop,
    CmdWlbsEnable,
    CmdWlbsFormatMessage,
    CmdWlbsGetEffectiveVersion,
    CmdWlbsGetNumPortRules,
    CmdWlbsEnumPortRules,
    CmdWlbsGetPortRule,
    CmdWlbsInit,
    CmdWlbsPasswordSet,
    CmdWlbsPortSet,
    CmdWlbsQuery,
    CmdWlbsReadReg,
    CmdWlbsResolve,
    CmdWlbsResume,
    CmdWlbsSetDefaults,
    CmdWlbsSetRemotePassword,
    CmdWlbsStart,
    CmdWlbsStop,
    CmdWlbsSuspend,
    CmdWlbsTimeoutSet,
    CmdWlbsWriteReg
}
WLBS_COMMAND;

extern BOOL WINAPI WlbsFormatMessage
(
    DWORD           error,      /* IN  - WLBS_... or WSA... return value. */
    WLBS_COMMAND    command,    /* IN  - Which routine returned the value. */
    BOOL            cluster,    /* IN  - TRUE - command was issued on entire
                                         cluster, FALSE - single host. */
    WCHAR*          messagep,   /* IN  - Pointer to user-allocated buffer. */
    PDWORD          lenp        /* IN  - Buffer size.
                                   OUT - The required buffer size if the current
                                         size is insufficient */
);
/*
    Return character string describing specified WLBS API return code. Note that
    message will depend on the command which returned the code and if it was
    issued in cluster-wide or single-host mode.

    returns:
        TRUE  => Message formatted successfully.
        FALSE => Bad error code (lenp will contain 0 on exit) or buffer is not
                 big enough to contain entire string (lenp will contain required
                 buffer size on exit).
*/

/* Support routines: */


extern DWORD WINAPI WlbsResolve
(
    const WCHAR*           address     /* IN  - Internet host name or IP address in
                                         dotted notation. */
);
/*
    Resolve Internet host name to its IP address. This routine can also be
    used to convert a string containing an IP address in dotted notation to a
    value that can be passed to cluster control routines.

    returns:
        0               => failed to resolve host name.
        <address>       => IP address corresponding to the specified address.
                           This value can be used in subsequent calls to
                           cluster control routines.
*/


extern BOOL WINAPI WlbsAddressToString
(
    DWORD           address,    /* IN  - IP address. */
    WCHAR*           buf,        /* OUT - Character buffer for resulting
                                         string. */
    PDWORD          lenp        /* IN  - Buffer size in characters.
                                   OUT - Characters written or required buffer
                                         size. */
);
/*
    Convert IP address to a string in dotted notation.

    returns:
        TRUE            => Successfully converted. lenp contains number of
                           character written.
        FALSE           => Buffer too small. lenp contains required buffer size
                           including terminating NULL character.
*/


extern BOOL WINAPI WlbsAddressToName
(
    DWORD    address,    /* IN  - IP address. */
    WCHAR*          buf,        /* OUT - Character buffer for resulting
                                         string. */
    PDWORD          lenp        /* IN  - Buffer size in characters.
                                   OUT - Characters written or required buffer
                                         size. */
);
/*
    Resolve IP address to Internet host name.

    returns:
        TRUE            => Successfully converted. lenp contains number of
                           character written.
        FALSE           => Buffer too small. lenp contains required buffer size
                           including terminating NULL character.
*/


/******************************************************************************
    Cluster host configuration routines. Note that in current implementation,
    cluster and host parameters need to be set to WLBS_LOCAL_CLUSTER and
    WLBS_LOCAL_HOST.
 ******************************************************************************/


extern DWORD WINAPI WlbsReadReg
(
    DWORD           cluster,    /* IN  - WLBS_LOCAL_CLUSTER */
    PWLBS_REG_PARAMS reg_data   /* OUT - Registry parameters */
);
/*
    Read WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => reg_data is NULL
    WLBS_REG_ERROR   => Error reading from the registry

    Local:

    WLBS_OK          => Registry parameters successfully read.

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsWriteReg
(
    DWORD           cluster,    /* IN  - WLBS_LOCAL_CLUSTER */
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Write WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_REG_ERROR   => Error accessing the registry.

    Local:

    WLBS_OK          => Registry parameters successfully written.

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsCommitChanges
(
    DWORD           cluster    /* IN  - WLBS_LOCAL_CLUSTER */
);
/*
    Write WLBS registry data.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.

    Local:

    WLBS_OK          => Changes have been successfully applied.
    WLBS_BAD_PARAMS  => Registry parameters were not accepted by the driver.
                        Reload was not performed
    WLBS_REBOOT      => Reboot required in order for config changes to
                        take effect.
    WLBS_IO_ERROR    => Error while writing to the driver.
    WLBS_REG_ERROR   => Error while trying to write MAC address changes to the
                        registry

    Remote:

    WLBS_LOCAL_ONLY  => This call is implemented for local only operation.
*/


extern DWORD WINAPI WlbsSetDefaults
(
    PWLBS_REG_PARAMS       reg_data     /* OUT - Default values    */
);
/*
    Fills in the reg_data structure with default values

    returns:

    WLBS_INIT_ERROR    => Error initializing control module. Cannot perform
                          control operations.

    WLBS_BAD_PARAMS    => Invalid structure

    Local:

    WLBS_OK            => Structure was filled in with the default values.

    Remote:

    WLBS_LOCAL_ONLY    => This call is implemented for local only operation.

*/

/******************************************************************************
    Registry parameter manipulation routines. Note that these routines operate
    WLBS_REG_PARAMS structure filled out by calling WlbsReadReg. Some parameters
    can be manipulated directly. Please make sure to use manipulation routines
    for the ones that they are provided for.
 ******************************************************************************/

extern DWORD WINAPI WlbsGetEffectiveVersion
(
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Returns the effective version of cluster 

    returns:

    CVY_VERSION_FULL  => There is atleast one port rule that has a specific 
                         vip associated with it 
                        
    CVY_VERSION_LOWEST_CLIENT_FULL  => All port rules have the "All vip" associated with them

*/


extern DWORD WINAPI WlbsGetNumPortRules
(
    const PWLBS_REG_PARAMS reg_data   /* IN  - Registry parameters. */
);
/*
    Returns number of port rules currently in the parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    1...WLBS_MAX_RULES

*/


extern DWORD WINAPI WlbsEnumPortRules
(
    const PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    PWLBS_PORT_RULE rules,      /* OUT - Array of port rules. */
    PDWORD          num_rules   /* IN  - Size of rules array.
                                   OUT - Number of rules retrieved. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few rules that fit
                                         in the array are returned. */
);
/*
    Enumerate all port rules in the list of port rules in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_TRUNCATED   => All port rules did not fit into specified array.
    WLBS_OK          => Rule has been successfully retrieved.

*/


extern DWORD WINAPI WlbsGetPortRule
(
    const PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    DWORD           vip,        /* IN  - Virtual IP Address of the port rule to retreive */
    DWORD           port,       /* IN  - Port, which rule to retrieve. */
    PWLBS_PORT_RULE rule        /* OUT - Port rule. */
);
/*
    Retrieve port rule containing specified port from the list of port rules
    in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    WLBS_OK          => Rule has been successfully retrieved.
    WLBS_NOT_FOUND   => Port not found among port rules.

*/


extern DWORD WINAPI WlbsAddPortRule
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    const PWLBS_PORT_RULE rule        /* IN  - Port rule to add. */
);
/*
    Add port to list of port rules in parameter structure.

    returns:

    WLBS_INIT_ERROR     => Error initializing control module. Cannot perform
                           control operations.
    WLBS_BAD_PARAMS     => Registry parameter structure is invalid.
    WLBS_OK             => Rule has been successfully added.
    WLBS_PORT_OVERLAP   => Port rule overlaps with existing port rule.
    WLBS_BAD_PORT_PARAMS=> Invalid port rule parameters.
    WLBS_MAX_PORT_RULES => Maximum number of port rules already reached.
*/


extern DWORD WINAPI WlbsDeletePortRule
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    DWORD           vip,        /* IN  - Virtual IP Address of the port rule to retreive */
    DWORD           port        /* IN  - Port, which rule to delete. */
);
/*
    Remove port rule containing specified port from the list of port rules
    in parameter structure.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.
    WLBS_NOT_FOUND   => Port not found among port rules.

    WLBS_OK          => Rule has been successfully deleted.

*/


extern DWORD WINAPI WlbsSetRemotePassword
(
    PWLBS_REG_PARAMS reg_data,  /* IN  - Registry parameters. */
    const WCHAR*           password   /* IN  - Password or NULL for no password. */
);
/*
    Set remote password code to encrypted value of the specified password.

    returns:

    WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                        control operations.
    WLBS_BAD_PARAMS  => Registry parameter structure is invalid.

    WLBS_OK          => Password has been successfully set.

*/

DWORD WINAPI WlbsNotifyConfigChange(DWORD cluster);


#ifdef __cplusplus
} /* extern "C" */
#endif


#endif _WLBSCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
FAR PASCAL
WsControl(
	DWORD	Protocol,
	DWORD	Action,
	LPVOID	InputBuffer,
	LPDWORD	InputBufferLength,
	LPVOID	OutputBuffer,
	LPDWORD	OutputBufferLength
	);

typedef DWORD (FAR PASCAL * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  TCP/IP action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001
#define WSCNTL_TCPIP_ICMP_ECHO				0x00000002


#endif	// _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\wlbsctrl.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbsctrl.c

Abstract:

    Windows Load Balancing Service (WLBS)
    API - specification.  This set of API is for internal use only.  
        another set of WMI API is provided for public use.

Author:

    fengsun

--*/

#ifndef _WLBSCTRL_H_
#define _WLBSCTRL_H_

/* CONSTANTS */

#define CVY_MAX_HOST_NAME        100

#define WLBS_API_VER_MAJOR       2       /* WLBS control API major version. */
#define WLBS_API_VER_MINOR       0       /* WLBS control API minor version. */
#define WLBS_API_VER             (WLBS_API_VER_MINOR | (WLBS_API_VER_MAJOR << 8))
                                         /* WLBS control API version. */
#define WLBS_PRODUCT_NAME        "WLBS"
                                         /* Default product name used for API
                                            initialization. */


#define WLBS_MAX_HOSTS           32      /* Maximum number of cluster hosts. */
#define WLBS_MAX_RULES           32      /* Maximum number of port rules. */



#define WLBS_ALL_CLUSTERS        0       /* Used to specify all clusters in
                                            WLBS...Set routines. */
#define WLBS_LOCAL_CLUSTER       0       /* Used to specify that cluster
                                            operations are to be performed on the
                                            local host. WLBS_LOCAL_HOST value
                                            below has to be used for the host
                                            argument when using
                                            WLBS_LOCAL_CLUSTER. */
#define WLBS_LOCAL_HOST          ((DWORD)-2) /* When specifying WLBS_LOCAL_CLUSTER,
                                            this value should be used for the
                                            host argument. */
#define WLBS_DEFAULT_HOST        0       /* Used to specify that remote cluster
                                            operations are to be performed on
                                            the default host. */
#define WLBS_ALL_HOSTS           0xffffffff
                                         /* Used to specify that remote cluster
                                            operation is to be performed on all
                                            hosts. */
#define WLBS_ALL_PORTS           0xffffffff
                                         /* Used to specify all load-balanced
                                            port rules as the target for
                                            enable/disable/drain commands. */


/* WLBS return values. Windows Sockets errors are returned 'as-is'. */

#define WLBS_OK                  1000    /* Success. */
#define WLBS_ALREADY             1001    /* Cluster mode is already stopped/
                                            started, or traffic handling is
                                            already enabled/disabled on specified
                                            port. */
#define WLBS_DRAIN_STOP          1002    /* Cluster mode stop or start operation
                                            interrupted connection draining
                                            process. */
#define WLBS_BAD_PARAMS          1003    /* Cluster mode could not be started
                                            due to configuration problems
                                            (bad registry parameters) on the
                                            target host. */
#define WLBS_NOT_FOUND           1004    /* Port number not found among port
                                            rules. */
#define WLBS_STOPPED             1005    /* Cluster mode is stopped on the
                                            host. */
#define WLBS_CONVERGING          1006    /* Cluster is converging. */
#define WLBS_CONVERGED           1007    /* Cluster or host converged
                                            successfully. */
#define WLBS_DEFAULT             1008    /* Host is converged as default host. */
#define WLBS_DRAINING            1009    /* Host is draining after
                                            WLBSDrainStop command. */
#define WLBS_PRESENT             1010    /* WLBS is installed on this host.
                                            Local operations possible. */
#define WLBS_REMOTE_ONLY         1011    /* WLBS is not installed on this host
                                            or is not functioning. Only remote
                                            control operations can be carried
                                            out. */
#define WLBS_LOCAL_ONLY          1012    /* WinSock failed to load. Only local
                                            operations can be carried out. */
#define WLBS_SUSPENDED           1013    /* Cluster control operations are
                                            suspended. */
#define WLBS_DISCONNECTED        1014    /* Media is disconnected. */
#define WLBS_REBOOT              1050    /* Reboot required in order for config
                                            changes to take effect. */
#define WLBS_INIT_ERROR          1100    /* Error initializing control module. */
#define WLBS_BAD_PASSW           1101    /* Specified remote control password
                                            was not accepted by the cluster. */
#define WLBS_IO_ERROR            1102    /* Local I/O error opening or
                                            communicating with WLBS driver. */
#define WLBS_TIMEOUT             1103    /* Timed-out awaiting response from
                                            remote host. */
#define WLBS_PORT_OVERLAP        1150    /* Port rule overlaps with existing
                                            port rules. */
#define WLBS_BAD_PORT_PARAMS     1151    /* Invalid parameter(s) in port rule. */
#define WLBS_MAX_PORT_RULES      1152    /* Maximum number of port rules reached. */
#define WLBS_TRUNCATED           1153    /* Return value truncated */
#define WLBS_REG_ERROR           1154    /* Error while accessing the registry */


/* Filtering modes for port rules */

#define WLBS_SINGLE              1       /* single server mode */
#define WLBS_MULTI               2       /* multi-server mode (load balanced) */
#define WLBS_NEVER               3       /* mode for never handled by this server */
#define WLBS_ALL                 4       /* all server mode */

/* Protocol qualifiers for port rules */

#define WLBS_TCP                 1       /* TCP protocol */
#define WLBS_UDP                 2       /* UDP protocol */
#define WLBS_TCP_UDP             3       /* TCP or UDP protocols */

/* Server affinity values for multiple filtering mode */

#define WLBS_AFFINITY_NONE       0       /* no affinity (scale single client) */
#define WLBS_AFFINITY_SINGLE     1       /* single client affinity */
#define WLBS_AFFINITY_CLASSC     2       /* Class C affinity */


/* TYPES */


/* Response value type returned by each of the cluster hosts during remote
   operation. */

typedef struct
{
    DWORD       id;                     /* Priority ID of the responding cluster
                                           host */
    DWORD       address;                /* Dedicated IP address */
    DWORD       status;                 /* Status return value */
    DWORD       reserved1;              /* Reserved for future use */
    PVOID       reserved2;
    WCHAR       hostname[CVY_MAX_HOST_NAME + 1];
}
WLBS_RESPONSE, * PWLBS_RESPONSE;





/* MACROS */


/* Local operations */

#define WlbsLocalQuery(host_map)                                  \
    WlbsQuery     (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, \
                     host_map, NULL)

#define WlbsLocalSuspend()                                        \
    WlbsSuspend   (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalResume()                                         \
    WlbsResume    (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalStart()                                          \
    WlbsStart     (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalStop()                                           \
    WlbsStop      (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalDrainStop()                                      \
    WlbsDrainStop (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalEnable(port)                                     \
    WlbsEnable    (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, port)

#define WlbsLocalDisable(port)                                    \
    WlbsDisable   (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, port)

#define WlbsLocalDrain(port)                                      \
    WlbsDrain     (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, port)



/* Single host remote operations */

#define WlbsHostQuery(cluster, host, host_map)                    \
    WlbsQuery     (cluster, host, NULL, NULL, host_map, NULL)

#define WlbsHostSuspend(cluster, host)                            \
    WlbsSuspend   (cluster, host, NULL, NULL)

#define WlbsHostResume(cluster, host)                             \
    WlbsResume    (cluster, host, NULL, NULL)

#define WlbsHostStart(cluster, host)                              \
    WlbsStart     (cluster, host, NULL, NULL)

#define WlbsHostStop(cluster, host)                               \
    WlbsStop      (cluster, host, NULL, NULL)

#define WlbsHostDrainStop(cluster, host)                          \
    WlbsDrainStop (cluster, host, NULL, NULL)

#define WlbsHostEnable(cluster, host, port)                       \
    WlbsEnable    (cluster, host, NULL, NULL, port)

#define WlbsHostDisable(cluster, host, port)                      \
    WlbsDisable   (cluster, host, NULL, NULL, port)

#define WlbsHostDrain(cluster, host, port)                        \
    WlbsDrain     (cluster, host, NULL, NULL, port)

/* Cluster-wide remote operations */

#define WlbsClusterQuery(cluster, response, num_hosts, host_map)  \
    WlbsQuery     (cluster, WLBS_ALL_HOSTS, response, num_hosts,   \
                     host_map, NULL)

#define WlbsClusterSuspend(cluster, response, num_hosts)          \
    WlbsSuspend   (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterResume(cluster, response, num_hosts)           \
    WlbsResume    (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterStart(cluster, response, num_hosts)            \
    WlbsStart     (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterStop(cluster, response, num_hosts)             \
    WlbsStop      (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterDrainStop(cluster, response, num_hosts)        \
    WlbsDrainStop (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterEnable(cluster, response, num_hosts, port)     \
    WlbsEnable    (cluster, WLBS_ALL_HOSTS, response, num_hosts, port)

#define WlbsClusterDisable(cluster, response, num_hosts, port)    \
    WlbsDisable   (cluster, WLBS_ALL_HOSTS, response, num_hosts, port)

#define WlbsClusterDrain(cluster, response, num_hosts, port)      \
    WlbsDrain     (cluster, WLBS_ALL_HOSTS, response, num_hosts, port)


/* PROCEDURES */

/*************************************
   Initialization and support routines
 *************************************/

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD WINAPI WlbsInit
(
    WCHAR*          Reservered1,    /* IN  - for backward compatibility */
    DWORD           version,    /* IN  - Pass WLBS_API_VER value. */
    PVOID           Reservered2    /* IN  - Pass NULL. Reserved for future use. */
);
/*
    Initialize WLBS control module.

    returns:
        WLBS_PRESENT        => WLBS is installed on this host. Local and remote
                               control operations can be executed.
        WLBS_REMOTE_ONLY    => WLBS is not installed on this system or is not
                               functioning properly. Only remote operations can
                               be carried out.
        WLBS_LOCAL_ONLY     => WinSock failed to load. Only local operations can
                               be carried out.
        WLBS_INIT_ERROR     => Error initializing control module. Cannot perform
                               control operations.
*/




/******************************************************************************
   Cluster control routines:

   The following routines can be used to control individual cluster hosts or the
   entire cluster, both locally and remotely. They are designed to be as generic
   as possible. Macros, defined above, are designed to provide simpler
   interfaces for particular types of operations.

   It is highly recommended to make all response arrays of size WLBS_MAX_HOSTS
   to make your implementation independent of the actual cluster size.

   Please note that cluster address has to correspond to the primary cluster
   address as entered in the WLBS Setup Dialog. WLBS will not recognize
   control messages sent to dedicated or additional multi-homed cluster
   addresses.
 ******************************************************************************/


extern DWORD WINAPI WlbsQuery
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,   /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    PDWORD          host_map,   /* OUT - Bitmap with ones in the bit positions
                                         representing priority IDs of the hosts
                                         currently present in the cluster. NULL
                                         if host map information is not
                                         needed. */
    PVOID           reserved    /* IN  - Pass NULL. Reserved for future use. */
);
/*
    Query status of specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_STOPPED     => Cluster mode on the host is stopped.
        WLBS_CONVERGING  => Host is converging.
        WLBS_DRAINING    => Host is draining.
        WLBS_CONVERGED   => Host converged.
        WLBS_DEFAULT     => Host converged as default host.

        Cluster-wide:

        <1..32>          => Number of active cluster hosts when the cluster
                            is converged.
        WLBS_SUSPENDED   => Entire cluster is suspended. All cluster hosts
                            reported as being suspended.
        WLBS_STOPPED     => Entire cluster is stopped. All cluster hosts reported
                            as being stopped.
        WLBS_DRAINING    => Entire cluster is draining. All cluster hosts
                            reported as being stopped or draining.
        WLBS_CONVERGING  => Cluster is converging. At least one cluster host
                            reported its state as converging.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the query.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system. Only remote
                            operations can be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsSuspend
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,   /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Suspend cluster operation control on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode control suspended.
        WLBS_ALREADY     => Cluster mode control already suspended.
        WLBS_STOPPED     => Cluster mode was stopped and control suspended.
        WLBS_DRAIN_STOP  => Suspending cluster mode control interrupted ongoing
                           connection draining.

        Cluster-wide:

        WLBS_OK          => Cluster mode control suspended on all hosts.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by at least one member of the cluster.
        WLBS_TIMEOUT     => No response received.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsResume
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Resume cluster operation control on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode control resumed.
        WLBS_ALREADY     => Cluster mode control already resumed.

        Cluster-wide:

        WLBS_OK          => Cluster mode control resumed on all hosts.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsStart
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Start cluster operations on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode started.
        WLBS_ALREADY     => Cluster mode already started.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_DRAIN_STOP  => Starting cluster mode interrupted ongoing connection
                            draining.
        WLBS_BAD_PARAMS  => Could not start cluster mode due to invalid configuration
                            parameters.

        Cluster-wide:

        WLBS_OK          => Cluster mode started on all hosts.
        WLBS_BAD_PARAMS  => Could not start cluster mode on at least one host
                            due to invalid configuration parameters.
        WLBS_SUSPENDED   => If at least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsStop
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE   response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Stop cluster operations on specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Cluster mode stopped.
        WLBS_ALREADY     => Cluster mode already stopped.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_DRAIN_STOP  => Starting cluster mode interrupted ongoing connection
                            draining.

        Cluster-wide:

        WLBS_OK          => Cluster mode stopped on all hosts.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsDrainStop
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts   /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
);
/*
    Enter draining mode on specified host or all cluster hosts. New connections
    will not be accepted. Cluster mode will be stopped when all existing
    connections finish. While draining, host will participate in convergence and
    remain part of the cluster.

    Draining mode can be interrupted by performing WlbsStop or WlbsStart.
    WlbsEnable, WlbsDisable and WlbsDrain commands cannot be executed
    while the host is draining.

    Note that this command is NOT equivalent to doing WlbsDrain with
    WLBS_ALL_PORTS parameter followed by WlbsStop. WlbsDrainStop affects all
    ports, not just the ones specified in the multiple host filtering mode port
    rules.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Host entered draining mode.
        WLBS_ALREADY     => Host is already draining.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_STOPPED     => Cluster mode is already stopped.

        Cluster-wide:

        WLBS_OK          => Draining mode entered on all hosts.
        WLBS_STOPPED     => Cluster mode is already stopped on all hosts.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsEnable
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    DWORD           vip,        /* IN  - Virtual IP Address to specify the target port
                                         rule or WLBS_EVERY_VIP */ 
    DWORD           port        /* IN  - Port number to specify the target port
                                         rule or WLBS_ALL_PORTS. */
);
/*
    Enable traffic handling for rule containing the specified port on specified
    host or all cluster hosts. Only rules that are set for multiple host
    filtering mode are affected.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => Port rule enabled.
        WLBS_ALREADY     => Port rule already enabled.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_NOT_FOUND   => No port rule containing specified port found.
        WLBS_STOPPED     => Cannot start handling traffic since cluster mode
                            is stopped.
        WLBS_DRAINING    => Cannot enable handling traffic since host is draining.

        Cluster-wide:

        WLBS_OK          => Port rule enabled on all hosts with cluster mode
                            started.
        WLBS_NOT_FOUND   => At least one host could not find port rule containing
                            specified port.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsDisable
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,  /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    DWORD           vip,        /* IN  - Virtual IP Address to specify the target port
                                         rule or WLBS_EVERY_VIP */ 
    DWORD           port        /* IN  - Port number to specify the target port
                                         rule or WLBS_ALL_PORTS. */
);
/*
    Disable ALL traffic handling for rule containing the specified port on
    specified host or all cluster hosts. Only rules that are set for multiple
    host filtering mode are affected.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => All traffic handling on the port rule is disabled.
        WLBS_ALREADY     => Port rule already disabled.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_NOT_FOUND   => No port rule containing specified port found.
        WLBS_STOPPED     => Cannot stop handling traffic since cluster mode
                            is stopped.
        WLBS_DRAINING    => Cannot stop handling traffic since host is draining.

        Cluster-wide:

        WLBS_OK          => Port rule disabled on all hosts with cluster mode
                            started.
        WLBS_NOT_FOUND   => At least one host could not find port rule containing
                            specified port.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


extern DWORD WINAPI WlbsDrain
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default
                                         host, WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,   /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    DWORD           vip,        /* IN  - Virtual IP Address to specify the target port
                                         rule or WLBS_EVERY_VIP */ 
    DWORD           port        /* IN  - Port number to specify the target port
                                         rule or WLBS_ALL_PORTS. */
);
/*
    Disable NEW traffic handling for rule containing the specified port on
    specified host or all cluster hosts. Only rules that are set for multiple
    host filtering mode are affected.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_OK          => New traffic handling on the port rule is disabled.
        WLBS_ALREADY     => Port rule already being drained.
        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_NOT_FOUND   => No port rule containing specified port found.
        WLBS_STOPPED     => Cannot stop handling traffic since cluster mode
                            is stopped.
        WLBS_DRAINING    => Cannot stop handling traffic since host is draining.

        Cluster-wide:

        WLBS_OK          => Port rule disabled on all hosts with cluster mode
                            started.
        WLBS_NOT_FOUND   => At least one host could not find port rule containing
                            specified port.
        WLBS_SUSPENDED   => At least one host is suspended.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
                            to the command.
        WLBS_LOCAL_ONLY  => WinSock failed to load. Only local operations can
                            be carried out.
        WSA...           => Specified Winsock error occurred when communicating
                            with the cluster.

        Local:

        WLBS_REMOTE_ONLY => WLBS is not installed on this system or is not
                            functioning properly. Only remote operations can
                            be carried out.
        WLBS_IO_ERROR    => I/O error opening or communicating with WLBS
                            driver. WLBS might not be loaded.
*/


/******************************************************************************
    "Sticky" options for remote operations. Parameters set by these routines will
    apply for all subsequent remote cluster control operations for the specified
    cluster. Use WLBS_ALL_CLUSTERS to adjust parameters for all clusters.
 ******************************************************************************/


extern VOID WINAPI WlbsPortSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    WORD            port        /* IN  - UDP port or 0 to revert to the
                                         default (2504). */
);
/*
    Set UDP port that will be used for sending control messages to the cluster.

    returns:
*/


extern VOID WINAPI WlbsPasswordSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    WCHAR*          password    /* IN  - Password or NULL to revert to the
                                         default (no password). */
);
/*
    Set password to be used in the subsequent control messages sent to the
    cluster.

    returns:
*/


extern VOID WINAPI WlbsCodeSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    DWORD           password    /* IN  - Password or 0 to revert to the
                                         default (no password). */
);
/*
    Set password to be used in the subsequent control messages sent to the
    cluster.

    returns:
*/


extern VOID WINAPI WlbsDestinationSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    DWORD           dest        /* IN  - Destination address or 0 to revert to
                                         the default (same as the cluster
                                         address specified during control
                                         calls). */
);
/*
    Set the destination address to send cluster control messages to. This
    parameter in only supplied for debugging or special purposes. By default
    all control messages are sent to the cluster primary address specified
    when invoking cluster control routines.

    returns:
*/


extern VOID WINAPI WlbsTimeoutSet
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_ALL_CLUSTERS
                                         for all clusters. */
    DWORD           milliseconds /*IN  - Number of milliseconds or 0 to revert
                                         to the default (10 seconds). */
);
/*
    Set number of milliseconds to wait for replies from cluster hosts when
    performing remote operations.

    returns:
*/

DWORD WINAPI WlbsEnumClusters(OUT DWORD* pdwAddresses, OUT DWORD* pdwNum);

DWORD WINAPI WlbsGetAdapterGuid(IN DWORD cluster, OUT GUID* pAdapterGuid);

/* For connection notification ... */

DWORD WINAPI WlbsConnectionUp
(
    DWORD dwServerIp,
    WORD wServerPort,
    DWORD dwClientIp,
    WORD wClientPort,
    BYTE Protocol,
    PULONG NLBStatusEx
);

DWORD WINAPI WlbsConnectionDown
(
    DWORD dwServerIp,
    WORD wServerPort,
    DWORD dwClientIp,
    WORD wClientPort,
    BYTE Protocol,
    PULONG NLBStatusEx
); 

#ifdef __cplusplus
} /* extern "C" */
#endif


#endif /* _WLBSCTRL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\wlbsparm.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbsparm.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Registry parameters specification

Author:

    kyrilf

Environment:


Revision History:


--*/


#ifndef _Params_h_
#define _Params_h_

//
// These constants from the now-obsolete wlbslic.h
//
#define LICENSE_STR_IMPORTANT_CHARS 16  /* number of characters from the string
                                           used for encoding */

#define LICENSE_DATA_GRANULARITY    8   /* granularity in bytes of data for
                                           encoding/decoding */

#define LICENSE_STR_NIBBLES         (LICENSE_STR_IMPORTANT_CHARS / LICENSE_DATA_GRANULARITY)

#define LICENSE_TRIAL_CODE          _TEXT("")

#ifdef KERNEL_MODE

#include <ndis.h>
#include <ntddndis.h>
typedef BOOLEAN                 BOOL;

#else

#include <windows.h>

#endif

// ###### ramkrish
#define CVY_MAX_ADAPTERS               16        /* maximum number of adapters to bind to */

/* CONSTANTS */

#define CVY_STR_SIZE                    256
#define PARAMS_MAX_STRING_SIZE          256

/* compile-time parameters */

//
// Heartbeat and remote control packet version
//
#define CVY_VERSION             L"V2.4"
#define CVY_VERSION_MAJOR       2
#define CVY_VERSION_MINOR       4
#define CVY_VERSION_FULL        (CVY_VERSION_MINOR | (CVY_VERSION_MAJOR << 8))

#define CVY_WIN2K_VERSION       L"V2.3"
#define CVY_WIN2K_VERSION_FULL  0x00000203

#define CVY_NT40_VERSION        L"V2.1"
#define CVY_NT40_VERSION_FULL   0x00000201


#define CVY_NAME                L"WLBS"
#define CVY_NAME_MULTI_NIC      L"WLBS Cluster " /* ###### added for multi nic support log messages -- ramkrish */
#define CVY_HELP_FILE           L"WLBS.CHM"
#define CVY_CTXT_HELP_FILE      L"WLBS.HLP"
#define CVY_DEVICE_NAME         L"\\Device\\WLBS"
#define CVY_DOSDEVICE_NAME      L"\\DosDevices\\WLBS"

#define CVY_PARAMS_VERSION      4       /* current version of parameter
                                           structure */
#define CVY_MAX_USABLE_RULES    32      /* maximum # port rules  */
#define CVY_MAX_RULES           33      /* maximum # port rules + 1 */
#define CVY_MAX_HOSTS           32      /* maximum # of hosts */

/* filtering modes for port groups */

#define CVY_SINGLE              1       /* single server mode */
#define CVY_MULTI               2       /* multi-server mode (load balanced) */
#define CVY_NEVER               3       /* mode for never handled by this server */

/* protocol qualifiers for port rules */

#define CVY_TCP                 1       /* TCP protocol */
#define CVY_UDP                 2       /* UDP protocol */
#define CVY_TCP_UDP             3       /* TCP or UDP protocols */

/* server affinity values for multiple filtering mode */

#define CVY_AFFINITY_NONE       0       /* no affinity (scale single client) */
#define CVY_AFFINITY_SINGLE     1       /* single client affinity */
#define CVY_AFFINITY_CLASSC     2       /* Class C affinity */

/* registry key names */

#define CVY_NAME_NET_ADDR       L"NetworkAddress"
#define CVY_NAME_SAVED_NET_ADDR L"WLBSSavedNetworkAddress"
#define CVY_TYPE_NET_ADDR       REG_SZ

#define CVY_NAME_BDA_TEAMING      L"BDATeaming"
#define CVY_NAME_BDA_TEAM_ID      L"TeamID"
#define CVY_NAME_BDA_MASTER       L"Master"
#define CVY_NAME_BDA_REVERSE_HASH L"ReverseHash"

#define CVY_NAME_VERSION        L"ParametersVersion"
#define CVY_NAME_DED_IP_ADDR    L"DedicatedIPAddress"
#define CVY_NAME_DED_NET_MASK   L"DedicatedNetworkMask"
#define CVY_NAME_HOST_PRIORITY  L"HostPriority"
#define CVY_NAME_VIRTUAL_NIC    L"VirtualNICName"
#define CVY_NAME_CLUSTER_NIC    L"ClusterNICName"
#define CVY_NAME_NETWORK_ADDR   L"ClusterNetworkAddress"
#define CVY_NAME_CL_IP_ADDR     L"ClusterIPAddress"
#define CVY_NAME_CL_NET_MASK    L"ClusterNetworkMask"
#define CVY_NAME_CLUSTER_MODE   L"ClusterModeOnStart"
#define CVY_NAME_ALIVE_PERIOD   L"AliveMsgPeriod"
#define CVY_NAME_ALIVE_TOLER    L"AliveMsgTolerance"
#define CVY_NAME_NUM_ACTIONS    L"NumActions"
#define CVY_NAME_NUM_PACKETS    L"NumPackets"
#define CVY_NAME_NUM_SEND_MSGS  L"NumAliveMsgs"
#define CVY_NAME_DOMAIN_NAME    L"ClusterName"
#define CVY_NAME_INSTALL_DATE   L"InstallDate"
#define CVY_NAME_VERIFY_DATE    L"VerifyDate"
#define CVY_NAME_LICENSE_KEY    L"LicenseKey"
#define CVY_NAME_RMT_PASSWORD   L"RemoteMaintenanceEnabled"
#define CVY_NAME_RCT_PASSWORD   L"RemoteControlCode"
#define CVY_NAME_RCT_PORT       L"RemoteControlUDPPort"
#define CVY_NAME_RCT_ENABLED    L"RemoteControlEnabled"
#define CVY_NAME_NUM_RULES      L"NumberOfRules"
#define CVY_NAME_CUR_VERSION    L"CurrentVersion"
#define CVY_NAME_OLD_PORT_RULES L"PortRules"            /* Path in registry to old port rules. api\params.cpp, driver params.c and answer file use this. */
#define CVY_NAME_PORT_RULES     L"PortRules"            /* Path in registry to current port rules */
#define CVY_NAME_DSCR_PER_ALLOC L"DescriptorsPerAlloc"
#define CVY_NAME_MAX_DSCR_ALLOCS L"MaxDescriptorAllocs"
#define CVY_NAME_SCALE_CLIENT   L"ScaleSingleClient"
#define CVY_NAME_CLEANUP_DELAY  L"ConnectionCleanupDelay"
#define CVY_NAME_NBT_SUPPORT    L"NBTSupportEnable"
#define CVY_NAME_MCAST_SUPPORT  L"MulticastSupportEnable"
#define CVY_NAME_MCAST_SPOOF    L"MulticastARPEnable"
#define CVY_NAME_MASK_SRC_MAC   L"MaskSourceMAC"
#define CVY_NAME_NETMON_ALIVE   L"NetmonAliveMsgs"
#define CVY_NAME_EFFECTIVE_VERSION   L"EffectiveVersion"
#define CVY_NAME_IP_CHG_DELAY   L"IPChangeDelay"
#define CVY_NAME_CONVERT_MAC    L"IPToMACEnable"
#define CVY_NAME_PORTS          L"Ports"                /* for answer file use only */
#define CVY_NAME_PASSWORD       L"RemoteControlPassword"/* for answer file use only */
#define CVY_NAME_PORTRULE_VIPALL     L"All"             /* for answer file use only */

#define CVY_NAME_CODE           L"Private"
#define CVY_NAME_VIP            L"VirtualIPAddress"
#define CVY_NAME_START_PORT     L"StartPort"
#define CVY_NAME_END_PORT       L"EndPort"
#define CVY_NAME_PROTOCOL       L"Protocol"
#define CVY_NAME_MODE           L"Mode"
#define CVY_NAME_PRIORITY       L"Priority"
#define CVY_NAME_EQUAL_LOAD     L"EqualLoad"
#define CVY_NAME_LOAD           L"Load"
#define CVY_NAME_AFFINITY       L"Affinity"

//
// IGMP support registry entries
//
#define CVY_NAME_IGMP_SUPPORT   L"IGMPSupport"
#define CVY_NAME_MCAST_IP_ADDR  L"McastIPAddress"
#define CVY_NAME_IP_TO_MCASTIP  L"IPtoMcastIP"


/* registry key value ranges */

#define CVY_MIN_VERSION         1
#define CVY_MAX_VERSION         CVY_PARAMS_VERSION

#define CVY_MIN_HOST_PRIORITY   1
#define CVY_MAX_HOST_PRIORITY   CVY_MAX_HOSTS

#define CVY_MIN_ALIVE_PERIOD    100
#define CVY_MAX_ALIVE_PERIOD    10000

#define CVY_MIN_ALIVE_TOLER     5
#define CVY_MAX_ALIVE_TOLER     100

#define CVY_MIN_NUM_PACKETS     5
#define CVY_MAX_NUM_PACKETS     500    /* V2.1.1 */

#define CVY_MIN_NUM_ACTIONS     5
#define CVY_MAX_NUM_ACTIONS     500     /* V1.1.2 */

#define CVY_MIN_MAX_HOSTS       1
#define CVY_MAX_MAX_HOSTS       CVY_MAX_HOSTS

#define CVY_MIN_MAX_RULES       0
#define CVY_MAX_MAX_RULES       (CVY_MAX_RULES - 1)

#define CVY_MIN_RCT_CODE        0
#define CVY_MAX_RCT_CODE        LICENSE_STR_IMPORTANT_CHARS

#define CVY_MIN_NUM_RULES       0
#define CVY_MAX_NUM_RULES       (CVY_MAX_RULES - 1)

#define CVY_MIN_FT_RULES        0
#define CVY_MAX_FT_RULES        1

#define CVY_MIN_NUM_SEND_MSGS   (CVY_MIN_MAX_HOSTS + 1)
#define CVY_MAX_NUM_SEND_MSGS   (CVY_MAX_MAX_HOSTS + 1) * 10

#define CVY_MIN_PORT            0
#define CVY_MAX_PORT            65535

#define CVY_MIN_PROTOCOL        CVY_TCP
#define CVY_MAX_PROTOCOL        CVY_TCP_UDP

#define CVY_MIN_MODE            CVY_SINGLE
#define CVY_MAX_MODE            CVY_NEVER

#define CVY_MIN_EQUAL_LOAD      0
#define CVY_MAX_EQUAL_LOAD      1

#define CVY_MIN_LOAD            0
#define CVY_MAX_LOAD            100

#define CVY_MIN_PRIORITY        1
#define CVY_MAX_PRIORITY        CVY_MAX_HOSTS

#define CVY_MIN_CLUSTER_MODE    0
#define CVY_MAX_CLUSTER_MODE    1

#define CVY_MIN_LIC_VERSION     0
#define CVY_MAX_LIC_VERSION     10

#define CVY_MIN_CUR_VERSION     5
#define CVY_MAX_CUR_VERSION     15

#define CVY_MIN_DSCR_PER_ALLOC  16
#define CVY_MAX_DSCR_PER_ALLOC  1024

#define CVY_MIN_MAX_DSCR_ALLOCS 1
#define CVY_MAX_MAX_DSCR_ALLOCS 1024

#define CVY_MIN_SCALE_CLIENT    0
#define CVY_MAX_SCALE_CLIENT    1

#define CVY_MIN_CLEANUP_DELAY   0
#define CVY_MAX_CLEANUP_DELAY   3600000

#define CVY_MIN_NBT_SUPPORT     0
#define CVY_MAX_NBT_SUPPORT     1

#define CVY_MIN_MCAST_SUPPORT   0
#define CVY_MAX_MCAST_SUPPORT   1

#define CVY_MIN_MCAST_SPOOF     0
#define CVY_MAX_MCAST_SPOOF     1

#define CVY_MIN_MASK_SRC_MAC    0
#define CVY_MAX_MASK_SRC_MAC    1

#define CVY_MIN_NETMON_ALIVE    0
#define CVY_MAX_NETMON_ALIVE    1

#define CVY_MIN_IP_CHG_DELAY    0
#define CVY_MAX_IP_CHG_DELAY    3600000

#define CVY_MIN_CONVERT_MAC     0
#define CVY_MAX_CONVERT_MAC     1

#define CVY_MIN_RCT_PORT        1
#define CVY_MAX_RCT_PORT        65535

#define CVY_MIN_RCT_ENABLED     0
#define CVY_MAX_RCT_ENABLED     1

/* minimum and maximum string length */

#define CVY_MAX_PARAM_STR       100

#define CVY_MIN_VIRTUAL_NIC     0
#define CVY_MAX_VIRTUAL_NIC     256

#define CVY_MIN_CLUSTER_NIC     0
#define CVY_MAX_CLUSTER_NIC     256

#define CVY_MIN_CL_IP_ADDR      7
#define CVY_MAX_CL_IP_ADDR      17

#define CVY_MIN_CL_NET_MASK     7
#define CVY_MAX_CL_NET_MASK     17

#define CVY_MIN_DED_IP_ADDR     7
#define CVY_MAX_DED_IP_ADDR     17

#define CVY_MIN_DED_NET_MASK    7
#define CVY_MAX_DED_NET_MASK    17

#define CVY_MIN_CL_IGMP_ADDR    7
#define CVY_MAX_CL_IGMP_ADDR    17

#define CVY_MIN_VIRTUAL_IP_ADDR 7
#define CVY_MAX_VIRTUAL_IP_ADDR 17

#define CVY_MIN_NETWORK_ADDR    11
#define CVY_MAX_NETWORK_ADDR    17

#define CVY_MIN_LICENSE_KEY     1
#define CVY_MAX_LICENSE_KEY     20

#define CVY_MIN_DOMAIN_NAME     1
#define CVY_MAX_DOMAIN_NAME     100

#define CVY_MIN_HOST_NAME       1
#define CVY_MAX_HOST_NAME       100

#define CVY_MIN_AFFINITY        0
#define CVY_MAX_AFFINITY        2

#define CVY_MIN_PORTS           9
#define CVY_MAX_PORTS           (CVY_MAX_RULES * 40)

#define CVY_MAX_BDA_TEAM_ID     40

/* registry key types */

#define CVY_TYPE_VERSION        REG_DWORD
#define CVY_TYPE_HOST_PRIORITY  REG_DWORD
#define CVY_TYPE_VIRTUAL_NIC    REG_SZ
#define CVY_TYPE_CLUSTER_NIC    REG_SZ
#define CVY_TYPE_NETWORK_ADDR   REG_SZ
#define CVY_TYPE_CL_IP_ADDR     REG_SZ
#define CVY_TYPE_CL_NET_MASK    REG_SZ
#define CVY_TYPE_DED_IP_ADDR    REG_SZ
#define CVY_TYPE_DED_NET_MASK   REG_SZ
#define CVY_TYPE_ALIVE_PERIOD   REG_DWORD
#define CVY_TYPE_ALIVE_TOLER    REG_DWORD
#define CVY_TYPE_ALIVE_TOLER    REG_DWORD
#define CVY_TYPE_NUM_PACKETS    REG_DWORD
#define CVY_TYPE_NUM_ACTIONS    REG_DWORD
#define CVY_TYPE_NUM_SEND_MSGS  REG_DWORD
#define CVY_TYPE_DOMAIN_NAME    REG_SZ
#define CVY_TYPE_INSTALL_DATE   REG_DWORD
#define CVY_TYPE_VERIFY_DATE    REG_DWORD
#define CVY_TYPE_LICENSE_KEY    REG_SZ
#define CVY_TYPE_RMT_PASSWORD   REG_DWORD
#define CVY_TYPE_RCT_PASSWORD   REG_DWORD
#define CVY_TYPE_RCT_PORT       REG_DWORD
#define CVY_TYPE_RCT_ENABLED    REG_DWORD
#define CVY_TYPE_NUM_RULES      REG_DWORD
#define CVY_TYPE_CUR_VERSION    REG_DWORD
#define CVY_TYPE_PORT_RULES     REG_BINARY
#define CVY_TYPE_CLUSTER_MODE   REG_DWORD
#define CVY_TYPE_DSCR_PER_ALLOC REG_DWORD
#define CVY_TYPE_MAX_DSCR_ALLOCS REG_DWORD
#define CVY_TYPE_SCALE_CLIENT   REG_DWORD
#define CVY_TYPE_CLEANUP_DELAY  REG_DWORD
#define CVY_TYPE_NBT_SUPPORT    REG_DWORD
#define CVY_TYPE_MCAST_SUPPORT  REG_DWORD
#define CVY_TYPE_MCAST_SPOOF    REG_DWORD
#define CVY_TYPE_MASK_SRC_MAC   REG_DWORD
#define CVY_TYPE_NETMON_ALIVE   REG_DWORD
#define CVY_TYPE_EFFECTIVE_VERSION   REG_DWORD
#define CVY_TYPE_IP_CHG_DELAY   REG_DWORD
#define CVY_TYPE_CONVERT_MAC    REG_DWORD

/* Registry key types for port rule */
#define CVY_TYPE_CODE           REG_DWORD
#define CVY_TYPE_VIP            REG_SZ
#define CVY_TYPE_START_PORT     REG_DWORD
#define CVY_TYPE_END_PORT       REG_DWORD
#define CVY_TYPE_PROTOCOL       REG_DWORD
#define CVY_TYPE_MODE           REG_DWORD
#define CVY_TYPE_PRIORITY       REG_DWORD
#define CVY_TYPE_EQUAL_LOAD     REG_DWORD
#define CVY_TYPE_LOAD           REG_DWORD
#define CVY_TYPE_AFFINITY       REG_DWORD

#define CVY_TYPE_IGMP_SUPPORT   REG_DWORD
#define CVY_TYPE_MCAST_IP_ADDR  REG_SZ
#define CVY_TYPE_IP_TO_MCASTIP  REG_DWORD

#define CVY_TYPE_BDA_TEAM_ID      REG_SZ
#define CVY_TYPE_BDA_MASTER       REG_DWORD
#define CVY_TYPE_BDA_REVERSE_HASH REG_DWORD

/* default values */

#define CVY_DEF_UNICAST_NETWORK_ADDR   L"02-bf-00-00-00-00"
#define CVY_DEF_MULTICAST_NETWORK_ADDR L"03-bf-00-00-00-00"
#define CVY_DEF_IGMP_NETWORK_ADDR      L"01-00-5e-7f-00-00"

#define CVY_DEF_HOST_PRIORITY   1
#define CVY_DEF_VERSION         CVY_PARAMS_VERSION
#define CVY_DEF_VIRTUAL_NIC     L""
#define CVY_DEF_CLUSTER_NIC     L""
#define CVY_DEF_DOMAIN_NAME     L"cluster.domain.com"
#define CVY_DEF_NETWORK_ADDR    L"00-00-00-00-00-00"
#define CVY_DEF_CL_IP_ADDR      L"0.0.0.0"
#define CVY_DEF_CL_NET_MASK     L"0.0.0.0"
#define CVY_DEF_DED_IP_ADDR     L"0.0.0.0"
#define CVY_DEF_DED_NET_MASK    L"0.0.0.0"
#define CVY_DEF_ALL_VIP         L"255.255.255.255"
#define CVY_DEF_ALIVE_PERIOD    1000
#define CVY_DEF_ALIVE_TOLER     5
#define CVY_DEF_NUM_PACKETS     200     /* V1.2.1 */
#define CVY_DEF_NUM_ACTIONS     100     /* V1.1.2 */
#define CVY_DEF_NUM_SEND_MSGS   10
#define CVY_DEF_INSTALL_DATE    0
#define CVY_DEF_CLUSTER_MODE    1
#define CVY_DEF_LICENSE_KEY     LICENSE_TRIAL_CODE
#define CVY_DEF_RMT_PASSWORD    0
#define CVY_DEF_RCT_PASSWORD    0
#define CVY_DEF_RCT_PORT        2504
#define CVY_DEF_RCT_PORT_OLD    1717
#define CVY_DEF_RCT_ENABLED     0       /* V2.1.5 */

#define CVY_DEF_PORT_START      0
#define CVY_DEF_PORT_END        65535
#define CVY_DEF_PROTOCOL        CVY_TCP_UDP
#define CVY_DEF_MODE            CVY_MULTI
#define CVY_DEF_EQUAL_LOAD      1
#define CVY_DEF_LOAD            50
#define CVY_DEF_PRIORITY        1
#define CVY_DEF_AFFINITY        CVY_AFFINITY_SINGLE

#define CVY_DEF_DSCR_PER_ALLOC  512
#define CVY_DEF_MAX_DSCR_ALLOCS 512
#define CVY_DEF_SCALE_CLIENT    0
#define CVY_DEF_CLEANUP_DELAY   300000
#define CVY_DEF_NBT_SUPPORT     1
#define CVY_DEF_MCAST_SUPPORT   0
#define CVY_DEF_MCAST_SPOOF     1
#define CVY_DEF_MASK_SRC_MAC    1
#define CVY_DEF_NETMON_ALIVE    0
#define CVY_DEF_IP_CHG_DELAY    60000
#define CVY_DEF_CONVERT_MAC     1

#define CVY_DEF_IGMP_SUPPORT    FALSE
#define CVY_DEF_MCAST_IP_ADDR   L"0.0.0.0"
#define CVY_DEF_IGMP_INTERVAL   60000
#define CVY_DEF_IP_TO_MCASTIP   TRUE

#define CVY_DEF_BDA_ACTIVE       0
#define CVY_DEF_BDA_MASTER       0
#define CVY_DEF_BDA_REVERSE_HASH 0
#define CVY_DEF_BDA_TEAM_ID      '\0'

/* For virtual clusters, this the encoded "ALL VIPs".  Note: The user-level port
   rule sorting code DEPENDS on this value being 255.255.255.255.  If this value
   is changed, then the sorting code must also be change to ensure that port rules
   with this VIP are placed at the end of the sorted list.  By choosing 0xffffffff,
   this is done "automatically" by the sorting code; i.e. it is not a special case. */
#define CVY_ALL_VIP_NUMERIC_VALUE  0xffffffff


#define CVY_RULE_CODE_GET(rulep) ((rulep) -> code)
#define CVY_RULE_CODE_SET(rulep) ((rulep) -> code =                          \
                                 ((ULONG) (((rulep) -> start_port) <<  0) | \
                                   (ULONG) (((rulep) -> end_port)   << 12) | \
                                   (ULONG) (((rulep) -> protocol)   << 24) | \
                                   (ULONG) (((rulep) -> mode)       << 28) | \
                                   (ULONG) (((rulep) -> mode == CVY_MULTI ? \
                                   (rulep) -> mode_data . multi . affinity : 0) << 30) \
                                  ) ^ ~((DWORD)(IpAddressFromAbcdWsz((rulep) -> virtual_ip_addr))))

#define CVY_CHECK_MIN(x, y)      if ((x) < (y)) {(x) = (y);}
#define CVY_CHECK_MAX(x, y)      if ((x) > (y)) {(x) = (y);}


//
// WMI Event Tracing Constants
// These GUIDs and level constants are for internal use by NLB.
//

//
// See http://coreos/tech/tracing/ for details.
// Use TraceFormat(level, "fmt", ...) for tracing, where
// "level" is one of the arguments to WPP_DEFINE_BIT below.
// 
//
#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Regular, (e1f65b93,f32a,4ed6,aa72,b039e28f1574), \
        WPP_DEFINE_BIT(Critical)             \
        WPP_DEFINE_BIT(Informational)        \
        WPP_DEFINE_BIT(Verbose)              \
        WPP_DEFINE_BIT(Full)                 \
        WPP_DEFINE_BIT(Convergence)          \
        )    \
    WPP_DEFINE_CONTROL_GUID(Packets, (f498b9f5,9e67,446a,b9b8,1442ffaef434), \
        WPP_DEFINE_BIT(Heartbeats)           \
        WPP_DEFINE_BIT(TcpControl)           \
        )

#endif /* _Params_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\inc\oakdll.h ===
#ifndef OAKDLL_H
#define OAKDLL_H

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"
#include "ipsec.h"
#include "oakdefs.h"
#include "winipsec.h"

typedef enum _POLICY_GUID_TYPE {
    POLICY_GUID_MM = 1,
    POLICY_GUID_QM,
    POLICY_GUID_AUTH,
    POLICY_GUID_MM_FILTER
} POLICY_GUID_TYPE, *PPOLICY_GUID_TYPE;

DWORD WINAPI IKEInit () ;
DWORD WINAPI IKEShutdown () ;

DWORD WINAPI IKEInitiateIKENegotiation( 
    PIPSEC_QM_FILTER Filter,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    DWORD dwFlags,
    PHANDLE phNegotiationHandle);

DWORD WINAPI IKEQueryIKENegotiationStatus( 
    HANDLE hNegotiationHandle,
    SA_NEGOTIATION_STATUS_INFO *NegotiationStatus,
    DWORD dwFlags);

DWORD WINAPI IKECloseIKENegotiationHandle( 
                HANDLE hNegotiationHandle);

DWORD WINAPI IKEQueryStatistics( 
    PIKE_STATISTICS IKEStatistics);


DWORD WINAPI IKEDeleteAssociation( 
    IPSEC_MM_SA *MMTemplate,
    DWORD dwFlags);


DWORD WINAPI IKEQuerySpiChange( 
    HANDLE hNotifyHandle,
    LPDWORD dwListCount,
    IPSEC_QM_SA **FilterSpiList);

DWORD WINAPI IKERegisterNotifyClient( 
     DWORD dwClientProcessId,
     HANDLE hClientEvent,
     IPSEC_QM_SA QMInfo,  
     PHANDLE phNotifyHandle);

DWORD WINAPI IKECloseIKENotifyHandle(HANDLE hNotifyHandle);

DWORD WINAPI IKEInterfaceChange(); 

DWORD WINAPI IKEEnumMMs(IPSEC_MM_SA *MMTemplate,
                           IPSEC_MM_SA **MMArray,
                           LPDWORD pdwNumEntries,
                           LPDWORD pdwTotalMMsAvailable,
                           LPDWORD pdwEnumHandle,
                           DWORD dwFlags);

DWORD WINAPI
IKENotifyPolicyChange(GUID *pPolicyGuid, POLICY_GUID_TYPE GuidType);

DWORD WINAPI
IKEAddSAs(
    PIPSEC_QM_OFFER pQMOffer,
    PIPSEC_QM_FILTER pQMFilter,
    HANDLE *hLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE *InboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *OutboundKeyMat,
    BYTE *ContextInfo,
    DWORD dwFlags
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\inc\wzcsapi.h ===
#pragma once

# ifdef     __cplusplus
extern "C" {
# endif

PVOID
MIDL_user_allocate(size_t NumBytes);

VOID
MIDL_user_free(void * MemPointer);

//---------------------------------------
// Macros for handling additional attributes on WZC_WLAN_CONFIG structures
// Coding of additional attributes in the Reserved bytes of WZC_WLAN_CONFIG objects:
// Reserved
// [1]      [0]
// ---SSSAA CCCCCCCC
// SSS = [0-7; used: 0-6] selection set category, one of VPI, VI, PI, VPA, VA, PA, N
// AA  = [0-3; used: 0-3] authentication mode, NDIS_802_11_AUTHENTICATION_MODE value
// CCCCCCCC = [0-255] retry counter for this object.
//
#define NWB_AUTHMODE_MASK       0x03
#define NWB_SELCATEG_MASK       0x1C

#define NWB_SET_AUTHMODE(pNWB, nAM)     (pNWB)->Reserved[1] = (((pNWB)->Reserved[1] & ~NWB_AUTHMODE_MASK) | ((nAM) & NWB_AUTHMODE_MASK))
#define NWB_GET_AUTHMODE(pNWB)          ((pNWB)->Reserved[1] & NWB_AUTHMODE_MASK)

#define NWB_SET_SELCATEG(pNWB, nSC)     (pNWB)->Reserved[1] = (((pNWB)->Reserved[1] & ~NWB_SELCATEG_MASK) | (((nSC)<<2) & NWB_SELCATEG_MASK))
#define NWB_GET_SELCATEG(pNWB)          (((pNWB)->Reserved[1] & NWB_SELCATEG_MASK)>>2)

//---------------------------------------
// [P]RAW_DATA: generic description of a BLOB
typedef struct
{
    DWORD   dwDataLen;
#if defined(MIDL_PASS)
    [unique, size_is(dwDataLen)] LPBYTE pData;
#else
    LPBYTE  pData;
#endif
} RAW_DATA, *PRAW_DATA;

#if !defined(MIDL_PASS)

#include <ntddndis.h>
#define WZCCTL_MAX_WEPK_MATERIAL   32
#define WZCCTL_WEPK_PRESENT        0x0001  // specifies whether the configuration includes or not a WEP key
#define WZCCTL_WEPK_XFORMAT        0x0002  // the WEP Key material (if any) is entered as hexadecimal digits
#define WZCCTL_VOLATILE            0x0004  // this configuration should not be stored
#define WZCCTL_POLICY              0x0008  // this configuration is enforced by the policy

//---------------------------------------
// [P]WZC_WLAN_CONFIG: like NDIS_WLAN_BSSID, but contains all the additional
// data that defines a [Preferred] Wireless Zero Configuration
typedef struct
{
    ULONG                               Length;             // Length of this structure
    DWORD                               dwCtlFlags;         // control flags (NON-NDIS) see WZC_WEPK* constants
    // fields from the NDIS_WLAN_BSSID structure
    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
    UCHAR                               Reserved[2];
    NDIS_802_11_SSID                    Ssid;               // SSID
    ULONG                               Privacy;            // WEP encryption requirement
    NDIS_802_11_RSSI                    Rssi;               // receive signal strength in dBm
    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
    NDIS_802_11_CONFIGURATION           Configuration;
    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
    NDIS_802_11_RATES                   SupportedRates;
    // fields from NDIS_802_11_WEP structure
    ULONG   KeyIndex;                               // 0 is the per-client key, 1-N are the global keys
    ULONG   KeyLength;                              // length of key in bytes
    UCHAR   KeyMaterial[WZCCTL_MAX_WEPK_MATERIAL];  // variable length depending on above field
    // aditional field for the Authentication mode
    NDIS_802_11_AUTHENTICATION_MODE     AuthenticationMode;
    RAW_DATA                            rdUserData;         // upper level buffer, attached to this config
} WZC_WLAN_CONFIG, *PWZC_WLAN_CONFIG;

//---------------------------------------
// [P]WZC_802_11_CONFIG_LIST: like NDIS_802_11_BSSID_LIST but indexes a
// set of [Preferred] Wireless Zero Configurations
typedef struct
{
    ULONG           NumberOfItems;  // number of elements in the array below
    ULONG           Index;          // [start] index in the array below
    WZC_WLAN_CONFIG Config[1];      // array of WZC_WLAN_CONFIGs
} WZC_802_11_CONFIG_LIST, *PWZC_802_11_CONFIG_LIST;

// WZC dialog codes have the 16th bit set to 1. This is what quickly sepparates them from EAPOL signals.
#define WZCDLG_IS_WZC(x)         (((x) & 0x00010000) == 0x00010000)
#define WZCDLG_FAILED            0x00010001     // 802.11 automatic configuration failed

// Dialog BLOB passed through the UI pipe to netman and wzcdlg
typedef struct _WZCDLG_DATA
{
    DWORD       dwCode;
    DWORD       lParam; // long numeric data
} WZCDLG_DATA, *PWZCDLG_DATA;

#endif

//---------------------------------------
// [P]INTF_ENTRY: describes the key info for one interface
// this is used in conjunction with [P]INTFS_KEY_TABLE and WZCEnumInterfaces
typedef struct
{
#if defined(MIDL_PASS)
    [unique, string] LPWSTR wszGuid;
#else
    LPWSTR wszGuid;
#endif
} INTF_KEY_ENTRY, *PINTF_KEY_ENTRY;

//---------------------------------------
// [P]INTFS_KEY_TABLE: describes the table of key info for all interfaces
// this is used in conjunction with [P]INTF_KEY_ENTRY and WZCEnumInterfaces
typedef struct
{
    DWORD dwNumIntfs;
#if defined(MIDL_PASS)
    [size_is(dwNumIntfs)] PINTF_KEY_ENTRY pIntfs;
#else
    PINTF_KEY_ENTRY pIntfs;
#endif
} INTFS_KEY_TABLE, *PINTFS_KEY_TABLE;

//---------------------------------------
// Bits used in conjunction with INTF_ENTRY, WZCQueryInterface
// and WZCSetInterface. They point to the relevant information
// that is requested from the service or to the relevant information
// to be set down to the interface. On the output, they point to
// the information that was processed (queried/set) successfully.
#define INTF_ALL            0xffffffff

#define INTF_ALL_FLAGS      0x0000ffff
#define INTF_CM_MASK        0x00000007   // mask for the configuration mode (NDIS_802_11_NETWORK_INFRASTRUCTURE value)
#define INTF_ENABLED        0x00008000   // zero conf enabled for this interface
#define INTF_FALLBACK       0x00004000   // attempt to connect to visible non-preferred networks also
#define INTF_OIDSSUPP       0x00002000   // 802.11 OIDs are supported by the driver/firmware (can't be set)
#define INTF_VOLATILE       0x00001000   // the service parameters are volatile.
#define INTF_POLICY         0x00000800   // the service parameters are enforced by the policy.

#define INTF_DESCR          0x00010000
#define INTF_NDISMEDIA      0x00020000
#define INTF_PREFLIST       0x00040000

#define INTF_ALL_OIDS       0xfff00000
#define INTF_HANDLE         0x00100000
#define INTF_INFRAMODE      0x00200000
#define INTF_AUTHMODE       0x00400000
#define INTF_WEPSTATUS      0x00800000
#define INTF_SSID           0x01000000
#define INTF_BSSID          0x02000000
#define INTF_BSSIDLIST      0x04000000
#define INTF_LIST_SCAN      0x08000000
#define INTF_ADDWEPKEY      0x10000000
#define INTF_REMWEPKEY      0x20000000
#define INTF_LDDEFWKEY      0x40000000  // reload the default WEP_KEY

//---------------------------------------
// Bits used to specify particular control options for the interface
// entry
#define INTFCTL_CM_MASK     0x0007   // mask for the configuration mode (NDIS_802_11_NETWORK_INFRASTRUCTURE value)
#define INTFCTL_ENABLED     0x8000   // zero conf enabled for this interface
#define INTFCTL_FALLBACK    0x4000   // attempt to connect to visible non-preferred networks also
#define INTFCTL_OIDSSUPP    0x2000   // 802.11 OIDs are supported by the driver/firmware (can't be set)
#define INTFCTL_VOLATILE    0x1000   // the service parameters are volatile.
#define INTFCTL_POLICY      0x0800   // the service parameters policy enforced.

//---------------------------------------
// [P]INTF_ENTRY: contains everything an RPC client needs to know
// about an interface. It is used in conjunction with RpcQueryInterface.
// Flags below are to be used to specify what info is queried for the
// interface. Guid field is not covered since this is the key of the
// structure so it has to be specified eather way.
typedef struct
{
#if defined(MIDL_PASS)
    [string] LPWSTR wszGuid;
#else
    LPWSTR          wszGuid;
#endif
#if defined(MIDL_PASS)
    [string] LPWSTR wszDescr;
#else
    LPWSTR          wszDescr;
#endif
    ULONG           ulMediaState;
    ULONG           ulMediaType;
    ULONG           ulPhysicalMediaType;
    INT             nInfraMode;
    INT             nAuthMode;
    INT             nWepStatus;
    DWORD           dwCtlFlags;     // control flags (see INTFCTL_* defines)
    RAW_DATA        rdSSID;         // encapsulates the SSID raw binary
    RAW_DATA        rdBSSID;        // encapsulates the BSSID raw binary
    RAW_DATA        rdBSSIDList;    // encapsulates one WZC_802_11_CONFIG_LIST structure
    RAW_DATA        rdStSSIDList;   // encapsulates one WZC_802_11_CONFIG_LIST structure
    RAW_DATA        rdCtrlData;     // data for various control actions on the interface
} INTF_ENTRY, *PINTF_ENTRY;


//---------------------------------------
// Defines and datastucture for handling the WZC Service Context (generic service params)

// Default values for WZC internal timers (WZC_CONTEXT.tmT* fields)
#define TMMS_DEFAULT_TR	0x00000bb8      // Timeout until a rescan completes: ms (3sec)
#define TMMS_DEFAULT_TC 0x0000ea60      // Timeout to retry a valid configuration: ms (1min) 
#define TMMS_DEFAULT_TP 0x000007d0      // Timeout to expect a media connect for a selected config: ms (2sec)
#define TMMS_DEFAULT_TF 0x0000ea60      // Timeout to recover from a failed configuration: ms (1min)
#define TMMS_DEFAULT_TD 0x00001388      // Timeout to delay the {SSr} processing: ms (5sec)

// Default turns logging on
#define WZC_CTXT_LOGGING_ON      0x00000001 

// Structure: WZC_CONTEXT holds all global service options that may be customized
typedef struct _wzc_context_t
{
  DWORD dwFlags;            //service flags (see WZC_CTXT_*)
  //Service specific timers
  DWORD tmTr;               //Rescan timeout
  DWORD tmTc;               //Retry valid config timeout
  DWORD tmTp;               //Timeout to expect a media connect
  DWORD tmTf;               //Timeout to recover from an invalid config
  DWORD tmTd;               //Timeout to delay {Ssr} processing
} WZC_CONTEXT, *PWZC_CONTEXT;

// Context control flags (see WZCSet/QueryContext() calls)
#define WZC_CONTEXT_CTL_LOG         0x00000001
#define WZC_CONTEXT_CTL_TIMER_TR	0x00000002
#define WZC_CONTEXT_CTL_TIMER_TC	0x00000004
#define WZC_CONTEXT_CTL_TIMER_TP	0x00000008
#define WZC_CONTEXT_CTL_TIMER_TF	0x00000010
#define WZC_CONTEXT_CTL_TIMER_TD	0x00000020


//---------------------------------------
// Utility Rpc memory management routines
#define RpcCAlloc(nBytes)   MIDL_user_allocate(nBytes)
#define RpcFree(pMem)       MIDL_user_free(pMem)

//---------------------------------------
// GetSPResModule: Utility function used to return
// the handle to the module having WZC UI resources
// (needed for XP.QFE & XP.SP1 builds)
HINSTANCE
WZCGetSPResModule();

//---------------------------------------
// GetSPResModule: Utility function used to return
// the handle to the module having WZC UI resources
// (needed for XP.QFE & XP.SP1 builds)
HINSTANCE
WZCGetDlgResModule();

//---------------------------------------
// WZCDeleteIntfObj: cleans an INTF_ENTRY object that is
// allocated within any RPC call.
// 
// Parameters
// pIntf
//     [in] pointer to the INTF_ENTRY object to delete
VOID
WZCDeleteIntfObj(
    PINTF_ENTRY pIntf);

//---------------------------------------
// WZCEnumInterfaces: provides the table of key
// information for all the interfaces that are managed.
// For all subsequent calls the clients need to identify
// the Interface it operates on by providing the respective
// key info.
//
// Parameters:
//   pSrvAddr
//     [in] WZC Server to contact
//   pIntf
//     [out] table of key info for all interfaces
// Returned value:
//     Win32 error code 
DWORD
WZCEnumInterfaces(
    LPWSTR           pSrvAddr,
    PINTFS_KEY_TABLE pIntfs);

//---------------------------------------
// WZCQueryIterface: provides detailed information for a
// given interface.
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be queried (bitmask of INTF_*)
//   pIntf:
//     [in]  Key of the interface to query
//     [out] Requested data from the interface.
//   pdwOutFlags
//     [out] Fields successfully retrieved (bitmask of INTF_*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCQueryInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags);

//---------------------------------------
// WZCSetIterface: sets specific information on the interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be set (bitmask of INTF_*)
//   pIntf:
//     [in]  Key of the interface to query and data to be set
//   pdwOutFlags:
//     [out] Fields successfully set (bitmask of INTF_*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCSetInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags);

//---------------------------------------
// WZCRefreshInterface: refreshes specific information for the interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be refreshed and specific refresh actions to be
//           taken (bitmask of INTF_*)
//   pIntf:
//     [in]  Key of the interface to be refreshed
//   pdwOutFlags:
//     [out] Fields successfully refreshed (bitmask of INTF_*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCRefreshInterface(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PINTF_ENTRY         pIntf,
    LPDWORD             pdwOutFlags);


//---------------------------------------
// WZCQueryContext: retrieves the WZC service parameters
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be retrieved (bitmask of WZC_CONTEXT_CTL*)
//   pContext:
//     [in]  Placeholder for the service parameters
//   pdwOutFlags:
//     [out] Fields successfully retrieved (bitmask of WZC_CONTEXT_CTL*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCQueryContext(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PWZC_CONTEXT        pContext,
    LPDWORD             pdwOutFlags);


//---------------------------------------
// WZCSetContext: sets specific WZC service parameters
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   dwInFlags:
//     [in]  Fields to be set (bitmask of WZC_CONTEXT_CTL*)
//   pContext:
//     [in]  Context buffer containing the specific parameters to be set
//   pdwOutFlags:
//     [out] Fields successfully set (bitmask of WZC_CONTEXT_CTL*)
//
// Returned value:
//     Win32 error code 
DWORD
WZCSetContext(
    LPWSTR              pSrvAddr,
    DWORD               dwInFlags,
    PWZC_CONTEXT        pContext,
    LPDWORD             pdwOutFlags);

//============================================================================================
//
// EAPOL-related definitions
//


#define EAPOL_DISABLED                  0
#define EAPOL_ENABLED                   0x80000000

#define EAPOL_MACHINE_AUTH_DISABLED     0
#define EAPOL_MACHINE_AUTH_ENABLED      0x40000000

#define EAPOL_GUEST_AUTH_DISABLED       0
#define EAPOL_GUEST_AUTH_ENABLED        0x20000000

#define EAP_TYPE_MD5                    4
#define EAP_TYPE_TLS                    13
#define EAP_TYPE_PEAP                   25
#define EAP_TYPE_MSCHAPv2               26

#define DEFAULT_EAP_TYPE                EAP_TYPE_TLS
#define DEFAULT_EAPOL_STATE             EAPOL_ENABLED
#define DEFAULT_MACHINE_AUTH_STATE      EAPOL_MACHINE_AUTH_ENABLED
#define DEFAULT_GUEST_AUTH_STATE        EAPOL_GUEST_AUTH_DISABLED

#define DEFAULT_EAP_STATE               (DEFAULT_EAPOL_STATE | DEFAULT_MACHINE_AUTH_STATE | DEFAULT_GUEST_AUTH_STATE)

#define IS_EAPOL_ENABLED(x) \
    ((x & EAPOL_ENABLED)?1:0)
#define IS_MACHINE_AUTH_ENABLED(x) \
    ((x & EAPOL_MACHINE_AUTH_ENABLED)?1:0)
#define IS_GUEST_AUTH_ENABLED(x) \
    ((x & EAPOL_GUEST_AUTH_ENABLED)?1:0)

// Supplicant modes of operation depending on network state and 
// administrator decision

#define     SUPPLICANT_MODE_0       0
#define     SUPPLICANT_MODE_1       1
#define     SUPPLICANT_MODE_2       2
#define     SUPPLICANT_MODE_3       3
#define     MAX_SUPPLICANT_MODE     SUPPLICANT_MODE_3
#define     EAPOL_DEFAULT_SUPPLICANT_MODE   SUPPLICANT_MODE_2

// Auth modes of operation depending on administrator decision

#define     EAPOL_AUTH_MODE_0       0
#define     EAPOL_AUTH_MODE_1       1
#define     EAPOL_AUTH_MODE_2       2
#define     MAX_EAPOL_AUTH_MODE     EAPOL_AUTH_MODE_2
#define     EAPOL_DEFAULT_AUTH_MODE   EAPOL_AUTH_MODE_1

#define     GUID_STRING_LEN_WITH_TERM   39

//
// Heap-related functions
//
#define MALLOC(s)               HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define FREE(p)                 HeapFree(GetProcessHeap(), 0, (p))


// Double-threaded linked list node control block.  There is one node for each
// entry in a list.
//
// Applications should not access this structure directly.
//
typedef struct
_DTLNODE
{
    struct _DTLNODE* pdtlnodePrev; // Address of previous node or NULL if none
    struct _DTLNODE* pdtlnodeNext; // Address of next node or NULL if none
    VOID*    pData;        // Address of user's data
    LONG_PTR lNodeId;      // User-defined node identification code
}
DTLNODE;


//
// Double-threaded linked list control block.  There is one for each list.
//
// Applications should not access this structure directly.
//

typedef struct
_DTLLIST
{
    struct _DTLNODE* pdtlnodeFirst; // Address of first node or NULL if none
    struct _DTLNODE* pdtlnodeLast;  // Address of last node or NULL if none
    LONG     lNodes;        // Number of nodes in list
    LONG_PTR lListId;       // User-defined list identification code
}
DTLLIST;


// List node free function.  See FreeList.
//
typedef VOID (*PDESTROYNODE)( IN DTLNODE* );

#define DtlGetFirstNode( pdtllist )   ((pdtllist)->pdtlnodeFirst)
#define DtlGetNextNode( pdtlnode )    ((pdtlnode)->pdtlnodeNext)
#define DtlGetData( pdtlnode )        ((pdtlnode)->pData)

typedef enum _EAPTLS_CONNPROP_ATTRIBUTE_TYPE_
{

    ecatMinimum = 0,            //Undefined
    ecatFlagRegistryCert,       //Value is a pointer to BOOL
    ecatFlagScard,              //Value is a pointer to BOOL
    ecatFlagValidateServer,     //Value is a pointer to BOOL
    ecatFlagValidateName,       //Value is a pointer to BOOL
    ecatFlagDiffUser,           //Value is a pointer to BOOL
    ecatServerNames,            //Value is a pointer to NULL 
                                //terminated string of semi
                                //colon delimited server names
    ecatRootHashes              //Value is a pointer to 
                                //SHA1 hashes of Root certs.

}EAPTLS_CONNPROP_ATTRIBUTE_TYPE;

typedef struct _EAPTLS_CONNPROP_ATTRIBUTE
{

    EAPTLS_CONNPROP_ATTRIBUTE_TYPE  ecaType;
    DWORD                           dwLength;   //includes byte length of the value
                                                //if it is a LPWSTR, it includes
                                                //the null termination.
    PVOID                           Value;

}EAPTLS_CONNPROP_ATTRIBUTE, *PEAPTLS_CONNPROP_ATTRIBUTE;


// EAP configuration DLL entrypoints.  These definitions must match the
// raseapif.h prototypes for RasEapInvokeConfigUI and RasEapFreeUserData.

typedef DWORD (APIENTRY * RASEAPFREE)( PBYTE );
typedef DWORD (APIENTRY * RASEAPINVOKECONFIGUI)( DWORD, HWND, DWORD, PBYTE, DWORD, PBYTE*, DWORD*);
typedef DWORD (APIENTRY * RASEAPGETIDENTITY)( DWORD, HWND, DWORD, const WCHAR*, const WCHAR*, PBYTE, DWORD, PBYTE, DWORD, PBYTE*, DWORD*, WCHAR** );
typedef DWORD (APIENTRY * RASEAPINVOKEINTERACTIVEUI)( DWORD, HWND, PBYTE, DWORD, PBYTE*, DWORD* );
typedef DWORD (APIENTRY * RASEAPCREATECONNPROP)( PEAPTLS_CONNPROP_ATTRIBUTE, PVOID*, DWORD*, PVOID*, DWORD*);


#define RAS_EAP_VALUENAME_HIDEPEAPMSCHAPv2       TEXT("HidePEAPMSCHAPv2")

// Flags

#define EAPCFG_FLAG_RequireUsername   0x1
#define EAPCFG_FLAG_RequirePassword   0x2

// EAP configuration package definition.

typedef struct
_EAPCFG
{
    // The package's unique EAP algorithm code.
    //
    DWORD dwKey;

    // The friendly name of the package suitable for display to the user.
    //
    TCHAR* pszFriendlyName;

    // The SystemRoot-relative path to the package's configuration DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszConfigDll;

    // The SystemRoot-relative path to the package's identity DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszIdentityDll;

    // Flags that specify what standard credentials are required at dial
    // time.
    //
    DWORD dwStdCredentialFlags;

    // True if user is to be forced to run the configuration API for the
    // package, i.e. defaults are not sufficient.
    //
    BOOL fForceConfig;

    // True if the package provides MPPE encryption keys, false if not.
    //
    BOOL fProvidesMppeKeys;

    // The package's default configuration blob, which can be overwritten by
    // the configuration DLL.  May be NULL and 0 indicating there is none.
    //
    BYTE* pData;
    DWORD cbData;

    // EAP per user data to be stored in HKCU. This data is returned from
    // the EapInvokeConfigUI entrypoint in the eap dll.
    //
    BYTE* pUserData;
    DWORD cbUserData;

    // Set when the configuration DLL has been called on the package.  This is
    // not a registry setting.  It is provided for the convenience of the UI
    // only.
    //
    BOOL fConfigDllCalled;

    // Specifies the class ID of the configuration UI for remote machines.
    // Not used
    GUID guidConfigCLSID;
} EAPCFG;

VOID     DtlDestroyList( DTLLIST*, PDESTROYNODE );

DTLNODE *
CreateEapcfgNode(
    void);

VOID
DestroyEapcfgNode(
    IN OUT DTLNODE* pNode);

DTLNODE*
EapcfgNodeFromKey(
    IN DTLLIST* pList,
    IN DWORD dwKey);

#define     EAPOL_MUTUAL_AUTH_EAP_ONLY      0x00000001

DTLLIST*
ReadEapcfgList(IN DWORD   dwFlags);

#define MAX_SSID_LEN    32

//
// Structure : EAPOL_INTF_PARAMS
//

typedef struct _EAPOL_INTF_PARAMS
{
    DWORD   dwVersion;
    DWORD   dwReserved2;
    DWORD   dwEapFlags;
    DWORD   dwEapType;
    DWORD   dwSizeOfSSID;
    BYTE    bSSID[MAX_SSID_LEN];
} EAPOL_INTF_PARAMS, *PEAPOL_INTF_PARAMS;


//
// EAPOL states
//

typedef enum _EAPOL_STATE 
{
    EAPOLSTATE_LOGOFF = 0,
    EAPOLSTATE_DISCONNECTED,
    EAPOLSTATE_CONNECTING,
    EAPOLSTATE_ACQUIRED,
    EAPOLSTATE_AUTHENTICATING,
    EAPOLSTATE_HELD,
    EAPOLSTATE_AUTHENTICATED,
    EAPOLSTATE_UNDEFINED
} EAPOL_STATE;

//
// EAP UI State 
//

typedef enum _EAPUISTATE 
{
    EAPUISTATE_WAITING_FOR_IDENTITY = 1,
    EAPUISTATE_WAITING_FOR_UI_RESPONSE
} EAPUISTATE;


//
// Structure : EAPOL_INTF_STATE
//

typedef struct _EAPOL_INTF_STATE
{
#if defined(MIDL_PASS)
    [unique, string]    LPWSTR    pwszLocalMACAddr;
#else
    LPWSTR      pwszLocalMACAddr;
#endif
#if defined(MIDL_PASS)
    [unique, string]    LPWSTR    pwszRemoteMACAddr;
#else
    LPWSTR      pwszRemoteMACAddr;
#endif
    DWORD   dwSizeOfSSID;
    BYTE    bSSID[MAX_SSID_LEN+1];
#if defined(MIDL_PASS)
    [unique, string]    LPSTR    pszEapIdentity;
#else
    LPSTR       pszEapIdentity;
#endif
    EAPOL_STATE     dwState;
    EAPUISTATE      dwEapUIState;
    DWORD   dwEAPOLAuthMode;
    DWORD   dwEAPOLAuthenticationType;
    DWORD   dwEapType;
    DWORD   dwFailCount;
    DWORD   dwPhysicalMediumType;
} EAPOL_INTF_STATE, *PEAPOL_INTF_STATE;


#define     EAPOL_VERSION_1             1
#define     EAPOL_VERSION_2             2
#define     EAPOL_VERSION_3             3

#define     EAPOL_CURRENT_VERSION       EAPOL_VERSION_3

//
// Structure : EAPOL_AUTH_DATA
//
typedef struct _EAPOL_AUTH_DATA
{
    DWORD   dwEapType;
    DWORD   dwSize;
    BYTE    bData[1];
} EAPOL_AUTH_DATA, *PEAPOL_AUTH_DATA;

DWORD
WZCGetEapUserInfo (
        IN  WCHAR           *pwszGUID,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizOfSSID,
        IN  BYTE            *pbSSID,
        IN  OUT PBYTE       pbUserInfo,
        IN  OUT DWORD       *pdwInfoSize
        );

// Structure used to define the UI Response.
// Currently it contains upto 3 blobs.
// If more are required, add to the structure

#define NUM_RESP_BLOBS 3

typedef struct _EAPOLUI_RESP
{
    RAW_DATA    rdData0;
    RAW_DATA    rdData1;
    RAW_DATA    rdData2;
} EAPOLUI_RESP, *PEAPOLUI_RESP;


//
// EAPOL Policy related parameters
//

#define     EAPOL_CERT_TYPE_SMARTCARD   1
#define     EAPOL_CERT_TYPE_MC_CERT     2

typedef struct _EAPOL_POLICY_DATA {
    BYTE  pbWirelessSSID[32];
    DWORD dwWirelessSSIDLen;
    DWORD dwEnable8021x;
    DWORD dw8021xMode;
    DWORD dwEAPType;
    DWORD dwMachineAuthentication;
    DWORD dwMachineAuthenticationType;
    DWORD dwGuestAuthentication;
    DWORD dwIEEE8021xMaxStart;
    DWORD dwIEEE8021xStartPeriod;
    DWORD dwIEEE8021xAuthPeriod;
    DWORD dwIEEE8021xHeldPeriod;
    DWORD dwEAPDataLen;
    LPBYTE pbEAPData;
} EAPOL_POLICY_DATA, *PEAPOL_POLICY_DATA;


typedef struct _EAPOL_POLICY_LIST  {
	DWORD			    dwNumberOfItems;
	EAPOL_POLICY_DATA	EAPOLPolicy[1];
} EAPOL_POLICY_LIST, *PEAPOL_POLICY_LIST;


#if !defined(MIDL_PASS)

//---------------------------------------
// WZCEapolGetCustomAuthData: Get EAP-specific configuration data for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   dwEapTypeId:
//     [in]  EAP type Id
//   dwSizeOfSSID:
//     [in]  Size of SSID for which data is to be stored
//   pbSSID:
//     [in]  SSID for which data is to be stored
//   pbConnInfo:
//     [in out]  Connection EAP info
//   pdwInfoSize:
//     [in out]  Size of pbConnInfo
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolGetCustomAuthData (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN  DWORD         dwEapTypeId,
    IN  DWORD         dwSizeOfSSID,
    IN  BYTE          *pbSSID,
    IN OUT PBYTE      pbConnInfo,
    IN OUT PDWORD     pdwInfoSize
    );

//---------------------------------------
// WZCEapolSetCustomAuthData: Set EAP-specific configuration data for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   dwEapTypeId:
//     [in]  EAP type Id
//   dwSizeOfSSID:
//     [in]  Size of SSID for which data is to be stored
//   pbSSID:
//     [in]  SSID for which data is to be stored
//   pbConnInfo:
//     [in]  Connection EAP info
//   pdwInfoSize:
//     [in]  Size of pbConnInfo
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolSetCustomAuthData (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN  DWORD         dwEapTypeId,
    IN  DWORD         dwSizeOfSSID,
    IN  BYTE          *pbSSID,
    IN  PBYTE         pbConnInfo,
    IN  DWORD         dwInfoSize
    );

//---------------------------------------
// WZCEapolGetInterfaceParams: Get configuration parameters for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   pIntfParams:
//     [in out]  Interface Parameters
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolGetInterfaceParams (
    IN  LPWSTR          pSrvAddr,
    IN  PWCHAR          pwszGuid,
    IN OUT EAPOL_INTF_PARAMS   *pIntfParams
    );

//---------------------------------------
// WZCEapolSetInterfaceParams: Set configuration parameters for interface
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   pIntfParams:
//     [in]  Interface parameters
// Returned value:
//     Win32 error code 
DWORD
WZCEapolSetInterfaceParams (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid,
    IN  EAPOL_INTF_PARAMS   *pIntfParams
    );

//---------------------------------------
// WZCEapolReAuthenticate : Restart 802.1X authentication on an interface 
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
// Returned value:
//     Win32 error code 
DWORD
WZCEapolReAuthenticate (
    IN  LPWSTR        pSrvAddr,
    IN  PWCHAR        pwszGuid
    );

//---------------------------------------
// WZCEapolQueryState: Query the interface 802.1X/EAPOL state
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   pwszGuid:
//     [in]  Interface GUID
//   pIntfState:
//     [in out]  EAPOL Interface State
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolQueryState (
    IN  LPWSTR              pSrvAddr,
    IN  PWCHAR              pwszGuid,
    IN OUT EAPOL_INTF_STATE *pIntfState
    );

#endif // MIDL_PASS

//
// Free EAPOL interface state information on the client side obtained via
// RPC query
//

DWORD
WZCEapolFreeState (
    IN  EAPOL_INTF_STATE    *pIntfState
    );


//
// Structure: EAPOL_EAP_UI_CONTEXT
//

typedef struct _EAPOL_EAP_UI_CONTEXT
{
    DWORD       dwEAPOLUIMsgType;
    WCHAR       wszGUID[39];
    DWORD       dwSessionId;
    DWORD       dwContextId;
    DWORD       dwEapId;
    DWORD       dwEapTypeId;
    DWORD       dwEapFlags;
    WCHAR       wszSSID[MAX_SSID_LEN+1];
    DWORD       dwSizeOfSSID;
    BYTE        bSSID[MAX_SSID_LEN];
    DWORD       dwEAPOLState;
    DWORD       dwRetCode;
    DWORD       dwSizeOfEapUIData;
    BYTE        bEapUIData[1];
} EAPOL_EAP_UI_CONTEXT, *PEAPOL_EAP_UI_CONTEXT;

//
// Defines for messaging between Service and Dialog DLL
//

#define     EAPOLUI_GET_USERIDENTITY            0x00000001
#define     EAPOLUI_GET_USERNAMEPASSWORD        0x00000002
#define     EAPOLUI_INVOKEINTERACTIVEUI         0x00000004
#define     EAPOLUI_EAP_NOTIFICATION            0x00000008
#define     EAPOLUI_REAUTHENTICATE              0x00000010
#define     EAPOLUI_CREATEBALLOON               0x00000020
#define     EAPOLUI_CLEANUP                     0x00000040
#define     EAPOLUI_DUMMY                       0x00000080

#define     NUM_EAPOL_DLG_MSGS      8


//---------------------------------------
// WZCEapolUIResponse: Send Dlg response to Service
// 
// Parameters:
//   pSrvAddr:
//     [in]  WZC Server to contact
//   EapolUIContext:
//     [in]  EAPOLUI Context data
//   EapolUI:
//     [in]  EAPOLUI response data
//
// Returned value:
//     Win32 error code 
DWORD
WZCEapolUIResponse (
    IN  LPWSTR                  pSrvAddr,
    IN  EAPOL_EAP_UI_CONTEXT    EapolUIContext,
    IN  EAPOLUI_RESP            EapolUIResp
    );


# ifdef     __cplusplus
}
# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\inc\polstore2.h ===
enum STORAGE_LOCATION {
        LOCATION_LOCAL=0,
        LOCATION_REMOTE,
        LOCATION_GLOBAL,
        LOCATION_CACHE,
        LOCATION_FILE,
    };


#include <polstructs.h>


DWORD
IPSecEnumPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );

DWORD
IPSecSetPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
IPSecCreatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
IPSecDeletePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
IPSecEnumFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    );

DWORD
IPSecSetFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
IPSecCreateFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
IPSecDeleteFilterData(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    );

DWORD
IPSecEnumNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    );

DWORD
IPSecSetNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
IPSecCreateNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
IPSecDeleteNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    );

DWORD
IPSecCreateNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
IPSecSetNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
IPSecDeleteNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
IPSecEnumNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    );

DWORD
IPSecGetFilterData(
    HANDLE hPolicyStore,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
IPSecGetNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
IPSecEnumISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
IPSecSetISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

DWORD
IPSecCreateISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

DWORD
IPSecDeleteISAKMPData(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier
    );

DWORD
IPSecGetISAKMPData(
    HANDLE hPolicyStore,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
IPSecOpenPolicyStore(
    LPWSTR pszMachineName,
    DWORD dwTypeOfStore,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    );

DWORD
RegOpenPolicyStore(
    LPWSTR pszMachineName,
    HANDLE * phPolicyStore
    );

DWORD
DirOpenPolicyStore(
    LPWSTR pszMachineName,
    HANDLE * phPolicyStore
    );

DWORD
FileOpenPolicyStore(
    LPWSTR pszMachineName,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    );

DWORD
IPSecClosePolicyStore(
    HANDLE hPolicyStore
    );

DWORD
IPSecAssignPolicy(
    HANDLE hPolicyStore,
    GUID PolicyGUID
    );

DWORD
IPSecUnassignPolicy(
    HANDLE hPolicyStore,
    GUID PolicyGUID
    );

DWORD
ComputeDirLocationName(
    LPWSTR pszDirDomainName,
    LPWSTR * ppszDirFQPathName
    );

DWORD
IPSecGetAssignedPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );


DWORD
IPSecExportPolicies(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    );

DWORD
IPSecImportPolicies(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    );

/*
//////////////////////////////
//
// Globals
//
//////////////////////////////

// {6A1F5C6F-72B7-11d2-ACF0-0060B0ECCA17}
static const GUID GUID_POLSTORE_VERSION_INFO =
{ 0x6a1f5c6f, 0x72b7, 0x11d2, { 0xac, 0xf0, 0x0, 0x60, 0xb0, 0xec, 0xca, 0x17 } };


// {72385230-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_POLICY =
{ 0x72385230, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385231-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_ISAKMP =
{ 0x72385231, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385232-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_NFA =
{ 0x72385232, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385233-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_SECURE_INITIATOR_NEGPOL =
{ 0x72385233, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {72385236-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_RESPONDER_POLICY =
{ 0x72385236, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385237-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_RESPONDER_ISAKMP =
{ 0x72385237, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {72385238-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_L2TP_POLICY =
{ 0x72385238, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385239-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_L2TP_ISAKMP =
{ 0x72385239, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {7238523a-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_ME_TO_FROM_ANYONE_FILTER=
{ 0x7238523a, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {72385235-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_ICMP_FILTER =
{ 0x72385235, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


// {7238523c-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_POLICY =
{ 0x7238523c, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {7238523d-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_ISAKMP =
{ 0x7238523d, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {7238523e-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_NFA =
{ 0x7238523e, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {7238523f-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_LOCKDOWN_NEGPOL =
{ 0x7238523f, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

static const GUID GUID_BUILTIN_PERMIT_NEGPOL =
{ 0x7238523b, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };





//////////////////////////////
//////////////////////////////
//      Negotiation Policy Types
//////////////////////////////
//////////////////////////////
// {62F49E10-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_STANDARD =
{ 0x62f49e10, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E11-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_L2TP_BASE =
{ 0x62f49e11, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E12-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_L2TP_EXTENDED =
{ 0x62f49e12, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E13-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_DEFAULT =
{ 0x62f49e13, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


//////////////////////////////
//////////////////////////////
//      Negotiation Policy Actions
//////////////////////////////
//////////////////////////////

// {3F91A819-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_BLOCK =
{ 0x3f91a819, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {3F91A81A-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU =
{ 0x3f91a81a, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD2-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NO_IPSEC =
{ 0x8a171dd2, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD3-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NORMAL_IPSEC =
{ 0x8a171dd3, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };




//////////////////////////////
//////////////////////////////
//      GUID identifying the default IKE settings to use
//      in case no policy is assigned.
//////////////////////////////
//////////////////////////////
// {72385234-70FA-11d1-864C-14A300000000}
static const GUID GUID_BUILTIN_DEFAULT_ISAKMP_POLICY=
{ 0x72385234, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

///////////////////////
// GUIDS reserved for future use... These are handy mostly because they
// are easily recognizable because of the trailing zeros.  This helps out in
// debugging and in manual manipulation of policies by GUID -- such as removing
// built-in policies from the DS using adsvw etc.
//////////////////////
*/


#define PAS_INTERFACE_TYPE_NONE          0
#define PAS_INTERFACE_TYPE_DIALUP       -1
#define PAS_INTERFACE_TYPE_LAN          -2
#define PAS_INTERFACE_TYPE_ALL          -3


//
// Negotiation Policy Actions.
//

// {3F91A819-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_BLOCK =
{ 0x3f91a819, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {3F91A81A-7647-11d1-864D-D46A00000000}
static const GUID GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU =
{ 0x3f91a81a, 0x7647, 0x11d1, { 0x86, 0x4d, 0xd4, 0x6a, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD2-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NO_IPSEC =
{ 0x8a171dd2, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };

// {8A171DD3-77E3-11d1-8659-A04F00000000}
static const GUID GUID_NEGOTIATION_ACTION_NORMAL_IPSEC =
{ 0x8a171dd3, 0x77e3, 0x11d1, { 0x86, 0x59, 0xa0, 0x4f, 0x0, 0x0, 0x0, 0x0 } };


//
// Negotiation Policy Types.
//

// {62F49E10-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_STANDARD =
{ 0x62f49e10, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

// {62F49E13-6C37-11d1-864C-14A300000000}
static const GUID GUID_NEGOTIATION_TYPE_DEFAULT =
{ 0x62f49e13, 0x6c37, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


DWORD
IPSecRestoreDefaultPolicies(
    HANDLE hPolicyStore
    );


DWORD
IPSecIsDomainPolicyAssigned(
    PBOOL pbIsDomainPolicyAssigned
    );


//
// Polstore memory management functions.
//


LPVOID
IPSecAllocPolMem(
    DWORD cb
    );

BOOL
IPSecFreePolMem(
    LPVOID pMem
    );

LPWSTR
IPSecAllocPolStr(
    LPCWSTR pStr
    );

BOOL
IPSecFreePolStr(
    LPWSTR pStr
    );

DWORD
IPSecReallocatePolMem(
    LPVOID * ppOldMem,
    DWORD cbOld,
    DWORD cbNew
    );

BOOL
IPSecReallocatePolStr(
    LPWSTR *ppStr,
    LPWSTR pStr
    );

void
IPSecFreePolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

void
IPSecFreeNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

void
IPSecFreeFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

void
IPSecFreeISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

void
IPSecFreeNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
IPSecCopyPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
IPSecCopyNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
IPSecCopyFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
IPSecCopyFilterSpec(
    PIPSEC_FILTER_SPEC   pFilterSpecs,
    PIPSEC_FILTER_SPEC * ppFilterSpecs
    );

DWORD
IPSecCopyISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
IPSecCopyNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
IPSecCopyAuthMethod(
    PIPSEC_AUTH_METHOD   pAuthMethod,
    PIPSEC_AUTH_METHOD * ppAuthMethod
    );

void
IPSecFreeMulPolicyData(
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    );

void
IPSecFreeMulNegPolData(
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData,
    DWORD dwNumNegPolObjects
    );

void
IPSecFreeMulFilterData(
    PIPSEC_FILTER_DATA * ppIpsecFilterData,
    DWORD dwNumFilterObjects
    );

void
IPSecFreeFilterSpecs(
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs,
    DWORD dwNumFilterSpecs
    );

void
IPSecFreeFilterSpec(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec
    );

void
IPSecFreeMulISAKMPData(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumISAKMPObjects
    );

void
IPSecFreeMulNFAData(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFAObjects
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\globals.cpp ===
#include "ipseccmd.h"

char  STRLASTERR[POTF_MAX_STRLEN];  // used for error macro

TCHAR pszIpsecpolPrefix[]  = TEXT("ipseccmd ");

ShowOptions ipseccmdShow;

_TUCHAR    szServ[POTF_MAX_STRLEN] = {0};

bool  bLocalMachine = true;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\inc\polstructs.h ===
#define IPSEC_REGISTRY_PROVIDER     0
#define IPSEC_DIRECTORY_PROVIDER    1
#define IPSEC_FILE_PROVIDER         2


typedef struct _IPSEC_AUTH_METHOD {
    DWORD dwAuthType;
    DWORD dwAuthLen;
    LPWSTR pszAuthMethod;
    DWORD dwAltAuthLen;
    PBYTE pAltAuthMethod;
} IPSEC_AUTH_METHOD, *PIPSEC_AUTH_METHOD;

typedef struct _IPSEC_FILTER_SPEC {
    LPWSTR pszSrcDNSName;
    LPWSTR pszDestDNSName;
    LPWSTR pszDescription;
    GUID FilterSpecGUID;
    DWORD dwMirrorFlag;
    IPSEC_FILTER Filter;
} IPSEC_FILTER_SPEC, *PIPSEC_FILTER_SPEC;

typedef struct _IPSEC_FILTER_DATA {
    GUID  FilterIdentifier;
    DWORD dwNumFilterSpecs;
    PIPSEC_FILTER_SPEC * ppFilterSpecs;
    DWORD dwWhenChanged;
    LPWSTR pszIpsecName;
    LPWSTR pszDescription;
} IPSEC_FILTER_DATA, *PIPSEC_FILTER_DATA;

typedef IPSEC_ALG_TYPE IPSEC_SECURITY_METHOD, *PIPSEC_SECURITY_METHOD;

typedef struct _IPSEC_NEGPOL_DATA {
    GUID  NegPolIdentifier;
    GUID  NegPolAction;
    GUID  NegPolType;
    DWORD dwSecurityMethodCount;
    IPSEC_SECURITY_METHOD * pIpsecSecurityMethods;
    DWORD dwWhenChanged;
    LPWSTR pszIpsecName;
    LPWSTR pszDescription;
} IPSEC_NEGPOL_DATA, *PIPSEC_NEGPOL_DATA;

typedef struct _IPSEC_ISAKMP_DATA {
    GUID  ISAKMPIdentifier;
    ISAKMP_POLICY ISAKMPPolicy;
    DWORD dwNumISAKMPSecurityMethods;
    PCRYPTO_BUNDLE pSecurityMethods;
    DWORD dwWhenChanged;
} IPSEC_ISAKMP_DATA, *PIPSEC_ISAKMP_DATA;

typedef struct _IPSEC_NFA_DATA {
    LPWSTR pszIpsecName;
    GUID  NFAIdentifier;
    DWORD dwAuthMethodCount;
    PIPSEC_AUTH_METHOD * ppAuthMethods;
    DWORD dwInterfaceType;
    LPWSTR pszInterfaceName;
    DWORD dwTunnelIpAddr;
    DWORD dwTunnelFlags;
    DWORD dwActiveFlag;
    LPWSTR pszEndPointName;
    PIPSEC_FILTER_DATA pIpsecFilterData;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData;
    DWORD dwWhenChanged;
    GUID NegPolIdentifier;
    GUID FilterIdentifier;
    LPWSTR pszDescription;
} IPSEC_NFA_DATA, *PIPSEC_NFA_DATA;

typedef struct _IPSEC_POLICY_DATA{
    GUID  PolicyIdentifier;
    DWORD dwPollingInterval;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData;
    PIPSEC_NFA_DATA * ppIpsecNFAData;
    DWORD dwNumNFACount;
    DWORD dwWhenChanged;
    LPWSTR pszIpsecName;
    LPWSTR pszDescription;
    GUID ISAKMPIdentifier;
} IPSEC_POLICY_DATA, *PIPSEC_POLICY_DATA;


LPVOID
AllocPolMem(
    DWORD cb
    );

BOOL
FreePolMem(
    LPVOID pMem
    );

LPWSTR
AllocPolStr(
    LPCWSTR pStr
    );

BOOL
FreePolStr(
    LPWSTR pStr
    );

DWORD
ReallocatePolMem(
    LPVOID * ppOldMem,
    DWORD cbOld,
    DWORD cbNew
    );

BOOL
ReallocPolStr(
    LPWSTR *ppStr,
    LPWSTR pStr
    );

void
FreeIpsecPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

void
FreeIpsecNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

void
FreeIpsecFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

void
FreeIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

void
FreeIpsecNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
CopyIpsecPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
CopyIpsecNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
CopyIpsecAuthMethod(
    PIPSEC_AUTH_METHOD   pAuthMethod,
    PIPSEC_AUTH_METHOD * ppAuthMethod
    );

DWORD
CopyIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
CopyIpsecFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
CopyIpsecFilterSpec(
    PIPSEC_FILTER_SPEC   pFilterSpecs,
    PIPSEC_FILTER_SPEC * ppFilterSpecs
    );

DWORD
CopyIpsecNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );


void
FreeMulIpsecFilterData(
    PIPSEC_FILTER_DATA * ppIpsecFilterData,
    DWORD dwNumFilterObjects
    );

void
FreeMulIpsecNegPolData(
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData,
    DWORD dwNumNegPolObjects
    );

void
FreeMulIpsecPolicyData(
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    );

void
FreeMulIpsecNFAData(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFAObjects
    );

void
FreeIpsecFilterSpecs(
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs,
    DWORD dwNumFilterSpecs
    );

void
FreeIpsecFilterSpec(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec
    );

void
FreeMulIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumISAKMPObjects
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\inc\policycf.h ===
#ifndef _POLICYCF_H
#define _POLICYCF_H

#define CFSTR_IPSECPOLICYOBJECT   L"IPSEC_POLICYOBJECT"
#define POByteOffset(base, offset) (((LPBYTE)base)+offset)

typedef struct
{
	DWORD m_dwInterfaceFlags;
	long  m_lMMCUpdateHandle;

	DWORD m_dwOffsetObjClass;
	DWORD m_dwOffsetObjPath;
	DWORD m_dwOffsetRemoteMachineName;
} POLICYOBJECTSTRUCT;

class POLICYOBJECT
{
public:
	// Policy Object flags
	#define POFLAG_INVALID  0x00000000
	#define POFLAG_NEW		0x00000002
	#define POFLAG_EDIT		0x00000004
	#define POFLAG_APPLY	0x00000008
	#define POFLAG_CANCEL	0x00000010
	#define POFLAG_LOCAL	0x00000020
	#define POFLAG_GLOBAL   0x00000040
	#define POFLAG_REMOTE	0x00000080


	POLICYOBJECT ()	
	{
		dwInterfaceFlags (POFLAG_INVALID);
		lMMCUpdateHandle (0);
	};
	~POLICYOBJECT () {};

	// memory allocation helpers
	int DataGlobalAllocLen ()
	{
		return (sizeof (POLICYOBJECTSTRUCT) + 
			m_sObjClass.GetLength()*sizeof(wchar_t)+sizeof(wchar_t) + 
			m_sObjPath.GetLength()*sizeof(wchar_t)+sizeof(wchar_t) +
			m_sRemoteMachineName.GetLength()*sizeof(wchar_t)+sizeof(wchar_t));
	}

	HRESULT FromObjMedium (STGMEDIUM* pObjMedium)
	{
		HRESULT hr = E_UNEXPECTED;
	    POLICYOBJECTSTRUCT* pPolicyStruct = (POLICYOBJECTSTRUCT*) pObjMedium->hGlobal;	
		if (pPolicyStruct)
		{
			m_dwInterfaceFlags = pPolicyStruct->m_dwInterfaceFlags;
			m_lMMCUpdateHandle = pPolicyStruct->m_lMMCUpdateHandle;

			m_sObjPath		 = (LPWSTR)POByteOffset(pPolicyStruct, pPolicyStruct->m_dwOffsetObjPath);
			m_sObjClass		 = (LPWSTR)POByteOffset(pPolicyStruct, pPolicyStruct->m_dwOffsetObjClass);
			m_sRemoteMachineName = (LPWSTR)POByteOffset(pPolicyStruct, pPolicyStruct->m_dwOffsetRemoteMachineName);

			hr = S_OK;
		}
		return hr;
	}

	HRESULT ToPolicyStruct (POLICYOBJECTSTRUCT* pPolicyStruct)
	{
		HRESULT hr = E_UNEXPECTED;
		if (pPolicyStruct)
		{
			pPolicyStruct->m_dwInterfaceFlags = m_dwInterfaceFlags;
			pPolicyStruct->m_lMMCUpdateHandle = m_lMMCUpdateHandle;

			// store ObjPath
			int istrlenObjPath =  m_sObjPath.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
			int iStructLen = sizeof (POLICYOBJECTSTRUCT);
			LONG_PTR addr = ((LONG_PTR)(pPolicyStruct)) + iStructLen;
			memcpy((void*)addr,m_sObjPath,istrlenObjPath);
			pPolicyStruct->m_dwOffsetObjPath=iStructLen;

			// store ObjClass
			// using the current istrlen (length of ObjPath) determine new address and offset for the class
			addr = addr + istrlenObjPath;
			pPolicyStruct->m_dwOffsetObjClass=iStructLen+istrlenObjPath;
			// get new strlen and copy the class in
			int istrlenObjClass = m_sObjClass.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
			memcpy((void*)addr,m_sObjClass,istrlenObjClass);

			// store RemoteMachineName
			// using istrlenObjClass (length of ObjClass) determine new address and offset for the class
			addr = addr + istrlenObjClass;
			pPolicyStruct->m_dwOffsetRemoteMachineName=iStructLen+istrlenObjPath+istrlenObjClass;
			// get new strlen and copy the class in
			int istrlenRemoteMachineName = m_sRemoteMachineName.GetLength()*sizeof(wchar_t)+sizeof(wchar_t);
			memcpy((void*)addr,m_sRemoteMachineName,istrlenRemoteMachineName);

			hr = S_OK;
		}
		return hr;
	}

	// member access methods
	DWORD dwInterfaceFlags() {return m_dwInterfaceFlags;}
	void dwInterfaceFlags (DWORD dw) {m_dwInterfaceFlags = dw;}

	long lMMCUpdateHandle() {return m_lMMCUpdateHandle;}
	void lMMCUpdateHandle (long l) {m_lMMCUpdateHandle = l;}

	CString ObjClass() {return m_sObjClass;}
	void ObjClass (CString s) {m_sObjClass = s;}

	CString ObjPath() {return m_sObjPath;}
	void ObjPath (CString s) {m_sObjPath = s;}

	CString RemoteMachineName() {return m_sRemoteMachineName;}
	void RemoteMachineName (CString s) {m_sRemoteMachineName = s;}

private:
	DWORD m_dwInterfaceFlags;
	long  m_lMMCUpdateHandle;

	CString m_sObjClass;
	CString m_sObjPath;
	CString m_sRemoteMachineName;
};

#endif // _POLICYCF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\externs.h ===
// from ipseccmd.cpp

extern char  STRLASTERR[];  // used for error macro

extern TCHAR pszIpsecpolPrefix[];

extern _TUCHAR    szServ[POTF_MAX_STRLEN];
extern bool  bLocalMachine;

typedef struct _ShowOptions {
	bool bFilters;
	bool bPolicies;
	bool bAuth;
	bool bStats;
	bool bSAs;
} ShowOptions;

extern ShowOptions ipseccmdShow;

// from print.cpp
TCHAR oak_auth[][25];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\guidgen.cpp ===
/////////////////////////////////////////////////////////////
// Copyright(c) 2000, Microsoft Corporation
//
// guidgen.cpp
//
// Created on 3/1/00 by DKalin (Dennis Kalinichenko)
// Revisions:
//
// Implementation for the guid/name generation routines
//
/////////////////////////////////////////////////////////////

#include "ipseccmd.h"

/*********************************************************************
	FUNCTION: GenerateGuidNamePair
        PURPOSE:  Generates GUID and name for the object using specified prefix
        PARAMS:
          pszPrefix - prefix to use, can be NULL (then default prefix will be used)
          gID       - reference to GUID
          ppszName  - address of name pointer, memory will be allocated inside this function		
        RETURNS: none, will assert if memory cannot be allocated
        COMMENTS:
		  caller is responsible for freeing the memory allocated
		  (see also DeleteGuidsNames routine)
*********************************************************************/
void GenerateGuidNamePair (IN LPWSTR pszPrefix, OUT GUID& gID, OUT LPWSTR* ppszName)
{
	WCHAR StringTxt[POTF_MAX_STRLEN];
	RPC_STATUS RpcStat;
	int iReturn;

	// cleanup first
	assert(ppszName != 0);
	if (*ppszName != 0)
	{
		delete[] *ppszName;
	}

	// set the prefix
	if (pszPrefix == 0 || pszPrefix[0] == 0)
	{
		wcscpy(StringTxt, L"text2pol ");
	}
	else
	{
		wcscpy(StringTxt, pszPrefix);
	}

	RpcStat = UuidCreate(&gID);
	assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);

	// set the name to be equal to the prefix + GUID
	iReturn = StringFromGUID2(gID, StringTxt+wcslen(StringTxt), POTF_MAX_STRLEN-wcslen(StringTxt));
	assert(iReturn != 0);
	*ppszName = new WCHAR[wcslen(StringTxt)+1];
	assert(*ppszName != NULL);
	wcscpy(*ppszName, StringTxt);
} /* GenerateGuidNamePair */

/*********************************************************************
	FUNCTION: GenerateGuidsNames
        PURPOSE:  Generates all necessary GUIDs and names for IPSEC_IKE_POLICY
        PARAMS:
          pszPrefix   - prefix to use, can be NULL (then default prefix will be used)
          IPSecIkePol - reference to IPSEC_IKE_POLICY structure
        RETURNS: none, will assert if memory cannot be allocated
        COMMENTS:
		  caller is responsible for freeing the memory allocated
		  (see also DeleteGuidsNames routine)
*********************************************************************/
void GenerateGuidsNames (IN LPWSTR pszPrefix, IN OUT IPSEC_IKE_POLICY& IPSecIkePol)
{
	int i;
	IPSEC_IKE_POLICY TmpPol; // for checks
	RPC_STATUS RpcStat;

	// set TmpPol to 0's
	memset(&TmpPol, 0, sizeof(TmpPol));
	
	// walk through all the substructures and call GenerateGuidNamePair
	for (i = 0; i < (int) IPSecIkePol.dwNumMMFilters; i++)
	{
		GenerateGuidNamePair(pszPrefix, IPSecIkePol.pMMFilters[i].gFilterID, &IPSecIkePol.pMMFilters[i].pszFilterName);
	}
	for (i = 0; i < (int) IPSecIkePol.dwNumFilters; i++)
	{
//		printf("GenerateGuidsNames i is %d", i);
		if (IPSecIkePol.QMFilterType == QM_TRANSPORT_FILTER)
		{
			GenerateGuidNamePair(pszPrefix, IPSecIkePol.pTransportFilters[i].gFilterID, &IPSecIkePol.pTransportFilters[i].pszFilterName);
		}
		else
		{
			// tunnel
			GenerateGuidNamePair(pszPrefix, IPSecIkePol.pTunnelFilters[i].gFilterID, &IPSecIkePol.pTunnelFilters[i].pszFilterName);
		}
	}

	if (memcmp(&IPSecIkePol.IkePol, &TmpPol.IkePol, sizeof(TmpPol.IkePol)) != 0)
	{
		// IkePol is not 0's
		GenerateGuidNamePair(pszPrefix, IPSecIkePol.IkePol.gPolicyID, &IPSecIkePol.IkePol.pszPolicyName);
	}

	if (memcmp(&IPSecIkePol.IpsPol, &TmpPol.IpsPol, sizeof(TmpPol.IpsPol)) != 0)
	{
		// IkePol is not 0's
		GenerateGuidNamePair(pszPrefix, IPSecIkePol.IpsPol.gPolicyID, &IPSecIkePol.IpsPol.pszPolicyName);
	}

	// go for auth methods
	if (memcmp(&IPSecIkePol.AuthInfos, &TmpPol.AuthInfos, sizeof(TmpPol.AuthInfos)) != 0)
	{
		RpcStat = UuidCreate(&IPSecIkePol.AuthInfos.gMMAuthID);
		assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);
	}

	/* now fixup guid links */
	/* mainmode filters */
	for (i = 0; i < (int) IPSecIkePol.dwNumMMFilters; i++)
	{
		if (UuidIsNil(&IPSecIkePol.pMMFilters[i].gPolicyID, &RpcStat))
		{
			IPSecIkePol.pMMFilters[i].gPolicyID = IPSecIkePol.IkePol.gPolicyID;
		}
		if (UuidIsNil(&IPSecIkePol.pMMFilters[i].gMMAuthID, &RpcStat))
		{
			IPSecIkePol.pMMFilters[i].gMMAuthID = IPSecIkePol.AuthInfos.gMMAuthID;
		}
		assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);
	}
	/* quickmode filters */
	for (i = 0; i < (int) IPSecIkePol.dwNumFilters; i++)
	{
		if (IPSecIkePol.QMFilterType == QM_TRANSPORT_FILTER)
		{
			if (UuidIsNil(&IPSecIkePol.pTransportFilters[i].gPolicyID, &RpcStat))
			{
				IPSecIkePol.pTransportFilters[i].gPolicyID = IPSecIkePol.IpsPol.gPolicyID;
			}
		}
		else
		{
			// tunnel
			if (UuidIsNil(&IPSecIkePol.pTunnelFilters[i].gPolicyID, &RpcStat))
			{
				IPSecIkePol.pTunnelFilters[i].gPolicyID = IPSecIkePol.IpsPol.gPolicyID;
			}
		}
		assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);
	}

} /* GenerateGuidsNames */

/*********************************************************************
	FUNCTION: DeleteGuidsNames
        PURPOSE:  Deletes all GUIDs and names from IPSEC_IKE_POLICY (used for cleanup)
        PARAMS:
          IPSecIkePol - reference to IPSEC_IKE_POLICY structure
        RETURNS: none
        COMMENTS:
*********************************************************************/
void DeleteGuidsNames (IN OUT IPSEC_IKE_POLICY& IPSecIkePol)
{
	int i;

	// walk through all the substructures and call GenerateGuidNamePair
	for (i = 0; i < (int) IPSecIkePol.dwNumMMFilters; i++)
	{
		UuidCreateNil(&IPSecIkePol.pMMFilters[i].gFilterID);
		UuidCreateNil(&IPSecIkePol.pMMFilters[i].gPolicyID);
		UuidCreateNil(&IPSecIkePol.pMMFilters[i].gMMAuthID);
		if (IPSecIkePol.pMMFilters[i].pszFilterName != 0)
		{
			delete[] IPSecIkePol.pMMFilters[i].pszFilterName;
			IPSecIkePol.pMMFilters[i].pszFilterName = 0;
		}
	}

	for (i = 0; i < (int) IPSecIkePol.dwNumFilters; i++)
	{
		if (IPSecIkePol.QMFilterType == QM_TRANSPORT_FILTER)
		{
			UuidCreateNil(&IPSecIkePol.pTransportFilters[i].gFilterID);
			UuidCreateNil(&IPSecIkePol.pTransportFilters[i].gPolicyID);
			if (IPSecIkePol.pTransportFilters[i].pszFilterName != 0)
			{
				delete[] IPSecIkePol.pTransportFilters[i].pszFilterName;
				IPSecIkePol.pTransportFilters[i].pszFilterName = 0;
			}
		}
		else
		{
			// tunnel
			UuidCreateNil(&IPSecIkePol.pTunnelFilters[i].gFilterID);
			UuidCreateNil(&IPSecIkePol.pTunnelFilters[i].gPolicyID);
			if (IPSecIkePol.pTunnelFilters[i].pszFilterName != 0)
			{
				delete[] IPSecIkePol.pTunnelFilters[i].pszFilterName;
				IPSecIkePol.pTunnelFilters[i].pszFilterName = 0;
			}
		}
	}

	UuidCreateNil(&IPSecIkePol.IkePol.gPolicyID);
	if (IPSecIkePol.IkePol.pszPolicyName != 0)
	{
		delete[] IPSecIkePol.IkePol.pszPolicyName;
		IPSecIkePol.IkePol.pszPolicyName = 0;
	}

	UuidCreateNil(&IPSecIkePol.IpsPol.gPolicyID);
	if (IPSecIkePol.IpsPol.pszPolicyName != 0)
	{
		delete[] IPSecIkePol.IpsPol.pszPolicyName;
		IPSecIkePol.IpsPol.pszPolicyName = 0;
	}

	UuidCreateNil(&IPSecIkePol.AuthInfos.gMMAuthID);
} /* DeleteGuidsNames */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\pol2stor.cpp ===
#include "ipseccmd.h"

#ifdef __cplusplus
   extern "C" {
#endif


IPSECPolicyToStorage::IPSECPolicyToStorage():
  myPolicyStorage(NULL),
  myIPSECPolicy(NULL),
  mybIsOpen(false),
  mybPolicyExists(false)
{
}

IPSECPolicyToStorage::~IPSECPolicyToStorage()
{

// if (myIPSECPolicy)   IPSecFreePolicyData(myIPSECPolicy);
// polstore AVs if something inside the policy is missing

 if (myPolicyStorage)
 {
   IPSecClosePolicyStore(myPolicyStorage);
 }
}

// this small function will attempt to CreateIpsecPolicyData, and if it succeeds, it'll mark that object is created in the storage
//   so that next time we'll use Set routine, not Create
void
IPSECPolicyToStorage::TryToCreatePolicy()
{
	if (IPSecCreatePolicyData(myPolicyStorage, myIPSECPolicy) == ERROR_SUCCESS)
	{
		mybPolicyExists = true;
	}
}

// opens storage an initializes policy
// pass name as NULL for local storage or if you want
// the DS to be located
// szPolicyName is required
// szDescription is optional
HRESULT
IPSECPolicyToStorage::Open(
                           IN DWORD location,
                           IN LPTSTR name,
                           IN LPTSTR szPolicyName,
                           IN LPTSTR szDescription,
                           IN time_t tPollingInterval,
                           IN bool   bUseExisting)

{
   HRESULT        hrReturnCode   = S_OK;
   RPC_STATUS     RpcStat;

   // need to do error checking
   if (!szPolicyName || (szPolicyName[0] == TEXT('\0')) )
   {
      hrReturnCode = P2STORE_MISSING_NAME;
   }
   else
   {
      if (myPolicyStorage)
	  {
	      IPSecClosePolicyStore(myPolicyStorage);
		  myPolicyStorage = NULL;
	  }
      hrReturnCode = IPSecOpenPolicyStore(name, location, NULL, &myPolicyStorage);
	  if (hrReturnCode == ERROR_SUCCESS)
	  {
		  mybIsOpen = true;
          if (myIPSECPolicy)
		  {
			  IPSecFreePolicyData(myIPSECPolicy);
			  myIPSECPolicy = NULL;
		  }
		  if (bUseExisting)
		  {
			  // try to find existing policy cause user requested us to
			  // myIPSECPolicy will be NULL if we haven't found it
			  PIPSEC_POLICY_DATA *ppPolicyEnum  = NULL;
			  DWORD               dwNumPolicies = 0;


			  hrReturnCode = IPSecEnumPolicyData(myPolicyStorage, &ppPolicyEnum, &dwNumPolicies);
			  if (hrReturnCode == ERROR_SUCCESS && dwNumPolicies > 0 && ppPolicyEnum != NULL)
			  {
				  // we have something in the storage, let's go through it
				  int i;

				  for (i = 0; i < (int) dwNumPolicies; i++)
				  {
					  if (wcscmp(ppPolicyEnum[i]->pszIpsecName, szPolicyName) == 0)
					  {
						  // we found it
						  // make a copy in myIPSECPolicy and update description and polling interval
						  hrReturnCode = IPSecCopyPolicyData(ppPolicyEnum[i], &myIPSECPolicy);
						  mybPolicyExists = true;
						  if (hrReturnCode == ERROR_SUCCESS)
						  {
							  hrReturnCode = IPSecEnumNFAData(myPolicyStorage, myIPSECPolicy->PolicyIdentifier
								                              , &(myIPSECPolicy->ppIpsecNFAData), &(myIPSECPolicy->dwNumNFACount));
						  }
						  if (hrReturnCode == ERROR_SUCCESS)
						  {
							  int i;

							  // also get other parts of the policy, no error checks here
							  IPSecGetISAKMPData(myPolicyStorage, myIPSECPolicy->ISAKMPIdentifier, &(myIPSECPolicy->pIpsecISAKMPData));
							  for (i = 0; i < (int) myIPSECPolicy->dwNumNFACount; i++)
							  {
								  if (!UuidIsNil(&(myIPSECPolicy->ppIpsecNFAData[i]->NegPolIdentifier), &RpcStat))
								  {
									  IPSecGetNegPolData(myPolicyStorage,
										                 myIPSECPolicy->ppIpsecNFAData[i]->NegPolIdentifier,
														 &(myIPSECPolicy->ppIpsecNFAData[i]->pIpsecNegPolData));
								  }
								  if (!UuidIsNil(&(myIPSECPolicy->ppIpsecNFAData[i]->FilterIdentifier), &RpcStat))
								  {
									  IPSecGetFilterData(myPolicyStorage,
										                 myIPSECPolicy->ppIpsecNFAData[i]->FilterIdentifier,
														 &(myIPSECPolicy->ppIpsecNFAData[i]->pIpsecFilterData));
								  }
							  }

							  if (myIPSECPolicy->pszDescription == NULL && szDescription != NULL)
							  {
								  // we've got description to set
								  myIPSECPolicy->pszDescription = IPSecAllocPolStr(szDescription);
							  }
							  // set Polling Interval
							  if (tPollingInterval >= 0)
							  {
							  	myIPSECPolicy->dwPollingInterval = (DWORD) tPollingInterval;
							  }
							  // commit
							  hrReturnCode = IPSecSetPolicyData(myPolicyStorage, myIPSECPolicy);
						  }
					  }
				  }
			  }
			  else
			  {
				  hrReturnCode = ERROR_SUCCESS;
			  }

			  // clean it up
			  if (dwNumPolicies > 0 && ppPolicyEnum != NULL)
			  {
				  IPSecFreeMulPolicyData(ppPolicyEnum, dwNumPolicies);
			  }
		  }

		  // this is executed only when no bUseExisting was specified or existing policy wasn't found
		  if (!bUseExisting || myIPSECPolicy == NULL)
		  {
			  // create
			  mybPolicyExists = false;
              myIPSECPolicy = (PIPSEC_POLICY_DATA) IPSecAllocPolMem(sizeof(IPSEC_POLICY_DATA));
			  if (myIPSECPolicy == NULL)
			  {
				  hrReturnCode = GetLastError();
			  }
			  else
			  {
				  myIPSECPolicy->pszIpsecName = IPSecAllocPolStr(szPolicyName);
				  if (szDescription)
				  {
					  myIPSECPolicy->pszDescription = IPSecAllocPolStr(szDescription);
				  }
				  else
				  {
					  myIPSECPolicy->pszDescription = NULL;
				  }
				  myIPSECPolicy->dwPollingInterval = (DWORD) tPollingInterval;
				  RpcStat = UuidCreate(&(myIPSECPolicy->PolicyIdentifier));
				  assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);

				  // now init other stuff somehow
				  myIPSECPolicy->pIpsecISAKMPData = NULL;
				  myIPSECPolicy->ppIpsecNFAData = NULL;
				  myIPSECPolicy->dwNumNFACount = 0;
				  myIPSECPolicy->dwWhenChanged = 0;
				  UuidCreateNil(&(myIPSECPolicy->ISAKMPIdentifier));

//				  TryToCreatePolicy();
			  }
		  }
	  }
   }

   return hrReturnCode;
}



HRESULT
IPSECPolicyToStorage::AddRule(
                              IN IPSEC_IKE_POLICY IpsecIkePol,
                              PSTORAGE_INFO   pStorageInfo)
{
   HRESULT hrReturn = S_OK;
   PIPSEC_NFA_DATA pRule = MakeRule(IpsecIkePol, pStorageInfo);
   int i;

   if (!IsOpen())
   {
	   return ERROR_ACCESS_DENIED;
   }
   // form policy data structures
   myIPSECPolicy->dwNumNFACount++;
   myIPSECPolicy->ppIpsecNFAData = (PIPSEC_NFA_DATA *) ReallocPolMem(myIPSECPolicy->ppIpsecNFAData
	                                                              , (myIPSECPolicy->dwNumNFACount-1)*sizeof(PIPSEC_NFA_DATA)
																  , (myIPSECPolicy->dwNumNFACount)*sizeof(PIPSEC_NFA_DATA));
   myIPSECPolicy->ppIpsecNFAData[myIPSECPolicy->dwNumNFACount-1] = pRule;

   // commit everything
   // start from qm policy
   if (!pRule->pIpsecFilterData)
   {
	   // fix up neg pol
	   pRule->pIpsecNegPolData->NegPolType = GUID_NEGOTIATION_TYPE_DEFAULT;
   }
   hrReturn = IPSecCreateNegPolData(myPolicyStorage, pRule->pIpsecNegPolData);
   if (hrReturn != ERROR_SUCCESS)
   {
	   return hrReturn;
   }

   // filter
   if (pRule->pIpsecFilterData)
   {
	   hrReturn = IPSecCreateFilterData(myPolicyStorage, pRule->pIpsecFilterData);
	   if (hrReturn != ERROR_SUCCESS)
	   {
		   return hrReturn;
	   }
   }

   // NFA
   IPSecCreateNFAData(myPolicyStorage, myIPSECPolicy->PolicyIdentifier, pRule);
   // policy
   if (IsPolicyInStorage())
   {
	   IPSecSetPolicyData(myPolicyStorage, myIPSECPolicy);
   }
   else
   {
	   TryToCreatePolicy();
   }

   return hrReturn;
}

// Add default response rule to the policy
HRESULT IPSECPolicyToStorage::AddDefaultResponseRule ( )
{
   HRESULT hrReturn = S_OK;
   PIPSEC_NFA_DATA pRule = MakeDefaultResponseRule();
   int i;

   if (!IsOpen())
   {
	   return ERROR_ACCESS_DENIED;
   }
   // form policy data structures
   myIPSECPolicy->dwNumNFACount++;
   myIPSECPolicy->ppIpsecNFAData = (PIPSEC_NFA_DATA *) ReallocPolMem(myIPSECPolicy->ppIpsecNFAData
	                                                              , (myIPSECPolicy->dwNumNFACount-1)*sizeof(PIPSEC_NFA_DATA)
																  , (myIPSECPolicy->dwNumNFACount)*sizeof(PIPSEC_NFA_DATA));
   myIPSECPolicy->ppIpsecNFAData[myIPSECPolicy->dwNumNFACount-1] = pRule;

   // commit everything
   // start from qm policy
   // fix up neg pol
   pRule->pIpsecNegPolData->NegPolType = GUID_NEGOTIATION_TYPE_DEFAULT;
   hrReturn = IPSecCreateNegPolData(myPolicyStorage, pRule->pIpsecNegPolData);
   if (hrReturn != ERROR_SUCCESS)
   {
	   return hrReturn;
   }

   // NFA
   IPSecCreateNFAData(myPolicyStorage, myIPSECPolicy->PolicyIdentifier, pRule);
   // policy
   if (IsPolicyInStorage())
   {
	   IPSecSetPolicyData(myPolicyStorage, myIPSECPolicy);
   }
   else
   {
	   TryToCreatePolicy();
   }

   return hrReturn;
}


// this will update a rule:
// if there are filters, all the filters from the current NFA
// are removed and the ones passed in are added
// same thing goes for negotiation policies and authinfos

HRESULT
IPSECPolicyToStorage::UpdateRule(
                        IN PIPSEC_NFA_DATA  pRule,
                        IN IPSEC_IKE_POLICY IpsecIkePol,
                        IN PSTORAGE_INFO    pStorageInfo)
{
   RPC_STATUS     RpcStat;
   T2P_FILTER    *pFilterList;
   IF_TYPE        Interface;
   WCHAR wszRuleName[POTF_MAX_STRLEN];
   HRESULT hrReturn = S_OK;
   int i;
   GUID oldFilter, oldNegPol;

   if (pRule == NULL || !IsOpen())
   {
	   return ERROR_ACCESS_DENIED;
   }

   // first, remove filter and policy data
   oldFilter = pRule->FilterIdentifier;
   if (pRule->pIpsecFilterData)
   {
	   IPSecFreeFilterData(pRule->pIpsecFilterData);
   }
   oldNegPol = pRule->NegPolIdentifier;
   if (pRule->pIpsecNegPolData)
   {
	   IPSecFreeNegPolData(pRule->pIpsecNegPolData);
   }
   // free auth methods
   if (pRule->ppAuthMethods)
   {
	   for (i = 0; i < (int) pRule->dwAuthMethodCount; i++)
	   {
		   if (pRule->ppAuthMethods[i]->pszAuthMethod)
		   {
			   IPSecFreePolMem(pRule->ppAuthMethods[i]->pszAuthMethod);
		   }
		   if (pRule->ppAuthMethods[i]->dwAltAuthLen && pRule->ppAuthMethods[i]->pAltAuthMethod)
		   {
			   IPSecFreePolMem(pRule->ppAuthMethods[i]->pAltAuthMethod);
		   }
		   IPSecFreePolMem(pRule->ppAuthMethods[i]);
	   }
   }
   IPSecFreePolMem(pRule->ppAuthMethods);
   // free strings
   if (pRule->pszIpsecName)
   {
	   IPSecFreePolStr(pRule->pszIpsecName);
   }
   if (pRule->pszInterfaceName)
   {
	   IPSecFreePolStr(pRule->pszInterfaceName);
   }
   if (pRule->pszEndPointName)
   {
	   IPSecFreePolStr(pRule->pszEndPointName);
   }
   if (pRule->pszDescription)
   {
	   IPSecFreePolStr(pRule->pszDescription);
   }

   // now make a rule
   pRule->pszIpsecName = pRule->pszDescription = pRule->pszInterfaceName = pRule->pszEndPointName = NULL;
   if (pStorageInfo)
   {
           pRule->pszIpsecName = IPSecAllocPolStr(pStorageInfo->szRuleName);
   }
   pRule->dwWhenChanged = 0;

   // filters
  	if (IpsecIkePol.QMFilterType == QM_TRANSPORT_FILTER
		&& IpsecIkePol.pTransportFilters[0].SrcAddr.AddrType == IP_ADDR_UNIQUE
		&& IpsecIkePol.pTransportFilters[0].SrcAddr.uIpAddr == IP_ADDRESS_ME
		&& IpsecIkePol.pTransportFilters[0].DesAddr.AddrType == IP_ADDR_UNIQUE
		&& IpsecIkePol.pTransportFilters[0].DesAddr.uIpAddr == IP_ADDRESS_ME
		&& IpsecIkePol.pTransportFilters[0].InboundFilterFlag == (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG
		&& IpsecIkePol.pTransportFilters[0].OutboundFilterFlag == (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG)
	{
		pRule->pIpsecFilterData = NULL;
		UuidCreateNil(&(pRule->FilterIdentifier));
	}
    else
	{
	   pFilterList = new T2P_FILTER[IpsecIkePol.dwNumFilters];
	   for (i = 0; i < (int) IpsecIkePol.dwNumFilters; i++)
	   {
		   if (IpsecIkePol.QMFilterType == QM_TRANSPORT_FILTER)
		   {
			   pFilterList[i].QMFilterType = QM_TRANSPORT_FILTER;
			   pFilterList[i].TransportFilter = IpsecIkePol.pTransportFilters[i];
		   }
		   else
		   {
			   // tunnel
			   pFilterList[i].QMFilterType = QM_TUNNEL_FILTER;
			   pFilterList[i].TunnelFilter = IpsecIkePol.pTunnelFilters[i];
		   }
	   }
	   if (pStorageInfo)
	   {
			   pRule->pIpsecFilterData = MakeFilters(pFilterList, IpsecIkePol.dwNumFilters, pStorageInfo->szRuleName);
	   }
	   else
	   {
			   pRule->pIpsecFilterData = MakeFilters(pFilterList, IpsecIkePol.dwNumFilters, L"");
	   }
	   pRule->FilterIdentifier = pRule->pIpsecFilterData->FilterIdentifier;
	   delete[] pFilterList;
	}

   // filter action
   if (pStorageInfo)
   {
           pRule->pIpsecNegPolData = MakeNegotiationPolicy(IpsecIkePol.IpsPol, pStorageInfo->szRuleName);
   }
   else
   {
           pRule->pIpsecNegPolData = MakeNegotiationPolicy(IpsecIkePol.IpsPol, L"");
   }
   pRule->NegPolIdentifier = pRule->pIpsecNegPolData->NegPolIdentifier;
   if (pStorageInfo && pStorageInfo->guidNegPolAction != GUID_NEGOTIATION_ACTION_NORMAL_IPSEC)
   {
	   pRule->pIpsecNegPolData->NegPolAction = pStorageInfo->guidNegPolAction;
   }

   // tunnel address
   pRule->dwTunnelFlags = 0;
   if (IpsecIkePol.QMFilterType == QM_TUNNEL_FILTER)
   {
	   pRule->dwTunnelFlags = 1;
	   pRule->dwTunnelIpAddr = IpsecIkePol.pTunnelFilters[0].DesTunnelAddr.uIpAddr;
   }

   // interface type
   Interface = (IpsecIkePol.QMFilterType == QM_TRANSPORT_FILTER) ? IpsecIkePol.pTransportFilters[0].InterfaceType : IpsecIkePol.pTunnelFilters[0].InterfaceType;
   if (Interface == INTERFACE_TYPE_ALL)
   {
	   pRule->dwInterfaceType = PAS_INTERFACE_TYPE_ALL;
   }
   else if (Interface == INTERFACE_TYPE_LAN)
   {
	   pRule->dwInterfaceType = PAS_INTERFACE_TYPE_LAN;
   }
   else if (Interface == INTERFACE_TYPE_DIALUP)
   {
	   pRule->dwInterfaceType = PAS_INTERFACE_TYPE_DIALUP;
   }
   else
   {
	   pRule->dwInterfaceType = PAS_INTERFACE_TYPE_NONE;
   }

   // active flag
   pRule->dwActiveFlag = TRUE;

   // auth methods
   pRule->dwAuthMethodCount = IpsecIkePol.AuthInfos.dwNumAuthInfos;
   pRule->ppAuthMethods = (PIPSEC_AUTH_METHOD *) IPSecAllocPolMem(pRule->dwAuthMethodCount * sizeof(PIPSEC_AUTH_METHOD));
   for (i = 0; i < (int) pRule->dwAuthMethodCount; i++)
   {
	   pRule->ppAuthMethods[i] = (PIPSEC_AUTH_METHOD) IPSecAllocPolMem(sizeof(IPSEC_AUTH_METHOD));
	   pRule->ppAuthMethods[i]->dwAuthType = IpsecIkePol.AuthInfos.pAuthenticationInfo[i].AuthMethod;
	   if (pRule->ppAuthMethods[i]->dwAuthType == IKE_SSPI)
	   {
		   pRule->ppAuthMethods[i]->dwAuthLen = 0;
		   pRule->ppAuthMethods[i]->pszAuthMethod = NULL;
		   pRule->ppAuthMethods[i]->dwAltAuthLen = 0;
		   pRule->ppAuthMethods[i]->pAltAuthMethod = 0;
	   }
	   else if (pRule->ppAuthMethods[i]->dwAuthType == IKE_RSA_SIGNATURE)
	   {
		   LPTSTR pTemp = NULL;
		   pRule->ppAuthMethods[i]->dwAltAuthLen = IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize;
		   pRule->ppAuthMethods[i]->pAltAuthMethod = (PBYTE) IPSecAllocPolMem(IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize);
		   memcpy(pRule->ppAuthMethods[i]->pAltAuthMethod, IpsecIkePol.AuthInfos.pAuthenticationInfo[i].pAuthInfo, IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize);

		   hrReturn = CM_DecodeName(pRule->ppAuthMethods[i]->pAltAuthMethod, pRule->ppAuthMethods[i]->dwAltAuthLen, &pTemp);
		   assert(hrReturn == ERROR_SUCCESS);
		   pRule->ppAuthMethods[i]->pszAuthMethod = IPSecAllocPolStr(pTemp);
		   pRule->ppAuthMethods[i]->dwAuthLen = wcslen(pRule->ppAuthMethods[i]->pszAuthMethod);
		   delete[] pTemp;
	   }
	   else
	   {
		   pRule->ppAuthMethods[i]->dwAuthLen = IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize / sizeof(WCHAR);
		   pRule->ppAuthMethods[i]->pszAuthMethod = (LPWSTR) IPSecAllocPolMem(IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize + sizeof(WCHAR));
		   memcpy(pRule->ppAuthMethods[i]->pszAuthMethod, IpsecIkePol.AuthInfos.pAuthenticationInfo[i].pAuthInfo, IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize);
		   // add trailing '\0' - this is requirement for the polstore
	       pRule->ppAuthMethods[i]->pszAuthMethod[pRule->ppAuthMethods[i]->dwAuthLen] = 0;

		   pRule->ppAuthMethods[i]->dwAltAuthLen = 0;
		   pRule->ppAuthMethods[i]->pAltAuthMethod = 0;
	   }
   }

   // plumb it
   if (!pRule->pIpsecFilterData)
   {
	   // fix up neg pol
	   pRule->pIpsecNegPolData->NegPolType = GUID_NEGOTIATION_TYPE_DEFAULT;
   }
   hrReturn = IPSecCreateNegPolData(myPolicyStorage, pRule->pIpsecNegPolData);
   if (hrReturn != ERROR_SUCCESS)
   {
	   return hrReturn;
   }

   // filter
   if (pRule->pIpsecFilterData)
   {
	   hrReturn = IPSecCreateFilterData(myPolicyStorage, pRule->pIpsecFilterData);
	   if (hrReturn != ERROR_SUCCESS)
	   {
		   return hrReturn;
	   }
   }

   // NFA
   IPSecSetNFAData(myPolicyStorage, myIPSECPolicy->PolicyIdentifier, pRule);
   // policy
   if (IsPolicyInStorage())
   {
	   IPSecSetPolicyData(myPolicyStorage, myIPSECPolicy);
   }
   else
   {
	   TryToCreatePolicy();
   }

   if (!UuidIsNil(&oldFilter, &RpcStat))
   {
		IPSecDeleteFilterData(myPolicyStorage, oldFilter);
   }
   IPSecDeleteNegPolData(myPolicyStorage, oldNegPol);
   return hrReturn;
}

// forms a rule but doesn't commit it
PIPSEC_NFA_DATA
IPSECPolicyToStorage::MakeRule(IN IPSEC_IKE_POLICY IpsecIkePol, IN PSTORAGE_INFO pStorageInfo)
{
   RPC_STATUS     RpcStat;
   T2P_FILTER    *pFilterList;
   IF_TYPE        Interface;
   int i;
   WCHAR wszRuleName[POTF_MAX_STRLEN];
   PIPSEC_NFA_DATA pRule = (PIPSEC_NFA_DATA) IPSecAllocPolMem(sizeof(IPSEC_NFA_DATA));
   HRESULT hrReturn = S_OK;

   assert(pRule);
   pRule->pszIpsecName = pRule->pszDescription = pRule->pszInterfaceName = pRule->pszEndPointName = NULL;
   if (pStorageInfo)
   {
           pRule->pszIpsecName = IPSecAllocPolStr(pStorageInfo->szRuleName);
   }
   RpcStat = UuidCreate(&(pRule->NFAIdentifier));
   assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);
   pRule->dwWhenChanged = 0;

   // filters
  	if (IpsecIkePol.QMFilterType == QM_TRANSPORT_FILTER
		&& IpsecIkePol.pTransportFilters[0].SrcAddr.AddrType == IP_ADDR_UNIQUE
		&& IpsecIkePol.pTransportFilters[0].SrcAddr.uIpAddr == IP_ADDRESS_ME
		&& IpsecIkePol.pTransportFilters[0].DesAddr.AddrType == IP_ADDR_UNIQUE
		&& IpsecIkePol.pTransportFilters[0].DesAddr.uIpAddr == IP_ADDRESS_ME
		&& IpsecIkePol.pTransportFilters[0].InboundFilterFlag == (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG
		&& IpsecIkePol.pTransportFilters[0].OutboundFilterFlag == (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG)
	{
		pRule->pIpsecFilterData = NULL;
		UuidCreateNil(&(pRule->FilterIdentifier));
	}
    else
	{
	   pFilterList = new T2P_FILTER[IpsecIkePol.dwNumFilters];
	   for (i = 0; i < (int) IpsecIkePol.dwNumFilters; i++)
	   {
		   if (IpsecIkePol.QMFilterType == QM_TRANSPORT_FILTER)
		   {
			   pFilterList[i].QMFilterType = QM_TRANSPORT_FILTER;
			   pFilterList[i].TransportFilter = IpsecIkePol.pTransportFilters[i];
		   }
		   else
		   {
			   // tunnel
			   pFilterList[i].QMFilterType = QM_TUNNEL_FILTER;
			   pFilterList[i].TunnelFilter = IpsecIkePol.pTunnelFilters[i];
		   }
	   }
	   if (pStorageInfo)
	   {
			   pRule->pIpsecFilterData = MakeFilters(pFilterList, IpsecIkePol.dwNumFilters, pStorageInfo->szRuleName);
	   }
	   else
	   {
			   pRule->pIpsecFilterData = MakeFilters(pFilterList, IpsecIkePol.dwNumFilters, L"");
	   }
	   pRule->FilterIdentifier = pRule->pIpsecFilterData->FilterIdentifier;
	   delete[] pFilterList;
	}

   // filter action
   if (pStorageInfo)
   {
           pRule->pIpsecNegPolData = MakeNegotiationPolicy(IpsecIkePol.IpsPol, pStorageInfo->szRuleName);
   }
   else
   {
           pRule->pIpsecNegPolData = MakeNegotiationPolicy(IpsecIkePol.IpsPol, L"");
   }
   pRule->NegPolIdentifier = pRule->pIpsecNegPolData->NegPolIdentifier;
   if (pStorageInfo && pStorageInfo->guidNegPolAction != GUID_NEGOTIATION_ACTION_NORMAL_IPSEC)
   {
	   pRule->pIpsecNegPolData->NegPolAction = pStorageInfo->guidNegPolAction;
   }

   // tunnel address
   pRule->dwTunnelFlags = 0;
   if (IpsecIkePol.QMFilterType == QM_TUNNEL_FILTER)
   {
	   pRule->dwTunnelFlags = 1;
	   pRule->dwTunnelIpAddr = IpsecIkePol.pTunnelFilters[0].DesTunnelAddr.uIpAddr;
   }

   // interface type
   Interface = (IpsecIkePol.QMFilterType == QM_TRANSPORT_FILTER) ? IpsecIkePol.pTransportFilters[0].InterfaceType : IpsecIkePol.pTunnelFilters[0].InterfaceType;
   if (Interface == INTERFACE_TYPE_ALL)
   {
	   pRule->dwInterfaceType = PAS_INTERFACE_TYPE_ALL;
   }
   else if (Interface == INTERFACE_TYPE_LAN)
   {
	   pRule->dwInterfaceType = PAS_INTERFACE_TYPE_LAN;
   }
   else if (Interface == INTERFACE_TYPE_DIALUP)
   {
	   pRule->dwInterfaceType = PAS_INTERFACE_TYPE_DIALUP;
   }
   else
   {
	   pRule->dwInterfaceType = PAS_INTERFACE_TYPE_NONE;
   }

   // active flag
   pRule->dwActiveFlag = TRUE;

   // auth methods
   pRule->dwAuthMethodCount = IpsecIkePol.AuthInfos.dwNumAuthInfos;
   pRule->ppAuthMethods = (PIPSEC_AUTH_METHOD *) IPSecAllocPolMem(pRule->dwAuthMethodCount * sizeof(PIPSEC_AUTH_METHOD));
   for (i = 0; i < (int) pRule->dwAuthMethodCount; i++)
   {
	   pRule->ppAuthMethods[i] = (PIPSEC_AUTH_METHOD) IPSecAllocPolMem(sizeof(IPSEC_AUTH_METHOD));
	   pRule->ppAuthMethods[i]->dwAuthType = IpsecIkePol.AuthInfos.pAuthenticationInfo[i].AuthMethod;
	   if (pRule->ppAuthMethods[i]->dwAuthType == IKE_SSPI)
	   {
		   pRule->ppAuthMethods[i]->dwAuthLen = 0;
		   pRule->ppAuthMethods[i]->pszAuthMethod = NULL;
		   pRule->ppAuthMethods[i]->dwAltAuthLen = 0;
		   pRule->ppAuthMethods[i]->pAltAuthMethod = 0;
	   }
	   else if (pRule->ppAuthMethods[i]->dwAuthType == IKE_RSA_SIGNATURE)
	   {
		   LPTSTR pTemp = NULL;
		   pRule->ppAuthMethods[i]->dwAltAuthLen = IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize;
		   pRule->ppAuthMethods[i]->pAltAuthMethod = (PBYTE) IPSecAllocPolMem(IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize);
		   memcpy(pRule->ppAuthMethods[i]->pAltAuthMethod, IpsecIkePol.AuthInfos.pAuthenticationInfo[i].pAuthInfo, IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize);

		   hrReturn = CM_DecodeName(pRule->ppAuthMethods[i]->pAltAuthMethod, pRule->ppAuthMethods[i]->dwAltAuthLen, &pTemp);
		   assert(hrReturn == ERROR_SUCCESS);
		   pRule->ppAuthMethods[i]->pszAuthMethod = IPSecAllocPolStr(pTemp);
		   pRule->ppAuthMethods[i]->dwAuthLen = wcslen(pRule->ppAuthMethods[i]->pszAuthMethod);
		   delete[] pTemp;
	   }
	   else
	   {
		   pRule->ppAuthMethods[i]->dwAuthLen = IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize / sizeof(WCHAR);
		   pRule->ppAuthMethods[i]->pszAuthMethod = (LPWSTR) IPSecAllocPolMem(IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize + sizeof(WCHAR));
		   memcpy(pRule->ppAuthMethods[i]->pszAuthMethod, IpsecIkePol.AuthInfos.pAuthenticationInfo[i].pAuthInfo, IpsecIkePol.AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize);
		   // add trailing '\0' - this is requirement for the polstore
	       pRule->ppAuthMethods[i]->pszAuthMethod[pRule->ppAuthMethods[i]->dwAuthLen] = 0;

		   pRule->ppAuthMethods[i]->dwAltAuthLen = 0;
		   pRule->ppAuthMethods[i]->pAltAuthMethod = 0;
	   }
   }

   return pRule;
}

// does not commit it to the storage
// it is assumed that action is NEGOTIATE_SECURITY. If that's not true, it'll be corrected in MakeRule call
// Soft SA flag is handled here
PIPSEC_NEGPOL_DATA
IPSECPolicyToStorage::MakeNegotiationPolicy(IPSEC_QM_POLICY IpsPol,
                                            LPWSTR Name)
{
   RPC_STATUS RpcStat;
   int i;
   PIPSEC_NEGPOL_DATA pNegPol = (PIPSEC_NEGPOL_DATA) IPSecAllocPolMem(sizeof(IPSEC_NEGPOL_DATA));
   BOOL bPFS = FALSE;
   WCHAR pFAName[POTF_MAX_STRLEN];

   RpcStat = UuidCreate(&(pNegPol->NegPolIdentifier));
   assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);
   pNegPol->NegPolAction = GUID_NEGOTIATION_ACTION_NORMAL_IPSEC;
   pNegPol->NegPolType = GUID_NEGOTIATION_TYPE_STANDARD;
   pNegPol->dwSecurityMethodCount = IpsPol.dwOfferCount;
   if (IpsPol.dwFlags & IPSEC_QM_POLICY_ALLOW_SOFT)
   {
	   // we need to add one more offer with no security algorithms
       pNegPol->dwSecurityMethodCount++;
   }

   // allocate sec.methods
   pNegPol->pIpsecSecurityMethods = (IPSEC_SECURITY_METHOD *) IPSecAllocPolMem(pNegPol->dwSecurityMethodCount * sizeof(IPSEC_SECURITY_METHOD));
   // fix up PFS, in storage it is the property of the filter action, not individual offer
   for (i = 0; i < (int) IpsPol.dwOfferCount; i++)
   {
      if (IpsPol.pOffers[i].bPFSRequired)
      {
         bPFS = TRUE;
      }
   }

   // handle sec.methods
   for (i = 0; i < (int) IpsPol.dwOfferCount; i++)
   {
	   int j;

	   pNegPol->pIpsecSecurityMethods[i].Lifetime.KeyExpirationBytes = IpsPol.pOffers[i].Lifetime.uKeyExpirationKBytes;
	   pNegPol->pIpsecSecurityMethods[i].Lifetime.KeyExpirationTime = IpsPol.pOffers[i].Lifetime.uKeyExpirationTime;
       pNegPol->pIpsecSecurityMethods[i].Flags = 0;
	   pNegPol->pIpsecSecurityMethods[i].PfsQMRequired = bPFS;
	   pNegPol->pIpsecSecurityMethods[i].Count = IpsPol.pOffers[i].dwNumAlgos;
	   for (j = 0; j < (int) pNegPol->pIpsecSecurityMethods[i].Count && j < QM_MAX_ALGOS; j++)
	   {
		   pNegPol->pIpsecSecurityMethods[i].Algos[j].algoIdentifier = IpsPol.pOffers[i].Algos[j].uAlgoIdentifier;
		   pNegPol->pIpsecSecurityMethods[i].Algos[j].secondaryAlgoIdentifier = IpsPol.pOffers[i].Algos[j].uSecAlgoIdentifier;
		   pNegPol->pIpsecSecurityMethods[i].Algos[j].algoKeylen = IpsPol.pOffers[i].Algos[j].uAlgoKeyLen;
		   pNegPol->pIpsecSecurityMethods[i].Algos[j].algoRounds = IpsPol.pOffers[i].Algos[j].uAlgoRounds;
		   switch (IpsPol.pOffers[i].Algos[j].Operation)
		   {
				case AUTHENTICATION:
					pNegPol->pIpsecSecurityMethods[i].Algos[j].operation = Auth;
					break;
				case ENCRYPTION:
					pNegPol->pIpsecSecurityMethods[i].Algos[j].operation = Encrypt;
					break;
				default:
					pNegPol->pIpsecSecurityMethods[i].Algos[j].operation = None;
		   }
	   }
   }
   // add soft
   if (IpsPol.dwFlags & IPSEC_QM_POLICY_ALLOW_SOFT)
   {
	   // set Count (and everything) to 0
	   memset(&(pNegPol->pIpsecSecurityMethods[pNegPol->dwSecurityMethodCount - 1]), 0, sizeof(IPSEC_SECURITY_METHOD));
   }

   // name
   swprintf(pFAName, TEXT("%s filter action"), Name);
   pNegPol->pszIpsecName = IPSecAllocPolStr(pFAName);
   pNegPol->pszDescription = NULL;
   return pNegPol;
}


PIPSEC_FILTER_DATA
IPSECPolicyToStorage::MakeFilters(
                                 T2P_FILTER *Filters,
                                 UINT NumFilters,
                                 LPWSTR Name)
{
   RPC_STATUS     RpcStat;
   PIPSEC_FILTER_DATA pFilter = (PIPSEC_FILTER_DATA) IPSecAllocPolMem(sizeof(IPSEC_FILTER_DATA));
   int i;
   WCHAR pFLName[POTF_MAX_STRLEN];

   RpcStat = UuidCreate(&(pFilter->FilterIdentifier));
   assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);

   pFilter->dwNumFilterSpecs = NumFilters;
   pFilter->ppFilterSpecs = (PIPSEC_FILTER_SPEC *) IPSecAllocPolMem(NumFilters*sizeof(PIPSEC_FILTER_SPEC));
   assert(pFilter->ppFilterSpecs);

   for (i = 0; i < (int) NumFilters; i++)
   {
       pFilter->ppFilterSpecs[i] = (PIPSEC_FILTER_SPEC) IPSecAllocPolMem(sizeof(IPSEC_FILTER_SPEC));
	   assert(pFilter->ppFilterSpecs[i]);
	   ConvertFilter(Filters[i], *(pFilter->ppFilterSpecs[i]));
   }

   pFilter->dwWhenChanged = 0;
   swprintf(pFLName, TEXT("%s filter list"), Name);
   pFilter->pszIpsecName = IPSecAllocPolStr(pFLName);
   pFilter->pszDescription = NULL;

   return pFilter;
}

HRESULT
IPSECPolicyToStorage::SetISAKMPPolicy(IPSEC_MM_POLICY IkePol)
{
   HRESULT hrReturn = S_OK;
   RPC_STATUS RpcStat;
   GUID oldISAKMP;
   int i;

   if (!IsOpen())
   {
	   return ERROR_ACCESS_DENIED;
   }

   oldISAKMP = myIPSECPolicy->ISAKMPIdentifier;
   if (myIPSECPolicy->pIpsecISAKMPData)
   {
	   IPSecFreeISAKMPData(myIPSECPolicy->pIpsecISAKMPData);
   }

   RpcStat = UuidCreate(&(myIPSECPolicy->ISAKMPIdentifier));
   assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);

   myIPSECPolicy->pIpsecISAKMPData = (PIPSEC_ISAKMP_DATA) IPSecAllocPolMem(sizeof(IPSEC_ISAKMP_DATA));

   myIPSECPolicy->pIpsecISAKMPData->ISAKMPIdentifier = myIPSECPolicy->ISAKMPIdentifier;
   myIPSECPolicy->pIpsecISAKMPData->dwWhenChanged = 0;

   // sec methods stuff
   myIPSECPolicy->pIpsecISAKMPData->dwNumISAKMPSecurityMethods = IkePol.dwOfferCount;
   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods = (PCRYPTO_BUNDLE) IPSecAllocPolMem(sizeof(CRYPTO_BUNDLE)*IkePol.dwOfferCount);
   for (i = 0; i < (int) IkePol.dwOfferCount; i++)
   {
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].MajorVersion = 0;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].MinorVersion = 0;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].AuthenticationMethod = 0;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].PseudoRandomFunction.AlgorithmIdentifier = 0;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].PseudoRandomFunction.KeySize = 0;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].PseudoRandomFunction.Rounds = 0;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].PfsIdentityRequired = (IkePol.pOffers[i].dwQuickModeLimit == 1);
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].EncryptionAlgorithm.AlgorithmIdentifier = IkePol.pOffers[i].EncryptionAlgorithm.uAlgoIdentifier;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].EncryptionAlgorithm.KeySize = IkePol.pOffers[i].EncryptionAlgorithm.uAlgoKeyLen;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].EncryptionAlgorithm.Rounds = IkePol.pOffers[i].EncryptionAlgorithm.uAlgoRounds;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].HashAlgorithm.AlgorithmIdentifier = IkePol.pOffers[i].HashingAlgorithm.uAlgoIdentifier;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].HashAlgorithm.KeySize = IkePol.pOffers[i].HashingAlgorithm.uAlgoKeyLen;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].HashAlgorithm.Rounds = IkePol.pOffers[i].HashingAlgorithm.uAlgoRounds;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].OakleyGroup = IkePol.pOffers[i].dwDHGroup;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].QuickModeLimit = IkePol.pOffers[i].dwQuickModeLimit;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].Lifetime.KBytes = IkePol.pOffers[i].Lifetime.uKeyExpirationKBytes;
	   myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[i].Lifetime.Seconds = IkePol.pOffers[i].Lifetime.uKeyExpirationTime;
   }

   // now for other stuff - ISAKMPPolicy
   myIPSECPolicy->pIpsecISAKMPData->ISAKMPPolicy.PolicyId = myIPSECPolicy->ISAKMPIdentifier;
   myIPSECPolicy->pIpsecISAKMPData->ISAKMPPolicy.IdentityProtectionRequired = 0;
   myIPSECPolicy->pIpsecISAKMPData->ISAKMPPolicy.PfsIdentityRequired = myIPSECPolicy->pIpsecISAKMPData->pSecurityMethods[0].PfsIdentityRequired;

   // save it
   hrReturn = IPSecCreateISAKMPData(myPolicyStorage, myIPSECPolicy->pIpsecISAKMPData);
   if (hrReturn != ERROR_SUCCESS)
   {
	   return hrReturn;
   }

   if (IsPolicyInStorage())
   {
	   IPSecSetPolicyData(myPolicyStorage, myIPSECPolicy);
   }
   else
   {
	   TryToCreatePolicy();
   }

   IPSecDeleteISAKMPData(myPolicyStorage, oldISAKMP);

   return ERROR_SUCCESS;
}

LPVOID
IPSECPolicyToStorage::ReallocPolMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=IPSecAllocPolMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        IPSecFreePolMem(pOldMem);
    }

    return pNewMem;
}

// forms a rule but doesn't commit it
// forms default response rule
PIPSEC_NFA_DATA
IPSECPolicyToStorage::MakeDefaultResponseRule ()
{
   RPC_STATUS     RpcStat;
   PIPSEC_NFA_DATA pRule = (PIPSEC_NFA_DATA) IPSecAllocPolMem(sizeof(IPSEC_NFA_DATA));

   assert(pRule);
   pRule->pszIpsecName = pRule->pszDescription = pRule->pszInterfaceName = pRule->pszEndPointName = NULL;
   RpcStat = UuidCreate(&(pRule->NFAIdentifier));
   assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);
   pRule->dwWhenChanged = 0;

   // filter list
   pRule->pIpsecFilterData = NULL;
   UuidCreateNil(&(pRule->FilterIdentifier));

   // filter action
   pRule->pIpsecNegPolData = MakeDefaultResponseNegotiationPolicy ();

   pRule->NegPolIdentifier = pRule->pIpsecNegPolData->NegPolIdentifier;

   // tunnel address
   pRule->dwTunnelFlags = 0;

   // interface type
   pRule->dwInterfaceType = PAS_INTERFACE_TYPE_ALL;

   // active flag
   pRule->dwActiveFlag = FALSE;

   // auth methods
   pRule->dwAuthMethodCount = 1;
   pRule->ppAuthMethods = (PIPSEC_AUTH_METHOD *) IPSecAllocPolMem(pRule->dwAuthMethodCount * sizeof(PIPSEC_AUTH_METHOD));
   assert(pRule->ppAuthMethods);
   pRule->ppAuthMethods[0] = (PIPSEC_AUTH_METHOD) IPSecAllocPolMem(sizeof(IPSEC_AUTH_METHOD));
   pRule->ppAuthMethods[0]->dwAuthType = IKE_SSPI;
   pRule->ppAuthMethods[0]->dwAuthLen = 0;
   pRule->ppAuthMethods[0]->pszAuthMethod = NULL;

   return pRule;
}

// does not commit it to the storage
PIPSEC_NEGPOL_DATA
IPSECPolicyToStorage::MakeDefaultResponseNegotiationPolicy ( )
{
   RPC_STATUS RpcStat;
   int i;
   PIPSEC_NEGPOL_DATA pNegPol = (PIPSEC_NEGPOL_DATA) IPSecAllocPolMem(sizeof(IPSEC_NEGPOL_DATA));
   WCHAR pFAName[POTF_MAX_STRLEN];

   RpcStat = UuidCreate(&(pNegPol->NegPolIdentifier));
   assert(RpcStat == RPC_S_OK || RpcStat == RPC_S_UUID_LOCAL_ONLY);
   pNegPol->NegPolAction = GUID_NEGOTIATION_ACTION_NORMAL_IPSEC;
   pNegPol->NegPolType = GUID_NEGOTIATION_TYPE_DEFAULT;
   pNegPol->dwSecurityMethodCount = 6;

   // allocate sec.methods
   pNegPol->pIpsecSecurityMethods = (IPSEC_SECURITY_METHOD *) IPSecAllocPolMem(pNegPol->dwSecurityMethodCount * sizeof(IPSEC_SECURITY_METHOD));

   // method 0 - ESP[3DES, SHA1]
   pNegPol->pIpsecSecurityMethods[0].Lifetime.KeyExpirationBytes = 0;
   pNegPol->pIpsecSecurityMethods[0].Lifetime.KeyExpirationTime = 0;
   pNegPol->pIpsecSecurityMethods[0].Flags = 0;
   pNegPol->pIpsecSecurityMethods[0].PfsQMRequired = FALSE;
   pNegPol->pIpsecSecurityMethods[0].Count = 1;
   pNegPol->pIpsecSecurityMethods[0].Algos[0].algoIdentifier = IPSEC_DOI_ESP_3_DES;
   pNegPol->pIpsecSecurityMethods[0].Algos[0].secondaryAlgoIdentifier = IPSEC_DOI_AH_SHA1;
   pNegPol->pIpsecSecurityMethods[0].Algos[0].algoKeylen = 0;
   pNegPol->pIpsecSecurityMethods[0].Algos[0].algoRounds = 0;
   pNegPol->pIpsecSecurityMethods[0].Algos[0].operation = Encrypt;

   // method 1 - ESP[3DES, MD5]
   pNegPol->pIpsecSecurityMethods[1].Lifetime.KeyExpirationBytes = 0;
   pNegPol->pIpsecSecurityMethods[1].Lifetime.KeyExpirationTime = 0;
   pNegPol->pIpsecSecurityMethods[1].Flags = 0;
   pNegPol->pIpsecSecurityMethods[1].PfsQMRequired = FALSE;
   pNegPol->pIpsecSecurityMethods[1].Count = 1;
   pNegPol->pIpsecSecurityMethods[1].Algos[0].algoIdentifier = IPSEC_DOI_ESP_3_DES;
   pNegPol->pIpsecSecurityMethods[1].Algos[0].secondaryAlgoIdentifier = IPSEC_DOI_AH_MD5;
   pNegPol->pIpsecSecurityMethods[1].Algos[0].algoKeylen = 0;
   pNegPol->pIpsecSecurityMethods[1].Algos[0].algoRounds = 0;
   pNegPol->pIpsecSecurityMethods[1].Algos[0].operation = Encrypt;

   // method 2 - ESP[DES, SHA1]
   pNegPol->pIpsecSecurityMethods[2].Lifetime.KeyExpirationBytes = 0;
   pNegPol->pIpsecSecurityMethods[2].Lifetime.KeyExpirationTime = 0;
   pNegPol->pIpsecSecurityMethods[2].Flags = 0;
   pNegPol->pIpsecSecurityMethods[2].PfsQMRequired = FALSE;
   pNegPol->pIpsecSecurityMethods[2].Count = 1;
   pNegPol->pIpsecSecurityMethods[2].Algos[0].algoIdentifier = IPSEC_DOI_ESP_DES;
   pNegPol->pIpsecSecurityMethods[2].Algos[0].secondaryAlgoIdentifier = IPSEC_DOI_AH_SHA1;
   pNegPol->pIpsecSecurityMethods[2].Algos[0].algoKeylen = 0;
   pNegPol->pIpsecSecurityMethods[2].Algos[0].algoRounds = 0;
   pNegPol->pIpsecSecurityMethods[2].Algos[0].operation = Encrypt;

   // method 3 - ESP[DES, MD5]
   pNegPol->pIpsecSecurityMethods[3].Lifetime.KeyExpirationBytes = 0;
   pNegPol->pIpsecSecurityMethods[3].Lifetime.KeyExpirationTime = 0;
   pNegPol->pIpsecSecurityMethods[3].Flags = 0;
   pNegPol->pIpsecSecurityMethods[3].PfsQMRequired = FALSE;
   pNegPol->pIpsecSecurityMethods[3].Count = 1;
   pNegPol->pIpsecSecurityMethods[3].Algos[0].algoIdentifier = IPSEC_DOI_ESP_DES;
   pNegPol->pIpsecSecurityMethods[3].Algos[0].secondaryAlgoIdentifier = IPSEC_DOI_AH_MD5;
   pNegPol->pIpsecSecurityMethods[3].Algos[0].algoKeylen = 0;
   pNegPol->pIpsecSecurityMethods[3].Algos[0].algoRounds = 0;
   pNegPol->pIpsecSecurityMethods[3].Algos[0].operation = Encrypt;

   // method 4 - AH[SHA1]
   pNegPol->pIpsecSecurityMethods[4].Lifetime.KeyExpirationBytes = 0;
   pNegPol->pIpsecSecurityMethods[4].Lifetime.KeyExpirationTime = 0;
   pNegPol->pIpsecSecurityMethods[4].Flags = 0;
   pNegPol->pIpsecSecurityMethods[4].PfsQMRequired = FALSE;
   pNegPol->pIpsecSecurityMethods[4].Count = 1;
   pNegPol->pIpsecSecurityMethods[4].Algos[0].algoIdentifier = IPSEC_DOI_AH_SHA1;
   pNegPol->pIpsecSecurityMethods[4].Algos[0].secondaryAlgoIdentifier = IPSEC_DOI_AH_NONE;
   pNegPol->pIpsecSecurityMethods[4].Algos[0].algoKeylen = 0;
   pNegPol->pIpsecSecurityMethods[4].Algos[0].algoRounds = 0;
   pNegPol->pIpsecSecurityMethods[4].Algos[0].operation = Auth;

   // method 5 - AH[MD5]
   pNegPol->pIpsecSecurityMethods[5].Lifetime.KeyExpirationBytes = 0;
   pNegPol->pIpsecSecurityMethods[5].Lifetime.KeyExpirationTime = 0;
   pNegPol->pIpsecSecurityMethods[5].Flags = 0;
   pNegPol->pIpsecSecurityMethods[5].PfsQMRequired = FALSE;
   pNegPol->pIpsecSecurityMethods[5].Count = 1;
   pNegPol->pIpsecSecurityMethods[5].Algos[0].algoIdentifier = IPSEC_DOI_AH_MD5;
   pNegPol->pIpsecSecurityMethods[5].Algos[0].secondaryAlgoIdentifier = IPSEC_DOI_AH_NONE;
   pNegPol->pIpsecSecurityMethods[5].Algos[0].algoKeylen = 0;
   pNegPol->pIpsecSecurityMethods[5].Algos[0].algoRounds = 0;
   pNegPol->pIpsecSecurityMethods[5].Algos[0].operation = Auth;

   // name
   swprintf(pFAName, TEXT(""));
   pNegPol->pszIpsecName = IPSecAllocPolStr(pFAName);
   pNegPol->pszDescription = NULL;
   return pNegPol;
}

#ifdef __cplusplus
   }
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\ipseccmd.h ===
/////////////////////////////////////////////////////////////
// Copyright(c) 1998, Microsoft Corporation
//
// ipseccmd.h
//
// Created on 4/5/98 by Randyram
// Revisions:
//
// Includes all the necessary header files and definitions
// for the policy automation tool.
//
/////////////////////////////////////////////////////////////

#ifndef _IPSECCMD_H_
#define _IPSECCMD_H_

#include <windows.h>
#include <tchar.h>
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <assert.h>
#include <limits.h>
#include <objbase.h>
#include <ipexport.h>
#include <time.h>
#include "t2pmsgs.h"

extern "C" {

#include <dsgetdc.h>
#include <lm.h>
#include <rpc.h>
#include <winldap.h>
#include <time.h>
#include "winipsec.h"
#include <ipsec.h>
#include <oakdefs.h>
#include "polstore2.h"
}


// my includes

#include "text2pol.h"
#include "pol2stor.h"
#include "usepa.h"
#include "print.h"
#include "query.h"
#include "externs.h"

// my constants
#define IPSECCMD_USAGE  (-1)


// used for printing in PrintFilter
#define DebugPrint(X)   _tprintf(TEXT("%s\n"),X)

// this is for calling HrSetActivePolicy explicitly
typedef HRESULT (*LPHRSETACTIVEPOLICY)(GUID *);

const char  POTF_VERSION[]       = "v1.51 Copyright(c) 1998-2001, Microsoft Corporation";

// XX todo: make these real hresults
const HRESULT  POTF_NO_FILTERS            = 0x80001102;
const HRESULT  POTF_STORAGE_OPEN_FAILED   = 0x80001103;

const BSTR  POTF_DEFAULT_POLNAME      = L"ipseccmd";


// sleep time to wait for PA RPC to come up, in milliseconds
const UINT  POTF_PARPC_SLEEPTIME = 60000;

// starting GUID for policies
// {fa56f258-f6ac-11d1-92a3-0000f806bfbc}
const GUID  POTF_START_GUID = {
   0xfa56f258, // Data1
   0xf6ac,     // Data2
   0x0,        // Data3 for our own use
   {
      // Data4
      0x92, 0xa3, 0x0, 0x0, 0xf8, 0x06, 0xbf, 0xbc
   }
};
const unsigned short MAX_GUID_DATA3 = USHRT_MAX;


// forward declarations



void usage(FILE *, bool bExtendedUsage = false);

HRESULT
   StorePolicy(
               IN STORAGE_INFO StoreInfo,
               IN IPSEC_IKE_POLICY PolicyToStore
               );

int InitWinsock(
               WORD wVersionRequested
               );

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\ipseccmd.cpp ===
/////////////////////////////////////////////////////////////
// Copyright(c) 1998, Microsoft Corporation
//
// ipseccmd.cpp
//
// Created on 4/5/98 by Randyram
// Revisions:
//            3/2/00 DKalin
//              Update for whistler (dynamic mode only)
//            5/24/00 DKalin
//              Static store support (v1.35)
//            7/30/00 DKalin
//              Interface-based filtering support (v1.36)
//            8/23/00 DKalin
//              Got rid of ipsecposvc service, moved to the usage of persistent APIs
//              Default response rule support added
//
// This is the main file for the policy "on the fly" tool
//
/////////////////////////////////////////////////////////////

#include "ipseccmd.h"

int _cdecl ipseccmd_main(int argc, char *argv[])
{

   // status holders
   ULONG ulRpcErr = 0;
   DWORD dwStatus = ERROR_SUCCESS;
   BOOL bMMFiltersSpecified = FALSE;
   int i;
   PHANDLE hMMFilters = NULL, hFilters = NULL;
   LPVOID   myErrString = NULL;

   BOOL bShowSpecified = FALSE;
   int show_start_index = 0;

   // check to see if they're asking for help
   if ( (argc == 1) )
   {
      usage(stdout);
      printf("\nThe command completed successfully.\n");
      return 0;
   }
   else if ( (strchr(POTF_FLAG_TOKENS, argv[1][0]) != NULL) &&
             (strchr(POTF_HELP_FLAGS, argv[1][1]) != NULL) )
   {
      usage(stdout, true);
      printf("\nThe command completed successfully.\n");
      return 0;
   }

   // check to see if there are arguments longer than POTF_MAX_STRLEN - we won't accept these
   for (i = 1; i < argc; i++)
   {
	if (strlen(argv[i]) >= POTF_MAX_STRLEN)
	{
		printf("Error: the argument is too long (>%d symbols)\n", POTF_MAX_STRLEN-1);
		return 1;
	}
   }   

   // check for MM filters and show option
   for (i = 1; i < argc; i++)
   {
      if (strchr(POTF_FLAG_TOKENS, argv[i][0]) != NULL &&
          strncmp(&argv[i][1], POTF_MMFILTER_FLAG,
                              strlen(POTF_MMFILTER_FLAG)) == 0)
      {
        bMMFiltersSpecified = TRUE;
        break;
      }
	  if (!_stricmp(argv[i], KEYWORD_SHOW))
	  {
		bShowSpecified = TRUE;
		show_start_index = i;
		break;
	  }
   }

   // our RPC info-- process machine name here
   RPC_STATUS  RpcStat = RPC_S_OK;

   handle_t hIpsecpolsvc;

   // items for storage and conversion to storage
   STORAGE_INFO StoreInfo;
   memset(&StoreInfo, 0, sizeof(StoreInfo));

   // used to shift machinename out after processing
   char  **myArgv = argv;
   int   myArgc = argc;

   if ((argc > 1) && (strncmp(argv[1], "\\\\", 2) == 0))
   {
      TCHAR buf[POTF_MAX_STRLEN];
      _stprintf(buf, TEXT("%S"), argv[1]);
      _tcscpy((TCHAR *)szServ, buf+2);
      myArgv = argv + 1;
      myArgc = myArgc - 1;

      bLocalMachine = false;
   }

   // OK, now call show code if they asked us to
   if (bShowSpecified)
   {
	   i = ipseccmd_show_main(argc, argv, show_start_index);
	   if (i == IPSECCMD_USAGE)
	   {
		  usage(stdout, true);
		  printf("\nThe command completed successfully.\n");
		  return 0;
	   }
	   else if (i != 0)
	   {
		  return i;
	   }
	   else
	   {
		  printf("\nThe command completed successfully.\n");
		  return 0;
	   }
   }

   // check if they requested us to remove the persisted policy
	if ( myArgc == 2 && (strchr(POTF_FLAG_TOKENS, myArgv[1][0]) != NULL) &&
         (POTF_DELETERULE_FLAG == tolower(myArgv[1][1])) )
	{
		DeletePersistedIPSecPolicy(bLocalMachine ? L"" : szServ, pszIpsecpolPrefix);
		printf("\nThe command completed successfully.\n");
		return 0;
	}

   // init the policies
   DWORD dwConversionStatus = ERROR_SUCCESS;

   bool bConfirm = false;  // if true, print policy before plumbing
   char cConfirm = 'n';

   ///////////////////////////////////////////////////////////////////////
   //
   // CmdLineToPolicy changed to reduce the number of params.
   // To reduce the amount of code changed, I simply copy the
   // stuff I used to pass into the main policy struct and then
   // copy it back out.
   //
   ///////////////////////////////////////////////////////////////////////
   IPSEC_IKE_POLICY  IPSecIkePol;

   memset(&IPSecIkePol, 0, sizeof(IPSecIkePol));

   // Action!
   if (InitWinsock(MAKEWORD(2,0)))
   {
      // print the respective error from Text2Pol
      FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    GetModuleHandle(TEXT("text2pol.dll")),
                    T2P_WINSOCK_INITFAIL, 0,
                    (LPTSTR)&myErrString, 0, NULL);

      _ftprintf(stderr,
             TEXT("Error 0x%x occurred:\n\n%s\n"), T2P_WINSOCK_INITFAIL, myErrString);
      LocalFree(myErrString);
      return 1;
   }
   dwStatus =
        CmdLineToPolicy(myArgc, myArgv, IPSecIkePol, bConfirm, &StoreInfo);
   WSACleanup();

   if (!bLocalMachine)
   {
      //
      // copy the machine name into storage info in case it's needed
      //

      wcscpy(StoreInfo.szLocationName, szServ);
   }

   if (T2P_SUCCESS(dwStatus))
   {

     /// POST PROCESS POLICY////////////////////
     //  Get defaults, do fix ups
     ///////////////////////////////////////////

     // use default p1 policy if there isn't one specified
     if (IPSecIkePol.IkePol.dwOfferCount == 0)
     {
        LoadIkeDefaults(IPSecIkePol.IkePol);
     }

     // new with version 1.21: -f is required
	 // new with version 1.35: -f is not required if -y or -o specified
	// FIX: allow zero filters if -x is specified
     if (IPSecIkePol.dwNumFilters == 0 && !StoreInfo.bSetInActive && !StoreInfo.bDeletePolicy && !StoreInfo.bSetActive)
     {
        //LoadFilterDefaults(myFilters, myNumFilters);
        fprintf(stderr, "You must supply filters with -f\n\n");
        usage(stderr);
        return 1;
     }

     if (IPSecIkePol.IpsPol.dwOfferCount == 0)
        LoadOfferDefaults(IPSecIkePol.IpsPol.pOffers, IPSecIkePol.IpsPol.dwOfferCount);

     if (IPSecIkePol.AuthInfos.dwNumAuthInfos == 0)
     {
        IPSecIkePol.AuthInfos.pAuthenticationInfo = new IPSEC_MM_AUTH_INFO[1];
        assert(IPSecIkePol.AuthInfos.pAuthenticationInfo != NULL);

        IPSecIkePol.AuthInfos.pAuthenticationInfo[0].AuthMethod = IKE_SSPI;
        IPSecIkePol.AuthInfos.pAuthenticationInfo[0].dwAuthInfoSize = 0;
        IPSecIkePol.AuthInfos.pAuthenticationInfo[0].pAuthInfo = (LPBYTE) new wchar_t[1];
        IPSecIkePol.AuthInfos.pAuthenticationInfo[0].pAuthInfo[0] = UNICODE_NULL;

        IPSecIkePol.AuthInfos.dwNumAuthInfos = 1;
     }

	  if (StoreInfo.Type != STORAGE_TYPE_NONE)
      {
         //
         // store the policy
         //

         // XX put machine name into szLocationName

         dwConversionStatus =
            StorePolicy(StoreInfo, IPSecIkePol);

         if (dwConversionStatus != ERROR_SUCCESS)
         {
            if ( dwConversionStatus == P2STORE_MISSING_NAME )
            {
               fprintf(stderr, "You must supply a policy name\n");
            }
            else
            {
               fprintf(stderr, "Error converting policy: 0x%x\n",
                           dwConversionStatus);
            }
         }
      }
      else
      {
         /*
         // Check to make sure PA is up     //

         We do our best to get the PA up and running.  If, for some reason,
         we can't open SCM or get the service status, we don't abort, but
         let the exception handling around the actual RPC calls handle errors
         */

         if (!(PAIsRunning(dwStatus, (bLocalMachine) ? NULL : (TCHAR*)szServ))
               && dwStatus == ERROR_SUCCESS)
         {
            fprintf(stderr, "Policy Agent Service not running, starting it now...\n");
            if (!StartPA(dwStatus, (bLocalMachine) ? NULL : (TCHAR*)szServ))
            {
               fprintf(stderr,"Couldn't start Policy Agent service, error 0x%x, Exiting.\n",
                        dwStatus);
               return 1;
            }
         }
         else if (dwStatus != ERROR_SUCCESS)
         {
            fprintf(stderr,"Couldn't check status of Policy Agent service, error 0x%x, Exiting.\n",
                     dwStatus);
            return 1;
         }


      // get GUIDs

	  // first delete
	  DeleteGuidsNames(IPSecIkePol);
	  GenerateGuidsNames(pszIpsecpolPrefix, IPSecIkePol);

      if (bConfirm)
      {
         PrintPolicies(IPSecIkePol);
		 _flushall();
         cout << "Continue? [y/n]: ";
         cin >> cConfirm;
         if (cConfirm == 'n' || cConfirm == 'N')
            return 1;
      }


  	  RpcStat = PlumbIPSecPolicy((bLocalMachine) ? L"" : szServ, &IPSecIkePol, bMMFiltersSpecified, &hMMFilters, &hFilters, TRUE);
	  if (RpcStat == RPC_S_UNKNOWN_IF)
	  {
		fprintf(stderr, "PA RPC not ready. Sleeping for %d seconds...\n", POTF_PARPC_SLEEPTIME/1000);
		Sleep(POTF_PARPC_SLEEPTIME);
   	    RpcStat = PlumbIPSecPolicy((bLocalMachine) ? L"" : szServ, &IPSecIkePol, bMMFiltersSpecified, &hMMFilters, &hFilters, TRUE);
	  }

      if (RpcStat != RPC_S_OK)
      {
        // PAAddPolicy can return alot of different codes, not well defined.
        // so, process the ones we care about or can diagnose
        if (RpcStat == RPC_E_ACCESS_DENIED)
        {
           fprintf(stderr,"Access denied.  You do not have admin privileges on the target machine\n");
        }
        else
        {
           fprintf(stderr, "Failed to add policy, error 0x%x\n", RpcStat);
        }

      }
	  else
	  {
		  // everything is fine, must close handles
		  if (hMMFilters)
		  {
			for (i = 0; i < (int) IPSecIkePol.dwNumMMFilters; i++)
			{
				CloseMMFilterHandle(hMMFilters[i]);
			}
		  }
		  if (hFilters)
		  {
			for (i = 0; i < (int) IPSecIkePol.dwNumFilters; i++)
			{
				if (IPSecIkePol.QMFilterType == QM_TRANSPORT_FILTER)
				{
					CloseTransportFilterHandle(hFilters[i]);
				}
				else
				{
					CloseTunnelFilterHandle(hFilters[i]);
				}
			}
		  }
	  }

     }
   }
   else
   {
      if (dwStatus != POTF_FAILED)
      {
         // print the respective error from Text2Pol
         FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                       GetModuleHandle(TEXT("text2pol.dll")),
                       dwStatus, 0,
                       (LPTSTR)&myErrString, 0, NULL);

         _ftprintf(stderr,
                TEXT("Error 0x%x occurred:\n\n%s\n"), dwStatus, myErrString);
	     LocalFree(myErrString);
      }

      usage(stderr);
      return 1;
   }

   if (StoreInfo.Type != STORAGE_TYPE_NONE)
   {
      if ( StoreInfo.FilterList )
         delete [] StoreInfo.FilterList;
   }

   DeleteGuidsNames(IPSecIkePol);
   if (IPSecIkePol.IkePol.pOffers != NULL)
   {
      delete [] IPSecIkePol.IkePol.pOffers;
      IPSecIkePol.IkePol.pOffers = NULL;
   }
   if (IPSecIkePol.IpsPol.pOffers != NULL)
   {
      delete [] IPSecIkePol.IpsPol.pOffers;
      IPSecIkePol.IpsPol.pOffers = NULL;
   }
   if (IPSecIkePol.pMMFilters != NULL)
   {
      delete [] IPSecIkePol.pMMFilters;
      IPSecIkePol.pMMFilters = NULL;
   }
   if (IPSecIkePol.pTransportFilters != NULL)
   {
      delete [] IPSecIkePol.pTransportFilters;
      IPSecIkePol.pTransportFilters = NULL;
   }
   if (IPSecIkePol.pTunnelFilters != NULL)
   {
      delete [] IPSecIkePol.pTunnelFilters;
      IPSecIkePol.pTunnelFilters = NULL;
   }
   if (IPSecIkePol.AuthInfos.pAuthenticationInfo != NULL)
   {
      delete [] IPSecIkePol.AuthInfos.pAuthenticationInfo;
      IPSecIkePol.AuthInfos.pAuthenticationInfo = NULL;
   }

   memset(&IPSecIkePol, 0, sizeof(IPSecIkePol));
   printf("\nThe command completed successfully.\n");
   return 0;
}


/////////////////////// UTILITY FUNCTIONS //////////////////////////
/*
// Loads Me to Any
void LoadFilterDefaults(OUT FILTER * & Filters, OUT UINT & NumFilters)
{
   NumFilters = 2;

   Filters = new FILTER[NumFilters];
   assert(Filters != NULL);
   memset(Filters, 0, NumFilters * sizeof(FILTER));

   Filters[0].FilterSpec.DestAddr = 0;
   Filters[0].FilterSpec.DestMask = 0;
   Filters[0].FilterSpec.SrcAddr = 0;
   Filters[0].FilterSpec.SrcMask = -1;


   Filters[1].FilterSpec.DestAddr = 0;
   Filters[1].FilterSpec.DestMask = -1;
   Filters[1].FilterSpec.SrcAddr = 0;
   Filters[1].FilterSpec.SrcMask = 0;

   //Filters[0].InterfaceType = Filters[1].InterfaceType = PA_INTERFACE_TYPE_ALL;

   // set the GUID
   RPC_STATUS RpcStat;
   for (UINT i = 0; i < NumFilters; ++i)
   {
      RpcStat = UuidCreate(&Filters[i].FilterID);
      if (RpcStat != RPC_S_OK && RpcStat != RPC_S_UUID_LOCAL_ONLY)
      {
         sprintf(STRLASTERR, "Couldn't get GUID failed with status: %ul\n",
                 RpcStat);
         WARN;
      }
   }

}

*/

HRESULT
   StorePolicy(
               IN STORAGE_INFO StoreInfo,
               IN IPSEC_IKE_POLICY PolicyToStore
               )
{
   HRESULT hr     = S_OK;  // holds polstore info

   IPSECPolicyToStorage Polstore;

   WCHAR wszPolicyName[POTF_MAX_STRLEN],
         wszRuleName[POTF_MAX_STRLEN],
         wszLocationName[POTF_MAX_STRLEN];
   bool  bLocationUsed     = false;
   DWORD dwLocation;
   HANDLE hStore = NULL;
   int i;

   // do some initialization and checks before we write it

   if (StoreInfo.szLocationName[0] != '\0')
   {
      wcscpy(wszLocationName, StoreInfo.szLocationName);
//      MultiByteToWideChar(CP_THREAD_ACP, 0, StoreInfo.szLocationName, -1,
//                          wszLocationName, POTF_MAX_STRLEN);
      bLocationUsed = true;
   }

     wcscpy(wszPolicyName, StoreInfo.szPolicyName);
     wcscpy(wszRuleName, StoreInfo.szRuleName);

//   MultiByteToWideChar(CP_THREAD_ACP, 0, StoreInfo.szRuleName, -1,
//                       wszRuleName, POTF_MAX_STRLEN);
//   MultiByteToWideChar(CP_THREAD_ACP, 0, StoreInfo.szPolicyName, -1,
//                       wszPolicyName, POTF_MAX_STRLEN);

   dwLocation = IPSEC_REGISTRY_PROVIDER;

   if (StoreInfo.Type == STORAGE_TYPE_DS)
       dwLocation = IPSEC_DIRECTORY_PROVIDER;

   //
   // Special handling for setting active policy to NULL
   //

   if ( StoreInfo.bSetInActive )
   {
	  // deactivate policy in specified storage
	  PIPSEC_POLICY_DATA pipspd = NULL;

	  hr = IPSecOpenPolicyStore((bLocationUsed) ? wszLocationName : NULL, dwLocation, NULL, &hStore);
	  if (hr == ERROR_SUCCESS && hStore != NULL)
	  {
		hr = IPSecGetAssignedPolicyData(hStore, &pipspd);
		if (hr == ERROR_SUCCESS && pipspd != NULL)
		{
			hr = IPSecUnassignPolicy(hStore, pipspd[0].PolicyIdentifier);
			IPSecFreePolicyData(pipspd);
		}

		IPSecClosePolicyStore(hStore);
	  }

	  // now if there are no filters specified, bail out
	  if (PolicyToStore.dwNumFilters == 0)
	  {
		  return hr;
	  }
   }

   hr = Polstore.Open(dwLocation,
                     (bLocationUsed) ? wszLocationName : NULL,
                     wszPolicyName,
                     NULL,
                     (StoreInfo.tPollingInterval)
                        ? StoreInfo.tPollingInterval : P2STORE_DEFAULT_POLLINT,
                     true);

   if ( hr != ERROR_SUCCESS || hr == P2STORE_MISSING_NAME )
      return hr;

   //
   // Look through the rules to see if we should add or update
   //

   PIPSEC_POLICY_DATA   pPolicy = Polstore.GetPolicy();
   assert(pPolicy);
   hStore = Polstore.GetStorageHandle();

   if (PolicyToStore.dwNumFilters == 0 && StoreInfo.bSetActive)
   {
	// just set active
        hr = Polstore.SetAssignedPolicy(pPolicy);
	return hr;
   }


   if ( StoreInfo.bDeletePolicy )
   {
	  // remove policy from storage
	  if (!Polstore.IsPolicyInStorage())
	  {
		  return ERROR_FILE_NOT_FOUND;
	  }
	  // proceed and remove rule internals first (incl. filter and negpol)
	  for (i = 0; i < (int) pPolicy->dwNumNFACount; i++)
	  {
		  if (hr == ERROR_SUCCESS)
		  {
			  hr = IPSecDeleteNFAData(hStore, pPolicy->PolicyIdentifier, pPolicy->ppIpsecNFAData[i]);
		  }
	  }
	  for (i = 0; i < (int) pPolicy->dwNumNFACount; i++)
	  {
		  if (hr == ERROR_SUCCESS)
		  {
			  RPC_STATUS RpcStat;
			  if (!UuidIsNil(&(pPolicy->ppIpsecNFAData[i]->FilterIdentifier), &RpcStat))
			  {
				hr = IPSecDeleteFilterData(hStore, pPolicy->ppIpsecNFAData[i]->FilterIdentifier);
			  }
		  }
		  if (hr == ERROR_SUCCESS)
		  {
			  hr = IPSecDeleteNegPolData(hStore, pPolicy->ppIpsecNFAData[i]->NegPolIdentifier);
		  }
	  }
	  // now proceed and remove ISAKMP and policy
	  if (hr == ERROR_SUCCESS)
	  {
		  hr = IPSecDeletePolicyData(hStore, pPolicy);
	  }
	  if (hr == ERROR_SUCCESS)
	  {
		  hr = IPSecDeleteISAKMPData(hStore, pPolicy->ISAKMPIdentifier);
	  }
   }
   else
   {
	  PIPSEC_NFA_DATA pNFA = NULL;

      hr = Polstore.SetISAKMPPolicy(PolicyToStore.IkePol);

      if (!pPolicy->dwNumNFACount)
	  {
		  // add default response
		  hr = Polstore.AddDefaultResponseRule();
          pPolicy = Polstore.GetPolicy();
	  }

      // in the case of default response, always update the first rule (if it exists)
	  if (PolicyToStore.QMFilterType == QM_TRANSPORT_FILTER
		&& PolicyToStore.pTransportFilters[0].SrcAddr.AddrType == IP_ADDR_UNIQUE
		&& PolicyToStore.pTransportFilters[0].SrcAddr.uIpAddr == IP_ADDRESS_ME
		&& PolicyToStore.pTransportFilters[0].DesAddr.AddrType == IP_ADDR_UNIQUE
		&& PolicyToStore.pTransportFilters[0].DesAddr.uIpAddr == IP_ADDRESS_ME
		&& PolicyToStore.pTransportFilters[0].InboundFilterFlag == (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG
		&& PolicyToStore.pTransportFilters[0].OutboundFilterFlag == (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG)
	  {
		  if (pPolicy->dwNumNFACount)
		  {
			  pNFA = pPolicy->ppIpsecNFAData[pPolicy->dwNumNFACount-1];
		  }
	  }
	  else
	  {
		  for (i = 0; i < (int) pPolicy->dwNumNFACount; i++)
		  {
			  if (pPolicy->ppIpsecNFAData[i]->pszIpsecName && wcscmp(pPolicy->ppIpsecNFAData[i]->pszIpsecName, wszRuleName) == 0)
			  {
				  // found a rule
				  pNFA = pPolicy->ppIpsecNFAData[i];
				  break;
			  }
		  }
	  }

      if ( !pNFA )
      {
         hr = Polstore.AddRule(PolicyToStore, &StoreInfo);
      }
      else
      {
         hr = Polstore.UpdateRule(pNFA, PolicyToStore, &StoreInfo);
      }


      if (hr == ERROR_SUCCESS)
      {
         if (!Polstore.IsPolicyInStorage())
		 {
			 return ERROR_ACCESS_DENIED;
		 }

         if (StoreInfo.bSetActive)
         {
            hr = Polstore.SetAssignedPolicy(pPolicy);
         }
      }
   }

   return hr;
}

void usage(FILE *fh_usage, bool bExtendedUsage)
{

   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "%s\n", POTF_VERSION);
   fprintf(fh_usage, "USAGE: \n");
   fprintf(fh_usage, "ipseccmd \\\\machinename -f FilterList -n NegotiationPolicyList -t TunnelAddr\n");
   fprintf(fh_usage, "         -a AuthMethodList -1s SecurityMethodList -1k Phase1RekeyAfter -1p\n");
   fprintf(fh_usage, "         -1f MMFilterList -1e SoftSAExpirationTime -soft -confirm\n");
   fprintf(fh_usage, "         [-dialup OR -lan]\n");
   fprintf(fh_usage, "         {-w TYPE:DOMAIN -p PolicyName:PollInterval -r RuleName -x -y -o}\n");
   fprintf(fh_usage, "ipseccmd \\\\machinename show filters policies auth stats sas all\n");
   fprintf(fh_usage, " \n");
   fprintf(fh_usage, "\nBATCH MODE:\n");
   fprintf(fh_usage, "ipseccmd -file filename\n");
   fprintf(fh_usage, "         File must contain regular ipseccmd commands,\n");
   fprintf(fh_usage, "         all these commands will be executed in one shot.\n");
   fprintf(fh_usage, " \n");

   if ( !bExtendedUsage )
   {
      fprintf(fh_usage, "For extended usage, run: ipseccmd -?");
      fprintf(fh_usage, "\n");
      return;
   }

   //
   // new usage w/ storage added
   //

   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "ipseccmd has three mutually exclusive modes: static, dynamic, and query. \n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "The default mode is dynamic. \n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "Dynamic mode will plumb policy directly into the IPSec Services\n");
   fprintf(fh_usage, "Security Policies Database. The policy will be persisted, i.e. it will stay\n");
   fprintf(fh_usage, "after a reboot. The benefit of dynamic policy is that it can co-exist with\n");
   fprintf(fh_usage, "DS based policy.\n");
   fprintf(fh_usage, "\nTo delete all dynamic policies, execute \"ipseccmd -u\" command\n");
   fprintf(fh_usage, "\nWhen the tool is used in static mode,\n");
   fprintf(fh_usage, "it creates or modifies stored policy.  This policy can be used again and \n");
   fprintf(fh_usage, "will last the lifetime of the store. Static mode is indicated by the -w\n");
   fprintf(fh_usage, "flag.  The flags in the {} braces are only valid for static mode.  The usage \n");
   fprintf(fh_usage, "for static mode is an extension of dynamic mode, so please read through\n");
   fprintf(fh_usage, "the dynamic mode section.\n");
   fprintf(fh_usage, "\nIn query mode, the tool queries IPSec Security Policies Database.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "NOTE: references to SHA in ipseccmd are referring to the SHA1 algorithm.\n");
   fprintf(fh_usage, "\n");


   fprintf(fh_usage, "------------\n");
   fprintf(fh_usage, " QUERY MODE \n");
   fprintf(fh_usage, "------------\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "The tool displays requested type of data from IPSec Security Policies Database\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, " filters   - shows main mode and quick mode filters\n");
   fprintf(fh_usage, " policies  - shows main mode and quick mode policies\n");
   fprintf(fh_usage, " auth      - shows main mode authentication methods\n");
   fprintf(fh_usage, " stats     - shows Internet Key Exchange (IKE) and IPSec statistics\n");
   fprintf(fh_usage, " sas       - shows main mode and quick mode Security Associations\n");
   fprintf(fh_usage, " all       - shows all of the above data\n");
   fprintf(fh_usage, "It is possible to combine several flags\n");
   fprintf(fh_usage, "EXAMPLE: ipseccmd show filters policies\n");

   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "------------\n");
   fprintf(fh_usage, "DYNAMIC MODE\n");
   fprintf(fh_usage, "------------\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "Each execution of the tool sets an IPSec rule, an IKE policy,\n");
   fprintf(fh_usage, "or both.  When setting the IPSec policy,  think of it as setting an \"IP Security Rule\" \nin the UI.  So, if you need to set up a tunnel policy, you will need\n");
   fprintf(fh_usage, "to execute  the tool twice, once for the outbound filters and outgoing tunnel\n");
   fprintf(fh_usage, "endpoint, and once for the inbound filters and incoming tunnel endpoint.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "OPTIONS:\n");
   fprintf(fh_usage, "  \n");
   fprintf(fh_usage, "  \\\\machinename sets policies on that machine.  If not included, the \n");
   fprintf(fh_usage, "  local machine is assumed.\n");
   fprintf(fh_usage, "  NOTE: that if you use this it must be the first argument AND\n");
   fprintf(fh_usage, "  you MUST have administrative privileges on that machine.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  -confirm will ask you to confirm before setting policy\n");
   fprintf(fh_usage, "      can be abbreviated to -c\n");
   fprintf(fh_usage, "      *OPTIONAL, DYNAMIC MODE ONLY*\n");
   fprintf(fh_usage, "\n");


   fprintf(fh_usage, "  The following flags deal with IPSec policy. If omitted, a default value \n");
   fprintf(fh_usage, "  is used where specified.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  -f FilterList \n");
   fprintf(fh_usage, "      where FilterList is one or more space separated filterspecs\n");
   fprintf(fh_usage, "      a filterspec is of the format:\n");
   fprintf(fh_usage, "      A.B.C.D/mask:port=A.B.C.D/mask:port:protocol\n");
   fprintf(fh_usage, "        you can also specify DEFAULT to create default response rule\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      The Source address is always on the left of the '=' and the Destination \n");
   fprintf(fh_usage, "      address is always on the right.  \n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      MIRRORING: If you replace the '=' with a '+' two filters will be created, \n");
   fprintf(fh_usage, "      one in each direction.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      mask and port are optional.  If omitted, Any port and\n");
   fprintf(fh_usage, "      mask 255.255.255.255 will be used for the filter.  \n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      You can replace A.B.C.D/mask with the following for \n");
   fprintf(fh_usage, "      special meaning:\n");
   fprintf(fh_usage, "      0 means My address(es)\n");
   fprintf(fh_usage, "      * means Any address\n");
   fprintf(fh_usage, "      a DNS name (NOTE: multiple resolutions are ignored)\n");
   fprintf(fh_usage, "      a GUID of the local network interface in the form {12345678-1234-1234-1234-123456789ABC}\n");
   fprintf(fh_usage, "        GUIDs are NOT supported for static mode\n");
   fprintf(fh_usage, "\n");


   fprintf(fh_usage, "      protocol is optional, if omitted, Any protocol is assumed.  If you    \n");
   fprintf(fh_usage, "      indicate a protocol, a port must precede it or :: must preceded it.\n");
   fprintf(fh_usage, "      NOTE BENE: if protocol is specified, it must be the last item in \n");
   fprintf(fh_usage, "                 the filter spec. \n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      Examples:\n");
   fprintf(fh_usage, "      Machine1+Machine2::6 will filter TCP traffic between Machine1 and Machine2\n");
   fprintf(fh_usage, "      172.31.0.0/255.255.0.0:80=157.0.0.0/255.0.0.0:80:TCP will filter\n");
   fprintf(fh_usage, "        all TCP traffic from the first subnet, port 80 to the second subnet, \n");
   fprintf(fh_usage, "        port 80\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      PASSTHRU and DROP filters: By surrounding a filter specification with (), \n");
   fprintf(fh_usage, "      the filter will be a passthru filter.  If you surround it with [], the \n");
   fprintf(fh_usage, "      filter will be a blocking, or drop, filter. \n");
   fprintf(fh_usage, "      Example: (0+128.2.1.1) will create 2 filters (it's mirrored) that will \n");
   fprintf(fh_usage, "      be exempted from policy.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      You can use the following protocol symbols: ICMP UDP RAW TCP   \n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      Star notation:\n");
   fprintf(fh_usage, "      If you're subnet masks are along octet boundaries, then you\n");
   fprintf(fh_usage, "      can use the star notation to wildcard subnets.\n");
   fprintf(fh_usage, "      Examples:\n");
   fprintf(fh_usage, "      128.*.*.* is same as 128.0.0.0/255.0.0.0\n");
   fprintf(fh_usage, "      128.*.* is the same as above\n");
   fprintf(fh_usage, "      128.* is the same as above\n");
   fprintf(fh_usage, "      144.92.*.* is same as 144.92.0.0/255.255.0.0\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      There is no DEFAULT, -f is required\n");
   fprintf(fh_usage, " \n");


   fprintf(fh_usage, "  -n NegotiationPolicyList \n");
   fprintf(fh_usage, "      where NegotiationPolicyList is one or more space separated \n");
   fprintf(fh_usage, "      IPSec policies in the one of the following forms:\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      ESP[ConfAlg,AuthAlg]RekeyPFS[Group] \n");
   fprintf(fh_usage, "      AH[HashAlg] \n");
   fprintf(fh_usage, "      AH[HashAlg]+ESP[ConfAlg,AuthAlg]\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      where ConfAlg can be NONE, DES, or 3DES\n");
   fprintf(fh_usage, "      and AuthAlg can be NONE, MD5, or SHA\n");
   fprintf(fh_usage, "      and HashAlg is MD5 or SHA\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      NOTE: ESP[NONE,NONE] is not a supported config\n");
   fprintf(fh_usage, "      NOTE: SHA refers the SHA1 hash algorithm\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      Rekey is number of KBytes or number of seconds to rekey \n");
   fprintf(fh_usage, "      put K or S after the number to indicate KBytes or seconds, respectively\n");
   fprintf(fh_usage, "      Example: 3600S will rekey after 1 hour\n");
   fprintf(fh_usage, "      To use both, separate with a slash.\n");
   fprintf(fh_usage, "      Example: 3600S/5000K will rekey every hour and 5 MB.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      REKEY PARAMETERS ARE OPTIONAL\n");
   fprintf(fh_usage, "\n");


   fprintf(fh_usage, "      PFS this is OPTIONAL, if it is present it will enable phase 2 perfect\n");
   fprintf(fh_usage, "      forward secrecy.  You may use just P for short.\n");
   fprintf(fh_usage, "      It is also possible to specify which PFS Group to use: \n");
   fprintf(fh_usage, "        PFS1 or P1, PFS2 or P2\n");
   fprintf(fh_usage, "      By Default, PFS Group value will be taken from current Main Mode settings");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      DEFAULT: ESP[3DES,SHA] ESP[3DES,MD5] ESP[DES,SHA]\n");
   fprintf(fh_usage, "               ESP[DES,MD5]\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  -t tunnel address in one of the following forms:\n");
   fprintf(fh_usage, "      A.B.C.D\n");
   fprintf(fh_usage, "      DNS name\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      DEFAULT: omission of tunnel address assumes transport mode\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  -a AuthMethodList \n");
   fprintf(fh_usage, "      A list of space separated auth methods of the form:\n");
   fprintf(fh_usage, "      PRESHARE:\"preshared key string\"\n");
   fprintf(fh_usage, "      KERBEROS\n");
   fprintf(fh_usage, "      CERT:\"CA Info\"\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      The strings provided to preshared key and CA info ARE case sensitive.\n");
   fprintf(fh_usage, "      You can abbreviate the method with the first letter, ie. P, K, or C.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      DEFAULT: KERBEROS\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  -soft will allow soft associations\n");
   fprintf(fh_usage, "      DEFAULT: don't allow soft SAs\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  -lan will set policy only for lan adapters\n");
   fprintf(fh_usage, "  -dialup will set policy only for dialup adapters\n");
   fprintf(fh_usage, "      *BOTH ARE OPTIONAL, if not specified, All adapters are used*\n");
   fprintf(fh_usage, "      DEFAULT: All adapters\n");
   fprintf(fh_usage, "\n");


   fprintf(fh_usage, "  The following deal with IKE phase 1 policy.  An easy way to remember\n");
   fprintf(fh_usage, "  is that all IKE phase 1 parameters are passed with a 1 in the flag.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  If no IKE flags are specified, the current IKE policy\n");
   fprintf(fh_usage, "  will be used.  If there is no current IKE policy, the defaults \n");
   fprintf(fh_usage, "  specified below will be used.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  -1s SecurityMethodList\n");
   fprintf(fh_usage, "      where SecurityMethodList is one or more space separated SecurityMethods\n");
   fprintf(fh_usage, "      in the form:\n");
   fprintf(fh_usage, "      ConfAlg-HashAlg-GroupNum\n");
   fprintf(fh_usage, "      where ConfAlg can be DES or 3DES\n");
   fprintf(fh_usage, "      and HashAlg is MD5 or SHA\n");
   fprintf(fh_usage, "      and GroupNum is:\n");
   fprintf(fh_usage, "      1 (Low)\n");
   fprintf(fh_usage, "      2 (Med)\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "      Example: DES-SHA-1\n");
   fprintf(fh_usage, "      DEFAULT: 3DES-SHA-2 3DES-MD5-2 DES-SHA-1 DES-MD5-1\n");
   fprintf(fh_usage, "\n");


   fprintf(fh_usage, "  -1p enable PFS for phase 1\n");
   fprintf(fh_usage, "      DEFAULT: not enabled\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  -1k number of Quick Modes or number of seconds to rekey for phase 1\n");
   fprintf(fh_usage, "      put Q or S after the number to indicate Quick Modes or seconds,\n");
   fprintf(fh_usage, "       respectively\n");
   fprintf(fh_usage, "      Example: 10Q will rekey after 10 quick modes\n");
   fprintf(fh_usage, "      To use both, separate with a slash.\n");
   fprintf(fh_usage, "      Example: 10Q/3600S will rekey every hour and 10 quick modes\n");
   fprintf(fh_usage, "      *OPTIONAL*\n");
   fprintf(fh_usage, "      DEFAULT: no QM limit, 480 min lifetime\n");
   fprintf(fh_usage, "   \n");
   fprintf(fh_usage, "  -1e SoftSAExpirationTime\n");
   fprintf(fh_usage, "      set Soft SA expiration time attribute of the main mode policy\n");
   fprintf(fh_usage, "       value is specified in seconds\n");
   fprintf(fh_usage, "      DEFAULT: not set if Soft SA is not allowed\n");
   fprintf(fh_usage, "               set to 300 seconds if Soft SA is allowed\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "  -1f MMFilterList\n");
   fprintf(fh_usage, "      set specific main mode filters. Syntax is the same as for -f option\n");
   fprintf(fh_usage, "       except that you cannot specify passthru, block filters, ports and protocols\n");
   fprintf(fh_usage, "      DEFAULT: filters are generated automatically based on quick mode filters\n");
   fprintf(fh_usage, "   \n");
   fprintf(fh_usage, "-----------\n");
   fprintf(fh_usage, "STATIC MODE\n");
   fprintf(fh_usage, "-----------\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "Static mode uses most of the dynamic mode syntax, but adds a few flags\n");
   fprintf(fh_usage, "that enable it work at a policy level as well.  Remember, dynamic mode\n");
   fprintf(fh_usage, "just lets you add anonymous rules to the policy agent.  Static mode\n");
   fprintf(fh_usage, "allows you to create named policies and named rules.  It also has some\n");
   fprintf(fh_usage, "functionality to modify existing policies and rules, provided they were\n");
   fprintf(fh_usage, "originally created with ipseccmd.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "Static mode is supposed to provide most of the functionality of the IPSec UI\n");
   fprintf(fh_usage, "in a command line tool, so there are references here to the UI.\n");
   fprintf(fh_usage, "\n");


   fprintf(fh_usage, "First, there is one change to the dynamic mode usage that static mode\n");
   fprintf(fh_usage, "requires.  In static mode, pass through and block filters are indicated\n");
   fprintf(fh_usage, "in the NegotiationPolicyList that is specified by -n.  There are three\n");
   fprintf(fh_usage, "items you can pass in the NegotiationPolicyList that have special meaning:\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "BLOCK will ignore the rest of the policies in NegotiationPolicyList and \n");
   fprintf(fh_usage, "      will make all of the filters blocking or drop filters.\n");
   fprintf(fh_usage, "      This is the same as checking the \"Block\" radio button\n");
   fprintf(fh_usage, "      in the UI\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "PASS  will ignore the rest of the policies in NegotiationPolicyList and \n");
   fprintf(fh_usage, "      will make all of the filters pass through filters.\n");
   fprintf(fh_usage, "      This is the same as checking the \"Permit\"\n");
   fprintf(fh_usage, "      radio button in the UI\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "INPASS will plumb any inbound filters as pass through.\n");
   fprintf(fh_usage, "       This is the same as checking the \"Allow unsecured communication,\n");
   fprintf(fh_usage, "       but always respond using IPSEC\" check box in the UI\n");
   fprintf(fh_usage, "       \n");
   fprintf(fh_usage, "\n");


   fprintf(fh_usage, "Static Mode flags:\n");
   fprintf(fh_usage, "All flags are REQUIRED unless otherwise indicated.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "-w Write the policy to storage indicated by TYPE:LOCATION\n");
   fprintf(fh_usage, "   TYPE can be either REG for registry or DS for Directory Storage\n");
   fprintf(fh_usage, "        if \\\\machinename was specified and TYPE is REG, will be written\n");
   fprintf(fh_usage, "        to the remote machine's registry\n");
   fprintf(fh_usage, "   DOMAIN for the DS case only. Indicates the domain name of the\n");
   fprintf(fh_usage, "          DS to write to. If omitted, use the domain the local machine is in.\n");
   fprintf(fh_usage, "          OPTIONAL\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "-p PolicyName:PollInterval\n");
   fprintf(fh_usage, "   Name the policy with this string.  If a policy with this name is\n");
   fprintf(fh_usage, "   already in storage, this rule will be added to the policy. \n");
   fprintf(fh_usage, "   Otherwise a new policy will be created.  If PollInterval is specified,\n");
   fprintf(fh_usage, "   the polling interval for the policy will be set.\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "-r RuleName\n");
   fprintf(fh_usage, "   Name the rule with this string.  If a rule with that name already exists,\n");
   fprintf(fh_usage, "   that rule is modified to reflect the information supplied to ipseccmd.\n");
   fprintf(fh_usage, "   For example, if only -f is specified and the rule exists,\n");
   fprintf(fh_usage, "   only the filters of that rule will be replaced. \n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "-x will set the policy active in the LOCAL registry case OPTIONAL\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "-y will set the policy inactive in the LOCAL registry case OPTIONAL\n");
   fprintf(fh_usage, "\n");
   fprintf(fh_usage, "-o will delete the policy specified by -p OPTIONAL\n");
   fprintf(fh_usage, "   (NOTE: this will delete all aspects of the specified policy\n");
   fprintf(fh_usage, "    don't use if you have other policies pointing to the objects in that policy)\n");

   return;
}


// need to init/cleanup Winsock
int
    InitWinsock(
                       WORD wVersionRequested
               )
{
   WSADATA wsaData;
   int err;

   err = WSAStartup( wVersionRequested, &wsaData );
   if ( !err )
   {
     //
     // CHECK VERSION
     //

     if ( LOBYTE(wsaData.wVersion) != LOBYTE(wVersionRequested) ||
          HIBYTE(wsaData.wVersion) != HIBYTE(wVersionRequested) )
     {
        /* Tell the user that we could not find a usable */
        /* WinSock DLL.                                  */

        WSACleanup();
        err = (-1);
     }
   }

   return err;
}

// fgets function that reads a string from the file. Buffer is reallocated to make sure we read the whole string
char* my_fgets (char** ppbuf, int* pbufsize, FILE* f)
{
	char* tmp;
	int   itmp;

	tmp = fgets(*ppbuf, *pbufsize, f);
	if (!tmp)
		return NULL;
	itmp = strlen(*ppbuf);
	while (itmp == *pbufsize-1 && (*ppbuf)[*pbufsize-2] != '\r' && (*ppbuf)[*pbufsize-2] != '\n')
	{
		// need to read longer string
		*pbufsize *= 2;
		*ppbuf = (char*) realloc(*ppbuf, *pbufsize);
		assert(*ppbuf);

		// read again
		tmp = fgets(*ppbuf+itmp, *pbufsize/2+1, f);
		if (!tmp)
			return NULL;
		itmp = strlen(*ppbuf);
	}
	return tmp;
}

// "real" main that reads from file if needed (v 1.51)
int _cdecl main(int argc, char *argv[])
{
	   FILE *f;
   	   char *commandLine = NULL; // temp storage for cmd line
           int clSize = POTF_MAX_STRLEN;
	   char * tArgv[8192];

	   if (argc < 2 || _stricmp(argv[1], "-file"))
           {
                   // regular ipseccmd
                   return ipseccmd_main(argc, argv);
           }

           tArgv[0] = _strdup("ipseccmd");
           commandLine = new char[clSize];
	   assert(commandLine);
	   int tArgc = 1;
	   int iLine = 1;
	   if ((f = fopen(argv[2], "r")) == NULL)
	   {
		   printf("%s could not be opened for read! GetLastError = 0x%x\n", argv[2], GetLastError());
		   return 1;
	   }

 	    // now read the contents of the file
		while (!feof(f))
		{
			if (my_fgets(&commandLine, &clSize, f) != NULL)
			{
				if (strlen(commandLine) > 0)
				{
                                	if (commandLine[strlen(commandLine)-1] == '\r' || commandLine[strlen(commandLine)-1] == '\n')
					{
						commandLine[strlen(commandLine)-1] = 0;
					}
				}
				if (strlen(commandLine) > 0)
				{
                                	if (commandLine[strlen(commandLine)-1] == '\r' || commandLine[strlen(commandLine)-1] == '\n')
					{
						commandLine[strlen(commandLine)-1] = 0;
					}
				}
				// parse the command line
				tArgv[1] = strtok(commandLine, " \t");
				if (!tArgv[1])
				{
					// empty string, continue;
					continue;
				}
				tArgc++;
				if (!_stricmp(tArgv[1], tArgv[0]))
				{
					// line in file starts with "ipseccmd", skip the word;
					tArgc--;
				}
				while (tArgv[tArgc] = strtok(NULL, " \t"))
				{
					tArgc++;
				}

				// end parse
				ipseccmd_main (tArgc, tArgv);
		        tArgc = 1;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\print.h ===
/////////////////////////////////////////////////////////////
// Copyright(c) 2000, Microsoft Corporation
//                         
// print.h
//                              
// Created on 3/22/2000 by Dennis Kalinichenko (DKalin)
// Revisions:                  
//                            
// Includes all the necessary definitions for print.cpp printing library
//                                                       
/////////////////////////////////////////////////////////////

#ifndef _PRINT_H_
#define _PRINT_H_

#include "ipseccmd.h"

#ifndef MAXCOMPUTERNAMELEN
#define MAXCOMPUTERNAMELEN	(1024) 
#endif

#ifndef STRING_TEXT_SIZE
#define  STRING_TEXT_SIZE 128
#endif

#ifndef CERT_TEXT_SIZE
#define  CERT_TEXT_SIZE   8192
#endif


// forward declarations

void PrintPolicies(IN IPSEC_IKE_POLICY& IPSecIkePol);

void  PrintQMOffer(IN IPSEC_QM_OFFER mmOffer, IN PTCHAR pszPrefix, IN PTCHAR pszPrefix2);
void  PrintFilterAction(IN IPSEC_QM_POLICY qmPolicy, IN PTCHAR pszPrefix);
BOOL  PrintFilter (IN TRANSPORT_FILTER tFilter, IN BOOL bPrintNegPol, IN BOOL bPrintSpecific);
BOOL  PrintTunnelFilter (IN TUNNEL_FILTER tFilter, IN BOOL bPrintNegPol, IN BOOL bPrintSpecific);
BOOL  PrintMMFilter (IN MM_FILTER mmFilter, IN BOOL bPrintNegPol, IN BOOL bPrintSpecific);
void  PrintMMPolicy(IN IPSEC_MM_POLICY mmPolicy, IN PTCHAR pszPrefix);
void  PrintMMOffer(IN IPSEC_MM_OFFER mmOffer, IN PTCHAR pszPrefix, IN PTCHAR pszPrefix2);
void  PrintAddr(IN ADDR addr);
void  PrintAuthInfo(IN IPSEC_MM_AUTH_INFO authInfo);
void  PrintMMAuthMethods(IN MM_AUTH_METHODS mmAuth, IN PTCHAR pszPrefix);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\print.cpp ===
/////////////////////////////////////////////////////////////
// Copyright(c) 1998, Microsoft Corporation
//                         
// print.cpp          
//                              
// Created on 3/2/00 by DKalin
// Revisions:                  
//                            
// Print routines for ipsecpol tool
//                                                       
/////////////////////////////////////////////////////////////

#include "ipseccmd.h"

#define PRINT _ftprintf
#define OUTSTREAM stdout

// comment this if you don't want debug spew
//#define DEBUG

// The following is to format the output so that  understandable text can be printed
// instead of DWORDs or ints

TCHAR esp_algo[][25]= {_T("NONE"),
						_T("DES"),
						_T("Unknown"),
						_T("3DES"),
						_T("IPSEC_ESP_MAX")};

TCHAR ah_algo[][25]= {_T("NONE"),
					   _T("MD5"),
					   _T("SHA1"),
					   _T("IPSEC_AH_MAX")};

TCHAR operation[][25]= {_T("None"),
					   _T("Authentication"),
					   _T("Encryption"),
					   _T("Compression"),
					   _T("SA Delete")};

TCHAR oakley_states[][50]= {_T("MainMode No State"),
					   _T("MainMode SA Setup"),
					   _T("MainMode Key Exchange"),
					   _T("MainMode Key Authorizated"),
					   _T("AG Normal State"),
					   _T("AG Init Exchange"),
					   _T("AG Authorization"),
					   _T("QuickMode SA Accept"),
					   _T("QuickMode Awaiting Authorization"),
					   _T("QuickMode Idle"),
					   _T("QuickMode Waiting for Connection")
						};

TCHAR oak_auth[][25]= {_T("Unknown"),
					   _T("Preshared Key"),
					   _T("DSS Signature"),
					   _T("RSA (Cert) Signature"),
					   _T("RSA (Cert) Encryption"),
					   _T("Kerberos")
						};
TCHAR if_types[][25]= {_T("Unknown"),
					   _T("All"),
					   _T("LAN"),
					   _T("Dialup"),
					   _T("All")
						};


/////////////////////// UTILITY FUNCTIONS //////////////////////////
// PrintQMOffer will print quick mode policy offer with given prefix string (actually two prefix strings)
// Parms:   IN qmOffer    - IPSEC_QM_OFFER structure
//          IN pszPrefix  - prefix string
//          IN pszPrefix2 - 2nd prefix string (will be added to 1st)
// Returns: None

void PrintQMOffer(IN IPSEC_QM_OFFER qmOffer, IN PTCHAR pszPrefix, IN PTCHAR pszPrefix2)
{
	int i;

#ifdef DEBUG
	printf("DEBUG - number of Algos for this offer is %d\n", qmOffer.dwNumAlgos);
#endif

	for (i = 0; i < (int) qmOffer.dwNumAlgos; i++)
	{
		//print algo
		PRINT(OUTSTREAM,TEXT("%s%sAlgo #%d : "), pszPrefix, pszPrefix2, i+1);
#ifdef DEBUG
	        printf("DEBUG - operation code is %d\n", qmOffer.Algos[i].Operation);
#endif
		PRINT(OUTSTREAM,TEXT("%s"), operation[qmOffer.Algos[i].Operation]);

		switch (qmOffer.Algos[i].Operation)
		{
			case ENCRYPTION:
				PRINT(OUTSTREAM,TEXT(" %s"), esp_algo[qmOffer.Algos[i].uAlgoIdentifier]);
				if (qmOffer.Algos[i].uSecAlgoIdentifier != HMAC_AH_NONE)
				{
					PRINT(OUTSTREAM,TEXT(" %s"), ah_algo[qmOffer.Algos[i].uSecAlgoIdentifier]);
				}
				if (qmOffer.Algos[i].uAlgoKeyLen != 0 || qmOffer.Algos[i].uAlgoRounds != 0)
				{
					PRINT(OUTSTREAM,TEXT(" (%lubytes/%lurounds)"), qmOffer.Algos[i].uAlgoKeyLen, qmOffer.Algos[i].uAlgoRounds);
				}

				break;
			case AUTHENTICATION:
				PRINT(OUTSTREAM,TEXT(" %s"), ah_algo[qmOffer.Algos[i].uAlgoIdentifier]);
				if (qmOffer.Algos[i].uAlgoKeyLen != 0 || qmOffer.Algos[i].uAlgoRounds != 0)
				{
					PRINT(OUTSTREAM,TEXT(" (%lubytes/%lurounds)"), qmOffer.Algos[i].uAlgoKeyLen, qmOffer.Algos[i].uAlgoRounds);
				}

				break;
			case NONE:
			case COMPRESSION:
			case SA_DELETE:
			default:
				break;
		}

		if (qmOffer.Algos[i].MySpi != 0 || qmOffer.Algos[i].PeerSpi != 0)
		{
			PRINT(OUTSTREAM,TEXT("\n%s%s\t "), pszPrefix, pszPrefix2);
		}

		if (qmOffer.Algos[i].MySpi != 0)
		{
			PRINT(OUTSTREAM,TEXT(" MySpi %lu"), qmOffer.Algos[i].MySpi);
		}
		if (qmOffer.Algos[i].PeerSpi != 0)
		{
			PRINT(OUTSTREAM,TEXT(" PeerSpi %lu"), qmOffer.Algos[i].PeerSpi);
		}

		PRINT(OUTSTREAM,TEXT("\n"));
	}

    PRINT(OUTSTREAM,TEXT("%s%sPFS : %s"), pszPrefix, pszPrefix2, qmOffer.bPFSRequired ? _T("True") : _T("False"));
	if (qmOffer.bPFSRequired)
	{
		PRINT(OUTSTREAM,TEXT(" (Group %lu)"), qmOffer.dwPFSGroup);
	}
    PRINT(OUTSTREAM,TEXT(", Lifetime %luKbytes/%luseconds\n"), qmOffer.Lifetime.uKeyExpirationKBytes, qmOffer.Lifetime.uKeyExpirationTime);

	if (qmOffer.dwFlags != 0)
	{
		PRINT(OUTSTREAM,TEXT("%s%sFlags : %lu\n"), pszPrefix, pszPrefix2, qmOffer.dwFlags);
	}
} // end of PrintQMOffer

// PrintFilterAction will print filter action info with given prefix string
// Parms:   IN qmPolicy  - QM policy (aka filter action) information
//          IN pszPrefix - prefix string
// Returns: None

void PrintFilterAction(IN IPSEC_QM_POLICY qmPolicy, IN PTCHAR pszPrefix)
{
    TCHAR*  StringTxt = new TCHAR[STRING_TEXT_SIZE];
	int i;

	// continue here
	// dump all data
	PRINT(OUTSTREAM,TEXT("%sName : %s\n"), pszPrefix, qmPolicy.pszPolicyName );
	StringFromGUID2(qmPolicy.gPolicyID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT("%sPolicy Id : %s\n"), pszPrefix, StringTxt);
	PRINT(OUTSTREAM,TEXT("%sFlags : %lu %s %s %s\n"), pszPrefix, qmPolicy.dwFlags,
		(qmPolicy.dwFlags & IPSEC_QM_POLICY_TUNNEL_MODE) ? _T("(Tunnel)") : _T(""),
		(qmPolicy.dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY) ? _T("(Default)") : _T(""),
		(qmPolicy.dwFlags & IPSEC_QM_POLICY_ALLOW_SOFT) ? _T("(Allow Soft)") : _T(""));

	for (i = 0; i < (int) qmPolicy.dwOfferCount; i++)
	{
		PRINT(OUTSTREAM,TEXT("%sOffer #%d\n"), pszPrefix, i+1);
		PrintQMOffer(qmPolicy.pOffers[i], pszPrefix, TEXT("\t"));
	}
} // end of PrintFilterAction

// PrintFilter will print [transport] filter info with (optional) filter action info embedded
// Parms:   IN tFilter        - filter information (TRANSPORT_FILTER structure)
//			IN bPrintNegPol   - should we print the filter action info
//			IN bPrintSpecific - should we print specific filter information
// Returns: FALSE if error occured while retrieving filter action info
//          TRUE if everything is OK

BOOL PrintFilter (IN TRANSPORT_FILTER tFilter, IN BOOL bPrintNegPol, IN BOOL bPrintSpecific)
{
	int i;
    TCHAR * StringTxt = new TCHAR[STRING_TEXT_SIZE];
	DWORD hr;

	PRINT(OUTSTREAM,TEXT(" Name : %s\n"),tFilter.pszFilterName );
	StringFromGUID2(tFilter.gFilterID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT(" Filter Id : %s\n"),StringTxt);
	StringFromGUID2(tFilter.gPolicyID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT(" Policy Id : %s\n"),StringTxt);
	if (bPrintNegPol && (tFilter.InboundFilterFlag == NEGOTIATE_SECURITY || tFilter.OutboundFilterFlag == NEGOTIATE_SECURITY) ) 
	{
		// printing negpol only if we have actual negpol
		// need additional check for specific filter
		if (!bPrintSpecific || 
			(tFilter.dwDirection == FILTER_DIRECTION_INBOUND && tFilter.InboundFilterFlag == NEGOTIATE_SECURITY) ||
			(tFilter.dwDirection == FILTER_DIRECTION_OUTBOUND && tFilter.OutboundFilterFlag == NEGOTIATE_SECURITY))
		{
			// get qm policy and print it, right here
			PIPSEC_QM_POLICY pipsqmp;

			if ((hr = GetQMPolicyByID(szServ, tFilter.gPolicyID, &pipsqmp)) != ERROR_SUCCESS)
			{
//				PRINT(OUTSTREAM,TEXT("GetQMPolicyByID failed with error %d\n"), hr); 
				return FALSE;
			}

			PrintFilterAction(pipsqmp[0], TEXT("\t"));
			SPDApiBufferFree(pipsqmp);
		}
	}

	PRINT(OUTSTREAM,TEXT(" Src Addr : "));
	PrintAddr(tFilter.SrcAddr);
	PRINT(OUTSTREAM,TEXT("\n"));
	PRINT(OUTSTREAM,TEXT(" Des Addr : "));
	PrintAddr(tFilter.DesAddr);
	PRINT(OUTSTREAM,TEXT("\n"));
	PRINT(OUTSTREAM,TEXT(" Protocol : %lu  Src Port : %u  Des Port : %u\n"), tFilter.Protocol.dwProtocol, tFilter.SrcPort.wPort, tFilter.DesPort.wPort);
    if (!bPrintSpecific || tFilter.dwDirection == FILTER_DIRECTION_INBOUND)
	{
		if (tFilter.InboundFilterFlag == PASS_THRU)
			PRINT(OUTSTREAM,TEXT(" Inbound Passthru\n"));
		if (tFilter.InboundFilterFlag == BLOCKING)
			PRINT(OUTSTREAM,TEXT(" Inbound Block\n"));
	}
    if (!bPrintSpecific || tFilter.dwDirection == FILTER_DIRECTION_OUTBOUND)
	{
		if (tFilter.OutboundFilterFlag == PASS_THRU)
			PRINT(OUTSTREAM,TEXT(" Outbound Passthru\n"));
		if (tFilter.OutboundFilterFlag == BLOCKING)
			PRINT(OUTSTREAM,TEXT(" Outbound Block\n"));
	}

	if (bPrintSpecific)
	{
		PRINT(OUTSTREAM,TEXT(" Direction : %s, Weight : %lu\n"), 
			(tFilter.dwDirection == FILTER_DIRECTION_INBOUND) ? _T("Inbound") : ((tFilter.dwDirection == FILTER_DIRECTION_OUTBOUND) ? _T("Outbound") : _T("Error")),
			tFilter.dwWeight);
	}
	else
	{
		PRINT(OUTSTREAM,TEXT(" Mirrored : %s\n"), tFilter.bCreateMirror ? _T("True") : _T("False"));
	}

	PRINT(OUTSTREAM,TEXT(" Interface Type : %s\n"), if_types[tFilter.InterfaceType]);

	return TRUE;
} // end of PrintFilter

// PrintTunnelFilter will print tunnel filter info with (optional) filter action info embedded
// Parms:   IN tFilter        - filter information (TUNNEL_FILTER structure)
//			IN bPrintNegPol   - should we print the filter action info
//			IN bPrintSpecific - should we print specific filter information
// Returns: FALSE if error occured while retrieving filter action info
//          TRUE if everything is OK

BOOL PrintTunnelFilter (IN TUNNEL_FILTER tFilter, IN BOOL bPrintNegPol, IN BOOL bPrintSpecific)
{
	int i;
    TCHAR * StringTxt = new TCHAR[STRING_TEXT_SIZE];
	DWORD hr;

	PRINT(OUTSTREAM,TEXT(" Name : %s\n"),tFilter.pszFilterName );
	StringFromGUID2(tFilter.gFilterID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT(" Filter Id : %s\n"),StringTxt);
	StringFromGUID2(tFilter.gPolicyID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT(" Policy Id : %s\n"),StringTxt);
	if (bPrintNegPol && (tFilter.InboundFilterFlag == NEGOTIATE_SECURITY || tFilter.OutboundFilterFlag == NEGOTIATE_SECURITY) ) 
	{
		// printing negpol only if we have actual negpol
		// need additional check for specific filter
		if (!bPrintSpecific || 
			(tFilter.dwDirection == FILTER_DIRECTION_INBOUND && tFilter.InboundFilterFlag == NEGOTIATE_SECURITY) ||
			(tFilter.dwDirection == FILTER_DIRECTION_OUTBOUND && tFilter.OutboundFilterFlag == NEGOTIATE_SECURITY))
		{
			// get qm policy and print it, right here
			PIPSEC_QM_POLICY pipsqmp;

			if ((hr = GetQMPolicyByID(szServ, tFilter.gPolicyID, &pipsqmp)) != ERROR_SUCCESS)
			{
//				PRINT(OUTSTREAM,TEXT("GetQMPolicyByID failed with error %d\n"), hr); 
				return FALSE;
			}

			PrintFilterAction(pipsqmp[0], TEXT("\t"));
			SPDApiBufferFree(pipsqmp);
		}
	}

	PRINT(OUTSTREAM,TEXT(" Src Addr : "));
	PrintAddr(tFilter.SrcAddr);
	PRINT(OUTSTREAM,TEXT("\n"));
	PRINT(OUTSTREAM,TEXT(" Des Addr : "));
	PrintAddr(tFilter.DesAddr);
	PRINT(OUTSTREAM,TEXT("\n"));
	PRINT(OUTSTREAM,TEXT(" Src Tunnel Addr : "));
	PrintAddr(tFilter.SrcTunnelAddr);
	PRINT(OUTSTREAM,TEXT("\n"));
	PRINT(OUTSTREAM,TEXT(" Des Tunnel Addr : "));
	PrintAddr(tFilter.DesTunnelAddr);
	PRINT(OUTSTREAM,TEXT("\n"));
	PRINT(OUTSTREAM,TEXT(" Protocol : %lu  Src Port : %u  Des Port : %u\n"), tFilter.Protocol.dwProtocol, tFilter.SrcPort.wPort, tFilter.DesPort.wPort);
    if (!bPrintSpecific || tFilter.dwDirection == FILTER_DIRECTION_INBOUND)
	{
		if (tFilter.InboundFilterFlag == PASS_THRU)
			PRINT(OUTSTREAM,TEXT(" Inbound Passthru\n"));
		if (tFilter.InboundFilterFlag == BLOCKING)
			PRINT(OUTSTREAM,TEXT(" Inbound Block\n"));
	}
    if (!bPrintSpecific || tFilter.dwDirection == FILTER_DIRECTION_OUTBOUND)
	{
		if (tFilter.OutboundFilterFlag == PASS_THRU)
			PRINT(OUTSTREAM,TEXT(" Outbound Passthru\n"));
		if (tFilter.OutboundFilterFlag == BLOCKING)
			PRINT(OUTSTREAM,TEXT(" Outbound Block\n"));
	}

	if (bPrintSpecific)
	{
		PRINT(OUTSTREAM,TEXT(" Direction : %s, Weight : %lu\n"), 
			(tFilter.dwDirection == FILTER_DIRECTION_INBOUND) ? _T("Inbound") : ((tFilter.dwDirection == FILTER_DIRECTION_OUTBOUND) ? _T("Outbound") : _T("Error")),
			tFilter.dwWeight);
	}
	else
	{
		PRINT(OUTSTREAM,TEXT(" Mirrored : %s\n"), tFilter.bCreateMirror ? _T("True") : _T("False"));
	}

	PRINT(OUTSTREAM,TEXT(" Interface Type : %s\n"), if_types[tFilter.InterfaceType]);

	return TRUE;
} // end of PrintFilter

// PrintMMFilter will print mainmode filter info with (optional) mmpolicy info embedded
// Parms:   IN mmFilter       - Mainmode filter
//			IN bPrintNegPol   - should we print the mmpolicy info
//          IN bPrintSpecific - should we print specific filter info
// Returns: FALSE if any error, TRUE if OK

BOOL PrintMMFilter (IN MM_FILTER mmFilter, IN BOOL bPrintNegPol, IN BOOL bPrintSpecific)
{
	int i;
    TCHAR * StringTxt = new TCHAR[STRING_TEXT_SIZE];
	DWORD hr;

	PRINT(OUTSTREAM,TEXT(" Name : %s\n"),mmFilter.pszFilterName );
	StringFromGUID2(mmFilter.gFilterID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT(" Filter Id : %s\n"),StringTxt);
	StringFromGUID2(mmFilter.gPolicyID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT(" Policy Id : %s\n"),StringTxt);
	if (bPrintNegPol) 
	{
		// get mm policy and print it, right here
		PIPSEC_MM_POLICY pipsmmp;

		if ((hr = GetMMPolicyByID(szServ, mmFilter.gPolicyID, &pipsmmp)) != ERROR_SUCCESS)
		{
//			PRINT(OUTSTREAM,TEXT("GetMMPolicyByID failed with error %d\n"), hr); 
			return FALSE;
		}

		PrintMMPolicy(pipsmmp[0], TEXT("\t"));
		SPDApiBufferFree(pipsmmp);
	}

	PRINT(OUTSTREAM,TEXT(" Src Addr : "));
	PrintAddr(mmFilter.SrcAddr);
	PRINT(OUTSTREAM,TEXT("\n"));
	PRINT(OUTSTREAM,TEXT(" Des Addr : "));
	PrintAddr(mmFilter.DesAddr);
	PRINT(OUTSTREAM,TEXT("\n"));

	if (bPrintSpecific)
	{
		PRINT(OUTSTREAM,TEXT(" Direction : %s, Weight : %lu\n"), 
			(mmFilter.dwDirection == FILTER_DIRECTION_INBOUND) ? _T("Inbound") : ((mmFilter.dwDirection == FILTER_DIRECTION_OUTBOUND) ? _T("Outbound") : _T("Error")),
			mmFilter.dwWeight);
	}
	else
	{
		PRINT(OUTSTREAM,TEXT(" Mirrored : %s\n"), mmFilter.bCreateMirror ? _T("True") : _T("False"));
	}

	PRINT(OUTSTREAM,TEXT(" Interface Type : %s\n"), if_types[mmFilter.InterfaceType]);

	StringFromGUID2(mmFilter.gMMAuthID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT(" Auth Methods Id: %s\n"),StringTxt);
	if (bPrintNegPol)
	{
		//print auth methods as well
		PMM_AUTH_METHODS pmmam;

		if ((hr = GetMMAuthMethods(szServ, mmFilter.gMMAuthID, &pmmam)) != ERROR_SUCCESS)
		{
//			PRINT(OUTSTREAM,TEXT("GetMMAuthMethods failed with error %d\n"), hr); 
			return FALSE;
		}

		for (i = 0; i < (int) pmmam[0].dwNumAuthInfos; i++)
		{
			PRINT(OUTSTREAM,TEXT("\tAM #%d : "), i+1);
			PrintAuthInfo(pmmam[0].pAuthenticationInfo[i]);
			PRINT(OUTSTREAM,TEXT("\n"));
		}
		SPDApiBufferFree(pmmam);
	}

	return TRUE;

} // end of PrintMMFilter


// PrintMMAuthMethods will print main mode authentication methods information with given prefix string
// Parms:   IN mmAuth    - MM_AUTH_METHODS structure
//          IN pszPrefix - prefix string
// Returns: None

void PrintMMAuthMethods(IN MM_AUTH_METHODS mmAuth, IN PTCHAR pszPrefix)
{
	int i;
    TCHAR * StringTxt = new TCHAR[STRING_TEXT_SIZE];
	DWORD hr;

	StringFromGUID2(mmAuth.gMMAuthID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT("%sAuth Methods Id: %s\n"), pszPrefix, StringTxt);
	for (i = 0; i < (int) mmAuth.dwNumAuthInfos; i++)
	{
		PRINT(OUTSTREAM,TEXT("%s\tAM #%d : "), pszPrefix, i+1);
		PrintAuthInfo(mmAuth.pAuthenticationInfo[i]);
		PRINT(OUTSTREAM,TEXT("\n"));
	}
}

// PrintMMPolicy will print main mode policy information with given prefix string
// Parms:   IN mmPolicy  - IPSEC_MM_POLICY structure
//          IN pszPrefix - prefix string
// Returns: None

void PrintMMPolicy(IN IPSEC_MM_POLICY mmPolicy, IN PTCHAR pszPrefix)
{
	int i;
    TCHAR * StringTxt = new TCHAR[STRING_TEXT_SIZE];

	PRINT(OUTSTREAM,TEXT("%sName : %s\n"), pszPrefix, mmPolicy.pszPolicyName );
	StringFromGUID2(mmPolicy.gPolicyID, StringTxt, STRING_TEXT_SIZE);
	PRINT(OUTSTREAM,TEXT("%sPolicy Id : %s\n"), pszPrefix, StringTxt);
	PRINT(OUTSTREAM,TEXT("%sFlags : %lu %s %s\n"), pszPrefix, mmPolicy.dwFlags,
		(mmPolicy.dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY) ? _T("(Default)") : _T(""),
		(mmPolicy.dwFlags & IPSEC_MM_POLICY_ENABLE_DIAGNOSTICS) ? _T("(Enable Diag)") : _T(""));

	if (mmPolicy.uSoftSAExpirationTime != 0)
	{
		PRINT(OUTSTREAM,TEXT("%sSoft SA expiration time : %lu\n"), pszPrefix, mmPolicy.uSoftSAExpirationTime);
	}
	for (i = 0; i < (int) mmPolicy.dwOfferCount; i++)
	{
		PRINT(OUTSTREAM,TEXT("%sOffer #%d\n"), pszPrefix, i+1);
		PrintMMOffer(mmPolicy.pOffers[i], pszPrefix, TEXT("\t"));
	}

} // end of PrintMMPolicy
  
// PrintMMOffer will print main mode policy offer with given prefix string (actually two prefix strings)
// Parms:   IN mmOffer    - IPSEC_MM_OFFER structure
//          IN pszPrefix  - prefix string
//          IN pszPrefix2 - 2nd prefix string (will be added to 1st)
// Returns: None

void PrintMMOffer(IN IPSEC_MM_OFFER mmOffer, IN PTCHAR pszPrefix, IN PTCHAR pszPrefix2)
{
	PRINT(OUTSTREAM,TEXT("%s%s%s"), pszPrefix, pszPrefix2, esp_algo[mmOffer.EncryptionAlgorithm.uAlgoIdentifier]);
	if (mmOffer.EncryptionAlgorithm.uAlgoKeyLen != 0 || mmOffer.EncryptionAlgorithm.uAlgoRounds != 0)
	{
		PRINT(OUTSTREAM,TEXT("(%lubytes/%lurounds)"), mmOffer.EncryptionAlgorithm.uAlgoKeyLen, mmOffer.EncryptionAlgorithm.uAlgoRounds);
	}

	PRINT(OUTSTREAM,TEXT(" %s"), ah_algo[mmOffer.HashingAlgorithm.uAlgoIdentifier]);
	if (mmOffer.HashingAlgorithm.uAlgoKeyLen != 0 || mmOffer.HashingAlgorithm.uAlgoRounds != 0)
	{
		PRINT(OUTSTREAM,TEXT("(%lubytes/%lurounds)"), mmOffer.HashingAlgorithm.uAlgoKeyLen, mmOffer.HashingAlgorithm.uAlgoRounds);
	}

	PRINT(OUTSTREAM,TEXT("  DH Group %lu\n"), mmOffer.dwDHGroup);

    PRINT(OUTSTREAM,TEXT("%s%sQuickmode limit : %lu, Lifetime %luKbytes/%luseconds\n"), pszPrefix, pszPrefix2, mmOffer.dwQuickModeLimit, 
		mmOffer.Lifetime.uKeyExpirationKBytes, mmOffer.Lifetime.uKeyExpirationTime);

	if (mmOffer.dwFlags != 0)
	{
		PRINT(OUTSTREAM,TEXT("%s%sFlags : %lu\n"), pszPrefix, pszPrefix2, mmOffer.dwFlags);
	}
} // end of PrintMMOffer

// PrintAddr will print ADDR structure (address used in SPD)
// Parms:   IN addr       - ADDR structure
// Returns: None

void PrintAddr(IN ADDR addr)
{
    struct in_addr inAddr;
    TCHAR * StringTxt = new TCHAR[STRING_TEXT_SIZE];

	if (addr.AddrType == IP_ADDR_UNIQUE && addr.uIpAddr == IP_ADDRESS_ME)
	{
		PRINT(OUTSTREAM,TEXT("Me"));
	}
	else if (addr.AddrType == IP_ADDR_SUBNET && addr.uIpAddr == SUBNET_ADDRESS_ANY && addr.uSubNetMask == SUBNET_MASK_ANY)
	{
		PRINT(OUTSTREAM,TEXT("Any"));
	}
	else if (addr.AddrType == IP_ADDR_UNIQUE)
	{
	    inAddr.s_addr = addr.uIpAddr;
		PRINT(OUTSTREAM,TEXT("%S"), inet_ntoa(inAddr)) ;
	}
	else if (addr.AddrType == IP_ADDR_SUBNET)
	{
	    inAddr.s_addr = addr.uIpAddr;
		PRINT(OUTSTREAM,TEXT("subnet %S "), inet_ntoa(inAddr)) ;
	    inAddr.s_addr = addr.uSubNetMask;
		PRINT(OUTSTREAM,TEXT("mask %S"), inet_ntoa(inAddr)) ;
	}
        else if (addr.AddrType == IP_ADDR_INTERFACE)
        {
  	     StringFromGUID2(addr.gInterfaceID, StringTxt, STRING_TEXT_SIZE);
  	     PRINT(OUTSTREAM,TEXT("interface id %s "), StringTxt);
             if (addr.uIpAddr != IP_ADDRESS_ME)
             {
		inAddr.s_addr = addr.uIpAddr;
		PRINT(OUTSTREAM,TEXT("IP Addr %S "), inet_ntoa(inAddr)) ;
             }
        }
} // end of PrintAddr

// PrintAuthInfo will print authentication method information
// Parms:   IN authInfo - IPSEC_MM_AUTH_INFO structure
// Returns: None

void PrintAuthInfo(IN IPSEC_MM_AUTH_INFO authInfo)
{
	int i;
	DWORD   dwReturn;
    WCHAR   *pszCertStr, *pTmp;

	PRINT(OUTSTREAM,TEXT("%s"), oak_auth[authInfo.AuthMethod]);
	if (authInfo.AuthMethod == IKE_PRESHARED_KEY)
	{
		// print preshared key
		PRINT(OUTSTREAM,TEXT(" : \""));
		for (i = 0; i < (int) (authInfo.dwAuthInfoSize/sizeof(TCHAR)); i++)
		{
			PRINT(OUTSTREAM,TEXT("%c"), *(((TCHAR*)authInfo.pAuthInfo)+i));
		}
		PRINT(OUTSTREAM,TEXT("\""));
	}
	else if (authInfo.AuthMethod == IKE_RSA_SIGNATURE || authInfo.AuthMethod == IKE_RSA_ENCRYPTION)
	{
		// convert and print cert
		PRINT(OUTSTREAM,TEXT(" : \""));
 	    dwReturn = CM_DecodeName(authInfo.pAuthInfo, authInfo.dwAuthInfoSize, &pszCertStr);
		if (dwReturn != ERROR_SUCCESS)
		{
			PRINT(OUTSTREAM,TEXT("Unknown"));
		}
		else
		{
			for (pTmp = pszCertStr; *pTmp; pTmp++)
			{
				PRINT(OUTSTREAM,TEXT("%c"), *pTmp);
			}
			delete [] pszCertStr;
		}
		PRINT(OUTSTREAM,TEXT("\""));
	}
} // end of PrintAuthInfo


void PrintPolicies(IN IPSEC_IKE_POLICY& IPSecIkePol)
{
	int i;
	IPSEC_IKE_POLICY TmpPol; // for checks
	TCHAR szPrefix[] = TEXT(" ");

	// set TmpPol to 0's
	memset(&TmpPol, 0, sizeof(TmpPol));

   PRINT(OUTSTREAM,TEXT("==========================\n"));
   if (IPSecIkePol.dwNumMMFilters != 0)
   {
      for (i = 0; i < (int) IPSecIkePol.dwNumMMFilters; ++i)
      {
         PRINT(OUTSTREAM,TEXT("MM Filter %d\n"),i);
         PrintMMFilter(IPSecIkePol.pMMFilters[i], FALSE, FALSE);
         PRINT(OUTSTREAM,TEXT("==========================\n"));
      }
   }
   if (IPSecIkePol.dwNumFilters != 0)
   {
      for (i = 0; i < (int) IPSecIkePol.dwNumFilters; ++i)
      {
         PRINT(OUTSTREAM,TEXT("Filter %d\n"),i);
		 if (IPSecIkePol.QMFilterType == QM_TRANSPORT_FILTER)
		 {
			PrintFilter(IPSecIkePol.pTransportFilters[i], FALSE, FALSE);
		 }
		 else
		 {
			 // tunnel
			PrintTunnelFilter(IPSecIkePol.pTunnelFilters[i], FALSE, FALSE);
		 }
         PRINT(OUTSTREAM,TEXT("==========================\n"));
      }
   }
   PRINT(OUTSTREAM,TEXT("Oakley Auth: \n"));
	for (i = 0; i < (int) IPSecIkePol.AuthInfos.dwNumAuthInfos; i++)
	{
		PRINT(OUTSTREAM,TEXT("\tAM #%d : "), i+1);
		PrintAuthInfo(IPSecIkePol.AuthInfos.pAuthenticationInfo[i]);
		PRINT(OUTSTREAM,TEXT("\n"));
	}
   PRINT(OUTSTREAM,TEXT("==========================\n"));

   // continue here
   // mm policy
   if (memcmp(&IPSecIkePol.IkePol, &TmpPol.IkePol, sizeof(TmpPol.IkePol)) != 0)
   {
	   PRINT(OUTSTREAM,TEXT("MM Policy: \n"));
	   PrintMMPolicy(IPSecIkePol.IkePol, szPrefix);
   }

   PRINT(OUTSTREAM,TEXT("==========================\n"));
   // qm policy
   if (memcmp(&IPSecIkePol.IpsPol, &TmpPol.IpsPol, sizeof(TmpPol.IpsPol)) != 0)
   {
	   PRINT(OUTSTREAM,TEXT("QM Policy: \n"));
	   PrintFilterAction(IPSecIkePol.IpsPol, szPrefix);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\pol2stor.h ===
// define UNICODE for this module so linking works

#ifndef _POL2STORE_H_
#define _POL2STORE_H_

const time_t P2STORE_DEFAULT_POLLINT = 60 * 180;
const HRESULT P2STORE_MISSING_NAME = 0x00000013;

// these are the versions of storage that we want
const DWORD     P2S_MAJOR_VER = 0x00010000;
const DWORD     P2S_MINOR_VER = 0x00000000;

class  IPSECPolicyToStorage
{
public:

   // these just to initialization/deleting,
   // you must call Open to do anything useful
   IPSECPolicyToStorage();
   ~IPSECPolicyToStorage();

// opens the location and establishes
   // an ipsec policy to work with
   HRESULT
      Open(IN DWORD location,
           IN LPTSTR name,
           IN LPTSTR szPolicyName,
           IN LPTSTR szDescription = NULL,
           IN time_t tPollingInterval = P2STORE_DEFAULT_POLLINT,
           IN bool   bUseExisting = false);

// add rules to the policy
   HRESULT
      AddRule(IN IPSEC_IKE_POLICY ,
                     IN PSTORAGE_INFO    pStorageInfo = NULL);
   HRESULT
      AddDefaultResponseRule( );

   // associates an ISAKMP policy
   HRESULT SetISAKMPPolicy(IPSEC_MM_POLICY);

   HRESULT
      UpdateRule(
                    IN PIPSEC_NFA_DATA  pRule,
                    IN IPSEC_IKE_POLICY IpsecIkePol,
                    IN PSTORAGE_INFO    pStorageInfo = NULL);


   bool IsOpen()            { return mybIsOpen; }
   bool IsPolicyInStorage() { return mybPolicyExists; }

   // will return a list of filters given a filter spec
   // WILL NOT COMMIT to the storage
   PIPSEC_FILTER_DATA IPSECPolicyToStorage::MakeFilters(
                        T2P_FILTER *Filters,
                        UINT NumFilters,
                        LPWSTR);

   PIPSEC_POLICY_DATA GetPolicy() { return myIPSECPolicy; }
   HANDLE GetStorageHandle() { return myPolicyStorage; }
   DWORD SetAssignedPolicy(PIPSEC_POLICY_DATA p)
   {
           PIPSEC_POLICY_DATA pActive = NULL;
           DWORD  dwReturn = ERROR_SUCCESS;
	   dwReturn = IsPolicyInStorage() ?
                 (IPSecGetAssignedPolicyData(myPolicyStorage, &pActive),
                  pActive ? IPSecUnassignPolicy(myPolicyStorage, pActive->PolicyIdentifier) : 0,
                  IPSecAssignPolicy(myPolicyStorage, p->PolicyIdentifier)) :
                  ERROR_ACCESS_DENIED;
           // if (pActive)   IPSecFreePolicyData(pActive);
           // polstore AVs if something inside the policy is missing
           return dwReturn;
   }

   // this is temp patch
   static LPVOID ReallocPolMem (LPVOID pOldMem, DWORD cbOld, DWORD cbNew);

private:
   void TryToCreatePolicy();
   PIPSEC_NEGPOL_DATA
      MakeNegotiationPolicy(IPSEC_QM_POLICY IpsPol,
                            LPWSTR);
   PIPSEC_NEGPOL_DATA MakeDefaultResponseNegotiationPolicy ( );

   PIPSEC_NFA_DATA
      MakeRule(IN IPSEC_IKE_POLICY IpsecIkePol, IN PSTORAGE_INFO pStorageInfo = NULL);

   PIPSEC_NFA_DATA MakeDefaultResponseRule ( );
 
   HANDLE               myPolicyStorage;
   PIPSEC_POLICY_DATA   myIPSECPolicy;
   bool                 mybIsOpen;
   bool                 mybPolicyExists;
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\query.h ===
/////////////////////////////////////////////////////////////
// Copyright(c) 2001, Microsoft Corporation
//
// query.h
//
// Created on 1/18/01 by DKalin
// Revisions:
/////////////////////////////////////////////////////////////

#ifndef _QUERY_H_
#define _QUERY_H_

// my constants
#define KEYWORD_SHOW     "show"
#define KEYWORD_FILTERS  "filters"
#define KEYWORD_POLICIES "policies"
#define KEYWORD_AUTH     "auth"
#define KEYWORD_STATS    "stats"
#define KEYWORD_SAS      "sas"
#define KEYWORD_ALL      "all"


// process query command line
// accept command line (argc/argv) and the index where show flags start
// return 0 if command completed successfully, 
//        IPSECCMD_USAGE if there is usage error,
//        any other value indicates failure during execution (gets passed up)
//
// IMPORTANT: we assume that main module provide us with remote vs. local machine information
//            in the global variables
//
int ipseccmd_show_main ( int argc, char** argv, int start_index );

// run SPD query and display results, uses global flags to determine what needs to be printed
int do_show ( );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\spdutil.cpp ===
/////////////////////////////////////////////////////////////
// Copyright(c) 2001, Microsoft Corporation
//
// spdutil.cpp
//
// Created on 3/27/01 by DKalin
// Revisions:
// File created 3/27/01 DKalin
//
// Implementation for the auxiliary functions for text to policy conversion routines
//
// Separated from generic routines in text2pol.cpp and text2spd.cpp
//
/////////////////////////////////////////////////////////////

#include "ipseccmd.h"

int isdnsname(char *szStr)
{
   // if there is an alpha character in the string,
   // then we consider a DNS name
   if ( szStr )
   {
      for (UINT i = 0; i < strlen(szStr); ++i)
      {
         if ( isalpha(szStr[i]) )
            return 1;
      }
   }

   return 0;
}

// takes inFilter and reflects it to outFilter
// creates GUID and name for outFilter
bool MirrorFilter(IN T2P_FILTER inFilter, OUT T2P_FILTER & outFilter)
{
   bool  bReturn = true;

   memset(&outFilter, 0, sizeof(T2P_FILTER));
   outFilter.QMFilterType = inFilter.QMFilterType;

   if (inFilter.QMFilterType != QM_TUNNEL_FILTER)
   {
	   // process transport
	   // GUID first
      RPC_STATUS RpcStat = UuidCreate(&outFilter.TransportFilter.gFilterID);
      if (RpcStat != RPC_S_OK && RpcStat != RPC_S_UUID_LOCAL_ONLY)
      {
         sprintf(STRLASTERR, "Couldn't get GUID for mirror filter - UuidCreate failed with status: %ul\n",
                 RpcStat);
         WARN;
         bReturn = false;
      }
	  if (bReturn)
	  {
		  // now name, add " - Mirror"
		  WCHAR   wszMirrorSuffix[] = L" - Mirror";
		  int iNameLen = 0;
		  if (inFilter.TransportFilter.pszFilterName != NULL)
		  {
			  iNameLen = wcslen(inFilter.TransportFilter.pszFilterName);
		  }
		  WCHAR*  pwszTmp = new WCHAR[iNameLen+wcslen(wszMirrorSuffix)+1];
		  assert(pwszTmp != NULL);

		  wcscpy(pwszTmp, inFilter.TransportFilter.pszFilterName);
		  wcscat(pwszTmp, wszMirrorSuffix);
		  outFilter.TransportFilter.pszFilterName = pwszTmp;
	  }

	  // direction
	  outFilter.TransportFilter.dwDirection = inFilter.TransportFilter.dwDirection;
	  if (inFilter.TransportFilter.dwDirection == FILTER_DIRECTION_INBOUND)
	  {
		  outFilter.TransportFilter.dwDirection = FILTER_DIRECTION_OUTBOUND;
	  }
	  if (inFilter.TransportFilter.dwDirection == FILTER_DIRECTION_OUTBOUND)
	  {
		  outFilter.TransportFilter.dwDirection = FILTER_DIRECTION_INBOUND;
	  }

	  // straight copy stuff
	  outFilter.TransportFilter.InterfaceType = inFilter.TransportFilter.InterfaceType;
	  outFilter.TransportFilter.bCreateMirror = inFilter.TransportFilter.bCreateMirror;
	  outFilter.TransportFilter.dwFlags       = inFilter.TransportFilter.dwFlags;
      outFilter.TransportFilter.Protocol      = inFilter.TransportFilter.Protocol;
	  outFilter.TransportFilter.dwWeight      = inFilter.TransportFilter.dwWeight;
	  outFilter.TransportFilter.gPolicyID     = inFilter.TransportFilter.gPolicyID;

	  // the reflected stuff
	  outFilter.TransportFilter.SrcAddr            = inFilter.TransportFilter.DesAddr;
	  outFilter.TransportFilter.DesAddr            = inFilter.TransportFilter.SrcAddr;
	  outFilter.TransportFilter.SrcPort            = inFilter.TransportFilter.DesPort;
	  outFilter.TransportFilter.DesPort            = inFilter.TransportFilter.SrcPort;
	  outFilter.TransportFilter.InboundFilterFlag  = inFilter.TransportFilter.OutboundFilterFlag;
	  outFilter.TransportFilter.OutboundFilterFlag = inFilter.TransportFilter.InboundFilterFlag;
   }
   else
   {
	   // GUID first
      RPC_STATUS RpcStat = UuidCreate(&outFilter.TunnelFilter.gFilterID);
      if (RpcStat != RPC_S_OK && RpcStat != RPC_S_UUID_LOCAL_ONLY)
      {
         sprintf(STRLASTERR, "Couldn't get GUID for mirror filter - UuidCreate failed with status: %ul\n",
                 RpcStat);
         WARN;
         bReturn = false;
      }
	  if (bReturn)
	  {
		  // now name, add " - Mirror"
		  WCHAR   wszMirrorSuffix[] = L" - Mirror";
		  int iNameLen = 0;
		  if (inFilter.TunnelFilter.pszFilterName != NULL)
		  {
			  iNameLen = wcslen(inFilter.TunnelFilter.pszFilterName);
		  }
		  WCHAR*  pwszTmp = new WCHAR[iNameLen+wcslen(wszMirrorSuffix)+1];
		  assert(pwszTmp != NULL);

		  wcscpy(pwszTmp, inFilter.TunnelFilter.pszFilterName);
		  wcscat(pwszTmp, wszMirrorSuffix);
		  outFilter.TunnelFilter.pszFilterName = pwszTmp;
	  }

	  // direction
	  outFilter.TunnelFilter.dwDirection = inFilter.TunnelFilter.dwDirection;
	  if (inFilter.TunnelFilter.dwDirection == FILTER_DIRECTION_INBOUND)
	  {
		  outFilter.TunnelFilter.dwDirection = FILTER_DIRECTION_OUTBOUND;
	  }
	  if (inFilter.TunnelFilter.dwDirection == FILTER_DIRECTION_OUTBOUND)
	  {
		  outFilter.TunnelFilter.dwDirection = FILTER_DIRECTION_INBOUND;
	  }

	  // straight copy stuff
	  outFilter.TunnelFilter.InterfaceType = inFilter.TunnelFilter.InterfaceType;
	  outFilter.TunnelFilter.bCreateMirror = inFilter.TunnelFilter.bCreateMirror;
	  outFilter.TunnelFilter.dwFlags       = inFilter.TunnelFilter.dwFlags;
      outFilter.TunnelFilter.Protocol      = inFilter.TunnelFilter.Protocol;
	  outFilter.TunnelFilter.dwWeight      = inFilter.TunnelFilter.dwWeight;
	  outFilter.TunnelFilter.gPolicyID     = inFilter.TunnelFilter.gPolicyID;

	  // the reflected stuff
	  outFilter.TunnelFilter.SrcAddr            = inFilter.TunnelFilter.DesAddr;
	  outFilter.TunnelFilter.DesAddr            = inFilter.TunnelFilter.SrcAddr;
	  outFilter.TunnelFilter.SrcTunnelAddr      = inFilter.TunnelFilter.DesTunnelAddr;
	  outFilter.TunnelFilter.DesTunnelAddr      = inFilter.TunnelFilter.SrcTunnelAddr;
	  outFilter.TunnelFilter.SrcPort            = inFilter.TunnelFilter.DesPort;
	  outFilter.TunnelFilter.DesPort            = inFilter.TunnelFilter.SrcPort;
	  outFilter.TunnelFilter.InboundFilterFlag  = inFilter.TunnelFilter.OutboundFilterFlag;
	  outFilter.TunnelFilter.OutboundFilterFlag = inFilter.TunnelFilter.InboundFilterFlag;
   }

   return bReturn;
}

void LoadIkeDefaults(OUT IPSEC_MM_POLICY & IkePol)
{
   IkePol.dwOfferCount = 4;
   IkePol.pOffers = new IPSEC_MM_OFFER[IkePol.dwOfferCount];
   assert(IkePol.pOffers != NULL);
   memset(IkePol.pOffers, 0, sizeof(IPSEC_MM_OFFER) * IkePol.dwOfferCount);

   // init these
   for (UINT i = 0; i < IkePol.dwOfferCount; ++i)
   {
      IkePol.pOffers[i].dwQuickModeLimit = POTF_DEFAULT_P1REKEY_QMS;
      IkePol.pOffers[i].Lifetime.uKeyExpirationKBytes = 0;
      IkePol.pOffers[i].Lifetime.uKeyExpirationTime = POTF_DEFAULT_P1REKEY_TIME;
   }

   IkePol.pOffers[0].EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
   IkePol.pOffers[0].EncryptionAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
   IkePol.pOffers[0].EncryptionAlgorithm.uAlgoRounds = POTF_OAKLEY_ALGOROUNDS;

   IkePol.pOffers[0].HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_SHA1;
   IkePol.pOffers[0].HashingAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;

   IkePol.pOffers[0].dwDHGroup = POTF_OAKLEY_GROUP2;

   IkePol.pOffers[1].EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
   IkePol.pOffers[1].EncryptionAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
   IkePol.pOffers[1].EncryptionAlgorithm.uAlgoRounds = POTF_OAKLEY_ALGOROUNDS;

   IkePol.pOffers[1].HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_MD5;
   IkePol.pOffers[1].HashingAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;

   IkePol.pOffers[1].dwDHGroup = POTF_OAKLEY_GROUP2;

   IkePol.pOffers[2].EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_DES;
   IkePol.pOffers[2].HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_SHA1;
   IkePol.pOffers[2].dwDHGroup = POTF_OAKLEY_GROUP1;

   IkePol.pOffers[3].EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_DES;
   IkePol.pOffers[3].EncryptionAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;
   IkePol.pOffers[3].EncryptionAlgorithm.uAlgoRounds = POTF_OAKLEY_ALGOROUNDS;

   IkePol.pOffers[3].HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_MD5;
   IkePol.pOffers[3].HashingAlgorithm.uAlgoKeyLen = POTF_OAKLEY_ALGOKEYLEN;

   IkePol.pOffers[3].dwDHGroup = POTF_OAKLEY_GROUP1;

}

// Loads the following defaults, in order:
void LoadOfferDefaults(OUT PIPSEC_QM_OFFER & Offers, OUT DWORD & NumOffers)
{
   NumOffers = 4;

   Offers = new IPSEC_QM_OFFER[NumOffers];
   assert(Offers != NULL);
   memset(Offers, 0, sizeof(IPSEC_QM_OFFER) * NumOffers);

   for (DWORD i = 0; i < NumOffers; ++i)
   {
      Offers[i].Lifetime.uKeyExpirationKBytes  = POTF_DEFAULT_P2REKEY_BYTES;
      Offers[i].Lifetime.uKeyExpirationTime   = POTF_DEFAULT_P2REKEY_TIME;
      Offers[i].bPFSRequired = FALSE;
	  Offers[i].dwPFSGroup = 0;
	  Offers[i].dwFlags = 0;
      Offers[i].dwNumAlgos = 1;    // we don't do AND proposals
      Offers[i].Algos[0].Operation = ENCRYPTION;
   }

   Offers[0].Algos[0].uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
   Offers[0].Algos[0].uSecAlgoIdentifier = HMAC_AH_SHA1;

   Offers[1].Algos[0].uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
   Offers[1].Algos[0].uSecAlgoIdentifier = HMAC_AH_MD5;

   Offers[2].Algos[0].uAlgoIdentifier = IPSEC_DOI_ESP_DES;
   Offers[2].Algos[0].uSecAlgoIdentifier = HMAC_AH_SHA1;

   Offers[3].Algos[0].uAlgoIdentifier = IPSEC_DOI_ESP_DES;
   Offers[3].Algos[0].uSecAlgoIdentifier = HMAC_AH_MD5;
}

// generate corresponding mainmode filter for inFilter
// creates name and guid for outFilter
bool GenerateMMFilter(IN T2P_FILTER inFilter, OUT MM_FILTER &outFilter)
{
	bool bReturn = true;

	if (inFilter.QMFilterType == QM_TRANSPORT_FILTER)
	{
		// transport filter
	    // GUID first
	    RPC_STATUS RpcStat = UuidCreate(&outFilter.gFilterID);
	    if (RpcStat != RPC_S_OK && RpcStat != RPC_S_UUID_LOCAL_ONLY)
		{
		   sprintf(STRLASTERR, "Couldn't get GUID for MM filter - UuidCreate failed with status: %ul\n",
		  		   RpcStat);
		   WARN;
		   bReturn = false;
		}
		if (bReturn)
		{
			// set the name to be equal to the "text2pol " + GUID
			WCHAR StringTxt[POTF_MAX_STRLEN];
			int iReturn;

			wcscpy(StringTxt, L"text2pol ");
			iReturn = StringFromGUID2(outFilter.gFilterID, StringTxt+wcslen(StringTxt), POTF_MAX_STRLEN-wcslen(StringTxt));
			assert(iReturn != 0);
			outFilter.pszFilterName = new WCHAR[wcslen(StringTxt)+1];
			assert(outFilter.pszFilterName != NULL);
			wcscpy(outFilter.pszFilterName, StringTxt);
		}

		outFilter.InterfaceType       = inFilter.TransportFilter.InterfaceType;
		outFilter.bCreateMirror       = inFilter.TransportFilter.bCreateMirror;
		outFilter.dwFlags             = 0; // by default, set to none
		outFilter.SrcAddr             = inFilter.TransportFilter.SrcAddr;
		outFilter.DesAddr             = inFilter.TransportFilter.DesAddr;
		outFilter.dwDirection         = inFilter.TransportFilter.dwDirection;
		outFilter.dwWeight            = inFilter.TransportFilter.dwWeight;
	}
	else
	{
		// tunnel filter
	    // GUID first
	    RPC_STATUS RpcStat = UuidCreate(&outFilter.gFilterID);
	    if (RpcStat != RPC_S_OK && RpcStat != RPC_S_UUID_LOCAL_ONLY)
		{
		   sprintf(STRLASTERR, "Couldn't get GUID for mirror filter - UuidCreate failed with status: %ul\n",
		  		   RpcStat);
		   WARN;
		   bReturn = false;
		}
		if (bReturn)
		{
			// set the name to be equal to the "text2pol " + GUID
			WCHAR StringTxt[POTF_MAX_STRLEN];
			int iReturn;

			wcscpy(StringTxt, L"text2pol ");
			iReturn = StringFromGUID2(outFilter.gFilterID, StringTxt+wcslen(StringTxt), POTF_MAX_STRLEN-wcslen(StringTxt));
			assert(iReturn != 0);
			outFilter.pszFilterName = new WCHAR[wcslen(StringTxt)+1];
			assert(outFilter.pszFilterName != NULL);
			wcscpy(outFilter.pszFilterName, StringTxt);
		}

		outFilter.InterfaceType       = inFilter.TunnelFilter.InterfaceType;
		outFilter.bCreateMirror       = TRUE;
		outFilter.dwFlags             = 0; // by default, set to none
		outFilter.SrcAddr.AddrType    = IP_ADDR_UNIQUE;
	        outFilter.SrcAddr.uIpAddr     = IP_ADDRESS_ME;
		outFilter.SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
		UuidCreateNil(&(outFilter.SrcAddr.gInterfaceID));
		outFilter.DesAddr             = inFilter.TunnelFilter.DesTunnelAddr;
		outFilter.dwDirection         = inFilter.TunnelFilter.dwDirection;
		outFilter.dwWeight            = inFilter.TunnelFilter.dwWeight;
	}

	return bReturn;
}


DWORD CM_EncodeName ( LPTSTR pszSubjectName, BYTE **EncodedName, DWORD *EncodedNameLength )
{

    *EncodedNameLength=0;


    if (!CertStrToName(
        X509_ASN_ENCODING,
        pszSubjectName,
        CERT_X500_NAME_STR,
        NULL,
        NULL,
        EncodedNameLength,
        NULL)) {

//        DebugPrint1(L"Error in CertStrToName %d",GetLastError());
        return ERROR_INVALID_PARAMETER;
    }


    (*EncodedName)= new BYTE[*EncodedNameLength];
	assert (*EncodedName);

    if (!CertStrToName(
        X509_ASN_ENCODING,
        pszSubjectName,
        CERT_X500_NAME_STR,
        NULL,
        (*EncodedName),
        EncodedNameLength,
        NULL)) {

        delete (*EncodedName);
        (*EncodedName) = 0;
//        DebugPrint1(L"Error in CertStrToName %d",GetLastError());
        return ERROR_INVALID_PARAMETER;

    }

    return ERROR_SUCCESS;
}

DWORD CM_DecodeName ( BYTE *EncodedName, DWORD EncodedNameLength, LPTSTR *ppszSubjectName )
{

    DWORD DecodedNameLength=0;
	CERT_NAME_BLOB CertName;

	CertName.cbData = EncodedNameLength;
	CertName.pbData = EncodedName;


    DecodedNameLength = CertNameToStr(
        X509_ASN_ENCODING,
		&CertName,
        CERT_X500_NAME_STR,
        NULL,
        NULL);

	if (!DecodedNameLength)
		return ERROR_INVALID_PARAMETER;


    (*ppszSubjectName)= new TCHAR[DecodedNameLength];
	assert (*ppszSubjectName);

    DecodedNameLength = CertNameToStr(
        X509_ASN_ENCODING,
		&CertName,
        CERT_X500_NAME_STR,
        *ppszSubjectName,
        DecodedNameLength);

	if (!DecodedNameLength)
        {
                delete (*ppszSubjectName);
                (*ppszSubjectName) = 0;
		return ERROR_INVALID_PARAMETER;
        }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\query.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       query.cpp
//  Purpose:    query SPD and print IP Security information
//              
//
//--------------------------------------------------------------------------
/* Edit History:

	1/18/01	dkalin		Created
*/

// app's own header file

#include "ipseccmd.h"  

#pragma warning(disable:4311)

// forward function declarations
char *LongLongToString( DWORD dwHigh, DWORD dwLow, int iPrintCommas );
int AscMultUint( char *cProduct, char *cA, char *cB );
int AscAddUint(	char *cSum,	char *cA, char *cB );
void print_vpi(char *str, unsigned char *vpi, int vpi_len);

void reportError ( DWORD dwMessageId )
{
    LPVOID   myErrString = NULL;
	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            dwMessageId, 0,
            (LPTSTR)&myErrString, 0, NULL);

	_ftprintf(stderr,
			TEXT("%s\n"), myErrString);
	LocalFree(myErrString);
}


// run SPD query and display results, uses global flags to determine what needs to be printed
int do_show ( )
{
	int iReturn = 0; // success by default
	int i, j;
	DWORD hr = FALSE;		// assume success
	bool fTestPass = TRUE;
        char* pszLLString;
        TCHAR StringTxt[STRING_TEXT_SIZE+1];

	PMM_FILTER pmmf;	           // for MM filter calls
	PIPSEC_MM_SA pipsmmsa;         // for MM SA calls
	PIPSEC_QM_SA pipsqmsa;         // for QM SA calls
	PIPSEC_MM_POLICY pipsmmp;      // for MM policy calls
	PIPSEC_QM_POLICY pipsqmp;      // for QM policy calls
	PMM_AUTH_METHODS pmmam;        // for MM auth methods calls
    IKE_STATISTICS IKEStats;       // for IKE stats calls
	PIPSEC_STATISTICS pIPSecStats; // for IPSec stats calls
	PTRANSPORT_FILTER ptf;	       // for transport filter calls
	PTUNNEL_FILTER ptunf;	       // for tunnel filter calls
	DWORD dwCount;                 // counting objects here
	DWORD dwResumeHandle;          // handle for continuation calls 
	DWORD dwReserved;              // reserved container
	GUID  gDefaultGUID = {0};      // NULL GUID value

	if (ipseccmdShow.bFilters)
	{
		// print all filters
		// main mode generic with details
		_tprintf(TEXT("\nGeneric MM Filters\n------------------------------\n"));

		pmmf=NULL;
		dwResumeHandle=0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumMMFilters(szServ, ENUM_GENERIC_FILTERS, gDefaultGUID, &pmmf, 0, &dwCount, &dwResumeHandle);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No filters\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumMMFilters failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass = FALSE; // indicate an error
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				_tprintf(TEXT("\nGeneric MM Filter #%d:\n"), i+j+1);
				if (!PrintMMFilter(pmmf[j], TRUE, FALSE))
				{	
					fTestPass = FALSE; // indicate an error
					break;
				}
			}
			SPDApiBufferFree(pmmf);
			pmmf=NULL;
			if(!fTestPass)
				break;
		}
		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}

		// main mode specific without details
		_tprintf(TEXT("\nSpecific MM Filters\n------------------------------\n"));

		pmmf=NULL;
		dwResumeHandle=0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumMMFilters(szServ, ENUM_SPECIFIC_FILTERS, gDefaultGUID, &pmmf, 0, &dwCount, &dwResumeHandle);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No filters\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumMMFilters failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass = FALSE; // indicate an error
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				_tprintf(TEXT("\nSpecific MM Filter #%d:\n"), i+j+1);
				if (!PrintMMFilter(pmmf[j], FALSE, TRUE))
				{	// error
					fTestPass = FALSE; // indicate an error
					break;
				}
			}
			SPDApiBufferFree(pmmf);
			pmmf=NULL;
			if(!fTestPass)
				break;
		}
		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}

		// quick mode transport generic with details
		_tprintf(TEXT("\nGeneric Transport Filters\n------------------------------\n"));

		ptf=NULL;
		dwResumeHandle=0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumTransportFilters(szServ, ENUM_GENERIC_FILTERS, gDefaultGUID, &ptf, 0, &dwCount, &dwResumeHandle);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No filters\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumTransportFilters failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass=FALSE;
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				_tprintf(TEXT("\nGeneric Transport Filter #%d:\n"), i+j+1);
				if (!PrintFilter(ptf[j], TRUE, FALSE))
				{	// error
					fTestPass=FALSE;
					break;
				}
			}
			SPDApiBufferFree(ptf);
			ptf=NULL;
			if(!fTestPass)
				break;
		}
		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}

		// quick mode transport specific without details
		_tprintf(TEXT("\nSpecific Transport Filters\n------------------------------\n"));

		ptf=NULL;
		dwResumeHandle=0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumTransportFilters(szServ, ENUM_SPECIFIC_FILTERS, gDefaultGUID, &ptf, 0, &dwCount, &dwResumeHandle);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No filters\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumTransportFilters failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass=FALSE;
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				_tprintf(TEXT("\nSpecific Transport Filter #%d:\n"), i+j+1);
				if (!PrintFilter(ptf[j], FALSE, TRUE))
				{	// error
					fTestPass=FALSE;
					break;
				}
			}
			SPDApiBufferFree(ptf);
			ptf=NULL;
			if(!fTestPass)
				break;
		}
		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}

		// quick mode tunnel generic with details
		_tprintf(TEXT("\nGeneric Tunnel Filters\n------------------------------\n"));

		ptunf=NULL;
		dwResumeHandle=0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumTunnelFilters(szServ, ENUM_GENERIC_FILTERS, gDefaultGUID, &ptunf, 0, &dwCount, &dwResumeHandle);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No filters\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumTunnelFilters failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass=FALSE;
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				_tprintf(TEXT("\nGeneric Tunnel Filter #%d:\n"), i+j+1);
				if (!PrintTunnelFilter(ptunf[j], TRUE, FALSE))
				{	// error
					fTestPass=FALSE;
					break;
				}
			}
			SPDApiBufferFree(ptunf);
			ptunf=NULL;
			if(!fTestPass)
				break;
		}
		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}

		// quick mode tunnel specific without details
		_tprintf(TEXT("\nSpecific Tunnel Filters\n------------------------------\n"));

		ptunf=NULL;
		dwResumeHandle=0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumTunnelFilters(szServ, ENUM_SPECIFIC_FILTERS, gDefaultGUID, &ptunf, 0, &dwCount, &dwResumeHandle);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No filters\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumTunnelFilters failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass=FALSE;
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				_tprintf(TEXT("\nSpecific Tunnel Filter #%d:\n"), i+j+1);
				if (!PrintTunnelFilter(ptunf[j], FALSE, TRUE))
				{	// error
					fTestPass=FALSE;
					break;
				}
			}
			SPDApiBufferFree(ptunf);
			ptunf=NULL;
			if(!fTestPass)
				break;
		}
		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}
	}

	if (ipseccmdShow.bPolicies)
	{
		// print all policies
		// main mode policies
		_tprintf(TEXT("\nMain Mode Policies\n------------------------------\n"));

		pipsmmp=NULL;
		dwResumeHandle=0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumMMPolicies(szServ, &pipsmmp, 0, &dwCount, &dwResumeHandle);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No policies\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumMMPolicies failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass=FALSE;
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				_tprintf(TEXT("\nMain Mode Policy #%d:\n"), i+j+1);
				PrintMMPolicy(pipsmmp[j], _T(" "));
			}
			SPDApiBufferFree(pipsmmp);
			pipsmmp=NULL;
			if(!fTestPass)
				break;
		}
		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}

		// quick mode policies
		_tprintf(TEXT("\nQuick Mode Policies\n------------------------------\n"));

		pipsqmp=NULL;
		dwResumeHandle=0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumQMPolicies(szServ, &pipsqmp, 0, &dwCount, &dwResumeHandle);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No policies\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumQMPolicies failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass=FALSE;
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				_tprintf(TEXT("\nQuick Mode Policy #%d:\n"), i+j+1);
				PrintFilterAction(pipsqmp[j], _T(" "));
			}
			SPDApiBufferFree(pipsqmp);
			pipsqmp=NULL;
			if(!fTestPass)
				break;
		}
		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}
	}
	if (ipseccmdShow.bAuth)
	{
		// print main mode authentication methods
		_tprintf(TEXT("\nMain Mode Authentication Methods\n------------------------------\n"));

		pmmam=NULL;
		dwResumeHandle=0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumMMAuthMethods(szServ, &pmmam, 0, &dwCount, &dwResumeHandle);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No authentication methods\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumMMAuthMethods failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass=FALSE;
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				_tprintf(TEXT("\nMain Mode Authentication Methods #%d:\n"), i+j+1);
				PrintMMAuthMethods(pmmam[j], _T(" "));
			}
			SPDApiBufferFree(pmmam);
			pmmam=NULL;
			if(!fTestPass)
				break;
		}
		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}
	}
	if (ipseccmdShow.bStats)
	{
		// print stats
		// ike stats
        if ((hr = IPSecQueryIKEStatistics(szServ,&IKEStats)) != ERROR_SUCCESS)
		{
			_tprintf(TEXT("IPSecQueryIKEStatistics failed with error %d\n"), hr); 
			reportError(hr);
			fTestPass=FALSE;
		}
        if (fTestPass)
		{
			_tprintf(TEXT("\nIKE Statistics\n------------------------------\n"));
			printf(" Main Modes %d\n",IKEStats.dwOakleyMainModes);
			printf(" Quick Modes %d\n",IKEStats.dwOakleyQuickModes);
			printf(" Soft SAs %d\n",IKEStats.dwSoftAssociations);
			printf(" Authentication Failures %d\n",IKEStats.dwAuthenticationFailures);
			printf(" Active Acquire %d\n",IKEStats.dwActiveAcquire);
			printf(" Active Receive %d\n",IKEStats.dwActiveReceive);
			printf(" Acquire fail %d\n",IKEStats.dwAcquireFail);
			printf(" Receive fail %d\n",IKEStats.dwReceiveFail);
			printf(" Send fail %d\n",IKEStats.dwSendFail);
			printf(" Acquire Heap size %d\n",IKEStats.dwAcquireHeapSize);
			printf(" Receive Heap size %d\n",IKEStats.dwReceiveHeapSize);
			printf(" Negotiation Failures %d\n",IKEStats.dwNegotiationFailures);
			printf(" Invalid Cookies Rcvd %d\n",IKEStats.dwInvalidCookiesReceived);
			printf(" Total Acquire %d\n",IKEStats.dwTotalAcquire);
			printf(" TotalGetSpi %d\n",IKEStats.dwTotalGetSpi);
			printf(" TotalKeyAdd %d\n",IKEStats.dwTotalKeyAdd);
			printf(" TotalKeyUpdate %d\n",IKEStats.dwTotalKeyUpdate);
			printf(" GetSpiFail %d\n",IKEStats.dwGetSpiFail);
			printf(" KeyAddFail %d\n",IKEStats.dwKeyAddFail);
			printf(" KeyUpdateFail %d\n",IKEStats.dwKeyUpdateFail);
			printf(" IsadbListSize %d\n",IKEStats.dwIsadbListSize);
			printf(" ConnListSize %d\n",IKEStats.dwConnListSize);
			_tprintf(_TEXT("\n"));
		}

		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}

		// ipsec stats
        if ((hr = QueryIPSecStatistics(szServ,&pIPSecStats)) != ERROR_SUCCESS)
		{
			_tprintf(TEXT("QueryIPSecStatistics failed with error %d\n"), hr); 
			reportError(hr);
			fTestPass=FALSE;
		}
		if (fTestPass)
		{
			_tprintf(TEXT("\nIPSec Statistics\n------------------------------\n"));
			_tprintf(TEXT(" Active Assoc %lu\n"),pIPSecStats->dwNumActiveAssociations);
			_tprintf(TEXT(" Pending Key %lu\n"),pIPSecStats->dwNumPendingKeyOps);
			_tprintf(TEXT(" Key Adds %lu\n"),pIPSecStats->dwNumKeyAdditions);
			_tprintf(TEXT(" Key Deletes %lu\n"),pIPSecStats->dwNumKeyDeletions);
			_tprintf(TEXT(" ReKeys %lu\n"),pIPSecStats->dwNumReKeys);
			_tprintf(TEXT(" Active Tunnels %lu\n"),pIPSecStats->dwNumActiveTunnels);
			_tprintf(TEXT(" Bad SPI Pkts %lu\n"),pIPSecStats->dwNumBadSPIPackets);
			_tprintf(TEXT(" Pkts not Decrypted %lu\n"),pIPSecStats->dwNumPacketsNotDecrypted);
			_tprintf(TEXT(" Pkts not Authenticated %lu\n"),pIPSecStats->dwNumPacketsNotAuthenticated);
			_tprintf(TEXT(" Pkts with Replay Detection %lu\n"),pIPSecStats->dwNumPacketsWithReplayDetection);

			pszLLString = LongLongToString(pIPSecStats->uConfidentialBytesSent.HighPart,pIPSecStats->uConfidentialBytesSent.LowPart, 1);
			printf(" Confidential Bytes Sent %s\n", pszLLString);
			free(pszLLString);

			pszLLString = LongLongToString(pIPSecStats->uConfidentialBytesReceived.HighPart,pIPSecStats->uConfidentialBytesReceived.LowPart, 1);
			printf(" Confidential Bytes Received %s\n", pszLLString);
			free(pszLLString);

			pszLLString = LongLongToString(pIPSecStats->uAuthenticatedBytesSent.HighPart,pIPSecStats->uAuthenticatedBytesSent.LowPart, 1);
			printf(" Authenticated Bytes Sent %s\n", pszLLString);
			free(pszLLString);

			pszLLString = LongLongToString(pIPSecStats->uAuthenticatedBytesReceived.HighPart,pIPSecStats->uAuthenticatedBytesReceived.LowPart, 1);
			printf(" Authenticated Bytes Received %s\n", pszLLString);
			free(pszLLString);

			pszLLString = LongLongToString(pIPSecStats->uOffloadedBytesSent.HighPart,pIPSecStats->uOffloadedBytesSent.LowPart, 1);
			printf(" Offloaded Bytes Sent %s\n", pszLLString);
			free(pszLLString);

			pszLLString = LongLongToString(pIPSecStats->uOffloadedBytesReceived.HighPart,pIPSecStats->uOffloadedBytesReceived.LowPart, 1);
			printf(" Offloaded Bytes Received %s\n", pszLLString);
			free(pszLLString);

			pszLLString = LongLongToString(pIPSecStats->uBytesSentInTunnels.HighPart,pIPSecStats->uBytesSentInTunnels.LowPart, 1);
			printf(" Bytes Sent In Tunnels %s\n", pszLLString);
			free(pszLLString);

			pszLLString = LongLongToString(pIPSecStats->uBytesReceivedInTunnels.HighPart,pIPSecStats->uBytesReceivedInTunnels.LowPart, 1);
			printf(" Bytes Received In Tunnels %s\n", pszLLString);
			free(pszLLString);

			pszLLString = LongLongToString(pIPSecStats->uTransportBytesSent.HighPart,pIPSecStats->uTransportBytesSent.LowPart, 1);
			printf(" Transport Bytes Sent %s\n", pszLLString);
			free(pszLLString);

			pszLLString = LongLongToString(pIPSecStats->uTransportBytesReceived.HighPart,pIPSecStats->uTransportBytesReceived.LowPart, 1);
			printf(" Transport Bytes Received %s\n", pszLLString);
			free(pszLLString);

                        

			_tprintf(_TEXT("\n"));
			
			SPDApiBufferFree(pIPSecStats);
		}

		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}
	}
	if (ipseccmdShow.bSAs)
	{
		// print all SAs
		// main mode SAs
		_tprintf(TEXT("\nMain Mode SAs\n------------------------------\n"));

		pipsmmsa=NULL;
		dwResumeHandle=0;
		dwCount = 2;
	    dwReserved = 0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			IPSEC_MM_SA mmsaTemplate;
			memset(&mmsaTemplate, 0, sizeof(IPSEC_MM_SA));
			hr = IPSecEnumMMSAs(szServ, &mmsaTemplate, &pipsmmsa, &dwCount, &dwReserved, &dwResumeHandle, 0);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No SAs\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("IPSecEnumMMSAs failed with error %d\n"), hr); 
				reportError(hr);
				fTestPass=FALSE;
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				struct in_addr inAddr;

				_tprintf(TEXT("\nMain Mode SA #%d:\n"), i+j+1);
				// now print SA data
				inAddr.s_addr = pipsmmsa[j].Me.uIpAddr;
				printf(" From %s\n", inet_ntoa(inAddr));
				inAddr.s_addr = pipsmmsa[j].Peer.uIpAddr;
				printf("  To  %s\n", inet_ntoa(inAddr));

				StringFromGUID2(pipsmmsa[j].gMMPolicyID, StringTxt, STRING_TEXT_SIZE);
				_tprintf(TEXT(" Policy Id : %s\n"), StringTxt);

				_tprintf(TEXT(" Offer Used : \n"));
				PrintMMOffer(pipsmmsa[j].SelectedMMOffer, _T(""), _T("\t"));

				_tprintf(TEXT(" Auth Used : %s\n"), oak_auth[pipsmmsa[j].MMAuthEnum]);

				// print cookies
			    print_vpi(" Initiator cookie",(BYTE*)&(pipsmmsa[j].MMSpi.Initiator),sizeof(IKE_COOKIE));
				printf("\n");
				print_vpi(" Responder cookie",(BYTE*)&(pipsmmsa[j].MMSpi.Responder),sizeof(IKE_COOKIE));
				printf("\n");

				if (pipsmmsa[j].dwFlags != 0)
				{
					_tprintf(TEXT(" Flags : %lu\n"), pipsmmsa[j].dwFlags);
				}
			}
			SPDApiBufferFree(pipsmmsa);
			pipsmmsa=NULL;
			if (dwReserved == 0)
			{	
				break;
			}
			if(!fTestPass)
				break;
		}

		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}

		// quick mode SAs
		_tprintf(TEXT("\nQuick Mode SAs\n------------------------------\n"));

		pipsqmsa=NULL;
		dwResumeHandle=0;
		dwCount = 2;
	    dwReserved = 0;
		// make the call(s)
		for (i = 0; ;i+=dwCount)
		{
			hr = EnumQMSAs(szServ, NULL, &pipsqmsa, 0, &dwCount, &dwReserved, &dwResumeHandle, 0);
			if (hr == ERROR_NO_DATA || dwCount == 0)
			{
				if (i == 0)
				{
					_tprintf(TEXT("No SAs\n"));
				}
				break;
			}
			if (hr != ERROR_SUCCESS)
			{
				_tprintf(TEXT("EnumQMSAs failed with error %d\n"), hr); 
				fTestPass=FALSE;
				break;
			}
			for (j = 0; j < (int) dwCount; j++)
			{
				struct in_addr inAddr;

				_tprintf(TEXT("\nQuick Mode SA #%d:\n"), i+j+1);
				// now print SA data - QM filter
				StringFromGUID2(pipsqmsa[j].gQMFilterID, StringTxt, STRING_TEXT_SIZE);
				_tprintf(TEXT(" Filter Id : %s\n"), StringTxt);
				_tprintf(TEXT("  %s Filter\n"), 
					(pipsqmsa[j].IpsecQMFilter.QMFilterType == QM_TRANSPORT_FILTER) ? _T("Transport") :
					((pipsqmsa[j].IpsecQMFilter.QMFilterType == QM_TUNNEL_FILTER) ? _T("Tunnel") : _T("Unknown"))
				    );

				printf("  From ");
				PrintAddr(pipsqmsa[j].IpsecQMFilter.SrcAddr);
				printf("\n");
				printf("   To  ");
				PrintAddr(pipsqmsa[j].IpsecQMFilter.DesAddr);
				printf("\n");

				_tprintf(TEXT("  Protocol : %lu  Src Port : %u  Des Port : %u\n"), 
					pipsqmsa[j].IpsecQMFilter.Protocol.dwProtocol, pipsqmsa[j].IpsecQMFilter.SrcPort.wPort, pipsqmsa[j].IpsecQMFilter.DesPort.wPort);
				_tprintf(TEXT("  Direction : %s\n"), 
					(pipsqmsa[j].IpsecQMFilter.dwFlags & FILTER_DIRECTION_INBOUND) ? _T("Inbound") : 
				    ((pipsqmsa[j].IpsecQMFilter.dwFlags & FILTER_DIRECTION_OUTBOUND) ? _T("Outbound") : _T("Error")));

				if (pipsqmsa[j].IpsecQMFilter.QMFilterType == QM_TUNNEL_FILTER)
				{
					printf("  Tunnel From ");
					PrintAddr(pipsqmsa[j].IpsecQMFilter.MyTunnelEndpt);
					printf("\n");
					printf("  Tunnel  To  ");
					PrintAddr(pipsqmsa[j].IpsecQMFilter.PeerTunnelEndpt);
					printf("\n");
				}

				// policy and cookie
				StringFromGUID2(pipsqmsa[j].gQMPolicyID, StringTxt, STRING_TEXT_SIZE);
				_tprintf(TEXT(" Policy Id : %s\n"), StringTxt);

				_tprintf(TEXT(" Offer Used : \n"));
				PrintQMOffer(pipsqmsa[j].SelectedQMOffer, _T(""), _T("\t"));

				// print cookies
			    print_vpi(" Initiator cookie",(BYTE*)&(pipsqmsa[j].MMSpi.Initiator),sizeof(IKE_COOKIE));
				printf("\n");
				print_vpi(" Responder cookie",(BYTE*)&(pipsqmsa[j].MMSpi.Responder),sizeof(IKE_COOKIE));
				printf("\n");

			}
			SPDApiBufferFree(pipsqmsa);
			pipsqmsa=NULL;
			if (dwReserved == 0)
			{	
				break;
			}
			if(!fTestPass)
				break;
		}

		if (!fTestPass)
		{
			iReturn++;
			fTestPass = TRUE;
		}
	}

	return iReturn;
}

// process query command line
// accept command line (argc/argv) and the index where show flags start
// return 0 if command completed successfully, 
//        IPSECCMD_USAGE if there is usage error,
//        any other value indicates failure during execution (gets passed up)
//
// IMPORTANT: we assume that main module provide us with remote vs. local machine information
//            in the global variables
//
int ipseccmd_show_main ( int argc, char** argv, int start_index )
{
	int i;

    ipseccmdShow.bFilters = ipseccmdShow.bPolicies = ipseccmdShow.bAuth = ipseccmdShow.bStats = ipseccmdShow.bSAs = false;
	for (i = start_index ; i < argc; i++)
	{
		if (!_stricmp(argv[i], KEYWORD_SHOW))
		{
			continue; // skip that
		}
		else if (!_stricmp(argv[i], KEYWORD_FILTERS))
		{
			ipseccmdShow.bFilters = true;
		}
		else if (!_stricmp(argv[i], KEYWORD_POLICIES))
		{
			ipseccmdShow.bPolicies = true;
		}
		else if (!_stricmp(argv[i], KEYWORD_AUTH))
		{
			ipseccmdShow.bAuth = true;
		}
		else if (!_stricmp(argv[i], KEYWORD_STATS))
		{
			ipseccmdShow.bStats = true;
		}
		else if (!_stricmp(argv[i], KEYWORD_SAS))
		{
			ipseccmdShow.bSAs = true;
		}
		else if (!_stricmp(argv[i], KEYWORD_ALL))
		{
		    ipseccmdShow.bFilters = ipseccmdShow.bPolicies = ipseccmdShow.bAuth = ipseccmdShow.bStats = ipseccmdShow.bSAs = true;
		}
		else
		{
			return IPSECCMD_USAGE;
		}
	}

    return do_show();
}

// print_vpi prints IKE_COOKIE information
// Parms:   
// Returns: None

void print_vpi(char *str, unsigned char *vpi, int vpi_len)
{
    int i, j;
    char msg [256] ;
    char c [5];

    strcpy ( msg, str) ;
    strcat ( msg," ") ;
    if (vpi == NULL) {
        strcat(msg,"VPI NULL ");
        printf("%s", msg) ;
        return;
    }
    for (j=1, i=0; i<vpi_len; i++) {
        sprintf(c,"%02x",vpi[i]);
        strcat(msg, c) ;
        if (j == 16) {
            j = 0;
            printf("%s", msg);
            msg[0] = 0 ;
        }
        j++;
    }
    if ( j != 1)
    {
        printf("%s", msg);
    }
    else
    {
        printf("");
    }
} // end of print_vpi

/**********************************************************************************
 * 
 * AscAddUint - Add two numbers in ascii strings, storing the results in a third buffer
 *		cSum - Buffer for the sum
 *		cA - First addend
 *		cB - Second addend
 *
 *	This routine will add two arbitrarily long ascii strings. It makes several
 *	assumptions about them. 
 *		1) the string is null terminated.
 *		2) The LSB is the last char of the string. "1000000" is a million
 *		3) There are no signs or decimal points.
 *		4) The cSum buffer is large enough to store the result
 *		5) The sum will require 254 bytes or less.
 *
 * returns: 0 on success, else failure code.
 *
 **********************************************************************************/

int 
AscAddUint(
	char *cSum,
	char *cA,
	char *cB
	)
{
	int iALen, iBLen, iSumLen, iBiggerLen;
	int i,j,k, iCarry;
	char cTmp[255]={0}, *cBigger;

	// Verify parameters

	if ((cA == NULL) || (cB == NULL) || (cSum == NULL))
	{
		printf("AscAddUint(%0X,%0X, %0X) ERROR - bad parameters\n",
					(UINT) cA, (UINT) cB, (UINT) cSum);
		return(-1);
	}

	iALen = strlen(cA);
	iBLen = strlen(cB);
	iCarry = 0;

	// Loop through, adding the values. Our result string will be
	// backwards, we'll straighten it out when we copy it to the
	// cSum buffer.

	for (i=0; (i < iALen) && (i < iBLen); i++)
	{
		// Figure out the actual decimal value of the add.

		k = (int) (cA[iALen-i-1] + cB[iBLen-i-1] + iCarry);
		k -= 2 * '0';

		// Set the carry as appropriate

		iCarry = k/10;

		// Set the current digit's value.

		cTmp[i] = '0' + k%10;
	}

	// At this point, all digits present in both strings have been added.
	// In other words, "12345" + "678901", "12345" has been added to "78901"
	// The next step is to account for the high-order digits of the larger number.

	if (iALen > iBLen)
	{
		cBigger = cA;
		iBiggerLen = iALen;
	}
	else
	{
		cBigger = cB;
		iBiggerLen = iBLen;
	}

	while (i < iBiggerLen)
	{
		k = cBigger[iBiggerLen - i - 1] + iCarry - '0';

		// Set the carry as appropriate

		iCarry = k/10;

		// Set the current digit's value.

		cTmp[i] = '0' + k%10;
		i++;
	}

	// Finally, we might still have a set carry to put in the next
	// digit.

	if (iCarry)
	{
		cTmp[i++] = '0' + iCarry;
	}

	// Now that we've got the entire number, reverse it and put it back in the dest.

	// Skip leading 0's.

	i = strlen(cTmp) - 1;

	while ((i > 0)&&(cTmp[i] == '0'))
	{
		i--;
	}

	// and copy the number. 

	j = 0;
	while (i >= 0)
	{
		cSum[j++] = cTmp[i--];
	}

	cSum[j] = '\0';

	// We're done. Return 0 for success!

	return(0);
}



/**********************************************************************************
 * 
 * AscMultUint - Multiply two numbers in ascii strings, storing the results in a third buffer
 *		cProduct - Buffer for the product
 *		cA - First multiplicand
 *		cB - Second multiplicand
 *
 *	This routine will add two arbitrarily long ascii strings. It makes several
 *	assumptions about them. 
 *		1) the string is null terminated.
 *		2) The LSB is the last char of the string. "1000000" is a million
 *		3) There are no signs or decimal points.
 *		4) The cProduct buffer is large enough to store the result
 *		5) The product will require 254 bytes or less.
 *
 * returns: 0 on success, else failure code.
 *
 **********************************************************************************/

int 
AscMultUint(
	char *cProduct,
	char *cA,
	char *cB
	)
{
	int iALen, iBLen, iProductLen;
	int i,j,k, iCarry;
	char cTmp[255]={0};

	// Verify parameters

	if ((cA == NULL) || (cB == NULL) || (cProduct == NULL))
	{
		printf("AscMultUint(%0X,%0X, %0X) ERROR - bad parameters\n",
					(UINT) cA, (UINT) cB, (UINT) cProduct);
		return(-1);
	}

	iALen = strlen(cA);
	iBLen = strlen(cB);

	// We will multiply the traditional longhand way: for each digit in
	// cA, we will multiply it against cB and add the incremental result
	// into our temporary product.

	// for each digit of the first multiplicand

	for (i=0; i < iALen; i++)
	{
		iCarry = 0;

		// for each digit of the second multiplicand

		for(j=0; j < iBLen; j++)
		{
			// calculate this digit's value

			k = ((int) cA[iALen-i-1]-'0') * ((int) cB[iBLen-j-1]-'0');
			k += iCarry;

			// Add it in to the appropriate place in the result

			if (cTmp[i+j] != '\0')
			{
				k += (int) cTmp[i+j] - '0';
			}
			cTmp[i+j] = '0' + (k % 10);
			iCarry = k/10;
		}

		// Take care of the straggler carry. If the higher
		// digits happen to be '9999' then this can require
		// a loop.

		while (iCarry)
		{
			if (cTmp[i+j] != '\0')
			{
				iCarry += cTmp[i+j] - '0';
			}
			cTmp[i+j] = '0' + iCarry%10;
			iCarry /= 10;
			j++;
		}
	}

	// Now that we've got the entire number, reverse it and put it back in the dest.

	// Skip leading 0's.

	i = strlen(cTmp) - 1;

	while ((i > 0)&&(cTmp[i] == '0'))
	{
		i--;
	}

	// Copy the product.

	j = 0;
	while (i >= 0)
	{
		cProduct[j++] = cTmp[i--];
	}

	cProduct[j] = '\0';

	// We're done. Return 0 for success!

	return(0);
}



/*******************************************************
 *
 * LongLongToString - Convert a low and high DWORD to a decimal string 
 *		dwLow - Low order dword
 *		dwHigh - High order dword
 *		iPrintCommas - insert comma's if non-zero
 * 
 *	This routine will make a pretty string to match an input long-long, 
 *  and return it. If iPrintCommas is set, it will put in commas.
 *
 * 
 * returns: pointer to newly allocated string with number in it.
 *  NOTE - the caller is responsible for freeing the memory allocated.
 *
 *******************************************************/

char * 
LongLongToString(
	DWORD dwHigh, 
	DWORD dwLow, 
	int iPrintCommas
	)
{
	char cFourGig[]="4294967296";	// "four gigabytes"
	char cBuf[255]={0};
	char cRes[255]={0}, cFullRes[255]={0}, *cRet;
	int iPos, iPosRes, iThreeCount;

	// First, multiply the high dword by decimal 2^32 to
	// get the right decimal value for it.

	sprintf(cBuf,"%u",dwHigh);
	AscMultUint(cRes,cBuf,cFourGig);

	// next, add in the low DWORD (fine as it is) 
	// to the previous product

	sprintf(cBuf,"%u",dwLow);
	AscAddUint(cFullRes, cRes, cBuf);

	// Finally, copy the buffer with commas.

	iPos = iPosRes = 0;
	iThreeCount = strlen(cFullRes)%3;
	while(cFullRes[iPosRes] != '\0')
	{
		cBuf[iPos++] = cFullRes[iPosRes++];

		iThreeCount +=2; // Same as subtracting one for modulo math

		if ((!(iThreeCount%3))&&(cFullRes[iPosRes] != '\0')&&(iPrintCommas))
		{
			cBuf[iPos++]=',';
		}
	}

	cBuf[iPos] = '\0';

	cRet = _strdup(cBuf);

	return(cRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\text2pol.cpp ===
/////////////////////////////////////////////////////////////
// Copyright(c) 1998-2000, Microsoft Corporation
//
// text2pol.cpp
//
// Created on 4/5/98 by Randyram
// Revisions:
// Moved the routines to this module 8/25/98
//
// Split into text2pol.cpp, text2spd.h and text2spd.cpp 2/15/00 DKalin
//
// Implementation for the text to policy conversion routines (generic ones)
//   (See more in the text2spd.cpp)
//
/////////////////////////////////////////////////////////////

#include "ipseccmd.h"



// CFilter storage version
DWORD  ConvertFilter(IN T2P_FILTER &Filter,
                              IN OUT IPSEC_FILTER_SPEC &PolstoreFilter)
{
   DWORD    dwReturn = T2P_OK;   // return code of this function

   PolstoreFilter.pszSrcDNSName = PolstoreFilter.pszDestDNSName = 0;

   if (Filter.QMFilterType == QM_TRANSPORT_FILTER)
   {
		PolstoreFilter.FilterSpecGUID = Filter.TransportFilter.gFilterID;
                PolstoreFilter.pszDescription = IPSecAllocPolStr(Filter.TransportFilter.pszFilterName);
		PolstoreFilter.dwMirrorFlag   = Filter.TransportFilter.bCreateMirror;

		PolstoreFilter.Filter.SrcAddr      = Filter.TransportFilter.SrcAddr.uIpAddr;
		PolstoreFilter.Filter.SrcMask      = Filter.TransportFilter.SrcAddr.uSubNetMask;
		PolstoreFilter.Filter.DestAddr     = Filter.TransportFilter.DesAddr.uIpAddr;
		PolstoreFilter.Filter.DestMask     = Filter.TransportFilter.DesAddr.uSubNetMask;
		PolstoreFilter.Filter.TunnelAddr   = 0;
		PolstoreFilter.Filter.Protocol     = Filter.TransportFilter.Protocol.dwProtocol;
		PolstoreFilter.Filter.SrcPort      = Filter.TransportFilter.SrcPort.wPort;
		PolstoreFilter.Filter.DestPort     = Filter.TransportFilter.DesPort.wPort;
		PolstoreFilter.Filter.TunnelFilter = FALSE;
   }
   else
   {
	   // tunnel filter
		PolstoreFilter.FilterSpecGUID = Filter.TunnelFilter.gFilterID;
                PolstoreFilter.pszDescription = IPSecAllocPolStr(Filter.TunnelFilter.pszFilterName);
		PolstoreFilter.dwMirrorFlag   = FALSE;

		PolstoreFilter.Filter.SrcAddr      = Filter.TunnelFilter.SrcAddr.uIpAddr;
		PolstoreFilter.Filter.SrcMask      = Filter.TunnelFilter.SrcAddr.uSubNetMask;
		PolstoreFilter.Filter.DestAddr     = Filter.TunnelFilter.DesAddr.uIpAddr;
		PolstoreFilter.Filter.DestMask     = Filter.TunnelFilter.DesAddr.uSubNetMask;
		PolstoreFilter.Filter.TunnelAddr   = Filter.TunnelFilter.DesTunnelAddr.uIpAddr;
		PolstoreFilter.Filter.Protocol     = Filter.TunnelFilter.Protocol.dwProtocol;
		PolstoreFilter.Filter.SrcPort      = Filter.TunnelFilter.SrcPort.wPort;
		PolstoreFilter.Filter.DestPort     = Filter.TunnelFilter.DesPort.wPort;
		PolstoreFilter.Filter.TunnelFilter = TRUE;
   }

   return dwReturn;
}


DWORD TextToStorageLocation(IN char *szText, OUT STORAGE_INFO & StoreInfo)
{
   DWORD  dwReturn = T2P_OK;
   WCHAR  *pString = NULL,
   *pTmp    = NULL;
   WCHAR  szTmp[POTF_MAX_STRLEN];
   WCHAR  *Info = NULL;

   if (szText != NULL)
   {
      // copy szText so we can muck with it

      _stprintf(szTmp, TEXT("%S"), szText);

      // parse string
      if ( (pString = wcschr(szTmp, POTF_STORAGE_TOKEN)) != NULL )
         *pString = L'\0';

      if (towlower(szTmp[0]) == tolower(POTF_STORAGE_DS[0]))
      {
         StoreInfo.Type = STORAGE_TYPE_DS;

         if ((pString != NULL) && (wcslen(pString + 1) > 0) )
         {
            ++pString;  // now pointing at string

            wcscpy(StoreInfo.szLocationName, pString);
         }
         // else no domain provided
      }
      else if (towlower(szTmp[0]) == tolower(POTF_STORAGE_REG[0]))
      {
         StoreInfo.Type = STORAGE_TYPE_REGISTRY;
      }
      else if (towlower(szTmp[0]) == tolower(POTF_STORAGE_CACHE[0]))
      {
         StoreInfo.Type = STORAGE_TYPE_CACHE;
      }
      else  // invalid option
      {
         dwReturn = T2P_INVALID_STORAGE_INFO;
      }

   }
   else
      dwReturn = T2P_NULL_STRING;

   return dwReturn;
}

// the whole reason to have this is to extract the polling interval
// if specified
DWORD TextToPolicyName(IN char *szText, OUT STORAGE_INFO & StoreInfo)
{
   DWORD  dwReturn = T2P_OK;
   WCHAR  *pString = NULL,
   *pTmp    = NULL;
   WCHAR  szTmp[POTF_MAX_STRLEN];
   WCHAR  *Info = NULL;

   if (szText != NULL)
   {
      // copy szText so we can muck with it

      _stprintf(szTmp, TEXT("%S"), szText);

      // parse string
      if ( (pString = wcschr(szTmp, POTF_STORAGE_TOKEN)) != NULL )
         *pString = '\0';

      wcscpy(StoreInfo.szPolicyName, szTmp);

      if ((pString != NULL) && (wcslen(pString + 1) > 0) )
      {
         ++pString;  // now pointing at polling interval

         // XX could be checked more stringently
         // do the converstion to minutes here
         StoreInfo.tPollingInterval = 60 * (wcstol(pString, NULL, 10));
      }

   }
   else
      dwReturn = T2P_NULL_STRING;

   return dwReturn;
}

bool InStorageMode(IN UINT uArgCount, IN char *strArgs[])
{
   for (UINT i = 0; i < uArgCount; ++i)
      if ( strArgs[i][1] == POTF_STORAGE_FLAG )
         return true;

   return false;
}

// CmdLineToPolicy

// pStorageInfo has NULL as default
// Returns False if there is any kind of failure

DWORD  CmdLineToPolicy(IN UINT uArgCount, IN char *strArgs[],
                       OUT IPSEC_IKE_POLICY & IpsecIkePol,
                       OUT bool & bConfirm
			,OUT PSTORAGE_INFO  pStorageInfo)
{

   DWORD  dwReturn = T2P_OK;

   IPSEC_QM_POLICY   IpsPol;
   IPSEC_MM_POLICY   IkePol;
   MM_AUTH_METHODS   AuthInfos;
   MM_FILTER*        pMMFilters;
   DWORD             dwNumMMFilters;
   QM_FILTER_TYPE    QMFilterType;
   DWORD             dwNumFilters;
   TRANSPORT_FILTER* pTransportFilters;
   TUNNEL_FILTER*    pTunnelFilters;

   memcpy(&IpsPol, &IpsecIkePol.IpsPol, sizeof(IpsPol));
   memcpy(&IkePol, &IpsecIkePol.IkePol, sizeof(IkePol));
   memcpy(&AuthInfos, &IpsecIkePol.AuthInfos, sizeof(AuthInfos));

   pMMFilters        =   IpsecIkePol.pMMFilters;
   dwNumMMFilters    =   IpsecIkePol.dwNumMMFilters;
   QMFilterType      =   IpsecIkePol.QMFilterType;
   dwNumFilters      =   IpsecIkePol.dwNumFilters;
   pTransportFilters =   IpsecIkePol.pTransportFilters;
   pTunnelFilters    =   IpsecIkePol.pTunnelFilters;

   // used when finding out how much mem to alloc
   UINT  uFiltAlloc = 0,
   uMMFiltAlloc = 0,
   uSecMetAlloc = 0,
   uOfferAlloc = 0,
   uAuthAlloc = 0;

   UINT  i = 0; // loop cntr
   bool  bIsMirrorFilt = false,
         bMirrorFiltRC = true;   // since MirrorFilt is not a T2P mod

   T2P_FILTER Filter; // for TextToFilter calls
   memset(&Filter, 0, sizeof(Filter));
   Filter.QMFilterType = QM_TRANSPORT_FILTER; // by default it's transport

   bConfirm = false;

   // for post-processing Ike policy
   bool  bP1RekeyUsed = false;
   KEY_LIFETIME OakLife;
   DWORD           QMLimit = POTF_DEFAULT_P1REKEY_QMS;
   OakLife.uKeyExpirationTime  = POTF_DEFAULT_P1REKEY_TIME;
   OakLife.uKeyExpirationKBytes = 0; // not used

   IF_TYPE Interface = INTERFACE_TYPE_ALL;

   IPAddr DesTunnelAddr = 0;
   IPAddr SrcTunnelAddr = 0;

   // We do some things differently in storage mode:
   // * process negotiation policy actions
   // * use a different filter list
   //
   // This could all be much cleaner, but until the cmd line
   // parsing is actually separated from the policy processing
   // we're pretty much stuck with this unless we want to duplicated
   // alot of code.  eg. 2 cmdlinetopolicy, one dynamic, one storage
   //

   bool bStorageMode = InStorageMode(uArgCount, strArgs);

   if ( bStorageMode && !pStorageInfo )
      return T2P_NO_STORAGE_INFO;

   //
   // we'll allow the cmd line to specify
   // storage options.  Use a temp structure to hold those
   // options-- then we'll copy it at the end if pStorageInfo != NULL
   //

   STORAGE_INFO   tmpStorageInfo;
   memset(&tmpStorageInfo, 0, sizeof(tmpStorageInfo));
   tmpStorageInfo.guidNegPolAction = GUID_NEGOTIATION_ACTION_NORMAL_IPSEC;

   // init OUT params (free them if necessary)

   if (IkePol.pOffers != NULL)
   {
	   free(IkePol.pOffers);
   }
   IkePol.pOffers = NULL;
   IkePol.dwOfferCount = 0;

   if (IpsPol.pOffers != NULL)
   {
	   free(IpsPol.pOffers);
   }
   IpsPol.pOffers = NULL;
   IpsPol.dwOfferCount = 0;

   if (AuthInfos.pAuthenticationInfo != NULL)
   {
	   for (i = 0; i < (UINT) AuthInfos.dwNumAuthInfos; i++)
	   {
		   if (AuthInfos.pAuthenticationInfo[i].pAuthInfo != NULL)
			   free(AuthInfos.pAuthenticationInfo[i].pAuthInfo);
	   }
	   free(AuthInfos.pAuthenticationInfo);
   }
   AuthInfos.pAuthenticationInfo = NULL;
   AuthInfos.dwNumAuthInfos = NULL;

   // cleanup filters
   if (pTransportFilters != NULL)
   {
	   for (i = 0; i < (UINT) dwNumFilters; i++)
	   {
		   if (pTransportFilters[i].pszFilterName != NULL)
			   free(pTransportFilters[i].pszFilterName);
	   }
	   free(pTransportFilters);
   }
   pTransportFilters = NULL;

   if (pTunnelFilters != NULL)
   {
	   for (i = 0; i < (UINT) dwNumFilters; i++)
	   {
		   if (pTunnelFilters[i].pszFilterName != NULL)
			   free(pTunnelFilters[i].pszFilterName);
	   }
	   free(pTunnelFilters);
   }
   pTunnelFilters = NULL;

   QMFilterType = Filter.QMFilterType;
   dwNumFilters = 0;

   // mm filters
   if (pMMFilters != NULL)
   {
	   for (i = 0; i < (UINT) dwNumMMFilters; i++)
	   {
		   if (pMMFilters[i].pszFilterName != NULL)
			   free(pMMFilters[i].pszFilterName);
	   }
	   free(pMMFilters);
   }
   pMMFilters = NULL;

   dwNumMMFilters = 0;

   // we assume uArgCount and strArgs are OK
   // but defend against ######### here
   if (uArgCount > 0 && strArgs != NULL)
   {
      // find out how much memory we're going to need
      // we do this here because I allow multiple flags of same type
      for (i = 1; i < uArgCount; )
      {
         if ( strchr(POTF_FLAG_TOKENS, strArgs[i][0]) != NULL )
         {
            if (strArgs[i][1] == POTF_FILTER_FLAG)
            {
               if (strArgs[i][2] != '\0') // user omitted space
               {
                  ++uFiltAlloc;
               }

               ++i;

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  ++uFiltAlloc;
                  ++i;
               }
            }
            else if (strArgs[i][1] == POTF_NEGPOL_FLAG)
            {
               if (strArgs[i][2] != '\0') // user omitted space
                  ++uOfferAlloc;

               ++i;

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  ++uOfferAlloc;
                  ++i;
               }
            }
            else if (strArgs[i][1] == POTF_AUTH_FLAG)
            {
               if (strArgs[i][2] != '\0') // user omitted space
                  ++uAuthAlloc;

               ++i;

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  ++uAuthAlloc;
                  ++i;
               }
            }
            else if ( strncmp(&strArgs[i][1], POTF_SECMETHOD_FLAG,
                              strlen(POTF_SECMETHOD_FLAG)) == 0 )
            {
               if (strArgs[i][3] != '\0') // user omitted space
                  ++uSecMetAlloc;

               ++i;

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  ++uSecMetAlloc;
                  ++i;
               }
            }
            else if ( strncmp(&strArgs[i][1], POTF_MMFILTER_FLAG,
                              strlen(POTF_MMFILTER_FLAG)) == 0 )
            {
               if (strArgs[i][3] != '\0') // user omitted space
                  ++uMMFiltAlloc;

               ++i;

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  ++uMMFiltAlloc;
                  ++i;
               }
            }
			else if (strArgs[i][1] == POTF_TUNNEL_FLAG)
			{
				// switch to tunnel mode
				QMFilterType = Filter.QMFilterType = QM_TUNNEL_FILTER;
				i++;
			}
            else
               ++i;
         }
         else
            ++i;
      }

      // now allocate the memory
      if (uFiltAlloc)
      {
		 // we allocate both transport and tunnel filter storage because of RPC reasons
	
		 pTransportFilters = new TRANSPORT_FILTER[uFiltAlloc + 1];
		 assert(pTransportFilters != NULL);

		 // init these
		 for (i = 0; i <= uFiltAlloc; ++i)
			memset(&pTransportFilters[i], 0, sizeof(TRANSPORT_FILTER));
		 memset(&Filter.TransportFilter, 0, sizeof(TRANSPORT_FILTER));

		 // tunnel mode
		 pTunnelFilters = new TUNNEL_FILTER[uFiltAlloc + 1];
		 assert(pTunnelFilters != NULL);

		 // init these
		 for (i = 0; i <= uFiltAlloc; ++i)
			memset(&pTunnelFilters[i], 0, sizeof(TUNNEL_FILTER));
		 memset(&Filter.TunnelFilter, 0, sizeof(TUNNEL_FILTER));

		 if (!uMMFiltAlloc)
		 {
			 // allocate main mode filters for auto-generation
			 pMMFilters = new MM_FILTER[uFiltAlloc + 1];
			 assert(pMMFilters != NULL);

			 // init these
			 for (i = 0; i <= uFiltAlloc; ++i)
				memset(&pMMFilters[i], 0, sizeof(MM_FILTER));
		 }
      }
	  if (uMMFiltAlloc)
	  {
		 // allocate main mode filters
		 pMMFilters = new MM_FILTER[uMMFiltAlloc + 1];
		 assert(pMMFilters != NULL);

		 // init these
		 for (i = 0; i <= uMMFiltAlloc; ++i)
			memset(&pMMFilters[i], 0, sizeof(MM_FILTER));
	  }
      if (uAuthAlloc)
      {
         AuthInfos.pAuthenticationInfo = new IPSEC_MM_AUTH_INFO[uAuthAlloc + 1];
         assert(AuthInfos.pAuthenticationInfo != NULL);

         // init these
         for (i = 0; i <= uAuthAlloc; ++i)
            memset(&AuthInfos.pAuthenticationInfo[i], 0, sizeof(IPSEC_MM_AUTH_INFO));
      }
      if (uOfferAlloc)
      {
         IpsPol.pOffers = new IPSEC_QM_OFFER[uOfferAlloc + 1];
         assert(IpsPol.pOffers != NULL);

         // init these
         for (i = 0; i <= uOfferAlloc; ++i)
         {
            memset(&IpsPol.pOffers[i], 0, sizeof(IPSEC_QM_OFFER));
         }
      }
      if (uSecMetAlloc)
      {
         IkePol.pOffers = new IPSEC_MM_OFFER[uSecMetAlloc + 1];
         assert(IkePol.pOffers != NULL);

         // init these
         for (i = 0; i <= uSecMetAlloc; ++i)
         {
            memset(&IkePol.pOffers[i], 0, sizeof(IPSEC_MM_OFFER));
         }
      }

      // Main processing loop ////////////////////////////////////////////////////////
      // invariants;
      // 1. use dwReturn when calling util functions, if returns false
      // break out of for loop and let cleanup code take over
      // 2. advance i each time you process a param
      for (i = 1; i < uArgCount && T2P_SUCCESS(dwReturn); ) // we'll advance i below
      {
         // make sure there is actually a flag, else we have parse error
         if ( strchr(POTF_FLAG_TOKENS, strArgs[i][0]) != NULL )
         {
            if (strArgs[i][1] == POTF_FILTER_FLAG)  // filter list
            {
               // first filter is special case because user may
               // omit space after flag
               if ((strArgs[i][2] != '\0')
                   && (strchr(POTF_FLAG_TOKENS, strArgs[i][2]) == NULL))
               {
                  //
                  // Even if we're in storage mode, we use these
                  // filters.
                  //

                  dwReturn = TextToFilter(&strArgs[i][2], Filter);
				  if (QMFilterType == QM_TRANSPORT_FILTER)
				  {
					  memcpy(&pTransportFilters[dwNumFilters], &Filter.TransportFilter, sizeof(TRANSPORT_FILTER));
				  }
				  else
				  {
					  // tunnel
					  memcpy(&pTunnelFilters[dwNumFilters], &Filter.TunnelFilter, sizeof(TUNNEL_FILTER));
				  }

                  if (!T2P_SUCCESS(dwReturn))
                     break;
                  else
                  {
                      ++dwNumFilters;
                  }
               }
               else if (strArgs[i][2] != '\0')
               {
                  sprintf(STRLASTERR,
                          "Unexpected flag: %s. Check usage.\n", strArgs[i]);
                  PARSE_ERROR;
                  dwReturn = POTF_FAILED;
                  break;
               }

               ++i;  // advance to next arg

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  //
                  // Even if we're in storage mode, we fill these in
                  //

                  dwReturn = TextToFilter(&strArgs[i][0], Filter);
				  if (QMFilterType == QM_TRANSPORT_FILTER)
				  {
					  memcpy(&pTransportFilters[dwNumFilters], &Filter.TransportFilter, sizeof(TRANSPORT_FILTER));
				  }
				  else
				  {
					  // tunnel
					  memcpy(&pTunnelFilters[dwNumFilters], &Filter.TunnelFilter, sizeof(TUNNEL_FILTER));
				  }

                  if (!T2P_SUCCESS(dwReturn))
                     break;
                  else
                  {
                      ++dwNumFilters;
                  }

                  ++i; // advance to next arg
               }
            }
            else if (strArgs[i][1] == POTF_NEGPOL_FLAG)
            {

               // first offer is special case because user may
               // omit space after flag
               if ((strArgs[i][2] != '\0')
                   && (strchr(POTF_FLAG_TOKENS, strArgs[i][2]) == NULL))
               {
                  if ( !strcmp(&strArgs[i][2], POTF_PASSTHRU) )
                  {
                    tmpStorageInfo.guidNegPolAction
                         = GUID_NEGOTIATION_ACTION_NO_IPSEC;
                  }
                  else if ( !strcmp(&strArgs[i][2], POTF_INBOUND_PASSTHRU) )
                  {
                    tmpStorageInfo.guidNegPolAction =
                            GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU;
                  }
                  else if ( !strcmp(&strArgs[i][2], POTF_BLOCK) )
                  {
                    tmpStorageInfo.guidNegPolAction =
                              GUID_NEGOTIATION_ACTION_BLOCK;
                  }
                  else
                  {

                     dwReturn = TextToOffer(&strArgs[i][2], IpsPol.pOffers[IpsPol.dwOfferCount]);

                     if (!T2P_SUCCESS(dwReturn))  break;
                     else           ++IpsPol.dwOfferCount;
                  }
               }
               else if (strArgs[i][2] != '\0')
               {
                  sprintf(STRLASTERR,
                          "Unexpected flag: %s. Check usage.\n", strArgs[i]);
                  PARSE_ERROR;
                  dwReturn = POTF_FAILED;
                  break;
               }

               ++i;  // advance to next arg

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  if ( !strcmp(&strArgs[i][0], POTF_PASSTHRU) )
                  {
                    tmpStorageInfo.guidNegPolAction
                         = GUID_NEGOTIATION_ACTION_NO_IPSEC;
                  }
                  else if ( !strcmp(&strArgs[i][0], POTF_INBOUND_PASSTHRU) )
                  {
                    tmpStorageInfo.guidNegPolAction =
                            GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU;
                  }
                  else if ( !strcmp(&strArgs[i][0], POTF_BLOCK) )
                  {
                    tmpStorageInfo.guidNegPolAction =
                              GUID_NEGOTIATION_ACTION_BLOCK;
                  }
                  else
                  {
                     dwReturn = TextToOffer(&strArgs[i][0], IpsPol.pOffers[IpsPol.dwOfferCount]);

                     if (!T2P_SUCCESS(dwReturn))  goto error_occured;
                     else           ++IpsPol.dwOfferCount;
                  }

                  ++i; // advance to next arg
               }
            }
            else if (strArgs[i][1] == POTF_TUNNEL_FLAG)
            {
               if (strArgs[i][2] != '\0') // no space after flag
               {
                  TextToIPAddr(&strArgs[i][2], DesTunnelAddr);
               }
               else
               {
                  ++i;
                  TextToIPAddr(&strArgs[i][0], DesTunnelAddr);
               }

               ++i;
			   // now check for second tunnel address
			   if (i < uArgCount && strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL)
			   {
				   // not an option, tunnel address
				   SrcTunnelAddr = DesTunnelAddr;
				   TextToIPAddr(&strArgs[i][0], DesTunnelAddr);
				   ++i;
			   }

            }
            else if (strArgs[i][1] == POTF_AUTH_FLAG)
            {
               // first offer is special case because user may
               // omit space after flag
               if ((strArgs[i][2] != '\0')
                   && (strchr(POTF_FLAG_TOKENS, strArgs[i][2]) == NULL))
               {
                  dwReturn = TextToOakleyAuth(&strArgs[i][2], AuthInfos.pAuthenticationInfo[AuthInfos.dwNumAuthInfos]);
                  if (!T2P_SUCCESS(dwReturn))  break;
                  else           ++AuthInfos.dwNumAuthInfos;
               }
               else if (strArgs[i][2] != '\0')
               {
                  sprintf(STRLASTERR,
                          "Unexpected flag: %s. Check usage.\n", strArgs[i]);
                  PARSE_ERROR;
                  dwReturn = POTF_FAILED;
                  break;
               }

               ++i;  // advance to next arg

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  dwReturn = TextToOakleyAuth(&strArgs[i][0], AuthInfos.pAuthenticationInfo[AuthInfos.dwNumAuthInfos]);
                  if (!T2P_SUCCESS(dwReturn))  goto error_occured;
                  else           ++AuthInfos.dwNumAuthInfos;

                  ++i; // advance to next arg
               }
            }
            else if (strArgs[i][1] == POTF_STORAGE_FLAG)
            {
               if ((strArgs[i][2] != '\0')
                   && (strchr(POTF_FLAG_TOKENS, strArgs[i][2]) == NULL))
               {
                  dwReturn = TextToStorageLocation(&strArgs[i][2], tmpStorageInfo);
                  if (!T2P_SUCCESS(dwReturn))  break;
               }
               else if (strArgs[i][2] != '\0')
               {
                  sprintf(STRLASTERR,
                          "Unexpected flag: %s. Check usage.\n", strArgs[i]);
                  PARSE_ERROR;
                  dwReturn = POTF_FAILED;
                  break;
               }
               else  // storage info must be in next param
               {
                  ++i;  // advance to next arg
                  if ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
                  {
                     dwReturn = TextToStorageLocation(&strArgs[i][0], tmpStorageInfo);
                     if (!T2P_SUCCESS(dwReturn))  goto error_occured;

                     ++i; // advance to next arg
                  }
                  else
                  {
                     sprintf(STRLASTERR,
                             "You must specify storage info: %s. Check usage.\n", strArgs[i]);
                     PARSE_ERROR;
                     dwReturn = POTF_FAILED;
                     break;
                  }
               }
            }
            else if (strArgs[i][1] == POTF_POLNAME_FLAG)
            {
               if ((strArgs[i][2] != '\0')
                   && (strchr(POTF_FLAG_TOKENS, strArgs[i][2]) == NULL))
               {
                  dwReturn = TextToPolicyName(&strArgs[i][2], tmpStorageInfo);
                  if (!T2P_SUCCESS(dwReturn))  break;
               }
               else if (strArgs[i][2] != '\0')
               {
                  sprintf(STRLASTERR,
                          "Unexpected flag: %s. Check usage.\n", strArgs[i]);
                  PARSE_ERROR;
                  dwReturn = POTF_FAILED;
                  break;
               }
               else  // policy name must be in next param
               {
                  ++i;  // advance to next arg
                  if ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
                  {
                     dwReturn = TextToPolicyName(&strArgs[i][0], tmpStorageInfo);
                     if (!T2P_SUCCESS(dwReturn))  goto error_occured;

                     ++i; // advance to next arg
                  }
                  else
                  {
                     sprintf(STRLASTERR,
                             "You must specify policy name: %s. Check usage.\n", strArgs[i]);
                     PARSE_ERROR;
                     dwReturn = POTF_FAILED;
                     break;
                  }
               }
            }
            else if (strArgs[i][1] == POTF_RULENAME_FLAG)
            {
               // first offer is special case because user may
               // omit space after flag
               if ((strArgs[i][2] != '\0')
                   && (strchr(POTF_FLAG_TOKENS, strArgs[i][2]) == NULL))
               {
                 _stprintf(tmpStorageInfo.szRuleName, TEXT("%S"), &strArgs[i][2]);
               }
               else if (strArgs[i][2] != '\0')
               {
                  sprintf(STRLASTERR,
                          "Unexpected flag: %s. Check usage.\n", strArgs[i]);
                  PARSE_ERROR;
                  dwReturn = POTF_FAILED;
                  break;
               }
               else  // policy name must be in next param
               {
                  ++i;  // advance to next arg
                  if ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
                  {
                    _stprintf(tmpStorageInfo.szRuleName, TEXT("%S"), &strArgs[i][0]);

                     ++i; // advance to next arg
                  }
                  else
                  {
                     sprintf(STRLASTERR,
                             "You must specify rule name: %s. Check usage.\n", strArgs[i]);
                     PARSE_ERROR;
                     dwReturn = POTF_FAILED;
                     break;
                  }
               }
            }
            else if (strArgs[i][1] == POTF_SETACTIVE_FLAG)
            {
              tmpStorageInfo.bSetActive = TRUE;
              ++i;
            }
            else if (strArgs[i][1] == POTF_SETINACTIVE_FLAG)
            {
              tmpStorageInfo.bSetInActive = TRUE;
              ++i;
            }
            else if (strArgs[i][1] == POTF_CONFIRM_FLAG)
            {
               bConfirm = true;
               ++i;
            }
            else if (strArgs[i][1] == POTF_DELETEPOLICY_FLAG)
            {
               tmpStorageInfo.bDeletePolicy = true;
               ++i;
            }
            else if ( strncmp(&strArgs[i][1], POTF_DIALUP_FLAG,
                              strlen(POTF_DIALUP_FLAG)) == 0 )
            {
               Interface = INTERFACE_TYPE_DIALUP;
               ++i;
            }
            else if (strArgs[i][1] == POTF_DEACTIVATE_FLAG)
            {
			   // deactivate local registry policy right here
			   // this is left for backward compatibility with old text2pol
			   // directory policy assignment left intact

			   HANDLE hRegPolicyStore = NULL;
			   PIPSEC_POLICY_DATA pipspd = NULL;
			   DWORD  dwRes = ERROR_SUCCESS;

			   dwRes = IPSecOpenPolicyStore(NULL, IPSEC_REGISTRY_PROVIDER, NULL, &hRegPolicyStore);
			   if (dwRes == ERROR_SUCCESS && hRegPolicyStore != NULL)
			   {
					dwRes = IPSecGetAssignedPolicyData(hRegPolicyStore, &pipspd);
					if (dwRes == ERROR_SUCCESS && pipspd != NULL)
					{
						dwRes = IPSecUnassignPolicy(hRegPolicyStore, pipspd[0].PolicyIdentifier);
						IPSecFreePolicyData(pipspd);
					}

					IPSecClosePolicyStore(hRegPolicyStore);
			   }

			   if (dwRes != ERROR_SUCCESS)
			   {
                  sprintf(STRLASTERR,
                          "Polstore operation returned 0x%x!\n", dwRes);
                  PARSE_ERROR;
                  dwReturn = POTF_FAILED;
                  break;
			   }

               ++i;
            }
            else if ( strncmp(&strArgs[i][1], POTF_MMFILTER_FLAG,
                              strlen(POTF_MMFILTER_FLAG)) == 0 )
			{
               // first filter is special case because user may
               // omit space after flag
               if ((strArgs[i][3] != '\0')
                   && (strchr(POTF_FLAG_TOKENS, strArgs[i][3]) == NULL))
               {
                  dwReturn = TextToMMFilter(&strArgs[i][3], pMMFilters[dwNumMMFilters]);

                  if (!T2P_SUCCESS(dwReturn))
                     break;
                  else
                  {
                      ++dwNumMMFilters;
                  }
               }
               else if (strArgs[i][3] != '\0')
               {
                  sprintf(STRLASTERR,
                          "Unexpected flag: %s. Check usage.\n", strArgs[i]);
                  PARSE_ERROR;
                  dwReturn = POTF_FAILED;
                  break;
               }

               ++i;  // advance to next arg

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  dwReturn = TextToMMFilter(&strArgs[i][0], pMMFilters[dwNumMMFilters]);

                  if (!T2P_SUCCESS(dwReturn))
                     break;
                  else
                  {
                      ++dwNumMMFilters;
                  }

                  ++i; // advance to next arg
               }
			}
            else if ( strncmp(&strArgs[i][1], POTF_SECMETHOD_FLAG,
                              strlen(POTF_SECMETHOD_FLAG)) == 0 )
            {
               // first method is special case because user may
               // omit space after flag
               if ((strArgs[i][3] != '\0')
                   && (strchr(POTF_FLAG_TOKENS, strArgs[i][3]) == NULL))
               {
                  dwReturn = TextToSecMethod(&strArgs[i][3], IkePol.pOffers[IkePol.dwOfferCount]);
                  if (!T2P_SUCCESS(dwReturn))  break;
                  else           ++IkePol.dwOfferCount;
               }
               else if (strArgs[i][3] != '\0')
               {
                  sprintf(STRLASTERR,
                          "Unexpected flag: %s. Check usage.\n", strArgs[i]);
                  PARSE_ERROR;
                  dwReturn = false;
                  break;
               }

               ++i;  // advance to next arg

               while ( (i < uArgCount) && (strchr(POTF_FLAG_TOKENS, strArgs[i][0]) == NULL) )
               {
                  dwReturn = TextToSecMethod(&strArgs[i][0], IkePol.pOffers[IkePol.dwOfferCount]);
                  if (!T2P_SUCCESS(dwReturn))  goto error_occured;
                  else           ++IkePol.dwOfferCount;

                  ++i; // advance to next arg
               }
            }
            else if ( strncmp(&strArgs[i][1], POTF_P1PFS_FLAG,
                              strlen(POTF_P1PFS_FLAG)) == 0 )
            {
               QMLimit = 1;
			   bP1RekeyUsed = true; // will fixup all the P1 offers later
               ++i;
            }
            else if ( strncmp(&strArgs[i][1], POTF_SOFTSA_FLAG,
                              strlen(POTF_SOFTSA_FLAG)) == 0 )
            {
			   IpsPol.dwFlags |= IPSEC_QM_POLICY_ALLOW_SOFT;
			   if (!IkePol.uSoftSAExpirationTime)
			   {
				   // set this time to default
				   IkePol.uSoftSAExpirationTime = POTF_DEF_P1SOFT_TIME;
			   }
               ++i;
            }
            else if ( strncmp(&strArgs[i][1], POTF_LAN_FLAG,
                              strlen(POTF_LAN_FLAG)) == 0 )
            {
               Interface = INTERFACE_TYPE_LAN;
               ++i;
            }
            else if ( strncmp(&strArgs[i][1], POTF_SOFTSAEXP_FLAG,
                              strlen(POTF_SOFTSAEXP_FLAG)) == 0 )
            {
				if (strArgs[i][3] != '\0')
				{
					// they may have omitted a space
					IkePol.uSoftSAExpirationTime = atol(&strArgs[i][3]);
                    ++i;
				}
				else
				{
					++i;
					// process next arg
					IkePol.uSoftSAExpirationTime = atol(&strArgs[i][0]);
					++i;
				}
            }
            else if ( strncmp(&strArgs[i][1], POTF_P1REKEY_FLAG,
                              strlen(POTF_P1REKEY_FLAG)) == 0 )
            {
               // special case because user may
               // omit space after flag
               if (strArgs[i][3] != '\0')
               {
                  dwReturn = TextToP1Rekey(&strArgs[i][3], OakLife, QMLimit);
                  if (!T2P_SUCCESS(dwReturn))  break;

                  ++i;  // advance to next arg
               }
               else
               {
                  ++i;  // advance to next arg
                  dwReturn = TextToP1Rekey(&strArgs[i][0], OakLife, QMLimit);
                  if (!T2P_SUCCESS(dwReturn))  break;

                  ++i; // advance to next arg
               }

               bP1RekeyUsed = true;
            }
            else
            {
               sprintf(STRLASTERR,
                       "Unknown flag: %s\n", strArgs[i]);
               PARSE_ERROR;
               dwReturn = POTF_FAILED;
            }
         } // end if flag
         else
         {
            sprintf(STRLASTERR,
                    "I don't understand:\n%s\n", strArgs[i]);
            PARSE_ERROR;
            dwReturn = POTF_FAILED;
         }
      } // end main processing loop

      // now do some post-processing
      // either cleanup for errors or fix up policy

      if ( bP1RekeyUsed && T2P_SUCCESS(dwReturn) && (IkePol.pOffers == NULL))
      {
         LoadIkeDefaults(IkePol);
      }

	  // filter post-processing
	  // apply interface type to transports and interface type + tunnel address to tunnels
	  if (QMFilterType == QM_TRANSPORT_FILTER)
	  {
		  for (i = 0; i < dwNumFilters; i++)
		  {
			  RPC_STATUS RpcStat = RPC_S_OK;
			  pTransportFilters[i].InterfaceType = Interface;
			  // apply guidNegPolAction so that PASS INPASS and BLOCK take effect here
			  if (UuidCompare(&(tmpStorageInfo.guidNegPolAction), (UUID *) &GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU, &RpcStat) == 0 && RpcStat == RPC_S_OK)
			  {
				  pTransportFilters[i].InboundFilterFlag = PASS_THRU;
				  pTransportFilters[i].OutboundFilterFlag = NEGOTIATE_SECURITY;
			  }
			  else if (UuidCompare(&(tmpStorageInfo.guidNegPolAction), (UUID *) &GUID_NEGOTIATION_ACTION_BLOCK, &RpcStat) == 0 && RpcStat == RPC_S_OK)
			  {
				  pTransportFilters[i].InboundFilterFlag = BLOCKING;
				  pTransportFilters[i].OutboundFilterFlag = BLOCKING;
			  }
			  else if (UuidCompare(&(tmpStorageInfo.guidNegPolAction), (UUID *) &GUID_NEGOTIATION_ACTION_NO_IPSEC, &RpcStat) == 0 && RpcStat == RPC_S_OK)
			  {
				  pTransportFilters[i].InboundFilterFlag = PASS_THRU;
				  pTransportFilters[i].OutboundFilterFlag = PASS_THRU;
			  }
		  }
	  }
	  else
	  {
		  // tunnel filter
		  for (i = 0; i < dwNumFilters; i++)
		  {
			  pTunnelFilters[i].InterfaceType = Interface;

			  if (SrcTunnelAddr == 0)
			  {
				  // SrcTunnelAddr is set to any
				  pTunnelFilters[i].SrcTunnelAddr.AddrType = IP_ADDR_SUBNET;
				  pTunnelFilters[i].SrcTunnelAddr.uIpAddr = SUBNET_ADDRESS_ANY;
				  pTunnelFilters[i].SrcTunnelAddr.uSubNetMask = SUBNET_MASK_ANY;
			  }
			  else
			  {
				  pTunnelFilters[i].SrcTunnelAddr.AddrType = IP_ADDR_UNIQUE;
				  pTunnelFilters[i].SrcTunnelAddr.uIpAddr = SrcTunnelAddr;
				  pTunnelFilters[i].SrcTunnelAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
			  }

			  // DesTunnelAddr is our tunnel address
			  pTunnelFilters[i].DesTunnelAddr.AddrType = IP_ADDR_UNIQUE;
			  pTunnelFilters[i].DesTunnelAddr.uIpAddr = DesTunnelAddr;
			  pTunnelFilters[i].DesTunnelAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
		  }
	  }

	  // if mainmode filters specified, apply interface type
	  if (uMMFiltAlloc)
	  {
		  for (i = 0; i < dwNumMMFilters; i++)
		  {
			  pMMFilters[i].InterfaceType = Interface;
		  }
	  }

	  if (!uMMFiltAlloc)
	  {
		  // generate mainmode filters - filter generation also depends on QMFilterType
		  if (QMFilterType == QM_TRANSPORT_FILTER)
		  {
			  // transport
			  Filter.QMFilterType = QM_TRANSPORT_FILTER;
			  for (i = 0; i < dwNumFilters; i++)
			  {
				  bool bSuccess;
				  bool bFound;
				  int j;
				  memcpy(&Filter.TransportFilter, &pTransportFilters[i], sizeof(TRANSPORT_FILTER));
				  if (Filter.TransportFilter.OutboundFilterFlag == NEGOTIATE_SECURITY
                                      || Filter.TransportFilter.InboundFilterFlag == NEGOTIATE_SECURITY)
				  { 
					bSuccess = GenerateMMFilter(Filter, pMMFilters[dwNumMMFilters]);
					assert(bSuccess);
					dwNumMMFilters++;
				  }
			  }
		  }
		  else
		  {
			  // tunnel - generate just one filter
			  bool bSuccess;
			  Filter.QMFilterType = QM_TUNNEL_FILTER;
			  memcpy(&Filter.TunnelFilter, &pTunnelFilters[0], sizeof(TUNNEL_FILTER));
			  bSuccess = GenerateMMFilter(Filter, pMMFilters[0]);
			  assert(bSuccess);
			  dwNumMMFilters++;
		  }
	  }

error_occured:
      if (!T2P_SUCCESS(dwReturn))
      {
         // error occured, clean up
         if (uFiltAlloc)
         {
			// clean up both transports and tunnels since we allocated both

		   	for (i = 0; i <= uFiltAlloc; i++)
			{
			   if (pTransportFilters[i].pszFilterName != NULL)
				   free(pTransportFilters[i].pszFilterName);
			}
			delete [] pTransportFilters;
			pTransportFilters = NULL;

			// tunnel filter
			for (i = 0; i <= uFiltAlloc; i++)
			{
			   if (pTunnelFilters[i].pszFilterName != NULL)
				   free(pTunnelFilters[i].pszFilterName);
			}
			delete [] pTunnelFilters;
			pTunnelFilters = NULL;
			dwNumFilters = 0;

			if (!uMMFiltAlloc)
			{
			   for (i = 0; i <= uMMFiltAlloc; i++)
			   {
				   if (pMMFilters[i].pszFilterName != NULL)
					   free(pMMFilters[i].pszFilterName);
			   }
			   delete [] pMMFilters;
			   pMMFilters = NULL;
			   dwNumMMFilters = 0;
			}
         }
		 if (uMMFiltAlloc)
		 {
		   for (i = 0; i <= uMMFiltAlloc; i++)
		   {
			   if (pMMFilters[i].pszFilterName != NULL)
				   free(pMMFilters[i].pszFilterName);
		   }
		   delete [] pMMFilters;
		   pMMFilters = NULL;
		   dwNumMMFilters = 0;
		 }
         if (uOfferAlloc)
         {
            delete [] IpsPol.pOffers;
            IpsPol.pOffers = NULL;
			IpsPol.dwOfferCount = 0;
         }
         if (uSecMetAlloc)
         {
            delete [] IkePol.pOffers;
            IkePol.pOffers = NULL;
			IkePol.dwOfferCount = 0;
         }
      }
      else // fix up policy as necessary
      {
         //
         // if storage info requested, copy to caller
         // only copy fields that were indicated, this gets
         // passed in with caller specified items
         //

         if (bStorageMode)
         {
			T2P_FILTER tmpf;
			tmpf.QMFilterType = QMFilterType;

            tmpStorageInfo.FilterList = new IPSEC_FILTER_SPEC[dwNumFilters];
            assert(tmpStorageInfo.FilterList != NULL);

			// convert filters
			for (i = 0; i < dwNumFilters; i++)
			{
				if (tmpf.QMFilterType == QM_TRANSPORT_FILTER)
				{
					memcpy(&(tmpf.TransportFilter), &(pTransportFilters[i]), sizeof(TRANSPORT_FILTER));
				}
				else
				{
					// tunnel
					memcpy(&(tmpf.TunnelFilter), &(pTunnelFilters[i]), sizeof(TUNNEL_FILTER));
				}
				ConvertFilter(tmpf, tmpStorageInfo.FilterList[i]);
			}

            pStorageInfo->Type = tmpStorageInfo.Type;

            if (tmpStorageInfo.szLocationName[0] != '\0')
               wcscpy(pStorageInfo->szLocationName, tmpStorageInfo.szLocationName);
            if (tmpStorageInfo.szPolicyName[0] != '\0')
               wcscpy(pStorageInfo->szPolicyName, tmpStorageInfo.szPolicyName);
            if (tmpStorageInfo.szRuleName[0] != '\0')
               wcscpy(pStorageInfo->szRuleName, tmpStorageInfo.szRuleName);
            if (tmpStorageInfo.tPollingInterval)
               pStorageInfo->tPollingInterval = tmpStorageInfo.tPollingInterval;

            pStorageInfo->guidNegPolAction   = tmpStorageInfo.guidNegPolAction;
            pStorageInfo->bSetActive         = tmpStorageInfo.bSetActive;
            pStorageInfo->bSetInActive       = tmpStorageInfo.bSetInActive;
            pStorageInfo->bDeleteRule        = tmpStorageInfo.bDeleteRule;
            pStorageInfo->bDeletePolicy      = tmpStorageInfo.bDeletePolicy;
            pStorageInfo->FilterList         = tmpStorageInfo.FilterList;
            pStorageInfo->uNumFilters        = tmpStorageInfo.uNumFilters;

         }

         // fix up MM policy
         if (bP1RekeyUsed)
         {
            // fix up Ike policy by filling each ike offer
            // with the phase1 rekey
            for (i = 0; i < IkePol.dwOfferCount; ++i)
            {
               IkePol.pOffers[i].Lifetime.uKeyExpirationKBytes = OakLife.uKeyExpirationKBytes;
               IkePol.pOffers[i].Lifetime.uKeyExpirationTime  = OakLife.uKeyExpirationTime;
               IkePol.pOffers[i].dwQuickModeLimit = QMLimit;
            }

         }
         else
         {
            // load defaults
            for (i = 0; i < IkePol.dwOfferCount; ++i)
            {
               IkePol.pOffers[i].Lifetime.uKeyExpirationKBytes = 0; // not used
               IkePol.pOffers[i].Lifetime.uKeyExpirationTime  = POTF_DEFAULT_P1REKEY_TIME;
               IkePol.pOffers[i].dwQuickModeLimit = POTF_DEFAULT_P1REKEY_QMS;
            }
         }

         // if Kerberos is used, need to set AuthInfo string
         // to dummy since RPC will choke otherwise
         for (i = 0; i < AuthInfos.dwNumAuthInfos; ++i)
         {
            if (AuthInfos.pAuthenticationInfo[i].AuthMethod == IKE_SSPI ||
                (AuthInfos.pAuthenticationInfo[i].AuthMethod == IKE_RSA_SIGNATURE &&
                 AuthInfos.pAuthenticationInfo[i].pAuthInfo == NULL)
               )
            {
               AuthInfos.pAuthenticationInfo[i].dwAuthInfoSize = 0;
               AuthInfos.pAuthenticationInfo[i].pAuthInfo = (LPBYTE) new wchar_t[1];
               AuthInfos.pAuthenticationInfo[i].pAuthInfo[0] = UNICODE_NULL;
            }
         }
      }
   } // end if args valid
   else
   {
      fprintf(stderr, "Fatal error occured processing cmd line at line %d\n",
               __LINE__ );
      dwReturn = POTF_FAILED;
   }

   //
   // OK, copy the info to the caller
   //

   memcpy(&IpsecIkePol.IpsPol, &IpsPol, sizeof(IpsPol));
   memcpy(&IpsecIkePol.IkePol, &IkePol, sizeof(IkePol));
   memcpy(&IpsecIkePol.AuthInfos, &AuthInfos, sizeof(AuthInfos));

   IpsecIkePol.pMMFilters        =   pMMFilters;
   IpsecIkePol.dwNumMMFilters    =   dwNumMMFilters;
   IpsecIkePol.QMFilterType      =   QMFilterType;
   IpsecIkePol.dwNumFilters      =   dwNumFilters;
   IpsecIkePol.pTransportFilters =   pTransportFilters;
   IpsecIkePol.pTunnelFilters    =   pTunnelFilters;

   // done

   return dwReturn;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\usepa.cpp ===
/////////////////////////////////////////////////////////////
// Copyright(c) 1998, Microsoft Corporation
//
// useparpc.cpp
//
// Created on 8/15/98 by Randyram
// Revisions:
//   2/29/00 - DKalin
//     Removed out-of-date PA RPC routines, added Ipsecpol service management
//
// This holds all the init and cleanup code for using the
// SPD API and for using SCM for controlling PA and ipsecpolsvc
// see usepa.h for usage
//
/////////////////////////////////////////////////////////////

#include "ipseccmd.h"

const TCHAR szIpsecpolsvc[] = TEXT("ipsecpolsvc");

bool PAIsRunning(OUT DWORD &dwError, TCHAR *szServ)
{
   bool     bReturn = true;
   dwError = ERROR_SUCCESS;

   SERVICE_STATUS ServStat;
   memset(&ServStat, 0, sizeof(SERVICE_STATUS));

   SC_HANDLE   schMan = OpenSCManager(szServ, NULL, SC_MANAGER_ALL_ACCESS);

   if (schMan == NULL)
   {
      dwError = GetLastError();
      bReturn = false;
   }
   else
   {
      SC_HANDLE   schPA = OpenService(schMan, TEXT("policyagent"),
                                      SERVICE_QUERY_STATUS | SERVICE_START | SERVICE_STOP);
      if (schPA == NULL)
      {
         dwError = GetLastError();
         bReturn = false;
      }
      else if (QueryServiceStatus(schPA, &ServStat))
      {
         // check the status finally
         if (ServStat.dwCurrentState != SERVICE_RUNNING)
         {
            bReturn = false;
         }
         CloseServiceHandle(schPA);
      }
      CloseServiceHandle(schMan);
   }

   return bReturn;
}

bool StartPA(OUT DWORD &dwError, OPTIONAL TCHAR *szServ)
{
   bool     bReturn = true;
   dwError = ERROR_SUCCESS;

   SERVICE_STATUS ServStat;
   memset(&ServStat, 0, sizeof(SERVICE_STATUS));

   SC_HANDLE   schMan = OpenSCManager(szServ, NULL, SC_MANAGER_ALL_ACCESS);

   if (schMan == NULL)
   {
      dwError = GetLastError();
      bReturn = false;
   }
   else
   {
      SC_HANDLE   schPA = OpenService(schMan, TEXT("policyagent"),
                                      SERVICE_QUERY_STATUS | SERVICE_START | SERVICE_STOP);
      if (schPA == NULL)
      {
         dwError = GetLastError();
         bReturn = false;
      }
      else if (QueryServiceStatus(schPA, &ServStat))
      {
         // check the status finally
         if (ServStat.dwCurrentState != SERVICE_RUNNING)
         {
            if (!StartService(schPA, 0, NULL))
             {
                dwError = GetLastError();
                bReturn = false;
             }
         }
         CloseServiceHandle(schPA);
      }
      CloseServiceHandle(schMan);
   }

   return bReturn;
}

/*********************************************************************
	FUNCTION: InstallIpsecpolService
        PURPOSE:  Installs ipsecpolsvc service (incl. copying .exe to system32 dir)
        PARAMS:
          pszFilename   - name of the .exe file (full path recommended)
		  bFailIfExists - if TRUE,  fail if service already exists,
		                  if FALSE, stop service, delete it and proceed
						  ( default = TRUE )
        RETURNS: ERROR_SUCESS or GetLastError code
        COMMENTS:
*********************************************************************/
DWORD InstallIpsecpolService (IN LPCTSTR pszFilename, IN OPTIONAL BOOL bFailIfExists)
{
	DWORD dwReturn = ERROR_SUCCESS;
	
	// open SCM Manager first
   SC_HANDLE   schMan = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
   SC_HANDLE   schIpsecpolsvc;

   if (schMan == NULL)
   {
      dwReturn = GetLastError();
   }
   else
   {
	   // OK, we have handle access to SCM manager
	   // if bFailIfExists == FALSE, let's check if service is running and stop it
	   if (!bFailIfExists)
	   {
		   if (IsIpsecpolServiceRunning(dwReturn))
		   {
				dwReturn = StopIpsecpolService();
		   }
	   }

	   // continue only if we're okay so far
	   if (dwReturn != ERROR_SUCCESS)
	   {
			CloseServiceHandle(schMan);
			return dwReturn;
	   }

	   // now handle copyfile stuff
	   TCHAR  pszDestination[MAX_PATH+1];
	   TCHAR* pszWindir = _tgetenv(TEXT("WINDIR"));
	   TCHAR* pTmp;
	   if (pszWindir == NULL || pszFilename == NULL || pszFilename[0] == 0)
	   {
		   CloseServiceHandle(schMan);
		   return ERROR_PATH_NOT_FOUND;
	   }

	   _tcscpy(pszDestination, pszWindir);
	   _tcscat(pszDestination, TEXT("\\system32\\"));

	   pTmp = (TCHAR*) _tcsrchr(pszFilename, TEXT('\\'));
	   if (pTmp == NULL)
	   {
		   _tcscat(pszDestination, pszFilename);
	   }
	   else
	   {
		   _tcscat(pszDestination, pTmp+1);
	   }

	   // now copy file
	   if (!CopyFile(pszFilename, pszDestination, FALSE))
	   {
		   CloseServiceHandle(schMan);
		   return GetLastError();
	   }

	   // now delete service if it already exists and bFailIfExists is FALSE
	   if (!bFailIfExists)
	   {
		   // check if it exists and try to delete
		  schIpsecpolsvc = OpenService(schMan, szIpsecpolsvc,
										  SERVICE_QUERY_STATUS | SERVICE_START | SERVICE_STOP | STANDARD_RIGHTS_REQUIRED );
		  if (schIpsecpolsvc == NULL)
		  {
			 dwReturn = GetLastError();
			 if (dwReturn == ERROR_INVALID_NAME || dwReturn == ERROR_SERVICE_DOES_NOT_EXIST)
			 {
				 // doesn't exist, continue normally
				 dwReturn = ERROR_SUCCESS;
			 }
			 else
			 {	 // some real error
				 CloseServiceHandle(schMan);
				 return dwReturn;
			 }
		  }
		  else
		  {
			  // service exists, delete
			  DeleteService(schIpsecpolsvc);
			  CloseServiceHandle(schIpsecpolsvc);
		  }

	   }

	   // now create new service
	   schIpsecpolsvc = CreateService(schMan,
		                              szIpsecpolsvc,
									  szIpsecpolsvc,
									  SERVICE_QUERY_STATUS | SERVICE_START | SERVICE_STOP | STANDARD_RIGHTS_REQUIRED,
									  SERVICE_WIN32_OWN_PROCESS,
									  SERVICE_DEMAND_START,
									  SERVICE_ERROR_NORMAL,
									  pszDestination,
									  NULL,
									  NULL,
									  NULL,
									  NULL,
									  NULL);
	   if (schIpsecpolsvc == NULL)
	   {
		   // some error
		   CloseServiceHandle(schMan);
		   return GetLastError();
	   }
	   CloseServiceHandle(schIpsecpolsvc);
	   CloseServiceHandle(schMan);
   }

	return dwReturn;
} /* InstallIpsecpolService */

/*********************************************************************
	FUNCTION: StartIpsecpolService
        PURPOSE:  Attempts to start ipsecpolsvc service
        PARAMS:
          pszServ - optional name of the server (default is NULL, start on local machine)
        RETURNS: ERROR_SUCESS or GetLastError code
        COMMENTS:
*********************************************************************/
DWORD StartIpsecpolService (IN OPTIONAL LPCTSTR pszServ)
{
   DWORD dwReturn = ERROR_SUCCESS;

   SERVICE_STATUS ServStat;
   memset(&ServStat, 0, sizeof(SERVICE_STATUS));

   SC_HANDLE   schMan = OpenSCManager(pszServ, NULL, SC_MANAGER_ALL_ACCESS);

   if (schMan == NULL)
   {
      dwReturn = GetLastError();
   }
   else
   {
      SC_HANDLE   schIpsecpolsvc = OpenService(schMan, szIpsecpolsvc,
                                      SERVICE_QUERY_STATUS | SERVICE_START | SERVICE_STOP);
      if (schIpsecpolsvc == NULL)
      {
         dwReturn = GetLastError();
      }
      else if (QueryServiceStatus(schIpsecpolsvc, &ServStat))
      {
         // check the status finally
         if (ServStat.dwCurrentState != SERVICE_RUNNING)
         {
            if (!StartService(schIpsecpolsvc, 0, NULL))
             {
                dwReturn = GetLastError();
             }
         }
         CloseServiceHandle(schIpsecpolsvc);
      }
      CloseServiceHandle(schMan);
   }

	return dwReturn;
} /* StartIpsecpolService */

/*********************************************************************
	FUNCTION: StopIpsecpolService
        PURPOSE:  Attempts to stop ipsecpolsvc service
        PARAMS:
          pszServ - optional name of the server (default is NULL, start on local machine)
        RETURNS: ERROR_SUCESS or GetLastError code
        COMMENTS:
*********************************************************************/
DWORD StopIpsecpolService (IN OPTIONAL LPCTSTR pszServ)
{
   DWORD dwReturn = ERROR_SUCCESS;

   SERVICE_STATUS ServStat;
   memset(&ServStat, 0, sizeof(SERVICE_STATUS));

   SC_HANDLE   schMan = OpenSCManager(pszServ, NULL, SC_MANAGER_ALL_ACCESS);

   if (schMan == NULL)
   {
      dwReturn = GetLastError();
   }
   else
   {
      SC_HANDLE   schIpsecpolsvc = OpenService(schMan, szIpsecpolsvc,
                                      SERVICE_QUERY_STATUS | SERVICE_START | SERVICE_STOP);
      if (schIpsecpolsvc == NULL)
      {
         dwReturn = GetLastError();
      }
      else if (QueryServiceStatus(schIpsecpolsvc, &ServStat))
      {
         // check the status finally
         if (ServStat.dwCurrentState == SERVICE_RUNNING)
         {
            if (!ControlService(schIpsecpolsvc, SERVICE_CONTROL_STOP, &ServStat))
             {
                dwReturn = GetLastError();
             }
         }
         CloseServiceHandle(schIpsecpolsvc);
      }
      CloseServiceHandle(schMan);
   }

	return dwReturn;
} /* StopIpsecpolService */

/*********************************************************************
	FUNCTION: IsIpsecpolServiceRunning
        PURPOSE:  Checks if ipsecpolsvc service is currently running
        PARAMS:
		  dwReturn - holds errors retuned by SCM if any
          pszServ  - optional name of the server (default is NULL, start on local machine)
        RETURNS:  TRUE/FALSE
        COMMENTS: TRUE returned means service is running
		          FALSE and dwReturn == ERROR_SUCCESS means service is not running
				  FALSE and dwReturn != ERROR_SUCCESS means SCM operation failed (dwReturn is error code)
*********************************************************************/
BOOL IsIpsecpolServiceRunning (OUT DWORD &dwReturn, OPTIONAL LPCTSTR pszServ)
{
   BOOL     bReturn = TRUE;
   dwReturn = ERROR_SUCCESS;

   SERVICE_STATUS ServStat;
   memset(&ServStat, 0, sizeof(SERVICE_STATUS));

   SC_HANDLE   schMan = OpenSCManager(pszServ, NULL, SC_MANAGER_ALL_ACCESS);

   if (schMan == NULL)
   {
      dwReturn = GetLastError();
      bReturn  = FALSE;
   }
   else
   {
      SC_HANDLE   schIpsecpolsvc = OpenService(schMan, szIpsecpolsvc,
                                      SERVICE_QUERY_STATUS | SERVICE_START | SERVICE_STOP);
      if (schIpsecpolsvc == NULL)
      {
         dwReturn = GetLastError();
         bReturn  = FALSE;
      }
      else if (QueryServiceStatus(schIpsecpolsvc, &ServStat))
      {
         // check the status finally
         if (ServStat.dwCurrentState != SERVICE_RUNNING)
         {
            bReturn = FALSE;
         }
         CloseServiceHandle(schIpsecpolsvc);
      }
      CloseServiceHandle(schMan);
   }

   return bReturn;
} /* IsIpsecpolServiceRunning */

/*********************************************************************
	FUNCTION: InitIpsecpolsvcRPC
        PURPOSE:  Get an RPC handle from ipsecpolsvc that can be used to call its APIs
        PARAMS:
          pszServ      - name of the server (pass NULL for the local machine)
		  hIpsecpolsvc - returned handle
        RETURNS:  RPC_S_OK or RPC api error code
        COMMENTS: Service running is not prereq
*********************************************************************/
RPC_STATUS InitIpsecpolsvcRPC (IN TCHAR *pszServ, OUT handle_t &hIpsecpolsvc)
{
	RPC_STATUS status = RPC_S_OK;
    TCHAR localProtocol[]  = TEXT("ncacn_np");
    TCHAR remoteProtocol[] = TEXT("ncacn_np");
    TCHAR endpoint[] = TEXT("\\pipe\\ipsecpolsvc");
    PUSHORT stringBinding = NULL;
    ULONG SecurityLevel = RPC_C_AUTHN_LEVEL_CONNECT;

	if (pszServ != 0)
	{
		if (pszServ[0] == 0)
		{
			// empty string
			pszServ = NULL;
		}
	}

    status = RpcStringBindingCompose(0,
									 (PUSHORT)((pszServ == NULL) ? localProtocol : remoteProtocol),
                                     (PUSHORT)pszServ,
                                     (PUSHORT)endpoint,
                                     0,
                                     &stringBinding);
    if (status == RPC_S_OK)
    {
	    status = RpcBindingFromStringBinding(stringBinding, &hIpsecpolsvc);
    }


    if (status == RPC_S_OK)
    {
		status =
		RpcBindingSetAuthInfo(hIpsecpolsvc,
							  0,
							  SecurityLevel,
							  RPC_C_AUTHN_WINNT,
							  0,
							  0
							 );
    }


	if (stringBinding != NULL)
	{
		status = RpcStringFree(&stringBinding);
	}

	return status;
} /* InitIpsecpolsvcRPC */

/*********************************************************************
	FUNCTION: ShutdownIpsecpolsvcRPC
        PURPOSE:  Close RPC handle
        PARAMS:
		  hIpsecpolsvc - handle
        RETURNS:  RPC_S_OK or RPC api error code
        COMMENTS:
*********************************************************************/
RPC_STATUS ShutdownIpsecpolsvcRPC (IN handle_t hIpsecpolsvc)
{
	return RpcBindingFree(&hIpsecpolsvc);
} /* ShutdownIpsecpolsvcRPC */

/*********************************************************************
	FUNCTION: PlumbIPSecPolicy
        PURPOSE:  Plumbs IPSEC_IKE_POLICY to the specified machine
        PARAMS:
		  pszServerName     - machine name or NULL for local
                  pIPSecIkePol      - pointer to IPSEC_IKE_POLICY.
                     GUIDs/names must be generated prior to the call
                  bFailMMIfExists   - specifies MM filter behavior
                     bFailMMIfExists == FALSE will cause the call not to break
                       on ERROR_MM_FILTER_EXISTS when duplicate MM filters are there
                     bFailMMIfExists == TRUE  will fail on any SPD API error
                  ppMMFilterHandles - array of mm filter handles will be returned here
                  ppFilterHandles   - array of qm filter handles will be returned here
				  bPersist          - if TRUE, information will be persisted
        RETURNS:  ERROR_SUCCESS or win32 error code
        COMMENTS: CALLER is responsible for freeing the memory for the handle arrays
*********************************************************************/
DWORD
PlumbIPSecPolicy(
    IN LPWSTR pServerName,
    IN PIPSEC_IKE_POLICY pIPSecIkePol,
    IN BOOL bFailMMIfExists,
    OUT PHANDLE *ppMMFilterHandles,
    OUT PHANDLE *ppFilterHandles,
	IN OPTIONAL BOOL bPersist
    )
{
	DWORD dwReturn = ERROR_SUCCESS;
	RPC_STATUS RpcStat = RPC_S_OK;
	int i;
	HANDLE hFilter;
	BOOL bDefaultRule = FALSE; // will be true if default response rule is specified
	                           // default response rule is specified if there is exactly 1 transport filter that is Me-to-Me

	if (!pIPSecIkePol)
	{
		return ERROR_NO_DATA;
	}

    if (pIPSecIkePol->dwNumFilters == 1 && pIPSecIkePol->QMFilterType == QM_TRANSPORT_FILTER)
	{
		if (pIPSecIkePol->pTransportFilters[0].SrcAddr.AddrType == IP_ADDR_UNIQUE
			&& pIPSecIkePol->pTransportFilters[0].SrcAddr.uIpAddr == IP_ADDRESS_ME
			&& pIPSecIkePol->pTransportFilters[0].DesAddr.AddrType == IP_ADDR_UNIQUE
			&& pIPSecIkePol->pTransportFilters[0].DesAddr.uIpAddr == IP_ADDRESS_ME
			&& pIPSecIkePol->pTransportFilters[0].InboundFilterFlag == (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG
			&& pIPSecIkePol->pTransportFilters[0].OutboundFilterFlag == (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG)
		{
			bDefaultRule = TRUE;
		}
	}

	// allocate handle arrays first
	if (bDefaultRule)
	{
		*ppMMFilterHandles = *ppFilterHandles = 0;
		pIPSecIkePol->AuthInfos.dwFlags |= IPSEC_MM_AUTH_DEFAULT_AUTH;
		pIPSecIkePol->IkePol.dwFlags |= IPSEC_MM_POLICY_DEFAULT_POLICY;
		pIPSecIkePol->IpsPol.dwFlags |= IPSEC_QM_POLICY_DEFAULT_POLICY;
	}
	else
	{
		if (ppMMFilterHandles && pIPSecIkePol->dwNumMMFilters)
		{
			*ppMMFilterHandles = new HANDLE[pIPSecIkePol->dwNumMMFilters];
			if (*ppMMFilterHandles == 0)
			{
				return ERROR_OUTOFMEMORY;
			}
			memset(*ppMMFilterHandles, 0, sizeof(HANDLE)*pIPSecIkePol->dwNumMMFilters);
		}
		if (ppFilterHandles && pIPSecIkePol->dwNumFilters)
		{
			*ppFilterHandles = new HANDLE[pIPSecIkePol->dwNumFilters];
			if (*ppFilterHandles == 0)
			{
				if (ppMMFilterHandles)
				{
					if (*ppMMFilterHandles) { delete[] *ppMMFilterHandles; *ppMMFilterHandles = 0; }
				}
				return ERROR_OUTOFMEMORY;
			}
			memset(*ppFilterHandles, 0, sizeof(HANDLE)*pIPSecIkePol->dwNumFilters);
		}
	}

	// let's go and plumb everything
	// authinfos first
	if (!UuidIsNil(&(pIPSecIkePol->AuthInfos.gMMAuthID), &RpcStat))
	{
		dwReturn = AddMMAuthMethods(pServerName, bPersist ? PERSIST_SPD_OBJECT : 0, &(pIPSecIkePol->AuthInfos));
	}

	if (dwReturn != ERROR_SUCCESS)
	{
		if (ppMMFilterHandles && *ppMMFilterHandles) { delete[] *ppMMFilterHandles; *ppMMFilterHandles = 0; }
		if (ppFilterHandles && *ppFilterHandles)   { delete[] *ppFilterHandles;   *ppFilterHandles   = 0; }
		return dwReturn;
	}
	if (RpcStat != RPC_S_OK)
	{
		if (ppMMFilterHandles && *ppMMFilterHandles) { delete[] *ppMMFilterHandles; *ppMMFilterHandles = 0; }
		if (ppFilterHandles && *ppFilterHandles)   { delete[] *ppFilterHandles;   *ppFilterHandles   = 0; }
		return GetLastError();
	}

	// mm policy
	if (!UuidIsNil(&(pIPSecIkePol->IkePol.gPolicyID), &RpcStat))
	{
		dwReturn = AddMMPolicy(pServerName, bPersist ? PERSIST_SPD_OBJECT : 0, &(pIPSecIkePol->IkePol));
	}

	if (dwReturn != ERROR_SUCCESS)
	{
		if (ppMMFilterHandles && *ppMMFilterHandles) { delete[] *ppMMFilterHandles; *ppMMFilterHandles = 0; }
		if (ppFilterHandles && *ppFilterHandles)   { delete[] *ppFilterHandles;   *ppFilterHandles   = 0; }
		return dwReturn;
	}
	if (RpcStat != RPC_S_OK)
	{
		if (ppMMFilterHandles && *ppMMFilterHandles) { delete[] *ppMMFilterHandles; *ppMMFilterHandles = 0; }
		if (ppFilterHandles && *ppFilterHandles)   { delete[] *ppFilterHandles;   *ppFilterHandles   = 0; }
		return GetLastError();
	}

	// qm policy
	if (!UuidIsNil(&(pIPSecIkePol->IpsPol.gPolicyID), &RpcStat))
	{
		dwReturn = AddQMPolicy(pServerName, bPersist ? PERSIST_SPD_OBJECT : 0, &(pIPSecIkePol->IpsPol));
	}

	if (dwReturn != ERROR_SUCCESS)
	{
		if (ppMMFilterHandles && *ppMMFilterHandles) { delete[] *ppMMFilterHandles; *ppMMFilterHandles = 0; }
		if (ppFilterHandles && *ppFilterHandles)   { delete[] *ppFilterHandles;   *ppFilterHandles   = 0; }
		return dwReturn;
	}
	if (RpcStat != RPC_S_OK)
	{
		if (ppMMFilterHandles && *ppMMFilterHandles) { delete[] *ppMMFilterHandles; *ppMMFilterHandles = 0; }
		if (ppFilterHandles && *ppFilterHandles)   { delete[] *ppFilterHandles;   *ppFilterHandles   = 0; }
		return GetLastError();
	}

    if (bDefaultRule)
	{
		// return here
		return dwReturn;
	}

	// mm filters
	for (i = 0; i < (int) pIPSecIkePol->dwNumMMFilters; i++)
	{
                hFilter = NULL;
		if (!UuidIsNil(&(pIPSecIkePol->pMMFilters[i].gFilterID), &RpcStat))
		{
			dwReturn = AddMMFilter(pServerName, bPersist ? PERSIST_SPD_OBJECT : 0, &(pIPSecIkePol->pMMFilters[i]), &hFilter);
		}

		if (RpcStat != RPC_S_OK)
		{
			if (ppFilterHandles && *ppFilterHandles)   { delete[] *ppFilterHandles;   *ppFilterHandles   = 0; }
			return GetLastError();
		}

		if (!bFailMMIfExists && (dwReturn == ERROR_IPSEC_MM_POLICY_EXISTS || dwReturn == ERROR_IPSEC_MM_AUTH_EXISTS || dwReturn == ERROR_IPSEC_MM_FILTER_EXISTS))
		{
			dwReturn = ERROR_SUCCESS; // it's not actually an error
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			if (ppFilterHandles && *ppFilterHandles)   { delete[] *ppFilterHandles;   *ppFilterHandles   = 0; }
			return dwReturn;
		}

		if (ppMMFilterHandles)
		{
			(*ppMMFilterHandles)[i] = hFilter;
		}
	}

	// qm filters
	for (i = 0; i < (int) pIPSecIkePol->dwNumFilters; i++)
	{
                hFilter = NULL;
		if (pIPSecIkePol->QMFilterType == QM_TRANSPORT_FILTER)
		{
			if (!UuidIsNil(&(pIPSecIkePol->pTransportFilters[i].gFilterID), &RpcStat))
			{
				dwReturn = AddTransportFilter(pServerName, bPersist ? PERSIST_SPD_OBJECT : 0, &(pIPSecIkePol->pTransportFilters[i]), &hFilter);
			}
		}
		else
		{
			// tunnel
			if (!UuidIsNil(&(pIPSecIkePol->pTunnelFilters[i].gFilterID), &RpcStat))
			{
				dwReturn = AddTunnelFilter(pServerName, bPersist ? PERSIST_SPD_OBJECT : 0, &(pIPSecIkePol->pTunnelFilters[i]), &hFilter);
			}
		}

		if (dwReturn != ERROR_SUCCESS)
		{
			return dwReturn;
		}
		if (RpcStat != RPC_S_OK)
		{
			return GetLastError();
		}

		if (ppFilterHandles)
		{
			(*ppFilterHandles)[i] = hFilter;
		}
	}

    return dwReturn;
} /* PlumbIPSecPolicy */

/*********************************************************************
	FUNCTION: DeleteIPSecPolicy
        PURPOSE:  Complementary to PlumbIPSecPolicy, removes IPSEC_IKE_POLICY
        PARAMS:
		  pszServerName    - machine name or NULL for local
                  pIPSecIkePol     - pointer to IPSEC_IKE_POLICY.
                     GUIDs/names must be generated prior to the call
                  pMMFilterHandles - array of main mode filter handles
                  pFilterHandles   - array of quick mode filter handles
        RETURNS:  ERROR_SUCCESS or win32 error code
        COMMENTS: Function will try to
                    remove everything specified in the IPSEC_IKE_POLICY structure.
                  It is possible that one or several errors will be encountered.
                  Function will continue, but later first error will be returned.
*********************************************************************/
DWORD
DeleteIPSecPolicy(
    IN LPWSTR pServerName,
    IN PIPSEC_IKE_POLICY pIPSecIkePol,
    IN PHANDLE pMMFilterHandles,
    IN PHANDLE pFilterHandles
    )
{
	DWORD dwReturn     = ERROR_SUCCESS;
	DWORD dwErrorCode  = ERROR_SUCCESS;
	RPC_STATUS RpcStat = RPC_S_OK;
	int i;

	// mm filters
	if (pMMFilterHandles)
	{
		for (i = 0; i < (int) pIPSecIkePol->dwNumMMFilters; i++)
		{
			if (!UuidIsNil(&(pIPSecIkePol->pMMFilters[i].gFilterID), &RpcStat))
			{
				dwReturn = DeleteMMFilter(pMMFilterHandles[i]);
			}

			if (RpcStat != RPC_S_OK && dwErrorCode == ERROR_SUCCESS)
			{
				dwErrorCode = GetLastError();
			}

			if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
			{
				dwErrorCode = dwReturn;
			}
		}
	}

	// qm filters
	if (pFilterHandles)
	{
		for (i = 0; i < (int) pIPSecIkePol->dwNumFilters; i++)
		{
			if (pIPSecIkePol->QMFilterType == QM_TRANSPORT_FILTER)
			{
				if (!UuidIsNil(&(pIPSecIkePol->pTransportFilters[i].gFilterID), &RpcStat))
				{
					dwReturn = DeleteTransportFilter(pFilterHandles[i]);
				}
			}
			else
			{
				// tunnel
				if (!UuidIsNil(&(pIPSecIkePol->pTunnelFilters[i].gFilterID), &RpcStat))
				{
					dwReturn = DeleteTunnelFilter(pFilterHandles[i]);
				}
			}

			if (RpcStat != RPC_S_OK && dwErrorCode == ERROR_SUCCESS)
			{
				dwErrorCode = GetLastError();
			}

			if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
			{
				dwErrorCode = dwReturn;
			}
		}
	}

	// mm auth methods
	if (!UuidIsNil(&(pIPSecIkePol->AuthInfos.gMMAuthID), &RpcStat))
	{
		dwReturn = DeleteMMAuthMethods(pServerName, pIPSecIkePol->AuthInfos.gMMAuthID);
	}
	if (RpcStat != RPC_S_OK && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = GetLastError();
	}

	if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = dwReturn;
	}

	// mm policy
	if (!UuidIsNil(&(pIPSecIkePol->IkePol.gPolicyID), &RpcStat))
	{
		dwReturn = DeleteMMPolicy(pServerName, pIPSecIkePol->IkePol.pszPolicyName);
	}
	if (RpcStat != RPC_S_OK && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = GetLastError();
	}

	if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = dwReturn;
	}

	// qm policy
	if (!UuidIsNil(&(pIPSecIkePol->IpsPol.gPolicyID), &RpcStat))
	{
		dwReturn = DeleteQMPolicy(pServerName, pIPSecIkePol->IpsPol.pszPolicyName);
	}
	if (RpcStat != RPC_S_OK && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = GetLastError();
	}

	if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = dwReturn;
	}

	return dwErrorCode;

} /* DeleteIPSecPolicy */

/*********************************************************************
	FUNCTION: DeletePersistedIPSecPolicy
        PURPOSE:  Complementary to PlumbIPSecPolicy with persistent flag on,
					removes persisted policy
        PARAMS:
		  pszServerName    - machine name or NULL for local
		          pPolicyName - policy name prefix, if empty string of NULL,
					all persisted policy settings will be removed
        RETURNS:  ERROR_SUCCESS or win32 error code
        COMMENTS: Function will try to
                    remove everything specified.
                  It is possible that one or several errors will be encountered.
                  Function will continue, but later first error will be returned.
*********************************************************************/
DWORD
DeletePersistedIPSecPolicy(
    IN LPWSTR pServerName,
	IN LPWSTR pPolicyName
	)
{
	DWORD dwErrorCode, dwReturn;
	int i, j;
	PMM_FILTER pmmf;	           // for MM filter calls
	PIPSEC_QM_POLICY pipsqmp;      // for QM policy calls
	PTRANSPORT_FILTER ptf;	       // for transport filter calls
	PTUNNEL_FILTER ptunf;	       // for tunnel filter calls
	PMM_AUTH_METHODS pam;          // for auth method calls
	PIPSEC_MM_POLICY pipsmmp;      // for MM policy calls
	DWORD dwCount;                 // counting objects here
	DWORD dwResumeHandle;          // handle for continuation calls
	DWORD dwReserved;              // reserved container
	GUID  gDefaultGUID = {0};      // NULL GUID value
	int iPolNameLen = 0;
	HANDLE hFilter;
	BOOL bRemoveDefault = FALSE;

	dwErrorCode = dwReturn = ERROR_SUCCESS;
	if (pPolicyName && *pPolicyName)
	{
		iPolNameLen = wcslen(pPolicyName);
	}

	// start with mm filters, enum all
	pmmf=NULL;
	dwResumeHandle=0;
	// make the call(s)
	for (i = 0; ;i+=dwCount)
	{
		BOOL bRemoved = FALSE;
		DWORD dwOldResumeHandle = dwResumeHandle;

		dwReturn = EnumMMFilters(pServerName, ENUM_GENERIC_FILTERS, gDefaultGUID, &pmmf, 0, &dwCount, &dwResumeHandle);
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
		    // no more filters
			break;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			break;
		}
		for (j = 0; j < (int) dwCount; j++)
		{
			// check if it's our filter
			if (iPolNameLen == 0|| wcsncmp(pPolicyName, pmmf[j].pszFilterName, iPolNameLen) == 0)
			{
				dwReturn = OpenMMFilterHandle(pServerName, &(pmmf[j]), &hFilter);
				if (dwReturn == ERROR_SUCCESS)
				{
					dwReturn = DeleteMMFilter(hFilter);
					if (dwReturn == ERROR_SUCCESS)
					{
						bRemoved = TRUE;
					}
					if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
					{
						dwErrorCode = dwReturn;
					}
					dwReturn = CloseMMFilterHandle(hFilter);
				}
				if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
				{
					dwErrorCode = dwReturn;
				}
			}
		}
		SPDApiBufferFree(pmmf);
		pmmf=NULL;
		if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
		{
			dwErrorCode = dwReturn;
		}
		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration!
		}
	}
	if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = dwReturn;
	}

	// transport filters - the routine is similar
	ptf=NULL;
	dwResumeHandle=0;
	// make the call(s)
	for (i = 0; ;i+=dwCount)
	{
		BOOL bRemoved = FALSE;
		DWORD dwOldResumeHandle = dwResumeHandle;

		dwReturn = EnumTransportFilters(pServerName, ENUM_GENERIC_FILTERS, gDefaultGUID, &ptf, 0, &dwCount, &dwResumeHandle);
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
		    // no more filters
			break;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			break;
		}
		for (j = 0; j < (int) dwCount; j++)
		{
			// check if it's our filter
			if (iPolNameLen == 0|| wcsncmp(pPolicyName, ptf[j].pszFilterName, iPolNameLen) == 0)
			{
				dwReturn = OpenTransportFilterHandle(pServerName, &(ptf[j]), &hFilter);
				if (dwReturn == ERROR_SUCCESS)
				{
					dwReturn = DeleteTransportFilter(hFilter);
					if (dwReturn == ERROR_SUCCESS)
					{
						bRemoved = TRUE;
					}
					if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
					{
						dwErrorCode = dwReturn;
					}
					dwReturn = CloseTransportFilterHandle(hFilter);
				}
				if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
				{
					dwErrorCode = dwReturn;
				}
			}
		}
		SPDApiBufferFree(ptf);
		ptf=NULL;
		if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
		{
			dwErrorCode = dwReturn;
		}
		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration!
		}
	}
	if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = dwReturn;
	}

	// tunnel filters
	ptunf=NULL;
	dwResumeHandle=0;
	// make the call(s)
	for (i = 0; ;i+=dwCount)
	{
		BOOL bRemoved = FALSE;
		DWORD dwOldResumeHandle = dwResumeHandle;

		dwReturn = EnumTunnelFilters(pServerName, ENUM_GENERIC_FILTERS, gDefaultGUID, &ptunf, 0, &dwCount, &dwResumeHandle);
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
		    // no more filters
			break;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			break;
		}
		for (j = 0; j < (int) dwCount; j++)
		{
			// check if it's our filter
			if (iPolNameLen == 0|| wcsncmp(pPolicyName, ptunf[j].pszFilterName, iPolNameLen) == 0)
			{
				dwReturn = OpenTunnelFilterHandle(pServerName, &(ptunf[j]), &hFilter);
				if (dwReturn == ERROR_SUCCESS)
				{
					dwReturn = DeleteTunnelFilter(hFilter);
					if (dwReturn == ERROR_SUCCESS)
					{
						bRemoved = TRUE;
					}
					if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
					{
						dwErrorCode = dwReturn;
					}
					dwReturn = CloseTunnelFilterHandle(hFilter);
				}
				if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
				{
					dwErrorCode = dwReturn;
				}
			}
		}
		SPDApiBufferFree(ptunf);
		ptunf=NULL;
		if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
		{
			dwErrorCode = dwReturn;
		}
		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration!
		}
	}
	if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = dwReturn;
	}

    // mm policies
	pipsmmp=NULL;
	dwResumeHandle=0;
	// make the call(s)
	for (i = 0; ;i+=dwCount)
	{
		BOOL bRemoved = FALSE;
		DWORD dwOldResumeHandle = dwResumeHandle;

		dwReturn = EnumMMPolicies(pServerName, &pipsmmp, 0, &dwCount, &dwResumeHandle);
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
		    // no more filters
			break;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			break;
		}
		for (j = 0; j < (int) dwCount; j++)
		{
			// check if it's our mm policy
			if (iPolNameLen == 0|| wcsncmp(pPolicyName, pipsmmp[j].pszPolicyName, iPolNameLen) == 0)
			{
				dwReturn = DeleteMMPolicy(pServerName, pipsmmp[j].pszPolicyName);
				if (dwReturn == ERROR_SUCCESS)
				{
					bRemoved = TRUE;
				}
				if (dwReturn == ERROR_SUCCESS && (pipsmmp[j].dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY))
				{	// got to remove other defaults too
					bRemoveDefault = TRUE;
				}
				if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
				{
					dwErrorCode = dwReturn;
				}
			}
		}
		SPDApiBufferFree(pipsmmp);
		pipsmmp=NULL;
		if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
		{
			dwErrorCode = dwReturn;
		}
		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration!
		}
	}
	if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = dwReturn;
	}

    // auth methods
	pam=NULL;
	dwResumeHandle=0;
	// make the call(s)
	for (i = 0; ;i+=dwCount)
	{
		BOOL bRemoved = FALSE;
		DWORD dwOldResumeHandle = dwResumeHandle;

		dwReturn = EnumMMAuthMethods(pServerName, &pam, 0, &dwCount, &dwResumeHandle);
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
		    // no more filters
			break;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			break;
		}
		for (j = 0; j < (int) dwCount; j++)
		{
			// check if it's our auth method
			if (bRemoveDefault || (pam[j].dwFlags & IPSEC_MM_AUTH_DEFAULT_AUTH) == 0)
			{ // either remove default is set or this is non-default
				dwReturn = DeleteMMAuthMethods(pServerName, pam[j].gMMAuthID);
				if (dwReturn == ERROR_SUCCESS)
				{
					bRemoved = TRUE;
				}
				if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
				{
					dwErrorCode = dwReturn;
				}
			}
		}
		SPDApiBufferFree(pam);
		pam=NULL;
		if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
		{
			dwErrorCode = dwReturn;
		}
		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration!
		}
	}
	if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = dwReturn;
	}

	// qm policies
	pipsqmp=NULL;
	dwResumeHandle=0;
	// make the call(s)
	for (i = 0; ;i+=dwCount)
	{
		BOOL bRemoved = FALSE;
		DWORD dwOldResumeHandle = dwResumeHandle;

		dwReturn = EnumQMPolicies(pServerName, &pipsqmp, 0, &dwCount, &dwResumeHandle);
		if (dwReturn == ERROR_NO_DATA || dwCount == 0)
		{
			dwReturn = ERROR_SUCCESS;
		    // no more filters
			break;
		}
		if (dwReturn != ERROR_SUCCESS)
		{
			break;
		}
		for (j = 0; j < (int) dwCount; j++)
		{
			// check if it's our qm policy
			if (iPolNameLen == 0|| wcsncmp(pPolicyName, pipsqmp[j].pszPolicyName, iPolNameLen) == 0)
			{
				dwReturn = DeleteQMPolicy(pServerName, pipsqmp[j].pszPolicyName);
				if (dwReturn == ERROR_SUCCESS)
				{
					bRemoved = TRUE;
				}
				if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
				{
					dwErrorCode = dwReturn;
				}
			}
		}
		SPDApiBufferFree(pipsqmp);
		pipsqmp=NULL;
		if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
		{
			dwErrorCode = dwReturn;
		}
		if (bRemoved)
		{
			dwResumeHandle = dwOldResumeHandle; // need to restart enumeration!
		}
	}
	if (dwReturn != ERROR_SUCCESS && dwErrorCode == ERROR_SUCCESS)
	{
		dwErrorCode = dwReturn;
	}

	return dwErrorCode;
} /* DeletePersistedIPSecPolicy */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipsecshr\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <wchar.h>
#include <dsgetdc.h>
#include <lm.h>

#define UNICODE

#include <winldap.h>
#include <ipsec.h>
#include <oakdefs.h>
#include <polstructs.h>

#include "winsock2.h"
#include "winsock.h"
#include "spd_c.h"
#include "ipsecshr.h"


#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {                   \
        goto error;                  \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipsecshr\ikeutils.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    IKE utils

Abstract:

    Contains parameter validation 

Author:

    BrianSw  10-19-200

Environment:

    User Level: Win32

Revision History:


--*/

#include "precomp.h"


DWORD
ValidateInitiateIKENegotiation(
    STRING_HANDLE pServerName,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    DWORD dwFlags,
    IKENEGOTIATION_HANDLE * phIKENegotiation
    )
{

    DWORD dwError=ERROR_SUCCESS;

    if (pQMFilterContainer == NULL ||
        pQMFilterContainer->pQMFilters == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }

    if (pServerName && (wcscmp(pServerName,L"") != 0)) {
        if (uhClientEvent || phIKENegotiation || dwClientProcessId) {
            dwError=ERROR_NOT_SUPPORTED;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    } else {
        if (phIKENegotiation || dwClientProcessId || uhClientEvent) {
            if (!phIKENegotiation || !dwClientProcessId || !uhClientEvent) {
                dwError=ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
        }
    }

    if (!(pQMFilterContainer->pQMFilters) ||
        !(pQMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    
    dwError = ValidateIPSecQMFilter(
        pQMFilterContainer->pQMFilters
        );
    BAIL_ON_WIN32_ERROR(dwError);    

error:
    return dwError;
}


DWORD
ValidateQueryIKENegotiationStatus(
    IKENEGOTIATION_HANDLE hIKENegotiation,
    SA_NEGOTIATION_STATUS_INFO *NegotiationStatus
    )

{

    DWORD dwError=ERROR_SUCCESS;
    
    if (!hIKENegotiation || !NegotiationStatus) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
error:
    return dwError;
}


DWORD
ValidateCloseIKENegotiationHandle(
    IKENEGOTIATION_HANDLE * phIKENegotiation
    )
{
    DWORD dwError=ERROR_SUCCESS;
    
    if (!phIKENegotiation) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}



DWORD
ValidateEnumMMSAs(
    STRING_HANDLE pServerName, 
    PMM_SA_CONTAINER pMMTemplate,
    PMM_SA_CONTAINER *ppMMSAContainer,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle,
    DWORD dwFlags
    )
{
    DWORD dwError=ERROR_SUCCESS;

    if (pMMTemplate == NULL ||
        pMMTemplate->pMMSAs == NULL ||
        ppMMSAContainer == NULL ||
        *ppMMSAContainer == NULL ||
        pdwNumEntries == NULL ||
        pdwTotalMMsAvailable == NULL ||
        pdwEnumHandle == NULL ) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}


DWORD
ValidateDeleteMMSAs(
    STRING_HANDLE pServerName, 
    PMM_SA_CONTAINER pMMTemplate,
    DWORD dwFlags
    )

{

    DWORD dwError=ERROR_SUCCESS;

    if (pMMTemplate == NULL ||
        pMMTemplate->pMMSAs == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}

DWORD
ValidateQueryIKEStatistics(
    STRING_HANDLE pServerName, 
    IKE_STATISTICS *pIKEStatistics
    )

{

    DWORD dwError=ERROR_SUCCESS;

    if (pIKEStatistics == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}


DWORD
ValidateRegisterIKENotifyClient(
    STRING_HANDLE pServerName,    
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    PQM_SA_CONTAINER pQMSATemplateContainer,
    IKENOTIFY_HANDLE *phNotifyHandle,
    DWORD dwFlags
    )

{
    DWORD dwError=ERROR_SUCCESS;

    if (pServerName && (wcscmp(pServerName,L"") != 0)) {
        return ERROR_NOT_SUPPORTED;
    }

    if (pQMSATemplateContainer == NULL ||
        pQMSATemplateContainer->pQMSAs == NULL ||
        phNotifyHandle == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    } 
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;

}

DWORD ValidateQueryNotifyData(
    IKENOTIFY_HANDLE uhNotifyHandle,
    PDWORD pdwNumEntries,
    PQM_SA_CONTAINER *ppQMSAContainer,
    DWORD dwFlags
    )

{

    DWORD dwError=ERROR_SUCCESS;

    if (ppQMSAContainer == NULL ||
        *ppQMSAContainer == NULL ||
        pdwNumEntries == NULL ||
        *pdwNumEntries == 0) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);        

error:
    return dwError;

}

DWORD ValidateCloseNotifyHandle(
    IKENOTIFY_HANDLE *phHandle
    )
{
    DWORD dwError=ERROR_SUCCESS;

    if (phHandle == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:
    return dwError;
}


DWORD ValidateIPSecAddSA(
    STRING_HANDLE pServerName,
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    DWORD *uhLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE *pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *pOutboundKeyMat,
    BYTE *pContextInfo,
    DWORD dwFlags)
{
    DWORD dwError=ERROR_SUCCESS;

    if (!pQMFilterContainer ||
        !pQMPolicyContainer ||
        pContextInfo == NULL) {
        dwError= ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    if (uhLarvalContext == NULL){
        dwError= ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (!(pQMFilterContainer->pQMFilters) ||
        !(pQMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicyContainer->pPolicies) ||
        !(pQMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateIPSecQMFilter(
        pQMFilterContainer->pQMFilters
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ValidateQMOffers(
        1,
        pQMPolicyContainer->pPolicies->pOffers);
    BAIL_ON_WIN32_ERROR(dwError);

    if ((dwFlags & IPSEC_SA_INBOUND) &&
        (dwFlags & IPSEC_SA_OUTBOUND)) {
        dwError= ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\text2spd.cpp ===
/////////////////////////////////////////////////////////////
// Copyright(c) 2000-2001, Microsoft Corporation
//
// text2spd.cpp
//
// Created on 2/15/00 by DKalin
// Revisions:
// Split into text2spd.cpp and spdutil.cpp 3/27/01 DKalin
//
// Moved the routines to this module from text2pol.cpp 2/15/00 DKalin
//
// Implementation for the text to policy conversion routines that deal directly with SPD structures
//
// Separated from generic routines in text2pol.cpp
//
/////////////////////////////////////////////////////////////

#include "ipseccmd.h"


// if szSrc and/or szDst are passed in,
// caller must provide adequate space

DWORD TextToFilter(IN char *szText, IN OUT T2P_FILTER &Filter, char *szSrc, char *szDst)
{
   DWORD  dwReturn = T2P_OK;   // return code of this function
   char  *pToken = NULL, *pTmp = NULL;
   char  szTmp[POTF_MAX_STRLEN];
   char  *pPortTok = NULL,
         *pProtTok = NULL;
   BOOL  bMirror = false;

   if (szText != NULL)  // do not assume that caller is smart
   {
      // We copy szText to szTmp so we can muck with it
      // in the process, we
      // determine passthru or drop filter

	  // but first we set this filter to negotiate security and to be not mirrored
	  // we also set protocol field
	  if (Filter.QMFilterType != QM_TUNNEL_FILTER)
		{
			// transport filter

		    // the very first thing we do is check for default response rule specified
		    // then we set both Inbound and Outbound filter flags to POTF_DEFAULT_RESPONSE_FLAG
		    // and substitute "DEFAULT" string with "0+0" (Me-to-Me)
            if (_stricmp(POTF_FILTER_DEFAULT, szText) == 0)
			{
	  		    Filter.TransportFilter.InboundFilterFlag     = (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG;
			    Filter.TransportFilter.OutboundFilterFlag    = (FILTER_FLAG) POTF_DEFAULT_RESPONSE_FLAG;
				szText[0] = '0';
				szText[1] = '+';
				szText[2] = '0';
				szText[3] = '\0';
			}
			else
			{
  				Filter.TransportFilter.InboundFilterFlag     = NEGOTIATE_SECURITY;
				Filter.TransportFilter.OutboundFilterFlag    = NEGOTIATE_SECURITY;
			}

			Filter.TransportFilter.bCreateMirror         = FALSE;
			Filter.TransportFilter.Protocol.ProtocolType = PROTOCOL_UNIQUE;
			Filter.TransportFilter.Protocol.dwProtocol   = 0;
		}
		else
		{
			// tunnel filter
  		    Filter.TunnelFilter.InboundFilterFlag     = NEGOTIATE_SECURITY;
		    Filter.TunnelFilter.OutboundFilterFlag    = NEGOTIATE_SECURITY;
			Filter.TunnelFilter.bCreateMirror         = FALSE;
			Filter.TunnelFilter.Protocol.ProtocolType = PROTOCOL_UNIQUE;
			Filter.TunnelFilter.Protocol.dwProtocol   = 0;
			UuidCreateNil(&(Filter.TunnelFilter.SrcTunnelAddr.gInterfaceID));
			UuidCreateNil(&(Filter.TunnelFilter.DesTunnelAddr.gInterfaceID));
		}

      pToken = strchr(szText, POTF_PASSTHRU_OPEN_TOKEN);
      if (pToken != NULL)
      {
         if (strrchr(szText, POTF_PASSTHRU_CLOSE_TOKEN) == NULL)
         {
            dwReturn = T2P_PASSTHRU_NOT_CLOSED;
         }
         else
         {
            strcpy(szTmp, szText + 1);
            szTmp[strlen(szTmp) - 1] = '\0';
			if (Filter.QMFilterType != QM_TUNNEL_FILTER)
			{
				// transport filter
	            Filter.TransportFilter.InboundFilterFlag  = PASS_THRU;
	            Filter.TransportFilter.OutboundFilterFlag = PASS_THRU;
			}
			else
			{
				// tunnel filter
	            Filter.TunnelFilter.InboundFilterFlag  = PASS_THRU;
	            Filter.TunnelFilter.OutboundFilterFlag = PASS_THRU;
			}
         }
      }
      else if ( (pToken = strchr(szText, POTF_DROP_OPEN_TOKEN)) != NULL )
      {
         if (strrchr(szText, POTF_DROP_CLOSE_TOKEN) == NULL)
         {
            dwReturn = T2P_DROP_NOT_CLOSED;
         }
         else
         {
            strcpy(szTmp, szText + 1);
            szTmp[strlen(szTmp) - 1] = '\0';
			if (Filter.QMFilterType != QM_TUNNEL_FILTER)
			{
				// transport filter
	            Filter.TransportFilter.dwFlags |= FILTER_NATURE_BLOCKING;
	            Filter.TransportFilter.InboundFilterFlag  = BLOCKING;
	            Filter.TransportFilter.OutboundFilterFlag = BLOCKING;
			}
			else
			{
				// tunnel filter
	            Filter.TunnelFilter.dwFlags |= FILTER_NATURE_BLOCKING;
	            Filter.TunnelFilter.InboundFilterFlag  = BLOCKING;
	            Filter.TunnelFilter.OutboundFilterFlag = BLOCKING;
			}
         }
      }
      else
         strcpy(szTmp, szText);

      // parse into source and dest strings
      for (pToken = szText; *pToken != POTF_FILTER_TOKEN &&
          *pToken != POTF_FILTER_MIRTOKEN &&
          *pToken != '\0'; ++pToken)
         ;
      if (*pToken == '\0')
      {
         dwReturn = T2P_NOSRCDEST_TOKEN;
      }
      else if ( *(pToken + 1) == '\0' )
      {
         dwReturn = T2P_NO_DESTADDR;
      }
      else if (T2P_SUCCESS(dwReturn))
      {
         if (*pToken == POTF_FILTER_MIRTOKEN)
		 {
			 bMirror = TRUE;
			 // set Mirrored = true
			 if (Filter.QMFilterType != QM_TUNNEL_FILTER)
			 {
				 // transport filter
				 Filter.TransportFilter.bCreateMirror = TRUE;
			 }
			 else
			 {
				 // tunnel filter
				 Filter.TunnelFilter.bCreateMirror = TRUE;
			 }
		 }

         if (!bMirror)
            pToken = strchr(szTmp,  POTF_FILTER_TOKEN);
         else
            pToken = strchr(szTmp,  POTF_FILTER_MIRTOKEN);

         *pToken = '\0';

         // do the src address
         dwReturn = TextToFiltAddr(szTmp, Filter, szSrc);
         if (T2P_SUCCESS(dwReturn))
         {
            // do the dest address
            pPortTok = strchr(pToken + 1, POTF_PT_TOKEN);

            if (pPortTok == NULL)  // no port/prot specified
               dwReturn = TextToFiltAddr(pToken + 1, Filter, szDst, true);
            else if ( (pProtTok = strchr(pPortTok + 1, POTF_PT_TOKEN)) == NULL )
            {
               // there is a port but not a protocol specified
               // this is illegal (bug 285266)
               dwReturn = T2P_INVALID_ADDR;
            }
            else
            {
               // there is both port and protocol specified
               *pProtTok = '\0';
               dwReturn = TextToFiltAddr(pToken + 1, Filter, szDst, true);
               if (T2P_SUCCESS(dwReturn))
               {
					if (Filter.QMFilterType != QM_TUNNEL_FILTER)
					{
						// transport filter
						Filter.TransportFilter.Protocol.ProtocolType = PROTOCOL_UNIQUE;
	                    dwReturn = TextToProtocol(pProtTok + 1, Filter.TransportFilter.Protocol.dwProtocol);
					}
					else
					{
						// tunnel filter
						Filter.TunnelFilter.Protocol.ProtocolType = PROTOCOL_UNIQUE;
	                    dwReturn = TextToProtocol(pProtTok + 1, Filter.TunnelFilter.Protocol.dwProtocol);
					}
               }
            }
         }

         // we're done, do any fixing up of Filter
         if (T2P_SUCCESS(dwReturn))
         {
			if (Filter.QMFilterType != QM_TUNNEL_FILTER)
			{
				// transport filter
				// set the GUID
				RPC_STATUS RpcStat = UuidCreate(&Filter.TransportFilter.gFilterID);
				if (RpcStat != RPC_S_OK && RpcStat != RPC_S_UUID_LOCAL_ONLY)
				{
				   dwReturn = RpcStat;
				}

				// set the name to be equal to the "text2pol " + GUID
				if (T2P_SUCCESS(dwReturn))
				{
					WCHAR StringTxt[POTF_MAX_STRLEN];
					int iReturn;

					wcscpy(StringTxt, L"text2pol ");
					iReturn = StringFromGUID2(Filter.TransportFilter.gFilterID, StringTxt+wcslen(StringTxt), POTF_MAX_STRLEN-wcslen(StringTxt));
					assert(iReturn != 0);
					Filter.TransportFilter.pszFilterName = new WCHAR[wcslen(StringTxt)+1];
					assert(Filter.TransportFilter.pszFilterName != NULL);
					wcscpy(Filter.TransportFilter.pszFilterName, StringTxt);
				}
			}
			else
			{
				// tunnel filter
				// set the GUID
				RPC_STATUS RpcStat = UuidCreate(&Filter.TunnelFilter.gFilterID);
				if (RpcStat != RPC_S_OK && RpcStat != RPC_S_UUID_LOCAL_ONLY)
				{
				   dwReturn = RpcStat;
				}

				// set the name to be equal to the "text2pol " + GUID
				if (T2P_SUCCESS(dwReturn))
				{
					WCHAR StringTxt[POTF_MAX_STRLEN];
					int iReturn;

					wcscpy(StringTxt, L"text2pol ");
					iReturn = StringFromGUID2(Filter.TunnelFilter.gFilterID, StringTxt+wcslen(StringTxt), POTF_MAX_STRLEN-wcslen(StringTxt));
					assert(iReturn != 0);
					Filter.TunnelFilter.pszFilterName = new WCHAR[wcslen(StringTxt)+1];
					assert(Filter.TunnelFilter.pszFilterName != NULL);
					wcscpy(Filter.TunnelFilter.pszFilterName, StringTxt);
				}
			}
         }
      }
   }
   else  // szText is NULL
      dwReturn = T2P_NULL_STRING;

   return dwReturn;
}

DWORD TextToFiltAddr(IN char *szAddr, IN OUT T2P_FILTER & Filter,
                     OUT char *szName,
                     IN bool bDest) // bDest is false
{
   DWORD  dwReturn = T2P_OK;

   IPAddr   Address  = INADDR_NONE;
   IPMask   Mask     = INADDR_NONE;
   WORD     Port = 0;
   char     *pMask = NULL,
   *pPort = NULL,
   *pPeek = NULL;
   bool     bInterface = false;
   GUID     gInterfaceId;

   struct hostent    *pHostEnt;


   if (szAddr != NULL)
   {
      // copy szAddr so we can muck with it
      char szTmp[POTF_MAX_STRLEN];
      strcpy(szTmp, szAddr);

      // let's see what we have here
      if ( (pPort = strrchr(szTmp, POTF_PT_TOKEN)) != NULL )
      {
         *pPort = '\0';
         ++pPort;
      }
      if ( (pMask = strrchr(szTmp, POTF_MASK_TOKEN)) != NULL )
      {
         *pMask = '\0';
         ++pMask;
      }

      // first, the easy cases
      // To specify ME, use 0 for the address and -1 for the mask
      // To specify ANY use 0 for the address and 0 for the mask.
      if (szTmp[0] == POTF_ANYADDR_TOKEN)
      {
         Address = SUBNET_ADDRESS_ANY;
		 Mask = SUBNET_MASK_ANY;
      }
      else if (szTmp[0] == POTF_ME_TOKEN)
      {
         Address = IP_ADDRESS_ME;
         Mask = IP_ADDRESS_MASK_NONE;
      }
      else if (szTmp[0] == POTF_GUID_TOKEN)
      {  // interface-specific filter
         char *pGUIDEnd = NULL;
         if ( (pGUIDEnd = strrchr(szTmp, POTF_GUID_END_TOKEN)) != NULL )
         {
            *pGUIDEnd = '\0';
         }
         if (pGUIDEnd && UuidFromStringA((unsigned char *)(szTmp+1), &gInterfaceId) == RPC_S_OK)
         {
            bInterface = true;
         }
         else
         {
            dwReturn = T2P_INVALID_ADDR;
         }
      }
      else if (isdnsname(szTmp))   // DNS name
      {
         pHostEnt = gethostbyname(szTmp);
         if (pHostEnt != NULL)
         {
            Address = *(IPAddr *)pHostEnt->h_addr;
            // should check for more here, but not now

            // specific host, Mask is 255.255.255.255
            Mask = IP_ADDRESS_MASK_NONE;
         }
         else
         {
            dwReturn = T2P_DNSLOOKUP_FAILED;
         }

         if ( szName )
            strcpy(szName, szTmp);
      }
      else  // good old dotted notation
      {
         // process the * shortcut for subnetting
         if (strchr(szTmp, POTF_STAR_TOKEN) != NULL)
         {
            Mask = 0x000000FF;
            for (pPeek = szTmp; *pPeek != '\0'; ++pPeek)
            {
               if ((*pPeek == '.') && (*(pPeek + 1) != POTF_STAR_TOKEN))
                  Mask |= (Mask << 8);
               else if ((*pPeek == '.') && (*(pPeek + 1) != '\0'))
                  *(pPeek + 1) = '0';
            }
         }

         Address = inet_addr(szTmp);
         if (Address == INADDR_NONE)
         {
            dwReturn = T2P_INVALID_ADDR;
         }
         else
         {
            if (pMask != NULL)
            {
               Mask = inet_addr(pMask);
            }
            else if (pPeek == NULL)
               Mask = IP_ADDRESS_MASK_NONE;
         }
      }

      // now for the port and fill the Filter out
      if (T2P_SUCCESS(dwReturn))
      {
         if (pPort != NULL)
         {
            Port = (SHORT)atoi(pPort);
         }

		 if (Filter.QMFilterType != QM_TUNNEL_FILTER)
		 {
			 // transport filter
			 if (bDest) // we converted the dest addr
			 {
                            if (!bInterface)
                            {
				Filter.TransportFilter.DesAddr.AddrType   = (Mask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
				Filter.TransportFilter.DesAddr.uIpAddr     = Address;
				Filter.TransportFilter.DesAddr.uSubNetMask = Mask;
				Filter.TransportFilter.DesPort.PortType    = PORT_UNIQUE;
				Filter.TransportFilter.DesPort.wPort       = Port;
				UuidCreateNil(&(Filter.TransportFilter.DesAddr.gInterfaceID));
                            }
                            else
                            {
				Filter.TransportFilter.DesAddr.AddrType   = IP_ADDR_INTERFACE;
				Filter.TransportFilter.DesAddr.uIpAddr     = IP_ADDRESS_ME;
				Filter.TransportFilter.DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
				Filter.TransportFilter.DesPort.PortType    = PORT_UNIQUE;
				Filter.TransportFilter.DesPort.wPort       = Port;
				Filter.TransportFilter.DesAddr.gInterfaceID = gInterfaceId;
                            }
			 }
			 else
			 {
                            if (!bInterface)
                            {
				Filter.TransportFilter.SrcAddr.AddrType   = (Mask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
				Filter.TransportFilter.SrcAddr.uIpAddr     = Address;
				Filter.TransportFilter.SrcAddr.uSubNetMask = Mask;
				Filter.TransportFilter.SrcPort.PortType    = PORT_UNIQUE;
				Filter.TransportFilter.SrcPort.wPort       = Port;
				UuidCreateNil(&(Filter.TransportFilter.SrcAddr.gInterfaceID));
                            }
                            else
                            {
				Filter.TransportFilter.SrcAddr.AddrType   = IP_ADDR_INTERFACE;
				Filter.TransportFilter.SrcAddr.uIpAddr     = IP_ADDRESS_ME;
				Filter.TransportFilter.SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
				Filter.TransportFilter.SrcPort.PortType    = PORT_UNIQUE;
				Filter.TransportFilter.SrcPort.wPort       = Port;
				Filter.TransportFilter.SrcAddr.gInterfaceID = gInterfaceId;
                            }
			 }
		 }
		 else
		 {
			 // tunnel filter
			 if (bDest) // we converted the dest addr
			 {
                            if (!bInterface)
                            {
				Filter.TunnelFilter.DesAddr.AddrType    = (Mask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
				Filter.TunnelFilter.DesAddr.uIpAddr     = Address;
				Filter.TunnelFilter.DesAddr.uSubNetMask = Mask;
				Filter.TunnelFilter.DesPort.PortType    = PORT_UNIQUE;
				Filter.TunnelFilter.DesPort.wPort       = Port;
				UuidCreateNil(&(Filter.TunnelFilter.DesAddr.gInterfaceID));
                            }
                            else
                            {
				Filter.TunnelFilter.DesAddr.AddrType   = IP_ADDR_INTERFACE;
				Filter.TunnelFilter.DesAddr.uIpAddr     = IP_ADDRESS_ME;
				Filter.TunnelFilter.DesAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
				Filter.TunnelFilter.DesPort.PortType    = PORT_UNIQUE;
				Filter.TunnelFilter.DesPort.wPort       = Port;
				Filter.TunnelFilter.DesAddr.gInterfaceID = gInterfaceId;
                            }
			 }
			 else
			 {
                            if (!bInterface)
                            {
				Filter.TunnelFilter.SrcAddr.AddrType    = (Mask == IP_ADDRESS_MASK_NONE) ? IP_ADDR_UNIQUE : IP_ADDR_SUBNET;
				Filter.TunnelFilter.SrcAddr.uIpAddr     = Address;
				Filter.TunnelFilter.SrcAddr.uSubNetMask = Mask;
				Filter.TunnelFilter.SrcPort.PortType    = PORT_UNIQUE;
				Filter.TunnelFilter.SrcPort.wPort       = Port;
				UuidCreateNil(&(Filter.TunnelFilter.SrcAddr.gInterfaceID));
                            }
                            else
                            {
				Filter.TunnelFilter.SrcAddr.AddrType   = IP_ADDR_INTERFACE;
				Filter.TunnelFilter.SrcAddr.uIpAddr     = IP_ADDRESS_ME;
				Filter.TunnelFilter.SrcAddr.uSubNetMask = IP_ADDRESS_MASK_NONE;
				Filter.TunnelFilter.SrcPort.PortType    = PORT_UNIQUE;
				Filter.TunnelFilter.SrcPort.wPort       = Port;
				Filter.TunnelFilter.SrcAddr.gInterfaceID = gInterfaceId;
                            }
			 }
		 }
      }
   }
   else
      dwReturn = T2P_NULL_STRING;

   return dwReturn;
}

DWORD TextToProtocol(IN char *szProt, OUT DWORD & dwProtocol)
{
   DWORD dwReturn = T2P_OK;

   if (szProt != NULL)
   {
      // is it special string
      if (isalpha(szProt[0]))
      {
         if (_stricmp(szProt, POTF_TCP_STR) == 0)
            dwProtocol = (POTF_TCP_PROTNUM);
         else if (_stricmp(szProt, POTF_UDP_STR) == 0)
            dwProtocol = (POTF_UDP_PROTNUM);
         else if (_stricmp(szProt, POTF_ICMP_STR) == 0)
            dwProtocol = (POTF_ICMP_PROTNUM);
         else if (_stricmp(szProt, POTF_RAW_STR) == 0)
            dwProtocol = (POTF_RAW_PROTNUM);
         else
         {
            dwReturn = T2P_INVALID_PROTOCOL;
         }
      }
      else
      {
         dwProtocol = ((DWORD)atol(szProt));
      }
   }

   return dwReturn;
}



DWORD TextToOffer(IN char *szText, IN OUT IPSEC_QM_OFFER & Offer)
{
   DWORD  dwReturn = T2P_OK;
   char  szTmp[POTF_MAX_STRLEN];
   char  *pAnd = NULL,
   *pOptions = NULL,
   *pString = NULL;

   if (szText != NULL)
   {
      // we will for sure overwrite the Count and Algos
      // since they are required for valid conversion
      Offer.dwNumAlgos = 0;
	  Offer.dwPFSGroup = 0;

      // copy szText so we can muck it up
      strcpy(szTmp, szText);

      // process Rekey and PFS first
      pOptions = strrchr(szTmp, POTF_NEGPOL_CLOSE);
      if ((pOptions != NULL) && *(pOptions + 1) != '\0')
      {
         ++pOptions; // we have options

         pString = strchr(pOptions, POTF_NEGPOL_PFS);
         if (pString != NULL)
         {
            char *pStr;
            Offer.bPFSRequired = TRUE;
			Offer.dwPFSGroup = PFS_GROUP_MM;
            pStr = strchr(pString, '1');
            if (pStr)
            {
		Offer.dwPFSGroup = PFS_GROUP_1;
            }
            pStr = strchr(pString, '2');
            if (pStr)
            {
		Offer.dwPFSGroup = PFS_GROUP_2;
            }
            *pString = '\0';
         }

         if (pString != pOptions)   // user could have specified just PFS
         {
            // process key lifetime

            // two params specified?
            pString = strchr(pOptions, POTF_REKEY_TOKEN);
            if (pString != NULL)
            {
               *pString = '\0';
               ++pString;

               switch (pString[strlen(pString) - 1])
               {
               case 'k':
               case 'K':
                  pString[strlen(pString) - 1] = '\0';
                  Offer.Lifetime.uKeyExpirationKBytes = atol(pString);

                  if ( Offer.Lifetime.uKeyExpirationKBytes < POTF_MIN_P2LIFE_BYTES )
                  {
                     dwReturn = T2P_P2REKEY_TOO_LOW;
                  }

                  break;
               case 's':
               case 'S':
                  pString[strlen(pString) - 1] = '\0';
                  Offer.Lifetime.uKeyExpirationTime = atol(pString);

                  if ( Offer.Lifetime.uKeyExpirationTime < POTF_MIN_P2LIFE_TIME )
                  {
                     dwReturn = T2P_P2REKEY_TOO_LOW;
                  }

                  break;
               default:
                  dwReturn = T2P_INVALID_P2REKEY_UNIT;
                  break;
               }
            }

            switch (pOptions[strlen(pOptions) - 1])
            {
            case 'k':
            case 'K':
               pOptions[strlen(pOptions) - 1] = '\0';
               Offer.Lifetime.uKeyExpirationKBytes = atol(pOptions);

               if ( Offer.Lifetime.uKeyExpirationKBytes < POTF_MIN_P2LIFE_BYTES )
               {
                  dwReturn = T2P_P2REKEY_TOO_LOW;
               }

               break;
            case 's':
            case 'S':
               pOptions[strlen(pOptions) - 1] = '\0';
               Offer.Lifetime.uKeyExpirationTime = atol(pOptions);

               if ( Offer.Lifetime.uKeyExpirationTime < POTF_MIN_P2LIFE_TIME )
               {
                  dwReturn = T2P_P2REKEY_TOO_LOW;
               }

               break;
            default:
               dwReturn = T2P_INVALID_P2REKEY_UNIT;
               break;
            }

         }

         // important: we have to do this here so the alginfo
         // gets processed ok:
         *pOptions = '\0';
      }

      if ( T2P_SUCCESS(dwReturn) )
      {
         // now process the ipsec protocol spec AH, ESP

         pAnd = strchr(szTmp, POTF_NEGPOL_AND);

         if ( pAnd != NULL )
         {
            // we have an AND proposal
            *pAnd = '\0';
            ++pAnd;

            dwReturn = TextToAlgoInfo(szTmp, Offer.Algos[Offer.dwNumAlgos]);
            ++Offer.dwNumAlgos;
            if ( T2P_SUCCESS(dwReturn) )
            {

               dwReturn = TextToAlgoInfo(pAnd, Offer.Algos[Offer.dwNumAlgos]);
               ++Offer.dwNumAlgos;
            }
         }
         else
         {
            dwReturn = TextToAlgoInfo(szTmp, Offer.Algos[Offer.dwNumAlgos]);
            ++Offer.dwNumAlgos;
         }

      }
   }
   else
      dwReturn = T2P_NULL_STRING;

   return dwReturn;
}

DWORD TextToAlgoInfo(IN char *szText, OUT IPSEC_QM_ALGO & algoInfo)
{
   DWORD dwReturn = T2P_OK;
   char  szTmp[POTF_MAX_STRLEN];
   char  *pOpen = NULL,
   *pClose = NULL,
   *pString = NULL;

   // these are used for processing AND to default to NONE
   bool  bEncryption    = false, bAuthentication= false;

   if (szText == NULL)
      return T2P_NULL_STRING;

   // muck with the string so we can copy it ;)
   strcpy(szTmp, szText);

   algoInfo.uAlgoKeyLen = algoInfo.uAlgoRounds = 0;

   pOpen = strchr(szTmp, POTF_NEGPOL_OPEN);
   pClose = strrchr(szTmp, POTF_NEGPOL_CLOSE);

   if ((pOpen != NULL) && (pClose != NULL) && (*(pClose + 1) == '\0')) // defense
   {
      *pOpen = '\0';
      *pClose = '\0';
      ++pOpen;

      if (_stricmp(szTmp, POTF_NEGPOL_AH) == 0)
      {
         if (_stricmp(pOpen, POTF_NEGPOL_MD5) == 0)
            algoInfo.uAlgoIdentifier = IPSEC_DOI_AH_MD5;
         else if (_stricmp(pOpen, POTF_NEGPOL_SHA) == 0 || _stricmp(pOpen, POTF_NEGPOL_SHA1) == 0)
            algoInfo.uAlgoIdentifier = IPSEC_DOI_AH_SHA1;
         else
         {
            dwReturn = T2P_INVALID_HASH_ALG;
         }

         algoInfo.Operation = AUTHENTICATION;
      }
      else if (_stricmp(szTmp, POTF_NEGPOL_ESP) == 0)
      {
         algoInfo.Operation = ENCRYPTION;

         pString = strchr(pOpen, POTF_ESPTRANS_TOKEN);

         if (pString != NULL)
         {
            *pString = '\0';
            ++pString;

            // we allow the hash and encryption to be specified in either
            // the first or second field-- hence the long conditionals
			if (_stricmp(pOpen, POTF_NEGPOL_DES) == 0)
            {
               bEncryption = true;
               algoInfo.uAlgoIdentifier = IPSEC_DOI_ESP_DES;
            }
            else if (_stricmp(pOpen, POTF_NEGPOL_3DES) == 0)
            {
               bEncryption = true;
               algoInfo.uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
            }
            else if (_stricmp(pOpen, POTF_NEGPOL_MD5) == 0)
            {
               bAuthentication = true;
               algoInfo.uSecAlgoIdentifier = HMAC_AH_MD5;
            }
            else if (_stricmp(pOpen, POTF_NEGPOL_SHA) == 0 || _stricmp(pOpen, POTF_NEGPOL_SHA1) == 0)
            {
               bAuthentication = true;
               algoInfo.uSecAlgoIdentifier = HMAC_AH_SHA1;
            }
            else if (_stricmp(pOpen, POTF_NEGPOL_NONE) != 0) // parse error
            {
               dwReturn = T2P_GENERAL_PARSE_ERROR;
            }

            // now the second one

			if (_stricmp(pString, POTF_NEGPOL_DES) == 0 && !bEncryption)
            {
               bEncryption = true;
               algoInfo.uAlgoIdentifier = IPSEC_DOI_ESP_DES;
            }
            else if (_stricmp(pString, POTF_NEGPOL_3DES) == 0 && !bEncryption)
            {
               bEncryption = true;
               algoInfo.uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
            }
            else if (_stricmp(pString, POTF_NEGPOL_MD5) == 0 && !bAuthentication)
            {
               bAuthentication = true;
               algoInfo.uSecAlgoIdentifier = HMAC_AH_MD5;
            }
            else if ((_stricmp(pString, POTF_NEGPOL_SHA) == 0 || _stricmp(pString, POTF_NEGPOL_SHA1) == 0) && !bAuthentication)
            {
               bAuthentication = true;
               algoInfo.uSecAlgoIdentifier = HMAC_AH_SHA1;
            }
            else if (_stricmp(pString, POTF_NEGPOL_NONE) != 0) // parse error
            {
               dwReturn = T2P_DUP_ALGS;
            }

            // now, fill in the NONE policies or detect NONE, NONE
            if (!bAuthentication && !bEncryption)
            {
               dwReturn = T2P_NONE_NONE;
            }
            else if (!bAuthentication)
            {
               algoInfo.uSecAlgoIdentifier = HMAC_AH_NONE;
            }
            else if (!bEncryption)
            {
               algoInfo.uAlgoIdentifier = IPSEC_DOI_ESP_NONE;
            }
         }
         else // error
         {
            dwReturn = T2P_INCOMPLETE_ESPALGS;
         }
      }
      else
      {
         dwReturn = T2P_INVALID_IPSECPROT;
      }
   }
   else  // error
   {
      dwReturn = T2P_GENERAL_PARSE_ERROR;
   }

   return dwReturn;
}

DWORD TextToOakleyAuth(IN char *szText, OUT IPSEC_MM_AUTH_INFO & AuthInfo)
{
   DWORD  dwReturn = T2P_OK;
   char  *pString = NULL,
   *pTmp    = NULL;
   char  *szTmp = NULL;
   char  *Info = NULL;

   if (szText != NULL)
   {
      // copy szText so we can muck with it
	  szTmp = new char[strlen(szText)+1];
	  assert(szTmp != 0);
      strcpy(szTmp, szText);

      // parse string
      if ( (pString = strchr(szTmp, POTF_OAKAUTH_TOKEN)) != NULL )
         *pString = '\0';

      // not UNICODE compliant
      if (tolower(szTmp[0]) == tolower(POTF_OAKAUTH_PRESHARE[0]))
      {
         if ((pString != NULL) && (strlen(pString + 1) > 0) )
         {
            ++pString;  // now pointing at string

            AuthInfo.AuthMethod = IKE_PRESHARED_KEY;

            if (*pString == '"') // fix up if the user included quotes
            {
               ++pString;
               pTmp = strrchr(pString, '"');
               if (pTmp != NULL)
               {
                  *pTmp = '\0';
               }
            }

            // convert to wide and fill in
            Info = new char[strlen(pString) + 1];
            assert(Info != NULL);
            strcpy(Info, pString);
         }
         else  // no key provided
         {
            dwReturn = T2P_NO_PRESHARED_KEY;
         }
      }
      else if (tolower(szTmp[0]) == tolower(POTF_OAKAUTH_KERBEROS[0]))
      {
         AuthInfo.AuthMethod = IKE_SSPI;
      }
      else if (tolower(szTmp[0]) == tolower(POTF_OAKAUTH_CERT[0]))
      {
         AuthInfo.AuthMethod = IKE_RSA_SIGNATURE;

         if ((pString != NULL) && (strlen(pString + 1) > 0) )
         {
            // CA is indicated

            ++pString;  // now pointing at string

            Info = new char[strlen(pString) + 1];
            assert(Info != NULL);

            if (*pString == '"') // fix up if the user included quotes
            {
               ++pString;
               pTmp = strrchr(pString, '"');
               if (pTmp != NULL)
               {
                  *pTmp = '\0';
               }
            }

            strcpy(Info, pString);
         }

         // else the CA will be negotiated

      }
      else  // invalid option
      {
         dwReturn = T2P_INVALID_AUTH_METHOD;
      }

      // now convert the ascii to wide char
      // authinfo needs to be wide
      if (Info != NULL && T2P_SUCCESS(dwReturn))
      {
         AuthInfo.pAuthInfo = NULL;
         AuthInfo.dwAuthInfoSize = 0;

         AuthInfo.dwAuthInfoSize = MultiByteToWideChar(CP_THREAD_ACP, 0, Info, -1,
                                            (WCHAR *) AuthInfo.pAuthInfo, 0);
         if (AuthInfo.dwAuthInfoSize == 0) // failure
         {
            dwReturn = T2P_MB2WC_FAILED;
         }
         else
         {

            AuthInfo.pAuthInfo = (LPBYTE) new WCHAR[AuthInfo.dwAuthInfoSize];
            assert(AuthInfo.pAuthInfo != NULL);
            AuthInfo.dwAuthInfoSize = MultiByteToWideChar(CP_THREAD_ACP, 0, Info, -1,
                                            (WCHAR *) AuthInfo.pAuthInfo, AuthInfo.dwAuthInfoSize);
	    AuthInfo.dwAuthInfoSize--;
	    AuthInfo.dwAuthInfoSize *= sizeof(WCHAR);
         }

         if (AuthInfo.dwAuthInfoSize == 0) // failure
         {
            delete [] AuthInfo.pAuthInfo;
            dwReturn = T2P_MB2WC_FAILED;
         }

		 // now do additional conversion if this is cert
		 if (T2P_SUCCESS(dwReturn) && AuthInfo.AuthMethod == IKE_RSA_SIGNATURE)
		 {
			 LPBYTE asnCert;
			 dwReturn = CM_EncodeName((LPWSTR) AuthInfo.pAuthInfo, &asnCert, &AuthInfo.dwAuthInfoSize);
			 delete [] AuthInfo.pAuthInfo;
			 if (dwReturn != ERROR_SUCCESS)
			 {
				 dwReturn = T2P_INVALID_AUTH_METHOD;
			 }
			 else
			 {
				 AuthInfo.pAuthInfo = asnCert;
				 dwReturn = T2P_OK;
			 }
		 }
      }
   }
   else
      dwReturn = T2P_NULL_STRING;

   if (Info) delete Info;
   if (szTmp) delete szTmp;

   return dwReturn;
}

DWORD TextToSecMethod(IN char *szText, IN OUT IPSEC_MM_OFFER & SecMethod)
{
   DWORD  dwReturn = T2P_OK;
   char  szTmp[POTF_MAX_STRLEN];
   char  *pString1 = NULL,
   *pString2 = NULL;
   bool  bEncryption = false,
   bAuthentication = false;

   if (szText == NULL)
      return T2P_NULL_STRING;

   // copy szText so we can muck it up
   strcpy(szTmp, szText);
   pString1 = strchr(szTmp, POTF_P1_TOKEN);
   pString2 = strrchr(szTmp, POTF_P1_TOKEN);

   if ((pString1 != NULL) && (pString2 != NULL) && (pString1 != pString2))
   {
      // string parsed ok so far
      *pString1 = '\0';
      *pString2 = '\0';
      ++pString1;
      ++pString2;

      // we allow the hash and encryption to be specified in either
      // the first or second field-- hence the long conditionals
	  if (_stricmp(szTmp, POTF_P1_DES) == 0)
      {
         bEncryption = true;
         SecMethod.EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_DES;
		 SecMethod.EncryptionAlgorithm.uAlgoKeyLen = SecMethod.EncryptionAlgorithm.uAlgoRounds = 0;
      }
      else if (_stricmp(szTmp, POTF_P1_3DES) == 0)
      {
         bEncryption = true;
         SecMethod.EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
		 SecMethod.EncryptionAlgorithm.uAlgoKeyLen = SecMethod.EncryptionAlgorithm.uAlgoRounds = 0;
      }
      else if (_stricmp(szTmp, POTF_P1_MD5) == 0)
      {
         bAuthentication = true;
         SecMethod.HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_MD5;
		 SecMethod.HashingAlgorithm.uAlgoKeyLen = SecMethod.HashingAlgorithm.uAlgoRounds = 0;
      }
      else if (_stricmp(szTmp, POTF_P1_SHA) == 0)
      {
         bAuthentication = true;
         SecMethod.HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_SHA1;
		 SecMethod.HashingAlgorithm.uAlgoKeyLen = SecMethod.HashingAlgorithm.uAlgoRounds = 0;
      }
      else // parse error
      {
         dwReturn = T2P_GENERAL_PARSE_ERROR;
      }

      if (_stricmp(pString1, POTF_P1_DES) == 0 && !bEncryption)
      {
         bEncryption = true;
         SecMethod.EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_DES;
		 SecMethod.EncryptionAlgorithm.uAlgoKeyLen = SecMethod.EncryptionAlgorithm.uAlgoRounds = 0;
      }
      else if (_stricmp(pString1, POTF_P1_3DES) == 0 && !bEncryption)
      {
         bEncryption = true;
         SecMethod.EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
		 SecMethod.EncryptionAlgorithm.uAlgoKeyLen = SecMethod.EncryptionAlgorithm.uAlgoRounds = 0;
      }
      else if (_stricmp(pString1, POTF_P1_MD5) == 0 && !bAuthentication)
      {
         bAuthentication = true;
         SecMethod.HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_MD5;
		 SecMethod.HashingAlgorithm.uAlgoKeyLen = SecMethod.HashingAlgorithm.uAlgoRounds = 0;
      }
      else if (_stricmp(pString1, POTF_P1_SHA) == 0 && !bAuthentication)
      {
         bAuthentication = true;
         SecMethod.HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_SHA1;
		 SecMethod.HashingAlgorithm.uAlgoKeyLen = SecMethod.HashingAlgorithm.uAlgoRounds = 0;
      }
      else // parse error
      {
         dwReturn = T2P_DUP_ALGS;
      }

      // now for the group
      if (isdigit(pString2[0]))
      {
         switch (pString2[0])
         {
         case '1':
            SecMethod.dwDHGroup = POTF_OAKLEY_GROUP1;
            break;
         case '2':
            SecMethod.dwDHGroup = POTF_OAKLEY_GROUP2;
            break;
         default:
            dwReturn = T2P_INVALID_P1GROUP;
            break;
         }
      }
      else
      {
         dwReturn = T2P_P1GROUP_MISSING;
      }

   }
   else // parse error
   {
      dwReturn = T2P_GENERAL_PARSE_ERROR;
   }

   return dwReturn;
}

DWORD TextToP1Rekey(IN char *szText, IN OUT KEY_LIFETIME & LifeTime, OUT DWORD & QMLim)
{
   DWORD  dwReturn = T2P_OK;
   char  szTmp[POTF_MAX_STRLEN];
   char  *pString = NULL;

   if (!szText)
      return T2P_NULL_STRING;

   // copy szText so we can muck it up
   strcpy(szTmp, szText);

   // two params specified?
   pString = strchr(szTmp, POTF_QM_TOKEN);
   if (pString != NULL)
   {
      *pString = '\0';
      ++pString;

      switch (pString[strlen(pString) - 1])
      {
      case 'q':
      case 'Q':
         pString[strlen(pString) - 1] = '\0';
         QMLim = atol(pString);
         break;
      case 's':
      case 'S':
         pString[strlen(pString) - 1] = '\0';
         LifeTime.uKeyExpirationTime = atol(pString);
         break;
      default:
         dwReturn = T2P_INVALID_P1REKEY_UNIT;
         break;
      }
   }

   switch (szTmp[strlen(szTmp) - 1])
   {
   case 'q':
   case 'Q':
      szTmp[strlen(szTmp) - 1] = '\0';
      QMLim = atol(szTmp);
      break;
   case 's':
   case 'S':
      szTmp[strlen(szTmp) - 1] = '\0';
      LifeTime.uKeyExpirationTime = atol(szTmp);
      break;
   default:
      dwReturn = T2P_INVALID_P1REKEY_UNIT;
      break;
   }

   return dwReturn;
}

// caveat, won't go deep into DNS
DWORD TextToIPAddr(IN char *szText, IN OUT IPAddr & Address)
{
   DWORD  dwReturn = T2P_OK;
   struct hostent *pHostEnt;

   if (szText != NULL)
   {

      if (!strcmp(szText, POTF_ME_TUNNEL))
      {
         Address = 0;
      }
      else if (isdnsname(szText))   // DNS name
      {
         pHostEnt = gethostbyname(szText);
         if (pHostEnt != NULL)
         {
            Address = *(IPAddr *)pHostEnt->h_addr;
            // should check for more here, but not now
         }
         else
         {
            dwReturn = T2P_DNSLOOKUP_FAILED;
         }
      }
      else  // good old dotted notation
      {
         Address = inet_addr(szText);
         if (Address == INADDR_NONE)
         {
            dwReturn = T2P_INVALID_ADDR;
         }
      }
   }
   else
   {
      dwReturn = T2P_NULL_STRING;
   }


   return dwReturn;
}

// if szSrc and/or szDst are passed in,
// caller must provide adequate space

DWORD TextToMMFilter(IN char *szText, IN OUT MM_FILTER &Filter, char *szSrc, char *szDst)
{
   DWORD  dwReturn = T2P_OK;   // return code of this function
   char  *pToken = NULL, *pTmp = NULL;
   char  szTmp[POTF_MAX_STRLEN];
   char  *pPortTok = NULL,
         *pProtTok = NULL;
   BOOL  bMirror = false;
   T2P_FILTER t2pFilter; // for TextToFilterAddr calls

   if (szText != NULL)  // do not assume that caller is smart
   {
      // We copy szText to szTmp so we can muck with it
      // in the process, we
      // determine passthru or drop filter

	  // but first we set this filter to negotiate security and to be not mirrored
	  // we also set protocol field
		Filter.bCreateMirror         = FALSE;

	  // set up T2P_FILTER
	  t2pFilter.QMFilterType = QM_TRANSPORT_FILTER;
	  memset(&t2pFilter.TransportFilter, 0, sizeof(TRANSPORT_FILTER));

      pToken = strchr(szText, POTF_PASSTHRU_OPEN_TOKEN);
      if (pToken != NULL)
      {
         dwReturn = T2P_GENERAL_PARSE_ERROR;
      }
      else if ( (pToken = strchr(szText, POTF_DROP_OPEN_TOKEN)) != NULL )
      {
         dwReturn = T2P_GENERAL_PARSE_ERROR;
      }
      else
         strcpy(szTmp, szText);

      // parse into source and dest strings
      for (pToken = szText; *pToken != POTF_FILTER_TOKEN &&
          *pToken != POTF_FILTER_MIRTOKEN &&
          *pToken != '\0'; ++pToken)
         ;
      if (*pToken == '\0')
      {
         dwReturn = T2P_NOSRCDEST_TOKEN;
      }
      else if ( *(pToken + 1) == '\0' )
      {
         dwReturn = T2P_NO_DESTADDR;
      }
      else if (T2P_SUCCESS(dwReturn))
      {
         if (*pToken == POTF_FILTER_MIRTOKEN)
		 {
			 bMirror = TRUE;
			 // set Mirrored = true
			 Filter.bCreateMirror = TRUE;
		 }

         if (!bMirror)
            pToken = strchr(szTmp,  POTF_FILTER_TOKEN);
         else
            pToken = strchr(szTmp,  POTF_FILTER_MIRTOKEN);

         *pToken = '\0';

		 // check for port presence
         pPortTok = strchr(szTmp, POTF_PT_TOKEN);
		 if (pPortTok != NULL)
		 {
			 dwReturn = T2P_GENERAL_PARSE_ERROR;
		 }
		 else
		 {
			 // do the src address
			 dwReturn = TextToFiltAddr(szTmp, t2pFilter, szSrc);
			 // copy src address
			 Filter.SrcAddr = t2pFilter.TransportFilter.SrcAddr;
		 }
         if (T2P_SUCCESS(dwReturn))
         {
            // do the dest address
            pPortTok = strchr(pToken + 1, POTF_PT_TOKEN);

            if (pPortTok == NULL)  // no port/prot specified
			{
               dwReturn = TextToFiltAddr(pToken + 1, t2pFilter, szDst, true);
			   // copy dest address
			   Filter.DesAddr = t2pFilter.TransportFilter.DesAddr;
			}
            else
            {
			   // error
			   dwReturn = T2P_GENERAL_PARSE_ERROR;
            }
         }

         // we're done, do any fixing up of Filter
         if (T2P_SUCCESS(dwReturn))
         {
			// set the GUID
			RPC_STATUS RpcStat = UuidCreate(&Filter.gFilterID);
			if (RpcStat != RPC_S_OK && RpcStat != RPC_S_UUID_LOCAL_ONLY)
			{
			   dwReturn = RpcStat;
			}

			// set the name to be equal to the "text2pol " + GUID
			if (T2P_SUCCESS(dwReturn))
			{
				WCHAR StringTxt[POTF_MAX_STRLEN];
				int iReturn;

				wcscpy(StringTxt, L"text2pol ");
				iReturn = StringFromGUID2(Filter.gFilterID, StringTxt+wcslen(StringTxt), POTF_MAX_STRLEN-wcslen(StringTxt));
				assert(iReturn != 0);
				Filter.pszFilterName = new WCHAR[wcslen(StringTxt)+1];
				assert(Filter.pszFilterName != NULL);
				wcscpy(Filter.pszFilterName, StringTxt);
			}
         }
      }
   }
   else  // szText is NULL
      dwReturn = T2P_NULL_STRING;

   return dwReturn;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipsecshr\template.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    template.c

Abstract:

    Contains common template matching code

Author:

    BrianSw  10-19-200

Environment:

    User Level: Win32/kernel
    NOTE:  Since this is used by user and kernel mode, code accordingly

Revision History:


--*/

#include "precomp.h"



BOOL
WINAPI IsAllZero(BYTE *c, DWORD dwSize)
{

    DWORD i;
    for (i=0;i<dwSize;i++) {
        if (c[i] != 0) {
            return FALSE;
        }
    }
    return TRUE;

}

BOOL 
WINAPI CmpBlob(IPSEC_BYTE_BLOB* c1, IPSEC_BYTE_BLOB *c2)
{

    if (c1->dwSize == 0) {
        return TRUE;
    }
    if (c1->dwSize != c2->dwSize) {
        return FALSE;
    }
    if (memcmp(c1->pBlob,c2->pBlob,c1->dwSize) == 0) {
        return TRUE;
    }
    return FALSE;
}

BOOL 
WINAPI CmpData(BYTE* c1, BYTE *c2, DWORD size) 
{

    if ((!IsAllZero(c1,size)) && 
        (memcmp(c1,c2,size) != 0)) {
        return FALSE;
    }
    
    return TRUE;
}


/*
  For comparing structs like:

  typedef struct _PROTOCOL {
  PROTOCOL_TYPE ProtocolType;
  DWORD dwProtocol;
  } PROTOCOL, * PPROTOCOL;
  
  dwTypeSize is sizeof PROTOCOL_TYPE, dwStructSize is sizeof(PROTOCOL)

  Assumes type info is first in struct

  Template symantics:

  Template is:
  All 0, everything matches
  Type 0, rest non-0, exact match of rest of data
  Type non-0, rest 0, all entries of given type
  Type non-0, rest non-0, exact match

 */
BOOL 
WINAPI CmpTypeStruct(BYTE *Template, BYTE *comp,
                   DWORD dwTypeSize, DWORD dwStructSize)
{
    
    if (IsAllZero(Template,dwStructSize)) {
        return TRUE;
    }
    
    if (IsAllZero(Template,dwTypeSize)) {
        if (memcmp(Template+dwTypeSize,comp+dwTypeSize,
                   dwStructSize-dwTypeSize) == 0) {
            return TRUE;
        }
        return FALSE;
    }
    
    // Know here that Template.TypeInfo is non-0
    if (memcmp(Template,comp,dwTypeSize) != 0) {
        return FALSE;
    }
    
    if (IsAllZero(Template+dwTypeSize,dwStructSize-dwTypeSize)) {
        return TRUE;
    }
    if (memcmp(Template+dwTypeSize,comp+dwTypeSize,dwStructSize-dwTypeSize) == 0) {
        return TRUE;
    }
    
    return FALSE;

}

BOOL
WINAPI CmpAddr(ADDR *Template, ADDR *a2)
{
    if (Template->AddrType == IP_ADDR_UNIQUE && Template->uIpAddr) {
        if (Template->uIpAddr != (a2->uIpAddr)) {
            return FALSE;
        }
        if (a2->AddrType != IP_ADDR_UNIQUE) {
            return FALSE;
        }
    }
    
    if (Template->AddrType == IP_ADDR_SUBNET && Template->uIpAddr) {
        if ((Template->uIpAddr & Template->uSubNetMask)
            != (a2->uIpAddr & Template->uSubNetMask)) {
            return FALSE;
        }
        // Make sure template subnet contains a2's subnet (if a2 is unique, any subnet is superset of unique filter
        if (a2->AddrType == IP_ADDR_SUBNET && 
            ((Template->uSubNetMask & a2->uSubNetMask) != Template->uSubNetMask)) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL 
WINAPI CmpFilter(IPSEC_QM_FILTER *Template, IPSEC_QM_FILTER* f2) 
{


    if (!CmpTypeStruct((BYTE*)&Template->Protocol,
                           (BYTE*)&f2->Protocol,
                           sizeof(PROTOCOL_TYPE),
                           sizeof(PROTOCOL))) {
        return FALSE;
    }

    if (!CmpTypeStruct((BYTE*)&Template->SrcPort,
                       (BYTE*)&f2->SrcPort,
                       sizeof(PORT_TYPE),
                       sizeof(PORT))) {
        return FALSE;
    }

    if (!CmpTypeStruct((BYTE*)&Template->DesPort,
                       (BYTE*)&f2->DesPort,
                       sizeof(PORT_TYPE),
                       sizeof(PORT))) {
        return FALSE;
    }
    
    if (Template->QMFilterType) {
        if (Template->QMFilterType != f2->QMFilterType) {
            return FALSE;
        }
    }


    if (!CmpData((BYTE*)&Template->MyTunnelEndpt,
                 (BYTE*)&f2->MyTunnelEndpt,
                 sizeof(ADDR))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->PeerTunnelEndpt,
                 (BYTE*)&f2->PeerTunnelEndpt,
                 sizeof(ADDR))) {
        return FALSE;
    }

    if (!CmpAddr(&Template->SrcAddr,&f2->SrcAddr)) {
        return FALSE;
    }
    if (!CmpAddr(&Template->DesAddr,&f2->DesAddr)) {
        return FALSE;
    }

    return TRUE;

}

BOOL 
WINAPI CmpQMAlgo(PIPSEC_QM_ALGO Template, PIPSEC_QM_ALGO a2)
{
    
    if (!CmpData((BYTE*)&Template->Operation,
                 (BYTE*)&a2->Operation,
                 sizeof(IPSEC_OPERATION))) {
        return FALSE;
    }
    
    if (!CmpData((BYTE*)&Template->uAlgoIdentifier,
                 (BYTE*)&a2->uAlgoIdentifier,
                 sizeof(ULONG))) {
        return FALSE;
    }
    
    if (!CmpData((BYTE*)&Template->uSecAlgoIdentifier,
                 (BYTE*)&a2->uSecAlgoIdentifier,
                 sizeof(HMAC_AH_ALGO))) {
        return FALSE;
    }
    
    if (!CmpData((BYTE*)&Template->MySpi,
                 (BYTE*)&a2->MySpi,
                 sizeof(IPSEC_QM_SPI))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->PeerSpi,
                 (BYTE*)&a2->PeerSpi,
                 sizeof(IPSEC_QM_SPI))) {
        return FALSE;
    }
    
    return TRUE;

}

BOOL 
WINAPI CmpQMOffer(PIPSEC_QM_OFFER Template, PIPSEC_QM_OFFER o2)
{

    DWORD i;

    if (!CmpData((BYTE*)&Template->Lifetime,
                 (BYTE*)&o2->Lifetime,
                 sizeof(KEY_LIFETIME))) {
        return FALSE;
    }

    if (Template->bPFSRequired) {
        if (Template->bPFSRequired != o2->bPFSRequired) {
            return FALSE;
        }
    }
    if (Template->dwPFSGroup) {
        if (Template->dwPFSGroup != o2->dwPFSGroup) {
            return FALSE;
        }
    }
    if (Template->dwNumAlgos) {
        if (Template->dwNumAlgos != o2->dwNumAlgos) {
            return FALSE;
        }
        for (i=0; i < Template->dwNumAlgos; i++) {
            if (!CmpQMAlgo(&Template->Algos[i],
                           &o2->Algos[i])) {
                return FALSE;
            }
        }
    }   

    return TRUE;

}

/*
  True if this NotifyListEntry Template matches the CurInfo

 */
BOOL 
WINAPI MatchQMSATemplate(IPSEC_QM_SA *Template,IPSEC_QM_SA *CurInfo)
{

    if (Template == NULL) {
        return TRUE;
    }

    if (!CmpFilter(&Template->IpsecQMFilter,
                   &CurInfo->IpsecQMFilter)) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->MMSpi.Initiator,
                 (BYTE*)&CurInfo->MMSpi.Initiator,sizeof(IKE_COOKIE))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->MMSpi.Responder,
                 (BYTE*)&CurInfo->MMSpi.Responder,sizeof(IKE_COOKIE))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&Template->gQMPolicyID,
                 (BYTE*)&CurInfo->gQMPolicyID,sizeof(GUID))) {
        return FALSE;
    }
    
    if (!CmpQMOffer(&Template->SelectedQMOffer,
                    &CurInfo->SelectedQMOffer)) {
        return FALSE;
    }

    return TRUE;

}

BOOL 
WINAPI MatchMMSATemplate(IPSEC_MM_SA *MMTemplate, IPSEC_MM_SA *SaData)
{
    
    if (MMTemplate == NULL) {
        return TRUE;
    }
    if (!CmpData((BYTE*)&MMTemplate->gMMPolicyID,
                 (BYTE*)&SaData->gMMPolicyID,sizeof(GUID))) {
        return FALSE;
    }
    if (!CmpData((BYTE*)&MMTemplate->MMSpi.Initiator,
                 (BYTE*)&SaData->MMSpi.Initiator,sizeof(COOKIE))) {
        return FALSE;
    }
    if (!CmpData((BYTE*)&MMTemplate->MMSpi.Responder,
                 (BYTE*)&SaData->MMSpi.Responder,sizeof(COOKIE))) {
        return FALSE;
    }
    if (!CmpAddr(&MMTemplate->Me,&SaData->Me)) {
        return FALSE;
    }
    if (!CmpAddr(&MMTemplate->Peer,&SaData->Peer)) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.EncryptionAlgorithm,(BYTE*)&SaData->SelectedMMOffer.EncryptionAlgorithm,sizeof(IPSEC_MM_ALGO))) {
        return FALSE;
    }
    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.HashingAlgorithm,(BYTE*)&SaData->SelectedMMOffer.HashingAlgorithm,sizeof(IPSEC_MM_ALGO))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.dwDHGroup,(BYTE*)&SaData->SelectedMMOffer.dwDHGroup,sizeof(DWORD))) {
        return FALSE;
    }
    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.Lifetime,(BYTE*)&SaData->SelectedMMOffer.Lifetime,sizeof(KEY_LIFETIME))) {
        return FALSE;
    }

    if (!CmpData((BYTE*)&MMTemplate->SelectedMMOffer.dwQuickModeLimit,(BYTE*)&SaData->SelectedMMOffer.dwQuickModeLimit,sizeof(DWORD))) {
        return FALSE;
    }

    if (!CmpBlob(&MMTemplate->MyId,&SaData->MyId)) {
        return FALSE;
    }
    if (!CmpBlob(&MMTemplate->PeerId,&SaData->PeerId)) {
        return FALSE;
    }
    if (!CmpBlob(&MMTemplate->MyCertificateChain,&SaData->MyCertificateChain)) {
        return FALSE;
    }
    if (!CmpBlob(&MMTemplate->PeerCertificateChain,&SaData->PeerCertificateChain)) {
        return FALSE;
    }
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\usepa.h ===
/////////////////////////////////////////////////////////////
// Copyright(c) 1998-2000, Microsoft Corporation
//
// usepa.h
//
// Created on 8/15/98 by Randyram
// Revisions:
//   2/29/00 - DKalin
//             Removed out-of-date PA routines
//             Added new ipsecpol service management routines
//
// Includes util routines enables you to call PA and ipsecpolsvc RPC API
//
/////////////////////////////////////////////////////////////

#ifndef _USEPARPC_H_
#define _USEPARPC_H_

#include <tchar.h>
#include <windows.h>


// const defs
const _TUCHAR    szLOCALENDPT[] = TEXT("policyagent");
const TCHAR      szLOCAL_MACHINE[] = TEXT("\\\\.");
const UINT       USEPARPC_LOCLEN = sizeof(szLOCAL_MACHINE) / sizeof(TCHAR);


////////////////////////////////////////////////////////////////
//  Function:  PAIsRunning
//  Purpose:   checks to see if Policy Agent service is up
//
//  Pre-conditions:  none
//
//  Parameters:
//    dwReturn OUT    holds errors returned from SCM if any
//    szServ   IN OPT if not NULL, name of remote machine
//  Returns:
//    true on success (dwReturn is set to ERROR_SUCCESS)
//    false && dwReturn == ERROR_SUCCESS means PA service is not running
//    false && dwReturn != ERROR_SUCCESS an SCM operation failed,
//       dwReturn holds GetLastError from SCM call

bool   PAIsRunning(OUT DWORD &dwReturn, OPTIONAL TCHAR *szServ = NULL);

////////////////////////////////////////////////////////////////
//  Function:  StartPA
//  Purpose:   starts policy agent service
//
//  Pre-conditions:  none
//
//  Parameters:
//    dwReturn OUT    holds errors returned from SCM if any
//    szServ   IN OPT if not NULL, name of remote machine
//  Returns:
//    true on success (dwReturn is set to ERROR_SUCCESS)
//    false && dwReturn != ERROR_SUCCESS an SCM operation failed,
//       dwReturn holds GetLastError from SCM call

bool   StartPA(OUT DWORD &dwReturn, OPTIONAL TCHAR *szServ = NULL);

/*********************************************************************
	FUNCTION: InstallIpsecpolService
        PURPOSE:  Installs ipsecpolsvc service (incl. copying .exe to system32 dir)
        PARAMS:
          pszFilename   - name of the .exe file (full path recommended)
		  bFailIfExists - if TRUE,  fail if service already exists,
		                  if FALSE, stop service, delete it and proceed
						  ( default = TRUE )
        RETURNS: ERROR_SUCESS or GetLastError code
        COMMENTS:
*********************************************************************/
DWORD  InstallIpsecpolService (IN LPCTSTR pszFilename, IN OPTIONAL BOOL bFailIfExists = TRUE );

/*********************************************************************
	FUNCTION: StartIpsecpolService
        PURPOSE:  Attempts to start ipsecpolsvc service
        PARAMS:
          pszServ - optional name of the server (default is NULL, start on local machine)
        RETURNS: ERROR_SUCESS or GetLastError code
        COMMENTS:
*********************************************************************/
DWORD  StartIpsecpolService (IN OPTIONAL LPCTSTR pszServ = NULL);

/*********************************************************************
	FUNCTION: StopIpsecpolService
        PURPOSE:  Attempts to stop ipsecpolsvc service
        PARAMS:
          pszServ - optional name of the server (default is NULL, start on local machine)
        RETURNS: ERROR_SUCESS or GetLastError code
        COMMENTS:
*********************************************************************/
DWORD  StopIpsecpolService (IN OPTIONAL LPCTSTR pszServ = NULL);

/*********************************************************************
	FUNCTION: IsIpsecpolServiceRunning
        PURPOSE:  Checks if ipsecpolsvc service is currently running
        PARAMS:
		  dwReturn - holds errors retuned by SCM if any
          pszServ  - optional name of the server (default is NULL, start on local machine)
        RETURNS:  TRUE/FALSE
        COMMENTS: TRUE returned means service is running
		          FALSE and dwReturn == ERROR_SUCCESS means service is not running
				  FALSE and dwReturn != ERROR_SUCCESS means SCM operation failed (dwReturn is error code)
*********************************************************************/
BOOL  IsIpsecpolServiceRunning (OUT DWORD &dwReturn, OPTIONAL LPCTSTR pszServ = NULL);

/*********************************************************************
	FUNCTION: InitIpsecpolsvcRPC
        PURPOSE:  Get an RPC handle from ipsecpolsvc that can be used to call its APIs
        PARAMS:
          pszServ      - name of the server (pass NULL for the local machine)
		  hIpsecpolsvc - returned handle
        RETURNS:  RPC_S_OK or RPC api error code
        COMMENTS: Service running is not prereq
*********************************************************************/
RPC_STATUS  InitIpsecpolsvcRPC (IN TCHAR* pszServ, OUT handle_t &hIpsecpolsvc);

/*********************************************************************
	FUNCTION: ShutdownIpsecpolsvcRPC
        PURPOSE:  Close RPC handle
        PARAMS:
		  hIpsecpolsvc - handle
        RETURNS:  RPC_S_OK or RPC api error code
        COMMENTS:
*********************************************************************/
RPC_STATUS  ShutdownIpsecpolsvcRPC (IN handle_t hIpsecpolsvc);

/*********************************************************************
	FUNCTION: PlumbIPSecPolicy
        PURPOSE:  Plumbs IPSEC_IKE_POLICY to the specified machine
        PARAMS:
		  pszServerName     - machine name or NULL for local
                  pIPSecIkePol      - pointer to IPSEC_IKE_POLICY.
                     GUIDs/names must be generated prior to the call
                  bFailMMIfExists   - specifies MM filter behavior
                     bFailMMIfExists == FALSE will cause the call not to break
                       on ERROR_MM_FILTER_EXISTS when duplicate MM filters are there
                     bFailMMIfExists == TRUE  will fail on any SPD API error
                  ppMMFilterHandles - array of mm filter handles will be returned here
                  ppFilterHandles   - array of qm filter handles will be returned here
				  bPersist          - if TRUE, information will be persisted
        RETURNS:  ERROR_SUCCESS or win32 error code
        COMMENTS: CALLER is responsible for freeing the memory for the handle arrays
*********************************************************************/
DWORD
PlumbIPSecPolicy(
    IN LPWSTR pServerName,
    IN PIPSEC_IKE_POLICY pIPSecIkePol,
    IN BOOL bFailMMIfExists,
    OUT PHANDLE *ppMMFilterHandles,
    OUT PHANDLE *ppFilterHandles,
	IN OPTIONAL BOOL bPersist = FALSE
    );

/*********************************************************************
	FUNCTION: DeleteIPSecPolicy
        PURPOSE:  Complementary to PlumbIPSecPolicy, removes IPSEC_IKE_POLICY
        PARAMS:
		  pszServerName    - machine name or NULL for local
                  pIPSecIkePol     - pointer to IPSEC_IKE_POLICY.
                     GUIDs/names must be generated prior to the call
                  pMMFilterHandles - array of main mode filter handles
                  pFilterHandles   - array of quick mode filter handles
        RETURNS:  ERROR_SUCCESS or win32 error code
        COMMENTS: Function will try to
                    remove everything specified in the IPSEC_IKE_POLICY structure.
                  It is possible that one or several errors will be encountered.
                  Function will continue, but later first error will be returned.
*********************************************************************/
DWORD
DeleteIPSecPolicy(
    IN LPWSTR pServerName,
    IN PIPSEC_IKE_POLICY pIPSecIkePol,
    IN PHANDLE pMMFilterHandles,
    IN PHANDLE pFilterHandles
    );

/*********************************************************************
	FUNCTION: DeletePersistedIPSecPolicy
        PURPOSE:  Complementary to PlumbIPSecPolicy with persistent flag on,
					removes persisted policy
        PARAMS:
		  pszServerName    - machine name or NULL for local
		          pPolicyName - policy name prefix, if empty string of NULL,
					all persisted policy settings will be removed
        RETURNS:  ERROR_SUCCESS or win32 error code
        COMMENTS: Function will try to
                    remove everything specified.
                  It is possible that one or several errors will be encountered.
                  Function will continue, but later first error will be returned.
*********************************************************************/
DWORD
DeletePersistedIPSecPolicy(
    IN LPWSTR pServerName,
	IN LPWSTR pPolicyName
	);


#endif   /* _USEPARPC_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\dsstore.h ===
DWORD
OpenDirectoryServerHandle(
    LPWSTR pszDomainName,
    DWORD dwPortNumber,
    HLDAP * phLdapBindHandle
    );


DWORD
CloseDirectoryServerHandle(
    HLDAP hLdapBindHandle
    );

DWORD
ReadPolicyObjectFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );


DWORD
ReadNFAObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecOwnerReference,
    LPWSTR * ppszNFADNs,
    DWORD dwNumNfaObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNfaObjects,
    LPWSTR ** pppszFilterReferences,
    PDWORD pdwNumFilterReferences,
    LPWSTR ** pppszNegPolReferences,
    PDWORD pdwNumNegPolReferences
    );

DWORD
GenerateNFAQuery(
    LPWSTR * ppszNFADNs,
    DWORD dwNumNFAObjects,
    LPWSTR * ppszQueryBuffer
    );


DWORD
AppendCommonNameToQuery(
    LPWSTR szQueryBuffer,
    LPWSTR szCommonName
    );

DWORD
ComputePrelimCN(
    LPWSTR szNFADN,
    LPWSTR szCommonName
    );

DWORD
UnMarshallPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject,
    LDAPMessage *res
    );


DWORD
UnMarshallNFAObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    );


DWORD
GenerateISAKMPQuery(
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    LPWSTR * ppszQueryBuffer
    );

DWORD
UnMarshallISAKMPObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    );

DWORD
ReadISAKMPObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    );

typedef struct _ldapobject
{
    union {
        WCHAR *strVals;
        struct berval *bVals;
    } val;
} LDAPOBJECT, *PLDAPOBJECT;

#define LDAPOBJECT_STRING(pldapobject)      ((pldapobject)->val.strVals)
#define LDAPOBJECT_BERVAL(pldapobject)      ((pldapobject)->val.bVals)
#define LDAPOBJECT_BERVAL_VAL(pldapobject)  ((pldapobject)->val.bVals->bv_val)
#define LDAPOBJECT_BERVAL_LEN(pldapobject)  ((pldapobject)->val.bVals->bv_len)

void
FreeIpsecNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

void
FreeIpsecPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
UnMarshallFilterObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );


void
FreeIpsecFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );


DWORD
UnMarshallNegPolObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_NEGPOL_OBJECT * ppIpsecPolicyObject
    );


void
FreeIpsecNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
ReadFilterObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    );

DWORD
GenerateFilterQuery(
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    LPWSTR * ppszQueryBuffer
    );

DWORD
ReadNegPolObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    );

DWORD
GenerateNegPolQuery(
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    LPWSTR * ppszQueryBuffer
    );

DWORD
ComputePolicyContainerDN(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyContainerDN
    );

DWORD
ComputeDefaultDirectory(
    LPWSTR * ppszDefaultDirectory
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\dsstore.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       dsstore.c
//
//  Contents:   Policy management for directory.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

LPWSTR gpszIpSecContainer = L"CN=IP Security,CN=System,DC=ntdev,DC=microsoft,DC=com";
LPWSTR PolicyDNAttributes[] = {
                                L"ipsecID",
                                L"description",
                                L"ipsecDataType",
                                L"ipsecISAKMPReference",
                                L"ipsecData",
                                L"ipsecNFAReference",
                                L"ipsecName",
                                L"distinguishedName",
                                L"whenChanged",
                                NULL
                                };

LPWSTR NFADNAttributes[] = {
                                L"distinguishedName",
                                L"description",
                                L"ipsecName",
                                L"ipsecID",
                                L"ipsecDataType",
                                L"ipsecData",
                                L"ipsecOwnersReference",
                                L"ipsecFilterReference",
                                L"ipsecNegotiationPolicyReference",
                                L"whenChanged",
                                NULL
                                };

LPWSTR FilterDNAttributes[] = {
                                L"distinguishedName",
                                L"description",
                                L"ipsecName",
                                L"ipsecID",
                                L"ipsecDataType",
                                L"ipsecData",
                                L"ipsecOwnersReference",
                                L"whenChanged",
                                NULL
                                };

LPWSTR NegPolDNAttributes[] = {
                                L"distinguishedName",
                                L"description",
                                L"ipsecName",
                                L"ipsecID",
                                L"ipsecDataType",
                                L"ipsecData",
                                L"ipsecNegotiationPolicyAction",
                                L"ipsecNegotiationPolicyType",
                                L"ipsecOwnersReference",
                                L"whenChanged",
                                NULL
                                };

LPWSTR ISAKMPDNAttributes[] = {
                                L"distinguishedName",
                                L"ipsecName",
                                L"ipsecID",
                                L"ipsecDataType",
                                L"ipsecData",
                                L"ipsecOwnersReference",
                                L"whenChanged",
                                NULL
                                };







DWORD
OpenDirectoryServerHandle(
    LPWSTR pszDomainName,
    DWORD dwPortNumber,
    HLDAP * phLdapBindHandle
    )
{
    DWORD dwError = 0;


    *phLdapBindHandle = NULL;

    dwError = LdapOpen(
                pszDomainName,
                dwPortNumber,
                phLdapBindHandle
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapBind(
                *phLdapBindHandle
                );
    BAIL_ON_WIN32_ERROR(dwError);

    return(dwError);

error:

    if (*phLdapBindHandle) {
        CloseDirectoryServerHandle(
            *phLdapBindHandle
            );
        *phLdapBindHandle = NULL;
    }

    return(dwError);
}

DWORD
CloseDirectoryServerHandle(
    HLDAP hLdapBindHandle
    )
{

    int ldaperr = 0;

    if (hLdapBindHandle) {

        ldaperr = ldap_unbind(hLdapBindHandle);

    }

    return(0);
}


DWORD
ReadPolicyObjectFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    LPWSTR szFilterString = L"(objectClass=*)";
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;

    DWORD dwNumNFAObjectsReturned = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    LPWSTR * ppszFilterReferences = NULL;
    DWORD dwNumFilterReferences = 0;
    LPWSTR * ppszNegPolReferences = NULL;
    DWORD dwNumNegPolReferences = 0;

    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    DWORD dwNumFilterObjects = 0;

    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    DWORD dwNumNegPolObjects = 0;

    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    DWORD dwNumISAKMPObjects = 0;

    LPWSTR pszPolicyContainer = NULL;

    dwError = ComputePolicyContainerDN(
                  pszPolicyDN,
                  &pszPolicyContainer
                  );

    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszPolicyDN,
                  LDAP_SCOPE_BASE,
                  szFilterString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallPolicyObject(
                    hLdapBindHandle,
                    pszPolicyDN,
                    &pIpsecPolicyObject,
                    res
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadNFAObjectsFromDirectory(
                        hLdapBindHandle,
                        pszPolicyContainer,
                        pIpsecPolicyObject->pszIpsecOwnersReference,
                        pIpsecPolicyObject->ppszIpsecNFAReferences,
                        pIpsecPolicyObject->NumberofRules,
                        &ppIpsecNFAObjects,
                        &dwNumNFAObjectsReturned,
                        &ppszFilterReferences,
                        &dwNumFilterReferences,
                        &ppszNegPolReferences,
                        &dwNumNegPolReferences
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadFilterObjectsFromDirectory(
                        hLdapBindHandle,
                        pszPolicyContainer,
                        ppszFilterReferences,
                        dwNumFilterReferences,
                        &ppIpsecFilterObjects,
                        &dwNumFilterObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadNegPolObjectsFromDirectory(
                        hLdapBindHandle,
                        pszPolicyContainer,
                        ppszNegPolReferences,
                        dwNumNegPolReferences,
                        &ppIpsecNegPolObjects,
                        &dwNumNegPolObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadISAKMPObjectsFromDirectory(
                        hLdapBindHandle,
                        pszPolicyContainer,
                        &pIpsecPolicyObject->pszIpsecISAKMPReference,
                        1,
                        &ppIpsecISAKMPObjects,
                        &dwNumISAKMPObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->ppIpsecNFAObjects = ppIpsecNFAObjects;
    pIpsecPolicyObject->NumberofRulesReturned = dwNumNFAObjectsReturned;
    pIpsecPolicyObject->NumberofFilters = dwNumFilterObjects;
    pIpsecPolicyObject->ppIpsecFilterObjects = ppIpsecFilterObjects;
    pIpsecPolicyObject->ppIpsecNegPolObjects = ppIpsecNegPolObjects;
    pIpsecPolicyObject->NumberofNegPols = dwNumNegPolObjects;
    pIpsecPolicyObject->NumberofISAKMPs = dwNumISAKMPObjects;
    pIpsecPolicyObject->ppIpsecISAKMPObjects = ppIpsecISAKMPObjects;


    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (res) {
        LdapMsgFree(res);
    }

    if (ppszFilterReferences) {

        FreeFilterReferences(
                ppszFilterReferences,
                dwNumFilterReferences
                );
    }

    if (ppszNegPolReferences) {

        FreeNegPolReferences(
                ppszNegPolReferences,
                dwNumNegPolReferences
                );
    }

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    *ppIpsecPolicyObject = NULL;

    goto cleanup;

}


DWORD
ReadNFAObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecOwnerReference,
    LPWSTR * ppszNFADNs,
    DWORD dwNumNfaObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNfaObjects,
    LPWSTR ** pppszFilterReferences,
    PDWORD pdwNumFilterReferences,
    LPWSTR ** pppszNegPolReferences,
    PDWORD pdwNumNegPolReferences
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszFilterString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    LPWSTR * ppszFilterReferences = NULL;
    LPWSTR * ppszNegPolReferences = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;
    DWORD dwNumFilterReferences = 0;
    DWORD dwNumNegPolReferences = 0;




    DWORD dwNumNFAObjectsReturned = 0;

    dwError = GenerateNFAQuery(
                    ppszNFADNs,
                    dwNumNfaObjects,
                    &pszFilterString
                    );


    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecNFAObjects  = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NFA_OBJECT)*dwCount
                                            );
    if (!ppIpsecNFAObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszFilterReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwCount
                                        );
    if (!ppszFilterReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    ppszNegPolReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwCount
                                        );
    if (!ppszNegPolReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );

        }

        dwError =UnMarshallNFAObject(
                    hLdapBindHandle,
                    e,
                    &pIpsecNFAObject,
                    &pszFilterReference,
                    &pszNegPolReference
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNFAObjects + dwNumNFAObjectsReturned) = pIpsecNFAObject;

            if (pszFilterReference) {

                *(ppszFilterReferences + dwNumFilterReferences) = pszFilterReference;
                dwNumFilterReferences++;

            }

            if (pszNegPolReference) {

                *(ppszNegPolReferences + dwNumNegPolReferences) = pszNegPolReference;
                dwNumNegPolReferences++;
            }

            dwNumNFAObjectsReturned++;

        }


    }

    if (dwNumNFAObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppszFilterReferences = ppszFilterReferences;
    *pppszNegPolReferences = ppszNegPolReferences;

    *pppIpsecNFAObjects = ppIpsecNFAObjects;
    *pdwNumNfaObjects = dwNumNFAObjectsReturned;
    *pdwNumNegPolReferences = dwNumNegPolReferences;
    *pdwNumFilterReferences = dwNumFilterReferences;

    dwError = ERROR_SUCCESS;

cleanup:


    if (res) {
        LdapMsgFree(res);
    }


    if (pszFilterString) {
        FreePolStr(pszFilterString);
    }

    return(dwError);


error:
    if (ppszNegPolReferences) {
        FreeNegPolReferences(
                ppszNegPolReferences,
                dwNumNFAObjectsReturned
                );
    }


    if (ppszFilterReferences) {
        FreeFilterReferences(
                ppszFilterReferences,
                dwNumNFAObjectsReturned
                );
    }

    if (ppIpsecNFAObjects) {

        FreeIpsecNFAObjects(
                ppIpsecNFAObjects,
                dwNumNFAObjectsReturned
                );

    }

    *pppszNegPolReferences = NULL;
    *pppszFilterReferences = NULL;
    *pdwNumNegPolReferences = 0;
    *pdwNumFilterReferences = 0;
    *pppIpsecNFAObjects = NULL;
    *pdwNumNfaObjects = 0;

    goto cleanup;
}

DWORD
ReadFilterObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszFilterString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;

    DWORD dwNumFilterObjectsReturned = 0;

    //
    // It is possible to have zero filter objects - if we have
    // a single rule with no filters in it, then we should return
    // success with zero filters.
    //

    if (!dwNumFilterObjects) {

        *pppIpsecFilterObjects = 0;
        *pdwNumFilterObjects = 0;

        return(ERROR_SUCCESS);
    }

    dwError = GenerateFilterQuery(
                    ppszFilterDNs,
                    dwNumFilterObjects,
                    &pszFilterString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  FilterDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecFilterObjects  = (PIPSEC_FILTER_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_FILTER_OBJECT)*dwCount
                                            );
    if (!ppIpsecFilterObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );

        }

        dwError =UnMarshallFilterObject(
                    hLdapBindHandle,
                    e,
                    &pIpsecFilterObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecFilterObjects + dwNumFilterObjectsReturned) = pIpsecFilterObject;
            dwNumFilterObjectsReturned++;

        }


    }

    *pppIpsecFilterObjects = ppIpsecFilterObjects;
    *pdwNumFilterObjects = dwNumFilterObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    if (res) {

        LdapMsgFree(res);
    }



    return(dwError);


error:

    if (ppIpsecFilterObjects) {

        FreeIpsecFilterObjects(
                    ppIpsecFilterObjects,
                    dwNumFilterObjectsReturned
                    );
    }

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;

    goto cleanup;
}

DWORD
ReadNegPolObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszNegPolString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumNegPolObjectsReturned = 0;

    dwError = GenerateNegPolQuery(
                    ppszNegPolDNs,
                    dwNumNegPolObjects,
                    &pszNegPolString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNegPolString,
                  NegPolDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecNegPolObjects  = (PIPSEC_NEGPOL_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NEGPOL_OBJECT)*dwCount
                                            );

    if (!ppIpsecNegPolObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );

        }

        dwError =UnMarshallNegPolObject(
                    hLdapBindHandle,
                    e,
                    &pIpsecNegPolObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNegPolObjects + dwNumNegPolObjectsReturned) = pIpsecNegPolObject;
            dwNumNegPolObjectsReturned++;

        }


    }
    if (dwNumNegPolObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppIpsecNegPolObjects = ppIpsecNegPolObjects;
    *pdwNumNegPolObjects = dwNumNegPolObjectsReturned;


    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    if (res) {
        LdapMsgFree(res);
    }


    return(dwError);


error:

    if (ppIpsecNegPolObjects) {

        FreeIpsecNegPolObjects(
                    ppIpsecNegPolObjects,
                    dwNumNegPolObjectsReturned
                    );
    }

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;

    goto cleanup;
}

DWORD
ReadISAKMPObjectsFromDirectory(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    )
{

    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszISAKMPString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;

    DWORD dwNumISAKMPObjectsReturned = 0;

    dwError = GenerateISAKMPQuery(
                    ppszISAKMPDNs,
                    dwNumISAKMPObjects,
                    &pszISAKMPString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszISAKMPString,
                  ISAKMPDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecISAKMPObjects  = (PIPSEC_ISAKMP_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_ISAKMP_OBJECT)*dwCount
                                            );
    if (!ppIpsecISAKMPObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );

        }

        dwError =UnMarshallISAKMPObject(
                    hLdapBindHandle,
                    e,
                    &pIpsecISAKMPObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecISAKMPObjects + dwNumISAKMPObjectsReturned) = pIpsecISAKMPObject;

            dwNumISAKMPObjectsReturned++;

        }


    }

    if (dwNumISAKMPObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppIpsecISAKMPObjects = ppIpsecISAKMPObjects;
    *pdwNumISAKMPObjects = dwNumISAKMPObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    if (res) {
        LdapMsgFree(res);
    }


    return(dwError);


error:

    if (ppIpsecISAKMPObjects) {

        FreeIpsecISAKMPObjects(
                    ppIpsecISAKMPObjects,
                    dwNumISAKMPObjectsReturned
                    );
    }

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;

    goto cleanup;
}



DWORD
UnMarshallPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject,
    LDAPMessage *res
    )
{
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    LDAPMessage *e = NULL;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR * ppszTemp = NULL;


    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    dwError = LdapFirstEntry(
                    hLdapBindHandle,
                    res,
                    &e
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    /*
    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                                        pszPolicyDN
                                                        );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecPolicyObject->pszDescription = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecISAKMPReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecISAKMPReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecISAKMPReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecPolicyObject->pIpsecData = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNFAReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwCount; i++) {

        ppszTemp = (strvalues + i);
        //
        // Unmarshall all the values you can possibly have
        //
        pszIpsecNFAName = AllocPolStr(*ppszTemp);
        if (!pszIpsecNFAName) {
            dwError = ERROR_OUTOFMEMORY;

            pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
            pIpsecPolicyObject->NumberofRules = i;

            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszIpsecNFAName;

    }


    pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
    pIpsecPolicyObject->NumberofRules = dwCount;
    LdapValueFree(strvalues);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    *ppIpsecPolicyObject = NULL;

    return(dwError);
}



DWORD
UnMarshallNFAObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    )
{
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR * ppszTemp = NULL;

    LPWSTR pszTempFilterReference = NULL;
    LPWSTR pszTempNegPolReference = NULL;

    pIpsecNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                sizeof(IPSEC_NFA_OBJECT)
                                );
    if (!pIpsecNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecNFAObject->pszDistinguishedName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecNFAObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    //
    // Client does not always write the Name for an NFA.
    //

    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecNFAObject->pszIpsecName = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecNFAObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecNFAObject->pszIpsecName = NULL;
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecNFAObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecNFAObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecNFAObject->pszDescription = NULL;
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecNFAObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecNFAObject->pIpsecData = pBuffer;
    pIpsecNFAObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecOwnersReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    //BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError && strvalues) {

        pIpsecNFAObject->pszIpsecOwnersReference = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecNFAObject->pszIpsecOwnersReference) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNegotiationPolicyReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->pszIpsecNegPolReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecNFAObject->pszIpsecNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecFilterReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues) {

        pIpsecNFAObject->pszIpsecFilterReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
        if (!pIpsecNFAObject->pszIpsecFilterReference) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }


        pszTempFilterReference = AllocPolStr(
                                pIpsecNFAObject->pszIpsecFilterReference
                                );
        if (!pszTempFilterReference) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        pIpsecNFAObject->pszIpsecFilterReference = NULL;
    }
    pszTempNegPolReference = AllocPolStr(
                                 pIpsecNFAObject->pszIpsecNegPolReference
                                 );
    if (!pszTempNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    *ppszFilterReference = pszTempFilterReference;
    *ppszNegPolReference = pszTempNegPolReference;

    *ppIpsecNFAObject = pIpsecNFAObject;


    return(0);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszTempFilterReference) {
        FreePolStr(pszTempFilterReference);
    }

    if (pszTempNegPolReference) {
        FreePolStr(pszTempNegPolReference);
    }

    *ppIpsecNFAObject = NULL;
    *ppszFilterReference = NULL;
    *ppszNegPolReference = NULL;

    return(dwError);
}


DWORD
UnMarshallFilterObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecFilterNames = NULL;
    LPWSTR pszIpsecFilterName = NULL;
    LPWSTR * ppszTemp = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;

    pIpsecFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                sizeof(IPSEC_FILTER_OBJECT)
                                );
    if (!pIpsecFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->pszDistinguishedName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecFilterObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError && strvalues) {

        pIpsecFilterObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecFilterObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError && strvalues) {

        pIpsecFilterObject->pszIpsecName = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecFilterObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
    }

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecFilterObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecFilterObject->pIpsecData = pBuffer;
    pIpsecFilterObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecOwnersReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    if (!dwError && strvalues) {

        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        for (i = 0; i < dwCount; i++) {

            ppszTemp = (strvalues + i);
            //
            // Unmarshall all the values you can possibly have
            //
            pszIpsecNFAName = AllocPolStr(*ppszTemp);
            if (!pszIpsecNFAName) {
                dwError = ERROR_OUTOFMEMORY;

                pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecFilterObject->dwNFACount = i;

                BAIL_ON_WIN32_ERROR(dwError);
            }
            *(ppszIpsecNFANames + i) = pszIpsecNFAName;

        }

        pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecFilterObject->dwNFACount = dwCount;
        LdapValueFree(strvalues);

    }

    *ppIpsecFilterObject = pIpsecFilterObject;

    return(0);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(pIpsecFilterObject);
    }

    *ppIpsecFilterObject = NULL;

    return(dwError);
}


DWORD
UnMarshallNegPolObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_NEGPOL_OBJECT * ppIpsecPolicyObject
    )
{

    PIPSEC_NEGPOL_OBJECT pIpsecPolicyObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR * ppszTemp = NULL;

    pIpsecPolicyObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                sizeof(IPSEC_NEGPOL_OBJECT)
                                );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszDistinguishedName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    //
    // Names do not get written on an NegPol Object.
    //

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecPolicyObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecPolicyObject->pszIpsecName = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecPolicyObject->pszDescription = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNegotiationPolicyAction",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecNegPolAction = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecNegPolAction) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNegotiationPolicyType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecNegPolType = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecNegPolType) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecOwnersReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );

    if (!dwError && strvalues) {

        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        for (i = 0; i < dwCount; i++) {

            ppszTemp = (strvalues + i);
            //
            // Unmarshall all the values you can possibly have
            //
            pszIpsecNFAName = AllocPolStr(*ppszTemp);
            if (!pszIpsecNFAName) {
                dwError = ERROR_OUTOFMEMORY;

                pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecPolicyObject->dwNFACount = i;


                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFANames + i) = pszIpsecNFAName;
        }

        pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecPolicyObject->dwNFACount =  dwCount;
        LdapValueFree(strvalues);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecPolicyObject->pIpsecData = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

    return(0);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecNegPolObject(pIpsecPolicyObject);
    }

    *ppIpsecPolicyObject = NULL;

    return(dwError);
}


DWORD
UnMarshallISAKMPObject(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{

    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecISAKMPNames = NULL;
    LPWSTR pszIpsecISAKMPName = NULL;
    LPWSTR * ppszTemp = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;

    pIpsecISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                sizeof(IPSEC_ISAKMP_OBJECT)
                                );
    if (!pIpsecISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecISAKMPObject->pszDistinguishedName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );

    if (!pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);
    //
    // Names are not set for ISAKMP objects.
    //

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecISAKMPObject->pszIpsecName = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecISAKMPObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);
    } else {
        pIpsecISAKMPObject->pszIpsecName = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecISAKMPObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecISAKMPObject->pIpsecData = pBuffer;
    pIpsecISAKMPObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);

    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecOwnersReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    //
    // ipsecOwnersReference not written.
    //

    if (!dwError && strvalues) {

        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        for (i = 0; i < dwCount; i++) {

            ppszTemp = (strvalues + i);

            //
            // Unmarshall all the values you can possibly have
            //
            pszIpsecNFAName = AllocPolStr(*ppszTemp);
            if (!pszIpsecNFAName) {
                dwError = ERROR_OUTOFMEMORY;

                pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecISAKMPObject->dwNFACount = i;

                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFANames + i) = pszIpsecNFAName;

        }

        pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecISAKMPObject->dwNFACount = dwCount;
        LdapValueFree(strvalues);
    }

    *ppIpsecISAKMPObject = pIpsecISAKMPObject;

    return(0);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecISAKMPObject);
    }

    *ppIpsecISAKMPObject = NULL;

    return(dwError);
}


DWORD
GenerateFilterQuery(
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    LPWSTR * ppszQueryBuffer
    )
{
    DWORD i = 0;
    WCHAR szCommonName[512];
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszQueryBuffer = NULL;

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecFilter)");

    dwLength += wcslen(L"(|");

    for (i = 0; i < dwNumFilterObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszFilterDNs + i),
                        szCommonName
                        );

        dwLength += wcslen(L"(");
        dwLength += wcslen(szCommonName);
        dwLength += wcslen( L")");

    }
    dwLength += wcslen(L")");
    dwLength += wcslen(L")");

    pszQueryBuffer = (LPWSTR)AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    if (!pszQueryBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Now fill in the buffer
    //



    wcscpy(pszQueryBuffer,L"(&(objectclass=ipsecFilter)");

    wcscat(pszQueryBuffer, L"(|");

    for (i = 0; i < dwNumFilterObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszFilterDNs + i),
                        szCommonName
                        );

        wcscat(pszQueryBuffer, L"(");
        wcscat(pszQueryBuffer, szCommonName);
        wcscat(pszQueryBuffer, L")");

    }
    wcscat(pszQueryBuffer, L")");

    wcscat(pszQueryBuffer, L")");

    *ppszQueryBuffer = pszQueryBuffer;

    return(0);


error:

    if (pszQueryBuffer) {

        FreePolMem(pszQueryBuffer);
    }

    *ppszQueryBuffer = NULL;
    return(dwError);
}

DWORD
GenerateNegPolQuery(
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    LPWSTR * ppszQueryBuffer
    )
{
    DWORD i = 0;
    WCHAR szCommonName[512];
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszQueryBuffer = NULL;

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecNegotiationPolicy)");

    dwLength += wcslen(L"(|");

    for (i = 0; i < dwNumNegPolObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszNegPolDNs + i),
                        szCommonName
                        );

        dwLength += wcslen(L"(");
        dwLength += wcslen(szCommonName);
        dwLength += wcslen( L")");

    }
    dwLength += wcslen(L")");
    dwLength += wcslen(L")");

    pszQueryBuffer = (LPWSTR)AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    if (!pszQueryBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Now fill in the buffer
    //



    wcscpy(pszQueryBuffer,L"(&(objectclass=ipsecNegotiationPolicy)");

    wcscat(pszQueryBuffer, L"(|");

    for (i = 0; i < dwNumNegPolObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszNegPolDNs + i),
                        szCommonName
                        );

        wcscat(pszQueryBuffer, L"(");
        wcscat(pszQueryBuffer, szCommonName);
        wcscat(pszQueryBuffer, L")");

    }
    wcscat(pszQueryBuffer, L")");

    wcscat(pszQueryBuffer, L")");

    *ppszQueryBuffer = pszQueryBuffer;

    return(0);


error:

    if (pszQueryBuffer) {

        FreePolMem(pszQueryBuffer);
    }

    *ppszQueryBuffer = NULL;
    return(dwError);
}

DWORD
GenerateNFAQuery(
    LPWSTR * ppszNFADNs,
    DWORD dwNumNFAObjects,
    LPWSTR * ppszQueryBuffer
    )
{
    DWORD i = 0;
    WCHAR szCommonName[512];
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszQueryBuffer = NULL;

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecNFA)");

    dwLength += wcslen(L"(|");

    for (i = 0; i < dwNumNFAObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszNFADNs + i),
                        szCommonName
                        );

        dwLength += wcslen(L"(");
        dwLength += wcslen(szCommonName);
        dwLength += wcslen( L")");

    }
    dwLength += wcslen(L")");
    dwLength += wcslen(L")");

    pszQueryBuffer = (LPWSTR)AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    if (!pszQueryBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Now fill in the buffer
    //



    wcscpy(pszQueryBuffer,L"(&(objectclass=ipsecNFA)");

    wcscat(pszQueryBuffer, L"(|");

    for (i = 0; i < dwNumNFAObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszNFADNs + i),
                        szCommonName
                        );

        wcscat(pszQueryBuffer, L"(");
        wcscat(pszQueryBuffer, szCommonName);
        wcscat(pszQueryBuffer, L")");

    }
    wcscat(pszQueryBuffer, L")");

    wcscat(pszQueryBuffer, L")");

    *ppszQueryBuffer = pszQueryBuffer;

    return(0);


error:

    if (pszQueryBuffer) {

        FreePolMem(pszQueryBuffer);
    }

    *ppszQueryBuffer = NULL;
    return(dwError);
}

DWORD
GenerateISAKMPQuery(
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    LPWSTR * ppszQueryBuffer
    )
{
    DWORD i = 0;
    WCHAR szCommonName[512];
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszQueryBuffer = NULL;

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecISAKMPPolicy)");

    dwLength += wcslen(L"(|");

    for (i = 0; i < dwNumISAKMPObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszISAKMPDNs + i),
                        szCommonName
                        );

        dwLength += wcslen(L"(");
        dwLength += wcslen(szCommonName);
        dwLength += wcslen( L")");

    }
    dwLength += wcslen(L")");
    dwLength += wcslen(L")");

    pszQueryBuffer = (LPWSTR)AllocPolMem((dwLength + 1)*sizeof(WCHAR));
    if (!pszQueryBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Now fill in the buffer
    //



    wcscpy(pszQueryBuffer,L"(&(objectclass=ipsecISAKMPPolicy)");

    wcscat(pszQueryBuffer, L"(|");

    for (i = 0; i < dwNumISAKMPObjects; i++) {


        dwError = ComputePrelimCN(
                        *(ppszISAKMPDNs + i),
                        szCommonName
                        );

        wcscat(pszQueryBuffer, L"(");
        wcscat(pszQueryBuffer, szCommonName);
        wcscat(pszQueryBuffer, L")");

    }
    wcscat(pszQueryBuffer, L")");

    wcscat(pszQueryBuffer, L")");

    *ppszQueryBuffer = pszQueryBuffer;

    return(0);


error:

    if (pszQueryBuffer) {

        FreePolMem(pszQueryBuffer);
    }

    *ppszQueryBuffer = NULL;
    return(dwError);
}



DWORD
ComputePrelimCN(
    LPWSTR szNFADN,
    LPWSTR szCommonName
    )
{
    LPWSTR pszComma = NULL;

    pszComma = wcschr(szNFADN, L',');

    if (!pszComma) {
        return (ERROR_INVALID_DATA);
    }

    *pszComma = L'\0';

    wcscpy(szCommonName, szNFADN);

    *pszComma = L',';

    return(0);
}

DWORD
ComputePolicyContainerDN(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyContainerDN
    )
{
    LPWSTR pszComma = NULL;
    LPWSTR pszPolicyContainer = NULL;
    DWORD dwError = 0;

    *ppszPolicyContainerDN = NULL;
    pszComma = wcschr(pszPolicyDN, L',');

    pszPolicyContainer = AllocPolStr(
                            pszComma + 1
                            );
    if (!pszPolicyContainer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszPolicyContainerDN = pszPolicyContainer;

error:

    return(dwError);
}


DWORD
ComputeDefaultDirectory(
    LPWSTR * ppszDefaultDirectory
    )
{

    PDOMAIN_CONTROLLER_INFOW pDomainControllerInfo = NULL;
    DWORD dwError = 0;
    DWORD Flags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME;
    LPWSTR pszDefaultDirectory = NULL;


    *ppszDefaultDirectory = NULL;

    dwError = DsGetDcNameW(
                   NULL,
                   NULL,
                   NULL,
                   NULL,
                   Flags,
                   &pDomainControllerInfo
                   ) ;
    BAIL_ON_WIN32_ERROR(dwError);


    pszDefaultDirectory = AllocPolStr(
                                pDomainControllerInfo->DomainName
                                );
    if (!pszDefaultDirectory) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszDefaultDirectory = pszDefaultDirectory;

error:

    if (pDomainControllerInfo) {

        (void) NetApiBufferFree(pDomainControllerInfo) ;
    }


    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipsecshr\utils.c ===
#include "precomp.h"


DWORD
ValidateMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;


    if (!pMMPolicy) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMPolicy->pszPolicyName) || !(*(pMMPolicy->pszPolicyName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateMMOffers(
                  pMMPolicy->dwOfferCount,
                  pMMPolicy->pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
ValidateMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_MM_OFFER pTemp = NULL;


    if (!dwOfferCount || !pOffers || (dwOfferCount > IPSEC_MAX_MM_OFFERS)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Need to catch the exception when the number of offers
    // specified is more than the actual number of offers.
    //


    pTemp = pOffers;

    for (i = 0; i < dwOfferCount; i++) {

        if ((pTemp->dwDHGroup != DH_GROUP_1) &&
            (pTemp->dwDHGroup != DH_GROUP_2)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pTemp->EncryptionAlgorithm.uAlgoIdentifier >= IPSEC_DOI_ESP_MAX) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pTemp->HashingAlgorithm.uAlgoIdentifier >= IPSEC_DOI_AH_MAX) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pTemp++;

    }

error:

    return (dwError);
}


DWORD
ValidateMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;
    DWORD dwNumAuthInfos = 0;
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    BOOL bSSPI = FALSE;
    BOOL bPresharedKey = FALSE;


    if (!pMMAuthMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumAuthInfos = pMMAuthMethods->dwNumAuthInfos;
    pAuthenticationInfo = pMMAuthMethods->pAuthenticationInfo;

    if (!dwNumAuthInfos || !pAuthenticationInfo) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Need to catch the exception when the number of auth infos
    // specified is more than the actual number of auth infos.
    //


    pTemp = pAuthenticationInfo;

    for (i = 0; i < dwNumAuthInfos; i++) {

        if ((pTemp->AuthMethod != IKE_PRESHARED_KEY) &&
            (pTemp->AuthMethod != IKE_RSA_SIGNATURE) &&
            (pTemp->AuthMethod != IKE_SSPI)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pTemp->AuthMethod != IKE_SSPI) {
            if (!(pTemp->dwAuthInfoSize) || !(pTemp->pAuthInfo)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
        }

        if (pTemp->AuthMethod == IKE_SSPI) {
            if (bSSPI) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            bSSPI = TRUE;
        }

        if (pTemp->AuthMethod == IKE_PRESHARED_KEY) {
            if (bPresharedKey) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            bPresharedKey = TRUE;
        }

        pTemp++;

    }

error:

    return (dwError);
}


DWORD
ValidateQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;


    if (!pQMPolicy) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicy->pszPolicyName) || !(*(pQMPolicy->pszPolicyName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateQMOffers(
                  pQMPolicy->dwOfferCount,
                  pQMPolicy->pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
ValidateQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_QM_OFFER pTemp = NULL;
    DWORD j = 0;
    BOOL bAH = FALSE;
    BOOL bESP = FALSE;
    DWORD dwQMGroup = PFS_GROUP_NONE;


    if (!dwOfferCount || !pOffers || (dwOfferCount > IPSEC_MAX_QM_OFFERS)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Need to catch the exception when the number of offers
    // specified is more than the actual number of offers.
    //


    pTemp = pOffers;

    if (pTemp->bPFSRequired) {
        if ((pTemp->dwPFSGroup != PFS_GROUP_1) &&
            (pTemp->dwPFSGroup != PFS_GROUP_2) &&
            (pTemp->dwPFSGroup != PFS_GROUP_MM)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        dwQMGroup=pTemp->dwPFSGroup;
    }
    else {
        if (pTemp->dwPFSGroup != PFS_GROUP_NONE) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwOfferCount; i++) {
        
        if (dwQMGroup) {
            if ((!pTemp->bPFSRequired) || (pTemp->dwPFSGroup != dwQMGroup)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);    
            } 
        } else {            
            if ((pTemp->bPFSRequired) || (pTemp->dwPFSGroup != PFS_GROUP_NONE)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);    
            }
        }

        if (!(pTemp->dwNumAlgos) || (pTemp->dwNumAlgos > QM_MAX_ALGOS)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        bAH = FALSE;
        bESP = FALSE;

        for (j = 0; j < (pTemp->dwNumAlgos); j++) {

            switch (pTemp->Algos[j].Operation) {

            case AUTHENTICATION:
                if (bAH) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if ((pTemp->Algos[j].uAlgoIdentifier == IPSEC_DOI_AH_NONE) ||
                    (pTemp->Algos[j].uAlgoIdentifier >= IPSEC_DOI_AH_MAX)) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if (pTemp->Algos[j].uSecAlgoIdentifier != HMAC_AH_NONE) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                bAH = TRUE;
                break;

            case ENCRYPTION:
                if (bESP) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if (pTemp->Algos[j].uAlgoIdentifier >= IPSEC_DOI_ESP_MAX) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if (pTemp->Algos[j].uSecAlgoIdentifier >= HMAC_AH_MAX) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                if (pTemp->Algos[j].uAlgoIdentifier == IPSEC_DOI_ESP_NONE) {
                    if (pTemp->Algos[j].uSecAlgoIdentifier == HMAC_AH_NONE) {
                        dwError = ERROR_INVALID_PARAMETER;
                        BAIL_ON_WIN32_ERROR(dwError);
                    }
                }
                bESP = TRUE;
                break;

            case NONE:
            case COMPRESSION:
            default:
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
                break;

            }

        }

        pTemp++;

    }

error:

    return (dwError);
}


DWORD
ValidateMMFilter(
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function validates an external generic MM filter.

Arguments:

    pMMFilter - Filter to validate.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pMMFilter->SrcAddr, TRUE , FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pMMFilter->DesAddr, TRUE , TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pMMFilter->SrcAddr,
                     pMMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilter->pszFilterName) || !(*(pMMFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->InterfaceType >= INTERFACE_TYPE_MAX) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->dwFlags &&
        !(pMMFilter->dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY) &&
        !(pMMFilter->dwFlags & IPSEC_MM_AUTH_DEFAULT_AUTH)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ApplyMulticastFilterValidation(
                  pMMFilter->DesAddr,
                  pMMFilter->bCreateMirror
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
VerifyAddresses(
    ADDR Addr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    )
{
    DWORD dwError = 0;
    BOOL bIsValid = FALSE;

    switch (Addr.AddrType) {

    case IP_ADDR_UNIQUE:
        bIsValid = bIsValidIPAddress(
                       ntohl(Addr.uIpAddr),
                       bAcceptMe,
                       bIsDesAddr
                       );
        if (!bIsValid) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    case IP_ADDR_SUBNET:
        dwError = VerifySubNetAddress(
                      ntohl(Addr.uIpAddr),
                      ntohl(Addr.uSubNetMask),
                      bIsDesAddr
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case IP_ADDR_INTERFACE:
        if (Addr.uIpAddr) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


DWORD
VerifySubNetAddress(
    ULONG uSubNetAddr,
    ULONG uSubNetMask,
    BOOL bIsDesAddr
    )
{
    DWORD dwError = 0;
    BOOL  bIsValid = FALSE;

    if (uSubNetAddr == SUBNET_ADDRESS_ANY) {
        if (uSubNetMask != SUBNET_MASK_ANY) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        bIsValid = bIsValidSubnet(
                       uSubNetAddr,
                       uSubNetMask,
                       bIsDesAddr
                       );
        if (!bIsValid) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
bIsValidIPMask(
    ULONG uMask
    )
{
    BOOL bValidMask = FALSE;
    ULONG uTestMask = 0;

    //
    // Mask must be contiguous bits.
    //

    for (uTestMask = 0xFFFFFFFF; uTestMask; uTestMask <<= 1) {

        if (uTestMask == uMask) {
            bValidMask = TRUE;
            break;
        }

    }

    return (bValidMask);
}


BOOL
bIsValidIPAddress(
    ULONG uIpAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    )
{
    ULONG uHostMask = IN_CLASSA_HOST;   // Default host mask.


    //
    // Accept the address if its "me".
    //

    if (bAcceptMe) {
        if (uIpAddr == IP_ADDRESS_ME) {
            return TRUE;
        }
    }

    //
    // Reject if its a multicast address and is not the 
    // destination address.
    //

    if (IN_CLASSD(uIpAddr)) {
        if (bIsDesAddr) {
            return TRUE;
        }
        else {
            return FALSE;
        }
    }

    //
    // Reject if its a Class E address.
    //

    if (IN_CLASSE(uIpAddr)) {
        return FALSE;
    }

    //
    // Reject if the first octet is zero.
    //

    if (!(IN_CLASSA_NET & uIpAddr)) {
        return FALSE;
    }

    //
    // Use default mask based on Class when none is provided.
    //

    if (IN_CLASSA(uIpAddr)) {
        uHostMask = IN_CLASSA_HOST;
    }
    else if (IN_CLASSB(uIpAddr)) {
        uHostMask = IN_CLASSB_HOST;
    }
    else if (IN_CLASSC(uIpAddr)) {
        uHostMask = IN_CLASSC_HOST;
    }

    //
    // Accept address when host portion is non-zero.
    //

    if (uHostMask & uIpAddr) {
        return TRUE;
    }

    return FALSE;
}


BOOL
bIsValidSubnet(
    ULONG uIpAddr,
    ULONG uMask,
    BOOL bIsDesAddr
    )
{
    ULONG uHostMask = 0;


    //
    // Reject if its a multicast address and is not the 
    // destination address.
    //

    if (IN_CLASSD(uIpAddr)) {
        if (!bIsDesAddr) {
            return FALSE;
        }
    }

    //
    // Reject if its a Class E address.
    //

    if (IN_CLASSE(uIpAddr)) {
        return FALSE;
    }

    //
    // Reject if the first octet is zero.
    //

    if (!(IN_CLASSA_NET & uIpAddr)) {
        return FALSE;
    }

    //
    // If the mask is invalid then return.
    //

    if (!bIsValidIPMask(uMask)) {
        return FALSE;
    }

    //
    // Use the provided subnet mask to generate the host mask.
    //

    uHostMask = 0xFFFFFFFF ^ uMask;

    //
    // Validate the address and the mask.
    //

    if (IN_CLASSA(uIpAddr)) {
        if (IN_CLASSA_NET > uMask) {
            return FALSE;
        }
    }
    else if (IN_CLASSB(uIpAddr)) {
        if (IN_CLASSB_NET > uMask) {
            return FALSE;
        }
    }
    else if (IN_CLASSC(uIpAddr)) {
        if (IN_CLASSC_NET > uMask) {
            return TRUE;
        }
    }

    //
    // Accept address only when the host portion is zero, network
    // portion is non-zero and first octet is non-zero.
    //

    if (!(uHostMask & uIpAddr) &&
        (uMask & uIpAddr) &&
        (IN_CLASSA_NET & uIpAddr)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
AddressesConflict(
    ADDR SrcAddr,
    ADDR DesAddr
    )
{
    if ((SrcAddr.AddrType == IP_ADDR_UNIQUE) &&
        (DesAddr.AddrType == IP_ADDR_UNIQUE)) {

        if (SrcAddr.uIpAddr == DesAddr.uIpAddr) {
            return (TRUE);
        }

    }

    if ((SrcAddr.AddrType == IP_ADDR_INTERFACE) &&
        (DesAddr.AddrType == IP_ADDR_INTERFACE)) {
        return (TRUE);
    }

    return (FALSE);
}


DWORD
ValidateTransportFilter(
    PTRANSPORT_FILTER pTransportFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTransportFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTransportFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pTransportFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTransportFilter->SrcAddr,
                     pTransportFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyProtocols(pTransportFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTransportFilter->SrcPort,
                  pTransportFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTransportFilter->DesPort,
                  pTransportFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!(pTransportFilter->pszFilterName) || !(*(pTransportFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTransportFilter->InterfaceType >= INTERFACE_TYPE_MAX) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTransportFilter->InboundFilterFlag >= FILTER_FLAG_MAX) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTransportFilter->OutboundFilterFlag >= FILTER_FLAG_MAX) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTransportFilter->dwFlags &&
        !(pTransportFilter->dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ApplyMulticastFilterValidation(
                  pTransportFilter->DesAddr,
                  pTransportFilter->bCreateMirror
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}

DWORD
ValidateIPSecQMFilter(
    PIPSEC_QM_FILTER pQMFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;

    if (!pQMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pQMFilter->SrcAddr, FALSE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pQMFilter->DesAddr, FALSE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pQMFilter->SrcAddr,
                     pQMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyProtocols(pQMFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pQMFilter->SrcPort,
                  pQMFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pQMFilter->DesPort,
                  pQMFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    if (pQMFilter->QMFilterType == QM_TUNNEL_FILTER) {

        if (pQMFilter->MyTunnelEndpt.AddrType != IP_ADDR_UNIQUE) {
            dwError=ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        if (pQMFilter->PeerTunnelEndpt.AddrType != IP_ADDR_UNIQUE) {
            dwError=ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        dwError = VerifyAddresses(pQMFilter->MyTunnelEndpt, FALSE, FALSE);
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = VerifyAddresses(pQMFilter->PeerTunnelEndpt, FALSE, FALSE);
        BAIL_ON_WIN32_ERROR(dwError);

    }

    if (pQMFilter->QMFilterType != QM_TUNNEL_FILTER &&
        pQMFilter->QMFilterType != QM_TRANSPORT_FILTER) {
        dwError=ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}

DWORD
VerifyProtocols(
    PROTOCOL Protocol
    )
{
    DWORD dwError = 0;

    switch (Protocol.ProtocolType) {

    case PROTOCOL_UNIQUE:
        if (Protocol.dwProtocol > 255) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


DWORD
VerifyPortsForProtocol(
    PORT Port,
    PROTOCOL Protocol
    )
{
    DWORD dwError = 0;

    switch (Port.PortType) {

    case PORT_UNIQUE:

        if (Port.wPort < 0) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        switch (Protocol.ProtocolType) {

        case PROTOCOL_UNIQUE:
            if ((Protocol.dwProtocol != IPPROTO_TCP) &&
                (Protocol.dwProtocol != IPPROTO_UDP)) {
                if (Port.wPort != 0) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
            }
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
            break;

        }

        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


DWORD
ValidateMMFilterTemplate(
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pMMFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pMMFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pMMFilter->SrcAddr,
                     pMMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->dwDirection) {
        if ((pMMFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pMMFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


DWORD
ValidateTxFilterTemplate(
    PTRANSPORT_FILTER pTxFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTxFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTxFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pTxFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTxFilter->SrcAddr,
                     pTxFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyProtocols(pTxFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTxFilter->SrcPort,
                  pTxFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTxFilter->DesPort,
                  pTxFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTxFilter->dwDirection) {
        if ((pTxFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pTxFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


DWORD
ValidateTunnelFilter(
    PTUNNEL_FILTER pTunnelFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTunnelFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTunnelFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pTunnelFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTunnelFilter->SrcAddr,
                     pTunnelFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTunnelFilter->DesTunnelAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyProtocols(pTunnelFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTunnelFilter->SrcPort,
                  pTunnelFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTunnelFilter->DesPort,
                  pTunnelFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!(pTunnelFilter->pszFilterName) || !(*(pTunnelFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTunnelFilter->InterfaceType >= INTERFACE_TYPE_MAX) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTunnelFilter->bCreateMirror) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTunnelFilter->InboundFilterFlag >= FILTER_FLAG_MAX) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTunnelFilter->OutboundFilterFlag >= FILTER_FLAG_MAX) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pTunnelFilter->dwFlags &&
        !(pTunnelFilter->dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // No need to call ApplyMulticastFilterValidation as bCreateMirror
    // is always false for a tunnel filter.
    //

error:

    return (dwError);
}


DWORD
ValidateTnFilterTemplate(
    PTUNNEL_FILTER pTnFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTnFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pTnFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTnFilter->SrcAddr,
                     pTnFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pTnFilter->DesTunnelAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyProtocols(pTnFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->SrcPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->DesPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTnFilter->dwDirection) {
        if ((pTnFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pTnFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


DWORD
ApplyMulticastFilterValidation(
    ADDR Addr,
    BOOL bCreateMirror
    )
{
    DWORD dwError = 0;


    if (((Addr.AddrType == IP_ADDR_UNIQUE) ||
        (Addr.AddrType == IP_ADDR_SUBNET)) &&
        (IN_CLASSD(ntohl(Addr.uIpAddr))) &&
        bCreateMirror) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\freeobj.c ===
#include "precomp.h"

void
FreeIpsecNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    if (pIpsecNFAObject->pszDistinguishedName) {
        FreePolStr(pIpsecNFAObject->pszDistinguishedName);
    }

    if (pIpsecNFAObject->pszIpsecName) {
        FreePolStr(pIpsecNFAObject->pszIpsecName);
    }

    if (pIpsecNFAObject->pszDescription) {
        FreePolStr(pIpsecNFAObject->pszDescription);
    }

    if (pIpsecNFAObject->pszIpsecID) {
        FreePolStr(pIpsecNFAObject->pszIpsecID);
    }

    if (pIpsecNFAObject->pIpsecData) {
        FreePolMem(pIpsecNFAObject->pIpsecData);
    }

    if (pIpsecNFAObject->pszIpsecOwnersReference) {
        FreePolStr(pIpsecNFAObject->pszIpsecOwnersReference);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        FreePolStr(pIpsecNFAObject->pszIpsecFilterReference);
    }

    if (pIpsecNFAObject->pszIpsecNegPolReference) {
        FreePolStr(pIpsecNFAObject->pszIpsecNegPolReference);
    }

    FreePolMem(pIpsecNFAObject);

    return;
}


void
FreeIpsecPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    if (pIpsecPolicyObject->pszDescription) {
        FreePolStr(pIpsecPolicyObject->pszDescription);
    }

    if (pIpsecPolicyObject->pszIpsecOwnersReference) {
        FreePolStr(pIpsecPolicyObject->pszIpsecOwnersReference);
    }

    if (pIpsecPolicyObject->pszIpsecName) {
        FreePolStr(pIpsecPolicyObject->pszIpsecName);
    }

    if (pIpsecPolicyObject->pszIpsecID) {
        FreePolStr(pIpsecPolicyObject->pszIpsecID);
    }

    if (pIpsecPolicyObject->pIpsecData) {
        FreePolMem(pIpsecPolicyObject->pIpsecData);
    }

    if (pIpsecPolicyObject->pszIpsecISAKMPReference) {
        FreePolStr(pIpsecPolicyObject->pszIpsecISAKMPReference);
    }

    if (pIpsecPolicyObject->ppszIpsecNFAReferences) {
        FreeNFAReferences(
                pIpsecPolicyObject->ppszIpsecNFAReferences,
                pIpsecPolicyObject->NumberofRules
                );
    }

    if (pIpsecPolicyObject->ppIpsecNFAObjects) {
        FreeIpsecNFAObjects(
                pIpsecPolicyObject->ppIpsecNFAObjects,
                pIpsecPolicyObject->NumberofRulesReturned
                );
    }


    if (pIpsecPolicyObject->ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
                pIpsecPolicyObject->ppIpsecFilterObjects,
                pIpsecPolicyObject->NumberofFilters
                );
    }


    if (pIpsecPolicyObject->ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
                pIpsecPolicyObject->ppIpsecNegPolObjects,
                pIpsecPolicyObject->NumberofNegPols
                );
    }

    if (pIpsecPolicyObject->ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
                pIpsecPolicyObject->ppIpsecISAKMPObjects,
                pIpsecPolicyObject->NumberofISAKMPs
                );
    }

    FreePolMem(pIpsecPolicyObject);

    return;
}



void
FreeIpsecFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{

    if (pIpsecFilterObject->pszDistinguishedName) {
        FreePolStr(pIpsecFilterObject->pszDistinguishedName);
    }

    if (pIpsecFilterObject->pszDescription) {
        FreePolStr(pIpsecFilterObject->pszDescription);
    }

    if (pIpsecFilterObject->pszIpsecName) {
        FreePolStr(pIpsecFilterObject->pszIpsecName);
    }

    if (pIpsecFilterObject->pszIpsecID) {
        FreePolStr(pIpsecFilterObject->pszIpsecID);
    }

    if (pIpsecFilterObject->pIpsecData) {
        FreePolMem(pIpsecFilterObject->pIpsecData);
    }


    if (pIpsecFilterObject->ppszIpsecNFAReferences) {
        FreeNFAReferences(
                pIpsecFilterObject->ppszIpsecNFAReferences,
                pIpsecFilterObject->dwNFACount
                );
    }


    FreePolMem(pIpsecFilterObject);

    return;
}


void
FreeIpsecNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    if (pIpsecNegPolObject->pszDescription) {
        FreePolStr(pIpsecNegPolObject->pszDescription);
    }

    if (pIpsecNegPolObject->pszDistinguishedName) {
        FreePolStr(pIpsecNegPolObject->pszDistinguishedName);
    }

    if (pIpsecNegPolObject->pszIpsecName) {
        FreePolStr(pIpsecNegPolObject->pszIpsecName);
    }

    if (pIpsecNegPolObject->pszIpsecID) {
        FreePolStr(pIpsecNegPolObject->pszIpsecID);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolAction) {
        FreePolStr(pIpsecNegPolObject->pszIpsecNegPolAction);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolType) {
        FreePolStr(pIpsecNegPolObject->pszIpsecNegPolType);
    }

    if (pIpsecNegPolObject->pIpsecData) {
        FreePolMem(pIpsecNegPolObject->pIpsecData);
    }

    if (pIpsecNegPolObject->ppszIpsecNFAReferences) {
        FreeNFAReferences(
                pIpsecNegPolObject->ppszIpsecNFAReferences,
                pIpsecNegPolObject->dwNFACount
                );
    }


    FreePolMem(pIpsecNegPolObject);

    return;
}

void
FreeIpsecISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{

    if (pIpsecISAKMPObject->pszDistinguishedName) {
        FreePolStr(pIpsecISAKMPObject->pszDistinguishedName);
    }

    if (pIpsecISAKMPObject->pszIpsecName) {
        FreePolStr(pIpsecISAKMPObject->pszIpsecName);
    }

    if (pIpsecISAKMPObject->pszIpsecID) {
        FreePolStr(pIpsecISAKMPObject->pszIpsecID);
    }

    if (pIpsecISAKMPObject->pIpsecData) {
        FreePolMem(pIpsecISAKMPObject->pIpsecData);
    }

    if (pIpsecISAKMPObject->ppszIpsecNFAReferences) {
        FreeNFAReferences(
                pIpsecISAKMPObject->ppszIpsecNFAReferences,
                pIpsecISAKMPObject->dwNFACount
                );
    }


    FreePolMem(pIpsecISAKMPObject);

    return;
}


void
FreeNFAReferences(
    LPWSTR * ppszNFAReferences,
    DWORD dwNumNFAReferences
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumNFAReferences; i++) {

        if (*(ppszNFAReferences + i)) {

            FreePolStr(*(ppszNFAReferences + i));
        }
    }

    FreePolMem(ppszNFAReferences);
    return;
}

void
FreeFilterReferences(
    LPWSTR * ppszFilterReferences,
    DWORD dwNumFilterReferences
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumFilterReferences; i++) {

        if (*(ppszFilterReferences + i)) {

            FreePolStr(*(ppszFilterReferences + i));
        }
    }

    FreePolMem(ppszFilterReferences);
    return;
}






void
FreeNegPolReferences(
    LPWSTR * ppszNegPolReferences,
    DWORD dwNumNegPolReferences
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumNegPolReferences; i++) {

        if (*(ppszNegPolReferences + i)) {

            FreePolStr(*(ppszNegPolReferences + i));
        }
    }

    FreePolMem(ppszNegPolReferences);
    return;
}

void
FreeIpsecNFAObjects(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumNFAObjects; i++) {

        if (*(ppIpsecNFAObjects + i)) {

            FreeIpsecNFAObject(*(ppIpsecNFAObjects + i));

        }

    }

    FreePolMem(ppIpsecNFAObjects);

    return;
}

void
FreeIpsecFilterObjects(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumFilterObjects; i++) {

        if (*(ppIpsecFilterObjects + i)) {

            FreeIpsecFilterObject(*(ppIpsecFilterObjects + i));

        }

    }

    FreePolMem(ppIpsecFilterObjects);

    return;
}

void
FreeIpsecNegPolObjects(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumNegPolObjects; i++) {

        if (*(ppIpsecNegPolObjects + i)) {

            FreeIpsecNegPolObject(*(ppIpsecNegPolObjects + i));

        }

    }

    FreePolMem(ppIpsecNegPolObjects);

    return;
}

void
FreeIpsecISAKMPObjects(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        if (*(ppIpsecISAKMPObjects + i)) {

            FreeIpsecISAKMPObject(*(ppIpsecISAKMPObjects + i));

        }

    }

    FreePolMem(ppIpsecISAKMPObjects);

    return;
}


void
FreeIpsecPolicyObjects(
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects,
    DWORD dwNumPolicyObjects
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumPolicyObjects; i++) {

        if (*(ppIpsecPolicyObjects + i)) {

            FreeIpsecPolicyObject(*(ppIpsecPolicyObjects + i));

        }

    }

    FreePolMem(ppIpsecPolicyObjects);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\ldaputil.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       drt.cxx
//
//  Contents:   Main for OleDs DRT
//
//
//  History:    28-Oct-94  KrishnaG, created OleDs DRT
//              28-Oct-94  ChuckC, rewritten.
//
//----------------------------------------------------------------------------


#include "precomp.h"


DWORD
LdapOpen(
    WCHAR *domainName,
    int portno,
    HLDAP * phLdapHandle
    )
{
    int ldaperr = 0;
    void *ldapOption;
    HLDAP hLdapHandle = NULL;
    DWORD dwError = 0;

    hLdapHandle = ldap_init(domainName, portno );

    if (hLdapHandle == NULL ) {

        dwError = ERROR_BAD_NETPATH;
        goto error;
    }

    //
    // Now process versioning
    //

    ldapOption = (void *) LDAP_VERSION3;

    ldaperr = ldap_set_option(
                  hLdapHandle,
                  LDAP_OPT_VERSION,
                  &(ldapOption)
                  );

    ldapOption = LDAP_OPT_ON;

    ldaperr = ldap_set_option(
                    hLdapHandle,
                    LDAP_OPT_ENCRYPT,
                    &(ldapOption)
                    );


    ldaperr = ldap_connect(hLdapHandle, NULL);

    if (ldaperr) {

        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

        goto error;
    }

    //
    // Disabled Callback function support and chasing external referrals
    // KrishnaG - do I need to support this.

    *phLdapHandle = hLdapHandle;

    return(dwError);

error:

    if (hLdapHandle != NULL) {

        ldaperr = ldap_unbind( hLdapHandle );

    }

    return (dwError);
}

DWORD
LdapBind(
    HLDAP hLdapHandle
    )
{
    int ldaperr = 0;

    ldaperr = ldap_bind_s(hLdapHandle, NULL, NULL, LDAP_AUTH_SSPI);

    return (ldaperr);
}


DWORD
LdapSearchHelper(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
    )
{
    int nCount = 0;
    int j = 0;
    int ldaperr = 0;
    DWORD dwError = 0;

    if ( timeout == NULL )
    {
        ldaperr = ldap_search_s(
                        hLdapHandle,
                        base,
                        scope,
                        filter,
                        attrs,
                        attrsonly,
                        res
                        );
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

    }
    else
    {
        ldaperr = ldap_search_st(
                        hLdapHandle,
                        base,
                        scope,
                        filter,
                        attrs,
                        attrsonly,
                        timeout,
                        res
                        );
        dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

    }

    //
    // Is there an error with checking the no of results
    //

    return (dwError);
}


DWORD
LdapSearchS(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    LDAPMessage **res
    )
{

    DWORD dwError = 0;

    dwError = LdapSearchHelper(
                  hLdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  NULL,
                  res
                  );
    //
    // Is there a check needed for connection errors
    //

    return(dwError);

}

DWORD
LdapSearchST(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
    )
{
    DWORD dwError = 0;

    dwError = LdapSearchHelper(
                  hLdapHandle,
                  base,
                  scope,
                  filter,
                  attrs,
                  attrsonly,
                  timeout,
                  res
                  );

    return(dwError);
}




















//
// Completely new functionality - block ported from YihsinS code in ADSI
//


DWORD
LdapAbandon(
    HLDAP hLdapHandle,
    int   msgid
    )
{

    // No error code, 0 if success, -1 otherwise
    return ldap_abandon( hLdapHandle, msgid );
}

DWORD
LdapResult(
    HLDAP hLdapHandle,
    int    msgid,
    int    all,
    struct l_timeval *timeout,
    LDAPMessage **res,
    int    *restype
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    *restype = ldap_result( hLdapHandle, msgid, all, timeout, res );

    if ( *restype == -1 )  // error
        ldaperr = LdapGetLastError();

    if (ldaperr) {

       if (!ldap_count_entries( hLdapHandle, *res )) {

           dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
       }
    }else {

        dwError = 0;
    }

    return(dwError);

}

void
LdapMsgFree(
    LDAPMessage *res
    )
{
    ldap_msgfree( res );  // Returns the type of message freed which
                          // is not interesting
}

int
LdapResult2Error(
    HLDAP hLdapHandle,
    LDAPMessage *res,
    int freeit
    )
{

    return ldap_result2error( hLdapHandle, res, freeit );
}

DWORD
LdapFirstEntry(
    HLDAP hLdapHandle,
    LDAPMessage *res,
    LDAPMessage **pfirst
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    *pfirst = ldap_first_entry( hLdapHandle, res );

    if ( *pfirst == NULL )
    {
        ldaperr = LdapGetLastError();

        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
    }

    return(dwError);
}

DWORD
LdapNextEntry(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    LDAPMessage **pnext
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    *pnext = ldap_next_entry( hLdapHandle, entry );

    if ( *pnext == NULL )
    {
        ldaperr = LdapGetLastError();

        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
    }

    return(dwError);
}

int
LdapCountEntries(
    HLDAP hLdapHandle,
    LDAPMessage *res
    )
{

    return ldap_count_entries( hLdapHandle, res );
}

DWORD
LdapFirstAttribute(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    void  **ptr,
    WCHAR **pattr
    )
{

    // NOTE: The return value from ldap_first_attribute is static and
    //       should not be freed

    *pattr = ldap_first_attribute( hLdapHandle, entry,
                                   (struct berelement **) ptr );  // static data

    if ( *pattr == NULL )
    {
        DWORD dwError = 0;
        int ldaperr = 0;

        // Error occurred or end of attributes

        ldaperr = LdapGetLastError();

        CheckAndSetExtendedError( hLdapHandle, ldaperr);

        return(dwError);
    }

    return NO_ERROR;

}

DWORD
LdapNextAttribute(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    void  *ptr,
    WCHAR **pattr
    )
{

    // NOTE: The return value from ldap_next_attribute is static and
    //       should not be freed
    *pattr = ldap_next_attribute( hLdapHandle, entry,
                                  (struct berelement *) ptr );  // static data

#if 0   // Ignore the error code here since at the end of the enumeration,
        // we will probably get an error code here ( both Andy and umich's
        // dll will return errors sometimes. No error returned from NTDS,
        // but errors are returned from Exchange server  )

    if ( *pattr == NULL )
    {
        DWORD hr = NO_ERROR;
        int ldaperr = 0;

        // Error occurred or end of attributes
        ldaperr = LdapGetLastError();
        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        return(dwError);
    }
#endif

    return S_OK;
}


//
// NOTE: LdapGetValues return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

DWORD
LdapGetValues(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR *attr,
    WCHAR ***pvalues,
    int   *pcount
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    *pvalues = ldap_get_values( hLdapHandle, entry, attr );

    if ( *pvalues == NULL ) {

        *pcount=0;

        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //

        ldaperr = LdapGetLastError();

        if (ldaperr) {

            dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        }

        //
        // KrishnaG if  *pvalues is NULL which means I don't get back a
        // value - return an ERROR
        //

        return(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
    }

    *pcount = ldap_count_values( *pvalues );

    return S_OK;
}


//
// NOTE: LdapGetValuesLen return S_OK if attribute [attr] has no values
//       (*[pvalues] =NULL, *[pcount]=0) but all else ok.
//

DWORD
LdapGetValuesLen(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR *attr,
    struct berval ***pvalues,
    int   *pcount
    )
{
    //
    // NOTE: this can contain binary data as well as strings,
    //       strings are ascii, no conversion is done here
    //

    char *pszAttrA = NULL;
    DWORD dwError = 0;
    int ldaperr = 0;


    *pvalues = ldap_get_values_len( hLdapHandle, entry, attr );

    if ( *pvalues == NULL ){

        *pcount=0;

        //
        // ldap_get_values succeeds if attribute has no values
        // but all else ok.  (confiremed with anoopa)
        //

        ldaperr = LdapGetLastError();

        if (ldaperr) {

            dwError = CheckAndSetExtendedError( hLdapHandle,ldaperr);
        }

        return(ERROR_DS_NO_ATTRIBUTE_OR_VALUE);
    }

    *pcount = ldap_count_values_len( *pvalues );

    return S_OK;
}


void
LdapValueFree(
    WCHAR **vals
    )
{
    ldap_value_free( vals );
}

void
LdapValueFreeLen(
    struct berval **vals
    )
{
    ldap_value_free_len( vals );
}

void
LdapMemFree(
    WCHAR *pszString
    )
{
    ldap_memfree( pszString );
}

void
LdapAttributeFree(
    WCHAR *pszString
    )
{
    // String from ldap_first/next_attribute should not be freed,
    // so do nothing here
}

DWORD
LdapGetDn(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR **pdn
    )
{
    int ldaperr = 0;
    DWORD dwError = 0;

    *pdn = ldap_get_dn( hLdapHandle, entry );
    if ( *pdn == NULL )
    {
        // Error occurred
        ldaperr = LdapGetLastError();

        dwError = CheckAndSetExtendedError( hLdapHandle, ldaperr);
        return(dwError);
    }

    return(dwError);
}



DWORD
CheckAndSetExtendedError(
    HLDAP hLdapHandle,
    int     ldaperr
    )
{

    DWORD dwErr = NO_ERROR;

    switch (ldaperr) {

    case LDAP_SUCCESS :
        dwErr = NO_ERROR;
        break;

    case LDAP_OPERATIONS_ERROR :
        dwErr =  ERROR_DS_OPERATIONS_ERROR;
        break;

    case LDAP_PROTOCOL_ERROR :
        dwErr =  ERROR_DS_PROTOCOL_ERROR;
        break;

    case LDAP_TIMELIMIT_EXCEEDED :
        dwErr = ERROR_DS_TIMELIMIT_EXCEEDED;
        break;

    case LDAP_SIZELIMIT_EXCEEDED :
        dwErr = ERROR_DS_SIZELIMIT_EXCEEDED;
        break;

    case LDAP_COMPARE_FALSE :
        dwErr = ERROR_DS_COMPARE_FALSE;
        break;

    case LDAP_COMPARE_TRUE :
        dwErr = ERROR_DS_COMPARE_TRUE;
        break;

    case LDAP_AUTH_METHOD_NOT_SUPPORTED :
        dwErr = ERROR_DS_AUTH_METHOD_NOT_SUPPORTED;
        break;

    case LDAP_STRONG_AUTH_REQUIRED :
        dwErr =  ERROR_DS_STRONG_AUTH_REQUIRED;
        break;

    case LDAP_PARTIAL_RESULTS :

        //
        // Make sure we handle
        // partial results.
        //
        dwErr = ERROR_MORE_DATA;
        break;


    case LDAP_REFERRAL :
        dwErr =  ERROR_DS_REFERRAL;
        break;

    case LDAP_ADMIN_LIMIT_EXCEEDED :
        dwErr   = ERROR_DS_ADMIN_LIMIT_EXCEEDED;
        break;

    case LDAP_UNAVAILABLE_CRIT_EXTENSION :
        dwErr = ERROR_DS_UNAVAILABLE_CRIT_EXTENSION;
        break;

    case LDAP_CONFIDENTIALITY_REQUIRED :
        dwErr = ERROR_DS_CONFIDENTIALITY_REQUIRED;
        break;

    case LDAP_NO_SUCH_ATTRIBUTE :
        dwErr = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        break;

    case LDAP_UNDEFINED_TYPE :
        dwErr = ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED;
        break;

    case LDAP_INAPPROPRIATE_MATCHING :
        dwErr = ERROR_DS_INAPPROPRIATE_MATCHING;
        break;

    case LDAP_CONSTRAINT_VIOLATION :
        dwErr = ERROR_DS_CONSTRAINT_VIOLATION;
        break;

    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS :
        dwErr = ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS;
        break;

    case LDAP_INVALID_SYNTAX :
        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
        break;

    case LDAP_NO_SUCH_OBJECT :
        dwErr = ERROR_DS_NO_SUCH_OBJECT;
        break;

    case LDAP_ALIAS_PROBLEM :
        dwErr = ERROR_DS_ALIAS_PROBLEM;
        break;

    case LDAP_INVALID_DN_SYNTAX :
        dwErr = ERROR_DS_INVALID_DN_SYNTAX;
        break;

    case LDAP_IS_LEAF :
        dwErr = ERROR_DS_IS_LEAF;
        break;

    case LDAP_ALIAS_DEREF_PROBLEM :
        dwErr = ERROR_DS_ALIAS_DEREF_PROBLEM;
        break;

    case LDAP_INAPPROPRIATE_AUTH :
        dwErr = ERROR_DS_INAPPROPRIATE_AUTH;
        break;

    case LDAP_INVALID_CREDENTIALS :
        dwErr = ERROR_LOGON_FAILURE;
        break;

    case LDAP_INSUFFICIENT_RIGHTS :
        dwErr = ERROR_ACCESS_DENIED;
        break;

    case LDAP_BUSY :
        dwErr = ERROR_DS_BUSY;
        break;

    case LDAP_UNAVAILABLE :
        dwErr = ERROR_DS_UNAVAILABLE;
        break;

    case LDAP_UNWILLING_TO_PERFORM :
        dwErr = ERROR_DS_UNWILLING_TO_PERFORM;
        break;

    case LDAP_LOOP_DETECT :
        dwErr = ERROR_DS_LOOP_DETECT;
        break;

    case LDAP_NAMING_VIOLATION :
        dwErr = ERROR_DS_NAMING_VIOLATION;
        break;

    case LDAP_OBJECT_CLASS_VIOLATION :
        dwErr = ERROR_DS_OBJ_CLASS_VIOLATION;
        break;

    case LDAP_NOT_ALLOWED_ON_NONLEAF :
        dwErr = ERROR_DS_CANT_ON_NON_LEAF;
        break;

    case LDAP_NOT_ALLOWED_ON_RDN :
        dwErr = ERROR_DS_CANT_ON_RDN;
        break;

    case LDAP_ALREADY_EXISTS :
        dwErr = ERROR_OBJECT_ALREADY_EXISTS;
        break;

    case LDAP_NO_OBJECT_CLASS_MODS :
        dwErr = ERROR_DS_CANT_MOD_OBJ_CLASS;
        break;

    case LDAP_RESULTS_TOO_LARGE :
        dwErr = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        break;

    case LDAP_AFFECTS_MULTIPLE_DSAS :
        dwErr = ERROR_DS_AFFECTS_MULTIPLE_DSAS;
        break;

    case LDAP_OTHER :
        dwErr = ERROR_GEN_FAILURE;
        break;

    case LDAP_SERVER_DOWN :
        dwErr = ERROR_DS_SERVER_DOWN;
        break;

    case LDAP_LOCAL_ERROR :
        dwErr = ERROR_DS_LOCAL_ERROR;
        break;

    case LDAP_ENCODING_ERROR :
        dwErr = ERROR_DS_ENCODING_ERROR;
        break;

    case LDAP_DECODING_ERROR :
        dwErr = ERROR_DS_DECODING_ERROR;
        break;

    case LDAP_TIMEOUT :
        dwErr = ERROR_TIMEOUT;
        break;

    case LDAP_AUTH_UNKNOWN :
        dwErr = ERROR_DS_AUTH_UNKNOWN;
        break;

    case LDAP_FILTER_ERROR :
        dwErr = ERROR_DS_FILTER_UNKNOWN;
        break;

    case LDAP_USER_CANCELLED :
       dwErr = ERROR_CANCELLED;
       break;

    case LDAP_PARAM_ERROR :
        dwErr = ERROR_DS_PARAM_ERROR;
        break;

    case LDAP_NO_MEMORY :
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case LDAP_CONNECT_ERROR :
        dwErr = ERROR_CONNECTION_REFUSED;
        break;

    case LDAP_NOT_SUPPORTED :
        dwErr = ERROR_DS_NOT_SUPPORTED;
        break;

    case LDAP_NO_RESULTS_RETURNED :
        dwErr = ERROR_DS_NO_RESULTS_RETURNED;
        break;

    case LDAP_CONTROL_NOT_FOUND :
        dwErr = ERROR_DS_CONTROL_NOT_FOUND;
        break;

    case LDAP_MORE_RESULTS_TO_RETURN :
        dwErr = ERROR_MORE_DATA;
        break;

    case LDAP_CLIENT_LOOP :
        dwErr = ERROR_DS_CLIENT_LOOP;
        break;

    case LDAP_REFERRAL_LIMIT_EXCEEDED :
        dwErr = ERROR_DS_REFERRAL_LIMIT_EXCEEDED;
        break;

    default:
        dwErr = ERROR_DS_BUSY;

    }

    return(dwErr);
}




DWORD
LdapAddS(
    HLDAP hLdapHandle,
    WCHAR *dn,
    LDAPModW *attrs[]
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;


    ldaperr = ldap_add_s( hLdapHandle, dn, attrs );

    dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

    return(dwError);
}


DWORD
LdapModifyS(
    HLDAP hLdapHandle,
    WCHAR *dn,
    LDAPModW *mods[]
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;

    ldaperr = ldap_modify_s( hLdapHandle, dn, mods);

    dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

    return(dwError);
}


DWORD
LdapDeleteS(
    HLDAP hLdapHandle,
    WCHAR *dn
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;

    ldaperr = ldap_delete_s( hLdapHandle, dn );

    dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\memory.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include "precomp.h"

#define ADsAssert(x)    NULL

#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))

#define DWORD_ALIGN_UP(size) ((size+3)&~3)


#if DBG


DWORD dwMemLog = 0;

#define MAXDEPTH 10

typedef struct _ADSMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} ADSMEMTAG, *PADSMEMTAG ;

LIST_ENTRY       ADsMemList ;
DWORD            ADsMemCount ;
CRITICAL_SECTION ADsMemCritSect ;

/*++

Routine Description:

    This function initializes the ADs mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitPolMem(
    VOID
)
{
    InitializeCriticalSection(&ADsMemCritSect) ;
    InitializeListHead(&ADsMemList) ;
    ADsMemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertPolMemLeaks(
    VOID
)
{
    ADsAssert(IsListEmpty(&ADsMemList)) ;
}

#endif

LPVOID
AllocPolMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    return(LocalAlloc(LPTR, cb));

}

BOOL
FreePolMem(
   LPVOID pMem
)
{
    return(LocalFree(pMem) == NULL);
}

LPVOID
ReallocPolMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocPolMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreePolMem(pOldMem);
    }

    return pNewMem;
}

LPWSTR
AllocPolStr(
    LPCWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPWSTR)AllocPolMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
FreePolStr(
   LPWSTR pStr
)
{
   return pStr ? FreePolMem(pStr)
               : FALSE;
}

BOOL
ReallocPolStr(
   LPWSTR *ppStr,
   LPWSTR pStr
)
{
   FreePolStr(*ppStr);
   *ppStr=AllocPolStr(pStr);

   return TRUE;
}

DWORD
AllocatePolString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    )
{
    LPWSTR pszNewString = NULL;
    DWORD dwError = 0;

    pszNewString = AllocPolStr(pszString);

    if (!pszNewString) {
        dwError = GetLastError();
    }

    *ppszNewString = pszNewString;

    return(dwError);
}

void
FreePolString(
    LPWSTR pszString
    )
{
    if (pszString) {
        FreePolStr(pszString);
    }

    return;
}


DWORD
ReallocatePolMem(
    LPVOID * ppOldMem,
    DWORD cbOld,
    DWORD cbNew
    )
{
    DWORD dwError = 0;
    LPVOID pOldMem = NULL;
    LPVOID pNewMem = NULL;

    pOldMem = *ppOldMem;
    pNewMem = AllocPolMem(cbNew);

    if (!pNewMem) {
        dwError = ERROR_OUTOFMEMORY;
        return (dwError);
    }

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreePolMem(pOldMem);
    }

    *ppOldMem = pNewMem;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif


LPVOID
ReallocPolMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

DWORD
AllocatePolString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    );

void
FreePolString(
    LPWSTR pszString
    );


#if DBG

extern LIST_ENTRY ADsMemList ;

extern CRITICAL_SECTION ADsMemCritSect ;

VOID InitPolMem(
    VOID
    ) ;

VOID AssertPolMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitPolMem()
#define AssertPolMemLeaks()

#define DumpMemoryTracker()



#endif


#ifdef __cplusplus
}
#endif

/*
inline void * _CRTAPI1
operator new(size_t size)
{
    return AllocPolMem(size);
}

inline void  _CRTAPI1
operator delete(void * pv)
{
    FreePolMem(pv);
}*/


#endif // _MEMORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\persist.c ===
#include "precomp.h"

LPWSTR  gpszIpsecCacheKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Cache";


DWORD
CacheDirectorytoRegistry(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{

    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecRegPolicyObject = NULL;

    //
    // Delete the existing cache.
    //

    DeleteRegistryCache();


    //
    // Create a copy of the directory policy in registry terms
    //


    dwError = CloneDirectoryPolicyObject(
                    pIpsecPolicyObject,
                    &pIpsecRegPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);



    //
    // Write the registry policy
    //


    dwError = PersistRegistryObject(
                    pIpsecRegPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (pIpsecRegPolicyObject) {

        FreeIpsecPolicyObject(
            pIpsecRegPolicyObject
            );

    }

    return(dwError);

error:

    DeleteRegistryCache();

    goto cleanup;
}


DWORD
PersistRegistryObject(
    PIPSEC_POLICY_OBJECT pIpsecRegPolicyObject
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    DWORD dwDisposition = 0;

    dwError = RegCreateKeyExW(
                    HKEY_LOCAL_MACHINE,
                    gpszIpsecCacheKey,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegistryKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecRegPolicyObject->ppIpsecFilterObjects) {

        dwError = PersistFilterObjects(
                            hRegistryKey,
                            pIpsecRegPolicyObject->ppIpsecFilterObjects,
                            pIpsecRegPolicyObject->NumberofFilters
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecRegPolicyObject->ppIpsecNegPolObjects) {

        dwError = PersistNegPolObjects(
                            hRegistryKey,
                            pIpsecRegPolicyObject->ppIpsecNegPolObjects,
                            pIpsecRegPolicyObject->NumberofNegPols
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecRegPolicyObject->ppIpsecNFAObjects) {

        dwError = PersistNFAObjects(
                            hRegistryKey,
                            pIpsecRegPolicyObject->ppIpsecNFAObjects,
                            pIpsecRegPolicyObject->NumberofRulesReturned
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecRegPolicyObject->ppIpsecISAKMPObjects) {

        dwError = PersistISAKMPObjects(
                            hRegistryKey,
                            pIpsecRegPolicyObject->ppIpsecISAKMPObjects,
                            pIpsecRegPolicyObject->NumberofISAKMPs
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = PersistPolicyObject(
                        hRegistryKey,
                        pIpsecRegPolicyObject
                        );

error:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }


    return(dwError);
}



DWORD
PersistNegPolObjects(
    HKEY hRegistryKey,
    PIPSEC_NEGPOL_OBJECT *ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects
    )
{
    DWORD i = 0;
    DWORD dwError = 0;

    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError = PersistNegPolObject(
                            hRegistryKey,
                            *(ppIpsecNegPolObjects + i)
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return(dwError);

}

DWORD
PersistFilterObjects(
    HKEY hRegistryKey,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects
    )
{
    DWORD i = 0;
    DWORD dwError = 0;


    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError = PersistFilterObject(
                            hRegistryKey,
                            *(ppIpsecFilterObjects + i)
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    return(dwError);

}


DWORD
PersistNFAObjects(
    HKEY hRegistryKey,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects
    )
{
    DWORD i = 0;
    DWORD dwError = 0;

    for (i = 0; i < dwNumNFAObjects; i++) {

        dwError = PersistNFAObject(
                            hRegistryKey,
                            *(ppIpsecNFAObjects + i)
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return(dwError);

}

DWORD
PersistISAKMPObjects(
    HKEY hRegistryKey,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects
    )
{
    DWORD i = 0;
    DWORD dwError = 0;


    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError = PersistISAKMPObject(
                            hRegistryKey,
                            *(ppIpsecISAKMPObjects + i)
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    return(dwError);

}

DWORD
PersistPolicyObject(
    HKEY hRegistryKey,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwDisposition = 0;


    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecPolicyObject->pszIpsecOwnersReference,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hRegKey,
                   L"ClassName",
                   0,
                   REG_SZ,
                   (LPBYTE) L"ipsecPolicy",
                   (wcslen(L"ipsecPolicy") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecPolicyObject->pszDescription) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"description",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszDescription,
                        (wcslen(pIpsecPolicyObject->pszDescription) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {
        (VOID) RegDeleteValueW(
                   hRegKey,
                   L"description"
                   );
    }

    if (pIpsecPolicyObject->pszIpsecOwnersReference) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszIpsecOwnersReference,
                        (wcslen(pIpsecPolicyObject->pszIpsecOwnersReference) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszIpsecName,
                        (wcslen(pIpsecPolicyObject->pszIpsecName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszIpsecID,
                        (wcslen(pIpsecPolicyObject->pszIpsecID) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecPolicyObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecPolicyObject->pIpsecData) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecPolicyObject->pIpsecData,
                        pIpsecPolicyObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszIpsecISAKMPReference) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecISAKMPReference",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszIpsecISAKMPReference,
                        (wcslen(pIpsecPolicyObject->pszIpsecISAKMPReference) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->ppszIpsecNFAReferences) {


        dwError = RegWriteMultiValuedString(
                        hRegKey,
                        L"ipsecNFAReference",
                        pIpsecPolicyObject->ppszIpsecNFAReferences,
                        pIpsecPolicyObject->NumberofRules
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecPolicyObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return(dwError);
}

DWORD
PersistNFAObject(
    HKEY hRegistryKey,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{

    HKEY hRegKey = NULL;
    DWORD dwError = 0;
    DWORD dwDisposition = 0;
    LPBYTE pMem = NULL;


    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecNFAObject->pszDistinguishedName,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hRegKey,
                    L"ClassName",
                    0,
                    REG_SZ,
                    (LPBYTE) L"ipsecNFA",
                    (wcslen(L"ipsecNFA") + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNFAObject->pszDistinguishedName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszDistinguishedName,
                        (wcslen(pIpsecNFAObject->pszDistinguishedName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszIpsecName,
                        (wcslen(pIpsecNFAObject->pszIpsecName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszDescription) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"description",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszDescription,
                        (wcslen(pIpsecNFAObject->pszDescription) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {
        (VOID) RegDeleteValueW(
                   hRegKey,
                   L"description"
                   );
    }

    if (pIpsecNFAObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszIpsecID,
                        (wcslen(pIpsecNFAObject->pszIpsecID) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecNFAObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNFAObject->pIpsecData) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecNFAObject->pIpsecData,
                        pIpsecNFAObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecOwnersReference) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecOwnersReference",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszIpsecOwnersReference,
                        (wcslen(pIpsecNFAObject->pszIpsecOwnersReference) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecNegPolReference) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecNegotiationPolicyReference",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszIpsecNegPolReference,
                        (wcslen(pIpsecNFAObject->pszIpsecNegPolReference) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {

        pMem = AllocPolMem(
                   (wcslen(pIpsecNFAObject->pszIpsecFilterReference) + 1 + 1)*sizeof(WCHAR)
                   );
        if (!pMem) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memcpy(
            pMem,
            (LPBYTE) pIpsecNFAObject->pszIpsecFilterReference,
            (wcslen(pIpsecNFAObject->pszIpsecFilterReference) + 1)*sizeof(WCHAR)
            );

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecFilterReference",
                        0,
                        REG_MULTI_SZ,
                        pMem,
                        (wcslen(pIpsecNFAObject->pszIpsecFilterReference) + 1 + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

        if (pMem) {
            FreePolMem(pMem);
        }

    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecNFAObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {

        RegCloseKey(hRegKey);
    }

    return(dwError);
}


DWORD
PersistFilterObject(
    HKEY hRegistryKey,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    HKEY hRegKey = NULL;
    DWORD dwError = 0;
    DWORD dwDisposition = 0;

    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecFilterObject->pszDistinguishedName,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hRegKey,
                   L"ClassName",
                   0,
                   REG_SZ,
                   (LPBYTE) L"ipsecFilter",
                   (wcslen(L"ipsecFilter") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecFilterObject->pszDescription) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"description",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecFilterObject->pszDescription,
                        (wcslen(pIpsecFilterObject->pszDescription) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {
        (VOID) RegDeleteValueW(
                   hRegKey,
                   L"description"
                   );
    }

    if (pIpsecFilterObject->pszDistinguishedName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecFilterObject->pszDistinguishedName,
                        (wcslen(pIpsecFilterObject->pszDistinguishedName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecFilterObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecFilterObject->pszIpsecName,
                        (wcslen(pIpsecFilterObject->pszIpsecName) + 1)* sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecFilterObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecFilterObject->pszIpsecID,
                        (wcslen(pIpsecFilterObject->pszIpsecID) + 1)* sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecFilterObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecFilterObject->pIpsecData) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecFilterObject->pIpsecData,
                        pIpsecFilterObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecFilterObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecFilterObject->ppszIpsecNFAReferences) {

        dwError = RegWriteMultiValuedString(
                        hRegKey,
                        L"ipsecOwnersReference",
                        pIpsecFilterObject->ppszIpsecNFAReferences,
                        pIpsecFilterObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return(dwError);
}



DWORD
PersistNegPolObject(
    HKEY hRegistryKey,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    DWORD dwDisposition = 0;
    HKEY hRegKey = NULL;

    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecNegPolObject->pszDistinguishedName,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hRegKey,
                   L"ClassName",
                   0,
                   REG_SZ,
                   (LPBYTE) L"ipsecNegotiationPolicy",
                   (wcslen(L"ipsecNegotiationPolicy") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNegPolObject->pszDescription) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"description",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszDescription,
                        (wcslen(pIpsecNegPolObject->pszDescription) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {
        (VOID) RegDeleteValueW(
                   hRegKey,
                   L"description"
                   );
    }

    if (pIpsecNegPolObject->pszDistinguishedName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszDistinguishedName,
                        (wcslen(pIpsecNegPolObject->pszDistinguishedName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecNegPolObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszIpsecName,
                        (wcslen(pIpsecNegPolObject->pszIpsecName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszIpsecID,
                        (wcslen(pIpsecNegPolObject->pszIpsecID) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolAction) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecNegotiationPolicyAction",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszIpsecNegPolAction,
                        (wcslen(pIpsecNegPolObject->pszIpsecNegPolAction) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolType) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecNegotiationPolicyType",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszIpsecNegPolType,
                        (wcslen(pIpsecNegPolObject->pszIpsecNegPolType) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecNegPolObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNegPolObject->pIpsecData) {
        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecNegPolObject->pIpsecData,
                        pIpsecNegPolObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->ppszIpsecNFAReferences) {

        dwError = RegWriteMultiValuedString(
                        hRegKey,
                        L"ipsecOwnersReference",
                        pIpsecNegPolObject->ppszIpsecNFAReferences,
                        pIpsecNegPolObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecNegPolObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }


    return(dwError);
}

DWORD
PersistISAKMPObject(
    HKEY hRegistryKey,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    HKEY hRegKey = NULL;
    DWORD dwError = 0;
    DWORD dwDisposition = 0;

    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecISAKMPObject->pszDistinguishedName,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hRegKey,
                   L"ClassName",
                   0,
                   REG_SZ,
                   (LPBYTE) L"ipsecISAKMPPolicy",
                   (wcslen(L"ipsecISAKMPPolicy") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecISAKMPObject->pszDistinguishedName,
                        (wcslen(pIpsecISAKMPObject->pszDistinguishedName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecISAKMPObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecISAKMPObject->pszIpsecName,
                        (wcslen(pIpsecISAKMPObject->pszIpsecName) + 1)* sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecISAKMPObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecISAKMPObject->pszIpsecID,
                        (wcslen(pIpsecISAKMPObject->pszIpsecID) + 1)* sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecISAKMPObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecISAKMPObject->pIpsecData) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecISAKMPObject->pIpsecData,
                        pIpsecISAKMPObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecISAKMPObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    if (pIpsecISAKMPObject->ppszIpsecNFAReferences) {

        dwError = RegWriteMultiValuedString(
                        hRegKey,
                        L"ipsecOwnersReference",
                        pIpsecISAKMPObject->ppszIpsecNFAReferences,
                        pIpsecISAKMPObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return(dwError);
}





DWORD
CloneDirectoryPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_OBJECT * ppIpsecRegPolicyObject
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecRegPolicyObject = NULL;

    //
    // Clone Filter Objects
    //

    pIpsecRegPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_POLICY_OBJECT)
                                        );
    if (!pIpsecRegPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->ppIpsecFilterObjects) {

        dwError = CloneDirectoryFilterObjects(
                            pIpsecPolicyObject->ppIpsecFilterObjects,
                            pIpsecPolicyObject->NumberofFilters,
                            &pIpsecRegPolicyObject->ppIpsecFilterObjects
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->NumberofFilters = pIpsecPolicyObject->NumberofFilters;
    }

    //
    // Clone NegPol Objects
    //

    if (pIpsecPolicyObject->ppIpsecNegPolObjects) {

        dwError = CloneDirectoryNegPolObjects(
                            pIpsecPolicyObject->ppIpsecNegPolObjects,
                            pIpsecPolicyObject->NumberofNegPols,
                            &pIpsecRegPolicyObject->ppIpsecNegPolObjects
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->NumberofNegPols = pIpsecPolicyObject->NumberofNegPols;
    }


    //
    // Clone NFA Objects
    //

    if (pIpsecPolicyObject->ppIpsecNFAObjects) {

        dwError = CloneDirectoryNFAObjects(
                            pIpsecPolicyObject->ppIpsecNFAObjects,
                            pIpsecPolicyObject->NumberofRulesReturned,
                            &pIpsecRegPolicyObject->ppIpsecNFAObjects
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->NumberofRules = pIpsecPolicyObject->NumberofRules;
        pIpsecRegPolicyObject->NumberofRulesReturned = pIpsecPolicyObject->NumberofRulesReturned;
    }

    //
    // Clone ISAKMP Objects
    //

    if (pIpsecPolicyObject->ppIpsecISAKMPObjects) {

        dwError = CloneDirectoryISAKMPObjects(
                            pIpsecPolicyObject->ppIpsecISAKMPObjects,
                            pIpsecPolicyObject->NumberofISAKMPs,
                            &pIpsecRegPolicyObject->ppIpsecISAKMPObjects
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->NumberofISAKMPs = pIpsecPolicyObject->NumberofISAKMPs;
    }

    //
    // Now copy the rest of the data in the object
    //

    if (pIpsecPolicyObject->pszIpsecOwnersReference) {

        dwError = CopyPolicyDSToRegString(
                        pIpsecPolicyObject->pszIpsecOwnersReference,
                        &pIpsecRegPolicyObject->pszIpsecOwnersReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszIpsecName) {

        pIpsecRegPolicyObject->pszIpsecName = AllocPolStr(
                                            pIpsecPolicyObject->pszIpsecName
                                            );
        if (!pIpsecRegPolicyObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyObject->pszIpsecID) {

        pIpsecRegPolicyObject->pszIpsecID = AllocPolStr(
                                            pIpsecPolicyObject->pszIpsecID
                                            );
        if (!pIpsecRegPolicyObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyObject->pszIpsecISAKMPReference) {

        dwError = CopyISAKMPDSToFQRegString(
                        pIpsecPolicyObject->pszIpsecISAKMPReference,
                        &pIpsecRegPolicyObject->pszIpsecISAKMPReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegPolicyObject->dwIpsecDataType = pIpsecPolicyObject->dwIpsecDataType;

    if (pIpsecPolicyObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecPolicyObject->pIpsecData,
                            pIpsecPolicyObject->dwIpsecDataLen,
                            &pIpsecRegPolicyObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->dwIpsecDataLen = pIpsecPolicyObject->dwIpsecDataLen;
    }



    if (pIpsecPolicyObject->ppszIpsecNFAReferences) {

        dwError = CloneNFAReferencesDSToRegistry(
                        pIpsecPolicyObject->ppszIpsecNFAReferences,
                        pIpsecPolicyObject->NumberofRules,
                        &(pIpsecRegPolicyObject->ppszIpsecNFAReferences),
                        &(pIpsecRegPolicyObject->NumberofRules)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszDescription) {

        pIpsecRegPolicyObject->pszDescription = AllocPolStr(
                                                pIpsecPolicyObject->pszDescription
                                                );
        if (!pIpsecRegPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pIpsecRegPolicyObject->dwWhenChanged = pIpsecPolicyObject->dwWhenChanged;

    *ppIpsecRegPolicyObject = pIpsecRegPolicyObject;

    return(dwError);

error:

    if (pIpsecRegPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecRegPolicyObject
                );

    }

    *ppIpsecRegPolicyObject = NULL;

    return(dwError);
}



DWORD
CloneDirectoryNFAObjects(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecRegNFAObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT * ppIpsecRegNFAObjects = NULL;
    PIPSEC_NFA_OBJECT pIpsecRegNFAObject = NULL;

    if (dwNumNFAObjects) {
        ppIpsecRegNFAObjects = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                        dwNumNFAObjects*sizeof(PIPSEC_NFA_OBJECT)
                                        );
        if (!ppIpsecRegNFAObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNFAObjects; i++) {

        dwError = CloneDirectoryNFAObject(
                            *(ppIpsecNFAObjects + i),
                            &pIpsecRegNFAObject
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        *(ppIpsecRegNFAObjects + i) = pIpsecRegNFAObject;
    }


    *pppIpsecRegNFAObjects = ppIpsecRegNFAObjects;
    return(dwError);

error:

    if (ppIpsecRegNFAObjects) {
        FreeIpsecNFAObjects(
                ppIpsecRegNFAObjects,
                i
                );
    }

    *pppIpsecRegNFAObjects = NULL;
    return(dwError);
}


DWORD
CloneDirectoryFilterObjects(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecRegFilterObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_FILTER_OBJECT * ppIpsecRegFilterObjects = NULL;
    PIPSEC_FILTER_OBJECT pIpsecRegFilterObject = NULL;


    if (dwNumFilterObjects) {
        ppIpsecRegFilterObjects = (PIPSEC_FILTER_OBJECT *)AllocPolMem(
                                        dwNumFilterObjects*sizeof(PIPSEC_FILTER_OBJECT)
                                        );
       if (!ppIpsecRegFilterObjects) {
           dwError = ERROR_OUTOFMEMORY;
           BAIL_ON_WIN32_ERROR(dwError);
       }
    }

    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError = CloneDirectoryFilterObject(
                            *(ppIpsecFilterObjects + i),
                            &pIpsecRegFilterObject
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        *(ppIpsecRegFilterObjects + i) = pIpsecRegFilterObject;
    }


    *pppIpsecRegFilterObjects = ppIpsecRegFilterObjects;
    return(dwError);

error:

    if (ppIpsecRegFilterObjects) {
        FreeIpsecFilterObjects(
                ppIpsecRegFilterObjects,
                i
                );
    }

    *pppIpsecRegFilterObjects = NULL;
    return(dwError);
}

DWORD
CloneDirectoryISAKMPObjects(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecRegISAKMPObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_OBJECT * ppIpsecRegISAKMPObjects = NULL;
    PIPSEC_ISAKMP_OBJECT pIpsecRegISAKMPObject = NULL;

    if (dwNumISAKMPObjects) {
        ppIpsecRegISAKMPObjects = (PIPSEC_ISAKMP_OBJECT *)AllocPolMem(
                                        dwNumISAKMPObjects*sizeof(PIPSEC_ISAKMP_OBJECT)
                                        );
        if (!ppIpsecRegISAKMPObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError = CloneDirectoryISAKMPObject(
                            *(ppIpsecISAKMPObjects + i),
                            &pIpsecRegISAKMPObject
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        *(ppIpsecRegISAKMPObjects + i) = pIpsecRegISAKMPObject;
    }


    *pppIpsecRegISAKMPObjects = ppIpsecRegISAKMPObjects;
    return(dwError);

error:

    if (ppIpsecRegISAKMPObjects) {
        FreeIpsecISAKMPObjects(
                ppIpsecRegISAKMPObjects,
                i
                );
    }

    *pppIpsecRegISAKMPObjects = NULL;
    return(dwError);
}


DWORD
CloneDirectoryNegPolObjects(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecRegNegPolObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NEGPOL_OBJECT * ppIpsecRegNegPolObjects = NULL;
    PIPSEC_NEGPOL_OBJECT pIpsecRegNegPolObject = NULL;

    if (dwNumNegPolObjects) {
        ppIpsecRegNegPolObjects = (PIPSEC_NEGPOL_OBJECT *)AllocPolMem(
                                        dwNumNegPolObjects*sizeof(PIPSEC_NEGPOL_OBJECT)
                                        );
        if (!ppIpsecRegNegPolObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError = CloneDirectoryNegPolObject(
                            *(ppIpsecNegPolObjects + i),
                            &pIpsecRegNegPolObject
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        *(ppIpsecRegNegPolObjects + i) = pIpsecRegNegPolObject;
    }


    *pppIpsecRegNegPolObjects = ppIpsecRegNegPolObjects;
    return(dwError);

error:

    if (ppIpsecRegNegPolObjects) {
        FreeIpsecNegPolObjects(
                ppIpsecRegNegPolObjects,
                i
                );
    }

    *pppIpsecRegNegPolObjects = NULL;
    return(dwError);
}


DWORD
CloneDirectoryFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_OBJECT * ppIpsecRegFilterObject
    )
{

    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecRegFilterObject = NULL;

    pIpsecRegFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_FILTER_OBJECT)
                                        );
    if (!pIpsecRegFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecFilterObject->pszDistinguishedName) {
        dwError = CopyFilterDSToRegString(
                        pIpsecFilterObject->pszDistinguishedName,
                        &pIpsecRegFilterObject->pszDistinguishedName
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecFilterObject->pszDescription) {
        pIpsecRegFilterObject->pszDescription = AllocPolStr(
                                            pIpsecFilterObject->pszDescription
                                            );
        if (!pIpsecRegFilterObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterObject->pszIpsecName) {
        pIpsecRegFilterObject->pszIpsecName = AllocPolStr(
                                            pIpsecFilterObject->pszIpsecName
                                            );
        if (!pIpsecRegFilterObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterObject->pszIpsecID) {
        pIpsecRegFilterObject->pszIpsecID = AllocPolStr(
                                            pIpsecFilterObject->pszIpsecID
                                            );
        if (!pIpsecRegFilterObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pIpsecRegFilterObject->dwIpsecDataType = pIpsecFilterObject->dwIpsecDataType;

    if (pIpsecFilterObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecFilterObject->pIpsecData,
                            pIpsecFilterObject->dwIpsecDataLen,
                            &pIpsecRegFilterObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        pIpsecRegFilterObject->dwIpsecDataLen = pIpsecFilterObject->dwIpsecDataLen;
    }


    if (pIpsecFilterObject->ppszIpsecNFAReferences) {

        dwError = CloneNFAReferencesDSToRegistry(
                        pIpsecFilterObject->ppszIpsecNFAReferences,
                        pIpsecFilterObject->dwNFACount,
                        &pIpsecRegFilterObject->ppszIpsecNFAReferences,
                        &pIpsecRegFilterObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    pIpsecRegFilterObject->dwWhenChanged = pIpsecFilterObject->dwWhenChanged;

    *ppIpsecRegFilterObject = pIpsecRegFilterObject;

    return(dwError);

error:

    if (pIpsecRegFilterObject) {
        FreeIpsecFilterObject(pIpsecRegFilterObject);
    }

    *ppIpsecRegFilterObject = NULL;

    return(dwError);
}


DWORD
CloneDirectoryNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecRegNegPolObject
    )
{
    DWORD dwError = 0;

    PIPSEC_NEGPOL_OBJECT pIpsecRegNegPolObject = NULL;

    pIpsecRegNegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_NEGPOL_OBJECT)
                                        );
    if (!pIpsecRegNegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszDistinguishedName) {

        dwError = CopyNegPolDSToRegString(
                        pIpsecNegPolObject->pszDistinguishedName,
                        &pIpsecRegNegPolObject->pszDistinguishedName
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszIpsecName) {
        pIpsecRegNegPolObject->pszIpsecName = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecName
                                            );
        if (!pIpsecRegNegPolObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolObject->pszDescription) {
        pIpsecRegNegPolObject->pszDescription = AllocPolStr(
                                            pIpsecNegPolObject->pszDescription
                                            );
        if (!pIpsecRegNegPolObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolObject->pszIpsecID) {
        pIpsecRegNegPolObject->pszIpsecID = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecID
                                            );
        if (!pIpsecRegNegPolObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pIpsecRegNegPolObject->dwIpsecDataType = pIpsecNegPolObject->dwIpsecDataType;

    if (pIpsecNegPolObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecNegPolObject->pIpsecData,
                            pIpsecNegPolObject->dwIpsecDataLen,
                            &pIpsecRegNegPolObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegNegPolObject->dwIpsecDataLen = pIpsecNegPolObject->dwIpsecDataLen;
    }

    if (pIpsecNegPolObject->pszIpsecNegPolAction) {

        pIpsecRegNegPolObject->pszIpsecNegPolAction = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecNegPolAction
                                            );
        if (!pIpsecRegNegPolObject->pszIpsecNegPolAction) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolObject->pszIpsecNegPolType) {

        pIpsecRegNegPolObject->pszIpsecNegPolType = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecNegPolType
                                            );
        if (!pIpsecRegNegPolObject->pszIpsecNegPolType) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }


    if (pIpsecNegPolObject->ppszIpsecNFAReferences) {

        dwError = CloneNFAReferencesDSToRegistry(
                        pIpsecNegPolObject->ppszIpsecNFAReferences,
                        pIpsecNegPolObject->dwNFACount,
                        &pIpsecRegNegPolObject->ppszIpsecNFAReferences,
                        &pIpsecRegNegPolObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegNegPolObject->dwWhenChanged = pIpsecNegPolObject->dwWhenChanged;

    *ppIpsecRegNegPolObject = pIpsecRegNegPolObject;

    return(dwError);

error:

    if (pIpsecRegNegPolObject) {
        FreeIpsecNegPolObject(pIpsecRegNegPolObject);
    }

    *ppIpsecRegNegPolObject = NULL;

    return(dwError);
}

DWORD
CloneDirectoryNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_OBJECT * ppIpsecRegNFAObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecRegNFAObject = NULL;


    pIpsecRegNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_NFA_OBJECT)
                                        );
    if (!pIpsecRegNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecNFAObject->pszDistinguishedName) {

        dwError = CopyNFADSToRegString(
                        pIpsecNFAObject->pszDistinguishedName,
                        &pIpsecRegNFAObject->pszDistinguishedName
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecNFAObject->pszIpsecName) {

        pIpsecRegNFAObject->pszIpsecName = AllocPolStr(
                                            pIpsecNFAObject->pszIpsecName
                                            );
        if (!pIpsecRegNFAObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAObject->pszDescription) {

        pIpsecRegNFAObject->pszDescription = AllocPolStr(
                                            pIpsecNFAObject->pszDescription
                                            );
        if (!pIpsecRegNFAObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAObject->pszIpsecID) {

        pIpsecRegNFAObject->pszIpsecID = AllocPolStr(
                                            pIpsecNFAObject->pszIpsecID
                                            );
        if (!pIpsecRegNFAObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }


    pIpsecRegNFAObject->dwIpsecDataType = pIpsecNFAObject->dwIpsecDataType;

    if (pIpsecNFAObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecNFAObject->pIpsecData,
                            pIpsecNFAObject->dwIpsecDataLen,
                            &pIpsecRegNFAObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegNFAObject->dwIpsecDataLen = pIpsecNFAObject->dwIpsecDataLen;
    }


    if (pIpsecNFAObject->pszIpsecOwnersReference) {

        dwError = CopyPolicyDSToFQRegString(
                        pIpsecNFAObject->pszIpsecOwnersReference,
                        &pIpsecRegNFAObject->pszIpsecOwnersReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {

        dwError = CopyFilterDSToFQRegString(
                        pIpsecNFAObject->pszIpsecFilterReference,
                        &pIpsecRegNFAObject->pszIpsecFilterReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecNegPolReference) {

        dwError = CopyNegPolDSToFQRegString(
                        pIpsecNFAObject->pszIpsecNegPolReference,
                        &pIpsecRegNFAObject->pszIpsecNegPolReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegNFAObject->dwWhenChanged = pIpsecNFAObject->dwWhenChanged;


    *ppIpsecRegNFAObject = pIpsecRegNFAObject;

    return(dwError);

error:

    if (pIpsecRegNFAObject) {
        FreeIpsecNFAObject(pIpsecRegNFAObject);
    }

    *ppIpsecRegNFAObject = NULL;

    return(dwError);
}

DWORD
CloneDirectoryISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_OBJECT * ppIpsecRegISAKMPObject
    )
{

    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecRegISAKMPObject = NULL;

    pIpsecRegISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_ISAKMP_OBJECT)
                                        );
    if (!pIpsecRegISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecISAKMPObject->pszDistinguishedName) {

        dwError = CopyISAKMPDSToRegString(
                        pIpsecISAKMPObject->pszDistinguishedName,
                        &pIpsecRegISAKMPObject->pszDistinguishedName
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecISAKMPObject->pszIpsecName) {

        pIpsecRegISAKMPObject->pszIpsecName = AllocPolStr(
                                            pIpsecISAKMPObject->pszIpsecName
                                            );
        if (!pIpsecRegISAKMPObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }


    if (pIpsecISAKMPObject->pszIpsecID) {

        pIpsecRegISAKMPObject->pszIpsecID = AllocPolStr(
                                            pIpsecISAKMPObject->pszIpsecID
                                            );
        if (!pIpsecRegISAKMPObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pIpsecRegISAKMPObject->dwIpsecDataType = pIpsecISAKMPObject->dwIpsecDataType;


    if (pIpsecISAKMPObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecISAKMPObject->pIpsecData,
                            pIpsecISAKMPObject->dwIpsecDataLen,
                            &pIpsecRegISAKMPObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegISAKMPObject->dwIpsecDataLen = pIpsecISAKMPObject->dwIpsecDataLen;


    if (pIpsecISAKMPObject->ppszIpsecNFAReferences) {

        dwError = CloneNFAReferencesDSToRegistry(
                        pIpsecISAKMPObject->ppszIpsecNFAReferences,
                        pIpsecISAKMPObject->dwNFACount,
                        &pIpsecRegISAKMPObject->ppszIpsecNFAReferences,
                        &pIpsecRegISAKMPObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegISAKMPObject->dwWhenChanged = pIpsecISAKMPObject->dwWhenChanged;

    *ppIpsecRegISAKMPObject = pIpsecRegISAKMPObject;

    return(dwError);

error:

    if (pIpsecRegISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecRegISAKMPObject);
    }

    *ppIpsecRegISAKMPObject = NULL;

    return(dwError);
}


DWORD
CopyBinaryValue(
    LPBYTE pMem,
    DWORD dwMemSize,
    LPBYTE * ppNewMem
    )
{
    LPBYTE pNewMem = NULL;
    DWORD dwError = 0;


    pNewMem = (LPBYTE)AllocPolMem(dwMemSize);
    if (!pNewMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(pNewMem, pMem, dwMemSize);


    *ppNewMem = pNewMem;

    return(dwError);

error:

    if (pNewMem) {

        FreePolMem(pNewMem);
    }

    *ppNewMem = NULL;

    return(dwError);
}


DWORD
CopyFilterDSToFQRegString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszFilterName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszFilterDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszFilterName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszFilterName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszFilterName, gpszIpsecCacheKey);
    wcscat(pszFilterName, L"\\");
    wcscat(pszFilterName, pszGuidName);

    *ppszFilterName = pszFilterName;

    return(dwError);

error:

    *ppszFilterName = NULL;
    return(dwError);

}


DWORD
CopyNFADSToFQRegString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNFAName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszNFADN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszNFAName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszNFAName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszNFAName, gpszIpsecCacheKey);
    wcscat(pszNFAName, L"\\");
    wcscat(pszNFAName, pszGuidName);


    *ppszNFAName = pszNFAName;

    return(dwError);

error:

    *ppszNFAName = NULL;
    return(dwError);

}



DWORD
CopyNegPolDSToFQRegString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNegPolName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszNegPolDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszNegPolName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszNegPolName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszNegPolName, gpszIpsecCacheKey);
    wcscat(pszNegPolName, L"\\");
    wcscat(pszNegPolName, pszGuidName);

    *ppszNegPolName = pszNegPolName;

    return(dwError);

error:

    *ppszNegPolName = NULL;
    return(dwError);

}


DWORD
CopyPolicyDSToFQRegString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszPolicyDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszPolicyName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszPolicyName, gpszIpsecCacheKey);
    wcscat(pszPolicyName, L"\\");
    wcscat(pszPolicyName, pszGuidName);

    *ppszPolicyName = pszPolicyName;

    return(dwError);

error:

    *ppszPolicyName = NULL;
    return(dwError);

}

DWORD
CopyISAKMPDSToFQRegString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszISAKMPName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszISAKMPDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszISAKMPName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszISAKMPName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszISAKMPName, gpszIpsecCacheKey);
    wcscat(pszISAKMPName, L"\\");
    wcscat(pszISAKMPName, pszGuidName);


    *ppszISAKMPName = pszISAKMPName;

    return(dwError);

error:

    *ppszISAKMPName = NULL;
    return(dwError);

}


DWORD
ComputeGUIDName(
    LPWSTR szCommonName,
    LPWSTR * ppszGuidName
    )
{
    LPWSTR pszGuidName = NULL;
    DWORD dwError = 0;

    pszGuidName = wcschr(szCommonName, L'=');
    if (!pszGuidName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszGuidName = (pszGuidName + 1);

    return(dwError);

error:

    *ppszGuidName = NULL;

    return(dwError);
}



DWORD
CloneNFAReferencesDSToRegistry(
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNFACount,
    LPWSTR * * pppszIpsecRegNFAReferences,
    PDWORD pdwRegNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecRegNFAReferences = NULL;

    ppszIpsecRegNFAReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwNFACount
                                        );
    if (!ppszIpsecRegNFAReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNFACount; i++) {


        dwError = CopyNFADSToFQRegString(
                        *(ppszIpsecNFAReferences + i),
                        (ppszIpsecRegNFAReferences + i)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    *pppszIpsecRegNFAReferences = ppszIpsecRegNFAReferences;
    *pdwRegNFACount = dwNFACount;

    return(dwError);

error:

    if (ppszIpsecRegNFAReferences) {
        FreeNFAReferences(
                    ppszIpsecRegNFAReferences,
                    i
                    );

    }

    *pppszIpsecRegNFAReferences = NULL;
    *pdwRegNFACount = 0;

    return(dwError);

}

DWORD
DeleteRegistryCache(
    )
{
    DWORD dwError = 0;
    HKEY hParentKey = NULL;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize = 0;

    dwError = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    gpszIpsecCacheKey,
                    0,
                    KEY_ALL_ACCESS,
                    &hParentKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
    dwSize =  MAX_PATH;

    while((RegEnumKeyExW(hParentKey, 0, lpszName,
                    &dwSize, NULL,
                    NULL, NULL,NULL)) == ERROR_SUCCESS) {

        dwError = RegDeleteKeyW(
                        hParentKey,
                        lpszName
                        );
        if (dwError != ERROR_SUCCESS) {
            break;
        }


        memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
        dwSize =  MAX_PATH;
    }

error:

    if (hParentKey) {
        RegCloseKey(hParentKey);
    }

    return(dwError);
}


DWORD
RegWriteMultiValuedString(
    HKEY hRegKey,
    LPWSTR pszValueName,
    LPWSTR * ppszStringReferences,
    DWORD dwNumStringReferences
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    LPWSTR pMem = NULL;
    LPWSTR pszTemp = NULL;
    DWORD  dwSize = 0;

    if (!ppszStringReferences) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);

    }

    for (i = 0; i < dwNumStringReferences; i++) {

        dwSize += wcslen (*(ppszStringReferences + i));
        dwSize ++;
    }

    dwSize ++;

    pMem = (LPWSTR) AllocPolMem(dwSize*sizeof(WCHAR));

    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pMem;

    for (i = 0; i < dwNumStringReferences; i++) {

        memcpy(pszTemp, *(ppszStringReferences + i), wcslen(*(ppszStringReferences + i))*sizeof(WCHAR));
        pszTemp += wcslen(pszTemp) + 1;

    }

    //*pszTemp = L'\0';

    dwError = RegSetValueExW(
                    hRegKey,
                    pszValueName,
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pMem,
                    dwSize * sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);


error:

    if (pMem) {
        FreePolMem(pMem);
    }

    return(dwError);
}


DWORD
CopyFilterDSToRegString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszFilterName = NULL;

    dwError = ComputePrelimCN(
                    pszFilterDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszFilterName = AllocPolStr(pszGuidName);
    if (!pszFilterName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszFilterName = pszFilterName;

    return(dwError);

error:

    *ppszFilterName = NULL;
    return(dwError);

}


DWORD
CopyNFADSToRegString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNFAName = NULL;

    dwError = ComputePrelimCN(
                    pszNFADN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszNFAName = AllocPolStr(pszGuidName);
    if (!pszNFAName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszNFAName = pszNFAName;

    return(dwError);

error:

    *ppszNFAName = NULL;
    return(dwError);

}



DWORD
CopyNegPolDSToRegString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNegPolName = NULL;

    dwError = ComputePrelimCN(
                    pszNegPolDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszNegPolName = AllocPolStr(pszGuidName);
    if (!pszNegPolName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszNegPolName = pszNegPolName;

    return(dwError);

error:

    *ppszNegPolName = NULL;
    return(dwError);

}


DWORD
CopyPolicyDSToRegString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;

    dwError = ComputePrelimCN(
                    pszPolicyDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszPolicyName = AllocPolStr(pszGuidName);
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszPolicyName = pszPolicyName;

    return(dwError);

error:

    *ppszPolicyName = NULL;
    return(dwError);

}

DWORD
CopyISAKMPDSToRegString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszISAKMPName = NULL;

    dwError = ComputePrelimCN(
                    pszISAKMPDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszISAKMPName = AllocPolStr(pszGuidName);
    if (!pszISAKMPName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszISAKMPName = pszISAKMPName;

    return(dwError);

error:

    *ppszISAKMPName = NULL;
    return(dwError);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\persist.h ===
DWORD
CacheDirectorytoRegistry(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
PersistRegistryObject(
    PIPSEC_POLICY_OBJECT pIpsecRegPolicyObject
    );

DWORD
PersistNegPolObjects(
    HKEY hRegistryKey,
    PIPSEC_NEGPOL_OBJECT *ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects
    );


DWORD
PersistFilterObjects(
    HKEY hRegistryKey,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects
    );


DWORD
PersistNFAObjects(
    HKEY hRegistryKey,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects
    );

DWORD
PersistISAKMPObjects(
    HKEY hRegistryKey,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects
    );


DWORD
PersistPolicyObject(
    HKEY hRegistryKey,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
PersistNFAObject(
    HKEY hRegistryKey,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
PersistFilterObject(
    HKEY hRegistryKey,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
PersistNegPolObject(
    HKEY hRegistryKey,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
PersistISAKMPObject(
    HKEY hRegistryKey,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );



DWORD
CloneDirectoryPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_OBJECT * ppIpsecRegPolicyObject
    );

DWORD
CloneDirectoryNFAObjects(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecRegNFAObjects
    );


DWORD
CloneDirectoryFilterObjects(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecRegFilterObjects
    );


DWORD
CloneDirectoryNegPolObjects(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecRegNegPolObjects
    );

DWORD
CloneDirectoryISAKMPObjects(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecRegISAKMPObjects
    );

DWORD
CloneDirectoryFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_OBJECT * ppIpsecRegFilterObject
    );

DWORD
CloneDirectoryNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecRegNegPolObject
    );

DWORD
CloneDirectoryNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_OBJECT * ppIpsecRegNFAObject
    );

DWORD
CloneDirectoryISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_OBJECT * ppIpsecRegISAKMPObject
    );

DWORD
DeleteRegistryCache();

DWORD
CopyBinaryValue(
    LPBYTE pMem,
    DWORD dwMemSize,
    LPBYTE * ppNewMem
    );

DWORD
CopyFilterDSToRegString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    );

DWORD
CopyNFADSToRegString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    );

DWORD
CopyNegPolDSToRegString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    );

DWORD
CopyPolicyDSToRegString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    );

DWORD
CopyISAKMPDSToRegString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    );

DWORD
ComputeGUIDName(
    LPWSTR szCommonName,
    LPWSTR * ppszGuidName
    );

DWORD
CloneNFAReferencesDSToRegistry(
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNFACount,
    LPWSTR * * pppszIpsecRegNFAReferences,
    PDWORD pdwRegNFACount
    );

DWORD
RegWriteMultiValuedString(
    HKEY hRegKey,
    LPWSTR pszValueName,
    LPWSTR * ppszStringReferences,
    DWORD dwNumStringReferences
    );

DWORD
CopyFilterDSToFQRegString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    );

DWORD
CopyNFADSToFQRegString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    );

DWORD
CopyNegPolDSToFQRegString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    );

DWORD
CopyPolicyDSToFQRegString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    );

DWORD
CopyISAKMPDSToFQRegString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\ldaputil.h ===
typedef LDAP * PLDAP;

typedef PLDAP HLDAP;

DWORD
LdapOpen(
    WCHAR *domainName,
    int portno,
    HLDAP * phLdapHandle
    );


DWORD
LdapBind(
    HLDAP hLdapHandle
    );

DWORD
LdapSearchHelper(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
    );

DWORD
LdapSearchS(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    LDAPMessage **res
    );

DWORD
LdapSearchST(
    HLDAP hLdapHandle,
    WCHAR *base,
    int   scope,
    WCHAR *filter,
    WCHAR *attrs[],
    int   attrsonly,
    struct l_timeval *timeout,
    LDAPMessage **res
    );

DWORD
CheckAndSetExtendedError(
    HLDAP hLdapHandle,
    int ldaperr
    );


DWORD
LdapFirstEntry(
    HLDAP hLdapHandle,
    LDAPMessage *res,
    LDAPMessage **pfirst
    );

DWORD
LdapGetValues(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR *attr,
    WCHAR ***pvalues,
    int   *pcount
    );

DWORD
LdapGetValuesLen(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    WCHAR *attr,
    struct berval ***pvalues,
    int   *pcount
    );

DWORD
LdapNextEntry(
    HLDAP hLdapHandle,
    LDAPMessage *entry,
    LDAPMessage **pnext
    );

int
LdapCountEntries(
    HLDAP hLdapHandle,
    LDAPMessage *res
    );

void
LdapMsgFree(
    LDAPMessage *res
);

void LdapValueFree(
    WCHAR **vals
);

void LdapValueFreeLen(
    struct berval **vals
);

DWORD
LdapAddS(
    HLDAP hLdapHandle,
    WCHAR *dn,
    LDAPModW *attrs[]
    );

DWORD
LdapModifyS(
    HLDAP hLdapHandle,
    WCHAR *dn,
    LDAPModW *mods[]
    );

DWORD
LdapDeleteS(
    HLDAP hLdapHandle,
    WCHAR *dn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <wchar.h>
#include <dsgetdc.h>
#include <lm.h>

#define UNICODE

#include <winldap.h>
#include <ipsec.h>
#include <oakdefs.h>
#include <polstructs.h>

#include "ldaputil.h"

#include "memory.h"
#include "structs.h"
#include "dsstore.h"
#include "regstore.h"
#include "persist.h"
#include "procrule.h"
#include "utils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\regstore.c ===
#include "precomp.h"

LPWSTR gpszIpsecRegContainer = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local";


DWORD
OpenRegistryIPSECRootKey(
    LPWSTR pszServerName,
    LPWSTR pszIpsecRegRootContainer,
    HKEY * phRegistryKey
    )
{
    DWORD dwError = 0;

    dwError = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    (LPCWSTR) pszIpsecRegRootContainer,
                    0,
                    KEY_ALL_ACCESS,
                    phRegistryKey
                    );

    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
ReadPolicyObjectFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszPolicyDN,
    LPWSTR pszIpsecRegRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{

    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;

    DWORD dwNumNFAObjectsReturned = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    LPWSTR * ppszFilterReferences = NULL;
    DWORD dwNumFilterReferences = 0;
    LPWSTR * ppszNegPolReferences = NULL;
    DWORD dwNumNegPolReferences = 0;

    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    DWORD dwNumFilterObjects = 0;

    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    DWORD dwNumNegPolObjects = 0;

    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    DWORD dwNumISAKMPObjects = 0;


    dwError = UnMarshallRegistryPolicyObject(
                    hRegistryKey,
                    pszIpsecRegRootContainer,
                    pszPolicyDN,
                    REG_FULLY_QUALIFIED_NAME,
                    &pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadNFAObjectsFromRegistry(
                        hRegistryKey,
                        pszIpsecRegRootContainer,
                        pIpsecPolicyObject->pszIpsecOwnersReference,
                        pIpsecPolicyObject->ppszIpsecNFAReferences,
                        pIpsecPolicyObject->NumberofRules,
                        &ppIpsecNFAObjects,
                        &dwNumNFAObjectsReturned,
                        &ppszFilterReferences,
                        &dwNumFilterReferences,
                        &ppszNegPolReferences,
                        &dwNumNegPolReferences
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadFilterObjectsFromRegistry(
                        hRegistryKey,
                        pszIpsecRegRootContainer,
                        ppszFilterReferences,
                        dwNumFilterReferences,
                        &ppIpsecFilterObjects,
                        &dwNumFilterObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadNegPolObjectsFromRegistry(
                        hRegistryKey,
                        pszIpsecRegRootContainer,
                        ppszNegPolReferences,
                        dwNumNegPolReferences,
                        &ppIpsecNegPolObjects,
                        &dwNumNegPolObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadISAKMPObjectsFromRegistry(
                        hRegistryKey,
                        pszIpsecRegRootContainer,
                        &pIpsecPolicyObject->pszIpsecISAKMPReference,
                        1,
                        &ppIpsecISAKMPObjects,
                        &dwNumISAKMPObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecPolicyObject->ppIpsecNFAObjects = ppIpsecNFAObjects;
    pIpsecPolicyObject->NumberofRulesReturned = dwNumNFAObjectsReturned;
    pIpsecPolicyObject->NumberofFilters = dwNumFilterObjects;
    pIpsecPolicyObject->ppIpsecFilterObjects = ppIpsecFilterObjects;
    pIpsecPolicyObject->ppIpsecNegPolObjects = ppIpsecNegPolObjects;
    pIpsecPolicyObject->NumberofNegPols = dwNumNegPolObjects;
    pIpsecPolicyObject->NumberofISAKMPs = dwNumISAKMPObjects;
    pIpsecPolicyObject->ppIpsecISAKMPObjects = ppIpsecISAKMPObjects;


    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (ppszFilterReferences) {

        FreeFilterReferences(
                ppszFilterReferences,
                dwNumFilterReferences
                );
    }

    if (ppszNegPolReferences) {

        FreeNegPolReferences(
                ppszNegPolReferences,
                dwNumNegPolReferences
                );
    }


    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    *ppIpsecPolicyObject = NULL;


    goto cleanup;

}

DWORD
ReadNFAObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecOwnerReference,
    LPWSTR * ppszNFADNs,
    DWORD dwNumNfaObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNfaObjects,
    LPWSTR ** pppszFilterReferences,
    PDWORD pdwNumFilterReferences,
    LPWSTR ** pppszNegPolReferences,
    PDWORD pdwNumNegPolReferences
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    LPWSTR * ppszFilterReferences = NULL;
    LPWSTR * ppszNegPolReferences = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;
    DWORD dwNumFilterReferences = 0;
    DWORD dwNumNegPolReferences = 0;


    DWORD dwNumNFAObjectsReturned = 0;

    *pppszNegPolReferences = NULL;
    *pdwNumFilterReferences = 0;
    *pppszFilterReferences = NULL;
    *pdwNumNegPolReferences = 0;
    *pppIpsecNFAObjects = NULL;
    *pdwNumNfaObjects = 0;

    ppIpsecNFAObjects  = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NFA_OBJECT)*dwNumNfaObjects
                                            );
    if (!ppIpsecNFAObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    ppszFilterReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwNumNfaObjects
                                        );
    if (!ppszFilterReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszNegPolReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwNumNfaObjects
                                        );
    if (!ppszNegPolReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwNumNfaObjects; i++) {


        dwError =UnMarshallRegistryNFAObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    *(ppszNFADNs + i),
                    &pIpsecNFAObject,
                    &pszFilterReference,
                    &pszNegPolReference
                    );

        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNFAObjects + dwNumNFAObjectsReturned) = pIpsecNFAObject;

            if (pszFilterReference) {

                *(ppszFilterReferences + dwNumFilterReferences) = pszFilterReference;
                dwNumFilterReferences++;

            }

            if (pszNegPolReference) {

                *(ppszNegPolReferences + dwNumNegPolReferences) = pszNegPolReference;
                dwNumNegPolReferences++;
            }

            dwNumNFAObjectsReturned++;

        }

    }

    if (dwNumNFAObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppszFilterReferences = ppszFilterReferences;
    *pppszNegPolReferences = ppszNegPolReferences;

    *pppIpsecNFAObjects = ppIpsecNFAObjects;
    *pdwNumNfaObjects = dwNumNFAObjectsReturned;
    *pdwNumNegPolReferences = dwNumNegPolReferences;
    *pdwNumFilterReferences = dwNumFilterReferences;




    dwError = ERROR_SUCCESS;

cleanup:

    return(dwError);

error:

    if (ppszNegPolReferences) {
        FreeNegPolReferences(
                ppszNegPolReferences,
                dwNumNFAObjectsReturned
                );
    }


    if (ppszFilterReferences) {
        FreeFilterReferences(
                ppszFilterReferences,
                dwNumNFAObjectsReturned
                );
    }

    if (ppIpsecNFAObjects) {

        FreeIpsecNFAObjects(
                ppIpsecNFAObjects,
                dwNumNFAObjectsReturned
                );

    }

    *pppszNegPolReferences = NULL;
    *pppszFilterReferences = NULL;
    *pppIpsecNFAObjects = NULL;
    *pdwNumNfaObjects = 0;
    *pdwNumNegPolReferences = 0;
    *pdwNumFilterReferences = 0;

    goto cleanup;
}


DWORD
ReadFilterObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;

    DWORD dwNumFilterObjectsReturned = 0;


    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;

    ppIpsecFilterObjects  = (PIPSEC_FILTER_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_FILTER_OBJECT)*dwNumFilterObjects
                                            );
    if (!ppIpsecFilterObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError =UnMarshallRegistryFilterObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    *(ppszFilterDNs + i),
                    REG_FULLY_QUALIFIED_NAME,
                    &pIpsecFilterObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecFilterObjects + dwNumFilterObjectsReturned) = pIpsecFilterObject;
            dwNumFilterObjectsReturned++;

        }


    }

    *pppIpsecFilterObjects = ppIpsecFilterObjects;
    *pdwNumFilterObjects = dwNumFilterObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecFilterObjects) {

        FreeIpsecFilterObjects(
                    ppIpsecFilterObjects,
                    dwNumFilterObjectsReturned
                    );
    }

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;


    return(dwError);
}



DWORD
ReadNegPolObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumNegPolObjectsReturned = 0;


    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;

    ppIpsecNegPolObjects  = (PIPSEC_NEGPOL_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NEGPOL_OBJECT)*dwNumNegPolObjects
                                            );
    if (!ppIpsecNegPolObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError =UnMarshallRegistryNegPolObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    *(ppszNegPolDNs + i),
                    REG_FULLY_QUALIFIED_NAME,
                    &pIpsecNegPolObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNegPolObjects + dwNumNegPolObjectsReturned) = pIpsecNegPolObject;
            dwNumNegPolObjectsReturned++;

        }


    }

    if (dwNumNegPolObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppIpsecNegPolObjects = ppIpsecNegPolObjects;
    *pdwNumNegPolObjects = dwNumNegPolObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecNegPolObjects) {

        FreeIpsecNegPolObjects(
                    ppIpsecNegPolObjects,
                    dwNumNegPolObjectsReturned
                    );
    }

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;


    return(dwError);
}

DWORD
ReadISAKMPObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;

    DWORD dwNumISAKMPObjectsReturned = 0;


    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;

    ppIpsecISAKMPObjects  = (PIPSEC_ISAKMP_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_ISAKMP_OBJECT)*dwNumISAKMPObjects
                                            );
    if (!ppIpsecISAKMPObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError =UnMarshallRegistryISAKMPObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    *(ppszISAKMPDNs + i),
                    REG_FULLY_QUALIFIED_NAME,
                    &pIpsecISAKMPObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecISAKMPObjects + dwNumISAKMPObjectsReturned) = pIpsecISAKMPObject;
            dwNumISAKMPObjectsReturned++;

        }


    }

    if (dwNumISAKMPObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppIpsecISAKMPObjects = ppIpsecISAKMPObjects;
    *pdwNumISAKMPObjects = dwNumISAKMPObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecISAKMPObjects) {

        FreeIpsecISAKMPObjects(
                    ppIpsecISAKMPObjects,
                    dwNumISAKMPObjectsReturned
                    );
    }

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;


    return(dwError);
}



DWORD
UnMarshallRegistryPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecPolicyDN,
    DWORD  dwNameType,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{

    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD i = 0;
    DWORD dwCount = 0;
    DWORD dwError = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR pszTemp = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;


    if (!pszIpsecPolicyDN || !*pszIpsecPolicyDN) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNameType == REG_FULLY_QUALIFIED_NAME) {
        dwRootPathLen =  wcslen(pszIpsecRegRootContainer);
        if (wcslen(pszIpsecPolicyDN) <= (dwRootPathLen+1)) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pszRelativeName = pszIpsecPolicyDN + dwRootPathLen + 1;
    }else {
        pszRelativeName = pszIpsecPolicyDN;
    }

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszIpsecOwnersReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */


    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                                pszIpsecPolicyDN
                                                );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }



    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszIpsecName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"description",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszDescription,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwIpsecDataType = dwIpsecDataType;


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    REG_BINARY,
                    &pIpsecPolicyObject->pIpsecData,
                    &pIpsecPolicyObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecISAKMPReference",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszIpsecISAKMPReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pszTemp = pszIpsecNFAReference;
    while (*pszTemp != L'\0') {

        pszTemp += wcslen(pszTemp) + 1;
        dwCount++;
    }


    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pszIpsecNFAReference;
    for (i = 0; i < dwCount; i++) {

        pszString = AllocPolStr(pszTemp);
        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            pIpsecPolicyObject->ppszIpsecNFAReferences  = ppszIpsecNFANames;
            pIpsecPolicyObject->NumberofRules = i;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszString;

        pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
    pIpsecPolicyObject->NumberofRules = dwCount;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwWhenChanged = dwWhenChanged;

    *ppIpsecPolicyObject = pIpsecPolicyObject;


    if (hRegKey) {
        RegCloseKey(hRegKey);
    }



    return(dwError);

error:

    *ppIpsecPolicyObject = NULL;

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }


    if (hRegKey) {
        RegCloseKey(hRegKey);
    }



    return(dwError);
}

DWORD
UnMarshallRegistryNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecNFAReference,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    )
{

    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD i = 0;
    DWORD dwCount = 0;
    DWORD dwError = 0;
    LPWSTR  pszTempFilterReference = NULL;
    LPWSTR  pszTempNegPolReference = NULL;

    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;

    dwRootPathLen =  wcslen(pszIpsecRegRootContainer);

    if (!pszIpsecNFAReference || !*pszIpsecNFAReference) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (wcslen(pszIpsecNFAReference) <= (dwRootPathLen+1)) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszRelativeName = pszIpsecNFAReference + dwRootPathLen + 1;


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                sizeof(IPSEC_NFA_OBJECT)
                                );
    if (!pIpsecNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszDistinguishedName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecNFAObject->pszDistinguishedName = AllocPolStr(
                                                pszIpsecNFAReference
                                                );
    if (!pIpsecNFAObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Client does not always write the Name for an NFA
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecName,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"description",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszDescription,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize  = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->dwIpsecDataType = dwIpsecDataType;

    //
    // unmarshall the ipsecData blob
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    REG_BINARY,
                    &pIpsecNFAObject->pIpsecData,
                    &pIpsecNFAObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecOwnersReference",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecOwnersReference,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNegotiationPolicyReference",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecNegPolReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecFilterReference",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecFilterReference,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->dwWhenChanged = dwWhenChanged;

    if (pIpsecNFAObject->pszIpsecFilterReference && *(pIpsecNFAObject->pszIpsecFilterReference)) {
        pszTempFilterReference = AllocPolStr(
                                pIpsecNFAObject->pszIpsecFilterReference
                                );
        if (!pszTempFilterReference) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pszTempNegPolReference = AllocPolStr(
                                 pIpsecNFAObject->pszIpsecNegPolReference
                                 );
    if (!pszTempNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszFilterReference = pszTempFilterReference;
    *ppszNegPolReference = pszTempNegPolReference;

    *ppIpsecNFAObject = pIpsecNFAObject;


cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }


    return(dwError);

error:

    if (pIpsecNFAObject) {

        FreeIpsecNFAObject(pIpsecNFAObject);

    }

    if (pszTempFilterReference) {
        FreePolStr(pszTempFilterReference);
    }

    if (pszTempNegPolReference) {
        FreePolStr(pszTempNegPolReference);
    }

    *ppIpsecNFAObject = NULL;
    *ppszFilterReference = NULL;
    *ppszNegPolReference = NULL;

    goto cleanup;
}


DWORD
UnMarshallRegistryFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecFilterReference,
    DWORD  dwNameType,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{

    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;

    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszTemp = NULL;

    DWORD dwError = 0;
    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;

    if (!pszIpsecFilterReference || !*pszIpsecFilterReference) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNameType == REG_FULLY_QUALIFIED_NAME) {
        dwRootPathLen =  wcslen(pszIpsecRegRootContainer);
        if (wcslen(pszIpsecFilterReference) <= (dwRootPathLen+1)) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pszRelativeName = pszIpsecFilterReference + dwRootPathLen + 1;
    }else {
        pszRelativeName = pszIpsecFilterReference;
    }


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                sizeof(IPSEC_FILTER_OBJECT)
                                );
    if (!pIpsecFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecFilterObject->pszDistinguishedName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecFilterObject->pszDistinguishedName = AllocPolStr(
                                                pszIpsecFilterReference
                                                );
    if (!pIpsecFilterObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"description",
                    REG_SZ,
                    (LPBYTE *)&pIpsecFilterObject->pszDescription,
                    &dwSize
                    );
    //BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecFilterObject->pszIpsecName,
                    &dwSize
                    );
    //BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecFilterObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD,
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->dwIpsecDataType = dwIpsecDataType;


    //
    // unmarshall the ipsecData blob
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    dwType,
                    &pIpsecFilterObject->pIpsecData,
                    &pIpsecFilterObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Owner's reference
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    //BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError) {

        pszTemp = pszIpsecNFAReference;
        while (*pszTemp != L'\0') {

            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }


        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;
        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecFilterObject->dwNFACount = i;

                if (pszIpsecNFAReference) {
                    FreePolStr(pszIpsecNFAReference);
                }

                BAIL_ON_WIN32_ERROR(dwError);

            }

            *(ppszIpsecNFANames + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

        }
        if (pszIpsecNFAReference) {
            FreePolStr(pszIpsecNFAReference);
        }


        pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecFilterObject->dwNFACount = dwCount;


    }

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->dwWhenChanged = dwWhenChanged;


    *ppIpsecFilterObject = pIpsecFilterObject;


cleanup:

    if (hRegKey) {

        RegCloseKey(hRegKey);
    }

    return(dwError);

error:

    if (pIpsecFilterObject) {

        FreeIpsecFilterObject(pIpsecFilterObject);

    }

    *ppIpsecFilterObject = NULL;

    goto cleanup;
}


DWORD
UnMarshallRegistryNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecNegPolReference,
    DWORD  dwNameType,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{

    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;

    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszTemp = NULL;

    DWORD dwError = 0;

    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;

    if (!pszIpsecNegPolReference || !*pszIpsecNegPolReference) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNameType == REG_FULLY_QUALIFIED_NAME) {
        dwRootPathLen =  wcslen(pszIpsecRegRootContainer);
        if (wcslen(pszIpsecNegPolReference) <= (dwRootPathLen+1)) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pszRelativeName = pszIpsecNegPolReference + dwRootPathLen + 1;
    }else {
        pszRelativeName = pszIpsecNegPolReference;
    }

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecNegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                sizeof(IPSEC_NEGPOL_OBJECT)
                                );
    if (!pIpsecNegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszDistinguishedName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecNegPolObject->pszDistinguishedName = AllocPolStr(
                                                pszIpsecNegPolReference
                                                );
    if (!pIpsecNegPolObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Names do not get written on an NegPol Object
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszIpsecName,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"description",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszDescription,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);



    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNegotiationPolicyAction",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszIpsecNegPolAction,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNegotiationPolicyType",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszIpsecNegPolType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolObject->dwIpsecDataType = dwIpsecDataType;


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    REG_BINARY,
                    &pIpsecNegPolObject->pIpsecData,
                    &pIpsecNegPolObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError) {

        pszTemp = pszIpsecNFAReference;
        while (*pszTemp != L'\0') {

            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }


        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;
        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                pIpsecNegPolObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecNegPolObject->dwNFACount = i;


                if (pszIpsecNFAReference) {
                    FreePolStr(pszIpsecNFAReference);
                }

                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFANames + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

        }

        if (pszIpsecNFAReference) {
            FreePolStr(pszIpsecNFAReference);
        }


        pIpsecNegPolObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecNegPolObject->dwNFACount = dwCount;
    }

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolObject->dwWhenChanged = dwWhenChanged;



    *ppIpsecNegPolObject = pIpsecNegPolObject;


cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }


    return(dwError);

error:

    if (pIpsecNegPolObject) {

        FreeIpsecNegPolObject(pIpsecNegPolObject);

    }

    *ppIpsecNegPolObject = NULL;

    goto cleanup;
}

DWORD
UnMarshallRegistryISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecISAKMPReference,
    DWORD  dwNameType,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{

    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;

    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszTemp = NULL;

    DWORD dwError = 0;


    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;

    if (!pszIpsecISAKMPReference || !*pszIpsecISAKMPReference) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNameType == REG_FULLY_QUALIFIED_NAME) {
        dwRootPathLen =  wcslen(pszIpsecRegRootContainer);
        if (wcslen(pszIpsecISAKMPReference) <= (dwRootPathLen+1)) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pszRelativeName = pszIpsecISAKMPReference + dwRootPathLen + 1;
    }else {
        pszRelativeName = pszIpsecISAKMPReference;
    }


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                sizeof(IPSEC_ISAKMP_OBJECT)
                                );
    if (!pIpsecISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecISAKMPObject->pszDistinguishedName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecISAKMPObject->pszDistinguishedName = AllocPolStr(
                                                pszIpsecISAKMPReference
                                                );
    if (!pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Names are not set for ISAKMP objects
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecISAKMPObject->pszIpsecName,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecISAKMPObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD,
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->dwIpsecDataType = dwIpsecDataType;


    //
    // unmarshall the ipsecData blob
    //
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    REG_BINARY,
                    &pIpsecISAKMPObject->pIpsecData,
                    &pIpsecISAKMPObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // ipsecOwnersReference not written
    //


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);


    if (!dwError) {

        pszTemp = pszIpsecNFAReference;
        while (*pszTemp != L'\0') {

            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }


        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;
        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecISAKMPObject->dwNFACount = i;

                if (pszIpsecNFAReference) {
                    FreePolStr(pszIpsecNFAReference);
                }



                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFANames + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

        }

        if (pszIpsecNFAReference) {
            FreePolStr(pszIpsecNFAReference);
        }

        pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecISAKMPObject->dwNFACount = dwCount;
    }

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->dwWhenChanged = dwWhenChanged;


    *ppIpsecISAKMPObject = pIpsecISAKMPObject;


cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }


    return(dwError);

error:

    if (pIpsecISAKMPObject) {

        FreeIpsecISAKMPObject(pIpsecISAKMPObject);

    }

    *ppIpsecISAKMPObject = NULL;

    goto cleanup;
}


DWORD
RegstoreQueryValue(
    HKEY hRegKey,
    LPWSTR pszValueName,
    DWORD dwType,
    LPBYTE * ppValueData,
    LPDWORD pdwSize
    )
{
    DWORD dwSize = 0;
    LPWSTR pszValueData = NULL;
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    LPWSTR pszBuf = NULL;


    dwError = RegQueryValueExW(
                    hRegKey,
                    pszValueName,
                    NULL,
                    &dwType,
                    NULL,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwSize == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pBuffer = (LPBYTE)AllocPolMem(dwSize);
    if (!pBuffer) {

        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegQueryValueExW(
                    hRegKey,
                    pszValueName,
                    NULL,
                    &dwType,
                    pBuffer,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);




    switch (dwType) {
    case REG_SZ:
        pszBuf = (LPWSTR) pBuffer;
        if (!pszBuf || !*pszBuf) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    default:
        break;
    }

    *ppValueData = pBuffer;
    *pdwSize = dwSize;
    return(dwError);

error:

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppValueData = NULL;
    *pdwSize = 0;
    return(dwError);
}


VOID
FlushRegSaveKey(
    HKEY hRegistryKey
    )
{
    DWORD dwError = 0;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize = 0;


    memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
    dwSize = MAX_PATH;

    while((RegEnumKeyExW(
              hRegistryKey,
              0,
              lpszName,
              &dwSize,
              NULL,
              NULL,
              NULL,
              NULL)) == ERROR_SUCCESS) {

        dwError = RegDeleteKeyW(
                      hRegistryKey,
                      lpszName
                      );
        if (dwError != ERROR_SUCCESS) {
            break;
        }

        memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
        dwSize = MAX_PATH;

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\regstore.h ===
DWORD
OpenRegistryIPSECRootKey(
    LPWSTR pszServerName,
    LPWSTR pszIpsecRegRootContainer,
    HKEY * phRegistryKey
    );


DWORD
ReadPolicyObjectFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszPolicyDN,
    LPWSTR pszIpsecRegRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
ReadNFAObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecOwnerReference,
    LPWSTR * ppszNFADNs,
    DWORD dwNumNfaObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNfaObjects,
    LPWSTR ** pppszFilterReferences,
    PDWORD pdwNumFilterReferences,
    LPWSTR ** pppszNegPolReferences,
    PDWORD pdwNumNegPolReferences
    );

DWORD
ReadFilterObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    );

DWORD
ReadNegPolObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    );

DWORD
ReadISAKMPObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
UnMarshallRegistryPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecPolicyDN,
    DWORD  dwNameType,
    PIPSEC_POLICY_OBJECT  * ppIpsecPolicyObject
    );

DWORD
UnMarshallRegistryNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecNFAReference,
    PIPSEC_NFA_OBJECT * ppIpsecPolicyObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    );

DWORD
UnMarshallRegistryFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecFilterReference,
    DWORD  dwNameType,
    PIPSEC_FILTER_OBJECT * ppIpsecPolicyObject
    );

DWORD
UnMarshallRegistryNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecNegPolReference,
    DWORD  dwNameType,
    PIPSEC_NEGPOL_OBJECT * ppIpsecPolicyObject
    );

DWORD
UnMarshallRegistryISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecISAKMPReference,
    DWORD  dwNameType,
    PIPSEC_ISAKMP_OBJECT * ppIpsecPolicyObject
    );


void
FreeIpsecNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

void
FreeIpsecPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

void
FreeIpsecFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

void
FreeIpsecNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

void
FreeIpsecISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );

void
FreeNFAReferences(
    LPWSTR * ppszNFAReferences,
    DWORD dwNumNFAReferences
    );

void
FreeFilterReferences(
    LPWSTR * ppszFilterReferences,
    DWORD dwNumFilterReferences
    );

void
FreeNegPolReferences(
    LPWSTR * ppszNegPolReferences,
    DWORD dwNumNegPolReferences
    );

void
FreeIpsecNFAObjects(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects
    );

void
FreeIpsecFilterObjects(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects
    );

void
FreeIpsecNegPolObjects(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects
    );

void
FreeIpsecISAKMPObjects(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects
    );

void
FreeIpsecPolicyObjects(
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects,
    DWORD dwNumPolicyObjects
    );

DWORD
RegstoreQueryValue(
    HKEY hRegKey,
    LPWSTR pszValueName,
    DWORD dwType,
    LPBYTE * ppValueData,
    LPDWORD pdwSize
    );

#define  REG_RELATIVE_NAME          0
#define  REG_FULLY_QUALIFIED_NAME   1

VOID
FlushRegSaveKey(
    HKEY hRegistryKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\procrule.h ===
typedef struct _spec_buffer{
    DWORD dwSize;
    LPBYTE pMem;
} SPEC_BUFFER, *PSPEC_BUFFER;

DWORD
ProcessNFAs(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    DWORD dwStoreType,
    PDWORD pdwSlientErrorCode,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
ProcessNFA(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    DWORD dwStoreType,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );


DWORD
UnmarshallPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    DWORD dwStoreType,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
UnmarshallNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    DWORD dwStoreType,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
UnmarshallFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
UnmarshallNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
UnmarshallISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );


DWORD
FindIpsecFilterObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );


DWORD
FindIpsecNegPolObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    );


DWORD
UnmarshallFilterSpec(
    LPBYTE pMem,
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpec,
    PDWORD pdwNumBytesAdvanced
    );

DWORD
UnmarshallAuthMethods(
    LPBYTE pMem,
    PIPSEC_AUTH_METHOD * ppIpsecAuthMethod,
    PDWORD pdwNumBytesAdvanced
    );

DWORD
UnmarshallAltAuthMethods(
    LPBYTE pMem,
    PIPSEC_AUTH_METHOD pIpsecAuthMethod,
    PDWORD pdwNumBytesAdvanced
    );

DWORD
GenGUIDFromRegFilterReference(
    LPWSTR pszIpsecFilterReference,
    GUID * FilterIdentifier
    );

DWORD
GenGUIDFromRegNegPolReference(
    LPWSTR pszIpsecNegPolReference,
    GUID * NegPolIdentifier
    );

DWORD
GenGUIDFromRegISAKMPReference(
    LPWSTR pszIpsecISAKMPReference,
    GUID * ISAKMPIdentifier
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\procrule.c ===
#include "precomp.h"

DWORD
ProcessNFAs(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    DWORD dwStoreType,
    PDWORD pdwSlientErrorCode,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    DWORD NumberofRules = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumFilterObjects = 0;
    DWORD dwNumNegPolObjects = 0;

    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;

    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;

    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;

    DWORD dwNumNFACount = 0;


    NumberofRules = pIpsecPolicyObject->NumberofRulesReturned;

    ppIpsecNFAObjects = pIpsecPolicyObject->ppIpsecNFAObjects;
    ppIpsecFilterObjects = pIpsecPolicyObject->ppIpsecFilterObjects;
    ppIpsecNegPolObjects = pIpsecPolicyObject->ppIpsecNegPolObjects;

    dwNumFilterObjects = pIpsecPolicyObject->NumberofFilters;
    dwNumNegPolObjects = pIpsecPolicyObject->NumberofNegPols;



    __try {
    dwError = UnmarshallPolicyObject(
                    pIpsecPolicyObject,
                    dwStoreType,
                    &pIpsecPolicyData
                    );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
    }
    BAIL_ON_WIN32_ERROR(dwError);


    __try {
    dwError = UnmarshallISAKMPObject(
                    *(pIpsecPolicyObject->ppIpsecISAKMPObjects),
                     &pIpsecPolicyData->pIpsecISAKMPData
                     );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
    }
    BAIL_ON_WIN32_ERROR(dwError);


    ppIpsecNFAData = (PIPSEC_NFA_DATA *)AllocPolMem(
                                       sizeof(PIPSEC_NFA_DATA)* NumberofRules
                                       );
    if (!ppIpsecNFAData) {

        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);

    }

    for (i = 0; i < NumberofRules; i++) {

        pIpsecNFAObject = *(ppIpsecNFAObjects + i);


        dwError = ProcessNFA(
                        pIpsecNFAObject,
                        dwStoreType,
                        ppIpsecFilterObjects,
                        dwNumFilterObjects,
                        ppIpsecNegPolObjects,
                        dwNumNegPolObjects,
                        &pIpsecNFAData
                        );
        if (dwError == ERROR_SUCCESS) {

            if (pIpsecNFAData->dwActiveFlag != 0) {
                *(ppIpsecNFAData + dwNumNFACount) = pIpsecNFAData;
                dwNumNFACount++;
            }
            else {
                FreeIpsecNFAData(pIpsecNFAData);
            }
        }
        else {
            *pdwSlientErrorCode = dwError;
        }
    }

    pIpsecPolicyData->ppIpsecNFAData = ppIpsecNFAData;
    pIpsecPolicyData->dwNumNFACount  = dwNumNFACount;


    *ppIpsecPolicyData = pIpsecPolicyData;

    return(dwError);

error:

    if (pIpsecPolicyData) {

        FreeIpsecPolicyData(
                pIpsecPolicyData
                );
    }
    *ppIpsecPolicyData = NULL;


    return(dwError);

}

DWORD
ProcessNFA(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    DWORD dwStoreType,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    __try {
    dwError = UnmarshallNFAObject(
                    pIpsecNFAObject,
                    dwStoreType,
                    &pIpsecNFAData
                    );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
    }
    BAIL_ON_WIN32_ERROR(dwError);


    if (pIpsecNFAObject->pszIpsecFilterReference &&
                        *pIpsecNFAObject->pszIpsecFilterReference) {


            dwError = FindIpsecFilterObject(
                            pIpsecNFAObject,
                            ppIpsecFilterObjects,
                            dwNumFilterObjects,
                            &pIpsecFilterObject
                            );
            BAIL_ON_WIN32_ERROR(dwError);

            __try {
            dwError = UnmarshallFilterObject(
                            pIpsecFilterObject,
                            &pIpsecNFAData->pIpsecFilterData
                            );
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                dwError = ERROR_INVALID_DATA;
            }
            BAIL_ON_WIN32_ERROR(dwError);


    } else {

        //
        // We've received a NULL FilterReference or a NULL string FilterReference
        //
        //
        // This is acceptable - implies there is no filter associated
        //

        pIpsecNFAData->pIpsecFilterData = NULL;


    }

    dwError = FindIpsecNegPolObject(
                    pIpsecNFAObject,
                    ppIpsecNegPolObjects,
                    dwNumNegPolObjects,
                    &pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    __try {
    dwError = UnmarshallNegPolObject(
                    pIpsecNegPolObject,
                    &pIpsecNFAData->pIpsecNegPolData
                    );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecNFAData = pIpsecNFAData;

    return(dwError);


error:

    if (pIpsecNFAData) {

        FreeIpsecNFAData(
                pIpsecNFAData
                );
    }


    return(dwError);
}

DWORD
UnmarshallPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    DWORD dwStoreType,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    LPBYTE pMem = NULL;
    LPWSTR pszIpsecISAKMPReference = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwPollingInterval = 0;
    DWORD dwError = 0;
    DWORD dwSkipSize = 0;

    // {6A1F5C6F-72B7-11d2-ACF0-0060B0ECCA17}
    GUID GUID_POLSTORE_VERSION_INFO =
    { 0x6a1f5c6f, 0x72b7, 0x11d2, { 0xac, 0xf0, 0x0, 0x60, 0xb0, 0xec, 0xca, 0x17 } };


    // {22202163-4F4C-11d1-863B-00A0248D3021}
    static const GUID GUID_IPSEC_POLICY_DATA_BLOB =
    { 0x22202163, 0x4f4c, 0x11d1, { 0x86, 0x3b, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };

    pMem = pIpsecPolicyObject->pIpsecData;

    //
    // Check if the first blob is the version.
    //

    if (!memcmp(pMem, &(GUID_POLSTORE_VERSION_INFO), sizeof(GUID))) {
        pMem += sizeof(GUID);

        memcpy(&dwSkipSize, pMem, sizeof(DWORD));
        pMem += sizeof(DWORD);
        pMem += dwSkipSize;
    }


    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);


    memcpy((LPBYTE)&dwPollingInterval, pMem, sizeof(DWORD));


    pIpsecPolicyData = (PIPSEC_POLICY_DATA)AllocPolMem(
                                sizeof(IPSEC_POLICY_DATA)
                                );
    if (!pIpsecPolicyData) {

        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecPolicyObject->pszIpsecName && *(pIpsecPolicyObject->pszIpsecName)) {

        pIpsecPolicyData->pszIpsecName = AllocPolStr(
                                            pIpsecPolicyObject->pszIpsecName
                                            );
        if (!pIpsecPolicyData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyObject->pszDescription && *(pIpsecPolicyObject->pszDescription)){

        pIpsecPolicyData->pszDescription = AllocPolStr(
                                            pIpsecPolicyObject->pszDescription
                                            );
        if (!pIpsecPolicyData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    wGUIDFromString(pIpsecPolicyObject->pszIpsecID,
                    &pIpsecPolicyData->PolicyIdentifier
                    );

    switch(dwStoreType) {

    case IPSEC_REGISTRY_PROVIDER:
        dwError = GenGUIDFromRegISAKMPReference(
                      pIpsecPolicyObject->pszIpsecISAKMPReference,
                      &pIpsecPolicyData->ISAKMPIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;
    case IPSEC_DIRECTORY_PROVIDER:
        dwError = CopyISAKMPDSToFQRegString(
                        pIpsecPolicyObject->pszIpsecISAKMPReference,
                        &pszIpsecISAKMPReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
        dwError = GenGUIDFromRegISAKMPReference(
                      pszIpsecISAKMPReference,
                      &pIpsecPolicyData->ISAKMPIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    default:
         dwError = ERROR_INVALID_PARAMETER;
         BAIL_ON_WIN32_ERROR(dwError);

    }

    pIpsecPolicyData->dwWhenChanged = pIpsecPolicyObject->dwWhenChanged;

    pIpsecPolicyData->dwPollingInterval = dwPollingInterval;

    *ppIpsecPolicyData = pIpsecPolicyData;

    if (pszIpsecISAKMPReference) {
        FreePolStr(pszIpsecISAKMPReference);
    }

    return(0);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pszIpsecISAKMPReference) {
        FreePolStr(pszIpsecISAKMPReference);
    }

    *ppIpsecPolicyData = NULL;
    return(dwError);
}



DWORD
UnmarshallNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    DWORD dwStoreType,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    LPBYTE pMem = NULL;
    DWORD dwNumAuthMethods = 0;
    PIPSEC_AUTH_METHOD * ppIpsecAuthMethods = NULL;
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_AUTH_METHOD pIpsecAuthMethod = NULL;

    DWORD dwInterfaceType = 0;
    DWORD dwInterfaceNameLen = 0;
    LPWSTR pszInterfaceName = NULL;

    DWORD dwTunnelIpAddr = 0;
    DWORD dwTunnelFlags = 0;
    DWORD dwActiveFlag = 0;
    DWORD dwEndPointNameLen = 0;
    LPWSTR pszEndPointName = NULL;

    DWORD dwNumBytesAdvanced = 0;

    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    LPWSTR pszIpsecFilterReference = NULL;
    LPWSTR pszIpsecNegPolReference = NULL;

    // {11BBAC00-498D-11d1-8639-00A0248D3021}
    static const GUID GUID_IPSEC_NFA_BLOB =
    { 0x11bbac00, 0x498d, 0x11d1, { 0x86, 0x39, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };
    DWORD dwReadBytes = 0;
    GUID TmpGuid;
    DWORD dwNumAltAuthMethods = 0;


    pMem = pIpsecNFAObject->pIpsecData;

    pMem += sizeof(GUID);  // for the GUID
    pMem += sizeof(DWORD); // for the size

    memcpy((LPBYTE)&dwNumAuthMethods, pMem, sizeof(DWORD));


    pIpsecNFAData = (PIPSEC_NFA_DATA)AllocPolMem(
                                sizeof(IPSEC_NFA_DATA)
                                );
    if (!pIpsecNFAData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNumAuthMethods) {
        ppIpsecAuthMethods  = (PIPSEC_AUTH_METHOD *) AllocPolMem(
                                sizeof(PIPSEC_AUTH_METHOD)*dwNumAuthMethods
                                );
        if (!ppIpsecAuthMethods) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pMem += sizeof(DWORD);

    for (i = 0; i < dwNumAuthMethods;i++){


        __try {
        dwError = UnmarshallAuthMethods(
                        pMem,
                        &pIpsecAuthMethod,
                        &dwNumBytesAdvanced
                        );
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = ERROR_INVALID_DATA;
        }
        if (dwError) {

            pIpsecNFAData->dwAuthMethodCount = i;
            pIpsecNFAData->ppAuthMethods = ppIpsecAuthMethods;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pMem += dwNumBytesAdvanced;
        *(ppIpsecAuthMethods + i) = pIpsecAuthMethod;

    }
    pIpsecNFAData->dwAuthMethodCount =  dwNumAuthMethods;
    pIpsecNFAData->ppAuthMethods = ppIpsecAuthMethods;


    memcpy((LPBYTE)&dwInterfaceType, pMem, sizeof(DWORD));
    pIpsecNFAData->dwInterfaceType = dwInterfaceType;
    pMem += sizeof(DWORD);

    memcpy((LPBYTE)&dwInterfaceNameLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);

    if (dwInterfaceNameLen) {

        pszInterfaceName = AllocPolStr((LPWSTR)pMem);
        if (!pszInterfaceName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pIpsecNFAData->pszInterfaceName = pszInterfaceName;
    pMem += dwInterfaceNameLen;


    memcpy((LPBYTE)&dwTunnelIpAddr, pMem, sizeof(DWORD));
    pIpsecNFAData->dwTunnelIpAddr = dwTunnelIpAddr;
    pMem += sizeof(DWORD);

    memcpy((LPBYTE)&dwTunnelFlags, pMem, sizeof(DWORD));
    pIpsecNFAData->dwTunnelFlags  = dwTunnelFlags;
    pMem += sizeof(DWORD);

    memcpy((LPBYTE)&dwActiveFlag, pMem, sizeof(DWORD));
    pIpsecNFAData->dwActiveFlag  = dwActiveFlag;
    pMem += sizeof(DWORD);


    memcpy((LPBYTE)&dwEndPointNameLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);

    if (dwEndPointNameLen) {
        pszEndPointName = AllocPolStr((LPWSTR)pMem);
        if (!pszEndPointName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pIpsecNFAData->pszEndPointName = pszEndPointName;

    pMem += dwEndPointNameLen;

    __try {

    dwReadBytes = (DWORD) ((BYTE *) pMem - (BYTE *) pIpsecNFAObject->pIpsecData);

    if ((dwReadBytes < pIpsecNFAObject->dwIpsecDataLen) &&
        ((pIpsecNFAObject->dwIpsecDataLen - dwReadBytes) > sizeof(GUID))) {

        memset(&TmpGuid, 1, sizeof(GUID));

        if (memcmp(pMem, &TmpGuid, sizeof(GUID)) == 0) {

            pMem += sizeof(GUID);

            memcpy(&dwNumAltAuthMethods, pMem, sizeof(DWORD));
            pMem += sizeof(DWORD);

            if (dwNumAltAuthMethods == dwNumAuthMethods) {
                for (i = 0; i < dwNumAuthMethods; i++) {
                    dwError = UnmarshallAltAuthMethods(
                                  pMem,
                                  ppIpsecAuthMethods[i],
                                  &dwNumBytesAdvanced
                                  );
                    if (dwError) {
                        break;
                    }
                    pMem += dwNumBytesAdvanced;
                }
            }

        }

    }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }

    dwError = ERROR_SUCCESS;

    //
    // Convert the ipsecID to its GUID format
    //

    wGUIDFromString(pIpsecNFAObject->pszIpsecID,
                    &pIpsecNFAData->NFAIdentifier
                    );

    if (pIpsecNFAObject->pszIpsecName && *(pIpsecNFAObject->pszIpsecName)) {

        pIpsecNFAData->pszIpsecName = AllocPolStr(
                                            pIpsecNFAObject->pszIpsecName
                                            );
        if (!pIpsecNFAData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAObject->pszDescription && *(pIpsecNFAObject->pszDescription)) {

        pIpsecNFAData->pszDescription = AllocPolStr(
                                            pIpsecNFAObject->pszDescription
                                            );
        if (!pIpsecNFAData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    switch(dwStoreType) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = GenGUIDFromRegFilterReference(
                      pIpsecNFAObject->pszIpsecFilterReference,
                      &pIpsecNFAData->FilterIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = GenGUIDFromRegNegPolReference(
                      pIpsecNFAObject->pszIpsecNegPolReference,
                      &pIpsecNFAData->NegPolIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        break;

    case IPSEC_DIRECTORY_PROVIDER:

        if (pIpsecNFAObject->pszIpsecFilterReference &&
            *pIpsecNFAObject->pszIpsecFilterReference) {
            dwError = CopyFilterDSToFQRegString(
                          pIpsecNFAObject->pszIpsecFilterReference,
                          &pszIpsecFilterReference
                          );
            BAIL_ON_WIN32_ERROR(dwError);
            dwError = GenGUIDFromRegFilterReference(
                          pszIpsecFilterReference,
                          &pIpsecNFAData->FilterIdentifier
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }

        dwError = CopyNegPolDSToFQRegString(
                      pIpsecNFAObject->pszIpsecNegPolReference,
                      &pszIpsecNegPolReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        dwError = GenGUIDFromRegNegPolReference(
                      pszIpsecNegPolReference,
                      &pIpsecNFAData->NegPolIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        break;

    default:
         dwError = ERROR_INVALID_PARAMETER;
         BAIL_ON_WIN32_ERROR(dwError);

    }


    pIpsecNFAData->dwWhenChanged = pIpsecNFAObject->dwWhenChanged;

    *ppIpsecNFAData = pIpsecNFAData;

    if (pszIpsecFilterReference) {
        FreePolStr(pszIpsecFilterReference);
    }

    if (pszIpsecNegPolReference) {
        FreePolStr(pszIpsecNegPolReference);
    }

    return(0);

error:

    if (pIpsecNFAData) {
        FreeIpsecNFAData(pIpsecNFAData);
    }

    if (pszIpsecFilterReference) {
        FreePolStr(pszIpsecFilterReference);
    }

    if (pszIpsecNegPolReference) {
        FreePolStr(pszIpsecNegPolReference);
    }

    *ppIpsecNFAData = NULL;

    return(dwError);
}

DWORD
UnmarshallFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{

    LPBYTE pMem = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC  pIpsecFilterSpec = NULL;
    DWORD i = 0;
    DWORD dwNumBytesAdvanced = 0;

    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    DWORD dwError = 0;

    // {80DC20B5-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_FILTER_BLOB =
    { 0x80dc20b5, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };


    pIpsecFilterData = (PIPSEC_FILTER_DATA)AllocPolMem(
                                sizeof(IPSEC_FILTER_DATA)
                                );
    if (!pIpsecFilterData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMem = pIpsecFilterObject->pIpsecData;

    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);

    memcpy((LPBYTE)&dwNumFilterSpecs, pMem, sizeof(DWORD));

    if (dwNumFilterSpecs) {
        ppIpsecFilterSpecs  = (PIPSEC_FILTER_SPEC *)AllocPolMem(
                              sizeof(PIPSEC_FILTER_SPEC)*dwNumFilterSpecs
                              );
        if (!ppIpsecFilterSpecs) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pMem += sizeof(DWORD);

    for (i = 0; i < dwNumFilterSpecs;i++){

        __try {
        dwError = UnmarshallFilterSpec(
                        pMem,
                        &pIpsecFilterSpec,
                        &dwNumBytesAdvanced
                        );
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = ERROR_INVALID_DATA;
        }
        if (dwError) {

            pIpsecFilterData->dwNumFilterSpecs = i;
            pIpsecFilterData->ppFilterSpecs = ppIpsecFilterSpecs;
            BAIL_ON_WIN32_ERROR(dwError);
        }


        pMem += dwNumBytesAdvanced;
        *(ppIpsecFilterSpecs + i) = pIpsecFilterSpec;

    }
    pIpsecFilterData->dwNumFilterSpecs = dwNumFilterSpecs;
    pIpsecFilterData->ppFilterSpecs = ppIpsecFilterSpecs;


    //
    // Convert the ipsecID to its GUID format
    //


    if (pIpsecFilterObject->pszIpsecName && *(pIpsecFilterObject->pszIpsecName)) {

        pIpsecFilterData->pszIpsecName = AllocPolStr(
                                            pIpsecFilterObject->pszIpsecName
                                            );
        if (!pIpsecFilterData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterObject->pszDescription && *(pIpsecFilterObject->pszDescription)) {

        pIpsecFilterData->pszDescription = AllocPolStr(
                                            pIpsecFilterObject->pszDescription
                                            );
        if (!pIpsecFilterData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    wGUIDFromString(pIpsecFilterObject->pszIpsecID,
                    &pIpsecFilterData->FilterIdentifier
                    );
    pIpsecFilterData->dwWhenChanged = pIpsecFilterObject->dwWhenChanged;


    *ppIpsecFilterData = pIpsecFilterData;

    return(dwError);

error:

    if (pIpsecFilterData) {

        FreeIpsecFilterData(pIpsecFilterData);
    }

    *ppIpsecFilterData = NULL;

    return(dwError);
}

DWORD
UnmarshallNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{

    LPBYTE pMem = NULL;
    DWORD dwNumSecurityOffers = 0;
    PIPSEC_SECURITY_METHOD pIpsecOffer = NULL;

    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    DWORD dwError = 0;

    // {80DC20B9-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_NEGPOLICY_BLOB =
    { 0x80dc20b9, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };



    pMem = pIpsecNegPolObject->pIpsecData;

    pIpsecNegPolData = (PIPSEC_NEGPOL_DATA)AllocPolMem(
                                sizeof(IPSEC_NEGPOL_DATA)
                                );
    if (!pIpsecNegPolData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);


    memcpy((LPBYTE)&dwNumSecurityOffers, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);

    if (dwNumSecurityOffers) {

        pIpsecOffer = (PIPSEC_SECURITY_METHOD)AllocPolMem(
                                            sizeof(IPSEC_SECURITY_METHOD)*dwNumSecurityOffers
                                            );
        if (!pIpsecOffer) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memcpy((LPBYTE)pIpsecOffer, pMem,
               sizeof(IPSEC_SECURITY_METHOD)*dwNumSecurityOffers);
    }

    //
    // Convert the ipsecID to its GUID format
    //



    if (pIpsecNegPolObject->pszIpsecName && *(pIpsecNegPolObject->pszIpsecName)) {

        pIpsecNegPolData->pszIpsecName = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecName
                                            );
        if (!pIpsecNegPolData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolObject->pszDescription && *(pIpsecNegPolObject->pszDescription)){

        pIpsecNegPolData->pszDescription = AllocPolStr(
                                            pIpsecNegPolObject->pszDescription
                                            );
        if (!pIpsecNegPolData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    wGUIDFromString(pIpsecNegPolObject->pszIpsecID,
                    &pIpsecNegPolData->NegPolIdentifier
                    );

    wGUIDFromString(pIpsecNegPolObject->pszIpsecNegPolAction,
                    &pIpsecNegPolData->NegPolAction
                    );

    wGUIDFromString(pIpsecNegPolObject->pszIpsecNegPolType,
                    &pIpsecNegPolData->NegPolType
                    );

    pIpsecNegPolData->dwSecurityMethodCount = dwNumSecurityOffers;
    pIpsecNegPolData->pIpsecSecurityMethods = pIpsecOffer;

    pIpsecNegPolData->dwWhenChanged = pIpsecNegPolObject->dwWhenChanged;

    *ppIpsecNegPolData = pIpsecNegPolData;
    return(0);

error:

    if (pIpsecOffer) {
        FreePolMem(pIpsecOffer);
    }

    if (pIpsecNegPolData) {
        FreeIpsecNegPolData(pIpsecNegPolData);
    }

    *ppIpsecNegPolData = NULL;
    return(dwError);
}


DWORD
UnmarshallISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{

    LPBYTE pMem = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;

    DWORD dwNumISAKMPSecurityMethods = 0;
    PCRYPTO_BUNDLE pSecurityMethods = NULL;
    PCRYPTO_BUNDLE pSecurityMethod = NULL;

    DWORD i = 0;

    DWORD dwError = 0;

    // {80DC20B8-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_ISAKMP_POLICY_BLOB =
    { 0x80dc20b8, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };

    // CHECK THIS PART

    pMem = pIpsecISAKMPObject->pIpsecData;

    pIpsecISAKMPData = (PIPSEC_ISAKMP_DATA) AllocPolMem(
                                sizeof(IPSEC_ISAKMP_DATA)
                                );
    if (!pIpsecISAKMPData) {

        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);


    memcpy((LPBYTE)&pIpsecISAKMPData->ISAKMPPolicy, pMem, sizeof(ISAKMP_POLICY));
    pMem += sizeof(ISAKMP_POLICY);


    memcpy((LPBYTE)&dwNumISAKMPSecurityMethods, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);

    if (!dwNumISAKMPSecurityMethods) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNumISAKMPSecurityMethods) {
        pSecurityMethods = (PCRYPTO_BUNDLE) AllocPolMem(
                                    sizeof(CRYPTO_BUNDLE)*dwNumISAKMPSecurityMethods
                                    );
        if (!pSecurityMethods) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumISAKMPSecurityMethods; i++) {

        pSecurityMethod = pSecurityMethods + i;
        memcpy(pSecurityMethod, pMem, sizeof(CRYPTO_BUNDLE));
        pMem += sizeof(CRYPTO_BUNDLE);

    }
    pIpsecISAKMPData->dwNumISAKMPSecurityMethods = dwNumISAKMPSecurityMethods;
    pIpsecISAKMPData->pSecurityMethods = pSecurityMethods;

    //
    // Convert the ipsecID to its GUID format
    //

    wGUIDFromString(pIpsecISAKMPObject->pszIpsecID,
                    &pIpsecISAKMPData->ISAKMPIdentifier
                    );

    pIpsecISAKMPData->dwWhenChanged = pIpsecISAKMPObject->dwWhenChanged;


    *ppIpsecISAKMPData = pIpsecISAKMPData;
    return(0);

error:

    if (pIpsecISAKMPData) {

        FreeIpsecISAKMPData(pIpsecISAKMPData);
    }

    *ppIpsecISAKMPData = NULL;
    return(dwError);

}

DWORD
FindIpsecFilterObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    DWORD i = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    for (i = 0; i < dwNumFilterObjects; i++) {


        pIpsecFilterObject = *(ppIpsecFilterObjects + i);


        if (!_wcsicmp(pIpsecFilterObject->pszDistinguishedName,
                        pIpsecNFAObject->pszIpsecFilterReference)) {
            *ppIpsecFilterObject = pIpsecFilterObject;
            return(0);
        }

    }

    *ppIpsecFilterObject = NULL;
    return(ERROR_NOT_FOUND);
}


DWORD
FindIpsecNegPolObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{
    DWORD i = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    for (i = 0; i < dwNumNegPolObjects; i++) {


        pIpsecNegPolObject = *(ppIpsecNegPolObjects + i);


        if (!_wcsicmp(pIpsecNegPolObject->pszDistinguishedName,
                        pIpsecNFAObject->pszIpsecNegPolReference)) {
            *ppIpsecNegPolObject = pIpsecNegPolObject;
            return(0);
        }

    }

    *ppIpsecNegPolObject = NULL;
    return(ERROR_NOT_FOUND);
}

void
FreeIpsecFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{

    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pIpsecFilterSpec = NULL;

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppIpsecFilterSpecs = pIpsecFilterData->ppFilterSpecs;

    for (i = 0; i < dwNumFilterSpecs; i++) {

        pIpsecFilterSpec = *(ppIpsecFilterSpecs + i);

        if (pIpsecFilterSpec) {

            if (pIpsecFilterSpec->pszSrcDNSName){

                FreePolStr(pIpsecFilterSpec->pszSrcDNSName);
            }

            if (pIpsecFilterSpec->pszDestDNSName){

                FreePolStr(pIpsecFilterSpec->pszDestDNSName);
            }

            if (pIpsecFilterSpec->pszDescription){

                FreePolStr(pIpsecFilterSpec->pszDescription);
            }


            FreePolMem(pIpsecFilterSpec);

        }

    }

    FreePolMem(ppIpsecFilterSpecs);

    if (pIpsecFilterData->pszIpsecName) {
        FreePolStr(pIpsecFilterData->pszIpsecName);
    }

    if (pIpsecFilterData->pszDescription) {
        FreePolStr(pIpsecFilterData->pszDescription);
    }

    FreePolMem(pIpsecFilterData);

    return;
}




void
FreeIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    if (pIpsecISAKMPData->pSecurityMethods) {
        FreePolMem(pIpsecISAKMPData->pSecurityMethods);

    }

    FreePolMem(pIpsecISAKMPData);
    return;
}



void
FreeIpsecNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    if (pIpsecNegPolData->pIpsecSecurityMethods){

        FreePolMem(pIpsecNegPolData->pIpsecSecurityMethods);
    }

    if (pIpsecNegPolData->pszIpsecName) {
        FreePolStr(pIpsecNegPolData->pszIpsecName);
    }

    if (pIpsecNegPolData->pszDescription) {
        FreePolStr(pIpsecNegPolData->pszDescription);
    }

    FreePolMem(pIpsecNegPolData);

    return;
}


void
FreeIpsecNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwNumAuthMethods = 0;
    PIPSEC_AUTH_METHOD * ppIpsecAuthMethods = NULL;
    DWORD i = 0;
    PIPSEC_AUTH_METHOD pIpsecAuthMethod = NULL;

    ppIpsecAuthMethods = pIpsecNFAData->ppAuthMethods;

    dwNumAuthMethods = pIpsecNFAData->dwAuthMethodCount;

    for (i = 0; i < dwNumAuthMethods; i++) {

        pIpsecAuthMethod = *(ppIpsecAuthMethods + i);

        if (pIpsecAuthMethod) {

            if (pIpsecAuthMethod->pszAuthMethod) {
                FreePolStr(pIpsecAuthMethod->pszAuthMethod);
            }
            if (pIpsecAuthMethod->pAltAuthMethod) {
                FreePolMem(pIpsecAuthMethod->pAltAuthMethod);
            }

            FreePolMem(pIpsecAuthMethod);

        }

    }

    if (pIpsecNFAData->ppAuthMethods) {
        FreePolMem(pIpsecNFAData->ppAuthMethods);
    }

    if (pIpsecNFAData->pszInterfaceName) {

        FreePolStr(pIpsecNFAData->pszInterfaceName);
    }


    if (pIpsecNFAData->pszEndPointName) {
        FreePolStr(pIpsecNFAData->pszEndPointName);
    }

    if (pIpsecNFAData->pIpsecFilterData) {
        FreeIpsecFilterData(pIpsecNFAData->pIpsecFilterData);
    }


    if (pIpsecNFAData->pIpsecNegPolData) {
        FreeIpsecNegPolData(pIpsecNFAData->pIpsecNegPolData);
    }

    if (pIpsecNFAData->pszIpsecName) {
        FreePolStr(pIpsecNFAData->pszIpsecName);
    }

    if (pIpsecNFAData->pszDescription) {
        FreePolStr(pIpsecNFAData->pszDescription);
    }

    FreePolMem(pIpsecNFAData);
}

void
FreeIpsecPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD i = 0;
    DWORD dwNumNFACount = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;

    dwNumNFACount = pIpsecPolicyData->dwNumNFACount;
    ppIpsecNFAData = pIpsecPolicyData->ppIpsecNFAData;
    pIpsecISAKMPData = pIpsecPolicyData->pIpsecISAKMPData;

    if (pIpsecISAKMPData) {
        FreeIpsecISAKMPData(
                pIpsecISAKMPData
                );
    }

    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        if (pIpsecNFAData) {

            FreeIpsecNFAData(
                    pIpsecNFAData
                    );
        }

    }

    if (pIpsecPolicyData->ppIpsecNFAData) {
        FreePolMem(pIpsecPolicyData->ppIpsecNFAData);
    }

    if (pIpsecPolicyData->pszIpsecName) {
        FreePolStr(pIpsecPolicyData->pszIpsecName);
    }

    if (pIpsecPolicyData->pszDescription) {
        FreePolStr(pIpsecPolicyData->pszDescription);
    }

    if (pIpsecPolicyData) {
        FreePolMem(pIpsecPolicyData);
    }
}


DWORD
CopyIpsecPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pNewIpsecPolicyData = NULL;

    DWORD dwNumberofRules = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;

    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pNewIpsecNFAData = NULL;

    PIPSEC_NFA_DATA * ppNewIpsecNFAData = NULL;

    DWORD i = 0;


    *ppIpsecPolicyData = NULL;

    pNewIpsecPolicyData = (PIPSEC_POLICY_DATA) AllocPolMem(
                                                sizeof(IPSEC_POLICY_DATA)
                                                );
    if (!pNewIpsecPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumberofRules = pIpsecPolicyData->dwNumNFACount;
    ppIpsecNFAData = pIpsecPolicyData->ppIpsecNFAData;

    if (dwNumberofRules) {
        ppNewIpsecNFAData = (PIPSEC_NFA_DATA *) AllocPolMem(
                                                       sizeof(PIPSEC_NFA_DATA)*
                                                       dwNumberofRules
                                                       );

        if (!ppNewIpsecNFAData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    for (i = 0; i < dwNumberofRules; i++) {

            pIpsecNFAData = *(ppIpsecNFAData + i);

            dwError = CopyIpsecNFAData(
                          pIpsecNFAData,
                          &pNewIpsecNFAData
                          );

            if (dwError) {
                pNewIpsecPolicyData->ppIpsecNFAData = ppNewIpsecNFAData;
                pNewIpsecPolicyData->dwNumNFACount = i;
                BAIL_ON_WIN32_ERROR(dwError);
            }

 	    *(ppNewIpsecNFAData + i) = pNewIpsecNFAData;
    }

    pNewIpsecPolicyData->ppIpsecNFAData = ppNewIpsecNFAData;
    pNewIpsecPolicyData->dwNumNFACount = dwNumberofRules;

    if (pIpsecPolicyData->pIpsecISAKMPData) {

        dwError = CopyIpsecISAKMPData(
                      pIpsecPolicyData->pIpsecISAKMPData,
                      &pNewIpsecPolicyData->pIpsecISAKMPData
                      );

        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewIpsecPolicyData->dwPollingInterval = pIpsecPolicyData->dwPollingInterval;
    pNewIpsecPolicyData->dwWhenChanged = pIpsecPolicyData->dwWhenChanged;
    memcpy(
        &(pNewIpsecPolicyData->PolicyIdentifier),
        &(pIpsecPolicyData->PolicyIdentifier),
        sizeof(GUID)
        );
    memcpy(
        &(pNewIpsecPolicyData->ISAKMPIdentifier),
        &(pIpsecPolicyData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    if (pIpsecPolicyData->pszIpsecName &&
        *pIpsecPolicyData->pszIpsecName) {
        pNewIpsecPolicyData->pszIpsecName = AllocPolStr(
                                            pIpsecPolicyData->pszIpsecName
                                            );
        if (!pNewIpsecPolicyData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyData->pszDescription &&
        *pIpsecPolicyData->pszDescription) {
        pNewIpsecPolicyData->pszDescription = AllocPolStr(
                                              pIpsecPolicyData->pszDescription
                                              );
        if (!pNewIpsecPolicyData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    *ppIpsecPolicyData = pNewIpsecPolicyData;

    return (dwError);

error:

    if (pNewIpsecPolicyData) {
	FreeIpsecPolicyData(pNewIpsecPolicyData);
    }

    *ppIpsecPolicyData = NULL;

    return (dwError);

}

DWORD
CopyIpsecNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{

    PIPSEC_NFA_DATA pNewIpsecNFAData = NULL;
    DWORD dwError = 0;
    DWORD i = 0;

    DWORD dwAuthMethodCount = 0;

    PIPSEC_AUTH_METHOD * ppAuthMethods = NULL;
    PIPSEC_AUTH_METHOD * ppNewAuthMethods = NULL;

    PIPSEC_AUTH_METHOD pAuthMethod = NULL;
    PIPSEC_AUTH_METHOD pNewAuthMethod = NULL;


    pNewIpsecNFAData = (PIPSEC_NFA_DATA) AllocPolMem(
                                                sizeof(IPSEC_NFA_DATA)
                                                );
    if (!pNewIpsecNFAData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwAuthMethodCount = pIpsecNFAData->dwAuthMethodCount;
    ppAuthMethods = pIpsecNFAData->ppAuthMethods;

    if (dwAuthMethodCount) {
        ppNewAuthMethods = (PIPSEC_AUTH_METHOD *) AllocPolMem(
                                                       sizeof(PIPSEC_AUTH_METHOD)*
                                                       dwAuthMethodCount
                                                       );

        if (!ppNewAuthMethods) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    for (i = 0; i < dwAuthMethodCount; i++) {

            pAuthMethod = *(ppAuthMethods + i);

            dwError = CopyIpsecAuthMethod(
                          pAuthMethod,
                          &pNewAuthMethod
                          );

            if (dwError) {
                pNewIpsecNFAData->ppAuthMethods = ppNewAuthMethods;
                pNewIpsecNFAData->dwAuthMethodCount = i;
                BAIL_ON_WIN32_ERROR(dwError);
            }

 	    *(ppNewAuthMethods + i) = pNewAuthMethod;
    }

    pNewIpsecNFAData->ppAuthMethods = ppNewAuthMethods;
    pNewIpsecNFAData->dwAuthMethodCount = dwAuthMethodCount;


    if (pIpsecNFAData->pszIpsecName && *pIpsecNFAData->pszIpsecName) {
        pNewIpsecNFAData->pszIpsecName = AllocPolStr(
                                             pIpsecNFAData->pszIpsecName
                                             );

        if (!(pNewIpsecNFAData->pszIpsecName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAData->pszDescription && *pIpsecNFAData->pszDescription) {
        pNewIpsecNFAData->pszDescription = AllocPolStr(
                                             pIpsecNFAData->pszDescription
                                             );

        if (!(pNewIpsecNFAData->pszDescription)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    memcpy(
        &(pNewIpsecNFAData->NFAIdentifier),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );
    memcpy(
        &(pNewIpsecNFAData->FilterIdentifier),
        &(pIpsecNFAData->FilterIdentifier),
        sizeof(GUID)
        );
    memcpy(
        &(pNewIpsecNFAData->NegPolIdentifier),
        &(pIpsecNFAData->NegPolIdentifier),
        sizeof(GUID)
        );

    pNewIpsecNFAData->dwInterfaceType = pIpsecNFAData->dwInterfaceType;

    if (pIpsecNFAData->pszInterfaceName && *pIpsecNFAData->pszInterfaceName) {
        pNewIpsecNFAData->pszInterfaceName = AllocPolStr(
                                             pIpsecNFAData->pszInterfaceName
                                             );

        if (!(pNewIpsecNFAData->pszInterfaceName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pNewIpsecNFAData->dwTunnelIpAddr = pIpsecNFAData->dwTunnelIpAddr;
    pNewIpsecNFAData->dwTunnelFlags = pIpsecNFAData->dwTunnelFlags;
    pNewIpsecNFAData->dwActiveFlag = pIpsecNFAData->dwActiveFlag;

    if (pIpsecNFAData->pszEndPointName && *pIpsecNFAData->pszEndPointName) {
        pNewIpsecNFAData->pszEndPointName = AllocPolStr(
                                             pIpsecNFAData->pszEndPointName
                                             );

        if (!(pNewIpsecNFAData->pszEndPointName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }


    if (pIpsecNFAData->pIpsecFilterData) {

        dwError = CopyIpsecFilterData(
                      pIpsecNFAData->pIpsecFilterData,
                      &pNewIpsecNFAData->pIpsecFilterData
                      );

        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecNFAData->pIpsecNegPolData) {

        dwError = CopyIpsecNegPolData(
                      pIpsecNFAData->pIpsecNegPolData,
                      &pNewIpsecNFAData->pIpsecNegPolData
                      );

        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewIpsecNFAData->dwWhenChanged = pIpsecNFAData->dwWhenChanged;

    *ppIpsecNFAData = pNewIpsecNFAData;

    return(ERROR_SUCCESS);

error:

    if (pNewIpsecNFAData) {
        FreeIpsecNFAData(pNewIpsecNFAData);
    }

    *ppIpsecNFAData = NULL;

    return (dwError);

}


DWORD
CopyIpsecAuthMethod(
    PIPSEC_AUTH_METHOD   pAuthMethod,
    PIPSEC_AUTH_METHOD * ppAuthMethod
    )
{
    DWORD dwError = 0;
    PIPSEC_AUTH_METHOD pNewAuthMethod = NULL;

    pNewAuthMethod = (PIPSEC_AUTH_METHOD) AllocPolMem(
                                              sizeof(IPSEC_AUTH_METHOD)
                                              );

    if (!pNewAuthMethod) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewAuthMethod->dwAuthType = pAuthMethod->dwAuthType;
    pNewAuthMethod->dwAuthLen = pAuthMethod->dwAuthLen;

    if (pAuthMethod->pszAuthMethod) {
        pNewAuthMethod->pszAuthMethod = AllocPolStr(
                                            pAuthMethod->pszAuthMethod
                                            );

        if (!(pNewAuthMethod->pszAuthMethod)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pNewAuthMethod->dwAltAuthLen = 0;
    pNewAuthMethod->pAltAuthMethod = NULL;

    if (pAuthMethod->dwAltAuthLen && pAuthMethod->pAltAuthMethod) {
        pNewAuthMethod->pAltAuthMethod = AllocPolMem(
                                             pAuthMethod->dwAltAuthLen
                                             );
        if (!(pNewAuthMethod->pAltAuthMethod)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        memcpy(
            pNewAuthMethod->pAltAuthMethod, 
            pAuthMethod->pAltAuthMethod,
            pAuthMethod->dwAltAuthLen
            );
        pNewAuthMethod->dwAltAuthLen = pAuthMethod->dwAltAuthLen;
    }

    *ppAuthMethod = pNewAuthMethod;

    return (ERROR_SUCCESS);

error:

    if (pNewAuthMethod) {
        if (pNewAuthMethod->pszAuthMethod) {
            FreePolStr(pNewAuthMethod->pszAuthMethod);
        }
        if (pNewAuthMethod->pAltAuthMethod) {
            FreePolMem(pNewAuthMethod->pAltAuthMethod);
        }
        FreePolMem(pNewAuthMethod);
    }

    *ppAuthMethod = NULL;

    return (dwError);

}


DWORD
CopyIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA   pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPSecurityMethods = 0;

    pNewIpsecISAKMPData = (PIPSEC_ISAKMP_DATA) AllocPolMem(
                                              sizeof(IPSEC_ISAKMP_DATA)
                                              );

    if (!pNewIpsecISAKMPData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    memcpy(
        &(pNewIpsecISAKMPData->ISAKMPIdentifier),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pNewIpsecISAKMPData->ISAKMPPolicy),
        &(pIpsecISAKMPData->ISAKMPPolicy),
        sizeof(ISAKMP_POLICY)
        );

    dwNumISAKMPSecurityMethods =
               pIpsecISAKMPData->dwNumISAKMPSecurityMethods;

    pNewIpsecISAKMPData->dwWhenChanged =
                         pIpsecISAKMPData->dwWhenChanged;

    if (pIpsecISAKMPData->pSecurityMethods) {

        pNewIpsecISAKMPData->pSecurityMethods = (PCRYPTO_BUNDLE) AllocPolMem(
                                                                 sizeof(CRYPTO_BUNDLE) *
                                                                 dwNumISAKMPSecurityMethods
                                                                 );

        if (!(pNewIpsecISAKMPData->pSecurityMethods)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memcpy(
            pNewIpsecISAKMPData->pSecurityMethods,
            pIpsecISAKMPData->pSecurityMethods,
            sizeof(CRYPTO_BUNDLE)*dwNumISAKMPSecurityMethods
            );
        pNewIpsecISAKMPData->dwNumISAKMPSecurityMethods =
                             pIpsecISAKMPData->dwNumISAKMPSecurityMethods;
    }
    else {
        pNewIpsecISAKMPData->pSecurityMethods = NULL;
        pNewIpsecISAKMPData->dwNumISAKMPSecurityMethods = 0;
    }

    *ppIpsecISAKMPData = pNewIpsecISAKMPData;

    return(ERROR_SUCCESS);

error:

    *ppIpsecISAKMPData = NULL;

    return (dwError);

}



DWORD
CopyIpsecFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_FILTER_DATA pNewIpsecFilterData = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs = NULL;

    PIPSEC_FILTER_SPEC pFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC pNewFilterSpecs = NULL;


    pNewIpsecFilterData = (PIPSEC_FILTER_DATA) AllocPolMem(
                                                   sizeof(IPSEC_FILTER_DATA)
                                                   );

    if (!pNewIpsecFilterData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;

    if (dwNumFilterSpecs) {

        ppNewFilterSpecs = (PIPSEC_FILTER_SPEC *) AllocPolMem(
                                                   sizeof(PIPSEC_FILTER_SPEC)*
                                                   dwNumFilterSpecs
                                                   );
        if (!ppNewFilterSpecs) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumFilterSpecs; i++) {

            pFilterSpecs = *(ppFilterSpecs + i);

            dwError = CopyIpsecFilterSpec(
                          pFilterSpecs,
                          &pNewFilterSpecs
                          );

            if (dwError) {
                pNewIpsecFilterData->ppFilterSpecs = ppNewFilterSpecs;
                pNewIpsecFilterData->dwNumFilterSpecs = i;
                BAIL_ON_WIN32_ERROR(dwError);
            }

 	    *(ppNewFilterSpecs + i) = pNewFilterSpecs;
    }

    pNewIpsecFilterData->ppFilterSpecs = ppNewFilterSpecs;
    pNewIpsecFilterData->dwNumFilterSpecs = dwNumFilterSpecs;

    if (pIpsecFilterData->pszIpsecName && *pIpsecFilterData->pszIpsecName) {
        pNewIpsecFilterData->pszIpsecName = AllocPolStr(
                                             pIpsecFilterData->pszIpsecName
                                             );

        if (!(pNewIpsecFilterData->pszIpsecName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterData->pszDescription && *pIpsecFilterData->pszDescription) {
        pNewIpsecFilterData->pszDescription = AllocPolStr(
                                             pIpsecFilterData->pszDescription
                                             );

        if (!(pNewIpsecFilterData->pszDescription)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    memcpy(
        &(pNewIpsecFilterData->FilterIdentifier),
        &(pIpsecFilterData->FilterIdentifier),
        sizeof(GUID)
        );

    pNewIpsecFilterData->dwWhenChanged = pIpsecFilterData->dwWhenChanged;

    *ppIpsecFilterData = pNewIpsecFilterData;

    return(ERROR_SUCCESS);

error:

    if (pNewIpsecFilterData) {
        FreeIpsecFilterData(pNewIpsecFilterData);
    }
    *ppIpsecFilterData = NULL;
    return (dwError);

}


DWORD
CopyIpsecFilterSpec(
    PIPSEC_FILTER_SPEC   pFilterSpecs,
    PIPSEC_FILTER_SPEC * ppFilterSpecs
    )
{

   DWORD dwError = 0;
   PIPSEC_FILTER_SPEC   pNewFilterSpecs = NULL;

   pNewFilterSpecs = (PIPSEC_FILTER_SPEC) AllocPolMem(
                                              sizeof(IPSEC_FILTER_SPEC)
                                              );

   if (!pNewFilterSpecs) {
       dwError = ERROR_OUTOFMEMORY;
       BAIL_ON_WIN32_ERROR(dwError);
   }

   if (pFilterSpecs->pszSrcDNSName) {
        pNewFilterSpecs->pszSrcDNSName = AllocPolStr(
                                             pFilterSpecs->pszSrcDNSName
                                             );

        if (!(pNewFilterSpecs->pszSrcDNSName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
   }

   if (pFilterSpecs->pszDestDNSName) {
        pNewFilterSpecs->pszDestDNSName = AllocPolStr(
                                             pFilterSpecs->pszDestDNSName
                                             );

        if (!(pNewFilterSpecs->pszDestDNSName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
   }

   if (pFilterSpecs->pszDescription) {
        pNewFilterSpecs->pszDescription = AllocPolStr(
                                             pFilterSpecs->pszDescription
                                             );

        if (!(pNewFilterSpecs->pszDescription)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
   }

   memcpy(
       &(pNewFilterSpecs->FilterSpecGUID),
       &(pFilterSpecs->FilterSpecGUID),
       sizeof(GUID)
       );

   pNewFilterSpecs->dwMirrorFlag = pFilterSpecs->dwMirrorFlag;

   memcpy(
       &(pNewFilterSpecs->Filter),
       &(pFilterSpecs->Filter),
       sizeof(IPSEC_FILTER)
       );

   *ppFilterSpecs = pNewFilterSpecs;

   return(ERROR_SUCCESS);


error:

   if (pNewFilterSpecs) {
       if (pNewFilterSpecs->pszSrcDNSName){
            FreePolStr(pNewFilterSpecs->pszSrcDNSName);
       }
       if (pNewFilterSpecs->pszDestDNSName){
           FreePolStr(pNewFilterSpecs->pszDestDNSName);
       }
       if (pNewFilterSpecs->pszDescription){
           FreePolStr(pNewFilterSpecs->pszDescription);
       }
       FreePolMem(pNewFilterSpecs);
   }

   *ppFilterSpecs = NULL;

   return (dwError);

}


DWORD
CopyIpsecNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{

    DWORD dwNumSecurityOffers = 0;

    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;
    DWORD dwError = 0;


    pNewIpsecNegPolData = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                                   sizeof(IPSEC_NEGPOL_DATA)
                                                   );
    if (!pNewIpsecNegPolData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumSecurityOffers = pIpsecNegPolData->dwSecurityMethodCount;

    if (dwNumSecurityOffers) {

        pNewIpsecNegPolData->pIpsecSecurityMethods = (PIPSEC_SECURITY_METHOD) AllocPolMem(
                                              sizeof(IPSEC_SECURITY_METHOD)*dwNumSecurityOffers
                                              );

        if (!(pNewIpsecNegPolData->pIpsecSecurityMethods)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memcpy(
            (pNewIpsecNegPolData->pIpsecSecurityMethods),
            (pIpsecNegPolData->pIpsecSecurityMethods),
            sizeof(IPSEC_SECURITY_METHOD)*dwNumSecurityOffers
            );

        pNewIpsecNegPolData->dwSecurityMethodCount = dwNumSecurityOffers;

    }
    else {

        pNewIpsecNegPolData->dwSecurityMethodCount = 0;
        pNewIpsecNegPolData->pIpsecSecurityMethods = NULL;

    }

    if (pIpsecNegPolData->pszIpsecName && *pIpsecNegPolData->pszIpsecName) {
        pNewIpsecNegPolData->pszIpsecName = AllocPolStr(
                                             pIpsecNegPolData->pszIpsecName
                                             );

        if (!(pNewIpsecNegPolData->pszIpsecName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolData->pszDescription && *pIpsecNegPolData->pszDescription) {
        pNewIpsecNegPolData->pszDescription = AllocPolStr(
                                              pIpsecNegPolData->pszDescription
                                              );

        if (!(pNewIpsecNegPolData->pszDescription)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Convert the ipsecID to its GUID format
    //

    memcpy(
        &(pNewIpsecNegPolData->NegPolIdentifier),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pNewIpsecNegPolData->NegPolAction),
        &(pIpsecNegPolData->NegPolAction),
        sizeof(GUID)
        );

    memcpy(
        &(pNewIpsecNegPolData->NegPolType),
        &(pIpsecNegPolData->NegPolType),
        sizeof(GUID)
        );

    pNewIpsecNegPolData->dwWhenChanged = pIpsecNegPolData->dwWhenChanged;

    *ppIpsecNegPolData = pNewIpsecNegPolData;

    return (0);

error:

    if (pNewIpsecNegPolData) {
        FreeIpsecNegPolData(pNewIpsecNegPolData);
    }

    *ppIpsecNegPolData = NULL;

    return(dwError);

}


DWORD
UnmarshallFilterSpec(
    LPBYTE pMem,
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpec,
    PDWORD pdwNumBytesAdvanced
    )
{
    DWORD dwSrcDNSNameLen = 0;
    LPWSTR pszSrcDNSName = NULL;
    DWORD dwDestDNSNameLen = 0;
    LPWSTR pszDestDNSName = NULL;
    DWORD dwDescriptionLen = 0;
    LPWSTR pszDescription = NULL;
    GUID FilterSpecGUID;
    DWORD dwMirrorFlag = 0;
    IPSEC_FILTER ipsecFilter;
    PIPSEC_FILTER_SPEC pIpsecFilterSpec = NULL;
    DWORD dwNumBytesAdvanced = 0;

    DWORD dwError = 0;

    *ppIpsecFilterSpec = NULL;
    *pdwNumBytesAdvanced = 0;

    memcpy((LPBYTE)&dwSrcDNSNameLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwSrcDNSNameLen) {
        pszSrcDNSName = AllocPolStr((LPWSTR)pMem);
        if (!pszSrcDNSName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pMem += dwSrcDNSNameLen;
    dwNumBytesAdvanced += dwSrcDNSNameLen;

    memcpy((LPBYTE)&dwDestDNSNameLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwDestDNSNameLen) {
        pszDestDNSName = AllocPolStr((LPWSTR)pMem);
        if (!pszDestDNSName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pMem += dwDestDNSNameLen;
    dwNumBytesAdvanced += dwDestDNSNameLen;

    memcpy((LPBYTE)&dwDescriptionLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwDescriptionLen) {
        pszDescription = AllocPolStr((LPWSTR)pMem);
        if (!pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pMem += dwDescriptionLen;
    dwNumBytesAdvanced += dwDescriptionLen;


    memcpy((LPBYTE)&FilterSpecGUID, pMem, sizeof(GUID));
    pMem += sizeof(GUID);
    dwNumBytesAdvanced += sizeof(GUID);

    memcpy((LPBYTE)&dwMirrorFlag, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    memcpy((LPBYTE)&ipsecFilter, pMem, sizeof(IPSEC_FILTER));

    pIpsecFilterSpec = (PIPSEC_FILTER_SPEC)AllocPolMem(
                                sizeof(IPSEC_FILTER_SPEC)

                                 );
    if (!pIpsecFilterSpec) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pMem += sizeof(IPSEC_FILTER);
    dwNumBytesAdvanced += sizeof(IPSEC_FILTER);

    pIpsecFilterSpec->pszSrcDNSName = pszSrcDNSName;
    pIpsecFilterSpec->pszDestDNSName = pszDestDNSName;
    pIpsecFilterSpec->pszDescription = pszDescription;
    pIpsecFilterSpec->dwMirrorFlag = dwMirrorFlag;

    memcpy((LPBYTE)&pIpsecFilterSpec->FilterSpecGUID, &FilterSpecGUID, sizeof(GUID));
    memcpy((LPBYTE)&pIpsecFilterSpec->Filter, &ipsecFilter, sizeof(IPSEC_FILTER));

    *ppIpsecFilterSpec = pIpsecFilterSpec;
    *pdwNumBytesAdvanced = dwNumBytesAdvanced;

    return(dwError);

error:

    if (pszSrcDNSName) {
        FreePolStr(pszSrcDNSName);
    }

    if (pszDestDNSName) {
        FreePolStr(pszDestDNSName);
    }


    if (pszDescription) {
        FreePolStr(pszDescription);
    }

    *ppIpsecFilterSpec = NULL;
    *pdwNumBytesAdvanced = 0;

    return(dwError);
}

DWORD
UnmarshallAuthMethods(
    LPBYTE pMem,
    PIPSEC_AUTH_METHOD * ppIpsecAuthMethod,
    PDWORD pdwNumBytesAdvanced
    )
{
    DWORD dwError = 0;
    DWORD dwAuthType = 0;
    DWORD dwAuthLen = 0;
    LPWSTR pszAuthMethod = NULL;
    PIPSEC_AUTH_METHOD pIpsecAuthMethod = NULL;
    DWORD dwNumBytesAdvanced = 0;

    pIpsecAuthMethod = (PIPSEC_AUTH_METHOD)AllocPolMem(
                                sizeof(IPSEC_AUTH_METHOD)
                                 );
    if (!pIpsecAuthMethod) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy((LPBYTE)&dwAuthType, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    memcpy((LPBYTE)&dwAuthLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwAuthLen) {

        pszAuthMethod = AllocPolStr((LPWSTR)pMem);
        if (!pszAuthMethod) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pMem += dwAuthLen;
    dwNumBytesAdvanced += dwAuthLen;

    //
    // Unmarshall parameters.
    //

    pIpsecAuthMethod->dwAuthType = dwAuthType;
    pIpsecAuthMethod->dwAuthLen = (dwAuthLen - 2)/2;
    pIpsecAuthMethod->pszAuthMethod = pszAuthMethod;
    pIpsecAuthMethod->dwAltAuthLen = 0;
    pIpsecAuthMethod->pAltAuthMethod = NULL;

    *ppIpsecAuthMethod = pIpsecAuthMethod;
    *pdwNumBytesAdvanced = dwNumBytesAdvanced;

    return (dwError);

error:

    if (pszAuthMethod) {
        FreePolStr(pszAuthMethod);
    }

    if (pIpsecAuthMethod) {
        FreePolMem(pIpsecAuthMethod);
    }

    *ppIpsecAuthMethod = NULL;
    *pdwNumBytesAdvanced = 0;
    return (dwError);
}


DWORD
UnmarshallAltAuthMethods(
    LPBYTE pMem,
    PIPSEC_AUTH_METHOD pIpsecAuthMethod,
    PDWORD pdwNumBytesAdvanced
    )
{
    DWORD dwError = 0;
    DWORD dwAuthType = 0;
    DWORD dwAuthLen = 0;
    PBYTE pAltAuthMethod = NULL;
    DWORD dwNumBytesAdvanced = 0;


    memcpy((LPBYTE)&dwAuthType, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    memcpy((LPBYTE)&dwAuthLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwAuthLen) {
        pAltAuthMethod = (PBYTE) AllocPolMem(dwAuthLen);
        if (!pAltAuthMethod) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        memcpy(pAltAuthMethod, pMem, dwAuthLen);
    }
    pMem += dwAuthLen;
    dwNumBytesAdvanced += dwAuthLen;

    pIpsecAuthMethod->dwAltAuthLen = dwAuthLen;
    pIpsecAuthMethod->pAltAuthMethod = pAltAuthMethod;

    *pdwNumBytesAdvanced = dwNumBytesAdvanced;

    return (dwError);

error:

    if (pAltAuthMethod) {
        FreePolMem(pAltAuthMethod);
    }

    pIpsecAuthMethod->dwAltAuthLen = 0;
    pIpsecAuthMethod->pAltAuthMethod = NULL;

    *pdwNumBytesAdvanced = 0;
    return (dwError);
}


void
FreeMulIpsecFilterData(
    PIPSEC_FILTER_DATA * ppIpsecFilterData,
    DWORD dwNumFilterObjects
    )
{
    DWORD i = 0;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;

    if (!ppIpsecFilterData) {
        return;
    }

    for (i = 0; i < dwNumFilterObjects; i++) {

        pIpsecFilterData = *(ppIpsecFilterData + i);

        if (pIpsecFilterData) {
            FreeIpsecFilterData(pIpsecFilterData);
        }
    }

    FreePolMem(ppIpsecFilterData);

    return;
}



void
FreeMulIpsecNegPolData(
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData,
    DWORD dwNumNegPolObjects
    )
{
    DWORD i = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    if (!ppIpsecNegPolData) {
        return;
    }

    for (i = 0; i < dwNumNegPolObjects; i++) {

        pIpsecNegPolData = *(ppIpsecNegPolData + i);

        if (pIpsecNegPolData) {
            FreeIpsecNegPolData(pIpsecNegPolData);
        }
    }

    FreePolMem(ppIpsecNegPolData);

    return;
}


void
FreeMulIpsecPolicyData(
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    )
{
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    if (!ppIpsecPolicyData) {
        return;
    }

    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        if (pIpsecPolicyData) {
            FreeIpsecPolicyData(pIpsecPolicyData);
        }
    }

    FreePolMem(ppIpsecPolicyData);

    return;
}


void
FreeMulIpsecNFAData(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFAObjects
    )
{
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    if (!ppIpsecNFAData) {
        return;
    }

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        if (pIpsecNFAData) {
            FreeIpsecNFAData(pIpsecNFAData);
        }
    }

    FreePolMem(ppIpsecNFAData);

    return;
}


DWORD
GenGUIDFromRegFilterReference(
    LPWSTR pszIpsecFilterReference,
    GUID * FilterIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR pszGuid = NULL;

    if (pszIpsecFilterReference) {

        pszGuid = wcschr(pszIpsecFilterReference, L'{');

        if (!pszGuid) {
            dwError = ERROR_INVALID_DATA;
            return (dwError);
        }

        wGUIDFromString(pszGuid, FilterIdentifier);

    }else {
        memset(FilterIdentifier, 0, sizeof(GUID));
    }



    return(dwError);
}

DWORD
GenGUIDFromRegNegPolReference(
    LPWSTR pszIpsecNegPolReference,
    GUID * NegPolIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR pszGuid = NULL;

    if (pszIpsecNegPolReference) {

        pszGuid = wcschr(pszIpsecNegPolReference, L'{');

        if (!pszGuid) {
            dwError = ERROR_INVALID_DATA;
            return (dwError);
        }

        wGUIDFromString(pszGuid, NegPolIdentifier);


    }else {
        memset(NegPolIdentifier, 0, sizeof(GUID));
    }



    return(dwError);
}

DWORD
GenGUIDFromRegISAKMPReference(
    LPWSTR pszIpsecISAKMPReference,
    GUID * ISAKMPIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR pszGuid = NULL;

    if (pszIpsecISAKMPReference) {

        pszGuid = wcschr(pszIpsecISAKMPReference, L'{');

        if (!pszGuid) {
            dwError = ERROR_INVALID_DATA;
            return (dwError);
        }

        wGUIDFromString(pszGuid, ISAKMPIdentifier);

    }else {
        memset(ISAKMPIdentifier, 0, sizeof(GUID));
    }



    return(dwError);
}


void
FreeIpsecFilterSpecs(
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs,
    DWORD dwNumFilterSpecs
    )
{

    DWORD i = 0;
    PIPSEC_FILTER_SPEC pIpsecFilterSpec = NULL;

    for (i = 0; i < dwNumFilterSpecs; i++) {

        pIpsecFilterSpec = *(ppIpsecFilterSpecs + i);

        if (pIpsecFilterSpec) {

            FreeIpsecFilterSpec(pIpsecFilterSpec);

        }

    }

    FreePolMem(ppIpsecFilterSpecs);
}

void
FreeIpsecFilterSpec(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec
    )
{
    if (pIpsecFilterSpec->pszSrcDNSName){

        FreePolStr(pIpsecFilterSpec->pszSrcDNSName);
    }

    if (pIpsecFilterSpec->pszDestDNSName){

        FreePolStr(pIpsecFilterSpec->pszDestDNSName);
    }

    if (pIpsecFilterSpec->pszDescription){

        FreePolStr(pIpsecFilterSpec->pszDescription);
    }


    FreePolMem(pIpsecFilterSpec);

    return;
}


void
FreeMulIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumISAKMPObjects
    )
{
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    if (!ppIpsecISAKMPData) {
        return;
    }

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        pIpsecISAKMPData = *(ppIpsecISAKMPData + i);

        if (pIpsecISAKMPData) {
            FreeIpsecISAKMPData(pIpsecISAKMPData);
        }
    }

    FreePolMem(ppIpsecISAKMPData);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\utils.h ===
BOOL
HexStringToDword(
    LPCWSTR lpsz,
    DWORD * RetValue,
    int cDigits,
    WCHAR chDelim
    );

BOOL
wUUIDFromString(
    LPCWSTR lpsz,
    LPGUID pguid
    );

BOOL
wGUIDFromString(
    LPCWSTR lpsz,
    LPGUID pguid
    );

DWORD
EnablePrivilege(
    LPCTSTR pszPrivilege
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\connui.h ===
DWORD
IPSecIsLocalPolicyAssigned(
    PBOOL pbIsLocalPolicyAssigned
    );


DWORD
IPSecGetAssignedDomainPolicyName(
    LPWSTR * ppszAssignedDomainPolicyName
    );

DWORD
RegGetAssignedPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\api.c ===
#include "precomp.h"


LPWSTR gpszIpsecRegRootContainer = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local";

LPWSTR gpszIpsecFileRootContainer = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Save";


DWORD
IPSecEnumPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumPolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pppIpsecPolicyData,
                        pdwNumPolicyObjects
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumPolicyData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pppIpsecPolicyData,
                        pdwNumPolicyObjects
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;


    }

    return(dwError);
}


DWORD
IPSecSetPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetPolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pPolicyStore->pszLocationName,
                        pIpsecPolicyData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetPolicyData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecCreatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{

    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreatePolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreatePolicyData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecDeletePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidatePolicyDataDeletion(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeletePolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeletePolicyData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecEnumFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumFilterData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pppIpsecFilterData,
                        pdwNumFilterObjects
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumFilterData(
                        (pPolicyStore->hLdapBindHandle),
                        (pPolicyStore->pszIpsecRootContainer),
                        pppIpsecFilterData,
                        pdwNumFilterObjects
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecSetFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetFilterData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pPolicyStore->pszLocationName,
                            pIpsecFilterData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetFilterData(
                            (pPolicyStore->hLdapBindHandle),
                            (pPolicyStore->pszIpsecRootContainer),
                            pIpsecFilterData
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecCreateFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreateFilterData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecFilterData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreateFilterData(
                        (pPolicyStore->hLdapBindHandle),
                        (pPolicyStore->pszIpsecRootContainer),
                        pIpsecFilterData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;
    }

    return(dwError);
}


DWORD
IPSecDeleteFilterData(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateFilterDataDeletion(
                  hPolicyStore,
                  FilterIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeleteFilterData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            FilterIdentifier
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeleteFilterData(
                            (pPolicyStore->hLdapBindHandle),
                            (pPolicyStore->pszIpsecRootContainer),
                            FilterIdentifier
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecEnumNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumNegPolData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pppIpsecNegPolData,
                            pdwNumNegPolObjects
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumNegPolData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            pppIpsecNegPolData,
                            pdwNumNegPolObjects
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecSetNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    dwError = ValidateNegPolData(
                  pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetNegPolData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pPolicyStore->pszLocationName,
                            pIpsecNegPolData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetNegPolData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            pIpsecNegPolData
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecCreateNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    dwError = ValidateNegPolData(
                  pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreateNegPolData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecNegPolData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreateNegPolData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecNegPolData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecDeleteNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateNegPolDataDeletion(
                  hPolicyStore,
                  NegPolIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeleteNegPolData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            NegPolIdentifier
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeleteNegPolData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            NegPolIdentifier
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecCreateNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateNFAData(
                  hPolicyStore,
                  PolicyIdentifier,
                  pIpsecNFAData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch(pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreateNFAData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pPolicyStore->pszLocationName,
                        pIpsecNFAData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreateNFAData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pIpsecNFAData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecSetNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateNFAData(
                  hPolicyStore,
                  PolicyIdentifier,
                  pIpsecNFAData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetNFAData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pPolicyStore->pszLocationName,
                        pIpsecNFAData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetNFAData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pIpsecNFAData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecDeleteNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeleteNFAData(
                        (pPolicyStore->hRegistryKey),
                        (pPolicyStore->pszIpsecRootContainer),
                        PolicyIdentifier,
                        pPolicyStore->pszLocationName,
                        pIpsecNFAData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeleteNFAData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pIpsecNFAData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecEnumNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumNFAData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pppIpsecNFAData,
                        pdwNumNFAObjects
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumNFAData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pppIpsecNFAData,
                        pdwNumNFAObjects
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecGetFilterData(
    HANDLE hPolicyStore,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegGetFilterData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        FilterGUID,
                        ppIpsecFilterData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirGetFilterData(
                        (pPolicyStore->hLdapBindHandle),
                        (pPolicyStore->pszIpsecRootContainer),
                        FilterGUID,
                        ppIpsecFilterData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }


    return(dwError);
}


DWORD
IPSecGetNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegGetNegPolData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            NegPolGUID,
                            ppIpsecNegPolData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirGetNegPolData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            NegPolGUID,
                            ppIpsecNegPolData
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecEnumISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumISAKMPData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pppIpsecISAKMPData,
                            pdwNumISAKMPObjects
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumISAKMPData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            pppIpsecISAKMPData,
                            pdwNumISAKMPObjects
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecSetISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    dwError = ValidateISAKMPData(
                  pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetISAKMPData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pPolicyStore->pszLocationName,
                            pIpsecISAKMPData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetISAKMPData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            pIpsecISAKMPData
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecCreateISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    dwError = ValidateISAKMPData(
                  pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreateISAKMPData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecISAKMPData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreateISAKMPData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecISAKMPData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecDeleteISAKMPData(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateISAKMPDataDeletion(
                  hPolicyStore,
                  ISAKMPIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeleteISAKMPData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            ISAKMPIdentifier
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeleteISAKMPData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            ISAKMPIdentifier
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecGetISAKMPData(
    HANDLE hPolicyStore,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegGetISAKMPData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            ISAKMPGUID,
                            ppIpsecISAKMPData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirGetISAKMPData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            ISAKMPGUID,
                            ppIpsecISAKMPData
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecOpenPolicyStore(
    LPWSTR pszMachineName,
    DWORD dwTypeOfStore,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    )
{
    DWORD dwError = 0;


    switch (dwTypeOfStore) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = RegOpenPolicyStore(
                      pszMachineName,
                      phPolicyStore
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirOpenPolicyStore(
                      pszMachineName,
                      phPolicyStore
                      );
        break;

    case IPSEC_FILE_PROVIDER:

        dwError = FileOpenPolicyStore(
                      pszMachineName,
                      pszFileName,
                      phPolicyStore
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return (dwError);
}


DWORD
RegOpenPolicyStore(
    LPWSTR pszMachineName,
    HANDLE * phPolicyStore
    )
{
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    DWORD dwError = 0;
    HKEY hParentRegistryKey = NULL;
    HKEY hRegistryKey = NULL;
    WCHAR szName[MAX_PATH];
    LPWSTR pszLocationName = NULL;
    LPWSTR pszIpsecRootContainer = NULL;


    pszIpsecRootContainer = AllocPolStr(gpszIpsecRegRootContainer);
    if (!pszIpsecRootContainer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    szName[0] = L'\0';

    if (!pszMachineName || !*pszMachineName) {
        dwError = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,
                      (LPCWSTR) gpszIpsecRegRootContainer,
                      0,
                      KEY_ALL_ACCESS,
                      &hRegistryKey
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pszLocationName = NULL;
    }
    else {

        wcscpy(szName, L"\\\\");
        wcscat(szName, pszMachineName);

        dwError = RegConnectRegistryW(
                      szName,
                      HKEY_LOCAL_MACHINE,
                      &hParentRegistryKey
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = RegOpenKeyExW(
                      hParentRegistryKey,
                      (LPCWSTR) gpszIpsecRegRootContainer,
                      0,
                      KEY_ALL_ACCESS,
                      &hRegistryKey
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pszLocationName = AllocPolStr(szName);
        if (!pszLocationName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    pPolicyStore = (PIPSEC_POLICY_STORE)AllocPolMem(
                            sizeof(IPSEC_POLICY_STORE)
                            );
    if (!pPolicyStore) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pPolicyStore->dwProvider = IPSEC_REGISTRY_PROVIDER;
    pPolicyStore->hParentRegistryKey = hParentRegistryKey;
    pPolicyStore->hRegistryKey = hRegistryKey;
    pPolicyStore->pszLocationName = pszLocationName;
    pPolicyStore->hLdapBindHandle = NULL;
    pPolicyStore->pszIpsecRootContainer = pszIpsecRootContainer;
    pPolicyStore->pszFileName = NULL;

    *phPolicyStore = pPolicyStore;

    return(dwError);

error:

    if (pszIpsecRootContainer) {
        FreePolStr(pszIpsecRootContainer);
    }

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    if (hParentRegistryKey) {
        RegCloseKey(hParentRegistryKey);
    }

    if (pszLocationName) {
        FreePolStr(pszLocationName);
    }

    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }

    *phPolicyStore = NULL;

    return(dwError);
}


DWORD
DirOpenPolicyStore(
    LPWSTR pszMachineName,
    HANDLE * phPolicyStore
    )
{
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    DWORD dwError = 0;
    LPWSTR pszIpsecRootContainer = NULL;
    HLDAP hLdapBindHandle = NULL;
    LPWSTR pszDefaultDirectory = NULL;


    if (!pszMachineName || !*pszMachineName) {

        dwError = ComputeDefaultDirectory(
                      &pszDefaultDirectory
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = OpenDirectoryServerHandle(
                      pszDefaultDirectory,
                      389,
                      &hLdapBindHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = ComputeDirLocationName(
                      pszDefaultDirectory,
                      &pszIpsecRootContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        dwError = OpenDirectoryServerHandle(
                      pszMachineName,
                      389,
                      &hLdapBindHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = ComputeDirLocationName(
                      pszMachineName,
                      &pszIpsecRootContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    pPolicyStore = (PIPSEC_POLICY_STORE)AllocPolMem(
                            sizeof(IPSEC_POLICY_STORE)
                            );
    if (!pPolicyStore) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pPolicyStore->dwProvider = IPSEC_DIRECTORY_PROVIDER;
    pPolicyStore->hParentRegistryKey = NULL;
    pPolicyStore->hRegistryKey = NULL;
    pPolicyStore->pszLocationName = NULL;
    pPolicyStore->hLdapBindHandle = hLdapBindHandle;
    pPolicyStore->pszIpsecRootContainer = pszIpsecRootContainer;
    pPolicyStore->pszFileName = NULL;

    *phPolicyStore = pPolicyStore;

cleanup:

    if (pszDefaultDirectory) {
        FreePolStr(pszDefaultDirectory);
    }

    return(dwError);

error:

    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }

    if (pszIpsecRootContainer) {
        FreePolStr(pszIpsecRootContainer);
    }

    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }

    *phPolicyStore = NULL;

    goto cleanup;
}


DWORD
FileOpenPolicyStore(
    LPWSTR pszMachineName,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecRootContainer = NULL;
    HKEY hRegistryKey = NULL;
    LPWSTR pszTempFileName = NULL;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    DWORD dwDisposition = 0;


    pszIpsecRootContainer = AllocPolStr(gpszIpsecFileRootContainer);

    if (!pszIpsecRootContainer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pszMachineName || !*pszMachineName) {
        dwError = RegCreateKeyExW(
                      HKEY_LOCAL_MACHINE,
                      (LPCWSTR) gpszIpsecFileRootContainer,
                      0,
                      NULL,
                      0,
                      KEY_ALL_ACCESS,
                      NULL,
                      &hRegistryKey,
                      &dwDisposition
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pszFileName || !*pszFileName) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTempFileName = AllocPolStr(pszFileName);
    if (!pszTempFileName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
 
    pPolicyStore = (PIPSEC_POLICY_STORE)AllocPolMem(
                            sizeof(IPSEC_POLICY_STORE)
                            );
    if (!pPolicyStore) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pPolicyStore->dwProvider = IPSEC_FILE_PROVIDER;
    pPolicyStore->hParentRegistryKey = NULL;
    pPolicyStore->hRegistryKey = hRegistryKey;
    pPolicyStore->pszLocationName = NULL;
    pPolicyStore->hLdapBindHandle = NULL;
    pPolicyStore->pszIpsecRootContainer = pszIpsecRootContainer;
    pPolicyStore->pszFileName = pszTempFileName;

    *phPolicyStore = pPolicyStore;

    return(dwError);

error:

    if (pszIpsecRootContainer) {
        FreePolStr(pszIpsecRootContainer);
    }

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    if (pszTempFileName) {
        FreePolStr(pszTempFileName);
    }

    *phPolicyStore = NULL;

    return(dwError);
}


DWORD
IPSecClosePolicyStore(
    HANDLE hPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        if (pPolicyStore->hRegistryKey) {
            dwError = RegCloseKey(
                          pPolicyStore->hRegistryKey
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pPolicyStore->hParentRegistryKey) {
            dwError = RegCloseKey(
                          pPolicyStore->hParentRegistryKey
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        if (pPolicyStore->pszLocationName) {
            FreePolStr(pPolicyStore->pszLocationName);
        }

        if (pPolicyStore->pszIpsecRootContainer) {
            FreePolStr(pPolicyStore->pszIpsecRootContainer);
        }

        break;

    case IPSEC_DIRECTORY_PROVIDER:

        if (pPolicyStore->hLdapBindHandle) {
            CloseDirectoryServerHandle(
                pPolicyStore->hLdapBindHandle
                );
        }

        if (pPolicyStore->pszIpsecRootContainer) {
            FreePolStr(pPolicyStore->pszIpsecRootContainer);
        }

        break;

    case IPSEC_FILE_PROVIDER:

        if (pPolicyStore->hRegistryKey) {
            dwError = RegCloseKey(
                          pPolicyStore->hRegistryKey
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pPolicyStore->pszIpsecRootContainer) {
            FreePolStr(pPolicyStore->pszIpsecRootContainer);
        }

        if (pPolicyStore->pszFileName) {
            FreePolStr(pPolicyStore->pszFileName);
        }

        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }

error:

    return(dwError);
}


DWORD
IPSecAssignPolicy(
    HANDLE hPolicyStore,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegAssignPolicy(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            PolicyGUID,
                            pPolicyStore->pszLocationName
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecUnassignPolicy(
    HANDLE hPolicyStore,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegUnassignPolicy(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            PolicyGUID,
                            pPolicyStore->pszLocationName
                            );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
ComputeDirLocationName(
    LPWSTR pszDirDomainName,
    LPWSTR * ppszDirFQPathName
    )
{
    DWORD dwError = 0;
    WCHAR szName[MAX_PATH];
    LPWSTR pszDotBegin = NULL;
    LPWSTR pszDotEnd = NULL;
    LPWSTR pszDirFQPathName = NULL;
    LPWSTR pszDirName = NULL;

    szName[0] = L'\0';
    wcscpy(szName, L"CN=IP Security,CN=System");

    pszDirName = AllocPolStr(pszDirDomainName);

    if (!pszDirName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
        
    pszDotBegin = pszDirName;
    pszDotEnd = wcschr(pszDirName, L'.');

    if (!pszDotEnd) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    while (pszDotEnd) {

        *pszDotEnd = L'\0';

        wcscat(szName, L",DC=");
        wcscat(szName, pszDotBegin);

        *pszDotEnd = L'.';

        pszDotEnd += 1;
        pszDotBegin = pszDotEnd;

        pszDotEnd = wcschr(pszDotEnd, L'.');

    }

    wcscat(szName, L",DC=");
    wcscat(szName, pszDotBegin);

    pszDirFQPathName = AllocPolStr(szName);
    if (!pszDirFQPathName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszDirFQPathName = pszDirFQPathName;

cleanup:

    if (pszDirName) {
        FreePolStr(pszDirName);
    }

    return (dwError);

error:

    *ppszDirFQPathName = NULL;    
    goto cleanup;
}


DWORD
IPSecGetAssignedPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegGetAssignedPolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        ppIpsecPolicyData
                        );
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecExportPolicies(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pSrcPolicyStore = NULL;
    PIPSEC_POLICY_STORE pDesPolicyStore = NULL;


    pSrcPolicyStore = (PIPSEC_POLICY_STORE) hSrcPolicyStore;

    switch (pSrcPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:
    case IPSEC_DIRECTORY_PROVIDER:
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    pDesPolicyStore = (PIPSEC_POLICY_STORE) hDesPolicyStore;

    switch (pDesPolicyStore->dwProvider) {

    case IPSEC_FILE_PROVIDER:
        dwError = ExportPoliciesToFile(
                      hSrcPolicyStore,
                      hDesPolicyStore
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecImportPolicies(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pSrcPolicyStore = NULL;
    PIPSEC_POLICY_STORE pDesPolicyStore = NULL;


    pSrcPolicyStore = (PIPSEC_POLICY_STORE) hSrcPolicyStore;

    switch (pSrcPolicyStore->dwProvider) {

    case IPSEC_FILE_PROVIDER:
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    pDesPolicyStore = (PIPSEC_POLICY_STORE) hDesPolicyStore;

    switch (pDesPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:
    case IPSEC_DIRECTORY_PROVIDER:
        dwError = ImportPoliciesFromFile(
                      hSrcPolicyStore,
                      hDesPolicyStore
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecRestoreDefaultPolicies(
    HANDLE hPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = RegRestoreDefaults(
                      hPolicyStore,
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pPolicyStore->pszLocationName
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = ERROR_INVALID_PARAMETER;
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\utils.c ===
#include "precomp.h"


//
// Taken from windows\wmi\mofcheck\mofcheck.c
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCWSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;
    
    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;
        
        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}


DWORD
EnablePrivilege(
    LPCTSTR pszPrivilege
    )
{
    DWORD dwError = 0;
    BOOL bStatus = FALSE;
    HANDLE hTokenHandle = NULL;
    TOKEN_PRIVILEGES NewState;
    TOKEN_PRIVILEGES PreviousState;
    DWORD dwReturnLength = 0;


    bStatus = OpenThreadToken(
                  GetCurrentThread(),
                  TOKEN_ALL_ACCESS,
                  TRUE,
                  &hTokenHandle
                  );
    if (!bStatus) {
        bStatus = OpenProcessToken(
                      GetCurrentProcess(),
                      TOKEN_ALL_ACCESS,
                      &hTokenHandle
                      );
        if (!bStatus) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    bStatus = LookupPrivilegeValue(
                  NULL,
                  pszPrivilege,
                  &NewState.Privileges[0].Luid
                  );
    if (!bStatus) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bStatus = AdjustTokenPrivileges(
                  hTokenHandle,
                  FALSE,
                  &NewState,
                  sizeof(PreviousState),
                  &PreviousState,
                  &dwReturnLength
                  );
    if (!bStatus) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hTokenHandle) {
        CloseHandle(hTokenHandle);
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\pastore\structs.h ===
#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {\
        goto error; \
    }

typedef struct _IPSEC_NFA_OBJECT{
    LPWSTR pszDistinguishedName;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR pszIpsecOwnersReference;
    LPWSTR pszIpsecFilterReference;
    LPWSTR pszIpsecNegPolReference;
    DWORD  dwWhenChanged;
    LPWSTR pszDescription;
}IPSEC_NFA_OBJECT, *PIPSEC_NFA_OBJECT;

typedef struct _IPSEC_ISAKMP_OBJECT{
    LPWSTR pszDistinguishedName;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR * ppszIpsecNFAReferences;
    DWORD  dwNFACount;
    DWORD dwWhenChanged;
}IPSEC_ISAKMP_OBJECT, *PIPSEC_ISAKMP_OBJECT;

typedef struct _IPSEC_FILTER_OBJECT{
    LPWSTR pszDistinguishedName;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR * ppszIpsecNFAReferences;
    DWORD  dwNFACount;
    DWORD dwWhenChanged;
    LPWSTR pszDescription;
}IPSEC_FILTER_OBJECT, *PIPSEC_FILTER_OBJECT;

typedef struct _IPSEC_NEGPOL_OBJECT{
    LPWSTR pszDistinguishedName;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR pszIpsecNegPolAction;
    LPWSTR pszIpsecNegPolType;
    LPWSTR * ppszIpsecNFAReferences;
    DWORD  dwNFACount;
    DWORD dwWhenChanged;
    LPWSTR pszDescription;
}IPSEC_NEGPOL_OBJECT, *PIPSEC_NEGPOL_OBJECT;

typedef struct _IPSEC_POLICY_OBJECT{
    LPWSTR pszIpsecOwnersReference;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR pszIpsecISAKMPReference;
    DWORD  NumberofRules;
    DWORD  NumberofRulesReturned;
    LPWSTR * ppszIpsecNFAReferences;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects;
    DWORD  NumberofFilters;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects;
    DWORD  NumberofNegPols;
    PIPSEC_NEGPOL_OBJECT *ppIpsecNegPolObjects;
    DWORD  NumberofISAKMPs;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects;
    DWORD dwWhenChanged;
    LPWSTR pszDescription;
}IPSEC_POLICY_OBJECT, *PIPSEC_POLICY_OBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\ipseccmd\text2pol.h ===
/////////////////////////////////////////////////////////////
// Copyright(c) 1998-2000, Microsoft Corporation
//
// text2pol.h
//
// Created on 4/5/98 by Randyram
// Revisions:
// Moved the routines to this module 8/25/98
//
// SPD update 2/15/00 DKalin
//
// Includes all the necessary header files and definitions
// for the text to policy conversion routines
//
// GUID generation update 2/29/00 DKalin
//
// GUID manipulation routines added.
//
// Polstore v2 update 5/12/00 DKalin
//
// Polstore v2 support added
//
// Added SPDUtil.cpp declarations 3/27/01 DKalin 
//
/////////////////////////////////////////////////////////////

/* HOW TO USE THE TEXT2POL ROUTINES
   The following are guidelines/things you need to know to use these:

   1. The functions will not touch fields that it doesn't have to.  YOU
      are responsible for cleaning out the structures before you call a
      Text2Pol routine.

      What this also achieves is that you can set the structures to your
      desired defaults-- the defaults are written over if the string to
      convert specifies so.  If the Text2Pol routine doesn't have to touch
      it, then your default will be preserved.

   2. Return values and Error codes:
      Text2Pol routines return DWORDs
      The return codes are defined in t2pmsgs.h.
      The text2pol.dll has a resource table of messages compiled it with it.
      So, when you want to obtain the descriptive string that maps to the
      code, you can use FormatMessage API like so:
      FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                    GetModuleHandle(TEXT("text2pol.dll")),
                    ReturnCodeFromText2PolFunction, 0,
                    (LPTSTR)&myTest, 0, NULL);
      See MSDN for more on FormatMessage.
      One gotcha is that you need to pass in a handle to text2pol.dll because
      that is where the string table resource is.

   3. These are not UNICODE compliant yet.
*/

#ifndef TEXT2POL_H
#define TEXT2POL_H

//#define T2P_TEST_VERSION

// some macros
#define T2P_SUCCESS(Status)   ((DWORD)Status == T2P_OK)

const UINT  POTF_MAX_STRLEN   = 256;

const char  POTF_FILTER_TOKEN       = '=';
const char  POTF_FILTER_MIRTOKEN    = '+';   // indicates filter is two way
const char  POTF_PT_TOKEN           = ':';
const char  POTF_MASK_TOKEN         = '/';
const char  POTF_ANYADDR_TOKEN      = '*';
const char  POTF_ME_TOKEN           = '0';
const char  POTF_GUID_TOKEN         = '{';
const char  POTF_GUID_END_TOKEN     = '}';
const char  POTF_OAKAUTH_TOKEN      = ':';
const char  POTF_QM_TOKEN           = '/';
const char  POTF_P1_TOKEN           = '-';
const char  POTF_REKEY_TOKEN        = '/';
const char  POTF_ESPTRANS_TOKEN     = ',';
const char  POTF_STAR_TOKEN         = '*';
const char  POTF_STORAGE_TOKEN      = ':';

const char  POTF_PASSTHRU_OPEN_TOKEN   = '(';
const char  POTF_PASSTHRU_CLOSE_TOKEN  = ')';
const char  POTF_DROP_OPEN_TOKEN       = '[';
const char  POTF_DROP_CLOSE_TOKEN      = ']';

const char  POTF_ME_TUNNEL[]   = "0";

const char  POTF_OAKAUTH_PRESHARE[]    = "PRESHARE";
const char  POTF_OAKAUTH_KERBEROS[]    = "KERBEROS";
const char  POTF_OAKAUTH_CERT[]        = "CERT";

const char  POTF_STORAGE_REG[]        = "REG";
const char  POTF_STORAGE_DS[]         = "DS";
const char  POTF_STORAGE_CACHE[]      = "CACHE";

const char  POTF_P1_DES40[]     = "INVALID";

const char  POTF_P1_DES[]       = "DES";
const char  POTF_P1_3DES[]      = "3DES";
const char  POTF_P1_SHA[]       = "SHA";
const char  POTF_P1_SHA1[]      = "SHA1"; // same as SHA
const char  POTF_P1_MD5[]       = "MD5";

const char  POTF_PASSTHRU[]               = "PASS";
const char  POTF_INBOUND_PASSTHRU[]       = "INPASS";
const char  POTF_BLOCK[]                  = "BLOCK";

const UINT  POTF_OAKLEY_GROUP1       = DH_GROUP_1;
const UINT  POTF_OAKLEY_GROUP2       = DH_GROUP_2;

const ULONG POTF_OAKLEY_ALGOKEYLEN   = 64;
const ULONG POTF_OAKLEY_ALGOROUNDS   = 8;

const char  POTF_TCP_STR[]     = "TCP";
const char  POTF_UDP_STR[]     = "UDP";
const char  POTF_RAW_STR[]     = "RAW";
const char  POTF_ICMP_STR[]    = "ICMP";

const char  POTF_FILTER_DEFAULT[]      = "DEFAULT";
const DWORD POTF_DEFAULT_RESPONSE_FLAG = 0x00001000;

const DWORD POTF_TCP_PROTNUM     = 6;
const DWORD POTF_UDP_PROTNUM     = 17;
const DWORD POTF_ICMP_PROTNUM    = 1;
const DWORD POTF_RAW_PROTNUM     = 255;

const char  POTF_NEGPOL_ESP[]          = "ESP";
const char  POTF_NEGPOL_AH[]           = "AH";

const char  POTF_NEGPOL_DES40[]        = "INVALID";

const char  POTF_NEGPOL_DES[]          = "DES";
const char  POTF_NEGPOL_3DES[]         = "3DES";
const char  POTF_NEGPOL_SHA[]          = "SHA";
const char  POTF_NEGPOL_SHA1[]         = "SHA1"; // same as SHA
const char  POTF_NEGPOL_MD5[]          = "MD5";
const char  POTF_NEGPOL_NONE[]         = "NONE";
const char  POTF_NEGPOL_OPEN           = '[';
const char  POTF_NEGPOL_CLOSE          = ']';
const char  POTF_NEGPOL_AND            = '+';
const char  POTF_NEGPOL_PFS            = 'P';

// COMMAND LINE FLAGS /////////////////////
const char  POTF_FLAG_TOKENS[]      = "-/";  // what designates a flag
const char  POTF_FILTER_FLAG        = 'f';
const char  POTF_NEGPOL_FLAG        = 'n';
const char  POTF_TUNNEL_FLAG        = 't';
const char  POTF_AUTH_FLAG          = 'a';
const char  POTF_CONFIRM_FLAG       = 'c';
const char  POTF_STORAGE_FLAG       = 'w';
const char  POTF_POLNAME_FLAG       = 'p';
const char  POTF_RULENAME_FLAG      = 'r';
const char  POTF_SETACTIVE_FLAG     = 'x';
const char  POTF_SETINACTIVE_FLAG   = 'y';
const char  POTF_DEACTIVATE_FLAG    = 'd';

const char  POTF_MMFILTER_FLAG[]    = "1f"; // SPD addition
const char  POTF_SOFTSAEXP_FLAG[]   = "1e"; // SPD addition
const char  POTF_SECMETHOD_FLAG[]   = "1s";
const char  POTF_P1PFS_FLAG[]       = "1p";
const char  POTF_P1REKEY_FLAG[]     = "1k";
const char  POTF_SOFTSA_FLAG[]      = "soft";
const char  POTF_DIALUP_FLAG[]      = "dialup";
const char  POTF_LAN_FLAG[]         = "lan";
const char  POTF_DELETERULE_FLAG    = 'u';
const char  POTF_DELETEPOLICY_FLAG  = 'o';
const char  POTF_HELP_FLAGS[]       = "hH?";

const DWORD POTF_MIN_P2LIFE_BYTES   = 20480; // KB
const DWORD POTF_MIN_P2LIFE_TIME    = 300;   // seconds

const DWORD POTF_DEF_P1SOFT_TIME  = 300;   // seconds

//
// Structure for storage information
//

enum StorageType { STORAGE_TYPE_NONE = 0, STORAGE_TYPE_DS,
                   STORAGE_TYPE_REGISTRY, STORAGE_TYPE_CACHE };

const UINT  DNSNAME_MAXLEN = 255;

typedef struct DnsFilter {

   char     szSourceName[DNSNAME_MAXLEN];
   char     szDestName[DNSNAME_MAXLEN];

} *PDNSFILTER, DNSFILTER;

typedef struct StorageInfo {

    StorageType        Type;
    time_t             tPollingInterval;
    GUID               guidNegPolAction; // passthur, block, inbound passthru
    BOOL               bSetActive;
    BOOL               bSetInActive;
    BOOL               bDeleteRule;
    BOOL               bDeletePolicy;
	PIPSEC_FILTER_SPEC FilterList;       // holds filter data for the storage
    UINT               uNumFilters;

    WCHAR    szLocationName[POTF_MAX_STRLEN];
    WCHAR    szPolicyName[POTF_MAX_STRLEN];
    WCHAR    szRuleName[POTF_MAX_STRLEN];


} *PSTORAGE_INFO, STORAGE_INFO;


//
// structre for passing to CmdLineToPolicy
// holds everything you want to know about
// setting policy through the SPD/Polstore API
//

// macros
#define LASTERR(X,Y)    sprintf(STRLASTERR, X, Y)
#define LASTERR2(X,Y,Z)  sprintf(STRLASTERR, X, Y, Z)
#define PARSE_ERROR     cerr << STRLASTERR << endl
#define WARN            cout << STRLASTERR << endl

// use defaults from polwrap.h for policy
const DWORD POTF_DEFAULT_P2REKEY_TIME  =  0;
const DWORD POTF_DEFAULT_P2REKEY_BYTES =  0;

const DWORD POTF_DEFAULT_P1REKEY_TIME  =  480*60;
const DWORD POTF_DEFAULT_P1REKEY_QMS   =  0;


// globals
extern char  STRLASTERR[POTF_MAX_STRLEN];  // used for error macro

#define POTF_FAILED  0

// this is for calling HrSetActivePolicy explicitly
typedef HRESULT (*LPHRSETACTIVEPOLICY)(GUID *);

typedef struct _IPSEC_IKE_POLICY {
  DWORD             dwNumMMFilters;
  MM_FILTER*        pMMFilters;
  QM_FILTER_TYPE    QMFilterType;
  DWORD             dwNumFilters;
  TRANSPORT_FILTER* pTransportFilters;
  TUNNEL_FILTER*    pTunnelFilters;
  IPSEC_MM_POLICY   IkePol;
  IPSEC_QM_POLICY   IpsPol;
  MM_AUTH_METHODS   AuthInfos;
} *PIPSEC_IKE_POLICY, IPSEC_IKE_POLICY;

// this is T2P_FILTER structure
typedef struct _T2P_FILTER {

  QM_FILTER_TYPE    QMFilterType;
  TRANSPORT_FILTER  TransportFilter; // only one out of two gets filled
  TUNNEL_FILTER     TunnelFilter;

} *PT2P_FILTER, T2P_FILTER;


////////////////////////////////////////////////////////////////
//  Function:  TextToFilter
//  Purpose:   Converts text to a T2P_FILTER struct
/* string is of format:
      A.B.C.D/mask:port=A.B.C.D/mask:port:protocol
      The Source address is always on the left of the '=' and the Destination
      address is always on the right.

      If you replace the '=' with a '+' two filters will be created,
      one in each direction.

      mask and port are optional.  If omitted, Any port and
      mask 255.255.255.255 will be used for the filter.

      You can replace A.B.C.D/mask with the following for
      special meaning:
      0 means My address(es)
      * means Any address
      a DNS name

      protocol is optional, if omitted, Any protocol is assumed.  If you
      indicate a protocol, a port must precede it or :: must preceded it.
      Examples:
      Machine1+Machine2::6 will filter TCP traffic between Machine1 and Machine2
      172.31.0.0/255.255.0.0:80-157.0.0.0/255.0.0.0:80:TCP will filter
        all TCP traffic from the first subnet, port 80 to the second subnet,
        port 80

      And, yes, you can use the following protocol symbols:
      ICMP UDP RAW TCP

*/
//
//  Pre-conditions:  szText must be NULL terminated
//
//  Parameters:
//    szText IN      the string to convert
//    Filter IN OUT  a user allocated T2P_FILTER struct,
//                   user should fill QMFilterType field (otherwise we'll assume it's a transport filter)
//
//  Returns:   T2P_OK on success
//    on failure:
//    T2P_PASSTHRU_NOT_CLOSED
//    T2P_DROP_NOT_CLOSED
//    T2P_NULL_STRING
//    T2P_NOSRCDEST_TOKEN
//
//    whatever UuidCreate,TextToFiltAddr, TextToProtocol returns on failure

DWORD  TextToFilter(IN char *szText,
                             IN OUT T2P_FILTER &Filter,
                             char *szSrc = NULL,
                             char *szDst = NULL
                             );

DWORD  ConvertFilter(IN T2P_FILTER &Filter,
                              IN OUT IPSEC_FILTER_SPEC &PolstoreFilter);

////////////////////////////////////////////////////////////////
//  Function:  TextToFiltAddr
//  Purpose:
//    will take A.B.C.D/Mask:port part and translate
//    if bDest is true, puts the info into the dest addr of a filter
//    if bDest is not specified or false, puts info into src addr
//
//  Pre-conditions:  szAddr must be zero terminated
//
//  Parameters:
//    szAddr IN      the string to convert
//    Filter IN OUT  the target filter
//    bDest IN OPTIONAL
//
//  Returns:   T2P_OK on success
//    on failure:
//    T2P_DNSLOOKUP_FAILED
//    T2P_INVALID_ADDR
//    T2P_NULL_STRING

DWORD  TextToFiltAddr(IN char *szAddr, IN OUT T2P_FILTER & Filter,
                    OUT char *szName = NULL,
                    IN bool bDest = false);

////////////////////////////////////////////////////////////////
//  Function:
//  Purpose:
//      will convert string to protocol, including special
//       protocol strings like TCP, UDP, RAW, and ICMP
//
//  Pre-conditions:  szProt has to be NULL terminated
//
//  Parameters:
//    szProt IN      string to convert
//    dwProtocol OUT protocol number returned
//
//  Returns:   T2P_OK on success
//             T2P_INVALID_PROTOCOL on failure
//

DWORD  TextToProtocol(IN char *szProt, OUT DWORD & dwProtocol);

////////////////////////////////////////////////////////////////
//  Function:  TextToOffer
//  Purpose:   converts string to a Phase 2 offer
//             based on following format:
/*
      ESP[ConfAlg,AuthAlg]RekeyPFS
      AH[HashAlg]
      AH[HashAlg]+ESP[ConfAlg,AuthAlg]

      where ConfAlg can be NONE, DES, DES40 or 3DES
      and AuthAlg can be NONE, MD5, or SHA
      and HashAlg is MD5 or SHA

      ESP[NONE, NONE] is not a supported config

*/
//
//  Pre-conditions:  szText is null terminated
//
//  Parameters:
//    szText   IN       the string to convert
//    Offer    IN OUT   the returned offer
//  Returns:   T2P_OK on success
//    on failure:
//    T2P_INVALID_P2REKEY_UNIT
//    T2P_NULL_STRING
//    and anything that TextToAlgoInfo returns

DWORD  TextToOffer(IN char *szText, IN OUT IPSEC_QM_OFFER &);

////////////////////////////////////////////////////////////////
//  Function:  TextToAlgoInfo
//  Purpose:   converts string to IPSEC_QM_ALGO
//    parses AH[alg] or ESP[hashalg,encalg]
//
//  Pre-conditions:  szText is null terminated string
//
//  Parameters:
//    szText IN         string to convert
//    algoInfo IN OUT   target struct
//  Returns:   T2P_OK on success
//    on failure:
//    T2P_INVALID_HASH_ALG
//    T2P_GENERAL_PARSE_ERROR
//    T2P_DUP_ALGS
//    T2P_NONE_NONE
//    T2P_INCOMPLETE_ESPALGS
//    T2P_INVALID_IPSECPROT
//    T2P_NULL_STRING

DWORD  TextToAlgoInfo(IN char *szText, IN OUT IPSEC_QM_ALGO & algoInfo);

////////////////////////////////////////////////////////////////
//  Function:  TextToIPAddr
//  Purpose:   converts string to IPAddr, string of format:
//       IPv4 dot notation
//       DNS name
//
//  CAVEAT:  If domain name resolves to multiple addresses,
//           only the first one is used.
//  Pre-conditions:  szText is null terminated string
//
//  Parameters:
//    szText IN string to convert
//    ipaddr OUT  target
//
//  Returns:   T2P_OK on success
//    on failure:
//    T2P_NULL_STRING
//    T2P_INVALID_ADDR
//    T2P_DNSLOOKUP_FAILED
//
DWORD  TextToIPAddr(IN char *szText, IN OUT IPAddr &ipaddr);

////////////////////////////////////////////////////////////////
//  Function:  TextToOakleyAuth
//  Purpose:   converts string to IPSEC_MM_AUTH_INFO
//
//  Pre-conditions:  szText is null terminated string
//
//  Parameters:
//    szText IN      input string
//    OakAuth IN OUT target struct
//
//  Returns:   T2P_OK on success
//    on failure:
//    T2P_NO_PRESHARED_KEY
//    T2P_INVALID_AUTH_METHOD
//    T2P_MB2WC_FAILED
//    T2P_NULL_STRING
//

DWORD  TextToOakleyAuth(IN char *szText, IN OUT IPSEC_MM_AUTH_INFO & OakAuth);

////////////////////////////////////////////////////////////////
//  Function:  TextToSecMethod
//  Purpose:   converts string to Phase 1 offer
//
//  Pre-conditions:  szText is null term. string
//
//  Parameters:
//    szText IN   string to convert
//    p1offer IN OUT target struct
//
//  Returns:   T2P_OK on success
//    T2P_NULL_STRING
//    T2P_GENERAL_PARSE_ERROR
//    T2P_DUP_ALGS
//    T2P_INVALID_P1GROUP
//    T2P_P1GROUP_MISSING
//

DWORD  TextToSecMethod(IN char *szText, IN OUT IPSEC_MM_OFFER &p1offer);


////////////////////////////////////////////////////////////////
//  Function:  TextToP1Rekey
//  Purpose:   converts string to KEY_LIFETIME and QM limit
//
//  Pre-conditions:  szText is null term. string
//
//  Parameters:
//    szText IN input string
//    OakLife  IN OUT   target struct
//    QMLimit  IN OUT   target QM limit
//
//  Returns:   T2P_OK on success
//    on failure:
//    T2P_INVALID_P1REKEY_UNIT
//    T2P_NULL_STRING

DWORD  TextToP1Rekey(IN char *szText, IN OUT KEY_LIFETIME &OakLife, DWORD & QMLim);

////////////////////////////////////////////////////////////////
//  Function:  TextToMMFilter
//  Purpose:   Converts text to a MM_FILTER struct
/* string is of format:
      A.B.C.D/mask=A.B.C.D/mask
      The Source address is always on the left of the '=' and the Destination
      address is always on the right.

      If you replace the '=' with a '+' two filters will be created,
      one in each direction.

      mask is optional.  If omitted,
      mask 255.255.255.255 will be used for the filter.

      You can replace A.B.C.D/mask with the following for
      special meaning:
      0 means My address(es)
      * means Any address
      a DNS name

*/
//
//  Pre-conditions:  szText must be NULL terminated
//
//  Parameters:
//    szText IN      the string to convert
//    Filter IN OUT  a user allocated MM_FILTER struct,
//
//  Returns:   T2P_OK on success
//    on failure:
//    T2P_NULL_STRING
//    T2P_NOSRCDEST_TOKEN
//
//    whatever UuidCreate,TextToFiltAddr returns on failure

DWORD  TextToMMFilter(IN char *szText,
                               IN OUT MM_FILTER &Filter,
                               char *szSrc = NULL,
                               char *szDst = NULL
                               );

// CmdLineToPolicy
// This will take the command line, parse it all out
// and fill out the policy structures.
// Returns False if there is any kind of failure
// NOTE: uArgCount should be > 0 and strArgs non-null
DWORD   CmdLineToPolicy(IN UINT uArgCount, IN char *strArgs[],
                       OUT IPSEC_IKE_POLICY & IpsecIkePol,
                       OUT bool & bConfirm
                       ,OUT PSTORAGE_INFO pStorageInfo = NULL);

// mirror filter
bool  MirrorFilter(IN T2P_FILTER, OUT T2P_FILTER &);
// generate corresponding mainmode filter
bool  GenerateMMFilter(IN T2P_FILTER, OUT MM_FILTER &);

// this shouldn't be in here, it's a kludge.
void  LoadIkeDefaults(OUT IPSEC_MM_POLICY & IkePol);
void  LoadOfferDefaults(OUT PIPSEC_QM_OFFER & Offers, OUT DWORD & NumOffers);


DWORD  TextToStorageLocation(IN char *szText, IN OUT STORAGE_INFO & StoreInfo);
DWORD  TextToPolicyName(IN char *szText, IN OUT STORAGE_INFO & StoreInfo);


/*********************************************************************
	FUNCTION: GenerateGuidNamePair
        PURPOSE:  Generates GUID and name for the object using specified prefix
        PARAMS:
          pszPrefix - prefix to use, can be NULL (then default prefix will be used)
          gID       - reference to GUID
          ppszName  - address of name pointer, memory will be allocated inside this function		
        RETURNS: none, will assert if memory cannot be allocated
        COMMENTS:
		  caller is responsible for freeing the memory allocated
		  (see also DeleteGuidsNames routine)
*********************************************************************/
void  GenerateGuidNamePair (IN LPWSTR pszPrefix, OUT GUID& gID, OUT LPWSTR* ppszName);

/*********************************************************************
	FUNCTION: GenerateGuidsNames
        PURPOSE:  Generates all necessary GUIDs and names for IPSEC_IKE_POLICY
        PARAMS:
          pszPrefix   - prefix to use, can be NULL (then default prefix will be used)
          IPSecIkePol - reference to IPSEC_IKE_POLICY structure
        RETURNS: none, will assert if memory cannot be allocated
        COMMENTS:
		  caller is responsible for freeing the memory allocated
		  (see also DeleteGuidsNames routine)
*********************************************************************/
void  GenerateGuidsNames (IN LPWSTR pszPrefix, IN OUT IPSEC_IKE_POLICY& IPSecIkePol);

/*********************************************************************
	FUNCTION: DeleteGuidsNames
        PURPOSE:  Deletes all GUIDs and names from IPSEC_IKE_POLICY (used for cleanup)
        PARAMS:
          IPSecIkePol - reference to IPSEC_IKE_POLICY structure
        RETURNS: none
        COMMENTS:
*********************************************************************/
void  DeleteGuidsNames (IN OUT IPSEC_IKE_POLICY& IPSecIkePol);

///////////////////////////////////////////////////////////////////////
//
// PRIVATE DECLARATIONS (SPDUtil.cpp)
//
///////////////////////////////////////////////////////////////////////

int isdnsname(char *szStr);
DWORD CM_EncodeName ( LPTSTR pszSubjectName, BYTE **EncodedName, DWORD *EncodedNameLength );
DWORD CM_DecodeName ( BYTE *EncodedName, DWORD EncodedNameLength, LPTSTR *ppszSubjectName );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\dllsvr.c ===
#include "precomp.h"

#define COUNTOF(x) (sizeof x/sizeof *x)


DWORD
DllRegisterServer(
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    HKEY hOakleyKey = NULL;
    DWORD dwDisposition = 0;
    DWORD dwTypesSupported = 7;
    HKEY hPolicyLocationKey = NULL;
    HANDLE hPolicyStore = NULL;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application",
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreateKeyExW(
                  hRegistryKey,
                  L"Oakley",
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hOakleyKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hOakleyKey,
                   L"EventMessageFile",
                   0,
                   REG_SZ,
                   (LPBYTE) L"%SystemRoot%\\System32\\oakley.dll",
                   (wcslen(L"%SystemRoot%\\System32\\oakley.dll") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hOakleyKey,
                   L"TypesSupported",
                   0,
                   REG_DWORD,
                   (LPBYTE) &dwTypesSupported,
                   sizeof(DWORD)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    if (IsCleanInstall()) {

        dwError = RegCreateKeyExW(
                      HKEY_LOCAL_MACHINE,
                      L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local",
                      0,
                      NULL,
                      0,
                      KEY_ALL_ACCESS,
                      NULL,
                      &hPolicyLocationKey,
                      &dwDisposition
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = IPSecOpenPolicyStore(
                      NULL,
                      IPSEC_REGISTRY_PROVIDER,
                      NULL,
                      &hPolicyStore
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = GenerateDefaultInformation(
                      hPolicyStore
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (hPolicyStore) {
        (VOID) IPSecClosePolicyStore(
                   hPolicyStore
                   );
    }

    if (hPolicyLocationKey) {
        RegCloseKey(hPolicyLocationKey);
    }

    if (hOakleyKey) {
        RegCloseKey(hOakleyKey);
    }

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);                
}


DWORD
DllUnregisterServer(
    )
{
    return (ERROR_SUCCESS);
}


BOOL
IsCleanInstall(
    )
{
    BOOL bStatus = FALSE;

    bStatus = LocalIpsecInfoExists(
                  HKEY_LOCAL_MACHINE,
                  L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local"
                  );

    return (!bStatus);
}


BOOL
LocalIpsecInfoExists(
    HKEY hSourceParentKey,
    LPWSTR pszSourceKey
    )
{
    DWORD dwError = 0;
    HKEY hSourceKey = NULL;
    BOOL bStatus = FALSE;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize = 0;
    DWORD dwCount = 0;


    dwError = RegOpenKeyExW(
                  hSourceParentKey,
                  pszSourceKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hSourceKey
                  );
    if (dwError != ERROR_SUCCESS) {
        return (bStatus);
    }

    memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
    dwSize = COUNTOF(lpszName);

    if ((RegEnumKeyExW(
            hSourceKey,
            dwCount,
            lpszName,
            &dwSize,
            NULL,
            NULL,
            NULL,
            NULL)) == ERROR_SUCCESS) {
        bStatus = TRUE;
    }
    else {
        bStatus = FALSE;
    }

    RegCloseKey(hSourceKey);
    return (bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\connui.c ===
#include "precomp.h"


LPWSTR gpszIpsecLocalPolicyKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local";

LPWSTR gpszIpsecDSPolicyKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\GPTIPSECPolicy";

DWORD
IPSecIsDomainPolicyAssigned(
    PBOOL pbIsDomainPolicyAssigned
    )
{
    DWORD dwError = 0;
    BOOL bIsDomainPolicyAssigned = FALSE;
    HKEY hRegistryKey = NULL;
    DWORD dwType = 0;
    DWORD dwDSPolicyPathLength = 0;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) gpszIpsecDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegQueryValueExW(
                  hRegistryKey,
                  L"DSIPSECPolicyPath",
                  NULL,
                  &dwType,
                  NULL,
                  &dwDSPolicyPathLength
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwDSPolicyPathLength > 0) {
        bIsDomainPolicyAssigned = TRUE;
    }

    *pbIsDomainPolicyAssigned = bIsDomainPolicyAssigned;

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    *pbIsDomainPolicyAssigned = FALSE;
 
    goto cleanup;
}


DWORD
IPSecIsLocalPolicyAssigned(
    PBOOL pbIsLocalPolicyAssigned
    )
{
    DWORD dwError = 0;
    BOOL bIsLocalPolicyAssigned = FALSE;
    HKEY hRegistryKey = NULL;
    DWORD dwType = 0;
    DWORD dwLocalPolicyPathLength = 0;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) gpszIpsecLocalPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegQueryValueExW(
                  hRegistryKey,
                  L"ActivePolicy",
                  NULL,
                  &dwType,
                  NULL,
                  &dwLocalPolicyPathLength
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwLocalPolicyPathLength > 0) {
        bIsLocalPolicyAssigned = TRUE;
    }

    *pbIsLocalPolicyAssigned = bIsLocalPolicyAssigned;

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    *pbIsLocalPolicyAssigned = FALSE;
 
    goto cleanup;
}


DWORD
IPSecGetAssignedDomainPolicyName(
    LPWSTR * ppszAssignedDomainPolicyName
    )
{
    DWORD dwError = 0;
    LPWSTR pszAssignedDomainPolicyName = NULL;
    HKEY hRegistryKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) gpszIpsecDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegistryKey,
                  L"DSIPSECPolicyName",
                  REG_SZ,
                  (LPBYTE *)&pszAssignedDomainPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppszAssignedDomainPolicyName = pszAssignedDomainPolicyName;

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    *ppszAssignedDomainPolicyName = NULL;
 
    goto cleanup;
}


DWORD
RegGetAssignedPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    LPWSTR  pszIpsecPolicyName = NULL;
    DWORD dwSize = 0;
    LPWSTR  pszRelativeName = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    dwError = RegstoreQueryValue(
                  hRegistryKey,
                  L"ActivePolicy",
                  REG_SZ,
                  (LPBYTE *)&pszIpsecPolicyName,
                  &dwSize
                  );

    if (pszIpsecPolicyName && *pszIpsecPolicyName) {
        if (wcslen(pszIpsecPolicyName) >
            (wcslen(pszIpsecRootContainer) + 1)) {
            pszRelativeName = pszIpsecPolicyName
            + wcslen(pszIpsecRootContainer) + 1;

            dwError = UnMarshallRegistryPolicyObject(
                          hRegistryKey,
                          pszIpsecRootContainer,
                          pszRelativeName,
                          REG_RELATIVE_NAME,
                          &pIpsecPolicyObject
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            dwError = RegUnmarshallPolicyData(
                          pIpsecPolicyObject,
                          &pIpsecPolicyData
                          );
            BAIL_ON_WIN32_ERROR(dwError);

        }
    }

    *ppIpsecPolicyData = pIpsecPolicyData;

cleanup:

    if (pszIpsecPolicyName) {
        FreePolStr(pszIpsecPolicyName);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyObject
            );
    }

    return (dwError);

error:

    *ppIpsecPolicyData = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\dllsvr.h ===
DWORD
DllRegisterServer(
    );

DWORD
DllUnregisterServer(
    );

BOOL
IsCleanInstall(
    );

BOOL
LocalIpsecInfoExists(
    HKEY hSourceParentKey,
    LPWSTR pszSourceKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\export.c ===
#include "precomp.h"


DWORD
ExportPoliciesToFile(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pDesPolicyStore = NULL;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;


    pDesPolicyStore = (PIPSEC_POLICY_STORE) hDesPolicyStore;


    dwError = ExportFilterDataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore
                  );

    dwError = ExportNegPolDataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore
                  );

    dwError = ExportISAKMPDataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ExportPolicyDataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ExportNFADataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore,
                  ppIpsecPolicyData,
                  dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = EnablePrivilege(
                  SE_BACKUP_NAME
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    _wremove(pDesPolicyStore->pszFileName);

    dwError = RegSaveKeyW(
                  pDesPolicyStore->hRegistryKey,
                  pDesPolicyStore->pszFileName,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    FlushRegSaveKey(
        pDesPolicyStore->hRegistryKey
        );

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\filters-f.h ===
DWORD
ExportFilterDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    );

DWORD
ImportFilterDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\export.h ===
DWORD
ExportPoliciesToFile(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\filters-f.c ===
#include "precomp.h"


DWORD
ExportFilterDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA * ppIpsecFilterData = NULL;
    DWORD dwNumFilterObjects = 0;
    DWORD i = 0;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;


    dwError = IPSecEnumFilterData(
                  hSrcPolicyStore,
                  &ppIpsecFilterData,
                  &dwNumFilterObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumFilterObjects; i++) {

        pIpsecFilterData = *(ppIpsecFilterData + i);

        dwError = RegCreateFilterData(
                      pDesPolicyStore->hRegistryKey,
                      pDesPolicyStore->pszIpsecRootContainer,
                      pIpsecFilterData
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecFilterData) {
        FreeMulIpsecFilterData(
            ppIpsecFilterData,
            dwNumFilterObjects
            );
    }

    return (dwError);
}


DWORD
ImportFilterDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA * ppIpsecFilterData = NULL;
    DWORD dwNumFilterObjects = 0;
    DWORD i = 0;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;


    dwError = RegEnumFilterData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecFilterData,
                  &dwNumFilterObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumFilterObjects; i++) {

        pIpsecFilterData = *(ppIpsecFilterData + i);

        dwError = IPSecCreateFilterData(
                      hDesPolicyStore,
                      pIpsecFilterData
                      );
        if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
            dwError = IPSecSetFilterData(
                          hDesPolicyStore,
                          pIpsecFilterData
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (ppIpsecFilterData) {
        FreeMulIpsecFilterData(
            ppIpsecFilterData,
            dwNumFilterObjects
            );
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\filters-d.h ===
DWORD
DirEnumFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    );

DWORD
DirEnumFilterObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    );

DWORD
GenerateAllFiltersQuery(
    LPWSTR * ppszFilterString
    );

DWORD
DirSetFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
DirSetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
DirCreateFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
DirCreateFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
DirDeleteFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    );

DWORD
DirMarshallAddFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    LDAPModW *** pppLDAPModW
    );


DWORD
DirMarshallSetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
AllocateLDAPStringValue(
    LPWSTR pszString,
    PLDAPOBJECT * ppLdapObject
    );

DWORD
AllocateLDAPBinaryValue(
    LPBYTE pByte,
    DWORD dwNumBytes,
    PLDAPOBJECT * ppLdapObject
    );

void
FreeLDAPModWs(
    LDAPModW ** ppLDAPModW
    );

DWORD
DirUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
DirMarshallFilterObject(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );

DWORD
DirGetFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
DirGetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );

DWORD
GenerateSpecificFilterQuery(
    GUID FilterIdentifier,
    LPWSTR * ppszFilterString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\filters-r.h ===
DWORD
RegEnumFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    );

DWORD
RegEnumFilterObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    );

DWORD
RegSetFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
RegSetFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
RegCreateFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
RegCreateFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
RegDeleteFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    );

DWORD
RegUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
RegMarshallFilterObject(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );

DWORD
MarshallFilterBuffer(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );

DWORD
MarshallFilterSpecBuffer(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec,
    LPBYTE * ppMem,
    DWORD * pdwSize
    );

DWORD
RegGetFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

VOID
FreeSpecBuffer(
    PSPEC_BUFFER pSpecBuffer,
    DWORD dwNumFilterSpecs
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\filters-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       filters-d.c
//
//  Contents:   Filter Management for directory.
//
//
//  History:    KrishnaG
//              AbhisheV
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR FilterDNAttributes[];


DWORD
DirEnumFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PIPSEC_FILTER_DATA * ppIpsecFilterData = NULL;
    DWORD dwNumFilterObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = DirEnumFilterObjects(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    &ppIpsecFilterObjects,
                    &dwNumFilterObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumFilterObjects) {
        ppIpsecFilterData = (PIPSEC_FILTER_DATA *) AllocPolMem(
                            dwNumFilterObjects*sizeof(PIPSEC_FILTER_DATA)
                            );
        if (!ppIpsecFilterData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError = DirUnmarshallFilterData(
                        *(ppIpsecFilterObjects + i),
                        &pIpsecFilterData
                        );
        if (!dwError) {
            *(ppIpsecFilterData + j) = pIpsecFilterData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecFilterData) {
            FreePolMem(ppIpsecFilterData);
            ppIpsecFilterData = NULL;
        }
    }

    *pppIpsecFilterData = ppIpsecFilterData;
    *pdwNumFilterObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
            ppIpsecFilterObjects,
            dwNumFilterObjects
            );
    }

    return(dwError);

error:

    if (ppIpsecFilterData) {
        FreeMulIpsecFilterData(
                ppIpsecFilterData,
                i
                );
    }

    *pppIpsecFilterData = NULL;
    *pdwNumFilterObjects = 0;

    goto cleanup;
}


DWORD
DirEnumFilterObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    )
{
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszFilterString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;

    DWORD dwNumFilterObjectsReturned = 0;

    dwError = GenerateAllFiltersQuery(
                    &pszFilterString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  FilterDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecFilterObjects  = (PIPSEC_FILTER_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_FILTER_OBJECT)*dwCount
                                            );
    if (!ppIpsecFilterObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        } else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }

        dwError = UnMarshallFilterObject(
                      hLdapBindHandle,
                      e,
                      &pIpsecFilterObject
                      );

        if (dwError == ERROR_SUCCESS) {
            *(ppIpsecFilterObjects + dwNumFilterObjectsReturned) = pIpsecFilterObject;
            dwNumFilterObjectsReturned++;
        }

    }

    *pppIpsecFilterObjects = ppIpsecFilterObjects;
    *pdwNumFilterObjects = dwNumFilterObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
            ppIpsecFilterObjects,
            dwNumFilterObjectsReturned
            );
    }

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;

    goto cleanup;
}


DWORD
DirSetFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    dwError = DirMarshallFilterObject(
                    pIpsecFilterData,
                    pszIpsecRootContainer,
                    &pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetFilterObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirBackPropIncChangesForFilterToNFA(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecFilterData->FilterIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(pIpsecFilterObject);
    }

    return(dwError);
}


DWORD
DirSetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetFilterObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecFilterObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecFilterObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }


    return(dwError);
}


DWORD
DirCreateFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    dwError = DirMarshallFilterObject(
                        pIpsecFilterData,
                        pszIpsecRootContainer,
                        &pIpsecFilterObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreateFilterObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    return(dwError);
}


DWORD
DirCreateFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddFilterObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecFilterObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecFilterObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"CN=ipsecFilter");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    wcscat(szDistinguishedName, pszIpsecRootContainer);

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
DirMarshallAddFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 6;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecFilterObject->pszIpsecName ||
        !*pIpsecFilterObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecFilterObject->pszDescription ||
        !*pIpsecFilterObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecFilter",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecFilterObject->pszIpsecName &&
        *pIpsecFilterObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecFilterObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecFilterObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecFilterObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecFilterObject->pIpsecData,
                    pIpsecFilterObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecFilterObject->pszDescription &&
        *pIpsecFilterObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecFilterObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirMarshallSetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 5;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecFilterObject->pszIpsecName ||
        !*pIpsecFilterObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecFilterObject->pszDescription ||
        !*pIpsecFilterObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecFilterObject->pszIpsecName &&
        *pIpsecFilterObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecFilterObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecFilterObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecFilterObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecFilterObject->pIpsecData,
                    pIpsecFilterObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecFilterObject->pszDescription &&
        *pIpsecFilterObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecFilterObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
GenerateAllFiltersQuery(
    LPWSTR * ppszFilterString
    )
{
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszFilterString = NULL;


    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(objectclass=ipsecFilter)");

    pszFilterString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszFilterString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Now fill in the buffer
    //

    wcscpy(pszFilterString, L"(objectclass=ipsecFilter)");

    *ppszFilterString = pszFilterString;

    return(0);

error:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    *ppszFilterString = NULL;

    return(dwError);
}


DWORD
DirUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallFilterObject(
                  pIpsecFilterObject,
                  ppIpsecFilterData
                  );

    return(dwError);
}


DWORD
DirMarshallFilterObject(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_FILTER_OBJECT)
                                                    );
    if (!pIpsecFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecFilterData->FilterIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecFilter");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    wcscat(szDistinguishedName, pszIpsecRootContainer);

    pIpsecFilterObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecFilterObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecFilterData->pszIpsecName &&
        *pIpsecFilterData->pszIpsecName) {
        pIpsecFilterObject->pszIpsecName = AllocPolStr(
                                            pIpsecFilterData->pszIpsecName
                                            );
        if (!pIpsecFilterObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterData->pszDescription &&
        *pIpsecFilterData->pszDescription) {
        pIpsecFilterObject->pszDescription = AllocPolStr(
                                             pIpsecFilterData->pszDescription
                                             );
        if (!pIpsecFilterObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecFilterObject->pszIpsecID = AllocPolStr(
                                            szGuid
                                            );
    if (!pIpsecFilterObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecFilterObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallFilterBuffer(
                    pIpsecFilterData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->pIpsecData  = pBuffer;

    pIpsecFilterObject->dwIpsecDataLen = dwBufferLen;

    pIpsecFilterObject->dwWhenChanged = 0;

    *ppIpsecFilterObject = pIpsecFilterObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    *ppIpsecFilterObject = NULL;
    goto cleanup;
}


DWORD
DirGetFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;


    dwError = DirGetFilterObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  FilterGUID,
                  &pIpsecFilterObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUnmarshallFilterData(
                  pIpsecFilterObject,
                  &pIpsecFilterData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecFilterData = pIpsecFilterData;

cleanup:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    return(dwError);

error:

    *ppIpsecFilterData = NULL;

    goto cleanup;
}


DWORD
DirGetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszFilterString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;


    dwError = GenerateSpecificFilterQuery(
                  FilterGUID,
                  &pszFilterString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  FilterDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallFilterObject(
                  hLdapBindHandle,
                  e,
                  &pIpsecFilterObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecFilterObject = pIpsecFilterObject;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    *ppIpsecFilterObject = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificFilterQuery(
    GUID FilterIdentifier,
    LPWSTR * ppszFilterString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszFilterString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecFilter");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecFilter)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszFilterString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszFilterString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszFilterString, L"(&(objectclass=ipsecFilter)");
    wcscat(pszFilterString, L"(");
    wcscat(pszFilterString, szCommonName);
    wcscat(pszFilterString, L"))");

    *ppszFilterString = pszFilterString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    *ppszFilterString = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\import.c ===
#include "precomp.h"


DWORD
ImportPoliciesFromFile(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pSrcPolicyStore = NULL;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    PIPSEC_POLICY_STORE pDesPolicyStore = NULL;


    pSrcPolicyStore = (PIPSEC_POLICY_STORE) hSrcPolicyStore;

    dwError = EnablePrivilege(
                  SE_RESTORE_NAME
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegRestoreKeyW(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszFileName,
                  0
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteDuplicatePolicyData(
                  pSrcPolicyStore,
                  hDesPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ImportFilterDataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore
                  );

    dwError = ImportNegPolDataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore
                  );

    dwError = ImportISAKMPDataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ImportPolicyDataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ImportNFADataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore,
                  ppIpsecPolicyData,
                  dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pDesPolicyStore = (PIPSEC_POLICY_STORE) hDesPolicyStore;

    if (pDesPolicyStore->dwProvider == IPSEC_REGISTRY_PROVIDER) {
        (VOID) RegPingPASvcForActivePolicy(
                  pDesPolicyStore->hRegistryKey,
                  pDesPolicyStore->pszIpsecRootContainer,
                  pDesPolicyStore->pszLocationName
                  );
    }

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    FlushRegSaveKey(
        pSrcPolicyStore->hRegistryKey
        );

    return (dwError);
}


DWORD
DeleteDuplicatePolicyData(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;


    dwError = RegEnumPolicyData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );

    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = * (ppIpsecPolicyData + i);

        dwError = VerifyPolicyDataExistence(
                      hDesPolicyStore,
                      pIpsecPolicyData->PolicyIdentifier
                      );

        if (!dwError) {
            dwError = IPSecDeletePolicy(
                          hDesPolicyStore,
                          pIpsecPolicyData
                          ); 
        }

    }

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
IPSecDeletePolicy(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = RegDeletePolicy(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pPolicyStore->pszLocationName,
                      pIpsecPolicyData->PolicyIdentifier
                      );
        BAIL_ON_WIN32_ERROR (dwError);
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirDeletePolicy(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      pIpsecPolicyData->PolicyIdentifier
                      );
        BAIL_ON_WIN32_ERROR (dwError);
        break;

    }

error:

    return (dwError);
}


DWORD
RegDeletePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD dwNumNFAObjects = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    dwError = RegGetPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyGUID,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegEnumNFAData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyGUID,
                  &ppIpsecNFAData,
                  &dwNumNFAObjects
                  );

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        dwError = RegDeleteNFAData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      PolicyGUID,
                      pszLocationName,
                      pIpsecNFAData
                      );

        dwError = RegDeleteDynamicDefaultNegPolData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszLocationName,
                      pIpsecNFAData->NegPolIdentifier
                      );

    }

    dwError = RegDeletePolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData->ISAKMPIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            dwNumNFAObjects
            );
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(
            pIpsecPolicyData
            );
    }

    return (dwError);
}


DWORD
DirDeletePolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwNumNFAObjects = 0;
    DWORD i = 0;


    dwError = DirGetPolicyData(
                 hLdapBindHandle,
                 pszIpsecRootContainer,
                 PolicyIdentifier,
                 &pIpsecPolicyData
                 );
    BAIL_ON_WIN32_ERROR (dwError);

    dwError = DirEnumNFAData(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  PolicyIdentifier,
                  &ppIpsecNFAData,
                  &dwNumNFAObjects
                  );

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        dwError = DirDeleteNFAData(
                     hLdapBindHandle,
                     pszIpsecRootContainer,
                     PolicyIdentifier,
                     pIpsecNFAData
                     );

        dwError = DirDeleteDynamicDefaultNegPolData(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pIpsecNFAData->NegPolIdentifier
                      );

    }

    dwError = DirDeletePolicyData(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR (dwError);

    dwError = DirDeleteISAKMPData(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecPolicyData->ISAKMPIdentifier
                  );
    BAIL_ON_WIN32_ERROR (dwError);

error:

    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            dwNumNFAObjects
            );
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(
            pIpsecPolicyData
            );
    }

    return (dwError); 
}


DWORD
DirDeleteDynamicDefaultNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = DirGetNegPolData(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NegPolGUID,
                  &pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType),
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {

        dwError = DirDeleteNegPolData(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      NegPolGUID
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pIpsecNegPolData) {
        FreeIpsecNegPolData(
            pIpsecNegPolData
            );
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\filters-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       filters-r.c
//
//  Contents:   Filter management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR FilterDNAttributes[];


DWORD
RegEnumFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PIPSEC_FILTER_DATA * ppIpsecFilterData = NULL;
    DWORD dwNumFilterObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = RegEnumFilterObjects(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    &ppIpsecFilterObjects,
                    &dwNumFilterObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumFilterObjects) {
        ppIpsecFilterData = (PIPSEC_FILTER_DATA *) AllocPolMem(
                            dwNumFilterObjects*sizeof(PIPSEC_FILTER_DATA)
                            );
        if (!ppIpsecFilterData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError = RegUnmarshallFilterData(
                        *(ppIpsecFilterObjects + i),
                        &pIpsecFilterData
                        );
        if (!dwError) {
            *(ppIpsecFilterData + j) = pIpsecFilterData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecFilterData) {
            FreePolMem(ppIpsecFilterData);
            ppIpsecFilterData = NULL;
        }
    }

    *pppIpsecFilterData = ppIpsecFilterData;
    *pdwNumFilterObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
                ppIpsecFilterObjects,
                dwNumFilterObjects
                );
    }



    return(dwError);

error:

    if (ppIpsecFilterData) {
        FreeMulIpsecFilterData(
                ppIpsecFilterData,
                i
                );
    }

    *pppIpsecFilterData = NULL;
    *pdwNumFilterObjects = 0;

    goto cleanup;

}

DWORD
RegEnumFilterObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;

    DWORD dwNumFilterObjectsReturned = 0;
    DWORD dwIndex = 0;
    WCHAR szFilterName[MAX_PATH];
    DWORD dwSize = 0;

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;

    while (1) {

        dwSize = MAX_PATH;
        szFilterName[0] = L'\0';

        dwError = RegEnumKeyExW(
                        hRegistryKey,
                        dwIndex,
                        szFilterName,
                        &dwSize,
                        NULL,
                        NULL,
                        0,
                        0
                        );
        if (dwError == ERROR_NO_MORE_ITEMS) {
            break;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        if (!wcsstr(szFilterName, L"ipsecFilter")) {
            dwIndex++;
            continue;
        }

        pIpsecFilterObject = NULL;

        dwError =UnMarshallRegistryFilterObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    szFilterName,
                    REG_RELATIVE_NAME,
                    &pIpsecFilterObject
                    );
        if (dwError == ERROR_SUCCESS) {

            dwError = ReallocatePolMem(
                          (LPVOID *) &ppIpsecFilterObjects,
                          sizeof(PIPSEC_FILTER_OBJECT)*(dwNumFilterObjectsReturned),
                          sizeof(PIPSEC_FILTER_OBJECT)*(dwNumFilterObjectsReturned + 1)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            *(ppIpsecFilterObjects + dwNumFilterObjectsReturned) = pIpsecFilterObject;

            dwNumFilterObjectsReturned++;

        }

        dwIndex++;

    }

    *pppIpsecFilterObjects = ppIpsecFilterObjects;
    *pdwNumFilterObjects = dwNumFilterObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
                    ppIpsecFilterObjects,
                    dwNumFilterObjectsReturned
                    );
    }

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;


    return(dwError);
}


DWORD
RegSetFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    dwError = RegMarshallFilterObject(
                    pIpsecFilterData,
                    &pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetFilterObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegBackPropIncChangesForFilterToNFA(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  pIpsecFilterObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(pIpsecFilterObject);
    }

    return(dwError);
}


DWORD
RegSetFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    DWORD dwError = 0;

    dwError = PersistFilterObject(
                    hRegistryKey,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegCreateFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    dwError = RegMarshallFilterObject(
                        pIpsecFilterData,
                        &pIpsecFilterObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreateFilterObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
                pIpsecFilterObject
                );
    }

    return(dwError);
}

DWORD
RegCreateFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{

    DWORD dwError = 0;

    dwError = PersistFilterObject(
                    hRegistryKey,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegDeleteFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"ipsecFilter");
    wcscat(szDistinguishedName, szGuid);

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
RegUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallFilterObject(
                    pIpsecFilterObject,
                    ppIpsecFilterData
                    );


    return(dwError);
}

DWORD
RegMarshallFilterObject(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    time_t PresentTime;


    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_FILTER_OBJECT)
                                                    );
    if (!pIpsecFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecFilterData->FilterIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecFilter");
    wcscat(szDistinguishedName, szGuid);
    pIpsecFilterObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecFilterObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecFilterData->pszIpsecName &&
        *pIpsecFilterData->pszIpsecName) {
        pIpsecFilterObject->pszIpsecName = AllocPolStr(
                                            pIpsecFilterData->pszIpsecName
                                            );
        if (!pIpsecFilterObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterData->pszDescription &&
        *pIpsecFilterData->pszDescription) {
        pIpsecFilterObject->pszDescription = AllocPolStr(
                                             pIpsecFilterData->pszDescription
                                             );
        if (!pIpsecFilterObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecFilterObject->pszIpsecID = AllocPolStr(
                                            szGuid
                                            );
    if (!pIpsecFilterObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecFilterObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallFilterBuffer(
                    pIpsecFilterData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->pIpsecData  = pBuffer;

    pIpsecFilterObject->dwIpsecDataLen = dwBufferLen;

    time(&PresentTime);

    pIpsecFilterObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecFilterObject = pIpsecFilterObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    *ppIpsecFilterObject = NULL;
    goto cleanup;
}


DWORD
MarshallFilterBuffer(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pMem = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC  pIpsecFilterSpec = NULL;
    DWORD i = 0;
    DWORD dwNumBytesAdvanced = 0;
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    LPBYTE pCurrentPos = NULL;
    PSPEC_BUFFER pSpecBuffer = NULL;
    DWORD dwSpecSize = 0;
    DWORD dwTotalSize = 0;
    DWORD dwEffectiveSize = 0;

    // {80DC20B5-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_FILTER_BLOB =
    { 0x80dc20b5, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };


    //
    // Advance by the GUID
    //

    dwTotalSize += sizeof(GUID);


    //
    // Advance by a DWORD - Total size of the buffer.
    //

    dwTotalSize += sizeof(DWORD);

    //
    // Advance by a DWORD - this is dwNumFilterSpecs;
    //

    dwTotalSize += sizeof(DWORD);

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;

    pSpecBuffer = (PSPEC_BUFFER)AllocPolMem(
                        sizeof(SPEC_BUFFER)*dwNumFilterSpecs
                        );
    if (!pSpecBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNumFilterSpecs;i++){

        dwError = MarshallFilterSpecBuffer(
                        *(pIpsecFilterData->ppFilterSpecs + i),
                        &pMem,
                        &dwSpecSize
                        );
        BAIL_ON_WIN32_ERROR(dwError);

        dwTotalSize += dwSpecSize;

        //
        // Fill in the spec size information
        //

        (pSpecBuffer + i)->dwSize = dwSpecSize;
        (pSpecBuffer + i)->pMem = pMem;

    }

    dwTotalSize++;

    pBuffer = AllocPolMem(dwTotalSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pCurrentPos = pBuffer;

    //
    // Copy the GUID
    //
    memcpy(pCurrentPos, &GUID_IPSEC_FILTER_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    dwEffectiveSize = dwTotalSize - sizeof(GUID) - sizeof(DWORD) - 1;

    memcpy(pCurrentPos, &dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, &dwNumFilterSpecs, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);


    for (i = 0; i < dwNumFilterSpecs; i++) {

        pMem = (pSpecBuffer + i)->pMem;
        dwSpecSize = (pSpecBuffer + i)->dwSize;

        memcpy(pCurrentPos, pMem, dwSpecSize);
        pCurrentPos += dwSpecSize;

    }

    *ppBuffer = pBuffer;
    *pdwBufferLen = dwTotalSize;

cleanup:

    if (pSpecBuffer) {
        FreeSpecBuffer(
            pSpecBuffer,
            dwNumFilterSpecs
            );
    }

    return(dwError);

error:

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppBuffer = NULL;
    *pdwBufferLen = 0;

    goto cleanup;
}


DWORD
MarshallFilterSpecBuffer(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec,
    LPBYTE * ppMem,
    DWORD * pdwSize
    )
{
    DWORD dwSrcDNSNameLen = 0;
    DWORD dwDestDNSNameLen = 0;
    DWORD dwDescriptionLen = 0;

    LPBYTE pMem = NULL;
    LPBYTE pCurrentPos = NULL;

    DWORD dwSize = 0;
    DWORD dwError = 0;


    dwSize += sizeof(DWORD);

    if (pIpsecFilterSpec->pszSrcDNSName && 
        *pIpsecFilterSpec->pszSrcDNSName) {
        dwSrcDNSNameLen = (wcslen(pIpsecFilterSpec->pszSrcDNSName) + 1)
                          *sizeof(WCHAR);
    }
    else {
        dwSrcDNSNameLen = sizeof(WCHAR);
    }

    if (dwSrcDNSNameLen) {
        dwSize += dwSrcDNSNameLen;
    }

    dwSize += sizeof(DWORD);

    if (pIpsecFilterSpec->pszDestDNSName && 
        *pIpsecFilterSpec->pszDestDNSName) {
        dwDestDNSNameLen = (wcslen(pIpsecFilterSpec->pszDestDNSName) + 1)
                          *sizeof(WCHAR);
    }
    else {
        dwDestDNSNameLen = sizeof(WCHAR);
    }

    if (dwDestDNSNameLen) {
        dwSize += dwDestDNSNameLen;
    }

    dwSize += sizeof(DWORD);

    if (pIpsecFilterSpec->pszDescription && 
        *pIpsecFilterSpec->pszDescription) {
        dwDescriptionLen = (wcslen(pIpsecFilterSpec->pszDescription) + 1)
                           *sizeof(WCHAR);
    }
    else {
        dwDescriptionLen = sizeof(WCHAR);
    }

    if (dwDescriptionLen) {
        dwSize += dwDescriptionLen;
    }

    //
    // Filter Spec GUID
    //

    dwSize += sizeof(GUID);

    //
    // dwMirrorFlag
    //
    dwSize += sizeof(DWORD);

    dwSize += sizeof(IPSEC_FILTER);


    pMem = (LPBYTE)AllocPolMem(dwSize);
    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    pCurrentPos = pMem;

    memcpy(pCurrentPos, &(dwSrcDNSNameLen), sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pIpsecFilterSpec->pszSrcDNSName &&
        *pIpsecFilterSpec->pszSrcDNSName) {
        memcpy(pCurrentPos, pIpsecFilterSpec->pszSrcDNSName, dwSrcDNSNameLen);
    }
    pCurrentPos += dwSrcDNSNameLen;

    memcpy(pCurrentPos, &(dwDestDNSNameLen), sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pIpsecFilterSpec->pszDestDNSName &&
        *pIpsecFilterSpec->pszDestDNSName) {
        memcpy(pCurrentPos, pIpsecFilterSpec->pszDestDNSName, dwDestDNSNameLen);
    }
    pCurrentPos += dwDestDNSNameLen;


    memcpy(pCurrentPos, &(dwDescriptionLen), sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pIpsecFilterSpec->pszDescription &&
        *pIpsecFilterSpec->pszDescription) {
        memcpy(pCurrentPos, pIpsecFilterSpec->pszDescription, dwDescriptionLen);
    }
    pCurrentPos += dwDescriptionLen;

    memcpy(pCurrentPos, &(pIpsecFilterSpec->FilterSpecGUID), sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    memcpy(pCurrentPos, &(pIpsecFilterSpec->dwMirrorFlag), sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, &(pIpsecFilterSpec->Filter), sizeof(IPSEC_FILTER));

    *ppMem = pMem;
    *pdwSize = dwSize;

    return(dwError);

error:

    *ppMem = NULL;
    *pdwSize = 0;
    return(dwError);
}


DWORD
RegGetFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    WCHAR szIpsecFilterName[MAX_PATH];
    LPWSTR pszFilterName = NULL;

    szIpsecFilterName[0] = L'\0';
    wcscpy(szIpsecFilterName, L"ipsecFilter");

    dwError = UuidToString(&FilterGUID, &pszFilterName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecFilterName, L"{");
    wcscat(szIpsecFilterName, pszFilterName);
    wcscat(szIpsecFilterName, L"}");

    dwError =UnMarshallRegistryFilterObject(
                hRegistryKey,
                pszIpsecRootContainer,
                szIpsecFilterName,
                REG_RELATIVE_NAME,
                &pIpsecFilterObject
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUnmarshallFilterData(
                    pIpsecFilterObject,
                    &pIpsecFilterData
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
                pIpsecFilterObject
                );

    }

    if (pszFilterName) {
        RpcStringFree(&pszFilterName);
    }

    *ppIpsecFilterData = pIpsecFilterData;

    return(dwError);
}


VOID
FreeSpecBuffer(
    PSPEC_BUFFER pSpecBuffer,
    DWORD dwNumFilterSpecs
    )
{
    DWORD i = 0;

    if (pSpecBuffer) {
        for (i = 0; i < dwNumFilterSpecs; i++) {
            if ((pSpecBuffer+i)->pMem) {
                FreePolMem((pSpecBuffer+i)->pMem);
            }
        }
        FreePolMem(pSpecBuffer);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\import.h ===
DWORD
ImportPoliciesFromFile(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    );


DWORD
DeleteDuplicatePolicyData(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    );


DWORD
IPSecDeletePolicy(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );


DWORD
RegDeletePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID PolicyGUID
    );


DWORD
DirDeletePolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier
    );


DWORD
DirDeleteDynamicDefaultNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\init.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation
All rights reserved

Module Name:

    init.c

Abstract:

    Holds initialization code for polstore.dll

Author:

Environment:

    User Mode

Revision History:
--*/


#include "precomp.h"

HANDLE hInst;


BOOL
InitializeDll(
    IN PVOID hmod,
    IN DWORD Reason,
    IN PCONTEXT pctx OPTIONAL)
{
    DBG_UNREFERENCED_PARAMETER(pctx);

    switch (Reason) {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls((HMODULE)hmod);
        hInst = hmod;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\isakmp-d.h ===
DWORD
DirEnumISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
DirEnumISAKMPObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
DirSetISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

DWORD
DirSetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );

DWORD
DirCreateISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

DWORD
DirCreateISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );

DWORD
DirDeleteISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    );

DWORD
DirMarshallAddISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirMarshallSetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
GenerateAllISAKMPsQuery(
    LPWSTR * ppszISAKMPString
    );

DWORD
DirUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
DirMarshallISAKMPObject(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    );

DWORD
DirGetISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
DirGetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    );

DWORD
GenerateSpecificISAKMPQuery(
    GUID ISAKMPIdentifier,
    LPWSTR * ppszISAKMPString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\isakmp-f.h ===
DWORD
ExportISAKMPDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    );

DWORD
ImportISAKMPDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\isakmp-f.c ===
#include "precomp.h"


DWORD
ExportISAKMPDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPObjects = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    dwError = IPSecEnumISAKMPData(
                  hSrcPolicyStore,
                  &ppIpsecISAKMPData,
                  &dwNumISAKMPObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        pIpsecISAKMPData = *(ppIpsecISAKMPData + i);

        dwError = RegCreateISAKMPData(
                      pDesPolicyStore->hRegistryKey,
                      pDesPolicyStore->pszIpsecRootContainer,
                      pIpsecISAKMPData
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecISAKMPData) {
        FreeMulIpsecISAKMPData(
            ppIpsecISAKMPData,
            dwNumISAKMPObjects
            );
    }

    return (dwError);
}


DWORD
ImportISAKMPDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPObjects = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    dwError = RegEnumISAKMPData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecISAKMPData,
                  &dwNumISAKMPObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        pIpsecISAKMPData = *(ppIpsecISAKMPData + i);

        dwError = IPSecCreateISAKMPData(
                      hDesPolicyStore,
                      pIpsecISAKMPData
                      );
        if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
            dwError = IPSecSetISAKMPData(
                          hDesPolicyStore,
                          pIpsecISAKMPData
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecISAKMPData) {
        FreeMulIpsecISAKMPData(
            ppIpsecISAKMPData,
            dwNumISAKMPObjects
            );
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\isakmp-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       isakmp-r.c
//
//  Contents:   ISAKMP management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR ISAKMPDNAttributes[];


DWORD
RegEnumISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = RegEnumISAKMPObjects(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    &ppIpsecISAKMPObjects,
                    &dwNumISAKMPObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumISAKMPObjects) {
        ppIpsecISAKMPData = (PIPSEC_ISAKMP_DATA *) AllocPolMem(
                        dwNumISAKMPObjects*sizeof(PIPSEC_ISAKMP_DATA));
        if (!ppIpsecISAKMPData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError = RegUnmarshallISAKMPData(
                        *(ppIpsecISAKMPObjects + i),
                        &pIpsecISAKMPData
                        );
        if (!dwError) {
            *(ppIpsecISAKMPData + j) = pIpsecISAKMPData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecISAKMPData) {
            FreePolMem(ppIpsecISAKMPData);
            ppIpsecISAKMPData = NULL;
        }
    }

    *pppIpsecISAKMPData = ppIpsecISAKMPData;
    *pdwNumISAKMPObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
                ppIpsecISAKMPObjects,
                dwNumISAKMPObjects
                );
    }

    return(dwError);


error:

    if (ppIpsecISAKMPData) {
        FreeMulIpsecISAKMPData(
                ppIpsecISAKMPData,
                i
                );
    }

    *pppIpsecISAKMPData = NULL;
    *pdwNumISAKMPObjects = 0;

    goto cleanup;
}

DWORD
RegEnumISAKMPObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;

    DWORD dwNumISAKMPObjectsReturned = 0;
    DWORD dwIndex = 0;
    WCHAR szISAKMPName[MAX_PATH];
    DWORD dwSize = 0;
    DWORD dwReserved = 0;

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;

    while (1) {

        dwSize = MAX_PATH;
        dwReserved = 0;
        szISAKMPName[0] = L'\0';

        dwError = RegEnumKeyExW(
                        hRegistryKey,
                        dwIndex,
                        szISAKMPName,
                        &dwSize,
                        NULL,
                        NULL,
                        0,
                        0
                        );
        if (dwError == ERROR_NO_MORE_ITEMS) {
            break;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        if (!wcsstr(szISAKMPName, L"ipsecISAKMPPolicy")) {
            dwIndex++;
            continue;
        }

        pIpsecISAKMPObject = NULL;

        dwError =UnMarshallRegistryISAKMPObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    szISAKMPName,
                    REG_RELATIVE_NAME,
                    &pIpsecISAKMPObject
                    );
        if (dwError == ERROR_SUCCESS) {

            dwError = ReallocatePolMem(
                          (LPVOID *) &ppIpsecISAKMPObjects,
                          sizeof(PIPSEC_ISAKMP_OBJECT)*(dwNumISAKMPObjectsReturned),
                          sizeof(PIPSEC_ISAKMP_OBJECT)*(dwNumISAKMPObjectsReturned + 1)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            *(ppIpsecISAKMPObjects + dwNumISAKMPObjectsReturned) = pIpsecISAKMPObject;

            dwNumISAKMPObjectsReturned++;

        }

        dwIndex++;

    }

    *pppIpsecISAKMPObjects = ppIpsecISAKMPObjects;
    *pdwNumISAKMPObjects = dwNumISAKMPObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:

    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
            ppIpsecISAKMPObjects,
            dwNumISAKMPObjectsReturned
            );
    }

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;


    return(dwError);
}


DWORD
RegSetISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;

    dwError = RegMarshallISAKMPObject(
                    pIpsecISAKMPData,
                    &pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetISAKMPObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegBackPropIncChangesForISAKMPToPolicy(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  pIpsecISAKMPObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecISAKMPObject);
    }

    return(dwError);
}


DWORD
RegSetISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    DWORD dwError = 0;

    dwError = PersistISAKMPObject(
                    hRegistryKey,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegCreateISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;

    dwError = RegMarshallISAKMPObject(
                        pIpsecISAKMPData,
                        &pIpsecISAKMPObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreateISAKMPObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
                pIpsecISAKMPObject
                );
    }

    return(dwError);
}

DWORD
RegCreateISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{

    DWORD dwError = 0;

    dwError = PersistISAKMPObject(
                    hRegistryKey,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegDeleteISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"ipsecISAKMPPolicy");
    wcscat(szDistinguishedName, szGuid);

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
RegUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallISAKMPObject(
                    pIpsecISAKMPObject,
                    ppIpsecISAKMPData
                    );


    return(dwError);
}

DWORD
RegMarshallISAKMPObject(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    time_t PresentTime;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_ISAKMP_OBJECT)
                                                    );
    if (!pIpsecISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecISAKMPData->ISAKMPIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecISAKMPPolicy");
    wcscat(szDistinguishedName, szGuid);
    pIpsecISAKMPObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName.
    // ISAKMPData doesn't have a name.
    //

    pIpsecISAKMPObject->pszIpsecName = NULL;

    /*
    if (pIpsecISAKMPData->pszIpsecName &&
        *pIpsecISAKMPData->pszIpsecName) {
        pIpsecISAKMPObject->pszIpsecName = AllocPolStr(
                                           pIpsecISAKMPData->pszIpsecName
                                           );
        if (!pIpsecISAKMPObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    */

    //
    // Fill in the ipsecID
    //

    pIpsecISAKMPObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecISAKMPObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecISAKMPObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallISAKMPBuffer(
                    pIpsecISAKMPData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->pIpsecData  = pBuffer;

    pIpsecISAKMPObject->dwIpsecDataLen = dwBufferLen;

    time(&PresentTime);

    pIpsecISAKMPObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecISAKMPObject = pIpsecISAKMPObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    *ppIpsecISAKMPObject = NULL;
    goto cleanup;
}


DWORD
MarshallISAKMPBuffer(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pCurrentPos = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwSize = 0;
    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwNumISAKMPSecurityMethods = 0;
    PCRYPTO_BUNDLE pSecurityMethods = NULL;
    PCRYPTO_BUNDLE pSecurityMethod = NULL;
    ISAKMP_POLICY * pISAKMPPolicy = NULL;
    DWORD dwEffectiveSize = 0;

    // {80DC20B8-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_ISAKMP_POLICY_BLOB =
    { 0x80dc20b8, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };


    dwNumISAKMPSecurityMethods =pIpsecISAKMPData->dwNumISAKMPSecurityMethods;
    pISAKMPPolicy = &(pIpsecISAKMPData->ISAKMPPolicy);
    pSecurityMethods = pIpsecISAKMPData->pSecurityMethods;

    dwSize += sizeof(GUID);

    dwSize += sizeof(DWORD);

    dwSize += sizeof(ISAKMP_POLICY);

    dwSize += sizeof(DWORD);

    dwSize += sizeof(CRYPTO_BUNDLE)*dwNumISAKMPSecurityMethods;
    dwSize++;

    pBuffer = (LPBYTE)AllocPolMem(dwSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pBuffer;

    memcpy(pCurrentPos, &GUID_IPSEC_ISAKMP_POLICY_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    dwEffectiveSize = dwSize - sizeof(GUID) - sizeof(DWORD) - 1;

    memcpy(pCurrentPos, &dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, pISAKMPPolicy, sizeof(ISAKMP_POLICY));
    pCurrentPos += sizeof(ISAKMP_POLICY);

    memcpy(pCurrentPos, &dwNumISAKMPSecurityMethods, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    for (i = 0; i < dwNumISAKMPSecurityMethods; i++) {

        pSecurityMethod = pSecurityMethods + i;
        memcpy(pCurrentPos, pSecurityMethod, sizeof(CRYPTO_BUNDLE));
        pCurrentPos += sizeof(CRYPTO_BUNDLE);

    }

    *ppBuffer = pBuffer;
    *pdwBufferLen = dwSize;

    return(dwError);

error:

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppBuffer = NULL;
    *pdwBufferLen = 0;
    return(dwError);
}


DWORD
RegGetISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    WCHAR szIpsecISAKMPName[MAX_PATH];
    LPWSTR pszISAKMPName = NULL;

    szIpsecISAKMPName[0] = L'\0';
    wcscpy(szIpsecISAKMPName, L"ipsecISAKMPPolicy");

    dwError = UuidToString(&ISAKMPGUID, &pszISAKMPName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecISAKMPName, L"{");
    wcscat(szIpsecISAKMPName, pszISAKMPName);
    wcscat(szIpsecISAKMPName, L"}");


    dwError =UnMarshallRegistryISAKMPObject(
                hRegistryKey,
                pszIpsecRootContainer,
                szIpsecISAKMPName,
                REG_RELATIVE_NAME,
                &pIpsecISAKMPObject
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUnmarshallISAKMPData(
                    pIpsecISAKMPObject,
                    &pIpsecISAKMPData
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
                pIpsecISAKMPObject
                );
    }

    if (pszISAKMPName) {
        RpcStringFree(&pszISAKMPName);
    }

    *ppIpsecISAKMPData = pIpsecISAKMPData;

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\isakmp-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       isakmp-d.c
//
//  Contents:   ISAKMP Management for directory.
//
//
//  History:    AbhisheV
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR ISAKMPDNAttributes[];


DWORD
DirEnumISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = DirEnumISAKMPObjects(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    &ppIpsecISAKMPObjects,
                    &dwNumISAKMPObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumISAKMPObjects) {
        ppIpsecISAKMPData = (PIPSEC_ISAKMP_DATA *) AllocPolMem(
                            dwNumISAKMPObjects*sizeof(PIPSEC_ISAKMP_DATA)
                            );
        if (!ppIpsecISAKMPData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError = DirUnmarshallISAKMPData(
                        *(ppIpsecISAKMPObjects + i),
                        &pIpsecISAKMPData
                        );
        if (!dwError) {
            *(ppIpsecISAKMPData + j) = pIpsecISAKMPData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecISAKMPData) {
            FreePolMem(ppIpsecISAKMPData);
            ppIpsecISAKMPData = NULL;
        }
    }

    *pppIpsecISAKMPData = ppIpsecISAKMPData;
    *pdwNumISAKMPObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
            ppIpsecISAKMPObjects,
            dwNumISAKMPObjects
            );
    }

    return(dwError);

error:

    if (ppIpsecISAKMPData) {
        FreeMulIpsecISAKMPData(
                ppIpsecISAKMPData,
                i
                );
    }

    *pppIpsecISAKMPData = NULL;
    *pdwNumISAKMPObjects = 0;

    goto cleanup;
}


DWORD
DirEnumISAKMPObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    )
{
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszISAKMPString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;

    DWORD dwNumISAKMPObjectsReturned = 0;

    dwError = GenerateAllISAKMPsQuery(
                    &pszISAKMPString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszISAKMPString,
                  ISAKMPDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecISAKMPObjects  = (PIPSEC_ISAKMP_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_ISAKMP_OBJECT)*dwCount
                                            );
    if (!ppIpsecISAKMPObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        } else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }

        dwError = UnMarshallISAKMPObject(
                      hLdapBindHandle,
                      e,
                      &pIpsecISAKMPObject
                      );

        if (dwError == ERROR_SUCCESS) {
            *(ppIpsecISAKMPObjects + dwNumISAKMPObjectsReturned) = pIpsecISAKMPObject;
            dwNumISAKMPObjectsReturned++;
        }

    }

    *pppIpsecISAKMPObjects = ppIpsecISAKMPObjects;
    *pdwNumISAKMPObjects = dwNumISAKMPObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
            ppIpsecISAKMPObjects,
            dwNumISAKMPObjectsReturned
            );
    }

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;

    goto cleanup;
}


DWORD
DirSetISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;

    dwError = DirMarshallISAKMPObject(
                    pIpsecISAKMPData,
                    pszIpsecRootContainer,
                    &pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetISAKMPObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirBackPropIncChangesForISAKMPToPolicy(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecISAKMPData->ISAKMPIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecISAKMPObject);
    }

    return(dwError);
}


DWORD
DirSetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetISAKMPObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecISAKMPObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecISAKMPObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }


    return(dwError);
}


DWORD
DirCreateISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;

    dwError = DirMarshallISAKMPObject(
                        pIpsecISAKMPData,
                        pszIpsecRootContainer,
                        &pIpsecISAKMPObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreateISAKMPObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    return(dwError);
}


DWORD
DirCreateISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddISAKMPObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecISAKMPObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecISAKMPObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"CN=ipsecISAKMPPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    wcscat(szDistinguishedName, pszIpsecRootContainer);

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
DirMarshallAddISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 5;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecISAKMPObject->pszIpsecName ||
        !*pIpsecISAKMPObject->pszIpsecName) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecISAKMPPolicy",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecISAKMPObject->pszIpsecName &&
        *pIpsecISAKMPObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecISAKMPObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecISAKMPObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecISAKMPObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecISAKMPObject->pIpsecData,
                    pIpsecISAKMPObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirMarshallSetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 4;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecISAKMPObject->pszIpsecName ||
        !*pIpsecISAKMPObject->pszIpsecName) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecISAKMPObject->pszIpsecName &&
        *pIpsecISAKMPObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecISAKMPObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecISAKMPObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecISAKMPObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecISAKMPObject->pIpsecData,
                    pIpsecISAKMPObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
GenerateAllISAKMPsQuery(
    LPWSTR * ppszISAKMPString
    )
{
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszISAKMPString = NULL;


    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(objectclass=ipsecISAKMPPolicy)");

    pszISAKMPString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszISAKMPString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Now fill in the buffer
    //

    wcscpy(pszISAKMPString, L"(objectclass=ipsecISAKMPPolicy)");

    *ppszISAKMPString = pszISAKMPString;

    return(0);

error:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    *ppszISAKMPString = NULL;

    return(dwError);
}


DWORD
DirUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallISAKMPObject(
                  pIpsecISAKMPObject,
                  ppIpsecISAKMPData
                  );

    return(dwError);
}


DWORD
DirMarshallISAKMPObject(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_ISAKMP_OBJECT)
                                                    );
    if (!pIpsecISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecISAKMPData->ISAKMPIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecISAKMPPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    wcscat(szDistinguishedName, pszIpsecRootContainer);

    pIpsecISAKMPObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName.
    // ISAKMPData doesn't have a name.
    //

    pIpsecISAKMPObject->pszIpsecName = NULL;

    /*
    if (pIpsecISAKMPData->pszIpsecName &&
        *pIpsecISAKMPData->pszIpsecName) {
        pIpsecISAKMPObject->pszIpsecName = AllocPolStr(
                                           pIpsecISAKMPData->pszIpsecName
                                           );
        if (!pIpsecISAKMPObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    */

    //
    // Fill in the ipsecID
    //

    pIpsecISAKMPObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecISAKMPObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecISAKMPObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallISAKMPBuffer(
                    pIpsecISAKMPData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->pIpsecData  = pBuffer;

    pIpsecISAKMPObject->dwIpsecDataLen = dwBufferLen;

    pIpsecISAKMPObject->dwWhenChanged = 0;

    *ppIpsecISAKMPObject = pIpsecISAKMPObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    *ppIpsecISAKMPObject = NULL;
    goto cleanup;
}


DWORD
DirGetISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    dwError = DirGetISAKMPObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  ISAKMPGUID,
                  &pIpsecISAKMPObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUnmarshallISAKMPData(
                  pIpsecISAKMPObject,
                  &pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecISAKMPData = pIpsecISAKMPData;

cleanup:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    return(dwError);

error:

    *ppIpsecISAKMPData = NULL;

    goto cleanup;
}


DWORD
DirGetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszISAKMPString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;


    dwError = GenerateSpecificISAKMPQuery(
                  ISAKMPGUID,
                  &pszISAKMPString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszISAKMPString,
                  ISAKMPDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallISAKMPObject(
                  hLdapBindHandle,
                  e,
                  &pIpsecISAKMPObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecISAKMPObject = pIpsecISAKMPObject;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    *ppIpsecISAKMPObject = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificISAKMPQuery(
    GUID ISAKMPIdentifier,
    LPWSTR * ppszISAKMPString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszISAKMPString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecISAKMPPolicy");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecISAKMPPolicy)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszISAKMPString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszISAKMPString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszISAKMPString, L"(&(objectclass=ipsecISAKMPPolicy)");
    wcscat(pszISAKMPString, L"(");
    wcscat(pszISAKMPString, szCommonName);
    wcscat(pszISAKMPString, L"))");

    *ppszISAKMPString = pszISAKMPString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    *ppszISAKMPString = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\ldaputils.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       ldaputils.c
//
//  Contents:   Utilities for LDAP.
//
//
//  History:    KrishnaG
//              AbhisheV
//
//----------------------------------------------------------------------------


#include "precomp.h"


void
FreeLDAPModWs(
    struct ldapmodW ** AttributeList
    )
{
    DWORD i = 0;
    PLDAPModW attr = NULL;
    DWORD dwValCount = 0;
    PLDAP_BERVAL berValue = NULL;
    PWCHAR strValue = NULL;


    if (AttributeList == NULL) {
        return;
    }

    while (AttributeList[i] != NULL) {

        attr = AttributeList[i++];

        if (attr->mod_type != NULL) {
            FreePolStr(attr->mod_type);
        }

        if (attr->mod_op & LDAP_MOD_BVALUES) {

            if (attr->mod_vals.modv_bvals != NULL) {

                dwValCount = 0;

                while (attr->mod_vals.modv_bvals[dwValCount]) {

                    berValue = attr->mod_vals.modv_bvals[dwValCount++];
                    FreePolMem(berValue);

                }

                FreePolMem(attr->mod_vals.modv_bvals);

            }

        } else {

            if (attr->mod_vals.modv_strvals != NULL) {

                dwValCount = 0;

                while (attr->mod_vals.modv_strvals[dwValCount]) {

                    strValue = attr->mod_vals.modv_strvals[dwValCount];
                    FreePolMem(strValue);
                    dwValCount++;

                }

                FreePolMem(attr->mod_vals.modv_strvals);

            }

        }

    }

    FreePolMem(AttributeList[0]);

    FreePolMem(AttributeList);

    return;
}


DWORD
AllocateLDAPStringValue(
    LPWSTR pszString,
    PLDAPOBJECT * ppLdapObject
    )
{
    PLDAPOBJECT pLdapObject = NULL;
    DWORD dwError = 0;
    LPWSTR pszNewString = NULL;

    pLdapObject = (PLDAPOBJECT)AllocPolMem(
                                    (1 + 1)*sizeof(LDAPOBJECT)
                                    );
    if (!pLdapObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AllocatePolString(
                    pszString,
                    &pszNewString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    LDAPOBJECT_STRING(pLdapObject) = pszNewString;

    *ppLdapObject = pLdapObject;

    return(dwError);

error:

    *ppLdapObject = NULL;
    if (pLdapObject) {
        FreePolMem(
            pLdapObject
            );
    }

    return(dwError);
}


DWORD
AllocateLDAPBinaryValue(
    LPBYTE pByte,
    DWORD dwNumBytes,
    PLDAPOBJECT * ppLdapObject
    )
{
    PLDAPOBJECT pLdapObject = NULL;
    DWORD dwError = 0;
    LPBYTE pNewMem = NULL;

    pLdapObject = (PLDAPOBJECT)AllocPolMem(
                                    (1 + 1)*sizeof(LDAPOBJECT)
                                    );
    if (!pLdapObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    LDAPOBJECT_BERVAL(pLdapObject) =
        (struct berval *) AllocPolMem( sizeof(struct berval) + dwNumBytes );

    if (!LDAPOBJECT_BERVAL(pLdapObject)) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    LDAPOBJECT_BERVAL_LEN(pLdapObject) = dwNumBytes;
    LDAPOBJECT_BERVAL_VAL(pLdapObject) = (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapObject) + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapObject),
            pByte,
            dwNumBytes );

    *ppLdapObject = pLdapObject;

    return(dwError);

error:

    *ppLdapObject = NULL;
    if (pLdapObject) {
        FreePolMem(
            pLdapObject
            );
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\isakmp-r.h ===
DWORD
RegEnumISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    );


DWORD
RegEnumISAKMPObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    );


DWORD
RegSetISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );


DWORD
RegSetISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );


DWORD
RegCreateISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );


DWORD
RegCreateISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );


DWORD
RegDeleteISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    );


DWORD
RegUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
RegMarshallISAKMPObject(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    );


DWORD
MarshallISAKMPBuffer(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );


DWORD
RegGetISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\memory.c ===
#include "precomp.h"


LPVOID
IPSecAllocPolMem(
    DWORD cb
    )
{
    return AllocPolMem(cb);
}


BOOL
IPSecFreePolMem(
    LPVOID pMem
    )
{
    return FreePolMem(pMem);
}


LPWSTR
IPSecAllocPolStr(
    LPCWSTR pStr
    )
{
    return AllocPolStr(pStr);
}


BOOL
IPSecFreePolStr(
    LPWSTR pStr
    )
{
    return FreePolStr(pStr);
}


DWORD
IPSecReallocatePolMem(
    LPVOID * ppOldMem,
    DWORD cbOld,
    DWORD cbNew
    )
{
    return ReallocatePolMem(ppOldMem, cbOld, cbNew);
}


BOOL
IPSecReallocatePolStr(
    LPWSTR *ppStr,
    LPWSTR pStr
    )
{
    return ReallocPolStr(ppStr, pStr);
}


void
IPSecFreePolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    FreeIpsecPolicyData(pIpsecPolicyData);
}


void
IPSecFreeNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    FreeIpsecNegPolData(pIpsecNegPolData);
}


void
IPSecFreeFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    FreeIpsecFilterData(pIpsecFilterData);
}


void
IPSecFreeISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    FreeIpsecISAKMPData(pIpsecISAKMPData);
}


void
IPSecFreeNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    FreeIpsecNFAData(pIpsecNFAData);
}


DWORD
IPSecCopyPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    return CopyIpsecPolicyData(pIpsecPolicyData, ppIpsecPolicyData);
}


DWORD
IPSecCopyNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    return CopyIpsecNegPolData(pIpsecNegPolData, ppIpsecNegPolData);
}


DWORD
IPSecCopyFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    return CopyIpsecFilterData(pIpsecFilterData, ppIpsecFilterData);
}


DWORD
IPSecCopyFilterSpec(
    PIPSEC_FILTER_SPEC   pFilterSpecs,
    PIPSEC_FILTER_SPEC * ppFilterSpecs
    )
{
    return CopyIpsecFilterSpec(pFilterSpecs, ppFilterSpecs);
}


DWORD
IPSecCopyISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    return CopyIpsecISAKMPData(pIpsecISAKMPData, ppIpsecISAKMPData);
}


DWORD
IPSecCopyNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    return CopyIpsecNFAData(pIpsecNFAData, ppIpsecNFAData);
}


DWORD
IPSecCopyAuthMethod(
    PIPSEC_AUTH_METHOD   pAuthMethod,
    PIPSEC_AUTH_METHOD * ppAuthMethod
    )
{
    return CopyIpsecAuthMethod(pAuthMethod, ppAuthMethod);
}


void
IPSecFreeMulPolicyData(
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    )
{
    FreeMulIpsecPolicyData(ppIpsecPolicyData, dwNumPolicyObjects);
}


void
IPSecFreeMulNegPolData(
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData,
    DWORD dwNumNegPolObjects
    )
{
    FreeMulIpsecNegPolData(ppIpsecNegPolData, dwNumNegPolObjects);
}


void
IPSecFreeMulFilterData(
    PIPSEC_FILTER_DATA * ppIpsecFilterData,
    DWORD dwNumFilterObjects
    )
{
    FreeMulIpsecFilterData(ppIpsecFilterData, dwNumFilterObjects);
}


void
IPSecFreeFilterSpecs(
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs,
    DWORD dwNumFilterSpecs
    )
{
    FreeIpsecFilterSpecs(ppIpsecFilterSpecs, dwNumFilterSpecs);
}


void
IPSecFreeFilterSpec(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec
    )
{
    FreeIpsecFilterSpec(pIpsecFilterSpec);
}


void
IPSecFreeMulISAKMPData(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumISAKMPObjects
    )
{
    FreeMulIpsecISAKMPData(ppIpsecISAKMPData, dwNumISAKMPObjects);
}


void
IPSecFreeMulNFAData(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFAObjects
    )
{
    FreeMulIpsecNFAData(ppIpsecNFAData, dwNumNFAObjects);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\negpols-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       negpols-d.c
//
//  Contents:   NegPol management for directory.
//
//
//  History:    KrishnaG
//              AbhisheV
//
//----------------------------------------------------------------------------

#include "precomp.h"


extern LPWSTR NegPolDNAttributes[];

DWORD
DirEnumNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData = NULL;
    DWORD dwNumNegPolObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = DirEnumNegPolObjects(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    &ppIpsecNegPolObjects,
                    &dwNumNegPolObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumNegPolObjects) {
        ppIpsecNegPolData = (PIPSEC_NEGPOL_DATA *) AllocPolMem(
                            dwNumNegPolObjects*sizeof(PIPSEC_NEGPOL_DATA));
        if (!ppIpsecNegPolData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError = DirUnmarshallNegPolData(
                        *(ppIpsecNegPolObjects + i),
                        &pIpsecNegPolData
                        );
        if (!dwError) {
            *(ppIpsecNegPolData + j) = pIpsecNegPolData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecNegPolData) {
            FreePolMem(ppIpsecNegPolData);
            ppIpsecNegPolData = NULL;
        }
    }

    *pppIpsecNegPolData = ppIpsecNegPolData;
    *pdwNumNegPolObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
                ppIpsecNegPolObjects,
                dwNumNegPolObjects
                );
    }

    return(dwError);

error:

    if (ppIpsecNegPolData) {
        FreeMulIpsecNegPolData(
                ppIpsecNegPolData,
                i
                );
    }

    *pppIpsecNegPolData = NULL;
    *pdwNumNegPolObjects = 0;

    goto cleanup;
}


DWORD
DirEnumNegPolObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    )
{
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszNegPolString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumNegPolObjectsReturned = 0;

    dwError = GenerateAllNegPolsQuery(
                    &pszNegPolString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNegPolString,
                  NegPolDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecNegPolObjects  = (PIPSEC_NEGPOL_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NEGPOL_OBJECT)*dwCount
                                            );
    if (!ppIpsecNegPolObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        } else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }

        dwError =UnMarshallNegPolObject(
                     hLdapBindHandle,
                     e,
                     &pIpsecNegPolObject
                     );
        if (dwError == ERROR_SUCCESS) {
            *(ppIpsecNegPolObjects + dwNumNegPolObjectsReturned) = pIpsecNegPolObject;
            dwNumNegPolObjectsReturned++;
        }

    }

    *pppIpsecNegPolObjects = ppIpsecNegPolObjects;
    *pdwNumNegPolObjects = dwNumNegPolObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
            ppIpsecNegPolObjects,
            dwNumNegPolObjectsReturned
            );
    }

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;

    goto cleanup;
}


DWORD
DirSetNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    dwError = DirMarshallNegPolObject(
                    pIpsecNegPolData,
                    pszIpsecRootContainer,
                    &pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetNegPolObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirBackPropIncChangesForNegPolToNFA(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecNegPolData->NegPolIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(pIpsecNegPolObject);
    }

    return(dwError);
}


DWORD
DirSetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetNegPolObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecNegPolObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecNegPolObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirCreateNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    dwError = DirMarshallNegPolObject(
                        pIpsecNegPolData,
                        pszIpsecRootContainer,
                        &pIpsecNegPolObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreateNegPolObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }

    return(dwError);
}


DWORD
DirCreateNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddNegPolObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecNegPolObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecNegPolObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"CN=ipsecNegotiationPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    wcscat(szDistinguishedName, pszIpsecRootContainer);

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
DirMarshallAddNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 8;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecNegPolObject->pszIpsecName ||
        !*pIpsecNegPolObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecNegPolObject->pszDescription ||
        !*pIpsecNegPolObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecNegotiationPolicy",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecNegPolObject->pszIpsecName &&
        *pIpsecNegPolObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNegPolObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecNegPolObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecNegPolObject->pIpsecData,
                    pIpsecNegPolObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecNegPolObject->pszDescription &&
        *pIpsecNegPolObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNegPolObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 6. ipsecNegotiationPolicyAction
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyAction",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecNegPolAction,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 7. ipsecNegotiationPolicyType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecNegPolType,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirMarshallSetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 7;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecNegPolObject->pszIpsecName ||
        !*pIpsecNegPolObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecNegPolObject->pszDescription ||
        !*pIpsecNegPolObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecNegPolObject->pszIpsecName &&
        *pIpsecNegPolObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNegPolObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecNegPolObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecNegPolObject->pIpsecData,
                    pIpsecNegPolObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecNegPolObject->pszDescription &&
        *pIpsecNegPolObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNegPolObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 6. ipsecNegotiationPolicyAction
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyAction",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecNegPolAction,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 7. ipsecNegotiationPolicyType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecNegPolType,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
GenerateAllNegPolsQuery(
    LPWSTR * ppszNegPolString
    )
{
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszNegPolString = NULL;


    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(objectclass=ipsecNegotiationPolicy)");

    pszNegPolString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszNegPolString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Now fill in the buffer
    //

    wcscpy(pszNegPolString, L"(objectclass=ipsecNegotiationPolicy)");

    *ppszNegPolString = pszNegPolString;

    return(0);

error:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    *ppszNegPolString = NULL;

    return(dwError);
}


DWORD
DirUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNegPolObject(
                  pIpsecNegPolObject,
                  ppIpsecNegPolData
                  );

    return(dwError);
}


DWORD
DirMarshallNegPolObject(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszNegPolActionUuid = NULL;
    LPWSTR pszNegPolTypeUuid = NULL;
    WCHAR szGuidAction[MAX_PATH];
    WCHAR szGuidType[MAX_PATH];


    szGuidAction[0] = L'\0';
    szGuidType[0] = L'\0';
    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecNegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_NEGPOL_OBJECT)
                                                    );
    if (!pIpsecNegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecNegotiationPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    wcscat(szDistinguishedName, pszIpsecRootContainer);

    pIpsecNegPolObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecNegPolObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecNegPolData->pszIpsecName &&
        *pIpsecNegPolData->pszIpsecName) {
        pIpsecNegPolObject->pszIpsecName = AllocPolStr(
                                           pIpsecNegPolData->pszIpsecName
                                           );
        if (!pIpsecNegPolObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolData->pszDescription &&
        *pIpsecNegPolData->pszDescription) {
        pIpsecNegPolObject->pszDescription = AllocPolStr(
                                             pIpsecNegPolData->pszDescription
                                             );
        if (!pIpsecNegPolObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecNegPolObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecNegPolObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolAction,
                    &pszNegPolActionUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szGuidAction, L"{");
    wcscat(szGuidAction, pszNegPolActionUuid);
    wcscat(szGuidAction, L"}");

    pIpsecNegPolObject->pszIpsecNegPolAction = AllocPolStr(
                                                    szGuidAction
                                                    );
    if (!pIpsecNegPolObject->pszIpsecNegPolAction) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolType,
                    &pszNegPolTypeUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szGuidType, L"{");
    wcscat(szGuidType, pszNegPolTypeUuid);
    wcscat(szGuidType, L"}");

    pIpsecNegPolObject->pszIpsecNegPolType = AllocPolStr(
                                                 szGuidType
                                                 );
    if (!pIpsecNegPolObject->pszIpsecNegPolType) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecNegPolObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallNegPolBuffer(
                    pIpsecNegPolData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolObject->pIpsecData  = pBuffer;

    pIpsecNegPolObject->dwIpsecDataLen = dwBufferLen;

    pIpsecNegPolObject->dwWhenChanged = 0;

    *ppIpsecNegPolObject = pIpsecNegPolObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }
    if (pszNegPolActionUuid) {
        RpcStringFree(
            &pszNegPolActionUuid
            );
    }
    if (pszNegPolTypeUuid) {
        RpcStringFree(
            &pszNegPolTypeUuid
            );
    }

    return(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
                pIpsecNegPolObject
                );
    }

    *ppIpsecNegPolObject = NULL;
    goto cleanup;
}


DWORD
DirGetNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = DirGetNegPolObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NegPolGUID,
                  &pIpsecNegPolObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUnmarshallNegPolData(
                  pIpsecNegPolObject,
                  &pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecNegPolData = pIpsecNegPolData;

cleanup:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }

    return(dwError);

error:

    *ppIpsecNegPolData = NULL;

    goto cleanup;
}


DWORD
DirGetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszNegPolString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;


    dwError = GenerateSpecificNegPolQuery(
                  NegPolGUID,
                  &pszNegPolString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNegPolString,
                  NegPolDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallNegPolObject(
                  hLdapBindHandle,
                  e,
                  &pIpsecNegPolObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecNegPolObject = pIpsecNegPolObject;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }

    *ppIpsecNegPolObject = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificNegPolQuery(
    GUID NegPolIdentifier,
    LPWSTR * ppszNegPolString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszNegPolString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecNegotiationPolicy");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecNegotiationPolicy)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszNegPolString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszNegPolString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszNegPolString, L"(&(objectclass=ipsecNegotiationPolicy)");
    wcscat(pszNegPolString, L"(");
    wcscat(pszNegPolString, szCommonName);
    wcscat(pszNegPolString, L"))");

    *ppszNegPolString = pszNegPolString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    *ppszNegPolString = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\negpols-f.c ===
#include "precomp.h"


DWORD
ExportNegPolDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData = NULL;
    DWORD dwNumNegPolObjects = 0;
    DWORD i = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = IPSecEnumNegPolData(
                  hSrcPolicyStore,
                  &ppIpsecNegPolData,
                  &dwNumNegPolObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumNegPolObjects; i++) {

        pIpsecNegPolData = *(ppIpsecNegPolData + i);

        dwError = RegCreateNegPolData(
                      pDesPolicyStore->hRegistryKey,
                      pDesPolicyStore->pszIpsecRootContainer,
                      pIpsecNegPolData
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecNegPolData) {
        FreeMulIpsecNegPolData(
            ppIpsecNegPolData,
            dwNumNegPolObjects
            );
    }

    return (dwError);
}


DWORD
ImportNegPolDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData = NULL;
    DWORD dwNumNegPolObjects = 0;
    DWORD i = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = RegEnumNegPolData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecNegPolData,
                  &dwNumNegPolObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumNegPolObjects; i++) {

        pIpsecNegPolData = *(ppIpsecNegPolData + i);

        dwError = IPSecCreateNegPolData(
                      hDesPolicyStore,
                      pIpsecNegPolData
                      );
        if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
            dwError = IPSecSetNegPolData(
                          hDesPolicyStore,
                          pIpsecNegPolData
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecNegPolData) {
        FreeMulIpsecNegPolData(
            ppIpsecNegPolData,
            dwNumNegPolObjects
            );
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\negpols-f.h ===
DWORD
ExportNegPolDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    );

DWORD
ImportNegPolDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\negpols-d.h ===
DWORD
DirEnumNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    );

DWORD
DirEnumNegPolObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    );

DWORD
GenerateAllNegPolsQuery(
    LPWSTR * ppszNegPolString
    );

DWORD
DirSetNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
DirSetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
DirCreateNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
DirCreateNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
DirDeleteNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    );

DWORD
DirMarshallAddNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirMarshallSetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
DirMarshallNegPolObject(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    );

DWORD
DirGetNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
DirGetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    );

DWORD
GenerateSpecificNegPolQuery(
    GUID NegPolIdentifier,
    LPWSTR * ppszNegPolString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\negpols-r.h ===
DWORD
RegEnumNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    );

DWORD
RegEnumNegPolObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    );

DWORD
RegSetNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
RegSetNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
RegCreateNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
RegCreateNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
RegDeleteNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    );

DWORD
RegUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
RegMarshallNegPolObject(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    );


DWORD
MarshallNegPolBuffer(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );


DWORD
RegGetNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\negpols-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       negpols-r.c
//
//  Contents:   Negotiation Policy management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR NegPolDNAttributes[];


DWORD
RegEnumNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData = NULL;
    DWORD dwNumNegPolObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = RegEnumNegPolObjects(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    &ppIpsecNegPolObjects,
                    &dwNumNegPolObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumNegPolObjects) {
        ppIpsecNegPolData = (PIPSEC_NEGPOL_DATA *) AllocPolMem(
                            dwNumNegPolObjects*sizeof(PIPSEC_NEGPOL_DATA));
        if (!ppIpsecNegPolData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError = RegUnmarshallNegPolData(
                        *(ppIpsecNegPolObjects + i),
                        &pIpsecNegPolData
                        );
        if (!dwError) {
            *(ppIpsecNegPolData + j) = pIpsecNegPolData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecNegPolData) {
            FreePolMem(ppIpsecNegPolData);
            ppIpsecNegPolData = NULL;
        }
    }

    *pppIpsecNegPolData = ppIpsecNegPolData;
    *pdwNumNegPolObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
                ppIpsecNegPolObjects,
                dwNumNegPolObjects
                );
    }

    return(dwError);


error:

    if (ppIpsecNegPolData) {
        FreeMulIpsecNegPolData(
                ppIpsecNegPolData,
                i
                );
    }

    *pppIpsecNegPolData = NULL;
    *pdwNumNegPolObjects = 0;

    goto cleanup;
}

DWORD
RegEnumNegPolObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumNegPolObjectsReturned = 0;
    DWORD dwIndex = 0;
    WCHAR szNegPolName[MAX_PATH];
    DWORD dwSize = 0;
    DWORD dwReserved = 0;

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;

    while (1) {

        dwSize = MAX_PATH;
        dwReserved = 0;
        szNegPolName[0] = L'\0';

        dwError = RegEnumKeyExW(
                        hRegistryKey,
                        dwIndex,
                        szNegPolName,
                        &dwSize,
                        NULL,
                        NULL,
                        0,
                        0
                        );
        if (dwError == ERROR_NO_MORE_ITEMS) {
            break;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        if (!wcsstr(szNegPolName, L"ipsecNegotiationPolicy")) {
            dwIndex++;
            continue;
        }

        pIpsecNegPolObject = NULL;

        dwError =UnMarshallRegistryNegPolObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    szNegPolName,
                    REG_RELATIVE_NAME,
                    &pIpsecNegPolObject
                    );
        if (dwError == ERROR_SUCCESS) {

            dwError = ReallocatePolMem(
                          (LPVOID *) &ppIpsecNegPolObjects,
                          sizeof(PIPSEC_NEGPOL_OBJECT)*(dwNumNegPolObjectsReturned),
                          sizeof(PIPSEC_NEGPOL_OBJECT)*(dwNumNegPolObjectsReturned + 1)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            *(ppIpsecNegPolObjects + dwNumNegPolObjectsReturned) = pIpsecNegPolObject;

            dwNumNegPolObjectsReturned++;

        }

        dwIndex++;

    }

    *pppIpsecNegPolObjects = ppIpsecNegPolObjects;
    *pdwNumNegPolObjects = dwNumNegPolObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecNegPolObjects) {

        FreeIpsecNegPolObjects(
                    ppIpsecNegPolObjects,
                    dwNumNegPolObjectsReturned
                    );
    }

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;


    return(dwError);
}


DWORD
RegSetNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    dwError = RegMarshallNegPolObject(
                    pIpsecNegPolData,
                    &pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetNegPolObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegBackPropIncChangesForNegPolToNFA(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  pIpsecNegPolObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(pIpsecNegPolObject);
    }

    return(dwError);
}


DWORD
RegSetNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;

    dwError = PersistNegPolObject(
                    hRegistryKey,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegCreateNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    dwError = RegMarshallNegPolObject(
                        pIpsecNegPolData,
                        &pIpsecNegPolObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreateNegPolObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
                pIpsecNegPolObject
                );
    }

    return(dwError);
}

DWORD
RegCreateNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{

    DWORD dwError = 0;

    dwError = PersistNegPolObject(
                    hRegistryKey,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegDeleteNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"ipsecNegotiationPolicy");
    wcscat(szDistinguishedName, szGuid);

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
RegUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNegPolObject(
                    pIpsecNegPolObject,
                    ppIpsecNegPolData
                    );


    return(dwError);
}

DWORD
RegMarshallNegPolObject(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszNegPolActionUuid = NULL;
    LPWSTR pszNegPolTypeUuid = NULL;
    time_t PresentTime;
    WCHAR szGuidAction[MAX_PATH];
    WCHAR szGuidType[MAX_PATH];


    szGuidAction[0] = L'\0';
    szGuidType[0] = L'\0';
    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecNegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_NEGPOL_OBJECT)
                                                    );
    if (!pIpsecNegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecNegotiationPolicy");
    wcscat(szDistinguishedName, szGuid);
    pIpsecNegPolObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecNegPolObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecNegPolData->pszIpsecName &&
        *pIpsecNegPolData->pszIpsecName) {
        pIpsecNegPolObject->pszIpsecName = AllocPolStr(
                                           pIpsecNegPolData->pszIpsecName
                                           );
        if (!pIpsecNegPolObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolData->pszDescription &&
        *pIpsecNegPolData->pszDescription) {
        pIpsecNegPolObject->pszDescription = AllocPolStr(
                                             pIpsecNegPolData->pszDescription
                                             );
        if (!pIpsecNegPolObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecNegPolObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecNegPolObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolAction,
                    &pszNegPolActionUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szGuidAction, L"{");
    wcscat(szGuidAction, pszNegPolActionUuid);
    wcscat(szGuidAction, L"}");

    pIpsecNegPolObject->pszIpsecNegPolAction = AllocPolStr(
                                                    szGuidAction
                                                    );
    if (!pIpsecNegPolObject->pszIpsecNegPolAction) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolType,
                    &pszNegPolTypeUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szGuidType, L"{");
    wcscat(szGuidType, pszNegPolTypeUuid);
    wcscat(szGuidType, L"}");

    pIpsecNegPolObject->pszIpsecNegPolType = AllocPolStr(
                                                 szGuidType
                                                 );
    if (!pIpsecNegPolObject->pszIpsecNegPolType) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecNegPolObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallNegPolBuffer(
                    pIpsecNegPolData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolObject->pIpsecData  = pBuffer;

    pIpsecNegPolObject->dwIpsecDataLen = dwBufferLen;

    time(&PresentTime);

    pIpsecNegPolObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecNegPolObject = pIpsecNegPolObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }
    if (pszNegPolActionUuid) {
        RpcStringFree(
            &pszNegPolActionUuid
            );
    }
    if (pszNegPolTypeUuid) {
        RpcStringFree(
            &pszNegPolTypeUuid
            );
    }

    return(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
                pIpsecNegPolObject
                );
    }

    *ppIpsecNegPolObject = NULL;
    goto cleanup;
}


DWORD
MarshallNegPolBuffer(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pCurrentPos = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwSize = 0;
    DWORD dwError = 0;
    DWORD dwNumSecurityOffers = 0;
    IPSEC_SECURITY_METHOD * pIpsecOffer = NULL;
    DWORD i = 0;
    DWORD dwEffectiveSize = 0;

    // {80DC20B9-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_NEGPOLICY_BLOB =
    { 0x80dc20b9, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };

    dwNumSecurityOffers = pIpsecNegPolData->dwSecurityMethodCount;
    pIpsecOffer = pIpsecNegPolData->pIpsecSecurityMethods;

    dwSize += sizeof(GUID);

    dwSize += sizeof(DWORD);

    dwSize += sizeof(DWORD);


    for (i = 0; i < dwNumSecurityOffers; i++) {

        dwSize += sizeof(IPSEC_SECURITY_METHOD);

    }
    dwSize++;

    pBuffer = (LPBYTE)AllocPolMem(dwSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pBuffer;

    memcpy(pCurrentPos, &GUID_IPSEC_NEGPOLICY_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);
 
    dwEffectiveSize = dwSize - sizeof(GUID) - sizeof(DWORD) - 1;

    memcpy(pCurrentPos, &dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, &dwNumSecurityOffers, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    for (i = 0; i < dwNumSecurityOffers; i++) {

        memcpy(pCurrentPos, pIpsecOffer + i, sizeof(IPSEC_SECURITY_METHOD));
        pCurrentPos += sizeof(IPSEC_SECURITY_METHOD);
    }


    *ppBuffer = pBuffer;
    *pdwBufferLen = dwSize;

    return(dwError);

error:

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppBuffer = NULL;
    *pdwBufferLen = 0;
    return(dwError);
}


DWORD
RegGetNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    WCHAR szIpsecNegPolName[MAX_PATH];
    LPWSTR pszNegPolName = NULL;

    szIpsecNegPolName[0] = L'\0';
    wcscpy(szIpsecNegPolName, L"ipsecNegotiationPolicy");

    dwError = UuidToString(&NegPolGUID, &pszNegPolName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecNegPolName, L"{");
    wcscat(szIpsecNegPolName, pszNegPolName);
    wcscat(szIpsecNegPolName, L"}");


    dwError =UnMarshallRegistryNegPolObject(
                hRegistryKey,
                pszIpsecRootContainer,
                szIpsecNegPolName,
                REG_RELATIVE_NAME,
                &pIpsecNegPolObject
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUnmarshallNegPolData(
                    pIpsecNegPolObject,
                    &pIpsecNegPolData
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
                pIpsecNegPolObject
                );
    }

    if (pszNegPolName) {
        RpcStringFree(&pszNegPolName);
    }

    *ppIpsecNegPolData = pIpsecNegPolData;

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\policy-f.c ===
#include "precomp.h"


DWORD
ExportPolicyDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    dwError = IPSecEnumPolicyData(
                  hSrcPolicyStore,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        dwError = RegCreatePolicyData(
                      pDesPolicyStore->hRegistryKey,
                      pDesPolicyStore->pszIpsecRootContainer,
                      pIpsecPolicyData
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    *pppIpsecPolicyData = ppIpsecPolicyData;
    *pdwNumPolicyObjects = dwNumPolicyObjects;
    return (dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    *pppIpsecPolicyData = NULL;
    *pdwNumPolicyObjects = 0;

    return (dwError);
}


DWORD
ImportPolicyDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    dwError = RegEnumPolicyData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        dwError = IPSecCreatePolicyData(
                      hDesPolicyStore,
                      pIpsecPolicyData
                      );
        if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
            dwError = IPSecSetPolicyData(
                          hDesPolicyStore,
                          pIpsecPolicyData
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

    *pppIpsecPolicyData = ppIpsecPolicyData;
    *pdwNumPolicyObjects = dwNumPolicyObjects;
    return (dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    *pppIpsecPolicyData = NULL;
    *pdwNumPolicyObjects = 0;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\policy-f.h ===
DWORD
ExportPolicyDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );

DWORD
ImportPolicyDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\policy-d.h ===
DWORD
DirEnumPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );

DWORD
DirEnumPolicyObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    );

DWORD
GenerateAllPolicyQuery(
    LPWSTR * ppszPolicyString
    );

DWORD
UnMarshallPolicyObject2(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
DirUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
DirCreatePolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DirMarshallPolicyObject(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
ConvertGuidToDirISAKMPString(
    GUID ISAKMPIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecISAKMPReference
    );

DWORD
DirCreatePolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
DirMarshallAddPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirSetPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DirSetPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
DirMarshallSetPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirGetPolicyExistingISAKMPRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR * ppszIpsecISAKMPName
    );

DWORD
GenerateSpecificPolicyQuery(
    GUID PolicyIdentifier,
    LPWSTR * ppszPolicyString
    );

DWORD
DirDeletePolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
ConvertGuidToDirPolicyString(
    GUID PolicyIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecPolicyReference
    );

DWORD
DirGetPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\policy-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       policy-d.c
//
//  Contents:   Policy management for directory.
//
//
//  History:    AbhisheV (05/11/00)
//
//----------------------------------------------------------------------------


#include "precomp.h"

extern LPWSTR PolicyDNAttributes[];

DWORD
DirEnumPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = DirEnumPolicyObjects(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    &ppIpsecPolicyObjects,
                    &dwNumPolicyObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumPolicyObjects) {
        ppIpsecPolicyData = (PIPSEC_POLICY_DATA *) AllocPolMem(
                        dwNumPolicyObjects*sizeof(PIPSEC_POLICY_DATA));
        if (!ppIpsecPolicyData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumPolicyObjects; i++) {

        dwError = DirUnmarshallPolicyData(
                        *(ppIpsecPolicyObjects + i),
                        &pIpsecPolicyData
                        );
        if (!dwError) {
            *(ppIpsecPolicyData + j) = pIpsecPolicyData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecPolicyData) {
            FreePolMem(ppIpsecPolicyData);
            ppIpsecPolicyData = NULL;
        }
    }

    *pppIpsecPolicyData = ppIpsecPolicyData;
    *pdwNumPolicyObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
                ppIpsecPolicyObjects,
                dwNumPolicyObjects
                );
    }

    return(dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
                ppIpsecPolicyData,
                i
                );
    }

    *pppIpsecPolicyData = NULL;
    *pdwNumPolicyObjects = 0;

    goto cleanup;
}


DWORD
DirEnumPolicyObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    )
{
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;

    DWORD dwNumPolicyObjectsReturned = 0;

    dwError = GenerateAllPolicyQuery(
                    &pszPolicyString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszPolicyString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecPolicyObjects  = (PIPSEC_POLICY_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_POLICY_OBJECT)*dwCount
                                            );

    if (!ppIpsecPolicyObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        } else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }

        dwError = UnMarshallPolicyObject2(
                      hLdapBindHandle,
                      e,
                      &pIpsecPolicyObject
                      );
        if (dwError == ERROR_SUCCESS) {
            *(ppIpsecPolicyObjects + dwNumPolicyObjectsReturned) = pIpsecPolicyObject;
            dwNumPolicyObjectsReturned++;
        }

    }

    *pppIpsecPolicyObjects = ppIpsecPolicyObjects;
    *pdwNumPolicyObjects = dwNumPolicyObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
            ppIpsecPolicyObjects,
            dwNumPolicyObjectsReturned
            );
    }

    *pppIpsecPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;

    goto cleanup;
}


DWORD
GenerateAllPolicyQuery(
    LPWSTR * ppszPolicyString
    )
{
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszPolicyString = NULL;


    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(objectclass=ipsecPolicy)");

    pszPolicyString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszPolicyString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Now fill in the buffer
    //

    wcscpy(pszPolicyString, L"(objectclass=ipsecPolicy)");

    *ppszPolicyString = pszPolicyString;

    return(0);

error:

    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }

    *ppszPolicyString = NULL;

    return(dwError);
}


DWORD
UnMarshallPolicyObject2(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR * ppszTemp = NULL;


    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecPolicyObject->pszDescription = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecPolicyObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecPolicyObject->dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecISAKMPReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecISAKMPReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecISAKMPReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecPolicyObject->pIpsecData = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNFAReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwCount; i++) {

        ppszTemp = (strvalues + i);
        //
        // Unmarshall all the values you can possibly have
        //
        pszIpsecNFAName = AllocPolStr(*ppszTemp);
        if (!pszIpsecNFAName) {
            dwError = ERROR_OUTOFMEMORY;

            pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
            pIpsecPolicyObject->NumberofRules = i;

            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszIpsecNFAName;

    }


    pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
    pIpsecPolicyObject->NumberofRules = dwCount;
    LdapValueFree(strvalues);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    *ppIpsecPolicyObject = NULL;

    return(dwError);
}


DWORD
DirUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallPolicyObject(
                  pIpsecPolicyObject,
                  IPSEC_DIRECTORY_PROVIDER,
                  ppIpsecPolicyData
                  );

    return(dwError);
}


DWORD
DirCreatePolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;

    dwError = DirMarshallPolicyObject(
                        pIpsecPolicyData,
                        pszIpsecRootContainer,
                        &pIpsecPolicyObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreatePolicyObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the ISAKMP object reference.
    //

    dwError = DirAddPolicyReferenceToISAKMPObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecISAKMPReference,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the Policy object reference.
    //

    dwError = DirAddISAKMPReferenceToPolicyObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecOwnersReference,
                  pIpsecPolicyObject->pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyObject
            );
    }

    return(dwError);
}


DWORD
DirMarshallPolicyObject(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszIpsecISAKMPReference = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecPolicyData->PolicyIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    wcscat(szDistinguishedName, pszIpsecRootContainer);

    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecPolicyData->pszIpsecName &&
        *pIpsecPolicyData->pszIpsecName) {

        pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                           pIpsecPolicyData->pszIpsecName
                                           );
        if (!pIpsecPolicyObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyData->pszDescription &&
        *pIpsecPolicyData->pszDescription) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                             pIpsecPolicyData->pszDescription
                                             );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecPolicyObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallPolicyBuffer(
                    pIpsecPolicyData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pIpsecData  = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwBufferLen;

    dwError = ConvertGuidToDirISAKMPString(
                  pIpsecPolicyData->ISAKMPIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecPolicyObject->pszIpsecISAKMPReference = pszIpsecISAKMPReference;

    pIpsecPolicyObject->dwWhenChanged = 0;

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    *ppIpsecPolicyObject = NULL;
    goto cleanup;
}


DWORD
ConvertGuidToDirISAKMPString(
    GUID ISAKMPIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecISAKMPReference
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szGuidString[MAX_PATH];
    WCHAR szISAKMPReference[MAX_PATH];
    LPWSTR pszIpsecISAKMPReference = NULL;


    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szISAKMPReference[0] = L'\0';
    wcscpy(szISAKMPReference,L"CN=ipsecISAKMPPolicy");
    wcscat(szISAKMPReference, szGuidString);
    wcscat(szISAKMPReference, L",");
    wcscat(szISAKMPReference, pszIpsecRootContainer);

    pszIpsecISAKMPReference = AllocPolStr(
                                    szISAKMPReference
                                    );
    if (!pszIpsecISAKMPReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecISAKMPReference = pszIpsecISAKMPReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecISAKMPReference = NULL;

    goto cleanup;
}


DWORD
DirCreatePolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddPolicyObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecPolicyObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecPolicyObject->pszIpsecOwnersReference,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirMarshallAddPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 6;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecPolicyObject->pszIpsecName ||
        !*pIpsecPolicyObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecPolicyObject->pszDescription ||
        !*pIpsecPolicyObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecPolicy",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecPolicyObject->pszIpsecName &&
        *pIpsecPolicyObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecPolicyObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecPolicyObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecPolicyObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecPolicyObject->pIpsecData,
                    pIpsecPolicyObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecPolicyObject->pszDescription &&
        *pIpsecPolicyObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecPolicyObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirSetPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    LPWSTR pszOldIpsecISAKMPReference = NULL;


    dwError = DirMarshallPolicyObject(
                    pIpsecPolicyData,
                    pszIpsecRootContainer,
                    &pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirGetPolicyExistingISAKMPRef(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecPolicyData,
                  &pszOldIpsecISAKMPReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetPolicyObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszOldIpsecISAKMPReference && *pszOldIpsecISAKMPReference) {
        dwError = DirRemovePolicyReferenceFromISAKMPObject(
                      hLdapBindHandle,
                      pszOldIpsecISAKMPReference,
                      pIpsecPolicyObject->pszIpsecOwnersReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = DirAddPolicyReferenceToISAKMPObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecISAKMPReference,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUpdateISAKMPReferenceInPolicyObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecOwnersReference,
                  pszOldIpsecISAKMPReference,
                  pIpsecPolicyObject->pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pszOldIpsecISAKMPReference) {
        FreePolStr(pszOldIpsecISAKMPReference);
    }

    return(dwError);
}


DWORD
DirSetPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetPolicyObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecPolicyObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecPolicyObject->pszIpsecOwnersReference,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }


    return(dwError);
}


DWORD
DirMarshallSetPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 5;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecPolicyObject->pszIpsecName ||
        !*pIpsecPolicyObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecPolicyObject->pszDescription ||
        !*pIpsecPolicyObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecPolicyObject->pszIpsecName &&
        *pIpsecPolicyObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecPolicyObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecPolicyObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecPolicyObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecPolicyObject->pIpsecData,
                    pIpsecPolicyObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecPolicyObject->pszDescription &&
        *pIpsecPolicyObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecPolicyObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirGetPolicyExistingISAKMPRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR * ppszIpsecISAKMPName
    )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;
    LPWSTR pszIpsecISAKMPName = NULL;


    dwError = GenerateSpecificPolicyQuery(
                  pIpsecPolicyData->PolicyIdentifier,
                  &pszPolicyString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszPolicyString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallPolicyObject2(
                  hLdapBindHandle,
                  e,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pszIpsecISAKMPName = AllocPolStr(
                             pIpsecPolicyObject->pszIpsecISAKMPReference
                             );
    if (!pszIpsecISAKMPName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecISAKMPName = pszIpsecISAKMPName;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return(dwError);

error:

    *ppszIpsecISAKMPName = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificPolicyQuery(
    GUID PolicyIdentifier,
    LPWSTR * ppszPolicyString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszPolicyString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &PolicyIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecPolicy");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecPolicy)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszPolicyString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszPolicyString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszPolicyString, L"(&(objectclass=ipsecPolicy)");
    wcscat(pszPolicyString, L"(");
    wcscat(pszPolicyString, szCommonName);
    wcscat(pszPolicyString, L"))");

    *ppszPolicyString = pszPolicyString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }

    *ppszPolicyString = NULL;

    goto cleanup;
}


DWORD
DirDeletePolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;


    dwError = DirMarshallPolicyObject(
                  pIpsecPolicyData,
                  pszIpsecRootContainer,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirRemovePolicyReferenceFromISAKMPObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecISAKMPReference,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return(dwError);
}


DWORD
ConvertGuidToDirPolicyString(
    GUID PolicyIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecPolicyReference
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szGuidString[MAX_PATH];
    WCHAR szPolicyReference[MAX_PATH];
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = UuidToString(
                  &PolicyIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szPolicyReference[0] = L'\0';
    wcscpy(szPolicyReference,L"CN=ipsecPolicy");
    wcscat(szPolicyReference, szGuidString);
    wcscat(szPolicyReference, L",");
    wcscat(szPolicyReference, pszIpsecRootContainer);

    pszIpsecPolicyReference = AllocPolStr(
                                    szPolicyReference
                                    );
    if (!pszIpsecPolicyReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecPolicyReference = pszIpsecPolicyReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecPolicyReference = NULL;

    goto cleanup;
}


DWORD
DirGetPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;


    *ppIpsecPolicyData = NULL;

    dwError = GenerateSpecificPolicyQuery(
                  PolicyIdentifier,
                  &pszPolicyString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszPolicyString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallPolicyObject2(
                  hLdapBindHandle,
                  e,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUnmarshallPolicyData(
                  pIpsecPolicyObject,
                  ppIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszPolicyString) {
        FreePolStr(pszPolicyString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\policy-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       policy-r.c
//
//  Contents:   Policy management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR PolicyDNAttributes[];

DWORD
RegEnumPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = RegEnumPolicyObjects(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    &ppIpsecPolicyObjects,
                    &dwNumPolicyObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumPolicyObjects) {
        ppIpsecPolicyData = (PIPSEC_POLICY_DATA *) AllocPolMem(
                        dwNumPolicyObjects*sizeof(PIPSEC_POLICY_DATA));
        if (!ppIpsecPolicyData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumPolicyObjects; i++) {

        dwError = RegUnmarshallPolicyData(
                        *(ppIpsecPolicyObjects + i),
                        &pIpsecPolicyData
                        );
        if (!dwError) {
            *(ppIpsecPolicyData + j) = pIpsecPolicyData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecPolicyData) {
            FreePolMem(ppIpsecPolicyData);
            ppIpsecPolicyData = NULL;
        }
    }

    *pppIpsecPolicyData = ppIpsecPolicyData;
    *pdwNumPolicyObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
                ppIpsecPolicyObjects,
                dwNumPolicyObjects
                );
    }

    return(dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
                ppIpsecPolicyData,
                i
                );
    }

    *pppIpsecPolicyData = NULL;
    *pdwNumPolicyObjects = 0;

    goto cleanup;

}

DWORD
RegEnumPolicyObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;

    DWORD dwNumPolicyObjectsReturned = 0;
    DWORD dwIndex = 0;
    WCHAR szPolicyName[MAX_PATH];
    DWORD dwSize = 0;

    *pppIpsecPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;

    while (1) {

        dwSize = MAX_PATH;
        szPolicyName[0] = L'\0';

        dwError = RegEnumKeyExW(
                        hRegistryKey,
                        dwIndex,
                        szPolicyName,
                        &dwSize,
                        NULL,
                        NULL,
                        0,
                        0
                        );
        if (dwError == ERROR_NO_MORE_ITEMS) {
            break;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        if (!wcsstr(szPolicyName, L"ipsecPolicy")) {
            dwIndex++;
            continue;
        }

        pIpsecPolicyObject = NULL;

        dwError =UnMarshallRegistryPolicyObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    szPolicyName,
                    REG_RELATIVE_NAME,
                    &pIpsecPolicyObject
                    );
        if (dwError == ERROR_SUCCESS) {


            dwError = ReallocatePolMem(
                          (LPVOID *) &ppIpsecPolicyObjects,
                          sizeof(PIPSEC_POLICY_OBJECT)*(dwNumPolicyObjectsReturned),
                          sizeof(PIPSEC_POLICY_OBJECT)*(dwNumPolicyObjectsReturned + 1)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            *(ppIpsecPolicyObjects + dwNumPolicyObjectsReturned) = pIpsecPolicyObject;

            dwNumPolicyObjectsReturned++;

        }

        dwIndex++;

    }

    *pppIpsecPolicyObjects = ppIpsecPolicyObjects;
    *pdwNumPolicyObjects = dwNumPolicyObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
            ppIpsecPolicyObjects,
            dwNumPolicyObjectsReturned
            );
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyObject
            );
    }

    *pppIpsecPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;


    return(dwError);
}


DWORD
RegSetPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    LPWSTR pszAbsOldISAKMPRef = NULL;
    LPWSTR pszRelOldISAKMPRef = NULL;
    WCHAR szAbsPolicyReference[MAX_PATH];
    LPWSTR pszRelISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    BOOL bIsActive = FALSE;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegGetPolicyExistingISAKMPRef(
                   hRegistryKey,
                   pIpsecPolicyData,
                   &pszAbsOldISAKMPRef
                   );                    
    // BAIL_ON_WIN32_ERROR(dwError);

    if (pszAbsOldISAKMPRef && *pszAbsOldISAKMPRef) {
        pszRelOldISAKMPRef = pszAbsOldISAKMPRef + dwRootPathLen + 1;
    }

    dwError = RegMarshallPolicyObject(
                    pIpsecPolicyData,
                    pszIpsecRootContainer,
                    &pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetPolicyObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsPolicyReference[0] = L'\0';
    wcscpy(szAbsPolicyReference, pszIpsecRootContainer);
    wcscat(szAbsPolicyReference, L"\\");
    wcscat(szAbsPolicyReference, pIpsecPolicyObject->pszIpsecOwnersReference);

    pszRelISAKMPReference = pIpsecPolicyObject->pszIpsecISAKMPReference
                            + dwRootPathLen + 1;

    if (pszRelOldISAKMPRef) {
        dwError = RegRemovePolicyReferenceFromISAKMPObject(
                      hRegistryKey,
                      pszRelOldISAKMPRef,
                      szAbsPolicyReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegAddPolicyReferenceToISAKMPObject(
                  hRegistryKey,
                  pszRelISAKMPReference,
                  szAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUpdateISAKMPReferenceInPolicyObject(
                  hRegistryKey,
                  pIpsecPolicyObject->pszIpsecOwnersReference,
                  pszAbsOldISAKMPRef,
                  pIpsecPolicyObject->pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IsRegPolicyCurrentlyActive(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData->PolicyIdentifier,
                  &bIsActive
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bIsActive) {
        dwError = PingPolicyAgentSvc(pszLocationName);
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pszAbsOldISAKMPRef) {
        FreePolStr(pszAbsOldISAKMPRef);
    }

    return(dwError);
}


DWORD
RegSetPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    DWORD dwError = 0;

    dwError = PersistPolicyObject(
                    hRegistryKey,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegCreatePolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    WCHAR szAbsPolicyReference[MAX_PATH];
    LPWSTR pszRelISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegMarshallPolicyObject(
                        pIpsecPolicyData,
                        pszIpsecRootContainer,
                        &pIpsecPolicyObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreatePolicyObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsPolicyReference[0] = L'\0';
    wcscpy(szAbsPolicyReference, pszIpsecRootContainer);
    wcscat(szAbsPolicyReference, L"\\");
    wcscat(szAbsPolicyReference, pIpsecPolicyObject->pszIpsecOwnersReference);

    pszRelISAKMPReference = pIpsecPolicyObject->pszIpsecISAKMPReference
                            + dwRootPathLen + 1;

    //
    // Write the ISAKMP object reference.
    //

    dwError = RegAddPolicyReferenceToISAKMPObject(
                  hRegistryKey,
                  pszRelISAKMPReference,
                  szAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the Policy object reference.
    //

    dwError = RegAddISAKMPReferenceToPolicyObject(
                  hRegistryKey,
                  pIpsecPolicyObject->pszIpsecOwnersReference,
                  pIpsecPolicyObject->pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    return(dwError);
}


DWORD
RegCreatePolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{

    DWORD dwError = 0;

    dwError = PersistPolicyObject(
                    hRegistryKey,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegDeletePolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = ERROR_SUCCESS;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    WCHAR szAbsPolicyReference[MAX_PATH];
    LPWSTR pszRelISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    BOOL bIsActive = FALSE;


    dwError = IsRegPolicyCurrentlyActive(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData->PolicyIdentifier,
                  &bIsActive
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bIsActive) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwRootPathLen = wcslen(pszIpsecRootContainer);

    dwError = RegMarshallPolicyObject(
                    pIpsecPolicyData,
                    pszIpsecRootContainer,
                    &pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsPolicyReference[0] = L'\0';
    wcscpy(szAbsPolicyReference, pszIpsecRootContainer);
    wcscat(szAbsPolicyReference, L"\\");
    wcscat(szAbsPolicyReference, pIpsecPolicyObject->pszIpsecOwnersReference);

    pszRelISAKMPReference = pIpsecPolicyObject->pszIpsecISAKMPReference
                            + dwRootPathLen + 1;

    dwError = RegRemovePolicyReferenceFromISAKMPObject(
                  hRegistryKey,
                  pszRelISAKMPReference,
                  szAbsPolicyReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return(dwError);
}


DWORD
RegUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallPolicyObject(
                    pIpsecPolicyObject,
                    IPSEC_REGISTRY_PROVIDER,
                    ppIpsecPolicyData
                    );


    return(dwError);
}

DWORD
RegMarshallPolicyObject(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszIpsecISAKMPReference = NULL;
    time_t PresentTime;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecPolicyData->PolicyIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecPolicy");
    wcscat(szDistinguishedName, szGuid);
    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecPolicyData->pszIpsecName && 
        *pIpsecPolicyData->pszIpsecName) {

        pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                           pIpsecPolicyData->pszIpsecName
                                           );
        if (!pIpsecPolicyObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyData->pszDescription && 
        *pIpsecPolicyData->pszDescription) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                             pIpsecPolicyData->pszDescription
                                             );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecPolicyObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallPolicyBuffer(
                    pIpsecPolicyData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pIpsecData  = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwBufferLen;

    dwError = ConvertGuidToISAKMPString(
                  pIpsecPolicyData->ISAKMPIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecPolicyObject->pszIpsecISAKMPReference = pszIpsecISAKMPReference;

    time(&PresentTime);

    pIpsecPolicyObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    *ppIpsecPolicyObject = NULL;
    goto cleanup;

}


DWORD
MarshallPolicyBuffer(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pBuffer = NULL;
    DWORD dwSize = 0;
    DWORD dwError = 0;
    DWORD dwPollingInterval = 0;
    LPBYTE pCurrentPos = NULL;
    DWORD dwEffectiveSize = 0;

    // {22202163-4F4C-11d1-863B-00A0248D3021}
    static const GUID GUID_IPSEC_POLICY_DATA_BLOB =
    { 0x22202163, 0x4f4c, 0x11d1, { 0x86, 0x3b, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };


    dwSize += sizeof(GUID);
    dwSize += sizeof(DWORD);

    dwSize += sizeof(DWORD);
    dwSize++;


    pBuffer = AllocPolMem(dwSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pBuffer;

    memcpy(pCurrentPos, &GUID_IPSEC_POLICY_DATA_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    dwEffectiveSize = dwSize - sizeof(GUID) - sizeof(DWORD) - 1;

    memcpy(pCurrentPos, &dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    dwPollingInterval = pIpsecPolicyData->dwPollingInterval;
    memcpy(pCurrentPos, &dwPollingInterval, sizeof(DWORD));


    *ppBuffer = pBuffer;
    *pdwBufferLen = dwSize;
    return(dwError);

error:

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppBuffer = NULL;
    *pdwBufferLen = 0;
    return(dwError);
}


DWORD
ConvertGuidToISAKMPString(
    GUID ISAKMPIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecISAKMPReference
    )
{
    DWORD dwError = 0;
    WCHAR szISAKMPReference[MAX_PATH];
    LPWSTR pszIpsecISAKMPReference = NULL;
    WCHAR szGuidString[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szISAKMPReference[0] = L'\0';
    wcscpy(szISAKMPReference, pszIpsecRootContainer);
    wcscat(szISAKMPReference, L"\\");
    wcscat(szISAKMPReference, L"ipsecISAKMPPolicy");
    wcscat(szISAKMPReference, szGuidString);

    pszIpsecISAKMPReference = AllocPolStr(
                                    szISAKMPReference
                                    );
    if (!pszIpsecISAKMPReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecISAKMPReference = pszIpsecISAKMPReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecISAKMPReference = NULL;

    goto cleanup;
}


DWORD
RegGetPolicyExistingISAKMPRef(
    HKEY hRegistryKey,
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR * ppszISAKMPName
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szRelativeName[MAX_PATH];
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;


    szRelativeName[0] = L'\0';
    dwError = UuidToString(
                    &pIpsecPolicyData->PolicyIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szRelativeName, L"ipsecPolicy");
    wcscat(szRelativeName, L"{");
    wcscat(szRelativeName, pszStringUuid);
    wcscat(szRelativeName, L"}");

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    szRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecISAKMPReference",
                    REG_SZ,
                    (LPBYTE *)ppszISAKMPName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
RegAssignPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;
    WCHAR szRelativeName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    WCHAR szAbsPolicyRef[MAX_PATH];


    szRelativeName[0] = L'\0';
    dwError = UuidToString(
                  &PolicyIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szRelativeName, L"ipsecPolicy");
    wcscat(szRelativeName, L"{");
    wcscat(szRelativeName, pszStringUuid);
    wcscat(szRelativeName, L"}");

    szAbsPolicyRef[0] = L'\0';
    wcscpy(szAbsPolicyRef, pszIpsecRootContainer);
    wcscat(szAbsPolicyRef, L"\\");
    wcscat(szAbsPolicyRef, szRelativeName);

    dwError = RegSetValueExW(
                  hRegistryKey,
                  L"ActivePolicy",
                  0,
                  REG_SZ,
                  (LPBYTE) szAbsPolicyRef,
                  (wcslen(szAbsPolicyRef) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = PingPolicyAgentSvc(pszLocationName);
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return (dwError);
}


DWORD
RegUnassignPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;

    dwError = RegDeleteValueW(
                  hRegistryKey,
                  L"ActivePolicy"
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = PingPolicyAgentSvc(pszLocationName);
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
PingPolicyAgentSvc(
    LPWSTR pszLocationName
    )
{
    SC_HANDLE ServiceDatabase = NULL;
    SC_HANDLE ServiceHandle   = NULL;
    BOOL bStatus = FALSE;
    DWORD dwError = 0;
    SERVICE_STATUS IpsecStatus;


    memset(&IpsecStatus, 0, sizeof(SERVICE_STATUS));

    ServiceDatabase = OpenSCManagerW(
                          pszLocationName,
                          NULL,
                          SC_MANAGER_ALL_ACCESS
                          );
    if (ServiceDatabase == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ServiceHandle = OpenService(
                        ServiceDatabase,
                        "PolicyAgent",
                        SERVICE_ALL_ACCESS
                        );
    if (ServiceHandle == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bStatus = QueryServiceStatus(
                  ServiceHandle,
                  &IpsecStatus
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (IpsecStatus.dwCurrentState == SERVICE_STOPPED) {
        bStatus = StartService(
                      ServiceHandle,
                      0,
                      NULL
                      );
        if (bStatus == FALSE) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else if (IpsecStatus.dwCurrentState == SERVICE_RUNNING) {
        bStatus = ControlService(
                      ServiceHandle,
                      129,
                      &IpsecStatus
                      );
        if (bStatus == FALSE) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    if (ServiceDatabase != NULL) {
        CloseServiceHandle(ServiceDatabase);
    }

    if (ServiceHandle != NULL) {
        CloseServiceHandle(ServiceHandle);
    }

    return (dwError);
}


DWORD
IsRegPolicyCurrentlyActive(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PBOOL pbIsActive
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    *pbIsActive = FALSE;

    dwError = RegGetAssignedPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  &pIpsecPolicyData
                  );
    if (pIpsecPolicyData) {
        if (!memcmp(
                &PolicyIdentifier,
                &pIpsecPolicyData->PolicyIdentifier,
                sizeof(GUID))) {
            *pbIsActive = TRUE;
        }
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
RegGetPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    WCHAR szIpsecPolicyName[MAX_PATH];
    LPWSTR pszPolicyName = NULL;

    szIpsecPolicyName[0] = L'\0';
    wcscpy(szIpsecPolicyName, L"ipsecPolicy");

    dwError = UuidToString(&PolicyGUID, &pszPolicyName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecPolicyName, L"{");
    wcscat(szIpsecPolicyName, pszPolicyName);
    wcscat(szIpsecPolicyName, L"}");

    dwError = UnMarshallRegistryPolicyObject(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  szIpsecPolicyName,
                  REG_RELATIVE_NAME,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUnmarshallPolicyData(
                  pIpsecPolicyObject,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyObject
            );
    }

    if (pszPolicyName) {
        RpcStringFree(&pszPolicyName);
    }

    *ppIpsecPolicyData = pIpsecPolicyData;

    return(dwError);
}


DWORD
RegPingPASvcForActivePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    WCHAR szIpsecPolicyName[MAX_PATH];
    LPWSTR pszPolicyName = NULL;
    WCHAR szAbsPolicyReference[MAX_PATH];


    dwError = RegGetAssignedPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pIpsecPolicyData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    szIpsecPolicyName[0] = L'\0';
    wcscpy(szIpsecPolicyName, L"ipsecPolicy");

    dwError = UuidToString(&pIpsecPolicyData->PolicyIdentifier, &pszPolicyName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecPolicyName, L"{");
    wcscat(szIpsecPolicyName, pszPolicyName);
    wcscat(szIpsecPolicyName, L"}");

    szAbsPolicyReference[0] = L'\0';
    wcscpy(szAbsPolicyReference, pszIpsecRootContainer);
    wcscat(szAbsPolicyReference, L"\\");
    wcscat(szAbsPolicyReference, szIpsecPolicyName);

    dwError = RegUpdatePolicy(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  szAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = PingPolicyAgentSvc(pszLocationName);
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pszPolicyName) {
        RpcStringFree(&pszPolicyName);
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\precomp.h ===
//
// System Includes
//

#include <windows.h>

//
// CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <wchar.h>

#include <dsgetdc.h>
#include <lm.h>

#define UNICODE

#include <rpc.h>
#include <winldap.h>
#include <time.h>
#include <ipsec.h>
#include <oakdefs.h>
#include "polstore2.h"

#include "ldaputil.h"
#include "memory.h"
#include "structs.h"
#include "dsstore.h"
#include "regstore.h"
#include "persist.h"
#include "procrule.h"
#include "utils.h"

#include "policy-d.h"
#include "policy-r.h"
#include "filters-d.h"
#include "filters-r.h"
#include "negpols-d.h"
#include "negpols-r.h"
#include "rules-d.h"
#include "rules-r.h"
#include "refer-d.h"
#include "refer-r.h"
#include "isakmp-d.h"
#include "isakmp-r.h"

#include "connui.h"
#include "reginit.h"
#include "dllsvr.h"
#include "update-d.h"
#include "update-r.h"

#include "polstmsg.h"

typedef struct _IPSEC_POLICY_STORE {
    DWORD dwProvider;
    HKEY  hParentRegistryKey;
    HKEY  hRegistryKey;
    LPWSTR pszLocationName;
    HLDAP hLdapBindHandle;
    LPWSTR pszIpsecRootContainer;
    LPWSTR pszFileName;
}IPSEC_POLICY_STORE, *PIPSEC_POLICY_STORE;

#include "import.h"
#include "export.h"
#include "policy-f.h"
#include "filters-f.h"
#include "negpols-f.h"
#include "isakmp-f.h"
#include "rules-f.h"
#include "restore-r.h"
#include "validate.h"

#define SZAPPNAME L"polstore.dll"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\policy-r.h ===
DWORD
RegEnumPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );

DWORD
RegEnumPolicyObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    );

DWORD
RegSetPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
RegSetPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
RegCreatePolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
RegCreatePolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
RegDeletePolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
RegUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
RegMarshallPolicyObject(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
MarshallPolicyBuffer(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );

DWORD
ConvertGuidToISAKMPString(
    GUID ISAKMPIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecISAKMPReference
    );

DWORD
RegGetPolicyExistingISAKMPRef(
    HKEY hRegistryKey,
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR * ppszISAKMPName
    );

DWORD
RegAssignPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName
    );

DWORD
RegUnassignPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName
    );

DWORD
PingPolicyAgentSvc(
    LPWSTR pszLocationName
    );

DWORD
IsRegPolicyCurrentlyActive(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PBOOL pbIsActive
    );

DWORD
RegGetPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
RegPingPASvcForActivePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\refer-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       refer-d.c
//
//  Contents:   Reference Management for directory.
//
//
//  History:    KrishnaG
//              AbhishEV
//
//----------------------------------------------------------------------------


#include "precomp.h"


DWORD
DirAddNFAReferenceToPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecNFAReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecPolicyName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirRemoveNFAReferenceFromPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecNFAReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecPolicyName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddPolicyReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecPolicyName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddNegPolReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecNegPolName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNegPolName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirUpdateNegPolReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecNegPolName,
    LPWSTR pszNewIpsecNegPolName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszNewIpsecNegPolName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddFilterReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecFilterName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecFilterReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecFilterName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirUpdateFilterReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecFilterName,
    LPWSTR pszNewIpsecFilterName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecFilterReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszNewIpsecFilterName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddNFAReferenceToFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecFilterName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteNFAReferenceInFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecFilterName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddNFAReferenceToNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNegPolName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteNFAReferenceInNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNegPolName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddPolicyReferenceToISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;


    ppLDAPModW = (LDAPModW **) AllocPolMem(
                               (dwNumAttributes+1)*sizeof(LDAPModW*)
                               );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                             dwNumAttributes*sizeof(LDAPModW)
                             );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                  L"ipsecOwnersReference",
                  &(pLDAPModW +i)->mod_type
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                  pszIpsecPolicyName,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                  hLdapBindHandle,
                  pszIpsecISAKMPName,
                  ppLDAPModW
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddISAKMPReferenceToPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecISAKMPName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;


    ppLDAPModW = (LDAPModW **) AllocPolMem(
                               (dwNumAttributes+1)*sizeof(LDAPModW*)
                               );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                             dwNumAttributes*sizeof(LDAPModW)
                             );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                  L"ipsecISAKMPReference",
                  &(pLDAPModW +i)->mod_type
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                  pszIpsecISAKMPName,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                  hLdapBindHandle,
                  pszIpsecPolicyName,
                  ppLDAPModW
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirRemovePolicyReferenceFromISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = 0;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;


    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                  pszIpsecPolicyName,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecISAKMPName,
                    ppLDAPModW
                    );
    //
    // ipsecOwnersReference may be empty for ISAKMP object.
    //
    if (dwError == ERROR_DS_NO_ATTRIBUTE_OR_VALUE) {
        dwError = 0;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirUpdateISAKMPReferenceInPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszOldIpsecISAKMPName,
    LPWSTR pszNewIpsecISAKMPName
    )
{
    DWORD dwError = 0;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;


    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecISAKMPReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszNewIpsecISAKMPName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecPolicyName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirRemoveFilterReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecFilterReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW +i)->mod_values = NULL;

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    if (dwError == ERROR_DS_NO_ATTRIBUTE_OR_VALUE) {
        dwError = 0;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\refer-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       refer-r.c
//
//  Contents:   Reference management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------


#include "precomp.h"


//
// Policy Object References
//

DWORD
RegAddNFAReferenceToPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFADistinguishedName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFADistinguishedName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecNFAReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
RegRemoveNFAReferenceFromPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteValueFromMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pNewValueData && *pNewValueData) {
        dwError = RegSetValueExW(
                      hKey,
                      L"ipsecNFAReference",
                      0,
                      REG_MULTI_SZ,
                      (LPBYTE)pNewValueData,
                      dwNewSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDeleteValueW(
                      hKey,
                      L"ipsecNFAReference"
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}

//
// NFA Object References
//

DWORD
RegAddPolicyReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecPolicyName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecOwnersReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
RegAddNegPolReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecNegPolName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecNegotiationPolicyReference",
                    0,
                    REG_SZ,
                    (LPBYTE)pszIpsecNegPolName,
                    (wcslen(pszIpsecNegPolName) + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}


DWORD
RegUpdateNegPolReferenceInNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecNegPolName,
    LPWSTR pszNewIpsecNegPolName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecNegotiationPolicyReference",
                    0,
                    REG_SZ,
                    (LPBYTE)pszNewIpsecNegPolName,
                    (wcslen(pszNewIpsecNegPolName) + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}


DWORD
RegAddFilterReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecFilterName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pMem = NULL;


    pMem = AllocPolMem(
               (wcslen(pszIpsecFilterName) + 1 + 1)*sizeof(WCHAR)
               );
    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        pMem,
        (LPBYTE) pszIpsecFilterName,
        (wcslen(pszIpsecFilterName) + 1)*sizeof(WCHAR)
        );

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecFilterReference",
                    0,
                    REG_MULTI_SZ,
                    pMem,
                    (wcslen(pszIpsecFilterName) + 1 + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pMem) {
        FreePolMem(pMem);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}


DWORD
RegUpdateFilterReferenceInNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecFilterName,
    LPWSTR pszNewIpsecFilterName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pMem = NULL;


    pMem = AllocPolMem(
               (wcslen(pszNewIpsecFilterName) + 1 + 1)*sizeof(WCHAR)
               );
    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        pMem,
        (LPBYTE) pszNewIpsecFilterName,
        (wcslen(pszNewIpsecFilterName) + 1)*sizeof(WCHAR)
        );

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecFilterReference",
                    0,
                    REG_MULTI_SZ,
                    pMem,
                    (wcslen(pszNewIpsecFilterName) + 1 + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pMem) {
        FreePolMem(pMem);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}

//
// Filter Object References
//

DWORD
RegAddNFAReferenceToFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecFilterName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecOwnersReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}

DWORD
RegDeleteNFAReferenceInFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecFilterName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteValueFromMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pNewValueData && *pNewValueData) {
        dwError = RegSetValueExW(
                      hKey,
                      L"ipsecOwnersReference",
                      0,
                      REG_MULTI_SZ,
                      (LPBYTE)pNewValueData,
                      dwNewSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDeleteValueW(
                      hKey,
                      L"ipsecOwnersReference"
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


//
// NegPol Object References
//


DWORD
RegAddNFAReferenceToNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNegPolName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecOwnersReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
RegDeleteNFAReferenceInNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNegPolName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteValueFromMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pNewValueData && *pNewValueData) {
        dwError = RegSetValueExW(
                      hKey,
                      L"ipsecOwnersReference",
                      0,
                      REG_MULTI_SZ,
                      (LPBYTE)pNewValueData,
                      dwNewSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDeleteValueW(
                      hKey,
                      L"ipsecOwnersReference"
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
AddValueToMultiSz(
    LPBYTE pValueData,
    DWORD dwSize,
    LPWSTR pszValuetoAdd,
    LPBYTE * ppNewValueData,
    DWORD * pdwNewSize
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPBYTE pNewValueData = NULL;
    LPBYTE pNewPtr = NULL;
    DWORD dwLen = 0;
    DWORD dwAddSize = 0;
    DWORD dwNewSize = 0;
    BOOL bFound = FALSE;
    LPWSTR pszTemp = NULL;


    *ppNewValueData = NULL;
    *pdwNewSize = 0;

    dwLen = wcslen(pszValuetoAdd);
    dwLen ++;
    dwAddSize = dwLen*sizeof(WCHAR);

    if (pValueData) {

        pszTemp = (LPWSTR) pValueData;
        while (*pszTemp != L'\0') {
            if (!_wcsicmp(pszTemp, pszValuetoAdd)) {
                bFound = TRUE;
                break;
            }
            pszTemp += wcslen(pszTemp) + 1;
        }

        if (bFound) {
            dwNewSize = dwSize;
        }
        else {
            dwNewSize = dwSize + dwAddSize;
        }

    }
    else {
        dwNewSize = dwAddSize + sizeof(WCHAR);
    }

    pNewValueData = (LPBYTE)AllocPolMem(dwNewSize);
    if (!pNewValueData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!bFound) {
        wcscpy((LPWSTR)pNewValueData, pszValuetoAdd);
        pNewPtr = pNewValueData + dwAddSize;
    }
    else {
        pNewPtr = pNewValueData;
    }

    if (pValueData) {
        memcpy(pNewPtr, pValueData, dwSize);
    }

    *ppNewValueData = pNewValueData;
    *pdwNewSize = dwNewSize;

error:

    return(dwError);
}

DWORD
DeleteValueFromMultiSz(
    LPBYTE pValueData,
    DWORD dwSize,
    LPWSTR pszValuetoDel,
    LPBYTE * ppNewValueData,
    DWORD * pdwNewSize
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPBYTE pNewValueData = NULL;
    LPBYTE pNew = NULL;
    DWORD dwLen = 0;
    DWORD dwDelSize = 0;
    DWORD dwNewSize = 0;
    BOOL bFound = FALSE;
    LPWSTR pszTemp = NULL;


    *ppNewValueData = NULL;
    *pdwNewSize = 0;

    if (!pValueData || !dwSize) {
        return (ERROR_INVALID_PARAMETER);
    }

    pszTemp = (LPWSTR) pValueData;
    while (*pszTemp != L'\0') {
        if (!_wcsicmp(pszTemp, pszValuetoDel)) {
            bFound = TRUE;
            break;
        }
        pszTemp += wcslen(pszTemp) + 1;
    }

    if (!bFound) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwLen = wcslen(pszValuetoDel);
    dwLen ++;
    dwDelSize = dwLen*sizeof(WCHAR);


    if (dwSize == dwDelSize) {
        return (ERROR_SUCCESS);
    }

    dwNewSize = dwSize - dwDelSize;

    pNewValueData = (LPBYTE)AllocPolMem(dwNewSize);
    if (!pNewValueData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = (LPWSTR) pValueData;
    pNew = pNewValueData;
    while (*pszTemp != L'\0') {
        if (!_wcsicmp(pszTemp, pszValuetoDel)) {
            pszTemp += wcslen(pszTemp) + 1;
        }
        else {
            memcpy(pNew, (LPBYTE) pszTemp, (wcslen(pszTemp)+1)*sizeof(WCHAR));
            pNew += (wcslen(pszTemp)+1)*sizeof(WCHAR);
            pszTemp += wcslen(pszTemp) + 1;
        }
    }

    *ppNewValueData = pNewValueData;
    *pdwNewSize = dwNewSize;

error:

    return(dwError);
}


DWORD
RegDelFilterRefValueOfNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteValueW(
                    hKey,
                    L"ipsecFilterReference"
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}

//
// ISAKMP Object References.
//

DWORD
RegAddPolicyReferenceToISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyDistinguishedName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecISAKMPName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecPolicyDistinguishedName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecOwnersReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
RegRemovePolicyReferenceFromISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecISAKMPName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteValueFromMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecPolicyName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pNewValueData && *pNewValueData) {
        dwError = RegSetValueExW(
                      hKey,
                      L"ipsecOwnersReference",
                      0,
                      REG_MULTI_SZ,
                      (LPBYTE)pNewValueData,
                      dwNewSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDeleteValueW(
                      hKey,
                      L"ipsecOwnersReference"
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}

//
// Policy Object Reference to the ISAKMP object.
//

DWORD
RegAddISAKMPReferenceToPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecISAKMPName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecISAKMPReference",
                    0,
                    REG_SZ,
                    (LPBYTE)pszIpsecISAKMPName,
                    (wcslen(pszIpsecISAKMPName) + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}


DWORD
RegUpdateISAKMPReferenceInPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszOldIpsecISAKMPName,
    LPWSTR pszNewIpsecISAKMPName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecISAKMPReference",
                    0,
                    REG_SZ,
                    (LPBYTE)pszNewIpsecISAKMPName,
                    (wcslen(pszNewIpsecISAKMPName) + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\refer-d.h ===
DWORD
DirAddNFAReferenceToPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirRemoveNFAReferenceFromPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirAddPolicyReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecPolicyName
    );

DWORD
DirAddNegPolReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecNegPolName
    );

DWORD
DirUpdateNegPolReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecNegPolName,
    LPWSTR pszNewIpsecNegPolName
    );

DWORD
DirAddFilterReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecFilterName
    );

DWORD
DirUpdateFilterReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecFilterName,
    LPWSTR pszNewIpsecFilterName
    );

DWORD
DirAddNFAReferenceToFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirDeleteNFAReferenceInFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirAddNFAReferenceToNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirDeleteNFAReferenceInNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirAddPolicyReferenceToISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    );

DWORD
DirAddISAKMPReferenceToPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecISAKMPName
    );

DWORD
DirRemovePolicyReferenceFromISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    );

DWORD
DirUpdateISAKMPReferenceInPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszOldIpsecISAKMPName,
    LPWSTR pszNewIpsecISAKMPName
    );

DWORD
DirRemoveFilterReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\reginit.c ===
#include "precomp.h"


const DWORD PS_INTERFACE_TYPE_NONE = 0;
const DWORD PS_INTERFACE_TYPE_DIALUP = -1;
const DWORD PS_INTERFACE_TYPE_LAN = -2;
const DWORD PS_INTERFACE_TYPE_ALL = -3;

DWORD
GenerateDefaultInformation(
    HANDLE hPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pAllFilter = NULL;
    PIPSEC_FILTER_DATA pAllICMPFilter = NULL;
    PIPSEC_NEGPOL_DATA pPermitNegPol = NULL;
    PIPSEC_NEGPOL_DATA pRequestSecurityNegPol = NULL;
    PIPSEC_NEGPOL_DATA pRequireSecurityNegPol = NULL;
    PIPSEC_ISAKMP_DATA pDefaultISAKMP = NULL;

    // {72385234-70FA-11d1-864C-14A300000000}
    static const GUID GUID_DEFAULT_ISAKMP=
    { 0x72385234, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    dwError = CreateAllFilter(
                  hPolicyStore,
                  &pAllFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateAllICMPFilter(
                  hPolicyStore,
                  &pAllICMPFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreatePermitNegPol(
                  hPolicyStore,
                  &pPermitNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateRequestSecurityNegPol(
                  hPolicyStore,
                  &pRequestSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateRequireSecurityNegPol(
                  hPolicyStore,
                  &pRequireSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateClientPolicy(
                  hPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateRequestSecurityPolicy(
                  hPolicyStore,
                  pAllFilter,
                  pAllICMPFilter,
                  pPermitNegPol,
                  pRequestSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateRequireSecurityPolicy(
                  hPolicyStore,
                  pAllFilter,
                  pAllICMPFilter,
                  pPermitNegPol,
                  pRequireSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateISAKMP(
                  hPolicyStore,
                  GUID_DEFAULT_ISAKMP,
                  &pDefaultISAKMP
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pAllFilter) {
        FreeIpsecFilterData(pAllFilter);
    }

    if (pAllICMPFilter) {
        FreeIpsecFilterData(pAllICMPFilter);
    }

    if (pPermitNegPol) {
        FreeIpsecNegPolData(pPermitNegPol);
    }

    if (pRequestSecurityNegPol) {
        FreeIpsecNegPolData(pRequestSecurityNegPol);
    }

    if (pRequireSecurityNegPol) {
        FreeIpsecNegPolData(pRequireSecurityNegPol);
    }

    if (pDefaultISAKMP) {
        FreeIpsecISAKMPData(pDefaultISAKMP);
    }

    return(dwError);
}


DWORD
CreateAllFilter(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA * ppAllFilter
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pAllFilter = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;

    // {7238523a-70FA-11d1-864C-14A300000000}
    static const GUID GUID_ALL_FILTER=
    { 0x7238523a, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    pAllFilter = (PIPSEC_FILTER_DATA) AllocPolMem(
                                      sizeof(IPSEC_FILTER_DATA)
                                      );
    if (!pAllFilter) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pAllFilter->FilterIdentifier),
        &(GUID_ALL_FILTER),
        sizeof(GUID)
        );

    pAllFilter->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pAllFilter->pszIpsecName),
                               POLSTORE_ALL_FILTER_NAME
                               );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pAllFilter->pszDescription),
                                POLSTORE_ALL_FILTER_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwNumFilterSpecs = 1;
    ppFilterSpecs = (PIPSEC_FILTER_SPEC *) AllocPolMem(
                    sizeof(PIPSEC_FILTER_SPEC)*dwNumFilterSpecs
                    );
    if (!ppFilterSpecs) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pAllFilter->dwNumFilterSpecs = dwNumFilterSpecs;
    pAllFilter->ppFilterSpecs = ppFilterSpecs;

    pFilterSpec = (PIPSEC_FILTER_SPEC) AllocPolMem(
                  sizeof(IPSEC_FILTER_SPEC)
                  );
    if (!pFilterSpec) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    *(ppFilterSpecs + 0) = pFilterSpec;

    pFilterSpec->pszSrcDNSName = NULL;
    pFilterSpec->pszDestDNSName = NULL;
    pFilterSpec->pszDescription = NULL;

    dwError = UuidCreate(
                  &pFilterSpec->FilterSpecGUID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterSpec->dwMirrorFlag = 1;

    pFilterSpec->Filter.SrcAddr = 0;
    pFilterSpec->Filter.SrcMask = -1;
    pFilterSpec->Filter.DestAddr = 0;
    pFilterSpec->Filter.DestMask = 0;
    pFilterSpec->Filter.TunnelAddr = 0;
    pFilterSpec->Filter.Protocol = 0;
    pFilterSpec->Filter.SrcPort = 0;
    pFilterSpec->Filter.DestPort = 0;
    pFilterSpec->Filter.TunnelFilter = 0;
    pFilterSpec->Filter.Flags = 0;

    dwError = IPSecCreateFilterData(
                  hPolicyStore,
                  pAllFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppAllFilter = pAllFilter;

    return (dwError);

error:

    if (pAllFilter) {
        FreeIpsecFilterData(pAllFilter);
    }

    *ppAllFilter = NULL;
    return (dwError);
}


DWORD
CreateAllICMPFilter(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA * ppAllICMPFilter
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pAllICMPFilter = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;

    // {72385235-70FA-11d1-864C-14A300000000}
    static const GUID GUID_ALL_ICMP_FILTER =
    { 0x72385235, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    pAllICMPFilter = (PIPSEC_FILTER_DATA) AllocPolMem(
                                      sizeof(IPSEC_FILTER_DATA)
                                      );
    if (!pAllICMPFilter) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pAllICMPFilter->FilterIdentifier),
        &(GUID_ALL_ICMP_FILTER),
        sizeof(GUID)
        );

    pAllICMPFilter->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pAllICMPFilter->pszIpsecName),
                                POLSTORE_ALL_ICMP_FILTER_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pAllICMPFilter->pszDescription),
                                POLSTORE_ALL_ICMP_FILTER_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwNumFilterSpecs = 1;
    ppFilterSpecs = (PIPSEC_FILTER_SPEC *) AllocPolMem(
                    sizeof(PIPSEC_FILTER_SPEC)*dwNumFilterSpecs
                    );
    if (!ppFilterSpecs) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pAllICMPFilter->dwNumFilterSpecs = dwNumFilterSpecs;
    pAllICMPFilter->ppFilterSpecs = ppFilterSpecs;

    pFilterSpec = (PIPSEC_FILTER_SPEC) AllocPolMem(
                  sizeof(IPSEC_FILTER_SPEC)
                  );
    if (!pFilterSpec) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    *(ppFilterSpecs + 0) = pFilterSpec;

    pFilterSpec->pszSrcDNSName = NULL;
    pFilterSpec->pszDestDNSName = NULL;
    dwError = MapAndAllocPolStr(&(pFilterSpec->pszDescription),
                                POLSTORE_ICMPFILTER_SPEC_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &pFilterSpec->FilterSpecGUID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterSpec->dwMirrorFlag = 1;

    pFilterSpec->Filter.SrcAddr = 0;
    pFilterSpec->Filter.SrcMask = -1;
    pFilterSpec->Filter.DestAddr = 0;
    pFilterSpec->Filter.DestMask = 0;
    pFilterSpec->Filter.TunnelAddr = 0;
    pFilterSpec->Filter.Protocol = 1;
    pFilterSpec->Filter.SrcPort = 0;
    pFilterSpec->Filter.DestPort = 0;
    pFilterSpec->Filter.TunnelFilter = 0;
    pFilterSpec->Filter.Flags = 0;

    dwError = IPSecCreateFilterData(
                  hPolicyStore,
                  pAllICMPFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppAllICMPFilter = pAllICMPFilter;

    return (dwError);

error:

    if (pAllICMPFilter) {
        FreeIpsecFilterData(pAllICMPFilter);
    }

    *ppAllICMPFilter = NULL;
    return (dwError);
}


DWORD
CreatePermitNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppPermitNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pPermitNegPol = NULL;

    static const GUID GUID_PERMIT_NEGPOL =
    { 0x7238523b, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    pPermitNegPol = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                      sizeof(IPSEC_NEGPOL_DATA)
                                      );
    if (!pPermitNegPol) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pPermitNegPol->NegPolIdentifier),
        &(GUID_PERMIT_NEGPOL),
        sizeof(GUID)
        );

    memcpy(
        &(pPermitNegPol->NegPolAction),
        &(GUID_NEGOTIATION_ACTION_NO_IPSEC),
        sizeof(GUID)
        );

    memcpy(
        &(pPermitNegPol->NegPolType),
        &(GUID_NEGOTIATION_TYPE_STANDARD),
        sizeof(GUID)
        );

    pPermitNegPol->dwSecurityMethodCount = 0;
    pPermitNegPol->pIpsecSecurityMethods = NULL;

    pPermitNegPol->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pPermitNegPol->pszIpsecName),
                                POLSTORE_PERMIT_NEG_POL_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pPermitNegPol->pszDescription),
                                POLSTORE_PERMIT_NEG_POL_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IPSecCreateNegPolData(
                  hPolicyStore,
                  pPermitNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppPermitNegPol = pPermitNegPol;

    return (dwError);

error:

    if (pPermitNegPol) {
        FreeIpsecNegPolData(pPermitNegPol);
    }

    *ppPermitNegPol = NULL;
    return (dwError);
}


DWORD
CreateRequestSecurityNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppRequestSecurityNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pRequestSecurityNegPol = NULL;
    DWORD dwSecurityMethodCount = 0;
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods = NULL;
    PIPSEC_SECURITY_METHOD pMethod = NULL;

    // {72385233-70FA-11d1-864C-14A300000000}
    static const GUID GUID_SECURE_INITIATOR_NEGPOL =
    { 0x72385233, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    pRequestSecurityNegPol = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                      sizeof(IPSEC_NEGPOL_DATA)
                                      );
    if (!pRequestSecurityNegPol) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pRequestSecurityNegPol->NegPolIdentifier),
        &(GUID_SECURE_INITIATOR_NEGPOL),
        sizeof(GUID)
        );

    memcpy(
        &(pRequestSecurityNegPol->NegPolAction),
        &(GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU),
        sizeof(GUID)
        );

    memcpy(
        &(pRequestSecurityNegPol->NegPolType),
        &(GUID_NEGOTIATION_TYPE_STANDARD),
        sizeof(GUID)
        );

    dwSecurityMethodCount = 5;
    pIpsecSecurityMethods = (PIPSEC_SECURITY_METHOD) AllocPolMem(
                            sizeof(IPSEC_SECURITY_METHOD)*dwSecurityMethodCount
                            );
    if (!pIpsecSecurityMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMethod = pIpsecSecurityMethods;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 300;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Auth;
    pMethod->Algos[0].algoIdentifier = IPSEC_AH_SHA;
    pMethod->Algos[0].secondaryAlgoIdentifier = 0;;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 300;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Auth;
    pMethod->Algos[0].algoIdentifier = IPSEC_AH_MD5;
    pMethod->Algos[0].secondaryAlgoIdentifier = 0;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 0;

    pRequestSecurityNegPol->dwSecurityMethodCount = dwSecurityMethodCount;
    pRequestSecurityNegPol->pIpsecSecurityMethods = pIpsecSecurityMethods;

    pRequestSecurityNegPol->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pRequestSecurityNegPol->pszIpsecName),
                                POLSTORE_REQUEST_SECURITY_NEG_POL_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pRequestSecurityNegPol->pszDescription),
                                POLSTORE_REQUEST_SECURITY_NEG_POL_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IPSecCreateNegPolData(
                  hPolicyStore,
                  pRequestSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppRequestSecurityNegPol = pRequestSecurityNegPol;

    return (dwError);

error:

    if (pRequestSecurityNegPol) {
        FreeIpsecNegPolData(pRequestSecurityNegPol);
    }

    *ppRequestSecurityNegPol = NULL;
    return (dwError);
}


DWORD
CreateRequireSecurityNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppRequireSecurityNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pRequireSecurityNegPol = NULL;
    DWORD dwSecurityMethodCount = 0;
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods = NULL;
    PIPSEC_SECURITY_METHOD pMethod = NULL;

    // {7238523f-70FA-11d1-864C-14A300000000}
    static const GUID GUID_LOCKDOWN_NEGPOL =
    { 0x7238523f, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    pRequireSecurityNegPol = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                      sizeof(IPSEC_NEGPOL_DATA)
                                      );
    if (!pRequireSecurityNegPol) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pRequireSecurityNegPol->NegPolIdentifier),
        &(GUID_LOCKDOWN_NEGPOL),
        sizeof(GUID)
        );

    memcpy(
        &(pRequireSecurityNegPol->NegPolAction),
        &(GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU),
        sizeof(GUID)
        );

    memcpy(
        &(pRequireSecurityNegPol->NegPolType),
        &(GUID_NEGOTIATION_TYPE_STANDARD),
        sizeof(GUID)
        );

    dwSecurityMethodCount = 4;
    pIpsecSecurityMethods = (PIPSEC_SECURITY_METHOD) AllocPolMem(
                            sizeof(IPSEC_SECURITY_METHOD)*dwSecurityMethodCount
                            );
    if (!pIpsecSecurityMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMethod = pIpsecSecurityMethods;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_MD5;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_MD5;

    pRequireSecurityNegPol->dwSecurityMethodCount = dwSecurityMethodCount;
    pRequireSecurityNegPol->pIpsecSecurityMethods = pIpsecSecurityMethods;

    pRequireSecurityNegPol->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pRequireSecurityNegPol->pszIpsecName),
                                POLSTORE_REQUIRE_SECURITY_NEG_POL_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pRequireSecurityNegPol->pszDescription),
                                POLSTORE_REQUIRE_SECURITY_NEG_POL_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IPSecCreateNegPolData(
                  hPolicyStore,
                  pRequireSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppRequireSecurityNegPol = pRequireSecurityNegPol;

    return (dwError);

error:

    if (pRequireSecurityNegPol) {
        FreeIpsecNegPolData(pRequireSecurityNegPol);
    }

    *ppRequireSecurityNegPol = NULL;
    return (dwError);
}


DWORD
CreateClientPolicy(
    HANDLE hPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pClientISAKMP = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NEGPOL_DATA pDefaultNegPol = NULL;
    GUID NFAIdentifier;
    GUID FilterIdentifier;
    LPWSTR pszNFAName = NULL;
    LPWSTR pszNFADescription = NULL;

    // {72385237-70FA-11d1-864C-14A300000000}
    static const GUID GUID_RESPONDER_ISAKMP =
    { 0x72385237, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    // {72385236-70FA-11d1-864C-14A300000000}
    static const GUID GUID_RESPONDER_POLICY =
    { 0x72385236, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    dwError = CreateISAKMP(
                  hPolicyStore,
                  GUID_RESPONDER_ISAKMP,
                  &pClientISAKMP
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyData = (PIPSEC_POLICY_DATA) AllocPolMem(
                       sizeof(IPSEC_POLICY_DATA)
                       );
    if (!pIpsecPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pIpsecPolicyData->PolicyIdentifier),
        &GUID_RESPONDER_POLICY,
        sizeof(GUID)
        );

    pIpsecPolicyData->dwPollingInterval = 10800;

    pIpsecPolicyData->pIpsecISAKMPData = NULL;
    pIpsecPolicyData->ppIpsecNFAData = NULL;
    pIpsecPolicyData->dwNumNFACount = 0;

    pIpsecPolicyData->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszIpsecName),
                                POLSTORE_CLIENT_POLICY_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszDescription),
                                POLSTORE_CLIENT_POLICY_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIpsecPolicyData->ISAKMPIdentifier),
        &(pClientISAKMP->ISAKMPIdentifier),
        sizeof(GUID)
        );

    dwError = IPSecCreatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateDefaultNegPol(
                  hPolicyStore,
                  &pDefaultNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memset(&FilterIdentifier, 0, sizeof(GUID));

    dwError = CreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_RESPONDER_POLICY,
                  FilterIdentifier,
                  pDefaultNegPol->NegPolIdentifier,
                  pszNFAName,
                  pszNFADescription
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pClientISAKMP) {
        FreeIpsecISAKMPData(pClientISAKMP);
    }

    if (pDefaultNegPol) {
        FreeIpsecNegPolData(pDefaultNegPol);
    }

    return (dwError);
}


DWORD
CreateRequestSecurityPolicy(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pAllFilter,
    PIPSEC_FILTER_DATA pAllICMPFilter,
    PIPSEC_NEGPOL_DATA pPermitNegPol,
    PIPSEC_NEGPOL_DATA pRequestSecurityNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pRequestSecurityISAKMP = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NEGPOL_DATA pDefaultNegPol = NULL;
    GUID NFAIdentifier;
    GUID FilterIdentifier;
    LPWSTR pszNFAName = NULL;
    LPWSTR pszNFADescription = NULL;

    // {72385231-70FA-11d1-864C-14A300000000}
    static const GUID GUID_SECURE_INITIATOR_ISAKMP =
    { 0x72385231, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    // {72385230-70FA-11d1-864C-14A300000000}
    static const GUID GUID_SECURE_INITIATOR_POLICY =
    { 0x72385230, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    dwError = CreateISAKMP(
                  hPolicyStore,
                  GUID_SECURE_INITIATOR_ISAKMP,
                  &pRequestSecurityISAKMP
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyData = (PIPSEC_POLICY_DATA) AllocPolMem(
                       sizeof(IPSEC_POLICY_DATA)
                       );
    if (!pIpsecPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pIpsecPolicyData->PolicyIdentifier),
        &GUID_SECURE_INITIATOR_POLICY,
        sizeof(GUID)
        );

    pIpsecPolicyData->dwPollingInterval = 10800;

    pIpsecPolicyData->pIpsecISAKMPData = NULL;
    pIpsecPolicyData->ppIpsecNFAData = NULL;
    pIpsecPolicyData->dwNumNFACount = 0;

    pIpsecPolicyData->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszIpsecName),
                                POLSTORE_SECURE_INITIATOR_POLICY_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszDescription),
                                POLSTORE_SECURE_INITIATOR_POLICY_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIpsecPolicyData->ISAKMPIdentifier),
        &(pRequestSecurityISAKMP->ISAKMPIdentifier),
        sizeof(GUID)
        );

    dwError = IPSecCreatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateDefaultNegPol(
                  hPolicyStore,
                  &pDefaultNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memset(&FilterIdentifier, 0, sizeof(GUID));

    dwError = CreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_SECURE_INITIATOR_POLICY,
                  FilterIdentifier,
                  pDefaultNegPol->NegPolIdentifier,
                  pszNFAName,
                  pszNFADescription
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the ICMP Rule.
    //

    dwError = MapIdAndCreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_SECURE_INITIATOR_POLICY,
                  pAllICMPFilter->FilterIdentifier,
                  pPermitNegPol->NegPolIdentifier,
                  POLSTORE_ICMP_NFA_NAME,
                  POLSTORE_ICMP_NFA_DESCRIPTION
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the Secure Initiator Rule.
    //

    dwError = MapIdAndCreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_SECURE_INITIATOR_POLICY,
                  pAllFilter->FilterIdentifier,
                  pRequestSecurityNegPol->NegPolIdentifier,
                  POLSTORE_SECURE_INITIATOR_NFA_NAME,
                  POLSTORE_SECURE_INITIATOR_NFA_DESCRIPTION
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pRequestSecurityISAKMP) {
        FreeIpsecISAKMPData(pRequestSecurityISAKMP);
    }

    if (pDefaultNegPol) {
        FreeIpsecNegPolData(pDefaultNegPol);
    }

    return (dwError);
}


DWORD
CreateRequireSecurityPolicy(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pAllFilter,
    PIPSEC_FILTER_DATA pAllICMPFilter,
    PIPSEC_NEGPOL_DATA pPermitNegPol,
    PIPSEC_NEGPOL_DATA pRequireSecurityNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pRequireSecurityISAKMP = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NEGPOL_DATA pDefaultNegPol = NULL;
    GUID NFAIdentifier;
    GUID FilterIdentifier;
    LPWSTR pszNFAName = NULL;
    LPWSTR pszNFADescription = NULL;

    // {7238523d-70FA-11d1-864C-14A300000000}
    static const GUID GUID_LOCKDOWN_ISAKMP =
    { 0x7238523d, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    // {7238523c-70FA-11d1-864C-14A300000000}
    static const GUID GUID_LOCKDOWN_POLICY =
    { 0x7238523c, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    dwError = CreateISAKMP(
                  hPolicyStore,
                  GUID_LOCKDOWN_ISAKMP,
                  &pRequireSecurityISAKMP
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyData = (PIPSEC_POLICY_DATA) AllocPolMem(
                       sizeof(IPSEC_POLICY_DATA)
                       );
    if (!pIpsecPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pIpsecPolicyData->PolicyIdentifier),
        &GUID_LOCKDOWN_POLICY,
        sizeof(GUID)
        );

    pIpsecPolicyData->dwPollingInterval = 10800;

    pIpsecPolicyData->pIpsecISAKMPData = NULL;
    pIpsecPolicyData->ppIpsecNFAData = NULL;
    pIpsecPolicyData->dwNumNFACount = 0;

    pIpsecPolicyData->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszIpsecName),
                                POLSTORE_LOCKDOWN_POLICY_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszDescription),
                                POLSTORE_LOCKDOWN_POLICY_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIpsecPolicyData->ISAKMPIdentifier),
        &(pRequireSecurityISAKMP->ISAKMPIdentifier),
        sizeof(GUID)
        );

    dwError = IPSecCreatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateDefaultNegPol(
                  hPolicyStore,
                  &pDefaultNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memset(&FilterIdentifier, 0, sizeof(GUID));

    dwError = CreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_LOCKDOWN_POLICY,
                  FilterIdentifier,
                  pDefaultNegPol->NegPolIdentifier,
                  pszNFAName,
                  pszNFADescription
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the ICMP Rule.
    //

    dwError = MapIdAndCreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_LOCKDOWN_POLICY,
                  pAllICMPFilter->FilterIdentifier,
                  pPermitNegPol->NegPolIdentifier,
                  POLSTORE_ICMP_NFA_NAME,
                  POLSTORE_ICMP_NFA_DESCRIPTION
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the Secure Initiator Rule.
    //

    dwError = MapIdAndCreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_LOCKDOWN_POLICY,
                  pAllFilter->FilterIdentifier,
                  pRequireSecurityNegPol->NegPolIdentifier,
                  POLSTORE_LOCKDOWN_NFA_NAME,
                  POLSTORE_LOCKDOWN_NFA_DESCRIPTION
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pRequireSecurityISAKMP) {
        FreeIpsecISAKMPData(pRequireSecurityISAKMP);
    }

    if (pDefaultNegPol) {
        FreeIpsecNegPolData(pDefaultNegPol);
    }

    return (dwError);
}


DWORD
CreateISAKMP(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPSecurityMethods = 0;
    PCRYPTO_BUNDLE pSecurityMethods = NULL;
    PCRYPTO_BUNDLE pBundle = NULL;


    pIpsecISAKMPData = (PIPSEC_ISAKMP_DATA) AllocPolMem(
                       sizeof(IPSEC_ISAKMP_DATA)
                       );
    if (!pIpsecISAKMPData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        &(ISAKMPIdentifier),
        sizeof(GUID)
        );

    memset(
        &(pIpsecISAKMPData->ISAKMPPolicy),
        0,
        sizeof(ISAKMP_POLICY)
        );

    dwNumISAKMPSecurityMethods = 4;

    pSecurityMethods = (PCRYPTO_BUNDLE) AllocPolMem(
                       sizeof(CRYPTO_BUNDLE)*dwNumISAKMPSecurityMethods
                       );
    if (!pSecurityMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pBundle = pSecurityMethods;

    pBundle->Lifetime.Seconds = 480*60;
    pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_3_DES;
    pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_SHA;
    pBundle->OakleyGroup = 2;
    pBundle++;

    pBundle->Lifetime.Seconds = 480*60;
    pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_3_DES;
    pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_MD5;
    pBundle->OakleyGroup = 2;
    pBundle++;

    pBundle->Lifetime.Seconds = 480*60;
    pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_DES;
    pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_SHA;
    pBundle->OakleyGroup = 1;
    pBundle++;

    pBundle->Lifetime.Seconds = 480*60;
    pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_DES;
    pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_MD5;
    pBundle->OakleyGroup = 1;

    pIpsecISAKMPData->dwNumISAKMPSecurityMethods = dwNumISAKMPSecurityMethods;
    pIpsecISAKMPData->pSecurityMethods = pSecurityMethods;

    pIpsecISAKMPData->dwWhenChanged = 0;

    dwError = IPSecCreateISAKMPData(
                  hPolicyStore,
                  pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecISAKMPData = pIpsecISAKMPData;
    return (dwError);

error:

    if (pIpsecISAKMPData) {
        FreeIpsecISAKMPData(pIpsecISAKMPData);
    }

    *ppIpsecISAKMPData = NULL;
    return (dwError);
}


DWORD
CreateDefaultNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppDefaultNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pDefaultNegPol = NULL;
    DWORD dwSecurityMethodCount = 0;
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods = NULL;
    PIPSEC_SECURITY_METHOD pMethod = NULL;


    pDefaultNegPol = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                      sizeof(IPSEC_NEGPOL_DATA)
                                      );
    if (!pDefaultNegPol) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidCreate(
                  &(pDefaultNegPol->NegPolIdentifier)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pDefaultNegPol->NegPolAction),
        &(GUID_NEGOTIATION_ACTION_NORMAL_IPSEC),
        sizeof(GUID)
        );

    memcpy(
        &(pDefaultNegPol->NegPolType),
        &(GUID_NEGOTIATION_TYPE_DEFAULT),
        sizeof(GUID)
        );

    dwSecurityMethodCount = 6;
    pIpsecSecurityMethods = (PIPSEC_SECURITY_METHOD) AllocPolMem(
                            sizeof(IPSEC_SECURITY_METHOD)*dwSecurityMethodCount
                            );
    if (!pIpsecSecurityMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMethod = pIpsecSecurityMethods;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_MD5;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_MD5;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Auth;
    pMethod->Algos[0].algoIdentifier = IPSEC_AH_SHA;
    pMethod->Algos[0].secondaryAlgoIdentifier = 0;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Auth;
    pMethod->Algos[0].algoIdentifier = IPSEC_AH_MD5;
    pMethod->Algos[0].secondaryAlgoIdentifier = 0;

    pDefaultNegPol->dwSecurityMethodCount = dwSecurityMethodCount;
    pDefaultNegPol->pIpsecSecurityMethods = pIpsecSecurityMethods;

    pDefaultNegPol->dwWhenChanged = 0;

    pDefaultNegPol->pszIpsecName = NULL;

    pDefaultNegPol->pszDescription = NULL;

    dwError = IPSecCreateNegPolData(
                  hPolicyStore,
                  pDefaultNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppDefaultNegPol = pDefaultNegPol;

    return (dwError);

error:

    if (pDefaultNegPol) {
        FreeIpsecNegPolData(pDefaultNegPol);
    }

    *ppDefaultNegPol = NULL;
    return (dwError);
}


DWORD
CreateNFA(
    HANDLE hPolicyStore,
    GUID NFAIdentifier,
    GUID PolicyIdentifier,
    GUID FilterIdentifier,
    GUID NegPolIdentifier,
    LPWSTR pszNFAName,
    LPWSTR pszNFADescription
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    DWORD dwAuthMethodCount = 0;
    PIPSEC_AUTH_METHOD * ppAuthMethods = NULL;
    PIPSEC_AUTH_METHOD pMethod = NULL;


    pIpsecNFAData = (PIPSEC_NFA_DATA) AllocPolMem(
                    sizeof(IPSEC_NFA_DATA)
                    );
    if (!pIpsecNFAData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pszNFAName) {
        pIpsecNFAData->pszIpsecName = AllocPolStr(pszNFAName);
        if (!pIpsecNFAData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    memcpy(
        &(pIpsecNFAData->NFAIdentifier),
        &(NFAIdentifier),
        sizeof(GUID)
        );

    dwAuthMethodCount = 1;
    ppAuthMethods = (PIPSEC_AUTH_METHOD *) AllocPolMem(
                    sizeof(PIPSEC_AUTH_METHOD)*dwAuthMethodCount
                    );
    if (!ppAuthMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pIpsecNFAData->dwAuthMethodCount = dwAuthMethodCount;
    pIpsecNFAData->ppAuthMethods = ppAuthMethods;

    pMethod = (PIPSEC_AUTH_METHOD) AllocPolMem(
              sizeof(IPSEC_AUTH_METHOD)
              );
    if (!pMethod) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMethod->dwAuthType = OAK_SSPI;
    pMethod->dwAuthLen = 0;
    pMethod->pszAuthMethod = NULL;
    pMethod->dwAltAuthLen = 0;
    pMethod->pAltAuthMethod = NULL;

    *(ppAuthMethods + 0) = pMethod;

    pIpsecNFAData->dwInterfaceType = PS_INTERFACE_TYPE_ALL;
    pIpsecNFAData->pszInterfaceName = NULL;

    pIpsecNFAData->dwTunnelIpAddr = 0;
    pIpsecNFAData->dwTunnelFlags = 0;

    pIpsecNFAData->dwActiveFlag = 1;

    pIpsecNFAData->pszEndPointName = NULL;

    pIpsecNFAData->pIpsecFilterData = NULL;
    pIpsecNFAData->pIpsecNegPolData = NULL;

    pIpsecNFAData->dwWhenChanged = 0;

    memcpy(
        &(pIpsecNFAData->NegPolIdentifier),
        &(NegPolIdentifier),
        sizeof(GUID)
        );
    memcpy(
        &(pIpsecNFAData->FilterIdentifier),
        &(FilterIdentifier),
        sizeof(GUID)
        );

    if (pszNFADescription) {
        pIpsecNFAData->pszDescription = AllocPolStr(pszNFADescription);
        if (!pIpsecNFAData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    dwError = IPSecCreateNFAData(
                  hPolicyStore,
                  PolicyIdentifier,
                  pIpsecNFAData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAData) {
        FreeIpsecNFAData(pIpsecNFAData);
    }

    return (dwError);
}


DWORD
MapIdAndCreateNFA(
    HANDLE hPolicyStore,
    GUID NFAIdentifier,
    GUID PolicyIdentifier,
    GUID FilterIdentifier,
    GUID NegPolIdentifier,
    DWORD dwNFANameID,
    DWORD dwNFADescriptionID
    )
{
    LPWSTR pszNFAName = NULL, pszNFADescription = NULL;
    DWORD dwError = 0;

    dwError = MapAndAllocPolStr(&pszNFAName, dwNFANameID);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&pszNFADescription, dwNFADescriptionID);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError =  CreateNFA(hPolicyStore,
                        NFAIdentifier,
                        PolicyIdentifier,
                        FilterIdentifier,
                        NegPolIdentifier,
                        pszNFAName,
                        pszNFADescription
                        );
error:
    LocalFree(pszNFADescription);
    LocalFree(pszNFAName);

    return dwError;
}


DWORD
MapAndAllocPolStr(
    LPWSTR * plpStr,
    DWORD dwStrID
    )
{
    LPWSTR lpStr;
    DWORD dwResult;

    dwResult = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE
                            | FORMAT_MESSAGE_IGNORE_INSERTS,
                            GetModuleHandleW(SZAPPNAME),
                            dwStrID, LANG_NEUTRAL,
                            (LPWSTR) plpStr, 0, NULL);

    if (dwResult == 0) {
       *plpStr = NULL;
       return GetLastError();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\reginit.h ===
DWORD
GenerateDefaultInformation(
    HANDLE hPolicyStore
    );

DWORD
CreateAllFilter(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA * ppAllFilter
    );

DWORD
CreateAllICMPFilter(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA * ppAllICMPFilter
    );

DWORD
CreatePermitNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppPermitNegPol
    );

DWORD
CreateRequestSecurityNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppRequestSecurityNegPol
    );

DWORD
CreateRequireSecurityNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppRequireSecurityNegPol
    );

DWORD
CreateClientPolicy(
    HANDLE hPolicyStore
    );

DWORD
CreateRequestSecurityPolicy(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pAllFilter,
    PIPSEC_FILTER_DATA pAllICMPFilter,
    PIPSEC_NEGPOL_DATA pPermitNegPol,
    PIPSEC_NEGPOL_DATA pRequestSecurityNegPol
    );

DWORD
CreateRequireSecurityPolicy(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pAllFilter,
    PIPSEC_FILTER_DATA pAllICMPFilter,
    PIPSEC_NEGPOL_DATA pPermitNegPol,
    PIPSEC_NEGPOL_DATA pRequireSecurityNegPol
    );

DWORD
CreateISAKMP(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
CreateDefaultNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppDefaultNegPol
    );

DWORD
CreateNFA(
    HANDLE hPolicyStore,
    GUID NFAIdentifier,
    GUID PolicyIdentifier,
    GUID FilterIdentifier,
    GUID NegPolIdentifier,
    LPWSTR pszNFAName,
    LPWSTR pszNFADescription
    );

DWORD
MapIdAndCreateNFA(
    HANDLE hPolicyStore,
    GUID NFAIdentifier,
    GUID PolicyIdentifier,
    GUID FilterIdentifier,
    GUID NegPolIdentifier,
    DWORD dwNFANameID,
    DWORD dwNFADescriptionID
    );

DWORD
MapAndAllocPolStr(
    LPWSTR * plpStr,
    DWORD dwStrID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\restore-r.h ===
DWORD
RegRestoreDefaults(
    HANDLE hPolicyStore,
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    );

DWORD
RegRemoveDefaults(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    );

DWORD
RegDeleteDefaultPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID PolicyGUID
    );

DWORD
RegDeleteDynamicDefaultNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID NegPolGUID
    );

DWORD
RegRemoveOwnersReferenceInFilter(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegRemoveOwnersReferenceInNegPol(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegRemoveOwnersReferenceInISAKMP(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegDeleteDefaultFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegDeleteDefaultNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegDeleteDefaultISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegUpdateFilterOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNumNFAReferences
    );


DWORD
RegUpdateNegPolOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNumNFAReferences
    );


DWORD
RegUpdateISAKMPOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR * ppszIpsecPolicyReferences,
    DWORD dwNumPolicyReferences
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\refer-r.h ===
//
// Policy Object References
//

DWORD
RegAddNFAReferenceToPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFADistinguishedName
    );

DWORD
RegRemoveNFAReferenceFromPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    );

//
// NFA Object References
//

DWORD
RegAddPolicyReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecPolicyName
    );


DWORD
RegAddNegPolReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecNegPolName
    );

DWORD
RegUpdateNegPolReferenceInNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecNegPolName,
    LPWSTR pszNewIpsecNegPolName
    );


DWORD
RegAddFilterReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecFilterName
    );

DWORD
RegUpdateFilterReferenceInNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecFilterName,
    LPWSTR pszNewIpsecFilterName
    );


//
// Filter Object References
//


DWORD
RegAddNFAReferenceToFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    );

DWORD
RegDeleteNFAReferenceInFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    );

//
// NegPol Object References
//


DWORD
RegAddNFAReferenceToNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
RegDeleteNFAReferenceInNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
AddValueToMultiSz(
    LPBYTE pValueData,
    DWORD dwSize,
    LPWSTR pszValuetoAdd,
    LPBYTE * ppNewValueData,
    DWORD * pdwNewSize
    );

DWORD
DeleteValueFromMultiSz(
    LPBYTE pValueData,
    DWORD dwSize,
    LPWSTR pszValuetoDel,
    LPBYTE * ppNewValueData,
    DWORD * pdwNewSize
    );

DWORD
RegDelFilterRefValueOfNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName
    );

DWORD
RegAddPolicyReferenceToISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyDistinguishedName
    );

DWORD
RegRemovePolicyReferenceFromISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    );

DWORD
RegAddISAKMPReferenceToPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecISAKMPName
    );

DWORD
RegUpdateISAKMPReferenceInPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszOldIpsecISAKMPName,
    LPWSTR pszNewIpsecISAKMPName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\restore-r.c ===
#include "precomp.h"


DWORD
RegRestoreDefaults(
    HANDLE hPolicyStore,
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;

    LPWSTR * ppszIpsecAllFilterNFAReferences = NULL;
    DWORD dwNumAllFilterNFAReferences = 0;
    LPWSTR * ppszIpsecAllICMPFilterNFAReferences = NULL;
    DWORD dwNumAllICMPFilterNFAReferences = 0;

    LPWSTR * ppszIpsecPermitNegPolNFAReferences = NULL;
    DWORD dwNumPermitNegPolNFAReferences = 0;
    LPWSTR * ppszIpsecSecIniNegPolNFAReferences = NULL;
    DWORD dwNumSecIniNegPolNFAReferences = 0;
    LPWSTR * ppszIpsecLockdownNegPolNFAReferences = NULL;
    DWORD dwNumLockdownNegPolNFAReferences = 0;


    LPWSTR * ppszIpsecLockdownISAKMPPolicyReferences = NULL;
    DWORD dwNumLockdownISAKMPPolicyReferences = 0;
    LPWSTR * ppszIpsecSecIniISAKMPPolicyReferences = NULL;
    DWORD dwNumSecIniISAKMPPolicyReferences = 0;
    LPWSTR * ppszIpsecResponderISAKMPPolicyReferences = NULL;
    DWORD dwNumResponderISAKMPPolicyReferences = 0;
    LPWSTR * ppszIpsecDefaultISAKMPPolicyReferences = NULL;
    DWORD dwNumDefaultISAKMPPolicyReferences = 0;

    static const GUID GUID_ALL_FILTER=
    { 0x7238523a, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_ALL_ICMP_FILTER =
    { 0x72385235, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_PERMIT_NEGPOL =
    { 0x7238523b, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_SECURE_INITIATOR_NEGPOL =
    { 0x72385233, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_LOCKDOWN_NEGPOL =
    { 0x7238523f, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };
 
    static const GUID GUID_RESPONDER_ISAKMP =
    { 0x72385237, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_SECURE_INITIATOR_ISAKMP =
    { 0x72385231, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_LOCKDOWN_ISAKMP =
    { 0x7238523d, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_DEFAULT_ISAKMP=
    { 0x72385234, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    dwError = RegRemoveDefaults(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName
                  );

    dwError = RegDeleteDefaultFilterData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_ALL_FILTER,
                  &ppszIpsecAllFilterNFAReferences,
                  &dwNumAllFilterNFAReferences
                  );

    dwError = RegDeleteDefaultFilterData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_ALL_ICMP_FILTER,
                  &ppszIpsecAllICMPFilterNFAReferences,
                  &dwNumAllICMPFilterNFAReferences
                  );

    dwError = RegDeleteDefaultNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_PERMIT_NEGPOL,
                  &ppszIpsecPermitNegPolNFAReferences,
                  &dwNumPermitNegPolNFAReferences
                  );

    dwError = RegDeleteDefaultNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_SECURE_INITIATOR_NEGPOL,
                  &ppszIpsecSecIniNegPolNFAReferences,
                  &dwNumSecIniNegPolNFAReferences
                  );

    dwError = RegDeleteDefaultNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_LOCKDOWN_NEGPOL,
                  &ppszIpsecLockdownNegPolNFAReferences,
                  &dwNumLockdownNegPolNFAReferences
                  );

    dwError = RegDeleteDefaultISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_LOCKDOWN_ISAKMP,
                  &ppszIpsecLockdownISAKMPPolicyReferences,
                  &dwNumLockdownISAKMPPolicyReferences
                  );

    dwError = RegDeleteDefaultISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_SECURE_INITIATOR_ISAKMP,
                  &ppszIpsecSecIniISAKMPPolicyReferences,
                  &dwNumSecIniISAKMPPolicyReferences
                  );

    dwError = RegDeleteDefaultISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_RESPONDER_ISAKMP,
                  &ppszIpsecResponderISAKMPPolicyReferences,
                  &dwNumResponderISAKMPPolicyReferences
                  );

    dwError = RegDeleteDefaultISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_DEFAULT_ISAKMP,
                  &ppszIpsecDefaultISAKMPPolicyReferences,
                  &dwNumDefaultISAKMPPolicyReferences
                  );

    dwError = GenerateDefaultInformation(
                  hPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUpdateFilterOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_ALL_FILTER,
                  ppszIpsecAllFilterNFAReferences,
                  dwNumAllFilterNFAReferences
                  );

    dwError = RegUpdateFilterOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_ALL_ICMP_FILTER,
                  ppszIpsecAllICMPFilterNFAReferences,
                  dwNumAllICMPFilterNFAReferences
                  );

    dwError = RegUpdateNegPolOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_LOCKDOWN_NEGPOL,
                  ppszIpsecLockdownNegPolNFAReferences,
                  dwNumLockdownNegPolNFAReferences
                  );

    dwError = RegUpdateNegPolOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_SECURE_INITIATOR_NEGPOL,
                  ppszIpsecSecIniNegPolNFAReferences,
                  dwNumSecIniNegPolNFAReferences
                  );

    dwError = RegUpdateNegPolOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_PERMIT_NEGPOL,
                  ppszIpsecPermitNegPolNFAReferences,
                  dwNumPermitNegPolNFAReferences
                  );

    dwError = RegUpdateISAKMPOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_LOCKDOWN_ISAKMP,
                  ppszIpsecLockdownISAKMPPolicyReferences,
                  dwNumLockdownISAKMPPolicyReferences
                  );

    dwError = RegUpdateISAKMPOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_SECURE_INITIATOR_ISAKMP,
                  ppszIpsecSecIniISAKMPPolicyReferences,
                  dwNumSecIniISAKMPPolicyReferences
                  );

    dwError = RegUpdateISAKMPOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_RESPONDER_ISAKMP,
                  ppszIpsecResponderISAKMPPolicyReferences,
                  dwNumResponderISAKMPPolicyReferences
                  );

    dwError = RegUpdateISAKMPOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_DEFAULT_ISAKMP,
                  ppszIpsecDefaultISAKMPPolicyReferences,
                  dwNumDefaultISAKMPPolicyReferences
                  );

    (VOID) RegPingPASvcForActivePolicy(
               hRegistryKey,
               pszIpsecRootContainer,
               pszLocationName
               );

error:

    if (ppszIpsecAllFilterNFAReferences) {
        FreeNFAReferences(
            ppszIpsecAllFilterNFAReferences,
            dwNumAllFilterNFAReferences
            );
    }

    if (ppszIpsecAllICMPFilterNFAReferences) {
        FreeNFAReferences(
            ppszIpsecAllICMPFilterNFAReferences,
            dwNumAllICMPFilterNFAReferences
            );
    }

    if (ppszIpsecPermitNegPolNFAReferences) {
        FreeNFAReferences(
            ppszIpsecPermitNegPolNFAReferences,
            dwNumPermitNegPolNFAReferences
            );
    }

    if (ppszIpsecSecIniNegPolNFAReferences) {
        FreeNFAReferences(
            ppszIpsecSecIniNegPolNFAReferences,
            dwNumSecIniNegPolNFAReferences
            );
    }

    if (ppszIpsecLockdownNegPolNFAReferences) {
        FreeNFAReferences(
            ppszIpsecLockdownNegPolNFAReferences,
            dwNumLockdownNegPolNFAReferences
            );
    }

    if (ppszIpsecResponderISAKMPPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecResponderISAKMPPolicyReferences,
            dwNumResponderISAKMPPolicyReferences
            );
    }

    if (ppszIpsecSecIniISAKMPPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecSecIniISAKMPPolicyReferences,
            dwNumSecIniISAKMPPolicyReferences
            );
    }

    if (ppszIpsecLockdownISAKMPPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecLockdownISAKMPPolicyReferences,
            dwNumLockdownISAKMPPolicyReferences
            );
    }

    if (ppszIpsecDefaultISAKMPPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecDefaultISAKMPPolicyReferences,
            dwNumDefaultISAKMPPolicyReferences
            );
    }

    return (dwError);
}


DWORD
RegRemoveDefaults(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;

    static const GUID GUID_RESPONDER_POLICY =
    { 0x72385236, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_SECURE_INITIATOR_POLICY =
    { 0x72385230, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_LOCKDOWN_POLICY =
    { 0x7238523c, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    dwError = RegDeleteDefaultPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  GUID_LOCKDOWN_POLICY
                  );
    
    dwError = RegDeleteDefaultPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  GUID_SECURE_INITIATOR_POLICY
                  );

    dwError = RegDeleteDefaultPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  GUID_RESPONDER_POLICY
                  );

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
RegDeleteDefaultPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD dwNumNFAObjects = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    dwError = RegGetPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyGUID,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegEnumNFAData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyGUID,
                  &ppIpsecNFAData,
                  &dwNumNFAObjects
                  );
    
    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        dwError = RegDeleteNFAData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      PolicyGUID,
                      pszLocationName,
                      pIpsecNFAData
                      );

        dwError = RegDeleteDynamicDefaultNegPolData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszLocationName,
                      pIpsecNFAData->NegPolIdentifier
                      );

    }

    dwError = RegDeletePolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
    
    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            dwNumNFAObjects
            );
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(
            pIpsecPolicyData
            );
    }

    return(dwError);        
}


DWORD
RegDeleteDynamicDefaultNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID NegPolGUID
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = RegGetNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  NegPolGUID,
                  &pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType),
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {

        dwError = RegDeleteNegPolData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      NegPolGUID
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pIpsecNegPolData) {
        FreeIpsecNegPolData(
            pIpsecNegPolData
            );
    }

    return(dwError);        
}


DWORD
RegDeleteDefaultFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;


    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    dwError = RegRemoveOwnersReferenceInFilter(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  FilterIdentifier,
                  pppszIpsecNFAReferences,
                  pdwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteFilterData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  FilterIdentifier
                  );
error:

    return (dwError);
}


DWORD
RegDeleteDefaultNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;


    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    dwError = RegRemoveOwnersReferenceInNegPol(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  NegPolIdentifier,
                  pppszIpsecNFAReferences,
                  pdwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  NegPolIdentifier
                  );
error:

    return (dwError);
}


DWORD
RegDeleteDefaultISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;


    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    dwError = RegRemoveOwnersReferenceInISAKMP(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  ISAKMPIdentifier,
                  pppszIpsecPolicyReferences,
                  pdwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  ISAKMPIdentifier
                  );
error:

    return (dwError);
}


DWORD
RegRemoveOwnersReferenceInFilter(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecFilterReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;

    dwError = ConvertGuidToFilterString(
                  FilterIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecFilterReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecFilterReference + dwRootPathLen + 1;

    dwError = RegGetNFAReferencesForFilter(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszRelativeName,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegDeleteNFAReferenceInFilterObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecNFAReference
                      );

    }

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pszIpsecFilterReference) {
        FreePolStr(
            pszIpsecFilterReference
            );
    }

    return(dwError);

error:

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;
    goto cleanup;
}


DWORD
RegRemoveOwnersReferenceInNegPol(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecNegPolReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;

    dwError = ConvertGuidToNegPolString(
                  NegPolIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecNegPolReference + dwRootPathLen + 1;

    dwError = RegGetNFAReferencesForNegPol(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszRelativeName,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegDeleteNFAReferenceInNegPolObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecNFAReference
                      );

    }

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pszIpsecNegPolReference) {
        FreePolStr(
            pszIpsecNegPolReference
            );
    }

    return(dwError);

error:

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;
    goto cleanup;
}


DWORD
RegRemoveOwnersReferenceInISAKMP(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;

    dwError = ConvertGuidToISAKMPString(
                  ISAKMPIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecISAKMPReference + dwRootPathLen + 1;

    dwError = RegGetPolicyReferencesForISAKMP(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszRelativeName,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = RegRemovePolicyReferenceFromISAKMPObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecPolicyReference
                      );

    }

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pszIpsecISAKMPReference) {
        FreePolStr(
            pszIpsecISAKMPReference
            );
    }

    return(dwError);

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;
    goto cleanup;
}


DWORD
RegUpdateFilterOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNumNFAReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecFilterReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;


    dwError = ConvertGuidToFilterString(
                  FilterIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecFilterReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    pszRelativeName = pszIpsecFilterReference + dwRootPathLen + 1;

    for (i = 0; i < dwNumNFAReferences; i++) {
          
        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegAddNFAReferenceToFilterObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecNFAReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pszIpsecFilterReference) {
        FreePolStr(
            pszIpsecFilterReference
            );
    }

    return(dwError);
}


DWORD
RegUpdateNegPolOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNumNFAReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecNegPolReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;


    dwError = ConvertGuidToNegPolString(
                  NegPolIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    pszRelativeName = pszIpsecNegPolReference + dwRootPathLen + 1;

    for (i = 0; i < dwNumNFAReferences; i++) {
          
        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegAddNFAReferenceToNegPolObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecNFAReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pszIpsecNegPolReference) {
        FreePolStr(
            pszIpsecNegPolReference
            );
    }

    return(dwError);
}


DWORD
RegUpdateISAKMPOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR * ppszIpsecPolicyReferences,
    DWORD dwNumPolicyReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = ConvertGuidToISAKMPString(
                  ISAKMPIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    pszRelativeName = pszIpsecISAKMPReference + dwRootPathLen + 1;

    for (i = 0; i < dwNumPolicyReferences; i++) {
          
        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = RegAddPolicyReferenceToISAKMPObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pszIpsecISAKMPReference) {
        FreePolStr(
            pszIpsecISAKMPReference
            );
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\rules-f.c ===
#include "precomp.h"


DWORD
ExportNFADataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD j = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD dwNumNFAObjects = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        ppIpsecNFAData = NULL;
        dwNumNFAObjects = 0;

        dwError = IPSecEnumNFAData(
                      hSrcPolicyStore,
                      pIpsecPolicyData->PolicyIdentifier,
                      &ppIpsecNFAData,
                      &dwNumNFAObjects
                      );
        if (dwError) {
            continue;
        }

        for (j = 0; j < dwNumNFAObjects; j++) {

            pIpsecNFAData = *(ppIpsecNFAData + j);

            dwError = RegCreateNFAData(
                          pDesPolicyStore->hRegistryKey,
                          pDesPolicyStore->pszIpsecRootContainer,
                          pIpsecPolicyData->PolicyIdentifier,
                          pDesPolicyStore->pszLocationName,
                          pIpsecNFAData
                          );
            if (dwError) {
                continue;
            }

        }

        if (ppIpsecNFAData) {
            FreeMulIpsecNFAData(
                ppIpsecNFAData,
                dwNumNFAObjects
                );
        }

    }

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
ImportNFADataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD j = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD dwNumNFAObjects = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        ppIpsecNFAData = NULL;
        dwNumNFAObjects = 0;

        dwError = RegEnumNFAData(
                      pSrcPolicyStore->hRegistryKey,
                      pSrcPolicyStore->pszIpsecRootContainer,
                      pIpsecPolicyData->PolicyIdentifier,
                      &ppIpsecNFAData,
                      &dwNumNFAObjects
                      );
        if (dwError) {
            continue;
        }

        for (j = 0; j < dwNumNFAObjects; j++) {

            pIpsecNFAData = *(ppIpsecNFAData + j);

            dwError = IPSecCreateNFAData(
                          hDesPolicyStore,
                          pIpsecPolicyData->PolicyIdentifier,
                          pIpsecNFAData
                          );
            if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
                dwError = IPSecSetNFAData(
                              hDesPolicyStore,
                              pIpsecPolicyData->PolicyIdentifier,
                              pIpsecNFAData
                              );
            }
            if (dwError) {
                continue;
            }

        }

        if (ppIpsecNFAData) {
            FreeMulIpsecNFAData(
                ppIpsecNFAData,
                dwNumNFAObjects
                );
        }

    }

    dwError = ERROR_SUCCESS;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\rules-f.h ===
DWORD
ExportNFADataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    );

DWORD
ImportNFADataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\rules-d.h ===
DWORD
DirEnumNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    );

DWORD
DirEnumNFAObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    );

DWORD
DirGetNFADNsForPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    LPWSTR ** pppszNFADNs,
    PDWORD pdwNumNFAObjects
    );

DWORD
DirUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
DirCreateNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
DirMarshallNFAObject(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    );

DWORD
ConvertGuidToDirFilterString(
    GUID FilterIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecFilterReference
    );

DWORD
ConvertGuidToDirNegPolString(
    GUID NegPolIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecNegPolReference
    );

DWORD
DirCreateNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
DirMarshallAddNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirSetNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
DirSetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
DirMarshallSetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirDeleteNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
DirGetNFAExistingFilterRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszIpsecFilterName
    );

DWORD
GenerateSpecificNFAQuery(
    GUID NFAIdentifier,
    LPWSTR * ppszNFAString
    );

DWORD
DirGetNFAExistingNegPolRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszIpsecNegPolName
    );

DWORD
DirGetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NFAGUID,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\rules-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       rules-d.c
//
//  Contents:   Rule management for directory.
//
//
//  History:    AbhisheV
//
//----------------------------------------------------------------------------


#include "precomp.h"

extern LPWSTR NFADNAttributes[];
extern LPWSTR PolicyDNAttributes[];

DWORD
DirEnumNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject = NULL;
    DWORD dwNumNFAObjects = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    DWORD j = 0;


    dwError = GenerateSpecificPolicyQuery(
                  PolicyIdentifier,
                  &pszPolicyString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirEnumNFAObjects(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pszPolicyString,
                  &ppIpsecNFAObject,
                  &dwNumNFAObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumNFAObjects) {
        ppIpsecNFAData = (PIPSEC_NFA_DATA *)AllocPolMem(
                                sizeof(PIPSEC_NFA_DATA)*dwNumNFAObjects
                                );
        if (!ppIpsecNFAData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAObject = *(ppIpsecNFAObject + i);

        dwError = DirUnmarshallNFAData(
                        pIpsecNFAObject,
                        &pIpsecNFAData
                        );
        if (!dwError) {
            *(ppIpsecNFAData + j) = pIpsecNFAData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecNFAData) {
            FreePolMem(ppIpsecNFAData);
            ppIpsecNFAData = NULL;
        }
    }

    *pppIpsecNFAData = ppIpsecNFAData;
    *pdwNumNFAObjects  = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecNFAObject) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObject,
            dwNumNFAObjects
            );
    }

    if (pszPolicyString) {
        FreePolStr(pszPolicyString);
    }

    return(dwError);

error:

    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            i
            );
    }

    *pppIpsecNFAData  = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
DirEnumNFAObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszNFADNs = NULL;
    DWORD dwNumNFAObjects = 0;
    LPWSTR pszFilterString = NULL;
    LDAPMessage *res = NULL;
    DWORD dwCount = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    DWORD i = 0;
    LDAPMessage *e = NULL;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    DWORD dwNumNFAObjectsReturned = 0;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    dwError = DirGetNFADNsForPolicy(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pszIpsecPolicyName,
                  &ppszNFADNs,
                  &dwNumNFAObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GenerateNFAQuery(
                  ppszNFADNs,
                  dwNumNFAObjects,
                  &pszFilterString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecNFAObjects  = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                              sizeof(PIPSEC_NFA_OBJECT)*dwCount
                                              );
    if (!ppIpsecNFAObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwCount; i++) {

        if (i == 0) {
            dwError = LdapFirstEntry(
                          hLdapBindHandle,
                          res,
                          &e
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        else {
            dwError = LdapNextEntry(
                          hLdapBindHandle,
                          e,
                          &e
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }

        dwError =UnMarshallNFAObject(
                     hLdapBindHandle,
                     e,
                     &pIpsecNFAObject,
                     &pszFilterReference,
                     &pszNegPolReference
                     );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNFAObjects + dwNumNFAObjectsReturned) = pIpsecNFAObject;
            dwNumNFAObjectsReturned++;

            if (pszFilterReference) {
                FreePolStr(pszFilterReference);
                pszFilterReference = NULL;
            }

            if (pszNegPolReference) {
                FreePolStr(pszNegPolReference);
                pszNegPolReference = NULL;
            }

        }

    }

    *pppIpsecNFAObjects = ppIpsecNFAObjects;
    *pdwNumNFAObjects = dwNumNFAObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (res) {
        LdapMsgFree(res);
    }

    if (pszFilterString) {
        FreePolStr(pszFilterString);
    }

    if (ppszNFADNs) {
        FreeNFAReferences(
            ppszNFADNs,
            dwNumNFAObjects
            );
    }

    return(dwError);

error:

    if (ppIpsecNFAObjects) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObjects,
            dwNumNFAObjectsReturned
            );
    }

    *pppIpsecNFAObjects = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
DirGetNFADNsForPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    LPWSTR ** pppszNFADNs,
    PDWORD pdwNumNFAObjects
    )
{
    DWORD dwError = 0;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;
    LPWSTR * ppszNFADNs = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    DWORD dwNumberOfRules = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR pszNFADN = NULL;


    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszIpsecPolicyName,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallPolicyObject2(
                  hLdapBindHandle,
                  e,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ppszIpsecNFANames = pIpsecPolicyObject->ppszIpsecNFAReferences;
    dwNumberOfRules = pIpsecPolicyObject->NumberofRules;

    if (!dwNumberOfRules) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszNFADNs = (LPWSTR *)AllocPolMem(
                               sizeof(LPWSTR)*dwNumberOfRules
                               );
    if (!ppszNFADNs) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNumberOfRules; i++) {

        pszIpsecNFAName = *(ppszIpsecNFANames + i);

        pszNFADN = AllocPolStr(pszIpsecNFAName);

        if (!pszNFADN) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszNFADNs + i) = pszNFADN;

    }

    *pppszNFADNs = ppszNFADNs;
    *pdwNumNFAObjects = dwNumberOfRules;

cleanup:

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return(dwError);

error:

    if (ppszNFADNs) {
        FreeNFAReferences(
            ppszNFADNs,
            i
            );
    }

    *pppszNFADNs = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
DirUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNFAObject(
                  pIpsecNFAObject,
                  IPSEC_DIRECTORY_PROVIDER,
                  ppIpsecNFAData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
DirCreateNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = DirMarshallNFAObject(
                        pIpsecNFAData,
                        pszIpsecRootContainer,
                        &pIpsecNFAObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ConvertGuidToDirPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreateNFAObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the policy object reference.
    //

    dwError = DirAddNFAReferenceToPolicyObject(
                  hLdapBindHandle,
                  pszIpsecPolicyReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the NFA object reference.
    //

    dwError = DirAddPolicyReferenceToNFAObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszDistinguishedName,
                  pszIpsecPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the filter object reference for the NFA
    // only if the NFA is not a default rule.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirAddNFAReferenceToFilterObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszIpsecFilterReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the NFA object reference for the filter
    // only if the NFA is not a default rule.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirAddFilterReferenceToNFAObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszDistinguishedName,
                      pIpsecNFAObject->pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the negpol object reference for the NFA.
    //

    dwError = DirAddNFAReferenceToNegPolObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszIpsecNegPolReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the NFA object reference for the negpol.
    //

    dwError = DirAddNegPolReferenceToNFAObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszDistinguishedName,
                  pIpsecNFAObject->pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(
            pIpsecNFAObject
            );
    }

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    return(dwError);
}


DWORD
DirMarshallNFAObject(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszIpsecFilterReference = NULL;
    LPWSTR pszIpsecNegPolReference = NULL;
    GUID ZeroGuid;


    memset(&ZeroGuid, 0, sizeof(GUID));

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_NFA_OBJECT)
                                                    );
    if (!pIpsecNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNFAData->NFAIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecNFA");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    wcscat(szDistinguishedName, pszIpsecRootContainer);

    pIpsecNFAObject->pszDistinguishedName = AllocPolStr(
                                                szDistinguishedName
                                                );
    if (!pIpsecNFAObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecNFAData->pszIpsecName &&
        *pIpsecNFAData->pszIpsecName) {

        pIpsecNFAObject->pszIpsecName = AllocPolStr(
                                            pIpsecNFAData->pszIpsecName
                                            );
        if (!pIpsecNFAObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAData->pszDescription &&
        *pIpsecNFAData->pszDescription) {

        pIpsecNFAObject->pszDescription = AllocPolStr(
                                            pIpsecNFAData->pszDescription
                                            );
        if (!pIpsecNFAObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecNFAObject->pszIpsecID = AllocPolStr(
                                      szGuid
                                      );
    if (!pIpsecNFAObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecNFAObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallNFABuffer(
                    pIpsecNFAData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->pIpsecData  = pBuffer;

    pIpsecNFAObject->dwIpsecDataLen = dwBufferLen;

    //
    // Marshall the Filter Reference.
    // There's no filter reference for a default rule.
    //

    if (memcmp(
            &pIpsecNFAData->FilterIdentifier,
            &ZeroGuid,
            sizeof(GUID))) {
        dwError = ConvertGuidToDirFilterString(
                      pIpsecNFAData->FilterIdentifier,
                      pszIpsecRootContainer,
                      &pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecNFAObject->pszIpsecFilterReference = pszIpsecFilterReference;
    }
    else {
        pIpsecNFAObject->pszIpsecFilterReference = NULL;
    }

    //
    // Marshall the NegPol Reference
    //

    dwError = ConvertGuidToDirNegPolString(
                    pIpsecNFAData->NegPolIdentifier,
                    pszIpsecRootContainer,
                    &pszIpsecNegPolReference
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecNFAObject->pszIpsecNegPolReference = pszIpsecNegPolReference;

    pIpsecNFAObject->dwWhenChanged = 0;

    *ppIpsecNFAObject = pIpsecNFAObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(
                pIpsecNFAObject
                );
    }

    *ppIpsecNFAObject = NULL;
    goto cleanup;
}


DWORD
ConvertGuidToDirFilterString(
    GUID FilterIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecFilterReference
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szGuidString[MAX_PATH];
    WCHAR szFilterReference[MAX_PATH];
    LPWSTR pszIpsecFilterReference = NULL;


    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szFilterReference[0] = L'\0';
    wcscpy(szFilterReference,L"CN=ipsecFilter");
    wcscat(szFilterReference, szGuidString);
    wcscat(szFilterReference, L",");
    wcscat(szFilterReference, pszIpsecRootContainer);

    pszIpsecFilterReference = AllocPolStr(
                                    szFilterReference
                                    );
    if (!pszIpsecFilterReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecFilterReference = pszIpsecFilterReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecFilterReference = NULL;

    goto cleanup;
}


DWORD
ConvertGuidToDirNegPolString(
    GUID NegPolIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecNegPolReference
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szGuidString[MAX_PATH];
    WCHAR szNegPolReference[MAX_PATH];
    LPWSTR pszIpsecNegPolReference = NULL;


    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szNegPolReference[0] = L'\0';
    wcscpy(szNegPolReference,L"CN=ipsecNegotiationPolicy");
    wcscat(szNegPolReference, szGuidString);
    wcscat(szNegPolReference, L",");
    wcscat(szNegPolReference, pszIpsecRootContainer);

    pszIpsecNegPolReference = AllocPolStr(
                                    szNegPolReference
                                    );
    if (!pszIpsecNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecNegPolReference = pszIpsecNegPolReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecNegPolReference = NULL;

    goto cleanup;
}


DWORD
DirCreateNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddNFAObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecNFAObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecNFAObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirMarshallAddNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 6;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecNFAObject->pszIpsecName ||
        !*pIpsecNFAObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecNFAObject->pszDescription ||
        !*pIpsecNFAObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecNFA",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecNFAObject->pszIpsecName &&
        *pIpsecNFAObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNFAObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNFAObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecNFAObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecNFAObject->pIpsecData,
                    pIpsecNFAObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecNFAObject->pszDescription &&
        *pIpsecNFAObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNFAObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirSetNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    LPWSTR pszOldIpsecFilterReference = NULL;
    LPWSTR pszOldIpsecNegPolReference = NULL;


    dwError = DirMarshallNFAObject(
                    pIpsecNFAData,
                    pszIpsecRootContainer,
                    &pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirGetNFAExistingFilterRef(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecNFAData,
                  &pszOldIpsecFilterReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirGetNFAExistingNegPolRef(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecNFAData,
                  &pszOldIpsecNegPolReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetNFAObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszOldIpsecFilterReference) {
        dwError = DirDeleteNFAReferenceInFilterObject(
                      hLdapBindHandle,
                      pszOldIpsecFilterReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirAddNFAReferenceToFilterObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszIpsecFilterReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Update the NFA object reference for the filter.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirUpdateFilterReferenceInNFAObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszDistinguishedName,
                      pszOldIpsecFilterReference,
                      pIpsecNFAObject->pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = DirRemoveFilterReferenceInNFAObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pszOldIpsecNegPolReference) {
        dwError = DirDeleteNFAReferenceInNegPolObject(
                      hLdapBindHandle,
                      pszOldIpsecNegPolReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = DirAddNFAReferenceToNegPolObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszIpsecNegPolReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Update the NFA object reference for the negpol.
    //

    dwError = DirUpdateNegPolReferenceInNFAObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszDistinguishedName,
                  pszOldIpsecNegPolReference,
                  pIpsecNFAObject->pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirBackPropIncChangesForNFAToPolicy(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszOldIpsecFilterReference) {
        FreePolStr(pszOldIpsecFilterReference);
    }

    if (pszOldIpsecNegPolReference) {
        FreePolStr(pszOldIpsecNegPolReference);
    }

    return(dwError);
}


DWORD
DirSetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetNFAObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecNFAObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecNFAObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }


    return(dwError);
}


DWORD
DirMarshallSetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 5;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecNFAObject->pszIpsecName ||
        !*pIpsecNFAObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecNFAObject->pszDescription ||
        !*pIpsecNFAObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecNFAObject->pszIpsecName &&
        *pIpsecNFAObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNFAObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNFAObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecNFAObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecNFAObject->pIpsecData,
                    pIpsecNFAObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecNFAObject->pszDescription &&
        *pIpsecNFAObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNFAObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirDeleteNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = DirMarshallNFAObject(
                  pIpsecNFAData,
                  pszIpsecRootContainer,
                  &pIpsecNFAObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ConvertGuidToDirPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Remove the NFA reference from the policy object.
    //

    dwError = DirRemoveNFAReferenceFromPolicyObject(
                  hLdapBindHandle,
                  pszIpsecPolicyReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Remove the NFA Reference from the negpol object.
    //

    dwError = DirDeleteNFAReferenceInNegPolObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszIpsecNegPolReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    //
    // Remove the NFA Reference from the filter object.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirDeleteNFAReferenceInFilterObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszIpsecFilterReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    return(dwError);
}


DWORD
DirGetNFAExistingFilterRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszIpsecFilterName
    )
{
    DWORD dwError = 0;
    LPWSTR pszNFAString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    LPWSTR pszIpsecFilterName = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    dwError = GenerateSpecificNFAQuery(
                  pIpsecNFAData->NFAIdentifier,
                  &pszNFAString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNFAString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError =UnMarshallNFAObject(
                 hLdapBindHandle,
                 e,
                 &pIpsecNFAObject,
                 &pszFilterReference,
                 &pszNegPolReference
                 );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszFilterReference) {
        FreePolStr(pszFilterReference);
    }

    if (pszNegPolReference) {
        FreePolStr(pszNegPolReference);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        pszIpsecFilterName = AllocPolStr(
                                 pIpsecNFAObject->pszIpsecFilterReference
                                 );
        if (!pszIpsecFilterName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    *ppszIpsecFilterName = pszIpsecFilterName;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNFAString) {
        FreePolMem(pszNFAString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    return(dwError);

error:

    *ppszIpsecFilterName = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificNFAQuery(
    GUID NFAIdentifier,
    LPWSTR * ppszNFAString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszNFAString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &NFAIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecNFA");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecNFA)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszNFAString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszNFAString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszNFAString, L"(&(objectclass=ipsecNFA)");
    wcscat(pszNFAString, L"(");
    wcscat(pszNFAString, szCommonName);
    wcscat(pszNFAString, L"))");

    *ppszNFAString = pszNFAString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszNFAString) {
        FreePolMem(pszNFAString);
    }

    *ppszNFAString = NULL;

    goto cleanup;
}


DWORD
DirGetNFAExistingNegPolRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszIpsecNegPolName
    )
{
    DWORD dwError = 0;
    LPWSTR pszNFAString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    LPWSTR pszIpsecNegPolName = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    dwError = GenerateSpecificNFAQuery(
                  pIpsecNFAData->NFAIdentifier,
                  &pszNFAString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNFAString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError =UnMarshallNFAObject(
                 hLdapBindHandle,
                 e,
                 &pIpsecNFAObject,
                 &pszFilterReference,
                 &pszNegPolReference
                 );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszFilterReference) {
        FreePolStr(pszFilterReference);
    }

    if (pszNegPolReference) {
        FreePolStr(pszNegPolReference);
    }

    pszIpsecNegPolName = AllocPolStr(
                             pIpsecNFAObject->pszIpsecNegPolReference
                             );
    if (!pszIpsecNegPolName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecNegPolName = pszIpsecNegPolName;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNFAString) {
        FreePolMem(pszNFAString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    return(dwError);

error:

    *ppszIpsecNegPolName = NULL;

    goto cleanup;
}


DWORD
DirGetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NFAGUID,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszNFAString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    dwError = GenerateSpecificNFAQuery(
                  NFAGUID,
                  &pszNFAString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNFAString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallNFAObject(
                  hLdapBindHandle,
                  e,
                  &pIpsecNFAObject,
                  &pszFilterReference,
                  &pszNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszFilterReference) {
        FreePolStr(pszFilterReference);
    }

    if (pszNegPolReference) {
        FreePolStr(pszNegPolReference);
    }

    *ppIpsecNFAObject = pIpsecNFAObject;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNFAString) {
        FreePolMem(pszNFAString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(
            pIpsecNFAObject
            );
    }

    *ppIpsecNFAObject = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\rules-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       rules-r.c
//
//  Contents:   Rule management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR NFADNAttributes[];


#define AUTH_VERSION_ONE    1
#define AUTH_VERSION_TWO    2


DWORD
RegCreateNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    WCHAR szAbsNFAReference[MAX_PATH];
    LPWSTR pszAbsPolicyReference = NULL;
    LPWSTR pszRelPolicyReference = NULL;
    LPWSTR pszRelFilterReference = NULL;
    LPWSTR pszRelNegPolReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszIpsecPolicyRef = NULL;
    BOOL bIsActive = FALSE;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegMarshallNFAObject(
                    pIpsecNFAData,
                    pszIpsecRootContainer,
                    &pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the NFA object in the store.
    //

    dwError = RegCreateNFAObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ConvertGuidToPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pszRelPolicyReference = pszAbsPolicyReference
                            + dwRootPathLen + 1;

    szAbsNFAReference[0] = L'\0';
    wcscpy(szAbsNFAReference, pszIpsecRootContainer);
    wcscat(szAbsNFAReference, L"\\");
    wcscat(szAbsNFAReference, pIpsecNFAObject->pszDistinguishedName);

    //
    // Write the policy object reference.
    //

    dwError = RegAddNFAReferenceToPolicyObject(
                  hRegistryKey,
                  pszRelPolicyReference,
                  szAbsNFAReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Write the NFA object reference.
    //

    dwError = RegAddPolicyReferenceToNFAObject(
                  hRegistryKey,
                  pIpsecNFAObject->pszDistinguishedName,
                  pszAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the filter object reference for the NFA
    // only if the NFA is not a default rule.
    //


    if (pIpsecNFAObject->pszIpsecFilterReference) {
        pszRelFilterReference = pIpsecNFAObject->pszIpsecFilterReference
                                + dwRootPathLen + 1;
        dwError = RegAddNFAReferenceToFilterObject(
                      hRegistryKey,
                      pszRelFilterReference,
                      szAbsNFAReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the NFA object reference for the filter
    // only if the NFA is not a default rule.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = RegAddFilterReferenceToNFAObject(
                      hRegistryKey,
                      pIpsecNFAObject->pszDistinguishedName,
                      pIpsecNFAObject->pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the negpol object reference for the NFA.
    //
    pszRelNegPolReference = pIpsecNFAObject->pszIpsecNegPolReference
                            + dwRootPathLen + 1;
    dwError = RegAddNFAReferenceToNegPolObject(
                  hRegistryKey,
                  pszRelNegPolReference,
                  szAbsNFAReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the NFA object reference for the negpol.
    //

    dwError = RegAddNegPolReferenceToNFAObject(
                  hRegistryKey,
                  pIpsecNFAObject->pszDistinguishedName,
                  pIpsecNFAObject->pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IsRegPolicyCurrentlyActive(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyIdentifier,
                  &bIsActive
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bIsActive) {
        dwError = PingPolicyAgentSvc(pszLocationName);
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszAbsPolicyReference) {
        FreePolStr(pszAbsPolicyReference);
    }

    return(dwError);
}


DWORD
RegSetNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    WCHAR szAbsNFAReference[MAX_PATH];
    LPWSTR pszAbsOldFilterRef = NULL;
    LPWSTR pszAbsOldNegPolRef = NULL;
    LPWSTR pszRelOldFilterRef = NULL;
    LPWSTR pszRelOldNegPolRef = NULL;
    LPWSTR pszRelFilterReference = NULL;
    LPWSTR pszRelNegPolReference = NULL;
    DWORD dwRootPathLen = 0;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegGetNFAExistingFilterRef(
                   hRegistryKey,
                   pIpsecNFAData,
                   &pszAbsOldFilterRef
                   );
    //
    // Filter Reference can be null for a default rule.                    
    // BAIL_ON_WIN32_ERROR(dwError);
    //

    if (pszAbsOldFilterRef && *pszAbsOldFilterRef) {
        pszRelOldFilterRef = pszAbsOldFilterRef + dwRootPathLen + 1;
    }

    dwError = RegGetNFAExistingNegPolRef(
                   hRegistryKey,
                   pIpsecNFAData,
                   &pszAbsOldNegPolRef
                   );                    
    // BAIL_ON_WIN32_ERROR(dwError);
    if (pszAbsOldNegPolRef && *pszAbsOldNegPolRef) {
        pszRelOldNegPolRef = pszAbsOldNegPolRef + dwRootPathLen + 1;
    }

    //
    // Marshall to update the NFA object in the store
    //

    dwError = RegMarshallNFAObject(
                    pIpsecNFAData,
                    pszIpsecRootContainer,
                    &pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Update the NFA object
    //

    dwError = RegSetNFAObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsNFAReference[0] = L'\0';
    wcscpy(szAbsNFAReference, pszIpsecRootContainer);
    wcscat(szAbsNFAReference, L"\\");
    wcscat(szAbsNFAReference, pIpsecNFAObject->pszDistinguishedName);

    if (pszRelOldFilterRef && *pszRelOldFilterRef) {
        dwError = RegDeleteNFAReferenceInFilterObject(
                      hRegistryKey,
                      pszRelOldFilterRef,
                      szAbsNFAReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the new filter object reference for the NFA.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        pszRelFilterReference = pIpsecNFAObject->pszIpsecFilterReference
                                + dwRootPathLen + 1;
        dwError = RegAddNFAReferenceToFilterObject(
                      hRegistryKey,
                      pszRelFilterReference,
                      szAbsNFAReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }  

    //
    // Update the NFA object reference for the filter.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = RegUpdateFilterReferenceInNFAObject(
                      hRegistryKey,
                      pIpsecNFAObject->pszDistinguishedName,
                      pszAbsOldFilterRef,
                      pIpsecNFAObject->pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDelFilterRefValueOfNFAObject(
                      hRegistryKey,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the new negpol object reference for the NFA.
    //

    pszRelNegPolReference = pIpsecNFAObject->pszIpsecNegPolReference
                            + dwRootPathLen + 1;

    if (pszRelOldNegPolRef && *pszRelOldNegPolRef) {
        dwError = RegDeleteNFAReferenceInNegPolObject(
                      hRegistryKey,
                      pszRelOldNegPolRef,
                      szAbsNFAReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegAddNFAReferenceToNegPolObject(
                  hRegistryKey,
                  pszRelNegPolReference,
                  szAbsNFAReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Update the NFA object reference for the negpol.
    //

    dwError = RegUpdateNegPolReferenceInNFAObject(
                  hRegistryKey,
                  pIpsecNFAObject->pszDistinguishedName,
                  pszAbsOldNegPolRef,
                  pIpsecNFAObject->pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegBackPropIncChangesForNFAToPolicy(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszAbsOldFilterRef) {
        FreePolStr(pszAbsOldFilterRef);
    }

    if (pszAbsOldNegPolRef) {
        FreePolStr(pszAbsOldNegPolRef);
    }

    return(dwError);
}


DWORD
RegDeleteNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    LPWSTR pszAbsPolicyReference = NULL;
    LPWSTR pszRelPolicyReference = NULL;
    WCHAR szAbsNFAReference[MAX_PATH];
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelNegPolReference = NULL;
    LPWSTR pszRelFilterReference = NULL;
    BOOL bIsActive = FALSE;


    dwRootPathLen = wcslen(pszIpsecRootContainer);

    dwError = ConvertGuidToPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pszRelPolicyReference = pszAbsPolicyReference
                            + dwRootPathLen + 1;

    dwError = RegMarshallNFAObject(
                    pIpsecNFAData,
                    pszIpsecRootContainer,
                    &pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsNFAReference[0] = L'\0';
    wcscpy(szAbsNFAReference, pszIpsecRootContainer);
    wcscat(szAbsNFAReference, L"\\");
    wcscat(szAbsNFAReference, pIpsecNFAObject->pszDistinguishedName);

    //
    // Remove the NFA reference from the policy object.
    //

    dwError = RegRemoveNFAReferenceFromPolicyObject(
                  hRegistryKey,
                  pszRelPolicyReference,
                  szAbsNFAReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pszRelNegPolReference = pIpsecNFAObject->pszIpsecNegPolReference
                            + dwRootPathLen + 1;
    dwError = RegDeleteNFAReferenceInNegPolObject(
                  hRegistryKey,
                  pszRelNegPolReference,
                  szAbsNFAReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        pszRelFilterReference = pIpsecNFAObject->pszIpsecFilterReference
                                + dwRootPathLen + 1;
        dwError = RegDeleteNFAReferenceInFilterObject(
                      hRegistryKey,
                      pszRelFilterReference,
                      szAbsNFAReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IsRegPolicyCurrentlyActive(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyIdentifier,
                  &bIsActive
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bIsActive) {
        dwError = PingPolicyAgentSvc(pszLocationName);
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszAbsPolicyReference) {
        FreePolStr(pszAbsPolicyReference);
    }

    return(dwError);
}


DWORD
RegEnumNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject = NULL;
    DWORD dwNumNFAObjects = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    LPWSTR pszAbsPolicyReference = NULL;
    LPWSTR pszRelPolicyReference = NULL;
    DWORD dwRootPathLen = 0;
    DWORD j = 0;


    dwRootPathLen = wcslen(pszIpsecRootContainer);

    dwError = ConvertGuidToPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pszRelPolicyReference = pszAbsPolicyReference
                            + dwRootPathLen + 1;

    dwError = RegEnumNFAObjects(
                        hRegistryKey,
                        pszIpsecRootContainer,
                        pszRelPolicyReference,
                        &ppIpsecNFAObject,
                        &dwNumNFAObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumNFAObjects) {
        ppIpsecNFAData = (PIPSEC_NFA_DATA *)AllocPolMem(
                                sizeof(PIPSEC_NFA_DATA)*dwNumNFAObjects
                                );
        if (!ppIpsecNFAData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAObject = *(ppIpsecNFAObject + i);

        dwError = RegUnmarshallNFAData(
                        pIpsecNFAObject,
                        &pIpsecNFAData
                        );
        if (!dwError) {
            *(ppIpsecNFAData + j) = pIpsecNFAData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecNFAData) {
            FreePolMem(ppIpsecNFAData);
            ppIpsecNFAData = NULL;
        }
    }

    *pppIpsecNFAData = ppIpsecNFAData;
    *pdwNumNFAObjects  = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecNFAObject) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObject,
            dwNumNFAObjects
            );
    }

    if (pszAbsPolicyReference) {
        FreePolStr(pszAbsPolicyReference);
    }

    return(dwError);

error:

    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            i
            );
    }

    *pppIpsecNFAData  = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
RegEnumNFAObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecRelPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    )
{
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    DWORD dwNumNFAObjects = 0;
    DWORD dwError = 0;
    DWORD dwSize = 0;
    HKEY hRegKey = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR pszTemp = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    *pppIpsecNFAObjects = NULL;
    *pdwNumNFAObjects = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecRelPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pszTemp = pszIpsecNFAReference;
    while (*pszTemp != L'\0') {

        pszTemp += wcslen(pszTemp) + 1;
        dwCount++;
    }

    if (!dwCount) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pszIpsecNFAReference;
    for (i = 0; i < dwCount; i++) {

        pszString = AllocPolStr(pszTemp);
        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszString;

        pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

    }

    ppIpsecNFAObjects = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                    sizeof(PIPSEC_NFA_OBJECT)*dwCount
                                    );
    if (!ppIpsecNFAObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        dwError = UnMarshallRegistryNFAObject(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      *(ppszIpsecNFANames + i),
                      &pIpsecNFAObject,
                      &pszFilterReference,
                      &pszNegPolReference
                      );

        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNFAObjects + dwNumNFAObjects) = pIpsecNFAObject;

            dwNumNFAObjects++;

            if (pszFilterReference) {
                FreePolStr(pszFilterReference);
            }

            if (pszNegPolReference) {
                FreePolStr(pszNegPolReference);
            }

        }

    }

    *pppIpsecNFAObjects = ppIpsecNFAObjects;
    *pdwNumNFAObjects = dwNumNFAObjects;

    dwError = ERROR_SUCCESS;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    if (ppszIpsecNFANames) {
        FreeNFAReferences(
            ppszIpsecNFANames,
            dwCount
            );
    }

    return(dwError);

error:

    if (ppIpsecNFAObjects) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObjects,
            dwNumNFAObjects
            );
    }

    *pppIpsecNFAObjects = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
RegCreateNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    DWORD dwError = 0;

    dwError = PersistNFAObject(
                    hRegistryKey,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegSetNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    DWORD dwError = 0;

    dwError = PersistNFAObject(
                    hRegistryKey,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNFAObject(
                    pIpsecNFAObject,
                    IPSEC_REGISTRY_PROVIDER,
                    ppIpsecNFAData
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegMarshallNFAObject(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszIpsecFilterReference = NULL;
    LPWSTR pszIpsecNegPolReference = NULL;
    GUID ZeroGuid;
    time_t PresentTime;

    memset(&ZeroGuid, 0, sizeof(GUID));

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_NFA_OBJECT)
                                                    );
    if (!pIpsecNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNFAData->NFAIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecNFA");
    wcscat(szDistinguishedName, szGuid);
    pIpsecNFAObject->pszDistinguishedName = AllocPolStr(
                                                szDistinguishedName
                                                );
    if (!pIpsecNFAObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecNFAData->pszIpsecName &&
        *pIpsecNFAData->pszIpsecName) {

        pIpsecNFAObject->pszIpsecName = AllocPolStr(
                                            pIpsecNFAData->pszIpsecName
                                            );
        if (!pIpsecNFAObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAData->pszDescription &&
        *pIpsecNFAData->pszDescription) {

        pIpsecNFAObject->pszDescription = AllocPolStr(
                                            pIpsecNFAData->pszDescription
                                            );
        if (!pIpsecNFAObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecNFAObject->pszIpsecID = AllocPolStr(
                                      szGuid
                                      );
    if (!pIpsecNFAObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecNFAObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallNFABuffer(
                    pIpsecNFAData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->pIpsecData  = pBuffer;

    pIpsecNFAObject->dwIpsecDataLen = dwBufferLen;

    //
    // Marshall the Filter Reference.
    // There's no filter reference for a default rule.
    //

    if (memcmp(
            &pIpsecNFAData->FilterIdentifier,
            &ZeroGuid,
            sizeof(GUID))) {
        dwError = ConvertGuidToFilterString(
                      pIpsecNFAData->FilterIdentifier,
                      pszIpsecRootContainer,
                      &pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecNFAObject->pszIpsecFilterReference = pszIpsecFilterReference;
    }
    else {
        pIpsecNFAObject->pszIpsecFilterReference = NULL;
    }

    //
    // Marshall the NegPol Reference
    //

    dwError = ConvertGuidToNegPolString(
                    pIpsecNFAData->NegPolIdentifier,
                    pszIpsecRootContainer,
                    &pszIpsecNegPolReference
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecNFAObject->pszIpsecNegPolReference = pszIpsecNegPolReference;

    time(&PresentTime);

    pIpsecNFAObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecNFAObject = pIpsecNFAObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(
                pIpsecNFAObject
                );
    }

    *ppIpsecNFAObject = NULL;
    goto cleanup;
}


DWORD
MarshallNFABuffer(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pBuffer = NULL;
    LPBYTE pCurrentPos = NULL;
    DWORD dwTotalSize = 0;
    DWORD dwError = 0;
    LPBYTE pAuthMem = NULL;
    DWORD dwAuthSize = 0;
    DWORD dwInterfaceType = 0;
    DWORD dwInterfaceNameLen = 0;
    LPWSTR pszInterfaceName = NULL;
    DWORD dwTunnelIpAddr = 0;
    DWORD dwTunnelFlags = 0;
    DWORD dwActiveFlag = 0;
    LPWSTR pszEndPointName = NULL;
    DWORD dwEndPointNameLen = 0;
    PIPSEC_AUTH_METHOD pIpsecAuthMethod = NULL;
    DWORD dwNumAuthMethods = 0;
    DWORD i = 0;
    PSPEC_BUFFER  pSpecBuffer = NULL;
    PSPEC_BUFFER  pSpecBufferV2 = NULL;
    // {11BBAC00-498D-11d1-8639-00A0248D3021}
    static const GUID GUID_IPSEC_NFA_BLOB =
    { 0x11bbac00, 0x498d, 0x11d1, { 0x86, 0x39, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };
    DWORD dwEffectiveSize = 0;
    DWORD dwTotalV2AuthSize=0;


    dwTotalSize += sizeof(GUID);

    dwTotalSize += sizeof(DWORD);

    dwTotalSize += sizeof(DWORD);

    dwNumAuthMethods = pIpsecNFAData->dwAuthMethodCount;

    if (!dwNumAuthMethods) {
         dwError = ERROR_INVALID_PARAMETER;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    pSpecBuffer = AllocPolMem(
                    sizeof(SPEC_BUFFER)*dwNumAuthMethods
                    );
    if (!pSpecBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pSpecBufferV2 = AllocPolMem(
                      sizeof(SPEC_BUFFER)*dwNumAuthMethods
                      );
    if (!pSpecBufferV2) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNumAuthMethods;i++){

        pIpsecAuthMethod = *(pIpsecNFAData->ppAuthMethods + i);
        dwError = MarshallAuthMethods(
                        pIpsecAuthMethod,
                        &pAuthMem,
                        &dwAuthSize,
                        AUTH_VERSION_ONE
                        );
        BAIL_ON_WIN32_ERROR(dwError);
        dwTotalSize += dwAuthSize;

        (pSpecBuffer + i)->dwSize = dwAuthSize;
        (pSpecBuffer + i)->pMem = pAuthMem;

    }

    dwInterfaceType = pIpsecNFAData->dwInterfaceType;
    dwTotalSize += sizeof(DWORD);

    pszInterfaceName = pIpsecNFAData->pszInterfaceName;
    if (pszInterfaceName) {
        dwInterfaceNameLen = (wcslen(pszInterfaceName) + 1)*sizeof(WCHAR);
    }
    else {
        dwInterfaceNameLen = sizeof(WCHAR);
    }

    dwTotalSize += sizeof(DWORD);
    dwTotalSize += dwInterfaceNameLen;

    dwTunnelIpAddr = pIpsecNFAData->dwTunnelIpAddr;
    dwTotalSize += sizeof(DWORD);

    dwTunnelFlags = pIpsecNFAData->dwTunnelFlags;
    dwTotalSize += sizeof(DWORD);

    dwActiveFlag = pIpsecNFAData->dwActiveFlag;
    dwTotalSize += sizeof(DWORD);

    pszEndPointName = pIpsecNFAData->pszEndPointName;
    if (pszEndPointName) {
        dwEndPointNameLen = (wcslen(pszEndPointName) + 1)*sizeof(WCHAR);
    }
    else {
        dwEndPointNameLen = sizeof(WCHAR);
    }

    dwTotalSize += sizeof(DWORD);
    dwTotalSize += dwEndPointNameLen;

    //
    // Marshall version 2 auth data.
    //

    dwTotalSize += sizeof(GUID);
    dwTotalV2AuthSize += sizeof(GUID);

    dwTotalSize += sizeof(DWORD);
    dwTotalV2AuthSize += sizeof(DWORD);

    for (i = 0; i < dwNumAuthMethods; i++) {

        pIpsecAuthMethod = *(pIpsecNFAData->ppAuthMethods + i);
        dwError = MarshallAuthMethods(
                        pIpsecAuthMethod,
                        &pAuthMem,
                        &dwAuthSize,
                        AUTH_VERSION_TWO
                        );
        BAIL_ON_WIN32_ERROR(dwError);
        dwTotalSize += dwAuthSize;
        dwTotalV2AuthSize += dwAuthSize;

        (pSpecBufferV2 + i)->dwSize = dwAuthSize;
        (pSpecBufferV2 + i)->pMem = pAuthMem;

    }

    dwTotalSize++;

    pBuffer = AllocPolMem(dwTotalSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pBuffer;

    memcpy(pCurrentPos, &GUID_IPSEC_NFA_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    dwEffectiveSize = dwTotalSize - sizeof(GUID) - sizeof(DWORD) - 1 -
                      dwTotalV2AuthSize;

    memcpy(pCurrentPos, (LPBYTE)&dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwNumAuthMethods, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    for (i = 0; i < dwNumAuthMethods; i++) {

        pAuthMem = (pSpecBuffer + i)->pMem;
        dwAuthSize = (pSpecBuffer + i)->dwSize;

        memcpy(pCurrentPos, pAuthMem, dwAuthSize);
        pCurrentPos += dwAuthSize;

    }

    memcpy(pCurrentPos, (LPBYTE)&dwInterfaceType, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwInterfaceNameLen, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pszInterfaceName) {
        memcpy(pCurrentPos, pszInterfaceName, dwInterfaceNameLen);
    }
    pCurrentPos += dwInterfaceNameLen;

    memcpy(pCurrentPos, (LPBYTE)&dwTunnelIpAddr, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwTunnelFlags, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwActiveFlag, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwEndPointNameLen, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pszEndPointName) {
        memcpy(pCurrentPos, pszEndPointName, dwEndPointNameLen);
    }
    pCurrentPos += dwEndPointNameLen;

    //
    // Copy version 2 auth data.
    //

    memset(pCurrentPos, 1, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    memcpy(pCurrentPos, (LPBYTE)&dwNumAuthMethods, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    for (i = 0; i < dwNumAuthMethods; i++) {

        pAuthMem = (pSpecBufferV2 + i)->pMem;
        dwAuthSize = (pSpecBufferV2 + i)->dwSize;

        memcpy(pCurrentPos, pAuthMem, dwAuthSize);
        pCurrentPos += dwAuthSize;

    }

    *ppBuffer = pBuffer;
    *pdwBufferLen = dwTotalSize;

cleanup:

    if (pSpecBuffer) {
        FreeSpecBuffer(
            pSpecBuffer,
            dwNumAuthMethods
            );
    }

    if (pSpecBufferV2) {
        FreeSpecBuffer(
            pSpecBufferV2,
            dwNumAuthMethods
            );
    }

    return (dwError);

error:

    *ppBuffer = NULL;
    *pdwBufferLen = 0;
    goto cleanup;
}


DWORD
MarshallAuthMethods(
    PIPSEC_AUTH_METHOD pIpsecAuthMethod,
    LPBYTE * ppMem,
    DWORD * pdwSize,
    DWORD dwVersion
    )
{
    DWORD dwSize = 0;
    LPBYTE pMem = NULL;
    LPBYTE pCurrentPos = NULL;
    DWORD dwError = 0;
    LPWSTR pszAuthMethod = NULL;
    DWORD dwAuthType = 0;
    DWORD dwAuthLen = 0;
    PBYTE pAltAuthMethod = NULL;


    dwAuthType = pIpsecAuthMethod->dwAuthType;

    //
    // Length in number of characters excluding the null character for
    // auth version 1.
    //

    if (dwVersion == AUTH_VERSION_ONE) {
        dwAuthLen =  pIpsecAuthMethod->dwAuthLen;
        dwAuthLen = (dwAuthLen + 1)*2;
        pszAuthMethod = pIpsecAuthMethod->pszAuthMethod;
    }
    else {
        dwAuthLen =  pIpsecAuthMethod->dwAltAuthLen;
        pAltAuthMethod = pIpsecAuthMethod->pAltAuthMethod;
    }

    dwSize += sizeof(DWORD);

    dwSize +=  sizeof(DWORD);

    dwSize += dwAuthLen;

    pMem = AllocPolMem(dwSize);
    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pMem;

    memcpy(pCurrentPos, &dwAuthType, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    memcpy(pCurrentPos, &dwAuthLen, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (dwVersion == AUTH_VERSION_ONE) {
        if (pszAuthMethod) {
            memcpy(pCurrentPos, pszAuthMethod, dwAuthLen);
        }
    }
    else {
        if (pAltAuthMethod) {
            memcpy(pCurrentPos, pAltAuthMethod, dwAuthLen);
        }
    }

    *ppMem = pMem;
    *pdwSize = dwSize;

    return(dwError);

error:

    *ppMem = NULL;
    *pdwSize = 0;

    return(dwError);
}


DWORD
ConvertGuidToNegPolString(
    GUID NegPolIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecNegPolReference
    )
{
    DWORD dwError = 0;
    WCHAR szNegPolReference[MAX_PATH];
    LPWSTR pszIpsecNegPolReference = NULL;
    WCHAR szGuidString[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szNegPolReference[0] = L'\0';
    wcscpy(szNegPolReference, pszIpsecRootContainer);
    wcscat(szNegPolReference, L"\\");
    wcscat(szNegPolReference, L"ipsecNegotiationPolicy");
    wcscat(szNegPolReference, szGuidString);

    pszIpsecNegPolReference = AllocPolStr(
                                    szNegPolReference
                                    );
    if (!pszIpsecNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecNegPolReference = pszIpsecNegPolReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecNegPolReference = NULL;

    goto cleanup;
}


DWORD
ConvertGuidToFilterString(
    GUID FilterIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecFilterReference
    )
{
    DWORD dwError = 0;
    WCHAR szFilterReference[MAX_PATH];
    LPWSTR pszIpsecFilterReference = NULL;
    WCHAR szGuidString[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szFilterReference[0] = L'\0';
    wcscpy(szFilterReference, pszIpsecRootContainer);
    wcscat(szFilterReference, L"\\");
    wcscat(szFilterReference, L"ipsecFilter");
    wcscat(szFilterReference, szGuidString);

    pszIpsecFilterReference = AllocPolStr(
                                    szFilterReference
                                    );
    if (!pszIpsecFilterReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecFilterReference = pszIpsecFilterReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecFilterReference = NULL;

    goto cleanup;
}


DWORD
RegGetNFAExistingFilterRef(
    HKEY hRegistryKey,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszFilterName
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szRelativeName[MAX_PATH];
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;


    szRelativeName[0] = L'\0';
    dwError = UuidToString(
                    &pIpsecNFAData->NFAIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szRelativeName, L"ipsecNFA");
    wcscat(szRelativeName, L"{");
    wcscat(szRelativeName, pszStringUuid);
    wcscat(szRelativeName, L"}");

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    szRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecFilterReference",
                    REG_SZ,
                    (LPBYTE *)ppszFilterName,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = 0;

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
RegGetNFAExistingNegPolRef(
    HKEY hRegistryKey,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszNegPolName
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szRelativeName[MAX_PATH];
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;


    szRelativeName[0] = L'\0';
    dwError = UuidToString(
                    &pIpsecNFAData->NFAIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szRelativeName, L"ipsecNFA");
    wcscat(szRelativeName, L"{");
    wcscat(szRelativeName, pszStringUuid);
    wcscat(szRelativeName, L"}");

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    szRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNegotiationPolicyReference",
                    REG_SZ,
                    (LPBYTE *)ppszNegPolName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
ConvertGuidToPolicyString(
    GUID PolicyIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecPolicyReference
    )
{
    DWORD dwError = 0;
    WCHAR szPolicyReference[MAX_PATH];
    LPWSTR pszIpsecPolicyReference = NULL;
    WCHAR szGuidString[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = UuidToString(
                  &PolicyIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szPolicyReference[0] = L'\0';
    wcscpy(szPolicyReference, pszIpsecRootContainer);
    wcscat(szPolicyReference, L"\\");
    wcscat(szPolicyReference, L"ipsecPolicy");
    wcscat(szPolicyReference, szGuidString);

    pszIpsecPolicyReference = AllocPolStr(
                                    szPolicyReference
                                    );
    if (!pszIpsecPolicyReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecPolicyReference = pszIpsecPolicyReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecPolicyReference = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\rules-r.h ===
DWORD
RegCreateNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
RegSetNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
RegDeleteNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
RegEnumNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    );

DWORD
RegEnumNFAObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    );

DWORD
RegCreateNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
RegSetNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
RegUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
RegMarshallNFAObject(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    );

DWORD
MarshallNFABuffer(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );

DWORD
MarshallAuthMethods(
    PIPSEC_AUTH_METHOD pIpsecAuthMethod,
    LPBYTE * ppMem,
    DWORD * pdwSize,
    DWORD dwVersion
    );

DWORD
ConvertGuidToNegPolString(
    GUID NegPolIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecNegPolReference
    );

DWORD
ConvertGuidToFilterString(
    GUID FilterIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecFilterReference
    );

DWORD
RegGetNFAExistingFilterRef(
    HKEY hRegistryKey,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszFilterName
    );

DWORD
RegGetNFAExistingNegPolRef(
    HKEY hRegistryKey,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszNegPolName
    );

DWORD
ConvertGuidToPolicyString(
    GUID PolicyIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecPolicyReference
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\update-d.h ===
DWORD
DirBackPropIncChangesForISAKMPToPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    );

DWORD
DirBackPropIncChangesForFilterToNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    );

DWORD
DirBackPropIncChangesForNegPolToNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    );

DWORD
DirBackPropIncChangesForNFAToPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName
    );

DWORD
DirGetPolicyReferencesForISAKMP(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
DirUpdatePolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyReference,
    DWORD dwDataType
    );

DWORD
DirGetPolicyReferencesForNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
DirGetNFAReferencesForFilter(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
DirUpdateNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecNFAReference,
    DWORD dwDataType
    );

DWORD
DirGetNFAReferencesForNegPol(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
CopyReferences(
    LPWSTR * ppszIpsecReferences,
    DWORD dwNumReferences,
    LPWSTR ** pppszNewIpsecReferences,
    PDWORD pdwNumNewReferences
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\update-d.c ===
#include "precomp.h"


DWORD
DirBackPropIncChangesForISAKMPToPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = DirGetPolicyReferencesForISAKMP(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  ISAKMPIdentifier,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = DirUpdatePolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      0x200
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = DirUpdatePolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      0x100
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwError = ERROR_SUCCESS;

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
DirBackPropIncChangesForFilterToNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;


    dwError = DirGetNFAReferencesForFilter(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  FilterIdentifier,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = DirUpdateNFA(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference,
                      0x200
                      );
        if (dwError) {
            continue;
        }

        dwError = DirUpdateNFA(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference,
                      0x100
                      );
        if (dwError) {
            continue;
        }

        dwError = DirBackPropIncChangesForNFAToPolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference
                      );
        if (dwError) {
            continue;
        }

    }

    dwError = ERROR_SUCCESS;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}

    
DWORD
DirBackPropIncChangesForNegPolToNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;


    dwError = DirGetNFAReferencesForNegPol(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NegPolIdentifier,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = DirUpdateNFA(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference,
                      0x200
                      );
        if (dwError) {
            continue;
        }

        dwError = DirUpdateNFA(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference,
                      0x100
                      );
        if (dwError) {
            continue;
        }

        dwError = DirBackPropIncChangesForNFAToPolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference
                      );
        if (dwError) {
            continue;
        }

    }

    dwError = ERROR_SUCCESS;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
DirBackPropIncChangesForNFAToPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = DirGetPolicyReferencesForNFA(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pszNFADistinguishedName,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = DirUpdatePolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      0x200
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = DirUpdatePolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      0x100
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwError = ERROR_SUCCESS;

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
DirGetPolicyReferencesForISAKMP(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;


    dwError = DirGetISAKMPObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  ISAKMPIdentifier,
                  &pIpsecISAKMPObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyReferences(
                  pIpsecISAKMPObject->ppszIpsecNFAReferences,
                  pIpsecISAKMPObject->dwNFACount,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecISAKMPObject);
    }

    return (dwError);

error:

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    goto cleanup;
}


DWORD
DirUpdatePolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyReference,
    DWORD dwDataType
    )
{
    DWORD dwError = 0;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    WCHAR Buffer[64];
    DWORD dwIpsecDataType = dwDataType;


    Buffer[0] = L'\0';

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                   (dwNumAttributes+1) * sizeof(LDAPModW*)
                                   );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                 dwNumAttributes * sizeof(LDAPModW)
                                 );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                  L"ipsecDataType",
                  &(pLDAPModW +i)->mod_type
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                  Buffer,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                  hLdapBindHandle,
                  pszIpsecPolicyReference,
                  ppLDAPModW
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirGetPolicyReferencesForNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecID = NULL;
    GUID NFAIdentifier;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;


    pszIpsecID = wcschr(pszNFADistinguishedName, L'{');

    if (!pszIpsecID) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wGUIDFromString(
        pszIpsecID,
        &NFAIdentifier
        );

    dwError = DirGetNFAObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NFAIdentifier,
                  &pIpsecNFAObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyReferences(
                  &(pIpsecNFAObject->pszIpsecOwnersReference),
                  1,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    return (dwError);

error:

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    goto cleanup;
}


DWORD
DirGetNFAReferencesForFilter(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    dwError = DirGetFilterObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  FilterIdentifier,
                  &pIpsecFilterObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyReferences(
                  pIpsecFilterObject->ppszIpsecNFAReferences,
                  pIpsecFilterObject->dwNFACount,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(pIpsecFilterObject);
    }

    return (dwError);

error:

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    goto cleanup;
}


DWORD
DirUpdateNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecNFAReference,
    DWORD dwDataType
    )
{
    DWORD dwError = 0;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    WCHAR Buffer[64];
    DWORD dwIpsecDataType = dwDataType;


    Buffer[0] = L'\0';

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                   (dwNumAttributes+1) * sizeof(LDAPModW*)
                                   );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                 dwNumAttributes * sizeof(LDAPModW)
                                 );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                  L"ipsecDataType",
                  &(pLDAPModW +i)->mod_type
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                  Buffer,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                  hLdapBindHandle,
                  pszIpsecNFAReference,
                  ppLDAPModW
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirGetNFAReferencesForNegPol(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    dwError = DirGetNegPolObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NegPolIdentifier,
                  &pIpsecNegPolObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyReferences(
                  pIpsecNegPolObject->ppszIpsecNFAReferences,
                  pIpsecNegPolObject->dwNFACount,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(pIpsecNegPolObject);
    }

    return (dwError);

error:

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    goto cleanup;
}


DWORD
CopyReferences(
    LPWSTR * ppszIpsecReferences,
    DWORD dwNumReferences,
    LPWSTR ** pppszNewIpsecReferences,
    PDWORD pdwNumNewReferences
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszNewIpsecReferences = NULL;
    DWORD i = 0;
    LPWSTR pszTemp = NULL;
    LPWSTR pszString = NULL;


    if (!dwNumReferences || !ppszIpsecReferences) {
        *pppszNewIpsecReferences = NULL;
        *pdwNumNewReferences = 0;
        return (dwError);
    }

    ppszNewIpsecReferences = (LPWSTR *) AllocPolMem(
                             sizeof(LPWSTR) * dwNumReferences
                             );
    if (!ppszNewIpsecReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNumReferences; i++) {

        pszTemp = *(ppszIpsecReferences + i);

        pszString = AllocPolStr(pszTemp);

        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszNewIpsecReferences + i) = pszString;

    }

    *pppszNewIpsecReferences = ppszNewIpsecReferences;
    *pdwNumNewReferences = dwNumReferences;

    return (dwError);

error:

    if (ppszNewIpsecReferences) {
        FreeNFAReferences(
            ppszNewIpsecReferences,
            i
            );
    }

    *pppszNewIpsecReferences = NULL;
    *pdwNumNewReferences = 0;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\update-r.c ===
#include "precomp.h"


DWORD
RegBackPropIncChangesForISAKMPToPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;
    GUID PolicyIdentifier;
    BOOL bIsActive = FALSE;


    dwError = RegGetPolicyReferencesForISAKMP(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecISAKMPObject->pszDistinguishedName,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = RegUpdatePolicy(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = RegGetGuidFromPolicyReference(
                      pszIpsecPolicyReference,
                      &PolicyIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = IsRegPolicyCurrentlyActive(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      PolicyIdentifier,
                      &bIsActive
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        if (bIsActive) {
            dwError = PingPolicyAgentSvc(pszLocationName);
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    dwError = ERROR_SUCCESS;

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
RegBackPropIncChangesForFilterToNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    DWORD dwError = 0;
    DWORD dwRootPathLen = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszRelativeName = NULL;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegGetNFAReferencesForFilter(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecFilterObject->pszDistinguishedName,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegUpdateNFA(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference
                      );
        if (dwError) {
            continue;
        }

    }

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        pszRelativeName = pszIpsecNFAReference + dwRootPathLen + 1;

        dwError = RegBackPropIncChangesForNFAToPolicy(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszLocationName,
                      pszRelativeName
                      );
        if (dwError) {
            continue;
        }

    }

    dwError = ERROR_SUCCESS;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}

    
DWORD
RegBackPropIncChangesForNegPolToNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    DWORD dwRootPathLen = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszRelativeName = NULL;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegGetNFAReferencesForNegPol(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecNegPolObject->pszDistinguishedName,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegUpdateNFA(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference
                      );
        if (dwError) {
            continue;
        }

    }

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        pszRelativeName = pszIpsecNFAReference + dwRootPathLen + 1;

        dwError = RegBackPropIncChangesForNFAToPolicy(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszLocationName,
                      pszRelativeName
                      );
        if (dwError) {
            continue;
        }

    }

    dwError = ERROR_SUCCESS;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
RegBackPropIncChangesForNFAToPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    LPWSTR pszNFADistinguishedName
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;
    GUID PolicyIdentifier;
    BOOL bIsActive = FALSE;


    dwError = RegGetPolicyReferencesForNFA(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszNFADistinguishedName,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = RegUpdatePolicy(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = RegGetGuidFromPolicyReference(
                      pszIpsecPolicyReference,
                      &PolicyIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = IsRegPolicyCurrentlyActive(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      PolicyIdentifier,
                      &bIsActive
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        if (bIsActive) {
            dwError = PingPolicyAgentSvc(pszLocationName);
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    dwError = ERROR_SUCCESS;

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
RegGetPolicyReferencesForISAKMP(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszISAKMPDistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD i = 0;
    LPWSTR pszString = NULL;


    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszISAKMPDistinguishedName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ipsecOwnersReference",
                  REG_MULTI_SZ,
                  (LPBYTE *)&pszIpsecPolicyReference,
                  &dwSize
                  );

    if (!dwError) {

        pszTemp = pszIpsecPolicyReference;

        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }

        ppszIpsecPolicyReferences = (LPWSTR *) AllocPolMem(
                                   sizeof(LPWSTR)*dwCount
                                   );
        if (!ppszIpsecPolicyReferences) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecPolicyReference;

        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecPolicyReferences + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1;

        }

    }

    dwError = ERROR_SUCCESS;

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwCount;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    return (dwError);

error:

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            i
            );
    }

    goto cleanup;
}


DWORD
RegUpdatePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyReference
    )
{
    DWORD dwError = 0;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    time_t PresentTime;
    DWORD dwWhenChanged = 0;


    dwRootPathLen = wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecPolicyReference + dwRootPathLen + 1;

    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszRelativeName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"whenChanged",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwWhenChanged,
                  &dwSize
                  );
    if (dwError) {
        time(&PresentTime);
        dwWhenChanged = (DWORD) PresentTime;
    }
    else {
        dwWhenChanged++;
    }

    dwError = RegSetValueExW(
                  hRegKey,
                  L"whenChanged",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwWhenChanged,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
RegGetGuidFromPolicyReference(
    LPWSTR pszIpsecPolicyReference,
    GUID * pPolicyIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR pszGuid = NULL;


    memset(pPolicyIdentifier, 0, sizeof(GUID));

    if (pszIpsecPolicyReference) {

        pszGuid = wcschr(pszIpsecPolicyReference, L'{');
        if (!pszGuid) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        wGUIDFromString(pszGuid, pPolicyIdentifier);

    }

error:

    return(dwError);
}


DWORD
RegGetPolicyReferencesForNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD i = 0;
    LPWSTR pszString = NULL;


    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszNFADistinguishedName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ipsecOwnersReference",
                  REG_MULTI_SZ,
                  (LPBYTE *)&pszIpsecPolicyReference,
                  &dwSize
                  );

    if (!dwError) {

        pszTemp = pszIpsecPolicyReference;

        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }

        ppszIpsecPolicyReferences = (LPWSTR *) AllocPolMem(
                                   sizeof(LPWSTR)*dwCount
                                   );
        if (!ppszIpsecPolicyReferences) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecPolicyReference;

        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecPolicyReferences + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1;

        }

    }

    dwError = ERROR_SUCCESS;

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwCount;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    return (dwError);

error:

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            i
            );
    }

    goto cleanup;
}


DWORD
RegGetNFAReferencesForFilter(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszFilterDistinguishedName,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD i = 0;
    LPWSTR pszString = NULL;


    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszFilterDistinguishedName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ipsecOwnersReference",
                  REG_MULTI_SZ,
                  (LPBYTE *)&pszIpsecNFAReference,
                  &dwSize
                  );

    if (!dwError) {

        pszTemp = pszIpsecNFAReference;

        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }

        ppszIpsecNFAReferences = (LPWSTR *) AllocPolMem(
                                   sizeof(LPWSTR)*dwCount
                                   );
        if (!ppszIpsecNFAReferences) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;

        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFAReferences + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1;

        }

    }

    dwError = ERROR_SUCCESS;

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwCount;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    return (dwError);

error:

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            i
            );
    }

    goto cleanup;
}


DWORD
RegUpdateNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecNFAReference
    )
{
    DWORD dwError = 0;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    time_t PresentTime;
    DWORD dwWhenChanged = 0;


    dwRootPathLen = wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecNFAReference + dwRootPathLen + 1;

    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszRelativeName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"whenChanged",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwWhenChanged,
                  &dwSize
                  );
    if (dwError) {
        time(&PresentTime);
        dwWhenChanged = (DWORD) PresentTime;
    }
    else {
        dwWhenChanged++;
    }

    dwError = RegSetValueExW(
                  hRegKey,
                  L"whenChanged",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwWhenChanged,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
RegGetNFAReferencesForNegPol(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNegPolDistinguishedName,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD i = 0;
    LPWSTR pszString = NULL;


    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszNegPolDistinguishedName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ipsecOwnersReference",
                  REG_MULTI_SZ,
                  (LPBYTE *)&pszIpsecNFAReference,
                  &dwSize
                  );

    if (!dwError) {

        pszTemp = pszIpsecNFAReference;

        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }

        ppszIpsecNFAReferences = (LPWSTR *) AllocPolMem(
                                   sizeof(LPWSTR)*dwCount
                                   );
        if (!ppszIpsecNFAReferences) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;

        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFAReferences + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1;

        }

    }

    dwError = ERROR_SUCCESS;

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwCount;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    return (dwError);

error:

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            i
            );
    }

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\client.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    client.c

Abstract:

    Holds general client code.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
TranslateExceptionCode(
    DWORD dwExceptionCode
    )
{
    return (dwExceptionCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\client.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    client.h

Abstract:

    Holds client.c header information.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
TranslateExceptionCode(
    DWORD dwExceptionCode
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\update-r.h ===
DWORD
RegBackPropIncChangesForISAKMPToPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );

DWORD
RegBackPropIncChangesForFilterToNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );
    
DWORD
RegBackPropIncChangesForNegPolToNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
RegBackPropIncChangesForNFAToPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    LPWSTR pszNFADistinguishedName
    );

DWORD
RegGetPolicyReferencesForISAKMP(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszISAKMPDistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegUpdatePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyReference
    );

DWORD
RegGetGuidFromPolicyReference(
    LPWSTR pszIpsecPolicyReference,
    GUID * pPolicyIdentifier
    );

DWORD
RegGetPolicyReferencesForNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegGetNFAReferencesForFilter(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszFilterDistinguishedName,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegUpdateNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecNFAReference
    );

DWORD
RegGetNFAReferencesForNegPol(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNegPolDistinguishedName,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\validate.c ===
#include "precomp.h"

extern LPWSTR PolicyDNAttributes[];

DWORD
ValidateISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;


    if (!pIpsecISAKMPData) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pIpsecISAKMPData->pSecurityMethods) ||
        !(pIpsecISAKMPData->dwNumISAKMPSecurityMethods)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}


DWORD
ValidateNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;


    if (!pIpsecNegPolData) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!IsClearOnly(pIpsecNegPolData->NegPolAction) &&
        !IsBlocking(pIpsecNegPolData->NegPolAction)) {

        if (!(pIpsecNegPolData->pIpsecSecurityMethods) ||
            !(pIpsecNegPolData->dwSecurityMethodCount)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

error:

    return (dwError);
}


BOOL
IsClearOnly(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_NO_IPSEC),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}


BOOL
IsBlocking(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_BLOCK),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}


DWORD
ValidateISAKMPDataDeletion(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    LPWSTR pszIpsecISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = ConvertGuidToISAKMPString(
                      ISAKMPIdentifier,
                      pPolicyStore->pszIpsecRootContainer,
                      &pszIpsecISAKMPReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwRootPathLen =  wcslen(pPolicyStore->pszIpsecRootContainer);
        pszRelativeName = pszIpsecISAKMPReference + dwRootPathLen + 1;

        dwError = RegGetPolicyReferencesForISAKMP(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pszRelativeName,
                      &ppszIpsecPolicyReferences,
                      &dwNumReferences
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirGetPolicyReferencesForISAKMP(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      ISAKMPIdentifier,
                      &ppszIpsecPolicyReferences,
                      &dwNumReferences
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
        break;

    }

    if (!dwNumReferences) {
        dwError = ERROR_SUCCESS;
    }
    else {
        dwError = ERROR_INVALID_DATA;
    }

error:

    if (pszIpsecISAKMPReference) {
        FreePolStr(pszIpsecISAKMPReference);
    }

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
ValidateNegPolDataDeletion(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    LPWSTR pszIpsecNegPolReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = ConvertGuidToNegPolString(
                      NegPolIdentifier,
                      pPolicyStore->pszIpsecRootContainer,
                      &pszIpsecNegPolReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwRootPathLen =  wcslen(pPolicyStore->pszIpsecRootContainer);
        pszRelativeName = pszIpsecNegPolReference + dwRootPathLen + 1;

        dwError = RegGetNFAReferencesForNegPol(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pszRelativeName,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirGetNFAReferencesForNegPol(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      NegPolIdentifier,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
        break;

    }

    if (!dwNumReferences) {
        dwError = ERROR_SUCCESS;
    }
    else {
        dwError = ERROR_INVALID_DATA;
    }

error:

    if (pszIpsecNegPolReference) {
        FreePolStr(pszIpsecNegPolReference);
    }

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
ValidateFilterDataDeletion(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    LPWSTR pszIpsecFilterReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = ConvertGuidToFilterString(
                      FilterIdentifier,
                      pPolicyStore->pszIpsecRootContainer,
                      &pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwRootPathLen =  wcslen(pPolicyStore->pszIpsecRootContainer);
        pszRelativeName = pszIpsecFilterReference + dwRootPathLen + 1;

        dwError = RegGetNFAReferencesForFilter(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pszRelativeName,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirGetNFAReferencesForFilter(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      FilterIdentifier,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
        break;

    }

    if (!dwNumReferences) {
        dwError = ERROR_SUCCESS;
    }
    else {
        dwError = ERROR_INVALID_DATA;
    }

error:

    if (pszIpsecFilterReference) {
        FreePolStr(pszIpsecFilterReference);
    }

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
ValidatePolicyDataDeletion(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = ConvertGuidToPolicyString(
                      pIpsecPolicyData->PolicyIdentifier,
                      pPolicyStore->pszIpsecRootContainer,
                      &pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwRootPathLen =  wcslen(pPolicyStore->pszIpsecRootContainer);
        pszRelativeName = pszIpsecPolicyReference + dwRootPathLen + 1;

        dwError = RegGetNFAReferencesForPolicy(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pszRelativeName,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = GenerateSpecificPolicyQuery(
                      pIpsecPolicyData->PolicyIdentifier,
                      &pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = DirGetNFADNsForPolicy(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
        break;

    }

    if (!dwNumReferences) {
        dwError = ERROR_SUCCESS;
    }
    else {
        dwError = ERROR_INVALID_DATA;
    }

error:

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
ValidatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    dwError = IPSecGetISAKMPData(
                  hPolicyStore,
                  pIpsecPolicyData->ISAKMPIdentifier,
                  &pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPData) {
        FreeIpsecISAKMPData(
            pIpsecISAKMPData
            );
    }

    return (dwError);
}


DWORD
ValidateNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    GUID gZeroGUID;


    memset(&gZeroGUID, 0, sizeof(GUID));

    if (memcmp(
            &gZeroGUID,
            &pIpsecNFAData->FilterIdentifier,
            sizeof(GUID))) {
        dwError = IPSecGetFilterData(
                      hPolicyStore,
                      pIpsecNFAData->FilterIdentifier, 
                      &pIpsecFilterData
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = IPSecGetNegPolData(
                  hPolicyStore,
                  pIpsecNFAData->NegPolIdentifier, 
                  &pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPolicyDataExistence(
                  hPolicyStore,
                  PolicyIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterData) {
        FreeIpsecFilterData(
            pIpsecFilterData
            );
    }

    if (pIpsecNegPolData) {
        FreeIpsecNegPolData(
            pIpsecNegPolData
            );
    }

    return (dwError);
}


DWORD
VerifyPolicyDataExistence(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

        case IPSEC_REGISTRY_PROVIDER:
            dwError = RegVerifyPolicyDataExistence(
                          pPolicyStore->hRegistryKey,
                          pPolicyStore->pszIpsecRootContainer,
                          PolicyIdentifier
                          );
            break;

        case IPSEC_DIRECTORY_PROVIDER:
            dwError = DirVerifyPolicyDataExistence(
                          pPolicyStore->hLdapBindHandle,
                          pPolicyStore->pszIpsecRootContainer,
                          PolicyIdentifier
                          );
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            break;

    }

    return (dwError);
}


DWORD
RegGetNFAReferencesForPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecRelPolicyName,
    LPWSTR ** pppszIpsecNFANames,
    PDWORD pdwNumNFANames
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = 0;
    LPWSTR pszIpsecNFAReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;
    DWORD i = 0;


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecRelPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pszTemp = pszIpsecNFAReference;
    while (*pszTemp != L'\0') {

        pszTemp += wcslen(pszTemp) + 1;
        dwCount++;

    }

    if (!dwCount) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pszIpsecNFAReference;
    for (i = 0; i < dwCount; i++) {

        pszString = AllocPolStr(pszTemp);
        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszString;

        pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

    }

    *pppszIpsecNFANames = ppszIpsecNFANames;
    *pdwNumNFANames = dwCount;

    dwError = ERROR_SUCCESS;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    return(dwError);

error:

    if (ppszIpsecNFANames) {
        FreeNFAReferences(
            ppszIpsecNFANames,
            dwCount
            );
    }

    *pppszIpsecNFANames = NULL;
    *pdwNumNFANames = 0;

    goto cleanup;
}


DWORD
RegVerifyPolicyDataExistence(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    WCHAR szIpsecPolicyName[MAX_PATH];
    LPWSTR pszPolicyName = NULL;
    HKEY hRegKey = NULL;


    szIpsecPolicyName[0] = L'\0';
    wcscpy(szIpsecPolicyName, L"ipsecPolicy");

    dwError = UuidToString(&PolicyGUID, &pszPolicyName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecPolicyName, L"{");
    wcscat(szIpsecPolicyName, pszPolicyName);
    wcscat(szIpsecPolicyName, L"}");

    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  szIpsecPolicyName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszPolicyName) {
        RpcStringFree(&pszPolicyName);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
DirVerifyPolicyDataExistence(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;


    dwError = GenerateSpecificPolicyQuery(
                  PolicyGUID,
                  &pszPolicyString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszPolicyString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (pszPolicyString) {
        FreePolStr(pszPolicyString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\externs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    externs.h

Abstract:

    Holds externs for global variables.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


extern HANDLE ghInstance;

extern LPWSTR gpszStrBindingOptions;

extern const ULONG guFatalExceptions[];

extern const int FATAL_EXCEPTIONS_ARRAY_SIZE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\bind.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    bind.c

Abstract:

    Contains the RPC bind and un-bind routines.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


handle_t
TRANSPORTFILTER_HANDLE_bind(
    TRANSPORTFILTER_HANDLE hFilter,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
TRANSPORTFILTER_HANDLE_unbind(
    TRANSPORTFILTER_HANDLE hFilter,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
STRING_HANDLE_bind(
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStringBinding = NULL;
    handle_t   hBinding = NULL;
    LPWSTR pszServerPrincipalName = NULL;


    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0,
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStringBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStringBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStringBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStringBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingSetOption(
                    hBinding,
                    RPC_C_OPT_UNIQUE_BINDING,
                    (ULONG_PTR) 1
                    );

    if (RpcStatus != RPC_S_OK) {
        STRING_HANDLE_unbind(lpStr, hBinding);
        return NULL;
    }

    RpcStatus = RpcMgmtInqServerPrincName(
                    hBinding,
                    RPC_C_AUTHN_WINNT,
                    &pszServerPrincipalName
                    );

    if (RpcStatus != RPC_S_OK) {
        STRING_HANDLE_unbind(lpStr, hBinding);
        RpcRaiseException(RpcStatus);
    }

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcBindingSetAuthInfoW(
                        hBinding,
                        pszServerPrincipalName,
                        RPC_C_PROTECT_LEVEL_PKT_PRIVACY,
                        RPC_C_AUTHN_WINNT,
                        NULL,
                        RPC_C_AUTHZ_NONE
                        );
    }
    else {
        RpcStatus = RpcBindingSetAuthInfoW(
                        hBinding,
                        pszServerPrincipalName,
                        RPC_C_PROTECT_LEVEL_PKT_PRIVACY,
                        RPC_C_AUTHN_GSS_NEGOTIATE,
                        NULL,
                        RPC_C_AUTHZ_NONE
                        );
    }

    if (pszServerPrincipalName) {
        RpcStringFree(&pszServerPrincipalName);
    }

    if (RpcStatus != RPC_S_OK) {
        STRING_HANDLE_unbind(lpStr, hBinding);
        return NULL;
    }

    ASSERT(RpcStatus == RPC_S_OK);

    return (hBinding);
}


VOID
STRING_HANDLE_unbind(
    STRING_HANDLE lpStr,
    handle_t      hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
MMFILTER_HANDLE_bind(
    MMFILTER_HANDLE hFilter,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
MMFILTER_HANDLE_unbind(
    MMFILTER_HANDLE hFilter,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
IKENEGOTIATION_HANDLE_bind(
    IKENEGOTIATION_HANDLE hIKENegotiation,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
IKENEGOTIATION_HANDLE_unbind(
    IKENEGOTIATION_HANDLE hIKENegotiation,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
IKENOTIFY_HANDLE_bind(
    IKENOTIFY_HANDLE hIKENegotiation,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
IKENOTIFY_HANDLE_unbind(
    IKENOTIFY_HANDLE hIKENegotiation,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
TUNNELFILTER_HANDLE_bind(
    TUNNELFILTER_HANDLE hFilter,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
TUNNELFILTER_HANDLE_unbind(
    TUNNELFILTER_HANDLE hFilter,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\polstore\validate.h ===
DWORD
ValidateISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );


DWORD
ValidateNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );


BOOL
IsClearOnly(
    GUID gNegPolAction
    );


BOOL
IsBlocking(
    GUID gNegPolAction
    );


DWORD
ValidateISAKMPDataDeletion(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier
    );


DWORD
ValidateNegPolDataDeletion(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    );


DWORD
ValidateFilterDataDeletion(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    );


DWORD
ValidatePolicyDataDeletion(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );


DWORD
ValidatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );


DWORD
ValidateNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );


DWORD
VerifyPolicyDataExistence(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier
    );


DWORD
RegGetNFAReferencesForPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecRelPolicyName,
    LPWSTR ** pppszIpsecNFANames,
    PDWORD pdwNumNFANames
    );


DWORD
RegVerifyPolicyDataExistence(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID
    );


DWORD
DirVerifyPolicyDataExistence(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    init.c

Abstract:

    Holds initialization code for winipsec.dll.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


// This entry point is called on DLL initialization.
// The module handle is needed to load the resources.


BOOL
InitializeDll(
    IN PVOID    hmod,
    IN DWORD    dwReason,
    IN PCONTEXT pctx      OPTIONAL
    )
{
    DBG_UNREFERENCED_PARAMETER(pctx);

    switch (dwReason) {

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls((HMODULE) hmod);
        ghInstance = hmod;

        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\globals.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    globals.c

Abstract:

    Holds global variable declarations.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


HANDLE ghInstance = NULL;

/*
Security=[Impersonation | Identification | Anonymous] [Dynamic | Static] [True | False]
         (where True | False corresponds to EffectiveOnly)
*/

LPWSTR gpszStrBindingOptions = L"Security=Impersonation Dynamic False";


const ULONG guFatalExceptions[] =
    {
    STATUS_ACCESS_VIOLATION,
    STATUS_POSSIBLE_DEADLOCK,
    STATUS_INSTRUCTION_MISALIGNMENT,
    STATUS_DATATYPE_MISALIGNMENT,
    STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_ILLEGAL_INSTRUCTION,
    STATUS_BREAKPOINT,
    STATUS_STACK_OVERFLOW
    };


const int FATAL_EXCEPTIONS_ARRAY_SIZE =
    sizeof(guFatalExceptions) / sizeof(guFatalExceptions[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\spd_c_stub.c ===
#include "spd_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    precomp.h

Abstract:

    Precompiled header for winipsec.dll.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <winddiui.h>
#include <wininet.h>
#include "shlobj.h"
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <dsrole.h>
#include <dsgetdc.h>
#include <wininet.h>
#include <activeds.h>
#include <ntdsapi.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include "winsock2.h"
#include "winsock.h"

#include "spd_c.h"
#include "winipsec.h"
#include "externs.h"
#include "utils.h"
#include "client.h"
#include "ipsecshr.h"


#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {                   \
        goto error;                  \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\utils.c ===
#include "precomp.h"

DWORD
SPDDestroyClientContextHandle(
    DWORD dwStatus,
    HANDLE hFilter
    )
{
    DWORD dwError = 0;


    switch (dwStatus) {

    case RPC_S_SERVER_UNAVAILABLE:
    case RPC_S_CALL_FAILED:
    case RPC_S_CALL_FAILED_DNE:
    case RPC_S_UNKNOWN_IF:

        RpcTryExcept {

            RpcSsDestroyClientContext(&hFilter);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwError = TranslateExceptionCode(RpcExceptionCode());
            BAIL_ON_WIN32_ERROR(dwError);

        } RpcEndExcept

        break;

    default:

        dwError = dwStatus;
        break;

    }

error:

    return (dwError);
}


int
RPC_ENTRY
I_RpcExceptionFilter(
    unsigned long uExceptionCode
    )
{
    int i = 0;


    for (i = 0; i < FATAL_EXCEPTIONS_ARRAY_SIZE; i ++) {

        if (uExceptionCode == guFatalExceptions[i]) {
            return EXCEPTION_CONTINUE_SEARCH;
        }

    }

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\utils.h ===
DWORD
SPDDestroyClientContextHandle(
    DWORD dwStatus,
    HANDLE hFilter
    );

int
RPC_ENTRY
I_RpcExceptionFilter(
    unsigned long uExceptionCode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\winipsec.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    winipsec.c

Abstract:

    Contains IPSec WINAPI calls specific code.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
SPDApiBufferAllocate(
    DWORD dwByteCount,
    LPVOID * ppBuffer
    )
{
    DWORD dwError = 0;

    if (ppBuffer == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppBuffer = MIDL_user_allocate(dwByteCount);

    if (*ppBuffer == NULL) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}


VOID
SPDApiBufferFree(
    LPVOID pBuffer
    )
{
    if (pBuffer) {
        MIDL_user_free(pBuffer);
    }
}


DWORD
AddTransportFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PTRANSPORT_FILTER pTransportFilter,
    PHANDLE phFilter
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (!phFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTransportFilter(
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTransportFilters = pTransportFilter;

    RpcTryExcept {

        dwError = RpcAddTransportFilter(
                      pServerName,
                      dwFlags,
                      pFilterContainer,
                      phFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteTransportFilter(
    HANDLE hFilter
    )
{
    DWORD dwError = 0;


    if (!hFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcDeleteTransportFilter(
                      &hFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hFilter
                      );
    }

    return (dwError);
}


DWORD
EnumTransportFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PTRANSPORT_FILTER * ppTransportFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    memset(pFilterContainer, 0, sizeof(TRANSPORT_FILTER_CONTAINER));

    if (!ppTransportFilters || !pdwNumFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    RpcTryExcept {

        dwError = RpcEnumTransportFilters(
                      pServerName,
                      dwLevel,
                      gGenericFilterID,
                      &pFilterContainer,
                      dwPreferredNumEntries,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppTransportFilters = pFilterContainer->pTransportFilters;
    *pdwNumFilters = pFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppTransportFilters = NULL;
    *pdwNumFilters = 0;

    return (dwError);
}


DWORD
SetTransportFilter(
    HANDLE hFilter,
    PTRANSPORT_FILTER pTransportFilter
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (!hFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTransportFilter(
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTransportFilters = pTransportFilter;

    RpcTryExcept {

        dwError = RpcSetTransportFilter(
                      hFilter,
                      pFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetTransportFilter(
    HANDLE hFilter,
    PTRANSPORT_FILTER * ppTransportFilter
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    memset(pFilterContainer, 0, sizeof(TRANSPORT_FILTER_CONTAINER));

    if (!hFilter || !ppTransportFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetTransportFilter(
                      hFilter,
                      &pFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppTransportFilter = pFilterContainer->pTransportFilters;
    return (dwError);

error:

    *ppTransportFilter = NULL;
    return (dwError);
}


DWORD
AddQMPolicy(
    LPWSTR pServerName,
    DWORD dwFlags,
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    dwError = ValidateQMPolicy(
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pQMPolicyContainer->dwNumPolicies = 1;
    pQMPolicyContainer->pPolicies = pQMPolicy;

    RpcTryExcept {

        dwError = RpcAddQMPolicy(
                      pServerName,
                      dwFlags,
                      pQMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;


    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    RpcTryExcept {

        dwError = RpcDeleteQMPolicy(
                      pServerName,
                      pszPolicyName
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
EnumQMPolicies(
    LPWSTR pServerName,
    PIPSEC_QM_POLICY * ppQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    if (!ppQMPolicies || !pdwNumPolicies || !pdwResumeHandle) {
        //
        // Do not bail to error from here.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcEnumQMPolicies(
                      pServerName,
                      &pQMPolicyContainer,
                      dwPreferredNumEntries,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppQMPolicies = pQMPolicyContainer->pPolicies;
    *pdwNumPolicies = pQMPolicyContainer->dwNumPolicies;

    return (dwError);

error:

    *ppQMPolicies = NULL;
    *pdwNumPolicies = 0;

    return (dwError);
}


DWORD
SetQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateQMPolicy(
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pQMPolicyContainer->dwNumPolicies = 1;
    pQMPolicyContainer->pPolicies = pQMPolicy;

    RpcTryExcept {

        dwError = RpcSetQMPolicy(
                      pServerName,
                      pszPolicyName,
                      pQMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetQMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY * ppQMPolicy
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER  QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    if (!pszPolicyName || !*pszPolicyName || !ppQMPolicy) {
        //
        // Do not bail to error from here.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetQMPolicy(
                      pServerName,
                      pszPolicyName,
                      &pQMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppQMPolicy = pQMPolicyContainer->pPolicies;
    return (dwError);

error:

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
AddMMPolicy(
    LPWSTR pServerName,
    DWORD dwFlags,
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;


    dwError = ValidateMMPolicy(
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMPolicyContainer->dwNumPolicies = 1;
    pMMPolicyContainer->pPolicies = pMMPolicy;

    RpcTryExcept {

        dwError = RpcAddMMPolicy(
                      pServerName,
                      dwFlags,
                      pMMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;


    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    RpcTryExcept {

        dwError = RpcDeleteMMPolicy(
                      pServerName,
                      pszPolicyName
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
EnumMMPolicies(
    LPWSTR pServerName,
    PIPSEC_MM_POLICY * ppMMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;


    memset(pMMPolicyContainer, 0, sizeof(IPSEC_MM_POLICY_CONTAINER));

    if (!ppMMPolicies || !pdwNumPolicies || !pdwResumeHandle) {
        //
        // Do not bail to error from here.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcEnumMMPolicies(
                      pServerName,
                      &pMMPolicyContainer,
                      dwPreferredNumEntries,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMMPolicies = pMMPolicyContainer->pPolicies;
    *pdwNumPolicies = pMMPolicyContainer->dwNumPolicies;

    return (dwError);

error:

    *ppMMPolicies = NULL;
    *pdwNumPolicies = 0;

    return (dwError);
}


DWORD
SetMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;


    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateMMPolicy(
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMPolicyContainer->dwNumPolicies = 1;
    pMMPolicyContainer->pPolicies = pMMPolicy;

    RpcTryExcept {

        dwError = RpcSetMMPolicy(
                      pServerName,
                      pszPolicyName,
                      pMMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY * ppMMPolicy
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER  MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;


    memset(pMMPolicyContainer, 0, sizeof(IPSEC_MM_POLICY_CONTAINER));

    if (!pszPolicyName || !*pszPolicyName || !ppMMPolicy) {
        //
        // Do not bail to error from here.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetMMPolicy(
                      pServerName,
                      pszPolicyName,
                      &pMMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppMMPolicy = pMMPolicyContainer->pPolicies;
    return (dwError);

error:

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
AddMMFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PMM_FILTER pMMFilter,
    PHANDLE phMMFilter
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;


    if (!phMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilterContainer->dwNumFilters = 1;
    pMMFilterContainer->pMMFilters = pMMFilter;

    RpcTryExcept {

        dwError = RpcAddMMFilter(
                      pServerName,
                      dwFlags,
                      pMMFilterContainer,
                      phMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteMMFilter(
    HANDLE hMMFilter
    )
{
    DWORD dwError = 0;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcDeleteMMFilter(
                      &hMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hMMFilter
                      );
    }

    return (dwError);
}


DWORD
EnumMMFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PMM_FILTER * ppMMFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMMFilters,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;


    memset(pMMFilterContainer, 0, sizeof(MM_FILTER_CONTAINER));

    if (!ppMMFilters || !pdwNumMMFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    RpcTryExcept {

        dwError = RpcEnumMMFilters(
                      pServerName,
                      dwLevel,
                      gGenericFilterID,
                      &pMMFilterContainer,
                      dwPreferredNumEntries,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMMFilters = pMMFilterContainer->pMMFilters;
    *pdwNumMMFilters = pMMFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;

    return (dwError);
}


DWORD
SetMMFilter(
    HANDLE hMMFilter,
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilterContainer->dwNumFilters = 1;
    pMMFilterContainer->pMMFilters = pMMFilter;

    RpcTryExcept {

        dwError = RpcSetMMFilter(
                      hMMFilter,
                      pMMFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetMMFilter(
    HANDLE hMMFilter,
    PMM_FILTER * ppMMFilter
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;


    memset(pMMFilterContainer, 0, sizeof(MM_FILTER_CONTAINER));

    if (!hMMFilter || !ppMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetMMFilter(
                      hMMFilter,
                      &pMMFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppMMFilter = pMMFilterContainer->pMMFilters;
    return (dwError);

error:

    *ppMMFilter = NULL;
    return (dwError);
}


DWORD
MatchMMFilter(
    LPWSTR pServerName,
    PMM_FILTER pMMFilter,
    DWORD dwFlags,
    PMM_FILTER * ppMatchedMMFilters,
    PIPSEC_MM_POLICY * ppMatchedMMPolicies,
    PMM_AUTH_METHODS * ppMatchedMMAuthMethods,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER InMMFilterContainer;
    PMM_FILTER_CONTAINER pInMMFilterContainer = &InMMFilterContainer;
    MM_FILTER_CONTAINER OutMMFilterContainer;
    PMM_FILTER_CONTAINER pOutMMFilterContainer = &OutMMFilterContainer;
    IPSEC_MM_POLICY_CONTAINER MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;
    MM_AUTH_METHODS_CONTAINER MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;


    if (!pMMFilter || !ppMatchedMMFilters || !ppMatchedMMPolicies ||
        !ppMatchedMMAuthMethods || !pdwNumMatches || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateMMFilterTemplate(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pInMMFilterContainer->dwNumFilters = 1;
    pInMMFilterContainer->pMMFilters = pMMFilter;

    memset(pOutMMFilterContainer, 0, sizeof(MM_FILTER_CONTAINER));
    memset(pMMPolicyContainer, 0, sizeof(IPSEC_MM_POLICY_CONTAINER));
    memset(pMMAuthContainer, 0, sizeof(MM_AUTH_METHODS_CONTAINER));

    RpcTryExcept {

        dwError = RpcMatchMMFilter(
                      pServerName,
                      pInMMFilterContainer,
                      dwFlags,
                      &pOutMMFilterContainer,
                      &pMMPolicyContainer,
                      &pMMAuthContainer,
                      dwPreferredNumEntries,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMatchedMMFilters = pOutMMFilterContainer->pMMFilters;
    *ppMatchedMMPolicies = pMMPolicyContainer->pPolicies;
    *ppMatchedMMAuthMethods = pMMAuthContainer->pMMAuthMethods;
    *pdwNumMatches = pOutMMFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppMatchedMMFilters = NULL;
    *ppMatchedMMPolicies = NULL;
    *ppMatchedMMAuthMethods = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
MatchTransportFilter(
    LPWSTR pServerName,
    PTRANSPORT_FILTER pTxFilter,
    DWORD dwFlags,
    PTRANSPORT_FILTER * ppMatchedTxFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER InTxFilterContainer;
    PTRANSPORT_FILTER_CONTAINER pInTxFilterContainer = &InTxFilterContainer;
    TRANSPORT_FILTER_CONTAINER OutTxFilterContainer;
    PTRANSPORT_FILTER_CONTAINER pOutTxFilterContainer = &OutTxFilterContainer;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    if (!pTxFilter || !ppMatchedTxFilters || !ppMatchedQMPolicies ||
        !pdwNumMatches || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTxFilterTemplate(
                  pTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pInTxFilterContainer->dwNumFilters = 1;
    pInTxFilterContainer->pTransportFilters = pTxFilter;

    memset(pOutTxFilterContainer, 0, sizeof(TRANSPORT_FILTER_CONTAINER));
    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    RpcTryExcept {

        dwError = RpcMatchTransportFilter(
                      pServerName,
                      pInTxFilterContainer,
                      dwFlags,
                      &pOutTxFilterContainer,
                      &pQMPolicyContainer,
                      dwPreferredNumEntries,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMatchedTxFilters = pOutTxFilterContainer->pTransportFilters;
    *ppMatchedQMPolicies = pQMPolicyContainer->pPolicies;
    *pdwNumMatches = pOutTxFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppMatchedTxFilters = NULL;
    *ppMatchedQMPolicies = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
GetQMPolicyByID(
    LPWSTR pServerName,
    GUID gQMPolicyID,
    PIPSEC_QM_POLICY * ppQMPolicy
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER  QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    if (!ppQMPolicy) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetQMPolicyByID(
                      pServerName,
                      gQMPolicyID,
                      &pQMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppQMPolicy = pQMPolicyContainer->pPolicies;
    return (dwError);

error:

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
GetMMPolicyByID(
    LPWSTR pServerName,
    GUID gMMPolicyID,
    PIPSEC_MM_POLICY * ppMMPolicy
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER  MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;


    memset(pMMPolicyContainer, 0, sizeof(IPSEC_MM_POLICY_CONTAINER));

    if (!ppMMPolicy) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetMMPolicyByID(
                      pServerName,
                      gMMPolicyID,
                      &pMMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppMMPolicy = pMMPolicyContainer->pPolicies;
    return (dwError);

error:

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
AddMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwFlags,
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    MM_AUTH_METHODS_CONTAINER MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;


    dwError = ValidateMMAuthMethods(
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMAuthContainer->dwNumAuthMethods = 1;
    pMMAuthContainer->pMMAuthMethods = pMMAuthMethods;

    RpcTryExcept {

        dwError = RpcAddMMAuthMethods(
                      pServerName,
                      dwFlags,
                      pMMAuthContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID
    )
{
    DWORD dwError = 0;


    RpcTryExcept {

        dwError = RpcDeleteMMAuthMethods(
                      pServerName,
                      gMMAuthID
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
EnumMMAuthMethods(
    LPWSTR pServerName,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumAuthMethods,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    MM_AUTH_METHODS_CONTAINER MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;


    memset(pMMAuthContainer, 0, sizeof(MM_AUTH_METHODS_CONTAINER));

    if (!ppMMAuthMethods || !pdwNumAuthMethods || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcEnumMMAuthMethods(
                      pServerName,
                      &pMMAuthContainer,
                      dwPreferredNumEntries,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMMAuthMethods = pMMAuthContainer->pMMAuthMethods;
    *pdwNumAuthMethods = pMMAuthContainer->dwNumAuthMethods;

    return (dwError);

error:

    *ppMMAuthMethods = NULL;
    *pdwNumAuthMethods = 0;

    return (dwError);
}


DWORD
SetMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    MM_AUTH_METHODS_CONTAINER MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;


    dwError = ValidateMMAuthMethods(
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMAuthContainer->dwNumAuthMethods = 1;
    pMMAuthContainer->pMMAuthMethods = pMMAuthMethods;

    RpcTryExcept {

        dwError = RpcSetMMAuthMethods(
                      pServerName,
                      gMMAuthID,
                      pMMAuthContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS * ppMMAuthMethods
    )
{
    DWORD dwError = 0;
    MM_AUTH_METHODS_CONTAINER  MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;


    memset(pMMAuthContainer, 0, sizeof(MM_AUTH_METHODS_CONTAINER));

    if (!ppMMAuthMethods) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetMMAuthMethods(
                      pServerName,
                      gMMAuthID,
                      &pMMAuthContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppMMAuthMethods = pMMAuthContainer->pMMAuthMethods;
    return (dwError);

error:

    *ppMMAuthMethods = NULL;
    return (dwError);
}


DWORD
IPSecInitiateIKENegotiation(
    LPWSTR pServerName,
    PIPSEC_QM_FILTER pQMFilter,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    DWORD dwFlags,
    PHANDLE phNegotiation
    )
{
    DWORD dwError = 0;
    QM_FILTER_CONTAINER FilterContainer;
    PQM_FILTER_CONTAINER pFilterContainer = &FilterContainer;
    ULONG uhClientEvent = 0;

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pQMFilters = pQMFilter;
    uhClientEvent = HandleToUlong(hClientEvent);

    if (phNegotiation) {
        *phNegotiation=NULL;
    }

    dwError=ValidateInitiateIKENegotiation(
        pServerName,
        pFilterContainer,
        dwClientProcessId,
        uhClientEvent,
        dwFlags,
        phNegotiation
        );        
    BAIL_ON_WIN32_ERROR(dwError);    

    RpcTryExcept {

        dwError = RpcInitiateIKENegotiation(
                      pServerName,
                      pFilterContainer,
                      dwClientProcessId,
                      uhClientEvent,
                      dwFlags,
                      phNegotiation
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
IPSecQueryIKENegotiationStatus(
    HANDLE hNegotiation,
    PSA_NEGOTIATION_STATUS_INFO pNegotiationStatus
    )
{
    DWORD dwError = 0;

    dwError=ValidateQueryIKENegotiationStatus(
        hNegotiation,
        pNegotiationStatus
        );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcQueryIKENegotiationStatus(
                      hNegotiation,
                      pNegotiationStatus
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
IPSecCloseIKENegotiationHandle(
    HANDLE hNegotiation
    )
{
    DWORD dwError = 0;

    dwError=ValidateCloseIKENegotiationHandle(hNegotiation);
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcCloseIKENegotiationHandle(
                      &hNegotiation
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
IPSecEnumMMSAs(
    LPWSTR pServerName,
    PIPSEC_MM_SA pMMTemplate,
    PIPSEC_MM_SA * ppMMSAs,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    MM_SA_CONTAINER MMSAContainer, MMSAContainerTemplate;
    PMM_SA_CONTAINER pContainer = &MMSAContainer;


    MMSAContainerTemplate.dwNumMMSAs = 1;
    MMSAContainerTemplate.pMMSAs = pMMTemplate;

    memset(&MMSAContainer, 0, sizeof(MM_SA_CONTAINER));

    if (ppMMSAs == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    dwError=ValidateEnumMMSAs(
        pServerName,
        &MMSAContainerTemplate,
        &pContainer,
        pdwNumEntries,
        pdwTotalMMsAvailable,
        pdwEnumHandle,
        dwFlags
        );
    BAIL_ON_WIN32_ERROR(dwError);
            
    RpcTryExcept {

        dwError = RpcEnumMMSAs(
                      pServerName,
                      &MMSAContainerTemplate,
                      &pContainer,
                      pdwNumEntries,
                      pdwTotalMMsAvailable,
                      pdwEnumHandle,
                      dwFlags
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMMSAs = pContainer->pMMSAs;

    return (dwError);

error:

    return (dwError);
}

   
DWORD
IPSecDeleteMMSAs(
    LPWSTR pServerName,
    PIPSEC_MM_SA pMMTemplate,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    MM_SA_CONTAINER MMSAContainerTemplate;


    MMSAContainerTemplate.dwNumMMSAs = 1;
    MMSAContainerTemplate.pMMSAs = pMMTemplate;

    dwError=ValidateDeleteMMSAs(
        pServerName,
        &MMSAContainerTemplate,
        dwFlags
        );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcDeleteMMSAs(
                      pServerName,
                      &MMSAContainerTemplate,
                      dwFlags
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
IPSecDeleteQMSAs(
    LPWSTR pServerName,
    PIPSEC_QM_SA pIpsecQMSA,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    QM_SA_CONTAINER QMSATempContainer;
    PQM_SA_CONTAINER pQMSATempContainer = &QMSATempContainer;


    memset(pQMSATempContainer, 0, sizeof(QM_SA_CONTAINER));

    if (!pIpsecQMSA) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pQMSATempContainer->dwNumQMSAs = 1;
    pQMSATempContainer->pQMSAs = pIpsecQMSA;

    RpcTryExcept {

        dwError = RpcDeleteQMSAs(
                      pServerName,
                      pQMSATempContainer,
                      dwFlags
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
IPSecQueryIKEStatistics(
    LPWSTR pServerName,
    PIKE_STATISTICS pIKEStatistics
    )
{
    DWORD dwError = 0;

    dwError=ValidateQueryIKEStatistics(
        pServerName,
        pIKEStatistics
        );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcQueryIKEStatistics(
                      pServerName,
                      pIKEStatistics
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}

DWORD
IPSecRegisterIKENotifyClient(
    LPWSTR pServerName,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    IPSEC_QM_SA QMTemplate,
    PHANDLE phNotifyHandle,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    ULONG uhClientEvent = 0;
    

    QM_SA_CONTAINER QMSAContainer;
    PQM_SA_CONTAINER pQMSAContainer = &QMSAContainer;

    QMSAContainer.dwNumQMSAs=1;
    QMSAContainer.pQMSAs=&QMTemplate;

    uhClientEvent = HandleToUlong(hClientEvent);

    dwError=ValidateRegisterIKENotifyClient(
        pServerName,
        dwClientProcessId,
        uhClientEvent,
        pQMSAContainer,
        phNotifyHandle,
        dwFlags
        );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcRegisterIKENotifyClient(
                      pServerName,
                      dwClientProcessId,
                      uhClientEvent,
                      pQMSAContainer,
                      phNotifyHandle,
                      dwFlags
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        
        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD IPSecQueryNotifyData(
    HANDLE hNotifyHandle,
    PDWORD pdwNumEntries,
    PIPSEC_QM_SA *ppQMSAs,
    DWORD dwFlags
    )

{

    DWORD dwError = 0;
    QM_SA_CONTAINER QMSAContainer;
    PQM_SA_CONTAINER pContainer = &QMSAContainer;

    memset(&QMSAContainer, 0, sizeof(QM_SA_CONTAINER));

    if (ppQMSAs == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    dwError=ValidateQueryNotifyData(
        hNotifyHandle,
        pdwNumEntries,
        &pContainer,
        dwFlags
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    RpcTryExcept {

        dwError = RpcQueryNotifyData(
                      hNotifyHandle,
                      pdwNumEntries,
                      &pContainer,
                      dwFlags
                     );

        if (dwError && dwError != ERROR_MORE_DATA) {
            goto error;
        }
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppQMSAs = pContainer->pQMSAs;
    *pdwNumEntries = pContainer->dwNumQMSAs;

    return (dwError);

error:

    return (dwError);



}

DWORD IPSecCloseNotifyHandle(
    HANDLE hNotifyHandle
    )

{
    DWORD dwError = 0;

    dwError=ValidateCloseNotifyHandle(hNotifyHandle);
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcCloseNotifyHandle(
                      &hNotifyHandle
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
QueryIPSecStatistics(
    LPWSTR pServerName,
    PIPSEC_STATISTICS * ppIpsecStatistics
    )
{
    DWORD dwError = 0;
    IPSEC_STATISTICS_CONTAINER IpsecStatsContainer;
    PIPSEC_STATISTICS_CONTAINER pIpsecStatsContainer = &IpsecStatsContainer;


    memset(pIpsecStatsContainer, 0, sizeof(IPSEC_STATISTICS_CONTAINER));

    if (!ppIpsecStatistics) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcQueryIPSecStatistics(
                      pServerName,
                      &pIpsecStatsContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppIpsecStatistics = pIpsecStatsContainer->pIpsecStatistics;
    return (dwError);

error:

    return (dwError);
}


DWORD
EnumQMSAs(
    LPWSTR pServerName,
    PIPSEC_QM_SA pQMSATemplate,
    PIPSEC_QM_SA * ppQMSAs,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumQMSAs,
    LPDWORD pdwNumTotalQMSAs,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    QM_SA_CONTAINER QMSATempContainer;
    PQM_SA_CONTAINER pQMSATempContainer = &QMSATempContainer;
    QM_SA_CONTAINER QMSAContainer;
    PQM_SA_CONTAINER pQMSAContainer = &QMSAContainer;


    memset(pQMSAContainer, 0, sizeof(QM_SA_CONTAINER));

    if (!ppQMSAs || !pdwNumQMSAs ||
        !pdwNumTotalQMSAs || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pQMSATemplate) {
        pQMSATempContainer->dwNumQMSAs = 1;
        pQMSATempContainer->pQMSAs = pQMSATemplate;
    }
    else {
        pQMSATempContainer->dwNumQMSAs = 0;
        pQMSATempContainer->pQMSAs = NULL;
    }

    RpcTryExcept {

        dwError = RpcEnumQMSAs(
                      pServerName,
                      pQMSATempContainer,
                      &pQMSAContainer,
                      dwPreferredNumEntries,
                      pdwNumTotalQMSAs,
                      pdwResumeHandle,
                      dwFlags
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppQMSAs = pQMSAContainer->pQMSAs;
    *pdwNumQMSAs = pQMSAContainer->dwNumQMSAs;

    return (dwError);

error:

    return (dwError);
}


DWORD
AddTunnelFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PTUNNEL_FILTER pTunnelFilter,
    PHANDLE phFilter
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (!phFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTunnelFilters = pTunnelFilter;

    RpcTryExcept {

        dwError = RpcAddTunnelFilter(
                      pServerName,
                      dwFlags,
                      pFilterContainer,
                      phFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteTunnelFilter(
    HANDLE hFilter
    )
{
    DWORD dwError = 0;


    if (!hFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcDeleteTunnelFilter(
                      &hFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hFilter
                      );
    }

    return (dwError);
}


DWORD
EnumTunnelFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,
    PTUNNEL_FILTER * ppTunnelFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    memset(pFilterContainer, 0, sizeof(TUNNEL_FILTER_CONTAINER));

    if (!ppTunnelFilters || !pdwNumFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    RpcTryExcept {

        dwError = RpcEnumTunnelFilters(
                      pServerName,
                      dwLevel,
                      gGenericFilterID,
                      &pFilterContainer,
                      dwPreferredNumEntries,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppTunnelFilters = pFilterContainer->pTunnelFilters;
    *pdwNumFilters = pFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppTunnelFilters = NULL;
    *pdwNumFilters = 0;

    return (dwError);
}


DWORD
SetTunnelFilter(
    HANDLE hFilter,
    PTUNNEL_FILTER pTunnelFilter
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (!hFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTunnelFilters = pTunnelFilter;

    RpcTryExcept {

        dwError = RpcSetTunnelFilter(
                      hFilter,
                      pFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetTunnelFilter(
    HANDLE hFilter,
    PTUNNEL_FILTER * ppTunnelFilter
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    memset(pFilterContainer, 0, sizeof(TUNNEL_FILTER_CONTAINER));

    if (!hFilter || !ppTunnelFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetTunnelFilter(
                      hFilter,
                      &pFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppTunnelFilter = pFilterContainer->pTunnelFilters;
    return (dwError);

error:

    *ppTunnelFilter = NULL;
    return (dwError);
}


DWORD
MatchTunnelFilter(
    LPWSTR pServerName,
    PTUNNEL_FILTER pTnFilter,
    DWORD dwFlags,
    PTUNNEL_FILTER * ppMatchedTnFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER InTnFilterContainer;
    PTUNNEL_FILTER_CONTAINER pInTnFilterContainer = &InTnFilterContainer;
    TUNNEL_FILTER_CONTAINER OutTnFilterContainer;
    PTUNNEL_FILTER_CONTAINER pOutTnFilterContainer = &OutTnFilterContainer;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    if (!pTnFilter || !ppMatchedTnFilters || !ppMatchedQMPolicies ||
        !pdwNumMatches || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTnFilterTemplate(
                  pTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pInTnFilterContainer->dwNumFilters = 1;
    pInTnFilterContainer->pTunnelFilters = pTnFilter;

    memset(pOutTnFilterContainer, 0, sizeof(TUNNEL_FILTER_CONTAINER));
    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    RpcTryExcept {

        dwError = RpcMatchTunnelFilter(
                      pServerName,
                      pInTnFilterContainer,
                      dwFlags,
                      &pOutTnFilterContainer,
                      &pQMPolicyContainer,
                      dwPreferredNumEntries,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMatchedTnFilters = pOutTnFilterContainer->pTunnelFilters;
    *ppMatchedQMPolicies = pQMPolicyContainer->pPolicies;
    *pdwNumMatches = pOutTnFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppMatchedTnFilters = NULL;
    *ppMatchedQMPolicies = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
OpenMMFilterHandle(
    LPWSTR pServerName,
    PMM_FILTER pMMFilter,
    PHANDLE phMMFilter
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;


    if (!phMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilterContainer->dwNumFilters = 1;
    pMMFilterContainer->pMMFilters = pMMFilter;

    RpcTryExcept {

        dwError = RpcOpenMMFilterHandle(
                      pServerName,
                      pMMFilterContainer,
                      phMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
CloseMMFilterHandle(
    HANDLE hMMFilter
    )
{
    DWORD dwError = 0;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcCloseMMFilterHandle(
                      &hMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hMMFilter
                      );
    }

    return (dwError);
}


DWORD
OpenTransportFilterHandle(
    LPWSTR pServerName,
    PTRANSPORT_FILTER pTransportFilter,
    PHANDLE phTxFilter
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (!phTxFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTransportFilter(
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTransportFilters = pTransportFilter;

    RpcTryExcept {

        dwError = RpcOpenTransportFilterHandle(
                      pServerName,
                      pFilterContainer,
                      phTxFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
CloseTransportFilterHandle(
    HANDLE hTxFilter
    )
{
    DWORD dwError = 0;


    if (!hTxFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcCloseTransportFilterHandle(
                      &hTxFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hTxFilter
                      );
    }

    return (dwError);
}


DWORD
OpenTunnelFilterHandle(
    LPWSTR pServerName,
    PTUNNEL_FILTER pTunnelFilter,
    PHANDLE phTnFilter
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (!phTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTunnelFilters = pTunnelFilter;

    RpcTryExcept {

        dwError = RpcOpenTunnelFilterHandle(
                      pServerName,
                      pFilterContainer,
                      phTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
CloseTunnelFilterHandle(
    HANDLE hTnFilter
    )
{
    DWORD dwError = 0;


    if (!hTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcCloseTunnelFilterHandle(
                      &hTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hTnFilter
                      );
    }

    return (dwError);
}


DWORD
EnumIPSecInterfaces(
    LPWSTR pServerName,
    PIPSEC_INTERFACE_INFO pIpsecIfTemplate,
    PIPSEC_INTERFACE_INFO * ppIpsecInterfaces,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumInterfaces,
    LPDWORD pdwNumTotalInterfaces,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    IPSEC_INTERFACE_CONTAINER IpsecIfTempContainer;
    PIPSEC_INTERFACE_CONTAINER pIpsecIfTempContainer = &IpsecIfTempContainer;
    IPSEC_INTERFACE_CONTAINER IpsecIfContainer;
    PIPSEC_INTERFACE_CONTAINER pIpsecIfContainer = &IpsecIfContainer;


    memset(pIpsecIfContainer, 0, sizeof(IPSEC_INTERFACE_CONTAINER));

    if (!ppIpsecInterfaces || !pdwNumInterfaces ||
        !pdwNumTotalInterfaces || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pIpsecIfTemplate) {
        pIpsecIfTempContainer->dwNumInterfaces = 1;
        pIpsecIfTempContainer->pIpsecInterfaces = pIpsecIfTemplate;
    }
    else {
        pIpsecIfTempContainer->dwNumInterfaces = 0;
        pIpsecIfTempContainer->pIpsecInterfaces = NULL;
    }

    RpcTryExcept {

        dwError = RpcEnumIpsecInterfaces(
                      pServerName,
                      pIpsecIfTempContainer,
                      &pIpsecIfContainer,
                      dwPreferredNumEntries,
                      pdwNumTotalInterfaces,
                      pdwResumeHandle,
                      dwFlags
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppIpsecInterfaces = pIpsecIfContainer->pIpsecInterfaces;
    *pdwNumInterfaces = pIpsecIfContainer->dwNumInterfaces;

    return (dwError);

error:

    *ppIpsecInterfaces = NULL;
    *pdwNumInterfaces = 0;
    *pdwNumTotalInterfaces = 0;

    return (dwError);
}

DWORD IPSecAddSAs(
    LPWSTR pServerName,
    PIPSEC_QM_OFFER pQMOffer,
    PIPSEC_QM_FILTER pQMFilter,
    HANDLE *hLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE *pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *pOutboundKeyMat,
    BYTE *pContextInfo,
    DWORD dwFlags)
{

    DWORD dwError = 0;
    QM_FILTER_CONTAINER FilterContainer;
    PQM_FILTER_CONTAINER pFilterContainer = &FilterContainer;
    ULONG uhClientEvent = 0;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;
    IPSEC_QM_POLICY QMPolicy;
    DWORD uhLarvalContext=0;
    
    memset(&QMPolicy,0,sizeof(IPSEC_QM_POLICY));

    
    if (hLarvalContext == NULL) {
        dwError=ERROR_INVALID_PARAMETER;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    uhLarvalContext=HandleToUlong(*hLarvalContext);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pQMFilters = pQMFilter;

    pQMPolicyContainer->dwNumPolicies=1;
    QMPolicy.pOffers=pQMOffer;
    QMPolicy.dwOfferCount=1;
    pQMPolicyContainer->pPolicies=&QMPolicy;

    dwError=ValidateIPSecAddSA(
        pServerName,
        pQMPolicyContainer,
        pFilterContainer,
        &uhLarvalContext,
        dwInboundKeyMatLen,
        pInboundKeyMat,
        dwOutboundKeyMatLen,
        pOutboundKeyMat,
        pContextInfo,
        dwFlags);
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = RpcIPSecAddSA(
        pServerName,
        pQMPolicyContainer,
        pFilterContainer,
        &uhLarvalContext,
        dwInboundKeyMatLen,
        pInboundKeyMat,
        dwOutboundKeyMatLen,
        pOutboundKeyMat,
        pContextInfo,
        dwFlags);
    BAIL_ON_WIN32_ERROR(dwError);
    
    *hLarvalContext=LongToHandle(uhLarvalContext);
    
error:

    return dwError;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\client\midluser.c ===
/*++

Copyright (c) 1991 Microsoft Corporation


Module Name:

    midluser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    danl    02/06/1991

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


PVOID
MIDL_user_allocate(
    IN size_t NumBytes
    )
/*++

Routine Description:

    Allocates storage for RPC transactions. The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - the number of bytes to allocate.

Return Value:

    None.

--*/
{
    return (LocalAlloc(0,NumBytes));
}


VOID
MIDL_user_free(
    IN void * MemPointer
    )
/*++

Routine Description:

    Frees storage used in RPC transactions. The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - pointer to the memory block that is to be released.

Return Value:

    None.

--*/

{
    LocalFree(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\idl\import.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    krishnaG    21-September-1999

Environment:

    User Level: Win32

Revision History:

    abhisheV    29-September-1999

--*/


#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPDEVMODEW DWORD
#define PSECURITY_DESCRIPTOR DWORD
#define BOOL DWORD
#endif

#include <winipsec.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\address.h ===
#define IN_CLASSE(i)    (((long)(i) & 0xF0000000) == 0xF0000000)


DWORD
VerifyAddresses(
    ADDR Addr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    );


BOOL
EqualAddresses(
    IN ADDR     OldAddr,
    IN ADDR     NewAddr
    );


VOID
CopyAddresses(
    IN  ADDR    InAddr,
    OUT PADDR   pOutAddr
    );


BOOL
AddressesConflict(
    ADDR    SrcAddr,
    ADDR    DesAddr
    );


VOID
FreeAddresses(
    ADDR    Addr
    );


DWORD
VerifySubNetAddress(
    ULONG uSubNetAddr,
    ULONG uSubNetMask,
    BOOL bIsDesAddr
    );


BOOL
bIsValidIPMask(
    ULONG uMask
    );


BOOL
bIsValidIPAddress(
    ULONG uIpAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    );


BOOL
bIsValidSubnet(
    ULONG uIpAddr,
    ULONG uMask,
    BOOL bIsDesAddr
    );


BOOL
MatchAddresses(
    ADDR AddrToMatch,
    ADDR AddrTemplate
    );


DWORD
ApplyMulticastFilterValidation(
    ADDR Addr,
    BOOL bCreateMirror
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\address.c ===
#include"precomp.h"


DWORD
VerifyAddresses(
    ADDR Addr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    )
{
    DWORD   dwError = 0;
    BOOL    bIsValid = FALSE;

    switch (Addr.AddrType) {

    case IP_ADDR_UNIQUE:
        bIsValid = bIsValidIPAddress(
                       ntohl(Addr.uIpAddr),
                       bAcceptMe,
                       bIsDesAddr
                       );
        if (!bIsValid) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    case IP_ADDR_SUBNET:
        dwError = VerifySubNetAddress(
                      ntohl(Addr.uIpAddr),
                      ntohl(Addr.uSubNetMask),
                      bIsDesAddr
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case IP_ADDR_INTERFACE:
        if (Addr.uIpAddr) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


BOOL
EqualAddresses(
    IN ADDR     OldAddr,
    IN ADDR     NewAddr
    )
{
    BOOL bMatches = FALSE;

    if (OldAddr.AddrType == NewAddr.AddrType) {
        switch(OldAddr.AddrType) {
        case IP_ADDR_UNIQUE:
            if (OldAddr.uIpAddr == NewAddr.uIpAddr) {
                bMatches = TRUE;
            }
            break;
        case IP_ADDR_SUBNET:
            if ((OldAddr.uIpAddr == NewAddr.uIpAddr) && 
                (OldAddr.uSubNetMask == NewAddr.uSubNetMask)) {
                bMatches = TRUE;
            }
            break;
        case IP_ADDR_INTERFACE:
            if (!memcmp(
                     &OldAddr.gInterfaceID,
                     &NewAddr.gInterfaceID,
                     sizeof(GUID)) &&
                (OldAddr.uIpAddr == NewAddr.uIpAddr)) {
                bMatches = TRUE;
            }
            break;
        }
    }

    return (bMatches);
}


VOID
CopyAddresses(
    IN  ADDR    InAddr,
    OUT PADDR   pOutAddr
    )
{
    pOutAddr->AddrType = InAddr.AddrType;
    switch (InAddr.AddrType) {
    case IP_ADDR_UNIQUE:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
        memset(&pOutAddr->gInterfaceID, 0, sizeof(GUID));
        break;
    case IP_ADDR_SUBNET:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = InAddr.uSubNetMask;
        memset(&pOutAddr->gInterfaceID, 0, sizeof(GUID));
        break;
    case IP_ADDR_INTERFACE:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
        memcpy(
            &pOutAddr->gInterfaceID,
            &InAddr.gInterfaceID,
            sizeof(GUID)
            );
        break;
    }
}


BOOL
AddressesConflict(
    ADDR    SrcAddr,
    ADDR    DesAddr
    )
{
    if ((SrcAddr.AddrType == IP_ADDR_UNIQUE) &&
        (DesAddr.AddrType == IP_ADDR_UNIQUE)) {

        if (SrcAddr.uIpAddr == DesAddr.uIpAddr) {
            return (TRUE);
        }

    }

    if ((SrcAddr.AddrType == IP_ADDR_INTERFACE) &&
        (DesAddr.AddrType == IP_ADDR_INTERFACE)) {
        return (TRUE);
    }

    return (FALSE);
}


VOID
FreeAddresses(
    ADDR    Addr
    )
{
    switch (Addr.AddrType) {

    case (IP_ADDR_UNIQUE):
    case (IP_ADDR_SUBNET):
    case (IP_ADDR_INTERFACE):
        break;

    }
}


DWORD
VerifySubNetAddress(
    ULONG uSubNetAddr,
    ULONG uSubNetMask,
    BOOL bIsDesAddr
    )
{
    DWORD dwError = 0;
    BOOL  bIsValid = FALSE;

    if (uSubNetAddr == SUBNET_ADDRESS_ANY) {
        if (uSubNetMask != SUBNET_MASK_ANY) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        bIsValid = bIsValidSubnet(
                       uSubNetAddr,
                       uSubNetMask,
                       bIsDesAddr
                       );
        if (!bIsValid) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
bIsValidIPMask(
    ULONG uMask
    )
{
    BOOL    bValidMask = FALSE;
    ULONG   uTestMask = 0;

    //
    // Mask must be contiguous bits.
    //

    for (uTestMask = 0xFFFFFFFF; uTestMask; uTestMask <<= 1) {

        if (uTestMask == uMask) {
            bValidMask = TRUE;
            break;
        }

    }

    return (bValidMask);
}


BOOL
bIsValidIPAddress(
    ULONG uIpAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    )
{
    ULONG uHostMask = IN_CLASSA_HOST;   // Default host mask.


    //
    // Accept the address if its "me".
    //

    if (bAcceptMe) {
        if (uIpAddr == IP_ADDRESS_ME) {
            return TRUE;
        }
    }

    //
    // Reject if its a multicast address and is not the 
    // destination address.
    //

    if (IN_CLASSD(uIpAddr)) {
        if (bIsDesAddr) {
            return TRUE;
        }
        else {
            return FALSE;
        }
    }

    //
    // Reject if its a Class E address.
    //

    if (IN_CLASSE(uIpAddr)) {
        return FALSE;
    }

    //
    // Reject if the first octet is zero.
    //

    if (!(IN_CLASSA_NET & uIpAddr)) {
        return FALSE;
    }

    //
    // Use default mask based on Class when none is provided.
    //

    if (IN_CLASSA(uIpAddr)) {
        uHostMask = IN_CLASSA_HOST;
    }
    else if (IN_CLASSB(uIpAddr)) {
        uHostMask = IN_CLASSB_HOST;
    }
    else if (IN_CLASSC(uIpAddr)) {
        uHostMask = IN_CLASSC_HOST;
    }

    //
    // Accept address when host portion is non-zero.
    //

    if (uHostMask & uIpAddr) {
        return TRUE;
    }

    return FALSE;
}


BOOL
bIsValidSubnet(
    ULONG uIpAddr,
    ULONG uMask,
    BOOL bIsDesAddr
    )
{
    ULONG uHostMask = 0;


    //
    // Reject if its a multicast address and is not the 
    // destination address.
    //

    if (IN_CLASSD(uIpAddr)) {
        if (!bIsDesAddr) {
            return FALSE;
        }
    }

    //
    // Reject if its a Class E address.
    //

    if (IN_CLASSE(uIpAddr)) {
        return FALSE;
    }

    //
    // Reject if the first octet is zero.
    //

    if (!(IN_CLASSA_NET & uIpAddr)) {
        return FALSE;
    }

    //
    // If the mask is invalid then return.
    //

    if (!bIsValidIPMask(uMask)) {
        return FALSE;
    }

    //
    // Use the provided subnet mask to generate the host mask.
    //

    uHostMask = 0xFFFFFFFF ^ uMask;

    //
    // Validate the address and the mask.
    // 

    if (IN_CLASSA(uIpAddr)) {
        if (IN_CLASSA_NET > uMask) {
            return FALSE;
        }
    }
    else if (IN_CLASSB(uIpAddr)) {
        if (IN_CLASSB_NET > uMask) {
            return FALSE;
        }
    }
    else if (IN_CLASSC(uIpAddr)) {
        if (IN_CLASSC_NET > uMask) {
            //
            // Superset of Class C Subnet Address.
            //
            return TRUE;
        }
    }

    //
    // Accept address only when the host portion is zero, network
    // portion is non-zero and first octet is non-zero.
    //

    if (!(uHostMask & uIpAddr) &&
        (uMask & uIpAddr) && 
        (IN_CLASSA_NET & uIpAddr)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
MatchAddresses(
    ADDR AddrToMatch,
    ADDR AddrTemplate
    )
{

    switch (AddrTemplate.AddrType) {

    case IP_ADDR_UNIQUE:
        if ((AddrToMatch.uIpAddr & AddrToMatch.uSubNetMask) !=
            (AddrTemplate.uIpAddr & AddrToMatch.uSubNetMask)) {
            return (FALSE);
        }
        break;

    case IP_ADDR_SUBNET:
        if ((AddrToMatch.uIpAddr & AddrToMatch.uSubNetMask) !=
            ((AddrTemplate.uIpAddr & AddrTemplate.uSubNetMask)
            & AddrToMatch.uSubNetMask)) {
            return (FALSE);
        }
        break;

    case IP_ADDR_INTERFACE:
        if (memcmp(
                &AddrToMatch.gInterfaceID,
                &AddrTemplate.gInterfaceID,
                sizeof(GUID))) {
            return (FALSE);
        }
        break;

    }

    return (TRUE);
}


DWORD
ApplyMulticastFilterValidation(
    ADDR Addr,
    BOOL bCreateMirror
    )
{
    DWORD dwError = 0;


    if (((Addr.AddrType == IP_ADDR_UNIQUE) ||
        (Addr.AddrType == IP_ADDR_SUBNET)) &&
        (IN_CLASSD(ntohl(Addr.uIpAddr))) &&
        bCreateMirror) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

!INCLUDE $(NTMAKEENV)\makefile.plt

CLIENT_ACF = spdcli.acf
SERVER_ACF = spdsrv.acf

IDL_NAME  = spd
IMPORT    = import

UNICODE=1

INCS  = -I. -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(OAK_INC_PATH) -I$(PROJECT_ROOT)\inc

CPP = -cpp_cmd "$(MIDL_CPP)" -DNO_STRICT $(MIDL_FLAGS)


CLIENT_TARGETS =   $(O)\$(IDL_NAME)_c.c  \
                   $(O)\$(IDL_NAME)_c.h


SERVER_TARGETS =   $(O)\$(IDL_NAME)_s.c  \
                   $(O)\$(IDL_NAME)_s.h


#
# Define Products and Dependencies
#

all:    $(CLIENT_TARGETS) $(SERVER_TARGETS) 
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delete_source all

delete_source:
    erase $(CLIENT_TARGETS) $(SERVER_TARGETS)

#
# MIDL COMPILE
#

MIDL_OPTIMIZATION_NT5=-Oicf -no_format_opt -robust -error all -out .\$(O)

$(CLIENT_TARGETS) : $(IDL_NAME).idl $(CLIENT_ACF) 
    midl $(MIDL_OPTIMIZATION_NT5) -acf $(CLIENT_ACF) -server none -oldnames -ms_ext -c_ext $(CPP) $(INCS) $(IDL_NAME).idl -header $(IDL_NAME)_c.h

$(SERVER_TARGETS) : $(IDL_NAME).idl $(SERVER_ACF) 
    midl $(MIDL_OPTIMIZATION_NT5) -acf $(SERVER_ACF) -client none -oldnames -ms_ext -c_ext $(CPP) $(INCS) $(IDL_NAME).idl -header $(IDL_NAME)_s.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\audit.h ===
DWORD
PerformAudit(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    PSID pSid,
    DWORD dwParamCnt,
    LPWSTR * ppszArgArray,
    BOOL bSuccess,
    BOOL bDoAudit
    );

VOID
AuditEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR * ppszArguments,
    BOOL bSuccess,
    BOOL bDoAudit
    );

VOID
AuditOneArgErrorEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    DWORD dwErrorCode,
    BOOL bSuccess,
    BOOL bDoAudit
    );

VOID
AuditIPSecPolicyEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR pszPolicyName,
    BOOL bSuccess,
    BOOL bDoAudit
    );

VOID
AuditIPSecPolicyErrorEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR pszPolicyName,
    DWORD dwErrorCode,
    BOOL bSuccess,
    BOOL bDoAudit
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\driver.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    driver.h

Abstract:

    This module contains all of the code prototypes to
    drive the management of specific filters in the 
    IPSec driver.

Author:

    abhisheV    05-November-1999

Environment

    User Level: Win32

Revision History:


--*/


#define DEVICE_NAME         L"\\\\.\\IpsecDev"
#define IPSEC_SERVICE_NAME  L"IPSEC"


#if defined(__cplusplus)
extern "C" {
#endif


DWORD
SPDStartIPSecDriver(
    );


DWORD
SPDStopIPSecDriver(
    );


DWORD
SPDOpenIPSecDriver(
    PHANDLE phIPSecDriver
    );


VOID
SPDCloseIPSecDriver(
    HANDLE hIPSecDriver
    );


DWORD
InsertTransportFiltersIntoIPSec(
    PINITXSFILTER pSpecificFilters
    );


DWORD
DeleteTransportFiltersFromIPSec(
    PINITXSFILTER pSpecificFilters
    );


DWORD
WrapTransportFilters(
    PINITXSFILTER pSpecificFilters,
    PIPSEC_FILTER_INFO * ppInternalFilters,
    PDWORD pdwNumFilters
    );


VOID
FormIPSecTransportFilter(
    PINITXSFILTER pSpecificFilter,
    PIPSEC_FILTER_INFO pIpsecFilter
    );


DWORD
QueryDriverForIpsecStats(
    PIPSEC_QUERY_STATS * ppQueryStats
    );


DWORD
IpsecEnumSAs(
    PDWORD pdwNumberOfSAs,
    PIPSEC_ENUM_SAS * ppIpsecEnumSAs
    );


DWORD
CopyQMSA(
    PIPSEC_SA_INFO pInfo,
    PIPSEC_QM_SA pQMSA
    );


VOID
CopyQMSAOffer(
    PIPSEC_SA_INFO pInfo,
    PIPSEC_QM_OFFER pOffer
    );


VOID
CopyQMSAFilter(
    IPAddr MyTunnelEndpt,
    PIPSEC_FILTER pIpsecFilter,
    PIPSEC_QM_FILTER pIpsecQMFilter
    );


VOID
CopyQMSAMMSpi(
    IKE_COOKIE_PAIR CookiePair,
    PIKE_COOKIE_PAIR pMMSpi
    );


VOID
FreeQMSAs(
    DWORD dwCnt,
    PIPSEC_QM_SA pQMSAs
    );


DWORD
InsertTunnelFiltersIntoIPSec(
    PINITNSFILTER pSpecificFilters
    );


DWORD
DeleteTunnelFiltersFromIPSec(
    PINITNSFILTER pSpecificFilters
    );


DWORD
WrapTunnelFilters(
    PINITNSFILTER pSpecificFilters,
    PIPSEC_FILTER_INFO * ppInternalFilters,
    PDWORD pdwNumFilters
    );


VOID
FormIPSecTunnelFilter(
    PINITNSFILTER pSpecificFilter,
    PIPSEC_FILTER_INFO pIpsecFilter
    );


DWORD
SPDSetIPSecDriverOpMode(
    DWORD dwOpMode
    );


DWORD
SPDRegisterIPSecDriverProtocols(
    DWORD dwRegisterMode
    );


#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\driver.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    driver.c

Abstract:

    This module contains all of the code to drive the
    management of specific filters in the IPSec driver.

Author:

    abhisheV    05-November-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
SPDStartIPSecDriver(
    )
/*++

Routine Description:

    Starts the IPSec Driver service.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    SC_HANDLE ServiceDatabase = NULL;
    SC_HANDLE ServiceHandle   = NULL;
    BOOL bStatus = FALSE;
    DWORD dwError = 0;
    SERVICE_STATUS IpsecStatus;


    memset(&IpsecStatus, 0, sizeof(SERVICE_STATUS));


    ServiceDatabase = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_ALL_ACCESS
                          );
    if (ServiceDatabase == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    ServiceHandle = OpenService(
                        ServiceDatabase,
                        IPSEC_SERVICE_NAME,
                        SERVICE_START | SERVICE_QUERY_STATUS
                        );
    if (ServiceHandle == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    bStatus = QueryServiceStatus(
                  ServiceHandle,
                  &IpsecStatus
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (IpsecStatus.dwCurrentState == SERVICE_STOPPED) {

        bStatus = StartService(
                      ServiceHandle,
                      0,
                      NULL
                      );
        if (bStatus == FALSE) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }


error:

    if (ServiceDatabase != NULL) {
        CloseServiceHandle(ServiceDatabase);
    }

    if (ServiceHandle != NULL) {
        CloseServiceHandle(ServiceHandle);
    }

    return (dwError);
}


DWORD
SPDStopIPSecDriver(
    )
/*++

Routine Description:

    Stops the IPSec Driver service.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    SC_HANDLE ServiceDatabase = NULL;
    SC_HANDLE ServiceHandle   = NULL;
    BOOL bStatus = FALSE;
    DWORD dwError = 0;
    SERVICE_STATUS IpsecStatus;


    memset(&IpsecStatus, 0, sizeof(SERVICE_STATUS));


    ServiceDatabase = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_ALL_ACCESS
                          );
    if (ServiceDatabase == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    ServiceHandle = OpenService(
                        ServiceDatabase,
                        IPSEC_SERVICE_NAME,
                        SERVICE_STOP | SERVICE_QUERY_STATUS
                        );
    if (ServiceHandle == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    bStatus = QueryServiceStatus(
                  ServiceHandle,
                  &IpsecStatus
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (IpsecStatus.dwCurrentState == SERVICE_RUNNING) {

        bStatus = ControlService(
                      ServiceHandle,
                      SERVICE_CONTROL_STOP,
                      &IpsecStatus
                      );
        if (bStatus == FALSE) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }


error:

    if (ServiceDatabase != NULL) {
        CloseServiceHandle(ServiceDatabase);
    }

    if (ServiceHandle != NULL) {
        CloseServiceHandle(ServiceHandle);
    }

    return (dwError);
}


DWORD
SPDOpenIPSecDriver(
    PHANDLE phIPSecDriver
    )
/*++

Routine Description:

    Opens a handle to the IPSec Driver.

Arguments:

    phIPSecDriver - pointer to a handle to the IPSec Driver.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;


    hIPSecDriver = CreateFile(
                       DEVICE_NAME,                  // File name.
                       GENERIC_READ | GENERIC_WRITE, // Access mode.
                       0,                            // Share mode.
                       NULL,                         // Security attributes.
                       OPEN_EXISTING,                // How to create.
                       0,                            // File attributes.
                       NULL                          // Handle to file.
                       );
    if (hIPSecDriver == INVALID_HANDLE_VALUE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *phIPSecDriver = hIPSecDriver;

    return (dwError);

error:

    *phIPSecDriver = INVALID_HANDLE_VALUE;

    return (dwError);
}


VOID
SPDCloseIPSecDriver(
    HANDLE hIPSecDriver
    )
/*++

Routine Description:

    Closes the handle to the IPSec Driver.

Arguments:

    hIPSecDriver - handle to the IPSec Driver to close.

Return Value:

    None.

--*/
{
    if (hIPSecDriver) {
        CloseHandle(hIPSecDriver);
    }
}


DWORD
InsertTransportFiltersIntoIPSec(
    PINITXSFILTER pSpecificFilters
    )
/*++

Routine Description:

    Insert a list of specific filters into the
    IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to insert.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;

    BOOL bStatus = FALSE;

    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;

    DWORD dwNumFilters = 0;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    LPBYTE pTemp = NULL;
    DWORD i = 0;


    if (!pSpecificFilters) {
        return (dwError);
    }

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = WrapTransportFilters(
                  pSpecificFilters,
                  &pInternalFilters,
                  &dwNumFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwInBufferSize = sizeof(DWORD) +
                     sizeof(IPSEC_FILTER_INFO)*dwNumFilters;

    dwError = AllocateSPDMemory(
                   dwInBufferSize,
                   &pInBuffer
                   );
    BAIL_ON_WIN32_ERROR(dwError);


    pTemp = pInBuffer;
    memcpy(pTemp, &dwNumFilters, sizeof(DWORD));
    pTemp += sizeof(DWORD);

    for (i = 0 ; i < dwNumFilters; i++) {

        memcpy(pTemp, &(pInternalFilters[i]), sizeof(IPSEC_FILTER_INFO));
        pTemp += sizeof(IPSEC_FILTER_INFO);

    }


    bStatus =  DeviceIoControl(
                   hIPSecDriver,
                   IOCTL_IPSEC_ADD_FILTER,
                   pInBuffer,
                   dwInBufferSize,
                   pOutBuffer,
                   dwOutBufferSize,
                   &dwBytesReturned,
                   NULL
                   );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pInternalFilters) {
        FreeSPDMemory(pInternalFilters);
    }

    if (pInBuffer) {
        FreeSPDMemory(pInBuffer);
    }

    if (pOutBuffer) {
        LocalFree(pOutBuffer);
    }

    return (dwError);
}


DWORD
DeleteTransportFiltersFromIPSec(
    PINITXSFILTER pSpecificFilters
    )
/*++

Routine Description:

    Delete a list of filters from the IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to delete.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

 --*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;

    BOOL bStatus = FALSE;

    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;

    DWORD dwNumFilters = 0;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    LPBYTE pTemp = NULL;
    DWORD i = 0;


    if (!pSpecificFilters) {
        return (dwError);
    }

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = WrapTransportFilters(
                  pSpecificFilters,
                  &pInternalFilters,
                  &dwNumFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwInBufferSize = sizeof(DWORD) +
                     sizeof(IPSEC_FILTER_INFO)*dwNumFilters;

    dwError = AllocateSPDMemory(
                   dwInBufferSize,
                   &pInBuffer
                   );
    BAIL_ON_WIN32_ERROR(dwError);


    pTemp = pInBuffer;
    memcpy(pTemp, &dwNumFilters, sizeof(DWORD));
    pTemp += sizeof(DWORD);

    for (i = 0 ; i < dwNumFilters; i++) {

        memcpy(pTemp, &(pInternalFilters[i]), sizeof(IPSEC_FILTER_INFO));
        pTemp += sizeof(IPSEC_FILTER_INFO);

    }


    bStatus =  DeviceIoControl(
                   hIPSecDriver,
                   IOCTL_IPSEC_DELETE_FILTER,
                   pInBuffer,
                   dwInBufferSize,
                   pOutBuffer,
                   dwOutBufferSize,
                   &dwBytesReturned,
                   NULL
                   );

    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pInternalFilters) {
        FreeSPDMemory(pInternalFilters);
    }

    if (pInBuffer) {
        FreeSPDMemory(pInBuffer);
    }

    if (pOutBuffer) {
        LocalFree(pOutBuffer);
    }

    return (dwError);
}


DWORD
WrapTransportFilters(
    PINITXSFILTER pSpecificFilters,
    PIPSEC_FILTER_INFO * ppInternalFilters,
    PDWORD pdwNumFilters
    )
/*++

Routine Description:

    Transforms a list of specific transport filters to
    an equivalent list of filters acceptable to the
    IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to convert.

    ppInternalFilters - list of transformed filters.

    pdwNumFilters - count of the filters in the transformed
                    list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITXSFILTER pTempFilter = NULL;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    DWORD dwNumFilters = 0;
    DWORD i = 0;


    //
    // At this point, there's atleast one filter in the
    // specific filter list.
    //

    pTempFilter = pSpecificFilters;

    while(pTempFilter) {
        pTempFilter = pTempFilter->pNext;
        dwNumFilters++;
    }


    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_FILTER_INFO)*dwNumFilters,
                  &pInternalFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    pTempFilter = pSpecificFilters;

    while(pTempFilter) {

        FormIPSecTransportFilter(
            pTempFilter,
            &(pInternalFilters[i])
            );

        pTempFilter = pTempFilter->pNext;
        i++;

    }

    *ppInternalFilters = pInternalFilters;
    *pdwNumFilters = dwNumFilters;
    return (dwError);

error:

    *ppInternalFilters = NULL;
    *pdwNumFilters = 0;
    return (dwError);
}


VOID
FormIPSecTransportFilter(
    PINITXSFILTER pSpecificFilter,
    PIPSEC_FILTER_INFO pIpsecFilter
    )
/*++

Routine Description:

    Transforms a specific transport filter to an
    equivalent filter acceptable to the IPSec Driver.

Arguments:

    pSpecificFilter - filter to convert.

    pIpsecFilter - transformed filter.

Return Value:

    NONE.

--*/
{
    memcpy(
        &(pIpsecFilter->FilterId),
        &(pSpecificFilter->gParentID),
        sizeof(GUID)
        );

    memcpy(
        &(pIpsecFilter->PolicyId),
        &(pSpecificFilter->gPolicyID),
        sizeof(GUID)
        );

    pIpsecFilter->Index = pSpecificFilter->dwWeight;

    pIpsecFilter->AssociatedFilter.SrcAddr = pSpecificFilter->SrcAddr.uIpAddr;
    pIpsecFilter->AssociatedFilter.SrcMask = pSpecificFilter->SrcAddr.uSubNetMask;

    pIpsecFilter->AssociatedFilter.DestAddr = pSpecificFilter->DesAddr.uIpAddr;
    pIpsecFilter->AssociatedFilter.DestMask = pSpecificFilter->DesAddr.uSubNetMask;

    pIpsecFilter->AssociatedFilter.Protocol = pSpecificFilter->Protocol.dwProtocol;
    pIpsecFilter->AssociatedFilter.SrcPort = pSpecificFilter->SrcPort.wPort;
    pIpsecFilter->AssociatedFilter.DestPort = pSpecificFilter->DesPort.wPort;

    pIpsecFilter->AssociatedFilter.TunnelFilter = FALSE;
    pIpsecFilter->AssociatedFilter.TunnelAddr = 0;

    pIpsecFilter->AssociatedFilter.Flags = 0;

    if (pSpecificFilter->dwDirection == FILTER_DIRECTION_INBOUND) {
        pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_INBOUND;
        switch (pSpecificFilter->InboundFilterFlag) {

        case PASS_THRU:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_PASS_THRU;
            break;

        case BLOCKING:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_DROP;
            break;

        default:
            break;
        }
    }
    else {
        pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_OUTBOUND;
        switch (pSpecificFilter->OutboundFilterFlag) {

        case PASS_THRU:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_PASS_THRU;
            break;

        case BLOCKING:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_DROP;
            break;

        default:
            break;
        }
    }
}


DWORD
QueryIPSecStatistics(
    LPWSTR pServerName,
    PIPSEC_STATISTICS * ppIpsecStatistics
    )
{
    DWORD dwError = 0;
    PIPSEC_STATISTICS pIpsecStatistics = NULL;


    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = QueryDriverForIpsecStats(
                  &pIpsecStatistics
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecStatistics = pIpsecStatistics;

cleanup:

    return (dwError);

error:

    *ppIpsecStatistics = NULL;

    goto cleanup;
}


DWORD
QueryDriverForIpsecStats(
    PIPSEC_QUERY_STATS * ppQueryStats
    )
{
    DWORD dwError = 0;
    PIPSEC_QUERY_STATS pQueryStats = NULL;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;
    BOOL bStatus = FALSE;
    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;


    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QUERY_STATS),
                  &pQueryStats
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pInBuffer =  (LPBYTE) pQueryStats;
    dwInBufferSize = sizeof(IPSEC_QUERY_STATS);

    pOutBuffer = (LPBYTE) pQueryStats;
    dwOutBufferSize = sizeof(IPSEC_QUERY_STATS);

    dwBytesReturned = dwOutBufferSize;

    bStatus = DeviceIoControl(
                  hIPSecDriver,
                  IOCTL_IPSEC_QUERY_STATS,
                  pInBuffer,
                  dwInBufferSize,
                  pOutBuffer,
                  dwOutBufferSize,
                  &dwBytesReturned,
                  NULL
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppQueryStats = pQueryStats;

cleanup:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    return (dwError);

error:

    if (pQueryStats) {
        SPDApiBufferFree(pQueryStats);
    }

    *ppQueryStats = NULL;

    goto cleanup;
}


DWORD
EnumQMSAs(
    LPWSTR pServerName,
    PIPSEC_QM_SA pQMSATemplate,
    PIPSEC_QM_SA * ppQMSAs,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumQMSAs,
    LPDWORD pdwNumTotalQMSAs,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    DWORD dwNumTotalQMSAs = 0;
    PIPSEC_ENUM_SAS pIpsecEnumSAs = NULL;
    PIPSEC_SA_INFO pInfo = NULL;
    DWORD i = 0;
    DWORD dwNumQMSAs = 0;
    PIPSEC_QM_SA pQMSAs = NULL;
    PIPSEC_SA_INFO pTemp = NULL;
    PIPSEC_QM_SA pTempQMSA = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_QMSA_ENUM_COUNT)) {
        dwNumToEnum = MAX_QMSA_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IpsecEnumSAs(
                  &dwNumTotalQMSAs,
                  &pIpsecEnumSAs
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumTotalQMSAs <= dwResumeHandle) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pInfo = pIpsecEnumSAs->pInfo;

    for (i = 0; i < dwResumeHandle; i++) {
        pInfo++;
    }

    dwNumQMSAs = dwNumTotalQMSAs - dwResumeHandle;

    if (dwNumQMSAs > dwNumToEnum) {
        dwNumQMSAs = dwNumToEnum;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_SA)*dwNumQMSAs,
                  &pQMSAs
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pInfo;
    pTempQMSA = pQMSAs;

    for (i = 0; i < dwNumQMSAs; i++) {

        dwError = CopyQMSA(
                      pTemp,
                      pTempQMSA
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp++;
        pTempQMSA++;

    }

    *ppQMSAs = pQMSAs;
    *pdwResumeHandle = dwResumeHandle + dwNumQMSAs;
    *pdwNumQMSAs = dwNumQMSAs;
    *pdwNumTotalQMSAs = dwNumTotalQMSAs;

cleanup:

    if (pIpsecEnumSAs) {
        FreeSPDMem(pIpsecEnumSAs);
    }

    return (dwError);

error:

    if (pQMSAs) {
        FreeQMSAs(
            i,
            pQMSAs
            );
    }

    *ppQMSAs = NULL;
    *pdwResumeHandle = dwResumeHandle;
    *pdwNumQMSAs = 0;
    *pdwNumTotalQMSAs = 0;

    goto cleanup;
}


DWORD
IpsecEnumSAs(
    PDWORD pdwNumberOfSAs,
    PIPSEC_ENUM_SAS * ppIpsecEnumSAs
    )
{
    DWORD dwError = 0;
    DWORD dwNumberOfSAs = 0;
    PIPSEC_ENUM_SAS pIpsecEnumSAs = NULL;
    HANDLE hIPSecDriver = NULL;
    BOOL bStatus = FALSE;
    PIPSEC_ENUM_SAS pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;


    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // The first call passes in a return buffer of size IPSEC_ENUM_SAS.
    // The idea here is to determine the number of SAs and then pass
    // a second buffer with the correct size.
    //

    dwOutBufferSize = sizeof(IPSEC_ENUM_SAS);

    pOutBuffer = (PIPSEC_ENUM_SAS) AllocSPDMem(
                                       sizeof(IPSEC_ENUM_SAS)
                                       );
    if (!pOutBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memset(pOutBuffer, 0, dwOutBufferSize);
    dwBytesReturned = dwOutBufferSize;

    bStatus =  DeviceIoControl(
                   hIPSecDriver,
                   IOCTL_IPSEC_ENUM_SAS,
                   NULL,
                   0,
                   (PVOID) pOutBuffer,
                   dwOutBufferSize,
                   &dwBytesReturned,
                   NULL
                   );

    //
    // The error code here should be either ERROR_BUFFER_OVERFLOW
    // or ERROR_MORE_DATA or ERROR_SUCCESS.
    //

    if (!bStatus) {
        dwError = GetLastError();
    }
    else {
        dwError = ERROR_SUCCESS;
    }

    while (dwError == ERROR_BUFFER_OVERFLOW || dwError == ERROR_MORE_DATA) {

        //
        // Determine the number of SAs that the driver currently has.
        //

        pIpsecEnumSAs = (PIPSEC_ENUM_SAS) pOutBuffer;
        dwNumberOfSAs = pIpsecEnumSAs->NumEntriesPresent;

        if (dwNumberOfSAs == 0) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pOutBuffer) {
            FreeSPDMem(pOutBuffer);
            pOutBuffer = NULL;
        }

        dwOutBufferSize = sizeof(IPSEC_ENUM_SAS)
                                + (dwNumberOfSAs -1)*sizeof(IPSEC_SA_INFO);

        pOutBuffer = (PIPSEC_ENUM_SAS) AllocSPDMem(
                                           dwOutBufferSize
                                           );
        if (!pOutBuffer) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memset(pOutBuffer, 0, dwOutBufferSize);
        dwBytesReturned = dwOutBufferSize;

        bStatus =  DeviceIoControl(
                       hIPSecDriver,
                       IOCTL_IPSEC_ENUM_SAS,
                       NULL,
                       0,
                       (PVOID) pOutBuffer,
                       dwOutBufferSize,
                       &dwBytesReturned,
                       NULL
                       );

        if (!bStatus) {
            dwError = GetLastError();
        }
        else {
            dwError = ERROR_SUCCESS;
        }

    }

    pIpsecEnumSAs = (PIPSEC_ENUM_SAS) pOutBuffer;
    dwNumberOfSAs = pIpsecEnumSAs->NumEntries;

    if (dwNumberOfSAs == 0) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pdwNumberOfSAs = dwNumberOfSAs;
    *ppIpsecEnumSAs = pIpsecEnumSAs;

cleanup:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    return (dwError);

error:

    *pdwNumberOfSAs = 0;
    *ppIpsecEnumSAs = NULL;

    if (pOutBuffer) {
        FreeSPDMem(pOutBuffer);
    }

    goto cleanup;
}


DWORD
CopyQMSA(
    PIPSEC_SA_INFO pInfo,
    PIPSEC_QM_SA pQMSA
    )
{
    DWORD dwError = 0;


    memcpy(
        &(pQMSA->gQMPolicyID),
        &(pInfo->PolicyId),
        sizeof(GUID)
        );

    memcpy(
        &(pQMSA->gQMFilterID),
        &(pInfo->FilterId),
        sizeof(GUID)
        );

    CopyQMSAOffer(
        pInfo,
        &(pQMSA->SelectedQMOffer)
        );

    CopyQMSAFilter(
        pInfo->InboundTunnelAddr,
        &(pInfo->AssociatedFilter),
        &(pQMSA->IpsecQMFilter)
        );

    CopyQMSAMMSpi(
        pInfo->CookiePair,
        &(pQMSA->MMSpi)
        );

    return (dwError);
}


VOID
CopyQMSAOffer(
    PIPSEC_SA_INFO pInfo,
    PIPSEC_QM_OFFER pOffer
    )
{
    DWORD i = 0;
    DWORD j = 0;
    DWORD k = 0;


    pOffer->Lifetime.uKeyExpirationTime =
    pInfo->Lifetime.KeyExpirationTime;

    pOffer->Lifetime.uKeyExpirationKBytes =
    pInfo->Lifetime.KeyExpirationBytes;

    pOffer->dwFlags = 0;

    pOffer->dwPFSGroup = pInfo->dwQMPFSGroup;

    if ((pOffer->dwPFSGroup != PFS_GROUP_1) &&
        (pOffer->dwPFSGroup != PFS_GROUP_2) &&
        (pOffer->dwPFSGroup != PFS_GROUP_MM)) {
         pOffer->dwPFSGroup = PFS_GROUP_NONE;
         pOffer->bPFSRequired = FALSE;
    }
    else {
         pOffer->bPFSRequired = TRUE;
    }

    i = 0;

    for (j = 0; (j < pInfo->NumOps) && (i < QM_MAX_ALGOS) ; j++) {

        switch (pInfo->Operation[j]) {

        case Auth:

            switch (pInfo->AlgoInfo[j].IntegrityAlgo.algoIdentifier) {

            case IPSEC_AH_MD5:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_AH_MD5;
                break;

            case IPSEC_AH_SHA:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_AH_SHA1;
                break;

            default:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_AH_NONE;
                break;

            }

            pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AH_NONE;

            pOffer->Algos[i].Operation = AUTHENTICATION;

            pOffer->Algos[i].uAlgoKeyLen =
            pInfo->AlgoInfo[j].IntegrityAlgo.algoKeylen;

            pOffer->Algos[i].uAlgoRounds =
            pInfo->AlgoInfo[j].IntegrityAlgo.algoRounds;

            pOffer->Algos[i].MySpi = pInfo->InboundSPI[j];
            pOffer->Algos[i].PeerSpi = pInfo->OutboundSPI[j];

            i++;
            break;

        case Encrypt:

            switch (pInfo->AlgoInfo[j].ConfAlgo.algoIdentifier) {

            case IPSEC_ESP_DES:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_ESP_DES;
                break;

            case IPSEC_ESP_DES_40:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_ESP_DES;
                break;

            case IPSEC_ESP_3_DES:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
                break;

            default:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_ESP_NONE;
                break;

            }

            switch (pInfo->AlgoInfo[j].IntegrityAlgo.algoIdentifier) {

            case IPSEC_AH_MD5:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AH_MD5;
                break;

            case IPSEC_AH_SHA:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AH_SHA1;
                break;

            default:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AH_NONE;
                break;

            }

            pOffer->Algos[i].Operation = ENCRYPTION;

            pOffer->Algos[i].uAlgoKeyLen =
            pInfo->AlgoInfo[j].ConfAlgo.algoKeylen;

            pOffer->Algos[i].uAlgoRounds =
            pInfo->AlgoInfo[j].ConfAlgo.algoRounds;

            pOffer->Algos[i].MySpi = pInfo->InboundSPI[j];
            pOffer->Algos[i].PeerSpi = pInfo->OutboundSPI[j];

            i++;
            break;

        case None:

            pOffer->Algos[i].Operation = NONE;
            pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_ESP_NONE;
            pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AH_NONE;
            pOffer->Algos[i].uAlgoKeyLen = 0;
            pOffer->Algos[i].uAlgoRounds = 0;
            pOffer->Algos[i].MySpi = pInfo->InboundSPI[j];
            pOffer->Algos[i].PeerSpi = pInfo->OutboundSPI[j];

            i++;
            break;

        case Compress:
        default:
            break;

        }

    }

    for (k = i; k < QM_MAX_ALGOS; k++) {
         memset(&(pOffer->Algos[k]), 0, sizeof(IPSEC_QM_ALGO));
    }

    pOffer->dwNumAlgos = i;

    return;
}


VOID
CopyQMSAFilter(
    IPAddr MyTunnelEndpt,
    PIPSEC_FILTER pIpsecFilter,
    PIPSEC_QM_FILTER pIpsecQMFilter
    )
{
    if (pIpsecFilter->TunnelFilter) {
        pIpsecQMFilter->QMFilterType = QM_TUNNEL_FILTER;
    }
    else {
        pIpsecQMFilter->QMFilterType = QM_TRANSPORT_FILTER;
    }

    PASetAddress(
        pIpsecFilter->SrcMask,
        pIpsecFilter->SrcAddr,
        &(pIpsecQMFilter->SrcAddr)
        );

    PASetAddress(
        pIpsecFilter->DestMask,
        pIpsecFilter->DestAddr,
        &(pIpsecQMFilter->DesAddr)
        );

    pIpsecQMFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    pIpsecQMFilter->Protocol.dwProtocol = pIpsecFilter->Protocol;

    pIpsecQMFilter->SrcPort.PortType = PORT_UNIQUE;
    pIpsecQMFilter->SrcPort.wPort = ntohs(pIpsecFilter->SrcPort);

    pIpsecQMFilter->DesPort.PortType = PORT_UNIQUE;
    pIpsecQMFilter->DesPort.wPort = ntohs(pIpsecFilter->DestPort);

    if (pIpsecFilter->TunnelFilter) {
        PASetTunnelAddress(
            MyTunnelEndpt,
            &(pIpsecQMFilter->MyTunnelEndpt)
            );
        PASetTunnelAddress(
            pIpsecFilter->TunnelAddr,
            &(pIpsecQMFilter->PeerTunnelEndpt)
            );
    }
    else {
        PASetAddress(
            SUBNET_MASK_ANY,
            SUBNET_ADDRESS_ANY,
            &(pIpsecQMFilter->MyTunnelEndpt)
            );
        PASetAddress(
            SUBNET_MASK_ANY,
            SUBNET_ADDRESS_ANY,
            &(pIpsecQMFilter->PeerTunnelEndpt)
            );
    }

    pIpsecQMFilter->dwFlags = 0;

    if ((pIpsecFilter->Flags) & FILTER_FLAGS_INBOUND) {
        pIpsecQMFilter->dwFlags |= FILTER_DIRECTION_INBOUND;
    }
    else {
        pIpsecQMFilter->dwFlags |= FILTER_DIRECTION_OUTBOUND;
    }

    if ((pIpsecFilter->Flags) & FILTER_FLAGS_PASS_THRU) {
        pIpsecQMFilter->dwFlags |= FILTER_NATURE_PASS_THRU;
    }
    else if ((pIpsecFilter->Flags) & FILTER_FLAGS_DROP) {
        pIpsecQMFilter->dwFlags |= FILTER_NATURE_BLOCKING;
    }
    else {
        pIpsecQMFilter->dwFlags |= 0;
    }

    return;
}


VOID
CopyQMSAMMSpi(
    IKE_COOKIE_PAIR CookiePair,
    PIKE_COOKIE_PAIR pMMSpi
    )
{
    pMMSpi->Initiator = CookiePair.Initiator;

    pMMSpi->Responder = CookiePair.Responder;

    return;
}


VOID
FreeQMSAs(
    DWORD dwCnt,
    PIPSEC_QM_SA pQMSAs
    )
{
    if (pQMSAs) {
        SPDApiBufferFree(pQMSAs);
    }
}


DWORD
InsertTunnelFiltersIntoIPSec(
    PINITNSFILTER pSpecificFilters
    )
/*++

Routine Description:

    Insert a list of specific filters into the
    IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to insert.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;

    BOOL bStatus = FALSE;

    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;

    DWORD dwNumFilters = 0;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    LPBYTE pTemp = NULL;
    DWORD i = 0;


    if (!pSpecificFilters) {
        return (dwError);
    }

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = WrapTunnelFilters(
                  pSpecificFilters,
                  &pInternalFilters,
                  &dwNumFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwInBufferSize = sizeof(DWORD) +
                     sizeof(IPSEC_FILTER_INFO)*dwNumFilters;

    dwError = AllocateSPDMemory(
                   dwInBufferSize,
                   &pInBuffer
                   );
    BAIL_ON_WIN32_ERROR(dwError);


    pTemp = pInBuffer;
    memcpy(pTemp, &dwNumFilters, sizeof(DWORD));
    pTemp += sizeof(DWORD);

    for (i = 0 ; i < dwNumFilters; i++) {

        memcpy(pTemp, &(pInternalFilters[i]), sizeof(IPSEC_FILTER_INFO));
        pTemp += sizeof(IPSEC_FILTER_INFO);

    }


    bStatus =  DeviceIoControl(
                   hIPSecDriver,
                   IOCTL_IPSEC_ADD_FILTER,
                   pInBuffer,
                   dwInBufferSize,
                   pOutBuffer,
                   dwOutBufferSize,
                   &dwBytesReturned,
                   NULL
                   );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pInternalFilters) {
        FreeSPDMemory(pInternalFilters);
    }

    if (pInBuffer) {
        FreeSPDMemory(pInBuffer);
    }

    if (pOutBuffer) {
        LocalFree(pOutBuffer);
    }

    return (dwError);
}


DWORD
DeleteTunnelFiltersFromIPSec(
    PINITNSFILTER pSpecificFilters
    )
/*++

Routine Description:

    Delete a list of filters from the IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to delete.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

 --*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;

    BOOL bStatus = FALSE;

    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;

    DWORD dwNumFilters = 0;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    LPBYTE pTemp = NULL;
    DWORD i = 0;


    if (!pSpecificFilters) {
        return (dwError);
    }

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = WrapTunnelFilters(
                  pSpecificFilters,
                  &pInternalFilters,
                  &dwNumFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwInBufferSize = sizeof(DWORD) +
                     sizeof(IPSEC_FILTER_INFO)*dwNumFilters;

    dwError = AllocateSPDMemory(
                   dwInBufferSize,
                   &pInBuffer
                   );
    BAIL_ON_WIN32_ERROR(dwError);


    pTemp = pInBuffer;
    memcpy(pTemp, &dwNumFilters, sizeof(DWORD));
    pTemp += sizeof(DWORD);

    for (i = 0 ; i < dwNumFilters; i++) {

        memcpy(pTemp, &(pInternalFilters[i]), sizeof(IPSEC_FILTER_INFO));
        pTemp += sizeof(IPSEC_FILTER_INFO);

    }


    bStatus =  DeviceIoControl(
                   hIPSecDriver,
                   IOCTL_IPSEC_DELETE_FILTER,
                   pInBuffer,
                   dwInBufferSize,
                   pOutBuffer,
                   dwOutBufferSize,
                   &dwBytesReturned,
                   NULL
                   );

    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pInternalFilters) {
        FreeSPDMemory(pInternalFilters);
    }

    if (pInBuffer) {
        FreeSPDMemory(pInBuffer);
    }

    if (pOutBuffer) {
        LocalFree(pOutBuffer);
    }

    return (dwError);
}


DWORD
WrapTunnelFilters(
    PINITNSFILTER pSpecificFilters,
    PIPSEC_FILTER_INFO * ppInternalFilters,
    PDWORD pdwNumFilters
    )
/*++

Routine Description:

    Transforms a list of specific tunnel filters to
    an equivalent list of filters acceptable to the
    IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to convert.

    ppInternalFilters - list of transformed filters.

    pdwNumFilters - count of the filters in the transformed
                    list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNSFILTER pTempFilter = NULL;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    DWORD dwNumFilters = 0;
    DWORD i = 0;


    //
    // At this point, there's atleast one filter in the
    // specific filter list.
    //

    pTempFilter = pSpecificFilters;

    while(pTempFilter) {
        pTempFilter = pTempFilter->pNext;
        dwNumFilters++;
    }


    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_FILTER_INFO)*dwNumFilters,
                  &pInternalFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    pTempFilter = pSpecificFilters;

    while(pTempFilter) {

        FormIPSecTunnelFilter(
            pTempFilter,
            &(pInternalFilters[i])
            );

        pTempFilter = pTempFilter->pNext;
        i++;

    }

    *ppInternalFilters = pInternalFilters;
    *pdwNumFilters = dwNumFilters;
    return (dwError);

error:

    *ppInternalFilters = NULL;
    *pdwNumFilters = 0;
    return (dwError);
}


VOID
FormIPSecTunnelFilter(
    PINITNSFILTER pSpecificFilter,
    PIPSEC_FILTER_INFO pIpsecFilter
    )
/*++

Routine Description:

    Transforms a specific tunnel filter to an
    equivalent filter acceptable to the IPSec Driver.

Arguments:

    pSpecificFilter - filter to convert.

    pIpsecFilter - transformed filter.

Return Value:

    NONE.

--*/
{
    memcpy(
        &(pIpsecFilter->FilterId),
        &(pSpecificFilter->gParentID),
        sizeof(GUID)
        );

    memcpy(
        &(pIpsecFilter->PolicyId),
        &(pSpecificFilter->gPolicyID),
        sizeof(GUID)
        );

    pIpsecFilter->Index = pSpecificFilter->dwWeight;

    pIpsecFilter->AssociatedFilter.SrcAddr = pSpecificFilter->SrcAddr.uIpAddr;
    pIpsecFilter->AssociatedFilter.SrcMask = pSpecificFilter->SrcAddr.uSubNetMask;

    pIpsecFilter->AssociatedFilter.DestAddr = pSpecificFilter->DesAddr.uIpAddr;
    pIpsecFilter->AssociatedFilter.DestMask = pSpecificFilter->DesAddr.uSubNetMask;

    pIpsecFilter->AssociatedFilter.Protocol = pSpecificFilter->Protocol.dwProtocol;
    pIpsecFilter->AssociatedFilter.SrcPort = pSpecificFilter->SrcPort.wPort;
    pIpsecFilter->AssociatedFilter.DestPort = pSpecificFilter->DesPort.wPort;

    pIpsecFilter->AssociatedFilter.TunnelFilter = TRUE;
    pIpsecFilter->AssociatedFilter.TunnelAddr = pSpecificFilter->DesTunnelAddr.uIpAddr;

    pIpsecFilter->AssociatedFilter.Flags = 0;

    if (pSpecificFilter->dwDirection == FILTER_DIRECTION_INBOUND) {
        pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_INBOUND;
        switch (pSpecificFilter->InboundFilterFlag) {

        case PASS_THRU:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_PASS_THRU;
            break;

        case BLOCKING:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_DROP;
            break;

        default:
            break;
        }
    }
    else {
        pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_OUTBOUND;
        switch (pSpecificFilter->OutboundFilterFlag) {

        case PASS_THRU:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_PASS_THRU;
            break;

        case BLOCKING:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_DROP;
            break;

        default:
            break;
        }
    }
}


DWORD
SPDSetIPSecDriverOpMode(
    DWORD dwOpMode
    )
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    PIPSEC_SET_OPERATION_MODE pIpsecSetOpMode = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;
    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;
    BOOL bStatus = FALSE;


    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_SET_OPERATION_MODE),
                  &pIpsecSetOpMode
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecSetOpMode->OperationMode = (OPERATION_MODE) dwOpMode;

    pInBuffer =  (LPBYTE) pIpsecSetOpMode;
    dwInBufferSize = sizeof(IPSEC_SET_OPERATION_MODE);

    pOutBuffer = (LPBYTE) pIpsecSetOpMode;
    dwOutBufferSize = sizeof(IPSEC_SET_OPERATION_MODE);

    dwBytesReturned = dwOutBufferSize;

    bStatus = DeviceIoControl(
                  hIPSecDriver,
                  IOCTL_IPSEC_SET_OPERATION_MODE,
                  pInBuffer,
                  dwInBufferSize,
                  pOutBuffer,
                  dwOutBufferSize,
                  &dwBytesReturned,
                  NULL
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pIpsecSetOpMode) {
        FreeSPDMemory(pIpsecSetOpMode);
    }

    return (dwError);
}


DWORD
IPSecDeleteQMSAs(
    LPWSTR pServerName,
    PIPSEC_QM_SA pIpsecQMSA,
    DWORD dwFlags
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HANDLE hIPSecDriver = NULL;
    IPSEC_DELETE_SA IpsecDeleteSA;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;
    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;
    BOOL bStatus = FALSE;


    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    
    memcpy(
        &IpsecDeleteSA.SATemplate,
        pIpsecQMSA,
        sizeof(IPSEC_QM_SA)
        );

    pInBuffer = (LPBYTE) &IpsecDeleteSA;
    dwInBufferSize = sizeof(IPSEC_DELETE_SA);

    pOutBuffer = (LPBYTE) &IpsecDeleteSA;
    dwOutBufferSize = sizeof(IPSEC_DELETE_SA);

    dwBytesReturned = dwOutBufferSize;

    bStatus = DeviceIoControl(
                  hIPSecDriver,
                  IOCTL_IPSEC_DELETE_SA,
                  pInBuffer,
                  dwInBufferSize,
                  pOutBuffer,
                  dwOutBufferSize,
                  &dwBytesReturned,
                  NULL
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    return (dwError);
}


DWORD
SPDRegisterIPSecDriverProtocols(
    DWORD dwRegisterMode
    )
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    PIPSEC_REGISTER_PROTOCOL pIpsecRegisterProtocol = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;
    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;
    BOOL bStatus = FALSE;


    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_REGISTER_PROTOCOL),
                  &pIpsecRegisterProtocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecRegisterProtocol->RegisterProtocol = (REGISTER_PROTOCOL) dwRegisterMode;

    pInBuffer =  (LPBYTE) pIpsecRegisterProtocol;
    dwInBufferSize = sizeof(IPSEC_REGISTER_PROTOCOL);

    pOutBuffer = (LPBYTE) pIpsecRegisterProtocol;
    dwOutBufferSize = sizeof(IPSEC_REGISTER_PROTOCOL);

    dwBytesReturned = dwOutBufferSize;

    bStatus = DeviceIoControl(
                  hIPSecDriver,
                  IOCTL_IPSEC_REGISTER_PROTOCOL,
                  pInBuffer,
                  dwInBufferSize,
                  pOutBuffer,
                  dwOutBufferSize,
                  &dwBytesReturned,
                  NULL
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pIpsecRegisterProtocol) {
        FreeSPDMemory(pIpsecRegisterProtocol);
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\audit.c ===
#include "precomp.h"


#define MAX_AUDIT_BUFFER    4096

#define MAX_MSG_BUFFER      2048

WCHAR gszAuditBuffer[MAX_AUDIT_BUFFER];

WCHAR * gpszAuditBuffer = gszAuditBuffer;

WCHAR gszAuditMsgBuffer[MAX_MSG_BUFFER];

WCHAR * gpszAuditMsgBuffer = gszAuditMsgBuffer;


DWORD
PerformAudit(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    PSID pSid,
    DWORD dwParamCnt,
    LPWSTR * ppszArgArray,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    SE_ADT_PARAMETER_ARRAY * pParArray = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD dwStrSize = 0;
    DWORD i = 0;
    DWORD dwAllocSize = 0;
    BYTE * pbyteCurAddr = NULL;
    DWORD dwSidLength = RtlLengthSid(pSid);
    UNICODE_STRING * pusStrArray = NULL;
    WCHAR * pszModuleName = L"IPSec Server";


    //
    // dwCategoryId should be equal to SE_CATEGID_POLICY_CHANGE.
    //

    dwCategoryId = SE_CATEGID_POLICY_CHANGE;

    for (i = 0; i < dwParamCnt; i++) {
        dwStrSize += (wcslen(ppszArgArray[i]) + 1) * sizeof(WCHAR);
    }

    dwStrSize += (wcslen(pszModuleName) + 1) * sizeof(WCHAR);

    dwAllocSize = sizeof(SE_ADT_PARAMETER_ARRAY) +
                  dwParamCnt * sizeof(UNICODE_STRING) + dwStrSize;
    dwAllocSize += PtrAlignSize(dwSidLength);

    if (dwAllocSize > MAX_AUDIT_BUFFER) {
        return (ERROR_BUFFER_OVERFLOW);
    }

    pParArray = (SE_ADT_PARAMETER_ARRAY *) gpszAuditBuffer;

    pParArray->CategoryId = dwCategoryId;
    pParArray->AuditId = dwAuditId;
    pParArray->ParameterCount = dwParamCnt + 2;
    pParArray->Length = dwAllocSize;
    pParArray->Flags = 0;

    if (bSuccess) {
        pParArray->Type = EVENTLOG_AUDIT_SUCCESS;
    }
    else {
        pParArray->Type = EVENTLOG_AUDIT_FAILURE;
    }

    pbyteCurAddr = (BYTE *) (pParArray + 1);

    pParArray->Parameters[0].Type = SeAdtParmTypeSid;
    pParArray->Parameters[0].Length = dwSidLength;
    pParArray->Parameters[0].Data[0] = 0;
    pParArray->Parameters[0].Data[1] = 0;
    pParArray->Parameters[0].Address = pSid;

    memcpy((BYTE *) pbyteCurAddr, (BYTE *) pSid, dwSidLength);

    pbyteCurAddr = (BYTE *) pbyteCurAddr + PtrAlignSize(dwSidLength);

    pusStrArray = (UNICODE_STRING *) pbyteCurAddr;

    pusStrArray[0].Length = wcslen(pszModuleName) * sizeof(WCHAR);
    pusStrArray[0].MaximumLength = pusStrArray[0].Length + sizeof(WCHAR);
    pusStrArray[0].Buffer = (LPWSTR) pszModuleName;

    pParArray->Parameters[1].Type = SeAdtParmTypeString;
    pParArray->Parameters[1].Length = sizeof(UNICODE_STRING) +
                                      pusStrArray[0].MaximumLength;
    pParArray->Parameters[1].Data[0] = 0;
    pParArray->Parameters[1].Data[1] = 0;
    pParArray->Parameters[1].Address = (PVOID) &pusStrArray[0];

    for (i = 0; i < dwParamCnt; i++) {

        pusStrArray[i+1].Length = wcslen(ppszArgArray[i]) * sizeof(WCHAR);
        pusStrArray[i+1].MaximumLength = pusStrArray[i+1].Length + sizeof(WCHAR);
        pusStrArray[i+1].Buffer = (LPWSTR) ppszArgArray[i];

        pParArray->Parameters[i+2].Type = SeAdtParmTypeString;
        pParArray->Parameters[i+2].Length = sizeof(UNICODE_STRING) +
                                            pusStrArray[i+1].MaximumLength;
        pParArray->Parameters[i+2].Data[0] = 0;
        pParArray->Parameters[i+2].Data[1] = 0;
        pParArray->Parameters[i+2].Address = (PVOID) &pusStrArray[i+1];

    }

    if (bDoAudit) {
        ntStatus = LsaIWriteAuditEvent(pParArray, 0);
    }

    return (ERROR_SUCCESS);
}


VOID
AuditEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR * ppszArguments,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    DWORD dwError = 0;
    LPWSTR pszArgArray[3];
    DWORD dwParamCnt = 0;


    EnterCriticalSection(&gcSPDAuditSection);

    dwError = FormatMessage(
                  FORMAT_MESSAGE_FROM_HMODULE |
                  FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  ghIpsecServerModule,
                  dwStrId,
                  LANG_NEUTRAL,
                  gpszAuditMsgBuffer,
                  MAX_MSG_BUFFER,
                  (va_list *) ppszArguments
                  );
    if (dwError == 0) {
        wsprintf(
            gpszAuditMsgBuffer,
            L"IPSec Services encountered an error while auditing event ID 0x%x",
            dwStrId
            );
    }

    gpszAuditMsgBuffer[MAX_MSG_BUFFER - 1] = 0;

    if (dwError != 0) {

       switch (dwAuditId) {

       case SE_AUDITID_IPSEC_POLICY_CHANGED:
           dwParamCnt = 1;
           pszArgArray[0] = (LPWSTR) gpszAuditMsgBuffer;
           break;

       default:
           LeaveCriticalSection(&gcSPDAuditSection);
           return;

       }

       (VOID) PerformAudit(
                  dwCategoryId,
                  dwAuditId,
                  gpIpsecServerSid,
                  dwParamCnt,
                  (LPWSTR *) pszArgArray,
                  bSuccess,
                  bDoAudit
                  );

    }

    LeaveCriticalSection(&gcSPDAuditSection);
    return;
}


VOID
AuditOneArgErrorEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    DWORD dwErrorCode,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    DWORD dwError = 0;
    LPVOID lpvMsgBuf = NULL;
    WCHAR szAuditLocalMsgBuffer[MAX_PATH];
    WCHAR * pszAuditLocalMsgBuffer = szAuditLocalMsgBuffer;


    szAuditLocalMsgBuffer[0] = L'\0';

    dwError = FormatMessage(
                  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_IGNORE_INSERTS,
                  NULL,
                  dwErrorCode,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPWSTR) &lpvMsgBuf,
                  0,
                  NULL
                  );
    if (!dwError) {
        wsprintf(
            pszAuditLocalMsgBuffer,
            L"0x%x",
            dwErrorCode
            );
        AuditEvent(
            dwCategoryId,
            dwAuditId,
            dwStrId,
            (LPWSTR *) &pszAuditLocalMsgBuffer,
            bSuccess,
            bDoAudit
            );
        return;
    }

    AuditEvent(
        dwCategoryId,
        dwAuditId,
        dwStrId,
        (LPWSTR *) &lpvMsgBuf,
        bSuccess,
        bDoAudit
        );

    if (lpvMsgBuf) {
        LocalFree(lpvMsgBuf);
    }

    return;
}


VOID
AuditIPSecPolicyEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR pszPolicyName,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    WCHAR szAuditLocalMsgBuffer[MAX_PATH];
    WCHAR * pszAuditLocalMsgBuffer = szAuditLocalMsgBuffer;


    szAuditLocalMsgBuffer[0] = L'\0';

    wsprintf(pszAuditLocalMsgBuffer, L"%s", pszPolicyName);

    AuditEvent(
        dwCategoryId,
        dwAuditId,
        dwStrId,
        (LPWSTR *) &pszAuditLocalMsgBuffer,
        bSuccess,
        bDoAudit
        );

    return;
}


VOID
AuditIPSecPolicyErrorEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR pszPolicyName,
    DWORD dwErrorCode,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    DWORD dwError = 0;
    WCHAR szAuditPolicyMsgBuffer[MAX_PATH];
    WCHAR * pszAuditPolicyMsgBuffer = szAuditPolicyMsgBuffer;
    WCHAR szAuditErrorMsgBuffer[MAX_PATH];
    WCHAR * pszAuditErrorMsgBuffer = szAuditErrorMsgBuffer;
    LPWSTR pszArgArray[2];
    LPWSTR * ppszArgArray = pszArgArray;
    LPVOID lpvMsgBuf = NULL;


    szAuditPolicyMsgBuffer[0] = L'\0';
    szAuditErrorMsgBuffer[0] = L'\0';

    wsprintf(pszAuditPolicyMsgBuffer, L"%s", pszPolicyName);

    dwError = FormatMessage(
                  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_IGNORE_INSERTS,
                  NULL,
                  dwErrorCode,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPWSTR) &lpvMsgBuf,
                  0,
                  NULL
                  );
    if (!dwError) {
        wsprintf(
            pszAuditErrorMsgBuffer,
            L"0x%x",
            dwErrorCode
            );
        pszArgArray[0] = pszAuditPolicyMsgBuffer;
        pszArgArray[1] = pszAuditErrorMsgBuffer;
        AuditEvent(
            dwCategoryId,
            dwAuditId,
            dwStrId,
            (LPWSTR *) ppszArgArray,
            bSuccess,
            bDoAudit
            );
        return;
    }

    pszArgArray[0] = pszAuditPolicyMsgBuffer;
    pszArgArray[1] = (LPWSTR) lpvMsgBuf;
    AuditEvent(
        dwCategoryId,
        dwAuditId,
        dwStrId,
        (LPWSTR *) ppszArgArray,
        bSuccess,
        bDoAudit
        );

    if (lpvMsgBuf) {
        LocalFree(lpvMsgBuf);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\externs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    externs.h

Abstract:

    Holds externs for global variables.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


extern  BOOL                        gbSPDRPCServerUp;

extern  HANDLE                      ghServiceStopEvent;

extern  CRITICAL_SECTION            gcServerListenSection;

extern  DWORD                       gdwServersListening;

extern  BOOL                        gbServerListenSection;

extern PIPSEC_INTERFACE             gpInterfaceList;

extern BOOL                         gbwsaStarted;

extern SOCKET                       gIfChangeEventSocket;

extern HANDLE                       ghIfChangeEvent;

extern HANDLE                       ghOverlapEvent;

extern WSAOVERLAPPED                gwsaOverlapped;

extern WSADATA                      gwsaData;


//
// Globals for transport-mode filters - txfilter.c
//

extern PINITXFILTER gpIniTxFilter;

extern PINITXSFILTER gpIniTxSFilter;

extern PTX_FILTER_HANDLE gpTxFilterHandle;

extern CRITICAL_SECTION             gcSPDSection;

extern BOOL                         gbSPDSection;

//
// Globals for quick mode policies - qm-policy.c
//

extern PINIQMPOLICY gpIniQMPolicy;

extern PINIQMPOLICY gpIniDefaultQMPolicy;

//
// Globals for main mode policies - mm-policy.c
//

extern PINIMMPOLICY gpIniMMPolicy;

extern PINIMMPOLICY gpIniDefaultMMPolicy;

//
// Globals for main mode filters - mmfilter.c
//

extern PINIMMFILTER gpIniMMFilter;

extern PINIMMSFILTER gpIniMMSFilter;

extern PMM_FILTER_HANDLE gpMMFilterHandle;

//
// Globals for main mode auth methods - mmauth.c
//

extern PINIMMAUTHMETHODS gpIniMMAuthMethods;

extern PINIMMAUTHMETHODS gpIniDefaultMMAuthMethods;


//
// Policy Agent Store specific globals.
//

extern IPSEC_POLICY_STATE gIpsecPolicyState;

extern PIPSEC_POLICY_STATE gpIpsecPolicyState;

extern DWORD gCurrentPollingInterval;

extern DWORD gDefaultPollingInterval;

extern LPWSTR gpszIpsecDSPolicyKey;

extern LPWSTR gpszIpsecLocalPolicyKey;

extern LPWSTR gpszIpsecCachePolicyKey;

extern LPWSTR gpszDefaultISAKMPPolicyDN;

extern LPWSTR gpszLocPolicyAgent;

extern DWORD gdwDSConnectivityCheck;

extern HANDLE ghNewDSPolicyEvent;

extern HANDLE ghNewLocalPolicyEvent;

extern HANDLE ghForcedPolicyReloadEvent;

extern HANDLE ghPolicyChangeNotifyEvent;

extern BOOL gbLoadedISAKMPDefaults;


//
// PA Store to SPD intergration specific globals.
//

extern PMMPOLICYSTATE gpMMPolicyState;

extern PMMAUTHSTATE gpMMAuthState;

extern PMMFILTERSTATE gpMMFilterState;

extern DWORD gdwMMPolicyCounter;

extern DWORD gdwMMFilterCounter;

extern PQMPOLICYSTATE gpQMPolicyState;

extern DWORD gdwQMPolicyCounter;

extern PTXFILTERSTATE gpTxFilterState;

extern DWORD gdwTxFilterCounter;


//
// Globals for tunnel-mode filters - tnfilter.c
//

extern PINITNFILTER gpIniTnFilter;

extern PINITNSFILTER gpIniTnSFilter;

extern PTN_FILTER_HANDLE gpTnFilterHandle;


extern PTNFILTERSTATE gpTnFilterState;

extern DWORD gdwTnFilterCounter;


extern BOOL gbIsIKEUp;


extern PSECURITY_DESCRIPTOR gpSPDSD;

extern BOOL gbIKENotify;

extern HANDLE ghIPSecDriver;

extern BOOL gbLoadingPersistence;


extern SID gIpsecServerSid;

extern PSID gpIpsecServerSid;

extern CRITICAL_SECTION gcSPDAuditSection;

extern BOOL gbSPDAuditSection;

extern HMODULE ghIpsecServerModule;

extern BOOL gbIsIoctlPended;

extern BOOL gbBackwardSoftSA;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\ikerpc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    ikerpc.c

Abstract:

    This module contains all of the code to service the
    RPC calls made to the SPD that are serviced in IKE.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


VOID
IKENEGOTIATION_HANDLE_rundown(
    IKENEGOTIATION_HANDLE hIKENegotiation
    )
{
    if (!gbIsIKEUp) {
        return;
    }

    if (hIKENegotiation) {
        (VOID) IKECloseIKENegotiationHandle(
                   hIKENegotiation
                   );
    }
}


VOID
IKENOTIFY_HANDLE_rundown(
    IKENOTIFY_HANDLE hIKENotifyHandle
    )
{
    if (!gbIsIKEUp) {
        return;
    }

    if (hIKENotifyHandle) {
        (VOID) IKECloseIKENotifyHandle(
                   hIKENotifyHandle
                   );
    }
}


DWORD
RpcInitiateIKENegotiation(
    STRING_HANDLE pServerName,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    DWORD dwFlags,
    IKENEGOTIATION_HANDLE * phIKENegotiation
    )
{
    DWORD dwError = 0;
    HANDLE hClientEvent = NULL;
    PIPSEC_QM_FILTER pQMFilter = NULL;
    BOOL bImpersonating = FALSE;

    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateInitiateIKENegotiation(pServerName,
                                             pQMFilterContainer,
                                             dwClientProcessId,
                                             uhClientEvent,
                                             dwFlags,
                                             phIKENegotiation);
    BAIL_ON_WIN32_ERROR(dwError);    


    hClientEvent = LongToHandle(uhClientEvent);

    pQMFilter = pQMFilterContainer->pQMFilters;

    dwError = IKEInitiateIKENegotiation(
                  pQMFilter,
                  dwClientProcessId,
                  hClientEvent,
                  dwFlags,
                  phIKENegotiation
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcQueryIKENegotiationStatus(
    IKENEGOTIATION_HANDLE hIKENegotiation,
    SA_NEGOTIATION_STATUS_INFO *NegotiationStatus
    )
{
    DWORD dwError = 0;
    DWORD dwFlags=0;
    BOOL bImpersonating = FALSE;

    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);


    dwError=ValidateQueryIKENegotiationStatus(hIKENegotiation,
                                              NegotiationStatus);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKEQueryIKENegotiationStatus(
                  hIKENegotiation,
                  NegotiationStatus,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcCloseIKENegotiationHandle(
    IKENEGOTIATION_HANDLE * phIKENegotiation
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateCloseIKENegotiationHandle(phIKENegotiation);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKECloseIKENegotiationHandle(
                  *phIKENegotiation
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phIKENegotiation = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumMMSAs(
    STRING_HANDLE pServerName, 
    PMM_SA_CONTAINER pMMTemplate,
    PMM_SA_CONTAINER *ppMMSAContainer,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle,
    DWORD dwFlags
    )
{

    DWORD dwError = 0;
    PIPSEC_MM_SA pMMSAs=NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateEnumMMSAs(pServerName,
                              pMMTemplate,
                              ppMMSAContainer,
                              pdwNumEntries,
                              pdwTotalMMsAvailable,
                              pdwEnumHandle,
                              dwFlags);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError= IKEEnumMMs(
        pMMTemplate->pMMSAs,
        &pMMSAs,
        pdwNumEntries,
        pdwTotalMMsAvailable,
        pdwEnumHandle,
        dwFlags
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    (*ppMMSAContainer)->pMMSAs=pMMSAs;
    (*ppMMSAContainer)->dwNumMMSAs=*pdwNumEntries;

error:
    
    if (dwError != ERROR_SUCCESS) {
        if (ppMMSAContainer && *ppMMSAContainer) {
            (*ppMMSAContainer)->pMMSAs=NULL;
            (*ppMMSAContainer)->dwNumMMSAs=0;
        }
    }
        
    SPDRevertToSelf(bImpersonating);
    return dwError;
}


DWORD
RpcDeleteMMSAs(
    STRING_HANDLE pServerName, 
    PMM_SA_CONTAINER pMMTemplate,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateDeleteMMSAs(pServerName,
                                pMMTemplate,
                                dwFlags);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError= IKEDeleteAssociation(
        pMMTemplate->pMMSAs,
        dwFlags);
    
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return dwError;
}

DWORD
RpcQueryIKEStatistics(
    STRING_HANDLE pServerName, 
    IKE_STATISTICS *pIKEStatistics
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateQueryIKEStatistics(pServerName,
                                       pIKEStatistics);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKEQueryStatistics(pIKEStatistics);

    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return dwError;
}


DWORD
RpcRegisterIKENotifyClient(
    STRING_HANDLE pServerName,    
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    PQM_SA_CONTAINER pQMSATemplateContainer,
    IKENOTIFY_HANDLE *phNotifyHandle,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    HANDLE hClientEvent = LongToHandle(uhClientEvent);
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateRegisterIKENotifyClient(pServerName,
                                    dwClientProcessId,
                                    uhClientEvent,
                                    pQMSATemplateContainer,
                                    phNotifyHandle,
                                    dwFlags);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError= IKERegisterNotifyClient(
        dwClientProcessId,
        hClientEvent,
        *pQMSATemplateContainer->pQMSAs,
        phNotifyHandle);

    BAIL_ON_WIN32_ERROR(dwError);
    
error:

    SPDRevertToSelf(bImpersonating);
    return dwError;
}

DWORD RpcQueryNotifyData(
    IKENOTIFY_HANDLE uhNotifyHandle,
    PDWORD pdwNumEntries,
    PQM_SA_CONTAINER *ppQMSAContainer,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_SA pQMSAs=NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError=ValidateQueryNotifyData(uhNotifyHandle,
                                    pdwNumEntries,
                                    ppQMSAContainer,
                                    dwFlags);
    BAIL_ON_WIN32_ERROR(dwError);        

    dwError= IKEQuerySpiChange(
        uhNotifyHandle,
        pdwNumEntries,
        &pQMSAs);

    if ((dwError == ERROR_SUCCESS) ||
        (dwError == ERROR_MORE_DATA)) {

        (*ppQMSAContainer)->pQMSAs=pQMSAs;
        (*ppQMSAContainer)->dwNumQMSAs=*pdwNumEntries;
        
        SPDRevertToSelf(bImpersonating);
        return dwError;
    }
    
error:
    
    if (ppQMSAContainer && *ppQMSAContainer) {
        (*ppQMSAContainer)->pQMSAs=NULL;    
        (*ppQMSAContainer)->dwNumQMSAs=0;
    }
    if (pdwNumEntries) {
        *pdwNumEntries=0;
    }
    
    SPDRevertToSelf(bImpersonating);
    return dwError;
}

    
DWORD RpcCloseNotifyHandle(
    IKENOTIFY_HANDLE *phHandle
    )
{
    DWORD dwError =0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);    

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateCloseNotifyHandle(phHandle);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKECloseIKENotifyHandle(*phHandle);
    BAIL_ON_WIN32_ERROR(dwError);
    
    *phHandle = NULL;

error:
    
    SPDRevertToSelf(bImpersonating);
    return dwError;
}

DWORD RpcIPSecAddSA(
    STRING_HANDLE pServerName,
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    DWORD *uhLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE *pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *pOutboundKeyMat,
    BYTE *pContextInfo,
    DWORD dwFlags)


{
    DWORD dwError = 0;
    HANDLE hLarvalContext = NULL;
    PIPSEC_QM_FILTER pQMFilter = NULL;
    PIPSEC_QM_OFFER pQMOffer = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateIPSecAddSA(pServerName,
                               pQMPolicyContainer,
                               pQMFilterContainer,
                               uhLarvalContext,
                               dwInboundKeyMatLen,
                               pInboundKeyMat,
                               dwOutboundKeyMatLen,
                               pOutboundKeyMat,
                               pContextInfo,
                               dwFlags);
    BAIL_ON_WIN32_ERROR(dwError);


    hLarvalContext = LongToHandle(*uhLarvalContext);
    pQMFilter = pQMFilterContainer->pQMFilters;
    pQMOffer = pQMPolicyContainer->pPolicies->pOffers;

    dwError=IKEAddSAs(
        pQMOffer,
        pQMFilter,
        &hLarvalContext,
        dwInboundKeyMatLen,
        pInboundKeyMat,
        dwOutboundKeyMatLen,
        pOutboundKeyMat,
        pContextInfo,
        dwFlags);
    
    BAIL_ON_WIN32_ERROR(dwError);

    *uhLarvalContext = HandleToLong(hLarvalContext);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\interface.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    interface.h

Abstract:

    This module contains all of the code prototypes to
    drive the interface list management of IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
CreateInterfaceList(
    OUT PIPSEC_INTERFACE * ppIfListToCreate
    );


VOID
DestroyInterfaceList(
    IN PIPSEC_INTERFACE pIfListToDelete
    );


DWORD
OnInterfaceChangeEvent(
    );


VOID
FormObseleteAndNewIfLists(
    IN     PIPSEC_INTERFACE   pIfList,
    IN OUT PIPSEC_INTERFACE * ppExistingIfList,
    OUT    PIPSEC_INTERFACE * ppObseleteIfList,
    OUT    PIPSEC_INTERFACE * ppNewIfList
    );


VOID
AddToInterfaceList(
    IN  PIPSEC_INTERFACE   pIfListToAppend,
    OUT PIPSEC_INTERFACE * ppOriginalIfList
    );


VOID
MarkInterfaceListSuspect(
    IN  PIPSEC_INTERFACE pExistingIfList
    );


VOID
DeleteObseleteInterfaces(
    IN  OUT PIPSEC_INTERFACE * ppExistingIfList,
    OUT     PIPSEC_INTERFACE * ppObseleteIfList
    );


BOOL
InterfaceExistsInList(
    IN  PIPSEC_INTERFACE   pTestIf,
    IN  PIPSEC_INTERFACE   pExistingIfList,
    OUT PIPSEC_INTERFACE * ppExistingIf
    );


DWORD
GetInterfaceListFromStack(
    OUT PIPSEC_INTERFACE * ppIfList
    );


DWORD
GenerateInterfaces(
    IN  PMIB_IPADDRTABLE   pMibIpAddrTable,
    IN  PMIB_IFTABLE       pMibIfTable,
    OUT PIPSEC_INTERFACE * ppIfList
    );


PMIB_IFROW
GetMibIfRow(
    IN  PMIB_IFTABLE pMibIfTable,
    IN  DWORD        dwIndex
    );


DWORD
CreateNewInterface(
    IN  DWORD              dwInterfaceType,
    IN  ULONG              IpAddress,
    IN  DWORD              dwIndex,
    IN  PMIB_IFROW         pMibIfRow,
    OUT PIPSEC_INTERFACE * ppNewInterface
    );


BOOL
MatchInterfaceType(
    IN DWORD    dwIfListEntryIfType,
    IN IF_TYPE  dwFilterIfType
    );


BOOL
IsLAN(
    IN DWORD dwInterfaceType
    );


BOOL
IsDialUp(
    IN DWORD dwInterfaceType
    );


DWORD
InitializeInterfaceChangeEvent(
    );


DWORD
ResetInterfaceChangeEvent(
    );


VOID
DestroyInterfaceChangeEvent(
    );


HANDLE
GetInterfaceChangeEvent(
    );


BOOL
IsMyAddress(
    IN ULONG            IpAddrToCheck,
    IN ULONG            IpAddrMask,
    IN PIPSEC_INTERFACE pExistingIfList
    );


VOID
PrintInterfaceList(
    IN PIPSEC_INTERFACE pInterfaceList
    );


DWORD
GetMatchingInterfaces(
    IF_TYPE             FilterInterfaceType,
    PIPSEC_INTERFACE    pExistingIfList,
    MATCHING_ADDR    ** ppMatchingAddresses,
    DWORD             * pdwAddrCnt
    );


BOOL
InterfaceAddrIsLocal(
    ULONG            uIpAddr,
    ULONG            uIpAddrMask,
    MATCHING_ADDR  * pLocalAddresses,
    DWORD            dwAddrCnt
    );


VOID
FreeIpsecInterface(
    PIPSEC_INTERFACE pIpsecInterface
    );


DWORD
CopyIpsecInterface(
    PIPSEC_INTERFACE pIpsecIf,
    PIPSEC_INTERFACE_INFO pIpsecInterface
    );


VOID
FreeIpsecInterfaceInfos(
    DWORD dwNumInterfaces,
    PIPSEC_INTERFACE_INFO pIpsecInterfaces
    );


DWORD
GetInterfaceName(
    GUID gInterfaceID,
    LPWSTR * ppszInterfaceName
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\iphlpwrp.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    iphlpwrp.c

Abstract:

    This module contains all of the code to wrap
    the ip public help apis for getting the list of
    active interfaces on a machine.

Author:

    krishnaG

Environment

    User Level: Win32

Revision History:

    abhisheV    30-September-1999

--*/


#include "precomp.h"


DWORD
PaPNPGetIfTable(
    OUT PMIB_IFTABLE * ppMibIfTable
    )
{
    DWORD               dwStatus = 0;
    PMIB_IFTABLE        pIfTable = NULL;
    PMIB_IFTABLE        pMibIfTable = NULL;
    PIP_INTERFACE_INFO  pInterfaceInfo = NULL;
    DWORD               i = 0;
    DWORD               j = 0;
    DWORD               dwNameLen = 0;

    dwStatus =  AllocateAndGetIfTableFromStack(
                    &pIfTable,
                    TRUE,
                    GetProcessHeap(),
                    0,
                    TRUE
                    );
    BAIL_ON_WIN32_ERROR(dwStatus);

    pMibIfTable = (PMIB_IFTABLE) LocalAlloc(
                                     LPTR,
                                     sizeof(DWORD)+
                                     sizeof(MIB_IFROW) *
                                     pIfTable->dwNumEntries
                                     );

    if (!pMibIfTable) {
        dwStatus = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwStatus);
    }

    for (i = 0; i < pIfTable->dwNumEntries; i++) {
        memcpy(&(pMibIfTable->table[i]), &(pIfTable->table[i]), sizeof(MIB_IFROW));
    }
    pMibIfTable->dwNumEntries = pIfTable->dwNumEntries;

    //  Get the corresponding Interface Information structure here.

    dwStatus =  PaPNPGetInterfaceInformation(
                    &pInterfaceInfo
                    );
    BAIL_ON_WIN32_ERROR(dwStatus);

    if (!pInterfaceInfo) {
        dwStatus = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwStatus);
    }

    for (j = 0; j < pMibIfTable->dwNumEntries; j++) {
        for (i = 0; i < (DWORD) pInterfaceInfo->NumAdapters; i++) {
            if (pInterfaceInfo->Adapter[i].Index == pMibIfTable->table[j].dwIndex) {
                dwNameLen = wcslen((LPTSTR) &pInterfaceInfo->Adapter[i].Name);
                wcsncpy(
                    (LPTSTR)&(pMibIfTable->table[j].wszName),
                    (LPTSTR)&(pInterfaceInfo->Adapter[i].Name),
                    dwNameLen
                    );
            }
        }
    }

    *ppMibIfTable = pMibIfTable;

cleanup:

    if (pIfTable) {
        HeapFree(GetProcessHeap(), 0, pIfTable);
    }

    if (pInterfaceInfo) {
        LocalFree(pInterfaceInfo);
    }

    return (dwStatus);

error:

    if (pMibIfTable) {
        LocalFree(pMibIfTable);
    }

    *ppMibIfTable = NULL;

    goto cleanup;
}


DWORD
PaPNPGetInterfaceInformation(
    OUT PIP_INTERFACE_INFO * ppInterfaceInfo
    )
{

    LPBYTE  pBuffer = NULL;
    DWORD   dwBufferSize = 2048;
    DWORD   dwStatus = 0;

    pBuffer = (LPBYTE) LocalAlloc(
                           LPTR,
                           dwBufferSize
                           );

    if (!pBuffer) {
        return (ERROR_OUTOFMEMORY);
    }

    dwStatus = GetInterfaceInfo(
                   (PIP_INTERFACE_INFO) pBuffer,
                   &dwBufferSize
                   );

    if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {

        if (pBuffer) {
            LocalFree(pBuffer);
            pBuffer = NULL;
        }

        pBuffer = (LPBYTE) LocalAlloc(
                               LPTR,
                               dwBufferSize
                               );

        if (!pBuffer) {
            return (ERROR_OUTOFMEMORY);
        }

        dwStatus = GetInterfaceInfo(
                       (PIP_INTERFACE_INFO) pBuffer,
                       &dwBufferSize
                       );

        if (dwStatus) {
            goto error;
        }

    } 
    else if (dwStatus) {
        goto error;
    }

    *ppInterfaceInfo = (PIP_INTERFACE_INFO) pBuffer;

    return (dwStatus);

error:

    if (pBuffer) {
        LocalFree(pBuffer);
    }

    return (dwStatus);
}


VOID
PrintMibIfTable(
    IN PMIB_IFTABLE pMibIfTable
    )
{
    DWORD       dwNumEntries = 0;
    DWORD       i = 0;
    PMIB_IFROW  pMibIfRow = NULL;
    PMIB_IFROW  pCurrentMibIfRow = NULL;

    dwNumEntries = pMibIfTable->dwNumEntries;
    pMibIfRow = &(pMibIfTable->table[0]);

    for (i = 0; i < dwNumEntries; i++) {

        pCurrentMibIfRow = pMibIfRow + i;

        wprintf(L"Name = %s\n", pCurrentMibIfRow->wszName);
        wprintf(L"dwIndex = %d\n", pCurrentMibIfRow->dwIndex);
        printf("Description = %s\n", (pCurrentMibIfRow->bDescr));

    }

    wprintf(L"\n\n");
}



VOID
PrintInterfaceInfo(
    IN PIP_INTERFACE_INFO pInterfaceInfo
    )
{
    DWORD                   dwNumAdapters = 0;
    DWORD                   i = 0;
    PIP_ADAPTER_INDEX_MAP   pAdapterIndexMap = NULL;
    PIP_ADAPTER_INDEX_MAP   pCurrentAdapter = NULL;

    dwNumAdapters =  pInterfaceInfo->NumAdapters;
    pAdapterIndexMap = &(pInterfaceInfo->Adapter[0]);

    for (i = 0; i < dwNumAdapters; i++) {

        pCurrentAdapter = pAdapterIndexMap + i;
        wprintf(
            L"Adapter %d Index %d Name %s\n",
            i,
            pCurrentAdapter->Index,
            pCurrentAdapter->Name
            );

    }
}


VOID
PrintMibAddrTable(
    IN PMIB_IPADDRTABLE pMibAddrTable
    )
{
    DWORD           dwNumEntries = 0;
    DWORD           i = 0;
    PMIB_IPADDRROW  pMibAddrRow = NULL;
    PMIB_IPADDRROW  pCurrentMibAddrRow = NULL;

    dwNumEntries = pMibAddrTable->dwNumEntries;
    pMibAddrRow = &(pMibAddrTable->table[0]);

    for (i = 0; i < dwNumEntries; i++) {

        pCurrentMibAddrRow = pMibAddrRow + i;

        wprintf(L"Address = %s\n", pCurrentMibAddrRow->dwAddr);
        wprintf(L"dwIndex = %d\n", pCurrentMibAddrRow->dwIndex);
        wprintf(L"dwMask = %s\n",  pCurrentMibAddrRow->dwMask);

    }
    wprintf(L"\n\n");
}


DWORD
PaPNPGetIpAddrTable(
    OUT PMIB_IPADDRTABLE * ppMibIpAddrTable
    )
{
    PMIB_IPADDRTABLE    pMibIpAddrTable = NULL;
    DWORD               dwBufferSize = 2048;
    DWORD               dwStatus = 0;
    DWORD               dwNameLen = 0;

    pMibIpAddrTable = (PMIB_IPADDRTABLE) LocalAlloc(
                                             LPTR,
                                             dwBufferSize
                                             );
    if (!pMibIpAddrTable) {
        return (ERROR_OUTOFMEMORY);
    }

    dwStatus = GetIpAddrTable(
                   (PMIB_IPADDRTABLE) pMibIpAddrTable,
                   &dwBufferSize,
                   TRUE
                   );

    if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {

        if (pMibIpAddrTable) {
            LocalFree(pMibIpAddrTable);
            pMibIpAddrTable = NULL;
        }

        pMibIpAddrTable = (PMIB_IPADDRTABLE) LocalAlloc(
                                                 LPTR,
                                                 dwBufferSize
                                                 );
        if (!pMibIpAddrTable) {
            return (ERROR_OUTOFMEMORY);
        }

        dwStatus = GetIpAddrTable(
                       (PMIB_IPADDRTABLE) pMibIpAddrTable,
                       &dwBufferSize,
                       TRUE
                       );
        if (dwStatus) {
            goto error;
        }

    }
    else if (dwStatus) {
        goto error;
    }

    *ppMibIpAddrTable = pMibIpAddrTable;

    return (dwStatus);

error:

    *ppMibIpAddrTable = NULL;

    if (pMibIpAddrTable) {
        LocalFree(pMibIpAddrTable);
    }

    return (dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\globals.c ===
/*++


Copyright (c) 1999 Microsoft Corporation


Module Name:

    globals.c

Abstract:

    Holds global variable declarations.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


BOOL                        gbSPDRPCServerUp = FALSE;

HANDLE                      ghServiceStopEvent = NULL;

CRITICAL_SECTION            gcServerListenSection;

DWORD                       gdwServersListening = 0;

BOOL                        gbServerListenSection = FALSE;

PIPSEC_INTERFACE            gpInterfaceList = NULL;


BOOL                        gbwsaStarted = FALSE;

SOCKET                      gIfChangeEventSocket = INVALID_SOCKET;

HANDLE                      ghIfChangeEvent = NULL;

HANDLE                      ghOverlapEvent = NULL;

WSAOVERLAPPED               gwsaOverlapped;

WSADATA                     gwsaData;


//
// Globals for transport-mode filters - txfilter.c
//

PINITXFILTER gpIniTxFilter = NULL;

PINITXSFILTER gpIniTxSFilter = NULL;

PTX_FILTER_HANDLE gpTxFilterHandle = NULL;

CRITICAL_SECTION            gcSPDSection;

BOOL                        gbSPDSection = FALSE;

//
// Globals for quick mode policies - qm-policy.c
//

PINIQMPOLICY gpIniQMPolicy = NULL;

PINIQMPOLICY gpIniDefaultQMPolicy = NULL;

//
// Globals for main mode policies - mm-policy.c
//

PINIMMPOLICY gpIniMMPolicy = NULL;

PINIMMPOLICY gpIniDefaultMMPolicy = NULL;

//
// Globals for main mode filters - mmfilter.c
//

PINIMMFILTER gpIniMMFilter = NULL;

PINIMMSFILTER gpIniMMSFilter = NULL;

PMM_FILTER_HANDLE gpMMFilterHandle = NULL;

//
// Globals for main mode auth methods - mmauth.c
//

PINIMMAUTHMETHODS gpIniMMAuthMethods = NULL;

PINIMMAUTHMETHODS gpIniDefaultMMAuthMethods = NULL;


//
// Policy Agent Store specific globals.
//

IPSEC_POLICY_STATE gIpsecPolicyState;

PIPSEC_POLICY_STATE gpIpsecPolicyState = &gIpsecPolicyState;

DWORD gCurrentPollingInterval = 0;

DWORD gDefaultPollingInterval = 166*60; // (seconds).

LPWSTR gpszIpsecDSPolicyKey =    L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\GPTIPSECPolicy";

LPWSTR gpszIpsecLocalPolicyKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local";

LPWSTR gpszIpsecCachePolicyKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Cache";

LPWSTR gpszDefaultISAKMPPolicyDN = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local\\ipsecISAKMPPolicy{72385234-70FA-11D1-864C-14A300000000}";

LPWSTR gpszLocPolicyAgent = L"SYSTEM\\CurrentControlSet\\Services\\PolicyAgent";

DWORD gdwDSConnectivityCheck = 0;

HANDLE ghNewDSPolicyEvent = NULL;

HANDLE ghNewLocalPolicyEvent = NULL;

HANDLE ghForcedPolicyReloadEvent = NULL;

HANDLE ghPolicyChangeNotifyEvent = NULL;

BOOL gbLoadedISAKMPDefaults = FALSE;


//
// PA Store to SPD intergration specific globals.
//

PMMPOLICYSTATE gpMMPolicyState = NULL;

PMMAUTHSTATE gpMMAuthState = NULL;

PMMFILTERSTATE gpMMFilterState = NULL;

DWORD gdwMMPolicyCounter = 0;

DWORD gdwMMFilterCounter = 0;

PQMPOLICYSTATE gpQMPolicyState = NULL;

DWORD gdwQMPolicyCounter = 0;

PTXFILTERSTATE gpTxFilterState = NULL;

DWORD gdwTxFilterCounter = 0;


//
// Globals for tunnel-mode filters - tnfilter.c
//

PINITNFILTER gpIniTnFilter = NULL;

PINITNSFILTER gpIniTnSFilter = NULL;

PTN_FILTER_HANDLE gpTnFilterHandle = NULL;


PTNFILTERSTATE gpTnFilterState = NULL;

DWORD gdwTnFilterCounter = 0;

BOOL gbIsIKEUp = FALSE;

PSECURITY_DESCRIPTOR gpSPDSD = NULL;

BOOL gbIKENotify = FALSE;

HANDLE ghIPSecDriver = INVALID_HANDLE_VALUE;

BOOL gbLoadingPersistence = FALSE;


SID gIpsecServerSid = { SID_REVISION,
                        1,
                        SECURITY_NT_AUTHORITY,
                        SECURITY_NETWORK_SERVICE_RID
                      };

PSID gpIpsecServerSid = &gIpsecServerSid;

CRITICAL_SECTION gcSPDAuditSection;

BOOL gbSPDAuditSection = FALSE;

HMODULE ghIpsecServerModule = NULL;

BOOL gbIsIoctlPended = FALSE;

BOOL gbBackwardSoftSA = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\interface.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    interface.c

Abstract:

    This module contains all of the code to drive
    the interface list management of IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
CreateInterfaceList(
    OUT PIPSEC_INTERFACE * ppIfListToCreate
    )
{
    DWORD            dwError = 0;
    PIPSEC_INTERFACE pIfList = NULL;


    dwError = GetInterfaceListFromStack(
                  &pIfList
                  );

    ENTER_SPD_SECTION();

    *ppIfListToCreate = pIfList;

    LEAVE_SPD_SECTION();

    return (dwError);
}


VOID
DestroyInterfaceList(
    IN PIPSEC_INTERFACE pIfListToDelete
    )
{
    PIPSEC_INTERFACE pIf = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;

    pIf = pIfListToDelete;

    while (pIf) {
        pTempIf = pIf;
        pIf = pIf->pNext;
        FreeIpsecInterface(pTempIf);
    }
}


DWORD
OnInterfaceChangeEvent(
    )
{
    DWORD            dwError = 0;
    PIPSEC_INTERFACE pIfList = NULL;
    PIPSEC_INTERFACE pObseleteIfList = NULL;
    PIPSEC_INTERFACE pNewIfList = NULL;
    PIPSEC_INTERFACE pExistingIfList = NULL;
    DWORD dwMMError = 0;
    DWORD dwTxError = 0;
    DWORD dwTnError = 0;


    dwError = ResetInterfaceChangeEvent();

    (VOID) GetInterfaceListFromStack(
               &pIfList
               );

    ENTER_SPD_SECTION();

    pExistingIfList = gpInterfaceList;

    // Interface List from Stack can be NULL.

    FormObseleteAndNewIfLists(
        pIfList,
        &pExistingIfList,
        &pObseleteIfList,
        &pNewIfList
        );

    if (pNewIfList) {
        AddToInterfaceList(
            pNewIfList,
            &pExistingIfList
            );
    }

    if (pObseleteIfList) {
        DestroyInterfaceList(
            pObseleteIfList
            );
    }

    gpInterfaceList = pExistingIfList;

    (VOID) ApplyIfChangeToIniMMFilters(
               &dwMMError,
               pExistingIfList
               );

    (VOID) ApplyIfChangeToIniTxFilters(
               &dwTxError,
               pExistingIfList
               );

    (VOID) ApplyIfChangeToIniTnFilters(
               &dwTnError,
               pExistingIfList
               );

    LEAVE_SPD_SECTION();

    if (dwMMError || dwTxError || dwTnError) {
        AuditEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_FAILED_PNP_FILTER_PROCESSING,
            NULL,
            FALSE,
            TRUE
            );
    }

    return (dwError);
}


VOID
FormObseleteAndNewIfLists(
    IN     PIPSEC_INTERFACE   pIfList,
    IN OUT PIPSEC_INTERFACE * ppExistingIfList,
    OUT    PIPSEC_INTERFACE * ppObseleteIfList,
    OUT    PIPSEC_INTERFACE * ppNewIfList
    )
{
    PIPSEC_INTERFACE pObseleteIfList = NULL;
    PIPSEC_INTERFACE pNewIfList = NULL;
    PIPSEC_INTERFACE pIf = NULL;
    PIPSEC_INTERFACE pNewIf = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;
    BOOL             bInterfaceExists = FALSE;
    PIPSEC_INTERFACE pExistingIf = NULL;
    PIPSEC_INTERFACE pExistingIfList = NULL;

    pExistingIfList = *ppExistingIfList;

    MarkInterfaceListSuspect(
        pExistingIfList
        );

    pIf = pIfList;

    while (pIf) {

        bInterfaceExists = InterfaceExistsInList(
                               pIf,
                               pExistingIfList,
                               &pExistingIf
                               );

        if (bInterfaceExists) {

            // Interface already exists in the list.
            // Delete the interface.

            pTempIf = pIf;
            pIf = pIf->pNext;
            FreeIpsecInterface(pTempIf);

            // The corresponding entry in the original interface list
            // is not a suspect any more.

            pExistingIf->bIsASuspect = FALSE;

        }
        else {

            // This is a new interface.
            // Add it to the list of new interfaces.

            pNewIf =  pIf;
            pIf = pIf->pNext;

            pTempIf = pNewIfList;
            pNewIfList = pNewIf;
            pNewIfList->pNext = pTempIf;

        }

    }

    DeleteObseleteInterfaces(
        &pExistingIfList,
        &pObseleteIfList
        );

    *ppExistingIfList = pExistingIfList;
    *ppObseleteIfList = pObseleteIfList;
    *ppNewIfList = pNewIfList;
}


VOID
AddToInterfaceList(
    IN  PIPSEC_INTERFACE   pIfListToAppend,
    OUT PIPSEC_INTERFACE * ppOriginalIfList
    )
{
    PIPSEC_INTERFACE pIf = NULL;
    PIPSEC_INTERFACE pIfToAppend = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;

    pIf = pIfListToAppend;

    while (pIf) {

        pIfToAppend = pIf;
        pIf = pIf->pNext;
        
        pTempIf = *ppOriginalIfList;
        *ppOriginalIfList = pIfToAppend;
        (*ppOriginalIfList)->pNext = pTempIf;

    }
}


VOID
MarkInterfaceListSuspect(
    IN  PIPSEC_INTERFACE pExistingIfList
    )
{
    PIPSEC_INTERFACE pIf = NULL;

    pIf = pExistingIfList;

    while (pIf) {
        pIf->bIsASuspect = TRUE;
        pIf = pIf->pNext;
    }
}


VOID
DeleteObseleteInterfaces(
    IN  OUT PIPSEC_INTERFACE * ppExistingIfList,
    OUT     PIPSEC_INTERFACE * ppObseleteIfList
    )
{
    PIPSEC_INTERFACE pCurIf = NULL;
    PIPSEC_INTERFACE pPreIf = NULL;
    PIPSEC_INTERFACE pStartIf = NULL;
    PIPSEC_INTERFACE pObseleteIfList = NULL;
    PIPSEC_INTERFACE pObseleteIf = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;

    pCurIf = *ppExistingIfList;
    pStartIf = pCurIf;

    while (pCurIf) {

        if (pCurIf->bIsASuspect) {

            pObseleteIf = pCurIf;
            pCurIf = pCurIf->pNext;

            if (pPreIf) {
                pPreIf->pNext = pCurIf;
            }
            else {
                pStartIf = pCurIf;
            }

            pTempIf = pObseleteIfList;
            pObseleteIfList = pObseleteIf;
            pObseleteIfList->pNext = pTempIf;

        }
        else {

            pPreIf = pCurIf;
            pCurIf = pCurIf->pNext;

        }

    }

    *ppObseleteIfList = pObseleteIfList;
    *ppExistingIfList = pStartIf;
}


BOOL
InterfaceExistsInList(
    IN  PIPSEC_INTERFACE   pTestIf,
    IN  PIPSEC_INTERFACE   pExistingIfList,
    OUT PIPSEC_INTERFACE * ppExistingIf
    )
{
    PIPSEC_INTERFACE pIf = NULL;
    PIPSEC_INTERFACE pExistingIf = NULL;
    BOOL             bIfExists = FALSE;

    pIf = pExistingIfList;

    while (pIf) {

        if ((pIf->dwIndex == pTestIf->dwIndex) &&
            (pIf->IpAddress == pTestIf->IpAddress)) {

            bIfExists = TRUE;
            pExistingIf = pIf;

            break;

        }

        pIf = pIf->pNext;

    }

    *ppExistingIf = pExistingIf;
    return (bIfExists);
}


DWORD
GetInterfaceListFromStack(
    OUT PIPSEC_INTERFACE *ppIfList
    )
{
    DWORD            dwError = 0;
    PMIB_IPADDRTABLE pMibIpAddrTable = NULL;
    PMIB_IFTABLE     pMibIfTable = NULL;
    PIPSEC_INTERFACE pIfList = NULL;

    dwError = PaPNPGetIpAddrTable(
                  &pMibIpAddrTable
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = PaPNPGetIfTable(
                  &pMibIfTable
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GenerateInterfaces(
                  pMibIpAddrTable,
                  pMibIfTable,
                  &pIfList
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    
    *ppIfList = pIfList;

cleanup:

    if (pMibIfTable) {
        LocalFree(pMibIfTable);
    }

    if (pMibIpAddrTable) {
        LocalFree(pMibIpAddrTable);
    }

    return (dwError);

error:

    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        IPSECSVC_INTERFACE_LIST_INCOMPLETE,
        NULL,
        FALSE,
        TRUE
        );
    *ppIfList = NULL;
    goto cleanup;
}


DWORD
GenerateInterfaces(
    IN  PMIB_IPADDRTABLE   pMibIpAddrTable,
    IN  PMIB_IFTABLE       pMibIfTable,
    OUT PIPSEC_INTERFACE * ppIfList
    )
{
    DWORD            dwError = 0;
    DWORD            dwInterfaceType = 0;
    ULONG            IpAddress = 0;
    DWORD            dwIndex = 0;
    DWORD            dwNumEntries = 0;
    DWORD            dwCnt = 0;
    PMIB_IFROW       pMibIfRow = NULL;
    PIPSEC_INTERFACE pNewIf = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;
    PIPSEC_INTERFACE pIfList = NULL;
    DWORD            dwNewIfsCnt = 0;

    dwNumEntries = pMibIpAddrTable->dwNumEntries;

    for (dwCnt = 0; dwCnt < dwNumEntries; dwCnt++) {

        dwIndex = pMibIpAddrTable->table[dwCnt].dwIndex;

        pMibIfRow = GetMibIfRow(
                        pMibIfTable,
                        dwIndex
                        );
        if (!pMibIfRow) {
            continue;
        }

        IpAddress = pMibIpAddrTable->table[dwCnt].dwAddr;
        dwInterfaceType = pMibIfRow->dwType;

        dwError = CreateNewInterface(
                      dwInterfaceType,
                      IpAddress,
                      dwIndex,
                      pMibIfRow,
                      &pNewIf
                      );
        if (dwError) {
            continue;
        }

        pTempIf = pIfList;
        pIfList = pNewIf;
        pIfList->pNext = pTempIf;
        dwNewIfsCnt++;

    }

    if (dwNewIfsCnt) {
        *ppIfList = pIfList;
        dwError = ERROR_SUCCESS;
    }
    else {
        *ppIfList = NULL;
        dwError = ERROR_INVALID_DATA;
    }

    return (dwError);
}


PMIB_IFROW
GetMibIfRow(
    IN  PMIB_IFTABLE pMibIfTable,
    IN  DWORD        dwIndex
    )
{
    DWORD      i = 0;
    PMIB_IFROW pMibIfRow = NULL;

    for (i = 0; i < pMibIfTable->dwNumEntries; i++) {

        if (pMibIfTable->table[i].dwIndex == dwIndex) {
            pMibIfRow = &(pMibIfTable->table[i]);
            break;
        }

    }

    return (pMibIfRow);
}


DWORD
CreateNewInterface(
    IN  DWORD              dwInterfaceType,
    IN  ULONG              IpAddress,
    IN  DWORD              dwIndex,
    IN  PMIB_IFROW         pMibIfRow,
    OUT PIPSEC_INTERFACE * ppNewInterface
    )
{
    DWORD            dwError =  0;
    PIPSEC_INTERFACE pNewInterface = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pszTemp = NULL;
    WCHAR szDeviceName[MAXLEN_IFDESCR*sizeof(WCHAR)];
    GUID gInterfaceID;

    
    szDeviceName[0] = L'\0';

    if (IpAddress == INADDR_ANY) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        if (dwInterfaceType == MIB_IF_TYPE_LOOPBACK) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pszString = AllocSPDStr(pMibIfRow->wszName);
    if (!pszString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (wcslen(pszString) <= wcslen(L"\\DEVICE\\TCPIP_")) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pszString + wcslen(L"\\DEVICE\\TCPIP_");

    wGUIDFromString(pszTemp, &gInterfaceID);

    pNewInterface = (PIPSEC_INTERFACE) AllocSPDMem(
                                           sizeof(IPSEC_INTERFACE)
                                           );
    if (!pNewInterface) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewInterface->dwInterfaceType = dwInterfaceType;
    pNewInterface->IpAddress = IpAddress;
    pNewInterface->dwIndex = dwIndex;
    pNewInterface->bIsASuspect = FALSE;

    memcpy(
        &pNewInterface->gInterfaceID,
        &gInterfaceID,
        sizeof(GUID)
        );

    pNewInterface->pszInterfaceName = NULL;

    mbstowcs(
        szDeviceName,
        pMibIfRow->bDescr,
        MAXLEN_IFDESCR
        );

    pNewInterface->pszDeviceName = AllocSPDStr(
                                       szDeviceName
                                       );
    if (!pNewInterface->pszDeviceName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewInterface->pNext = NULL;

    *ppNewInterface = pNewInterface;

cleanup:

    if (pszString) {
        FreeSPDStr(pszString);
    }

    return(dwError);

error:

    *ppNewInterface = NULL;

    if (pNewInterface) {
        FreeIpsecInterface(pNewInterface);
    }

    goto cleanup;
}


BOOL
MatchInterfaceType(
    IN DWORD    dwIfListEntryIfType,
    IN IF_TYPE  FilterIfType
    )
{
    BOOL bMatchesType = FALSE;

    if (FilterIfType == INTERFACE_TYPE_ALL) {
        bMatchesType = TRUE;
    }
    else if (FilterIfType == INTERFACE_TYPE_LAN) {
        bMatchesType = IsLAN(dwIfListEntryIfType);
    }
    else if (FilterIfType == INTERFACE_TYPE_DIALUP) {
        bMatchesType = IsDialUp(dwIfListEntryIfType);
    }

    return (bMatchesType);
}


BOOL
IsLAN(
    IN DWORD dwInterfaceType
    )
{
    BOOL bIsLAN = FALSE;

    if ((dwInterfaceType == MIB_IF_TYPE_ETHERNET) ||
        (dwInterfaceType == MIB_IF_TYPE_FDDI) ||
        (dwInterfaceType == MIB_IF_TYPE_TOKENRING)) {
        bIsLAN = TRUE;
    }

    return (bIsLAN);
}


BOOL
IsDialUp(
    IN DWORD dwInterfaceType
    )
{
    BOOL bIsDialUp = FALSE;

    if ((dwInterfaceType == MIB_IF_TYPE_PPP) ||
        (dwInterfaceType == MIB_IF_TYPE_SLIP)) {
        bIsDialUp = TRUE;
    }

    return (bIsDialUp);
}


DWORD
InitializeInterfaceChangeEvent(
    )
{
    DWORD   dwError = 0;
    WORD    wsaVersion = MAKEWORD(2,0);

    memset(&gwsaOverlapped, 0, sizeof(WSAOVERLAPPED));

    // Start up WinSock.

    dwError = WSAStartup(
                  wsaVersion,
                  &gwsaData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    gbwsaStarted = TRUE;

    if ((LOBYTE(gwsaData.wVersion) != LOBYTE(wsaVersion)) ||
        (HIBYTE(gwsaData.wVersion) != HIBYTE(wsaVersion))) {
        dwError = WSAVERNOTSUPPORTED; 
        BAIL_ON_WIN32_ERROR(dwError);
    }

    // Set up the Socket.

    gIfChangeEventSocket = WSASocket(
                               AF_INET,
                               SOCK_DGRAM,
                               0,
                               NULL,
                               0,
                               WSA_FLAG_OVERLAPPED
                               );
    if (gIfChangeEventSocket == INVALID_SOCKET) {
        dwError = WSAGetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghIfChangeEvent = WSACreateEvent();
    if (ghIfChangeEvent == WSA_INVALID_EVENT) {
        dwError = WSAGetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghOverlapEvent = WSACreateEvent();
    if (ghOverlapEvent == WSA_INVALID_EVENT) {
        dwError = WSAGetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }
    gwsaOverlapped.hEvent = ghOverlapEvent;

error:

    return (dwError);
}


DWORD
ResetInterfaceChangeEvent(
    )
{
    DWORD dwError = 0;
    LONG  lNetworkEvents = FD_ADDRESS_LIST_CHANGE;
    DWORD dwOutSize = 0;

    ResetEvent(ghIfChangeEvent);
    gbIsIoctlPended = FALSE;

    dwError = WSAIoctl(
                  gIfChangeEventSocket,
                  SIO_ADDRESS_LIST_CHANGE,
                  NULL,
                  0,
                  NULL,
                  0,
                  &dwOutSize,
                  &gwsaOverlapped,
                  NULL
                  );

    if (dwError == SOCKET_ERROR) {
        dwError = WSAGetLastError();
        if (dwError != ERROR_IO_PENDING) {
            return (dwError);
        }
        else {
            gbIsIoctlPended = TRUE;
        }
    }

    dwError = WSAEventSelect(
                  gIfChangeEventSocket,
                  ghIfChangeEvent,
                  lNetworkEvents
                  );

    return (dwError);
}


VOID
DestroyInterfaceChangeEvent(
    )
{
    DWORD dwStatus = 0;
    BOOL bDoneWaiting = FALSE;


    if (gIfChangeEventSocket) {
        if (gbIsIoctlPended) {
            CancelIo((HANDLE) gIfChangeEventSocket);
            while (!bDoneWaiting) {
                dwStatus = WaitForSingleObject(
                               ghOverlapEvent,
                               1000
                               );
                switch (dwStatus) {
                case WAIT_OBJECT_0:
                    bDoneWaiting = TRUE;
                    break;
                case WAIT_TIMEOUT:
                    ASSERT(FALSE);
                    break;
                default:
                    bDoneWaiting = TRUE;
                    ASSERT(FALSE);
                    break;
                }
            }
        }
        closesocket(gIfChangeEventSocket);
    }

    if (ghIfChangeEvent) {
        CloseHandle(ghIfChangeEvent);
    }

    if (ghOverlapEvent) {
        CloseHandle(ghOverlapEvent);
    }

    if (gbwsaStarted) {
        WSACleanup();
    }
}


HANDLE
GetInterfaceChangeEvent(
    )
{
    return ghOverlapEvent;
}


BOOL
IsMyAddress(
    IN ULONG            IpAddrToCheck,
    IN ULONG            IpAddrMask,
    IN PIPSEC_INTERFACE pExistingIfList
    )
{
    BOOL bIsMyAddress = FALSE;
    PIPSEC_INTERFACE pIf = NULL;

    pIf = pExistingIfList;

    while (pIf) {

        if ((pIf->IpAddress & IpAddrMask) ==
            (IpAddrToCheck & IpAddrMask)) {

            bIsMyAddress = TRUE;
            break;

        }

        pIf = pIf->pNext;

    }

    return (bIsMyAddress);
}


VOID
PrintInterfaceList(
    IN PIPSEC_INTERFACE pInterfaceList
    )
{
    WCHAR            PrintData[256];
    PIPSEC_INTERFACE pInterface = NULL;
    DWORD            i = 0;

    pInterface = pInterfaceList;

    while (pInterface) {
        
        wsprintf(PrintData, L"Interface Entry no. %d\n", i+1);
        OutputDebugString((LPCTSTR) PrintData);

        wsprintf(PrintData, L"\tInterface Type:  %d\n", pInterface->dwInterfaceType);
        OutputDebugString((LPCTSTR) PrintData);

        wsprintf(PrintData, L"\tIP Address:  %s\n", pInterface->IpAddress);
        OutputDebugString((LPCTSTR) PrintData);

        wsprintf(PrintData, L"\tIndex:  %d\n", pInterface->dwIndex);
        OutputDebugString((LPCTSTR) PrintData);

        wsprintf(PrintData, L"\tIs a suspect:  %d\n", pInterface->bIsASuspect);
        OutputDebugString((LPCTSTR) PrintData);

        i++;
        pInterface = pInterface->pNext;

    }
}


DWORD
GetMatchingInterfaces(
    IF_TYPE             FilterInterfaceType,
    PIPSEC_INTERFACE    pExistingIfList,
    MATCHING_ADDR    ** ppMatchingAddresses,
    DWORD             * pdwAddrCnt
    )
{
    DWORD               dwError = 0;
    MATCHING_ADDR     * pMatchingAddresses = NULL;
    PIPSEC_INTERFACE    pTempIf = NULL;
    BOOL                bMatches = FALSE;
    DWORD               dwCnt = 0;
    DWORD               i = 0;

    pTempIf = pExistingIfList;
    while (pTempIf) {

        bMatches = MatchInterfaceType(
                       pTempIf->dwInterfaceType,
                       FilterInterfaceType
                       );
        if (bMatches) {
            dwCnt++;
        }
        pTempIf = pTempIf->pNext;

    }        

    if (!dwCnt) {
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    dwError = AllocateSPDMemory(
                  sizeof(MATCHING_ADDR) * dwCnt,
                  (LPVOID *) &pMatchingAddresses
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTempIf = pExistingIfList;
    while (pTempIf) {

        bMatches = MatchInterfaceType(
                       pTempIf->dwInterfaceType,
                       FilterInterfaceType
                       );
        if (bMatches) {
            pMatchingAddresses[i].uIpAddr = pTempIf->IpAddress;
            memcpy(
                &pMatchingAddresses[i].gInterfaceID,
                &pTempIf->gInterfaceID,
                sizeof(GUID)
                );
            i++;
        }
        pTempIf = pTempIf->pNext;

    }

    *ppMatchingAddresses = pMatchingAddresses;
    *pdwAddrCnt = i;
    return (dwError);

success:
error:

    *ppMatchingAddresses = NULL;
    *pdwAddrCnt = 0;
    return (dwError);
}


BOOL
InterfaceAddrIsLocal(
    ULONG            uIpAddr,
    ULONG            uIpAddrMask,
    MATCHING_ADDR  * pLocalAddresses,
    DWORD            dwAddrCnt
    )
{
    BOOL    bIsLocal = FALSE;
    DWORD   i = 0;


    for (i = 0; i < dwAddrCnt; i++) {

        if ((pLocalAddresses[i].uIpAddr & uIpAddrMask) ==
            (uIpAddr & uIpAddrMask)) {

            bIsLocal = TRUE;
            break;

        }

    }

    return (bIsLocal);
}


VOID
FreeIpsecInterface(
    PIPSEC_INTERFACE pIpsecInterface
    )
{
    if (pIpsecInterface) {

        if (pIpsecInterface->pszInterfaceName) {
            FreeSPDStr(pIpsecInterface->pszInterfaceName);
        }

        if (pIpsecInterface->pszDeviceName) {
            FreeSPDStr(pIpsecInterface->pszDeviceName);
        }

        FreeSPDMem(pIpsecInterface);

    }
}


DWORD
EnumIPSecInterfaces(
    LPWSTR pServerName,
    PIPSEC_INTERFACE_INFO pIpsecIfTemplate,
    PIPSEC_INTERFACE_INFO * ppIpsecInterfaces,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumInterfaces,
    LPDWORD pdwNumTotalInterfaces,
    LPDWORD pdwResumeHandle,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    PIPSEC_INTERFACE pIpsecIf = NULL;
    DWORD dwNumTotalInterfaces = 0;
    DWORD i = 0;
    PIPSEC_INTERFACE pTempIf = NULL;
    DWORD dwNumInterfaces = 0;
    PIPSEC_INTERFACE_INFO pIpsecInterfaces = NULL;
    PIPSEC_INTERFACE_INFO pTempInterface = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_INTERFACE_ENUM_COUNT)) {
        dwNumToEnum = MAX_INTERFACE_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIpsecIf = gpInterfaceList;

    for (i = 0; (i < dwResumeHandle) && (pIpsecIf != NULL); i++) {
        dwNumTotalInterfaces++;
        pIpsecIf = pIpsecIf->pNext;
    }

    if (!pIpsecIf) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pTempIf = pIpsecIf;

    while (pTempIf && (dwNumInterfaces < dwNumToEnum)) {
        dwNumTotalInterfaces++;
        dwNumInterfaces++;
        pTempIf = pTempIf->pNext;
    }

    while (pTempIf) {
        dwNumTotalInterfaces++;
        pTempIf = pTempIf->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_INTERFACE_INFO)*dwNumInterfaces,
                  &pIpsecInterfaces
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pTempIf = pIpsecIf;
    pTempInterface = pIpsecInterfaces;

    for (i = 0; i < dwNumInterfaces; i++) {

        dwError = CopyIpsecInterface(
                      pTempIf,
                      pTempInterface
                      );
        BAIL_ON_LOCK_ERROR(dwError);

        pTempIf = pTempIf->pNext;
        pTempInterface++;

    }

    *ppIpsecInterfaces = pIpsecInterfaces;
    *pdwNumInterfaces = dwNumInterfaces;
    *pdwNumTotalInterfaces = dwNumTotalInterfaces;
    *pdwResumeHandle = dwResumeHandle + dwNumInterfaces;

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if (pIpsecInterfaces) {
        FreeIpsecInterfaceInfos(
            i,
            pIpsecInterfaces
            );
    }

    *ppIpsecInterfaces = NULL;
    *pdwNumInterfaces = 0;
    *pdwNumTotalInterfaces = 0;
    *pdwResumeHandle = dwResumeHandle;

    return (dwError);
}


DWORD
CopyIpsecInterface(
    PIPSEC_INTERFACE pIpsecIf,
    PIPSEC_INTERFACE_INFO pIpsecInterface
    )
{
    DWORD dwError = 0;


    memcpy(
        &(pIpsecInterface->gInterfaceID),
        &(pIpsecIf->gInterfaceID),
        sizeof(GUID)
        );

    pIpsecInterface->dwIndex = pIpsecIf->dwIndex;

    if (!(pIpsecIf->pszInterfaceName)) {
        (VOID) GetInterfaceName(
                   pIpsecIf->gInterfaceID,
                   &pIpsecIf->pszInterfaceName
                   );
    }

    if (pIpsecIf->pszInterfaceName) {

        dwError =  SPDApiBufferAllocate(
                       wcslen(pIpsecIf->pszInterfaceName)*sizeof(WCHAR)
                       + sizeof(WCHAR),
                       &(pIpsecInterface->pszInterfaceName)
                       );
        BAIL_ON_WIN32_ERROR(dwError);

        wcscpy(pIpsecInterface->pszInterfaceName, pIpsecIf->pszInterfaceName);

    }

    dwError =  SPDApiBufferAllocate(
                   wcslen(pIpsecIf->pszDeviceName)*sizeof(WCHAR)
                   + sizeof(WCHAR),
                   &(pIpsecInterface->pszDeviceName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(pIpsecInterface->pszDeviceName, pIpsecIf->pszDeviceName);

    pIpsecInterface->dwInterfaceType = pIpsecIf->dwInterfaceType;

    pIpsecInterface->uIpAddr = pIpsecIf->IpAddress;

    return (dwError);

error:

    if (pIpsecInterface->pszInterfaceName) {
        SPDApiBufferFree(pIpsecInterface->pszInterfaceName);
    }

    return (dwError);
}


VOID
FreeIpsecInterfaceInfos(
    DWORD dwNumInterfaces,
    PIPSEC_INTERFACE_INFO pIpsecInterfaces
    )
{
    PIPSEC_INTERFACE_INFO pTempInterface = NULL;
    DWORD i = 0;


    if (!pIpsecInterfaces) {
        return;
    }

    pTempInterface = pIpsecInterfaces;

    for (i = 0; i < dwNumInterfaces; i++) {

        if (pTempInterface->pszInterfaceName) {
            SPDApiBufferFree(pTempInterface->pszInterfaceName);
        }

        if (pTempInterface->pszDeviceName) {
            SPDApiBufferFree(pTempInterface->pszDeviceName);
        }

        pTempInterface++;

    }

    SPDApiBufferFree(pIpsecInterfaces);
}


DWORD
GetInterfaceName(
    GUID gInterfaceID,
    LPWSTR * ppszInterfaceName
    )
{
    DWORD dwError = 0;
    DWORD dwSize = 0;
    WCHAR szInterfaceName[512];


    *ppszInterfaceName = NULL;
    szInterfaceName[0] = L'\0';

    dwSize = sizeof(szInterfaceName)/sizeof(WCHAR);

    dwError = NhGetInterfaceNameFromGuid(
                  &gInterfaceID,
                  szInterfaceName,
                  &dwSize,
                  FALSE,
                  FALSE
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppszInterfaceName = AllocSPDStr(
                            szInterfaceName
                            );

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\init.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    init.h

Abstract:

    This module contains all of the code prototypes
    to initialize the variables for the IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#define IPSEC_NEW_DS_POLICY_EVENT L"IPSEC_POLICY_CHANGE_EVENT"

#define DEFAULT_DS_CONNECTIVITY_CHECK 60 // (minutes).


#ifdef __cplusplus
extern "C" {
#endif


DWORD
InitSPDThruRegistry(
    );


DWORD
InitSPDGlobals(
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    init.h

Abstract:

    This module contains all of the code to
    initialize the variables for the IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


#define SZAPPNAME   L"ipsecsvc.dll"


DWORD
InitSPDThruRegistry(
    )
{
    DWORD dwError = 0;
    HKEY hKey = NULL;
    DWORD dwtype = REG_DWORD;
    DWORD dwsize = sizeof(DWORD);
    DWORD dwBackwardSoftSA = 0;

    dwError = RegOpenKey(
                  HKEY_LOCAL_MACHINE,
                  gpszLocPolicyAgent,
                  &hKey
                  );
    if (dwError) {
        gdwDSConnectivityCheck = DEFAULT_DS_CONNECTIVITY_CHECK;
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    //
    // Get DS connectivity check polling interval in minutes.
    //

    dwError = RegQueryValueEx(
                  hKey,
                  L"DSConnectivityCheck",
                  0,
                  &dwtype,
                  (unsigned char *) &gdwDSConnectivityCheck,
                  &dwsize
                  );
    if (dwError || !gdwDSConnectivityCheck) {
        gdwDSConnectivityCheck = DEFAULT_DS_CONNECTIVITY_CHECK;
        dwError = ERROR_SUCCESS;
    }

	//
    // Fix for bug 628668: SECURITY: ITG: BUG: IPsec accepts unsecured packet when
    // "accept unsecured" not checked.  If OldFallBackToClear == 1, then will revert
    // to old behavior and plumb inbound pass thru if fall back to clear selected.
    // If OldFallBackToClear 0, then will plumb "negotiate security" instead.
    //

    dwsize = sizeof(DWORD);
    dwError = RegQueryValueEx(
                  hKey,
                  L"OldFallBackToClear",
                  0,
                  &dwtype,
                  (unsigned char *) &dwBackwardSoftSA,
                  &dwsize
                  );
    if (dwError) {
        dwBackwardSoftSA = 0;
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

success:
    gbBackwardSoftSA = dwBackwardSoftSA ? TRUE : FALSE;
    
    if (hKey) {
        RegCloseKey(hKey);
    }

    return (dwError);
}


DWORD
InitSPDGlobals(
    )
{
    DWORD dwError = 0;
    SECURITY_ATTRIBUTES SecurityAttributes;


    dwError = InitializeSPDSecurity(&gpSPDSD);
    BAIL_ON_WIN32_ERROR(dwError);

    InitializeCriticalSection(&gcSPDAuditSection);
    gbSPDAuditSection = TRUE;

    ghIpsecServerModule = GetModuleHandle(SZAPPNAME);

    if (!ghIpsecServerModule) {
        dwError = ERROR_INVALID_HANDLE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memset(&SecurityAttributes, 0, sizeof(SECURITY_ATTRIBUTES));

    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = NULL;
    SecurityAttributes.bInheritHandle = TRUE;

    ghNewDSPolicyEvent = CreateEvent(
                             &SecurityAttributes,
                             TRUE,
                             FALSE,
                             IPSEC_NEW_DS_POLICY_EVENT
                             );
    if (!ghNewDSPolicyEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghNewLocalPolicyEvent = CreateEvent(
                                &SecurityAttributes,
                                TRUE,
                                FALSE,
                                NULL
                                );
    if (!ghNewLocalPolicyEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghForcedPolicyReloadEvent = CreateEvent(
                                    &SecurityAttributes,
                                    TRUE,
                                    FALSE,
                                    NULL
                                    );
    if (!ghForcedPolicyReloadEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // IPSEC_POLICY_CHANGE_NOTIFY is defined in ipsec.h.
    // 

    ghPolicyChangeNotifyEvent = CreateEvent(
                                    NULL,
                                    TRUE,
                                    FALSE,
                                    IPSEC_POLICY_CHANGE_NOTIFY
                                    );
    if (!ghPolicyChangeNotifyEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghServiceStopEvent = CreateEvent(
                             &SecurityAttributes,
                             TRUE,
                             FALSE,
                             NULL
                             );
    if (!ghServiceStopEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    InitializeCriticalSection(&gcServerListenSection);

    gbServerListenSection = TRUE;

    gdwServersListening = 0;

    InitializeCriticalSection(&gcSPDSection);

    gbSPDSection = TRUE;

    dwError = InitializeInterfaceChangeEvent();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ResetInterfaceChangeEvent();
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\midluser.c ===
/*++

Copyright (c) 1991 Microsoft Corporation


Module Name:

    midluser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    danl    02/06/1991

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


PVOID
MIDL_user_allocate(
    IN size_t NumBytes
    )
/*++

Routine Description:

    Allocates storage for RPC transactions. The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - the number of bytes to allocate.

Return Value:

    None.

--*/
{
    return (LocalAlloc(0,NumBytes));
}


VOID
MIDL_user_free(
    IN void * MemPointer
    )
/*++

Routine Description:

    Frees storage used in RPC transactions. The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - pointer to the memory block that is to be released.

Return Value:

    None.

--*/

{
    LocalFree(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\loopmgr.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    loopmgr.h

Abstract:

    This module contains all of the code prototypes to drive the
    Loop Manager of IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
ServiceWait(
    );


VOID
ComputeRelativePollingTime(
    time_t LastTimeOutTime,
    BOOL bInitialLoad,
    PDWORD pWaitMilliseconds
    );


VOID
NotifyIpsecPolicyChange(
    );


VOID
SendPschedIoctl(
    );


VOID
PADeleteInUsePolicies(
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\iphlpwrp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    iphlpwrp.h

Abstract:

    This module contains all of the code prototypes to
    wrap the ip public help apis for getting the list of
    active interfaces on a machine.

Author:

    krishnaG

Environment

    User Level: Win32

Revision History:

    abhisheV    30-September-1999

--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
PaPNPGetIfTable(
    OUT PMIB_IFTABLE * ppMibIfTable
    );


DWORD
PaPNPGetInterfaceInformation(
    OUT PIP_INTERFACE_INFO * ppInterfaceInfo
    );


VOID
PrintMibIfTable(
    IN PMIB_IFTABLE pMibIfTable
    );


VOID
PrintInterfaceInfo(
    IN PIP_INTERFACE_INFO pInterfaceInfo
    );


VOID
PrintMibAddrTable(
    IN PMIB_IPADDRTABLE pMibAddrTable
    );


DWORD
PaPNPGetIpAddrTable(
    OUT PMIB_IPADDRTABLE * ppMibIpAddrTable
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\ipsecspd.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    ipsecspd.c

Abstract:

    This module contains all of the code to drive
    the IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


SERVICE_STATUS           IPSecSPDStatus;
SERVICE_STATUS_HANDLE    IPSecSPDStatusHandle = NULL;


#define IPSECSPD_SERVICE        L"PolicyAgent"


void WINAPI
SPDServiceMain(
    IN DWORD    dwArgc,
    IN LPTSTR * lpszArgv
    )
{
    DWORD dwError = 0;


    // Sleep(30000);

    dwError = InitSPDThruRegistry();
    BAIL_ON_WIN32_ERROR(dwError);

    // Initialize all the status fields so that the subsequent calls
    // to SetServiceStatus need to only update fields that changed.

    IPSecSPDStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    IPSecSPDStatus.dwCurrentState = SERVICE_START_PENDING;
    IPSecSPDStatus.dwControlsAccepted = 0;
    IPSecSPDStatus.dwCheckPoint = 1;
    IPSecSPDStatus.dwWaitHint = 5000;
    IPSecSPDStatus.dwWin32ExitCode = NO_ERROR;
    IPSecSPDStatus.dwServiceSpecificExitCode = 0;

    // Initialize the workstation to receive service requests
    // by registering the service control handler.

    IPSecSPDStatusHandle = RegisterServiceCtrlHandlerW(
                                IPSECSPD_SERVICE,
                                IPSecSPDControlHandler
                                );
    if (IPSecSPDStatusHandle == (SERVICE_STATUS_HANDLE) NULL) {
        dwError = ERROR_INVALID_HANDLE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    (void) IPSecSPDUpdateStatus();

    dwError = InitSPDGlobals();
    BAIL_ON_WIN32_ERROR(dwError);

    IPSecSPDStatus.dwCurrentState = SERVICE_RUNNING;
    IPSecSPDStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                        SERVICE_ACCEPT_SHUTDOWN;
    IPSecSPDStatus.dwCheckPoint = 0;
    IPSecSPDStatus.dwWaitHint = 0;
    IPSecSPDStatus.dwWin32ExitCode = NO_ERROR;
    IPSecSPDStatus.dwServiceSpecificExitCode = 0;

    (void) IPSecSPDUpdateStatus();


    //
    // Get the current list of active interfaces on the machine.
    //
    (VOID) CreateInterfaceList(
               &gpInterfaceList
               );

    //
    // Open the IPSec Driver.
    //
    dwError = SPDOpenIPSecDriver(
                  &ghIPSecDriver
                  );
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_DRIVER_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
    }
    BAIL_ON_WIN32_ERROR(dwError);

    (VOID) LoadPersistedIPSecInformation();

    dwError = SPDSetIPSecDriverOpMode(
                  (DWORD) IPSEC_SECURE_MODE
                  );
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_DRIVER_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
    }
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDRegisterIPSecDriverProtocols(
                  (DWORD) IPSEC_REGISTER_PROTOCOLS
                  );
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_DRIVER_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
    }
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Start IKE Service.
    //
    dwError = IKEInit();
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_IKE_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
    }
    BAIL_ON_WIN32_ERROR(dwError);
    gbIsIKEUp = TRUE;
    gbIKENotify = TRUE;

    //
    // Start the RPC Server.
    //
    dwError = SPDStartRPCServer(
                  );
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_RPC_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
    }
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ServiceWait();

error:

    IPSecSPDShutdown(dwError);

    return;
}


DWORD
IPSecSPDUpdateStatus(
    )
{
    DWORD dwError = 0;

    if (!SetServiceStatus(IPSecSPDStatusHandle, &IPSecSPDStatus)) {
        dwError = GetLastError();
    }

    return (dwError);
}


VOID
IPSecSPDControlHandler(
    IN DWORD dwOpCode
    )
{
    switch (dwOpCode)
    {

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        if (IPSecSPDStatus.dwCurrentState != SERVICE_STOP_PENDING) {

            IPSecSPDStatus.dwCurrentState = SERVICE_STOP_PENDING;
            IPSecSPDStatus.dwCheckPoint = 1;
            IPSecSPDStatus.dwWaitHint = 60000;

            (void) IPSecSPDUpdateStatus();

            SetEvent(ghServiceStopEvent);

            return;

        }

        break;

    case SERVICE_CONTROL_NEW_LOCAL_POLICY:

        SetEvent(ghNewLocalPolicyEvent);

        break;

    case SERVICE_CONTROL_FORCED_POLICY_RELOAD:

        SetEvent(ghForcedPolicyReloadEvent);

        break;

    case SERVICE_CONTROL_INTERROGATE:

        break;

    }

    (void) IPSecSPDUpdateStatus();

    return;
}


VOID
IPSecSPDShutdown(
    IN DWORD dwErrorCode
    )
{
    gbIKENotify = FALSE;
    (VOID) DeleteAllPolicyInformation();

    ClearPolicyStateBlock(
        gpIpsecPolicyState
        );

    if (gbLoadedISAKMPDefaults) {
        UnLoadDefaultISAKMPInformation(gpszDefaultISAKMPPolicyDN);
    }

    ClearPAStoreGlobals();

    //
    // Service stop still pending.
    // Increment checkpoint counter and update 
    // the status with the Service Control Manager.
    //

    (IPSecSPDStatus.dwCheckPoint)++;

    (void) IPSecSPDUpdateStatus();

    if (gbSPDRPCServerUp) {
        gbSPDRPCServerUp = FALSE;
        SPDStopRPCServer();
    }

    if (gbIsIKEUp) {
        gbIsIKEUp = FALSE;
        IKEShutdown();
    }

    if (gpIniMMPolicy) {
        FreeIniMMPolicyList(gpIniMMPolicy);
    }

    if (gpIniMMAuthMethods) {
        FreeIniMMAuthMethodsList(gpIniMMAuthMethods);
    }

    if (gpIniQMPolicy) {
        FreeIniQMPolicyList(gpIniQMPolicy);
    }

    if (gpIniMMSFilter) {
        FreeIniMMSFilterList(gpIniMMSFilter);
    }

    if (gpMMFilterHandle) {
        FreeMMFilterHandleList(gpMMFilterHandle);
    }

    if (gpIniMMFilter) {
        FreeIniMMFilterList(gpIniMMFilter);
    }

    if (gpIniTxSFilter) {
        (VOID) DeleteTransportFiltersFromIPSec(gpIniTxSFilter);
        FreeIniTxSFilterList(gpIniTxSFilter);
    }

    if (gpTxFilterHandle) {
        FreeTxFilterHandleList(gpTxFilterHandle);
    }

    if (gpIniTxFilter) {
        FreeIniTxFilterList(gpIniTxFilter);
    }

    if (gpIniTnSFilter) {
        (VOID) DeleteTunnelFiltersFromIPSec(gpIniTnSFilter);
        FreeIniTnSFilterList(gpIniTnSFilter);
    }

    if (gpTnFilterHandle) {
        FreeTnFilterHandleList(gpTnFilterHandle);
    }

    if (gpIniTnFilter) {
        FreeIniTnFilterList(gpIniTnFilter);
    }

    (VOID) SPDRegisterIPSecDriverProtocols(
               (DWORD) IPSEC_DEREGISTER_PROTOCOLS
               );

    if (ghIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(ghIPSecDriver);
    }

    if (gpInterfaceList) {
        DestroyInterfaceList(
            gpInterfaceList
            );
    }

    ClearSPDGlobals();

    IPSecSPDStatus.dwCurrentState = SERVICE_STOPPED;
    IPSecSPDStatus.dwControlsAccepted = 0;
    IPSecSPDStatus.dwCheckPoint = 0;
    IPSecSPDStatus.dwWaitHint = 0;
    IPSecSPDStatus.dwWin32ExitCode = dwErrorCode;
    IPSecSPDStatus.dwServiceSpecificExitCode = 0;

    (void) IPSecSPDUpdateStatus();

    return;
}


VOID
ClearSPDGlobals(
    )
{
    DestroyInterfaceChangeEvent();

    if (gbSPDSection) {
        DeleteCriticalSection(&gcSPDSection);
    }

    if (gbServerListenSection == TRUE) {
        DeleteCriticalSection(&gcServerListenSection);
    }

    if (ghServiceStopEvent) {
        CloseHandle(ghServiceStopEvent);
    }

    if (ghNewDSPolicyEvent) {
        CloseHandle(ghNewDSPolicyEvent);
    }

    if (ghNewLocalPolicyEvent) {
        CloseHandle(ghNewLocalPolicyEvent);
    }

    if (ghForcedPolicyReloadEvent) {
        CloseHandle(ghForcedPolicyReloadEvent);
    }

    if (ghPolicyChangeNotifyEvent) {
        CloseHandle(ghPolicyChangeNotifyEvent);
    }

    if (gbSPDAuditSection) {
        DeleteCriticalSection(&gcSPDAuditSection);
    }

    if (gpSPDSD) {
        LocalFree(gpSPDSD);
    }
}


VOID
ClearPAStoreGlobals(
    )
{
    if (gpMMFilterState) {
        PAFreeMMFilterStateList(gpMMFilterState);
    }

    if (gpMMPolicyState) {
        PAFreeMMPolicyStateList(gpMMPolicyState);
    }

    if (gpMMAuthState) {
        PAFreeMMAuthStateList(gpMMAuthState);
    }

    if (gpTxFilterState) {
        PAFreeTxFilterStateList(gpTxFilterState);
    }

    if (gpTnFilterState) {
        PAFreeTnFilterStateList(gpTnFilterState);
    }

    if (gpQMPolicyState) {
        PAFreeQMPolicyStateList(gpQMPolicyState);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\loopmgr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    loopmgr.c

Abstract:

    This module contains all of the code to drive the
    Loop Manager of IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


enum {
    SERVICE_STOP_EVENT = 0,
    INTERFACE_CHANGE_EVENT,
    NEW_LOCAL_POLICY_EVENT,
    NEW_DS_POLICY_EVENT,
    FORCED_POLICY_RELOAD_EVENT,
    WAIT_EVENT_COUNT,
};


DWORD
ServiceWait(
    )
{
    DWORD dwError = 0;
    HANDLE hWaitForEvents[WAIT_EVENT_COUNT];
    BOOL bDoneWaiting = FALSE;
    DWORD dwWaitMilliseconds = 0;
    DWORD dwStatus = 0;
    time_t LastTimeOutTime = 0;


    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        IPSECSVC_SUCCESSFUL_START,
        NULL,
        TRUE,
        TRUE
        );

    hWaitForEvents[SERVICE_STOP_EVENT] = ghServiceStopEvent;
    hWaitForEvents[INTERFACE_CHANGE_EVENT] = GetInterfaceChangeEvent();
    hWaitForEvents[NEW_LOCAL_POLICY_EVENT] = ghNewLocalPolicyEvent;
    hWaitForEvents[NEW_DS_POLICY_EVENT] = ghNewDSPolicyEvent;
    hWaitForEvents[FORCED_POLICY_RELOAD_EVENT] = ghForcedPolicyReloadEvent;


    //
    // First load the default main mode policy.
    //

    (VOID) LoadDefaultISAKMPInformation(
               gpszDefaultISAKMPPolicyDN
               );


    //
    // Initialize Policy State Block.
    //

    InitializePolicyStateBlock(
        gpIpsecPolicyState
        );


    //
    // Call the Polling Manager for the first time.
    //

    (VOID) StartStatePollingManager(
               gpIpsecPolicyState
               );


    NotifyIpsecPolicyChange();


    ComputeRelativePollingTime(
        LastTimeOutTime,
        TRUE,
        &dwWaitMilliseconds
        );


    time(&LastTimeOutTime);


    while (!bDoneWaiting) {

        dwStatus = WaitForMultipleObjects(
                       WAIT_EVENT_COUNT,
                       hWaitForEvents,
                       FALSE,
                       dwWaitMilliseconds
                       );

        PADeleteInUsePolicies();

        switch (dwStatus) {

        case SERVICE_STOP_EVENT:

            dwError = ERROR_SUCCESS;
            bDoneWaiting = TRUE;
            break;

        case INTERFACE_CHANGE_EVENT:

            (VOID) OnInterfaceChangeEvent(
                       );
            (VOID) IKEInterfaceChange();
            break;

        case NEW_LOCAL_POLICY_EVENT:

            ResetEvent(ghNewLocalPolicyEvent);
            if ((gpIpsecPolicyState->dwCurrentState != POLL_STATE_DS_DOWNLOADED) &&
                (gpIpsecPolicyState->dwCurrentState != POLL_STATE_CACHE_DOWNLOADED)) {
                (VOID) ProcessLocalPolicyPollState(
                           gpIpsecPolicyState
                           );
                NotifyIpsecPolicyChange();
            }
            break;

        case NEW_DS_POLICY_EVENT:

            ResetEvent(ghNewDSPolicyEvent);
            (VOID) OnPolicyChanged(
                       gpIpsecPolicyState
                       );
            NotifyIpsecPolicyChange();
            break;

        case FORCED_POLICY_RELOAD_EVENT:

            ResetEvent(ghForcedPolicyReloadEvent);
            (VOID) OnPolicyChanged(
                       gpIpsecPolicyState
                       );
            NotifyIpsecPolicyChange();
            AuditEvent(
                SE_CATEGID_POLICY_CHANGE,
                SE_AUDITID_IPSEC_POLICY_CHANGED,
                PASTORE_FORCED_POLICY_RELOAD,
                NULL,
                TRUE,
                TRUE
                );
            break;

        case WAIT_TIMEOUT:

            time(&LastTimeOutTime);
            (VOID) OnPolicyPoll(
                       gpIpsecPolicyState
                       );
            break;

        case WAIT_FAILED:

            dwError = GetLastError();
            bDoneWaiting = TRUE;
            break;

        default:

            dwError = ERROR_INVALID_EVENT_COUNT;
            bDoneWaiting = TRUE;
            break;

        }

        ComputeRelativePollingTime(
            LastTimeOutTime,
            FALSE,
            &dwWaitMilliseconds
            );

    }

    if (!dwError) {
        AuditEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_SUCCESSFUL_SHUTDOWN,
            NULL,
            TRUE,
            TRUE
            );
    }
    else {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_ERROR_SHUTDOWN,
            dwError,
            FALSE,
            TRUE
            );
    }

    return (dwError);
}


VOID
ComputeRelativePollingTime(
    time_t LastTimeOutTime,
    BOOL bInitialLoad,
    PDWORD pWaitMilliseconds
    )
{
    DWORD WaitMilliseconds = 0;
    DWORD DSReconnectMilliseconds = 0;
    time_t NextTimeOutTime = 0;
    time_t PresentTime = 0;
    long WaitSeconds = gDefaultPollingInterval;


    WaitMilliseconds = gCurrentPollingInterval * 1000;

    if (!WaitMilliseconds) {
        WaitMilliseconds = INFINITE;
    }

    DSReconnectMilliseconds = gdwDSConnectivityCheck*60*1000;

    if ((gpIpsecPolicyState->dwCurrentState != POLL_STATE_DS_DOWNLOADED) &&
        (gpIpsecPolicyState->dwCurrentState != POLL_STATE_LOCAL_DOWNLOADED)) {
        if (WaitMilliseconds > DSReconnectMilliseconds) {
            WaitMilliseconds = DSReconnectMilliseconds;
        }
    }

    if (!bInitialLoad && WaitMilliseconds != INFINITE) {

        //
        // LastTimeOutTime is the snapshot time value in the past when
        // we timed out waiting for multiple events.
        // Ideally, the time for the next time out, NextTimeOutTime, is
        // the time value in future which is sum of the last time when
        // we timed out + the current waiting time value.
        //

        NextTimeOutTime = LastTimeOutTime + (WaitMilliseconds/1000);

        //
        // However, the last time we may not have timed out waiting
        // for multiple events but rather came out because one of the
        // events other than WAIT_TIMEOUT happened.
        // However, on that event we may not have done a policy
        // poll to figure out whether there was a policy change or
        // not. If we again wait for WaitMilliseconds, then we are
        // un-knowingly making our net time for policy poll greater
        // than the alloted time interval value = WaitMilliseconds.
        // So, we need to adjust the WaitMilliseconds to such a value
        // that no matter what happens, we always do a policy poll
        // atmost every WaitMilliseconds time interval value.
        // The current time is PresentTime.
        //

        time(&PresentTime);

        WaitSeconds = (long) (NextTimeOutTime - PresentTime);

        if (WaitSeconds < 0) {
            WaitMilliseconds = 0;
        }
        else {
            WaitMilliseconds = WaitSeconds * 1000;
        }

    }

    *pWaitMilliseconds = WaitMilliseconds;
}


VOID
NotifyIpsecPolicyChange(
    )
{
    PulseEvent(ghPolicyChangeNotifyEvent);

    SendPschedIoctl();

    ResetEvent(ghPolicyChangeNotifyEvent);

    return;
}


VOID
SendPschedIoctl(
    )
{
    HANDLE hPschedDriverHandle = NULL;
    ULONG uBytesReturned = 0;
    BOOL bIOStatus = FALSE;


    #define DriverName TEXT("\\\\.\\PSCHED")

    #define IOCTL_PSCHED_ZAW_EVENT CTL_CODE( \
                                       FILE_DEVICE_NETWORK, \
                                       20, \
                                       METHOD_BUFFERED, \
                                       FILE_ANY_ACCESS \
                                       )

    hPschedDriverHandle = CreateFile(
                              DriverName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                              NULL
                              );

    if (hPschedDriverHandle != INVALID_HANDLE_VALUE) {

        bIOStatus = DeviceIoControl(
                        hPschedDriverHandle,
                        IOCTL_PSCHED_ZAW_EVENT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &uBytesReturned,
                        NULL
                        );

        CloseHandle(hPschedDriverHandle);

    }
}


VOID
PADeleteInUsePolicies(
    )
{
    DWORD dwError = 0;

    dwError = PADeleteInUseMMPolicies();

    dwError = PADeleteInUseMMAuthMethods();

    dwError = PADeleteInUseQMPolicies();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocSPDMem(
    DWORD cb
);

BOOL
FreeSPDMem(
   LPVOID pMem
);

LPVOID
ReallocSPDMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocSPDStr(
    LPWSTR pStr
);

BOOL
FreeSPDStr(
   LPWSTR pStr
);


BOOL
ReallocSPDStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

DWORD
AllocateSPDMemory(
    DWORD cb,
    LPVOID * ppMem
    );

void
FreeSPDMemory(
    LPVOID pMem
    );

DWORD
AllocateSPDString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    );

void
FreeSPDString(
    LPWSTR pszString
    );


#if DBG

extern LIST_ENTRY SPDMemList ;

extern CRITICAL_SECTION SPDMemCritSect ;

VOID InitSPDMem(
    VOID
    ) ;

VOID AssertSPDMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitSPDMem()
#define AssertSPDMemLeaks()

#define DumpMemoryTracker()



#endif


#ifdef __cplusplus
}
#endif

/*
inline void * _CRTAPI1
operator new(size_t size)
{
    return AllocSPDMem(size);
}

inline void  _CRTAPI1
operator delete(void * pv)
{
    FreeSPDMem(pv);
}*/


#endif // _MEMORY_H_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\ipsecspd.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    ipsecspd.h

Abstract:

    This module contains all of the code prototypes
    to drive the IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


#define SERVICE_CONTROL_NEW_LOCAL_POLICY 129

#define SERVICE_CONTROL_FORCED_POLICY_RELOAD 130


VOID WINAPI
IPSecSPDServiceMain(
    IN DWORD    dwArgc,
    IN LPTSTR * lpszArgv
    );


DWORD
IPSecSPDUpdateStatus(
    );


VOID
IPSecSPDControlHandler(
    IN DWORD    dwOpCode
    );


VOID
IPSecSPDShutdown(
    IN DWORD    dwErrorCode
    );


VOID
ClearSPDGlobals(
    );


VOID
ClearPAStoreGlobals(
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\memory.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
//#include "oledsdbg.h"

#define SPDAssert(x)    NULL

#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))

#define DWORD_ALIGN_UP(size) ((size+3)&~3)


#if DBG


DWORD dwMemoryLog = 0;

#define MAXDEPTH 10

typedef struct _SPDMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} SPDMEMTAG, *PSPDMEMTAG ;

LIST_ENTRY       SPDMemList ;
DWORD            SPDMemCount ;
CRITICAL_SECTION SPDMemCritSect ;

/*++

Routine Description:

    This function initializes the SPD mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitSPDMem(
    VOID
)
{
    InitializeCriticalSection(&SPDMemCritSect) ;
    InitializeListHead(&SPDMemList) ;
    SPDMemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertSPDMemLeaks(
    VOID
)
{
    SPDAssert(IsListEmpty(&SPDMemList)) ;
}

#endif

LPVOID
AllocSPDMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    return(LocalAlloc(LPTR, cb));
}

BOOL
FreeSPDMem(
   LPVOID pMem
)
{
    return(LocalFree(pMem) == NULL);
}

LPVOID
ReallocSPDMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocSPDMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreeSPDMem(pOldMem);
    }

    return pNewMem;
}

LPWSTR
AllocSPDStr(
    LPWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPWSTR)AllocSPDMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
FreeSPDStr(
   LPWSTR pStr
)
{
   return pStr ? FreeSPDMem(pStr)
               : FALSE;
}

BOOL
ReallocSPDStr(
   LPWSTR *ppStr,
   LPWSTR pStr
)
{
   FreeSPDStr(*ppStr);
   *ppStr=AllocSPDStr(pStr);

   return TRUE;
}

DWORD
AllocateSPDMemory(
    DWORD cb,
    LPVOID * ppMem
    )
{
    DWORD dwError = 0;

    LPBYTE pMem = NULL;

    pMem = AllocSPDMem(cb);

    if (!pMem) {
        dwError = GetLastError();
    }

    *ppMem = pMem;

    return(dwError);
}

void
FreeSPDMemory(
    LPVOID pMem
    )
{
    if (pMem) {
        FreeSPDMem(pMem);
    }

    return;
}


DWORD
AllocateSPDString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    )
{
    LPWSTR pszNewString = NULL;
    DWORD dwError = 0;

    pszNewString = AllocSPDStr(pszString);

    if (!pszNewString) {
        dwError = GetLastError();
    }

    *ppszNewString = pszNewString;

    return(dwError);
}

void
FreeSPDString(
    LPWSTR pszString
    )
{
    if (pszString) {
        FreeSPDStr(pszString);
    }

    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mm-policy.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mm-policy.c

Abstract:


Author:


Environment: User Mode


Revision History:


--*/


#include "precomp.h"


DWORD
AddMMPolicy(
    LPWSTR pServerName,
    DWORD dwFlags,
    PIPSEC_MM_POLICY pMMPolicy
    )
/*++

Routine Description:

    This function adds a main mode policy to the SPD.

Arguments:

    pServerName - Server on which the main mode policy is to be added.

    pMMPolicy - Main mode policy to be added.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    BOOL bPersist = FALSE;


    bPersist = (BOOL) (dwFlags & PERSIST_SPD_OBJECT);

    //
    // Validate the main mode policy.
    //

    dwError = ValidateMMPolicy(
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicy(
                       gpIniMMPolicy,
                       pMMPolicy->pszPolicyName
                       );
    if (pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniMMPolicy = FindMMPolicyByGuid(
                       gpIniMMPolicy,
                       pMMPolicy->gPolicyID
                       );
    if (pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (bPersist && !gbLoadingPersistence) {
        dwError = PersistMMPolicy(
                      pMMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateIniMMPolicy(
                  pMMPolicy,
                  &pIniMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy->bIsPersisted = bPersist;

    pIniMMPolicy->pNext = gpIniMMPolicy;
    gpIniMMPolicy = pIniMMPolicy;

    if ((pIniMMPolicy->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultMMPolicy = pIniMMPolicy;
    }
 
    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMMPolicy && bPersist && !gbLoadingPersistence) {
        (VOID) SPDPurgeMMPolicy(
                   pMMPolicy->gPolicyID
                   );
    }

    return (dwError);
}


DWORD
ValidateMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;


    if (!pMMPolicy) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMPolicy->pszPolicyName) || !(*(pMMPolicy->pszPolicyName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateMMOffers(
                  pMMPolicy->dwOfferCount,
                  pMMPolicy->pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
ValidateMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_MM_OFFER pTemp = NULL;


    if (!dwOfferCount || !pOffers) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Need to catch the exception when the number of offers
    // specified is more than the actual number of offers.
    //


    pTemp = pOffers;

    for (i = 0; i < dwOfferCount; i++) {

        if ((pTemp->dwDHGroup != DH_GROUP_1) &&
            (pTemp->dwDHGroup != DH_GROUP_2)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pTemp->EncryptionAlgorithm.uAlgoIdentifier >= IPSEC_DOI_ESP_MAX) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pTemp->HashingAlgorithm.uAlgoIdentifier >= IPSEC_DOI_AH_MAX) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pTemp++;

    }

error:

    return (dwError);
}


DWORD
CreateIniMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy,
    PINIMMPOLICY * ppIniMMPolicy
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INIMMPOLICY),
                  &pIniMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIniMMPolicy->gPolicyID),
        &(pMMPolicy->gPolicyID),
        sizeof(GUID)
        );

    dwError =  AllocateSPDString(
                   pMMPolicy->pszPolicyName,
                   &(pIniMMPolicy->pszPolicyName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniMMPolicy->cRef = 0;
    pIniMMPolicy->bIsPersisted = FALSE;

    pIniMMPolicy->dwFlags = pMMPolicy->dwFlags;
    pIniMMPolicy->uSoftSAExpirationTime = pMMPolicy->uSoftSAExpirationTime;
    pIniMMPolicy->pNext = NULL;

    dwError = CreateIniMMOffers(
                  pMMPolicy->dwOfferCount,
                  pMMPolicy->pOffers,
                  &(pIniMMPolicy->dwOfferCount),
                  &(pIniMMPolicy->pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIniMMPolicy = pIniMMPolicy;
    return (dwError);

error:

    if (pIniMMPolicy) {
        FreeIniMMPolicy(
            pIniMMPolicy
            );
    }

    *ppIniMMPolicy = NULL;
    return (dwError);
}


DWORD
CreateIniMMOffers(
    DWORD dwInOfferCount,
    PIPSEC_MM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_OFFER pOffers = NULL;
    PIPSEC_MM_OFFER pTemp = NULL;
    PIPSEC_MM_OFFER pInTempOffer = NULL;
    DWORD i = 0;


    //
    // Offer count and the offers themselves have already been validated.
    // 

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_MM_OFFER) * dwInOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pOffers;
    pInTempOffer = pInOffers;

    for (i = 0; i < dwInOfferCount; i++) {

        memcpy(
            &(pTemp->Lifetime),
            &(pInTempOffer->Lifetime),
            sizeof(KEY_LIFETIME)
            );
        if (!(pTemp->Lifetime.uKeyExpirationTime)) {
            pTemp->Lifetime.uKeyExpirationTime = DEFAULT_MM_KEY_EXPIRATION_TIME;
        }

        pTemp->dwFlags = pInTempOffer->dwFlags;
        pTemp->dwQuickModeLimit = pInTempOffer->dwQuickModeLimit;
        pTemp->dwDHGroup = pInTempOffer->dwDHGroup;

        memcpy(
            &(pTemp->EncryptionAlgorithm),
            &(pInTempOffer->EncryptionAlgorithm),
            sizeof(IPSEC_MM_ALGO)
            );
        memcpy(
            &(pTemp->HashingAlgorithm),
            &(pInTempOffer->HashingAlgorithm),
            sizeof(IPSEC_MM_ALGO)
            );

        pInTempOffer++;
        pTemp++;

    }

    *pdwOfferCount = dwInOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:

    if (pOffers) {
        FreeIniMMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}
    

VOID
FreeIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy
    )
{
    if (pIniMMPolicy) {

        if (pIniMMPolicy->pszPolicyName) {
            FreeSPDString(pIniMMPolicy->pszPolicyName);
        }

        FreeIniMMOffers(
            pIniMMPolicy->dwOfferCount,
            pIniMMPolicy->pOffers
            );

        FreeSPDMemory(pIniMMPolicy);

    }
}


VOID
FreeIniMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    if (pOffers) {
        FreeSPDMemory(pOffers);
    }
}


PINIMMPOLICY
FindMMPolicy(
    PINIMMPOLICY pIniMMPolicyList,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY pTemp = NULL;


    pTemp = pIniMMPolicyList;

    while (pTemp) {

        if (!_wcsicmp(pTemp->pszPolicyName, pszPolicyName)) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


DWORD
DeleteMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName
    )
/*++

Routine Description:

    This function deletes a main mode policy from the SPD.

Arguments:

    pServerName - Server on which the main mode policy is to be deleted.

    pszPolicyName - Main mode policy to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    GUID gPolicyID;


    if (!pszPolicyName || !*pszPolicyName) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicy(
                       gpIniMMPolicy,
                       pszPolicyName
                       );
    if (!pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMPolicy->cRef) {
        dwError = ERROR_IPSEC_MM_POLICY_IN_USE;
        memcpy(&gPolicyID, &pIniMMPolicy->gPolicyID, sizeof(GUID));
        BAIL_ON_LOCK_ERROR(dwError);
    }

    memcpy(&gPolicyID, &pIniMMPolicy->gPolicyID, sizeof(GUID));

    if (pIniMMPolicy->bIsPersisted) {
        dwError = SPDPurgeMMPolicy(
                      gPolicyID
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = DeleteIniMMPolicy(
                  pIniMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gPolicyID),
                   POLICY_GUID_MM
                   );
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if ((dwError == ERROR_IPSEC_MM_POLICY_IN_USE) && gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gPolicyID),
                   POLICY_GUID_MM
                   );
    }

    return (dwError);
}


DWORD
EnumMMPolicies(
    LPWSTR pServerName,
    PIPSEC_MM_POLICY * ppMMPolicies,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle
    )
/*++

Routine Description:

    This function enumerates main mode policies from the SPD.

Arguments:

    pServerName - Server on which the main mode policies are to
                  be enumerated.

    ppMMPolicies - Enumerated main mode policies returned to the 
                   caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumPolicies - Number of main mode policies actually enumerated.

    pdwResumeHandle - Handle to the location in the main mode policy
                      list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    DWORD i = 0;
    PINIMMPOLICY pTemp = NULL;
    DWORD dwNumPolicies = 0;
    PIPSEC_MM_POLICY pMMPolicies = NULL;
    PIPSEC_MM_POLICY pMMPolicy = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_MMPOLICY_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMPOLICY_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = gpIniMMPolicy;

    for (i = 0; (i < dwResumeHandle) && (pIniMMPolicy != NULL); i++) {
        pIniMMPolicy = pIniMMPolicy->pNext;
    }

    if (!pIniMMPolicy) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pTemp = pIniMMPolicy;

    while (pTemp && (dwNumPolicies < dwNumToEnum)) {
        dwNumPolicies++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_POLICY)*dwNumPolicies,
                  &pMMPolicies
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pTemp = pIniMMPolicy;
    pMMPolicy = pMMPolicies;

    for (i = 0; i < dwNumPolicies; i++) {

        dwError = CopyMMPolicy(
                      pTemp,
                      pMMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);

        pTemp = pTemp->pNext;
        pMMPolicy++;

    }

    *ppMMPolicies = pMMPolicies;
    *pdwResumeHandle = dwResumeHandle + dwNumPolicies;
    *pdwNumPolicies = dwNumPolicies;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if (pMMPolicies) {
        FreeMMPolicies(
            i,
            pMMPolicies
            );
    }

    *ppMMPolicies = NULL;
    *pdwResumeHandle = dwResumeHandle;
    *pdwNumPolicies = 0;

    return (dwError);
}


DWORD
SetMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY pMMPolicy
    )
/*++

Routine Description:

    This function updates a main mode policy in the SPD.

Arguments:

    pServerName - Server on which the main mode policy is to be
                  updated.

    pszPolicyName - Name of the main mode policy to be updated.

    pMMPolicy - New main mode policy which will replace the 
                existing policy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;


    if (!pszPolicyName || !*pszPolicyName) {
        return (ERROR_INVALID_PARAMETER);
    }
    
    //
    // Validate main mode policy.
    //

    dwError = ValidateMMPolicy(
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicy(
                       gpIniMMPolicy,
                       pszPolicyName
                       );
    if (!pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (memcmp(
            &(pIniMMPolicy->gPolicyID),
            &(pMMPolicy->gPolicyID),
            sizeof(GUID))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = SetIniMMPolicy(
                  pIniMMPolicy,
                  pMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniMMPolicy->bIsPersisted) {
        dwError = PersistMMPolicy(
                      pMMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    LEAVE_SPD_SECTION();

    (VOID) IKENotifyPolicyChange(
               &(pMMPolicy->gPolicyID),
               POLICY_GUID_MM
               );

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    return (dwError);
}


DWORD
GetMMPolicy(
    LPWSTR pServerName,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY * ppMMPolicy
    )
/*++

Routine Description:

    This function gets a main mode policy from the SPD.

Arguments:

    pServerName - Server from which to get the main mode policy.

    pszPolicyName - Name of the main mode policy to get.

    ppMMPolicy - Main mode policy found returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    PIPSEC_MM_POLICY pMMPolicy = NULL;


    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicy(
                       gpIniMMPolicy,
                       pszPolicyName
                       );
    if (!pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniMMPolicy(
                  pIniMMPolicy,
                  &pMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppMMPolicy = pMMPolicy;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
SetIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;
    DWORD dwOfferCount = 0;
    PIPSEC_MM_OFFER pOffers = NULL;


    dwError = CreateIniMMOffers(
                  pMMPolicy->dwOfferCount,
                  pMMPolicy->pOffers,
                  &dwOfferCount,
                  &pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    FreeIniMMOffers(
        pIniMMPolicy->dwOfferCount,
        pIniMMPolicy->pOffers
        );
    
    if ((pIniMMPolicy->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultMMPolicy = NULL;
    }

    pIniMMPolicy->dwFlags = pMMPolicy->dwFlags;
    pIniMMPolicy->uSoftSAExpirationTime = pMMPolicy->uSoftSAExpirationTime;
    pIniMMPolicy->dwOfferCount = dwOfferCount;
    pIniMMPolicy->pOffers = pOffers;

    if ((pIniMMPolicy->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultMMPolicy = pIniMMPolicy;
    }

error:

    return (dwError);
}


DWORD
GetIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY * ppMMPolicy
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_POLICY),
                  &pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyMMPolicy(
                  pIniMMPolicy,
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppMMPolicy = pMMPolicy;
    return (dwError);

error:

    if (pMMPolicy) {
        SPDApiBufferFree(pMMPolicy);
    }

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
CopyMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;


    memcpy(
        &(pMMPolicy->gPolicyID),
        &(pIniMMPolicy->gPolicyID),
        sizeof(GUID)
        );

    dwError =  SPDApiBufferAllocate(
                   wcslen(pIniMMPolicy->pszPolicyName)*sizeof(WCHAR)
                   + sizeof(WCHAR),
                   &(pMMPolicy->pszPolicyName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(pMMPolicy->pszPolicyName, pIniMMPolicy->pszPolicyName);
 
    pMMPolicy->dwFlags = pIniMMPolicy->dwFlags;
    pMMPolicy->uSoftSAExpirationTime = pIniMMPolicy->uSoftSAExpirationTime;

    dwError = CreateMMOffers(
                  pIniMMPolicy->dwOfferCount,
                  pIniMMPolicy->pOffers,
                  &(pMMPolicy->dwOfferCount),
                  &(pMMPolicy->pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    return (dwError);

error:

    if (pMMPolicy->pszPolicyName) {
        SPDApiBufferFree(pMMPolicy->pszPolicyName);
    }

    return (dwError);
}


DWORD
CreateMMOffers(
    DWORD dwInOfferCount,
    PIPSEC_MM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_OFFER pOffers = NULL;
    PIPSEC_MM_OFFER pTemp = NULL;
    PIPSEC_MM_OFFER pInTempOffer = NULL;
    DWORD i = 0;


    //
    // Offer count and the offers themselves have already been validated.
    // 

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_OFFER) * dwInOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pOffers;
    pInTempOffer = pInOffers;

    for (i = 0; i < dwInOfferCount; i++) {

        memcpy(
            &(pTemp->Lifetime),
            &(pInTempOffer->Lifetime),
            sizeof(KEY_LIFETIME)
            );

        pTemp->dwFlags = pInTempOffer->dwFlags;
        pTemp->dwQuickModeLimit = pInTempOffer->dwQuickModeLimit;
        pTemp->dwDHGroup = pInTempOffer->dwDHGroup;

        memcpy(
            &(pTemp->EncryptionAlgorithm),
            &(pInTempOffer->EncryptionAlgorithm),
            sizeof(IPSEC_MM_ALGO)
            );
        memcpy(
            &(pTemp->HashingAlgorithm),
            &(pInTempOffer->HashingAlgorithm),
            sizeof(IPSEC_MM_ALGO)
            );

        pInTempOffer++;
        pTemp++;

    }

    *pdwOfferCount = dwInOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:

    if (pOffers) {
        FreeMMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


DWORD
DeleteIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY * ppTemp = NULL;


    ppTemp = &gpIniMMPolicy;

    while (*ppTemp) {

        if (*ppTemp == pIniMMPolicy) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pIniMMPolicy->pNext;
    }

    if ((pIniMMPolicy->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultMMPolicy = NULL;
    }

    FreeIniMMPolicy(pIniMMPolicy);

    return (dwError);
}


VOID
FreeMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    if (pOffers) {
        SPDApiBufferFree(pOffers);
    }
}


VOID
FreeIniMMPolicyList(
    PINIMMPOLICY pIniMMPolicyList
    )
{
    PINIMMPOLICY pTemp = NULL;
    PINIMMPOLICY pIniMMPolicy = NULL;


    pTemp = pIniMMPolicyList;

    while (pTemp) {

         pIniMMPolicy = pTemp;
         pTemp = pTemp->pNext;

         FreeIniMMPolicy(pIniMMPolicy);

    }
}


PINIMMPOLICY
FindMMPolicyByGuid(
    PINIMMPOLICY pIniMMPolicyList,
    GUID gPolicyID
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY pTemp = NULL;


    pTemp = pIniMMPolicyList;

    while (pTemp) {

        if (!memcmp(&(pTemp->gPolicyID), &gPolicyID, sizeof(GUID))) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


VOID
FreeMMPolicies(
    DWORD dwNumMMPolicies,
    PIPSEC_MM_POLICY pMMPolicies
    )
{
    DWORD i = 0;

    if (pMMPolicies) {

        for (i = 0; i < dwNumMMPolicies; i++) {

            if (pMMPolicies[i].pszPolicyName) {
                SPDApiBufferFree(pMMPolicies[i].pszPolicyName);
            }

            FreeMMOffers(
                pMMPolicies[i].dwOfferCount,
                pMMPolicies[i].pOffers
                );

        }

        SPDApiBufferFree(pMMPolicies);

    }

}


DWORD
GetMMPolicyByID(
    LPWSTR pServerName,
    GUID gMMPolicyID,
    PIPSEC_MM_POLICY * ppMMPolicy
    )
/*++

Routine Description:

    This function gets a main mode policy from the SPD.

Arguments:

    pServerName - Server from which to get the main mode policy.

    gMMPolicyID - Guid of the main mode policy to get.

    ppMMPolicy - Main mode policy found returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    PIPSEC_MM_POLICY pMMPolicy = NULL;


    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicyByGuid(
                       gpIniMMPolicy,
                       gMMPolicyID
                       );
    if (!pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniMMPolicy(
                  pIniMMPolicy,
                  &pMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppMMPolicy = pMMPolicy;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
LocateMMPolicy(
    PMM_FILTER pMMFilter,
    PINIMMPOLICY * ppIniMMPolicy
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;


    if ((pMMFilter->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {

        if (!gpIniDefaultMMPolicy) {
            dwError = ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pIniMMPolicy = gpIniDefaultMMPolicy;

    }
    else {

        pIniMMPolicy = FindMMPolicyByGuid(
                           gpIniMMPolicy,
                           pMMFilter->gPolicyID
                           );
        if (!pIniMMPolicy) {
            dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    *ppIniMMPolicy = pIniMMPolicy;
    return (dwError);

error:

    *ppIniMMPolicy = NULL;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mma-load.h ===
DWORD
LoadPersistedMMAuthMethods(
    HKEY hParentRegKey
    );

DWORD
SPDReadMMAuthMethods(
    HKEY hParentRegKey,
    LPWSTR pszMMAuthUniqueID,
    PMM_AUTH_METHODS * ppMMAuthMethods
    );

DWORD
UnMarshallMMAuthInfoBundle(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PIPSEC_MM_AUTH_INFO * pMMAuthInfos,
    PDWORD pdwNumAuthInfos
    );

DWORD
UnMarshallMMAuthMethod(
    LPBYTE pBuffer,
    PIPSEC_MM_AUTH_INFO pMMAuthInfo,
    PDWORD pdwNumBytesAdvanced
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmauth.h ===
typedef struct _iniMMauthmethods {
    GUID gMMAuthID;
    DWORD dwFlags;
    DWORD cRef;
    BOOL bIsPersisted;
    DWORD dwNumAuthInfos;
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo;
    struct _iniMMauthmethods * pNext;
} INIMMAUTHMETHODS, * PINIMMAUTHMETHODS;


DWORD
ValidateMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods
    );

PINIMMAUTHMETHODS
FindMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    GUID gMMAuthID
    );

DWORD
CreateIniMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods,
    PINIMMAUTHMETHODS * ppIniMMAuthMethods
    );

DWORD
CreateIniMMAuthInfos(
    DWORD dwInNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pInAuthenticationInfo,
    PDWORD pdwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    );

VOID
FreeIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods
    );

VOID
FreeIniMMAuthInfos(
    DWORD dwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo
    );

DWORD
DeleteIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods
    );

DWORD
SetIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PMM_AUTH_METHODS pMMAuthMethods
    );

DWORD
GetIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PMM_AUTH_METHODS * ppMMAuthMethods
    );

DWORD
CopyMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PMM_AUTH_METHODS pMMAuthMethods
    );

DWORD
CreateMMAuthInfos(
    DWORD dwInNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pInAuthenticationInfo,
    PDWORD pdwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    );


VOID
FreeMMAuthInfos(
    DWORD dwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo
    );

VOID
FreeIniMMAuthMethodsList(
    PINIMMAUTHMETHODS pIniMMAuthMethodsList
    );

VOID
FreeMMAuthMethods(
    DWORD dwNumAuthMethods,
    PMM_AUTH_METHODS pMMAuthMethods
    );

DWORD
LocateMMAuthMethods(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS * ppIniMMAuthMethods
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mma-pers.c ===
#include "precomp.h"


LPWSTR gpszIpsecMMAuthMethodsKey = 
L"SOFTWARE\\Microsoft\\IPSec\\MM Auth Methods";


DWORD
PersistMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    DWORD dwDisposition = 0;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecMMAuthMethodsKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegistryKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDWriteMMAuthMethods(
                  hRegistryKey,
                  pMMAuthMethods
                  );    
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    if (hRegistryKey) {
        (VOID) SPDPurgeMMAuthMethods(
                   pMMAuthMethods->gMMAuthID
                   );
    }

    goto cleanup;
}


DWORD
SPDWriteMMAuthMethods(
    HKEY hParentRegKey,
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    WCHAR szAuthID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    HKEY hRegKey = NULL;
    DWORD dwDisposition = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;


    szAuthID[0] = L'\0';

    dwError = UuidToString(
                  &pMMAuthMethods->gMMAuthID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szAuthID, L"{");
    wcscat(szAuthID, pszStringUuid);
    wcscat(szAuthID, L"}");

    dwError = RegCreateKeyExW(
                  hParentRegKey,
                  szAuthID,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"AuthID",
                  0,
                  REG_SZ,
                  (LPBYTE) szAuthID,
                  (wcslen(szAuthID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Flags",
                  0,
                  REG_DWORD,
                  (LPBYTE)&pMMAuthMethods->dwFlags,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MarshallMMAuthInfoBundle(
                  pMMAuthMethods->pAuthenticationInfo,
                  pMMAuthMethods->dwNumAuthInfos,
                  &pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"AuthInfoBundle",
                  0,
                  REG_BINARY,
                  (LPBYTE) pBuffer,
                  dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    return (dwError);

error:

    goto cleanup;
}


DWORD
MarshallMMAuthInfoBundle(
    PIPSEC_MM_AUTH_INFO pAuthInfoBundle,
    DWORD dwNumAuthInfos,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    )
{
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;
    DWORD i = 0;
    LPBYTE pMem = NULL;
    static const GUID GUID_IPSEC_MM_AUTH_INFO_VER1 =
    { 0xabcd0003, 0x0001, 0x0001, { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 } };
    DWORD dwNumBytesAdvanced = 0;


    dwBufferSize = sizeof(GUID) +
                   sizeof(DWORD) +
                   sizeof(DWORD);

    pTemp = pAuthInfoBundle;

    for (i = 0; i < dwNumAuthInfos; i++) {

        dwBufferSize += sizeof(DWORD);
        dwBufferSize += sizeof(DWORD);
        dwBufferSize += pTemp->dwAuthInfoSize;

        pTemp++;

    }

    pBuffer = (LPBYTE) AllocSPDMem(
                           dwBufferSize
                           );
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMem = pBuffer;

    memcpy(
        pMem,
        (LPBYTE) &GUID_IPSEC_MM_AUTH_INFO_VER1,
        sizeof(GUID)
        );
    pMem += sizeof(GUID);

    memcpy(
        pMem,
        (LPBYTE) &dwBufferSize,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    memcpy(
        pMem,
        (LPBYTE) &dwNumAuthInfos,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    pTemp = pAuthInfoBundle;

    for (i = 0; i < dwNumAuthInfos; i++) {

        CopyMMAuthInfoIntoBuffer(
            pTemp,
            pMem,
            &dwNumBytesAdvanced
            );

        pMem += dwNumBytesAdvanced;
        pTemp++;

    }

    *ppBuffer = pBuffer;
    *pdwBufferSize = dwBufferSize;

    return (dwError);

error:

    *ppBuffer = NULL;
    *pdwBufferSize = 0;

    return (dwError);
}


VOID
CopyMMAuthInfoIntoBuffer(
    PIPSEC_MM_AUTH_INFO pMMAuthInfo,
    LPBYTE pBuffer,
    PDWORD pdwNumBytesAdvanced
    )
{
    DWORD dwError = 0;
    DWORD dwNumBytesAdvanced = 0;
    DWORD dwAuthMethod = 0;
    DWORD dwAuthInfoSize = 0;
    LPBYTE pAuthInfo = NULL;
    LPBYTE pMem = NULL;


    dwAuthMethod = (DWORD) pMMAuthInfo->AuthMethod;
    dwAuthInfoSize = pMMAuthInfo->dwAuthInfoSize;
    pAuthInfo = pMMAuthInfo->pAuthInfo;

    pMem = pBuffer;

    memcpy(
        pMem,
        (LPBYTE) &dwAuthMethod,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    memcpy(
        pMem,
        (LPBYTE) &dwAuthInfoSize,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwAuthInfoSize) {
        memcpy(
            pMem,
            pAuthInfo,
            dwAuthInfoSize
            );
    }
    pMem += dwAuthInfoSize;
    dwNumBytesAdvanced += dwAuthInfoSize;

    *pdwNumBytesAdvanced = dwNumBytesAdvanced;

    return;
}


DWORD
SPDPurgeMMAuthMethods(
    GUID gMMAuthID
    )
{
    DWORD dwError = 0;
    HKEY hParentRegKey = NULL;
    DWORD dwDisposition = 0;
    WCHAR szAuthID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecMMAuthMethodsKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hParentRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szAuthID[0] = L'\0';

    dwError = UuidToString(
                  &gMMAuthID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szAuthID, L"{");
    wcscat(szAuthID, pszStringUuid);
    wcscat(szAuthID, L"}");

    dwError = RegDeleteKeyW(
                  hParentRegKey,
                  szAuthID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hParentRegKey) {
        RegCloseKey(hParentRegKey);
    }

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mm-policy.h ===
typedef struct _iniMMpolicy {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD  cRef;
    BOOL bIsPersisted;
    DWORD dwFlags;
    ULONG uSoftSAExpirationTime;
    DWORD dwOfferCount;
    PIPSEC_MM_OFFER pOffers;
    struct _iniMMpolicy * pNext;
} INIMMPOLICY, * PINIMMPOLICY;


DWORD
CreateIniMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy,
    PINIMMPOLICY * ppIniMMPolicy
    );

DWORD
ValidateMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy
    );

DWORD
ValidateMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    );

PINIMMPOLICY
FindMMPolicy(
    PINIMMPOLICY pIniMMPolicyList,
    LPWSTR pszPolicyName
    );

VOID
FreeIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy
    );

VOID
FreeIniMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    );

DWORD
CreateIniMMOffers(
    DWORD dwInOfferCount,
    PIPSEC_MM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    );

DWORD
SetIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY pMMPolicy
    );

DWORD
GetIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY * ppMMPolicy
    );

DWORD
CopyMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY pMMPolicy
    );

DWORD
CreateMMOffers(
    DWORD dwInOfferCount,
    PIPSEC_MM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    );

DWORD
DeleteIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy
    );

VOID
FreeMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    );

VOID
FreeIniMMPolicyList(
    PINIMMPOLICY pIniMMPolicyList
    );

PINIMMPOLICY
FindMMPolicyByGuid(
    PINIMMPOLICY pIniMMPolicyList,
    GUID gPolicyID
    );

VOID
FreeMMPolicies(
    DWORD dwNumMMPolicies,
    PIPSEC_MM_POLICY pMMPolicies
    );

DWORD
LocateMMPolicy(
    PMM_FILTER pMMFilter,
    PINIMMPOLICY * ppIniMMPolicy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mma-load.c ===
#include "precomp.h"


DWORD
LoadPersistedMMAuthMethods(
    HKEY hParentRegKey
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;
    WCHAR szMMAuthUniqueID[MAX_PATH];
    DWORD dwIndex = 0;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;
    LPWSTR pszServerName = NULL;
    DWORD dwPersist = 0;


    dwPersist |= PERSIST_SPD_OBJECT;

    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  L"MM Auth Methods",
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    while (1) {

        dwSize = MAX_PATH;
        szMMAuthUniqueID[0] = L'\0';

        dwError = RegEnumKeyExW(
                      hRegKey,
                      dwIndex,
                      szMMAuthUniqueID,
                      &dwSize,
                      NULL,
                      NULL,
                      0,
                      0
                      );

        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        }

        BAIL_ON_WIN32_ERROR(dwError);

        dwError = SPDReadMMAuthMethods(
                      hRegKey,
                      szMMAuthUniqueID,
                      &pMMAuthMethods
                      );

        if (dwError) {
            dwIndex++;
            continue;
        }

        dwError = AddMMAuthMethods(
                      pszServerName,
                      dwPersist,
                      pMMAuthMethods
                      );

        if (pMMAuthMethods) {
            FreeMMAuthMethods(
                1,
                pMMAuthMethods
                );
        }

        dwIndex++;

    }

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
SPDReadMMAuthMethods(
    HKEY hParentRegKey,
    LPWSTR pszMMAuthUniqueID,
    PMM_AUTH_METHODS * ppMMAuthMethods
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;
    LPWSTR pszAuthID = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;


    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  pszMMAuthUniqueID,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMAuthMethods = (PMM_AUTH_METHODS) AllocSPDMem(
                                   sizeof(MM_AUTH_METHODS)
                                   );
    if (!pMMAuthMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"AuthID",
                  REG_SZ,
                  (LPBYTE *)&pszAuthID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszAuthID,
        &pMMAuthMethods->gMMAuthID
        );

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"Flags",
                  NULL,
                  &dwType,
                  (LPBYTE)&pMMAuthMethods->dwFlags,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"AuthInfoBundle",
                  REG_BINARY,
                  (LPBYTE *)&pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallMMAuthInfoBundle(
                  pBuffer,
                  dwBufferSize,
                  &pMMAuthMethods->pAuthenticationInfo,
                  &pMMAuthMethods->dwNumAuthInfos
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppMMAuthMethods = pMMAuthMethods;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszAuthID) {
        FreeSPDStr(pszAuthID);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    return (dwError);

error:

    *ppMMAuthMethods = NULL;

    if (pMMAuthMethods) {
        FreeMMAuthMethods(
            1,
            pMMAuthMethods
            );
    }

    goto cleanup;
}


DWORD
UnMarshallMMAuthInfoBundle(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PIPSEC_MM_AUTH_INFO * ppMMAuthInfos,
    PDWORD pdwNumAuthInfos
    )
{
    DWORD dwError = 0;
    LPBYTE pMem = NULL;
    PIPSEC_MM_AUTH_INFO pMMAuthInfos = NULL;
    DWORD dwNumAuthInfos = 0;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;
    DWORD i = 0;
    DWORD dwNumBytesAdvanced = 0;


    pMem = pBuffer;

    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);

    memcpy(
        (LPBYTE) &dwNumAuthInfos,
        pMem,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    pMMAuthInfos = (PIPSEC_MM_AUTH_INFO) AllocSPDMem(
                                sizeof(IPSEC_MM_AUTH_INFO)*dwNumAuthInfos
                                );
    if (!pMMAuthInfos) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pMMAuthInfos;

    for (i = 0; i < dwNumAuthInfos; i++) {

        dwError = UnMarshallMMAuthMethod(
                      pMem,
                      pTemp,
                      &dwNumBytesAdvanced
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pMem += dwNumBytesAdvanced;
        pTemp++;

    }

    *ppMMAuthInfos = pMMAuthInfos;
    *pdwNumAuthInfos = dwNumAuthInfos;
    return (dwError);

error:

    if (pMMAuthInfos) {
        FreeIniMMAuthInfos(
            i,
            pMMAuthInfos
            );
    }

    *ppMMAuthInfos = NULL;
    *pdwNumAuthInfos = 0;
    return (dwError);
}


DWORD
UnMarshallMMAuthMethod(
    LPBYTE pBuffer,
    PIPSEC_MM_AUTH_INFO pMMAuthInfo,
    PDWORD pdwNumBytesAdvanced
    )
{
    DWORD dwError = 0;
    LPBYTE pMem = NULL;
    DWORD dwNumBytesAdvanced = 0;
    DWORD dwAuthMethod = 0;
    DWORD dwAuthInfoSize = 0;
    LPBYTE pAuthInfo = NULL;


    pMem = pBuffer;

    memcpy(
        (LPBYTE) &dwAuthMethod,
        pMem,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    memcpy(
        (LPBYTE) &dwAuthInfoSize,
        pMem,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwAuthInfoSize) {
        pAuthInfo = (LPBYTE) AllocSPDMem(
                                 dwAuthInfoSize
                                 );
        if (!pAuthInfo) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        memcpy(
            pAuthInfo,
            pMem,
            dwAuthInfoSize
            );
    }
    pMem += dwAuthInfoSize;
    dwNumBytesAdvanced += dwAuthInfoSize;

    pMMAuthInfo->AuthMethod = (MM_AUTH_ENUM) dwAuthMethod;
    pMMAuthInfo->dwAuthInfoSize = dwAuthInfoSize;
    pMMAuthInfo->pAuthInfo = pAuthInfo;


    *pdwNumBytesAdvanced = dwNumBytesAdvanced;
    return (dwError);

error:

    *pdwNumBytesAdvanced = 0;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mma-pers.h ===
DWORD
PersistMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods
    );

DWORD
SPDWriteMMAuthMethods(
    HKEY hParentRegKey,
    PMM_AUTH_METHODS pMMAuthMethods
    );

DWORD
MarshallMMAuthInfoBundle(
    PIPSEC_MM_AUTH_INFO pAuthInfoBundle,
    DWORD dwNumAuthInfos,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    );

VOID
CopyMMAuthInfoIntoBuffer(
    PIPSEC_MM_AUTH_INFO pMMAuthInfo,
    LPBYTE pBuffer,
    PDWORD pdwNumBytesAdvanced
    );

DWORD
SPDPurgeMMAuthMethods(
    GUID gMMAuthID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmauth.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmauth.c

Abstract:


Author:

    abhishev    06-January-2000

Environment: User Mode


Revision History:


--*/


#include "precomp.h"


DWORD
WINAPI
AddMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwFlags,
    PMM_AUTH_METHODS pMMAuthMethods
    )
/*++

Routine Description:

    This function adds main mode auths to the SPD.

Arguments:

    pServerName - Server on which the main mode auths are to be added.

    pMMAuthMethods - Main mode auths to be added.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;
    BOOL bPersist = FALSE;


    bPersist = (BOOL) (dwFlags & PERSIST_SPD_OBJECT);

    //
    // Validate the main mode auth methods.
    //

    dwError = ValidateMMAuthMethods(
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = FindMMAuthMethods(
                            gpIniMMAuthMethods,
                            pMMAuthMethods->gMMAuthID
                            );
    if (pIniMMAuthMethods) {
        dwError = ERROR_IPSEC_MM_AUTH_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (bPersist && !gbLoadingPersistence) {
        dwError = PersistMMAuthMethods(
                      pMMAuthMethods
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateIniMMAuthMethods(
                  pMMAuthMethods,
                  &pIniMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods->bIsPersisted = bPersist;

    pIniMMAuthMethods->pNext = gpIniMMAuthMethods;
    gpIniMMAuthMethods = pIniMMAuthMethods;

    if ((pIniMMAuthMethods->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {
        gpIniDefaultMMAuthMethods = pIniMMAuthMethods;
    }

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMMAuthMethods && bPersist && !gbLoadingPersistence) {
        (VOID) SPDPurgeMMAuthMethods(
                   pMMAuthMethods->gMMAuthID
                   );
    }

    return (dwError);
}


DWORD
ValidateMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;
    DWORD dwNumAuthInfos = 0;
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    BOOL bSSPI = FALSE;
    BOOL bPresharedKey = FALSE;


    if (!pMMAuthMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumAuthInfos = pMMAuthMethods->dwNumAuthInfos;
    pAuthenticationInfo = pMMAuthMethods->pAuthenticationInfo;

    if (!dwNumAuthInfos || !pAuthenticationInfo) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Need to catch the exception when the number of auth infos
    // specified is more than the actual number of auth infos.
    //


    pTemp = pAuthenticationInfo;

    for (i = 0; i < dwNumAuthInfos; i++) {

        if ((pTemp->AuthMethod != IKE_PRESHARED_KEY) &&
            (pTemp->AuthMethod != IKE_RSA_SIGNATURE) &&
            (pTemp->AuthMethod != IKE_SSPI)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pTemp->AuthMethod != IKE_SSPI) {
            if (!(pTemp->dwAuthInfoSize) || !(pTemp->pAuthInfo)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
        }

        if (pTemp->AuthMethod == IKE_SSPI) {
            if (bSSPI) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            bSSPI = TRUE;
        }

        if (pTemp->AuthMethod == IKE_PRESHARED_KEY) {
            if (bPresharedKey) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            bPresharedKey = TRUE;
        }

        pTemp++;

    }

error:

    return (dwError);
}


PINIMMAUTHMETHODS
FindMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    GUID gMMAuthID
    )
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pTemp = NULL;


    pTemp = pIniMMAuthMethods;

    while (pTemp) {

        if (!memcmp(&(pTemp->gMMAuthID), &gMMAuthID, sizeof(GUID))) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


DWORD
CreateIniMMAuthMethods(
    PMM_AUTH_METHODS pMMAuthMethods,
    PINIMMAUTHMETHODS * ppIniMMAuthMethods
    )
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INIMMAUTHMETHODS),
                  &pIniMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIniMMAuthMethods->gMMAuthID),
        &(pMMAuthMethods->gMMAuthID),
        sizeof(GUID)
        );

    pIniMMAuthMethods->dwFlags = pMMAuthMethods->dwFlags;
    pIniMMAuthMethods->cRef = 0;
    pIniMMAuthMethods->bIsPersisted = FALSE;
    pIniMMAuthMethods->pNext = NULL;

    dwError = CreateIniMMAuthInfos(
                  pMMAuthMethods->dwNumAuthInfos,
                  pMMAuthMethods->pAuthenticationInfo,
                  &(pIniMMAuthMethods->dwNumAuthInfos),
                  &(pIniMMAuthMethods->pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIniMMAuthMethods = pIniMMAuthMethods;
    return (dwError);

error:

    if (pIniMMAuthMethods) {
        FreeIniMMAuthMethods(
            pIniMMAuthMethods
            );
    }

    *ppIniMMAuthMethods = NULL;
    return (dwError);
}


DWORD
CreateIniMMAuthInfos(
    DWORD dwInNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pInAuthenticationInfo,
    PDWORD pdwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;
    PIPSEC_MM_AUTH_INFO pInTemp = NULL;
    DWORD i = 0;


    //
    // Number of auth infos and the auth infos themselves 
    // have already been validated.
    // 

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_MM_AUTH_INFO) * dwInNumAuthInfos,
                  &(pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pAuthenticationInfo;
    pInTemp = pInAuthenticationInfo;

    for (i = 0; i < dwInNumAuthInfos; i++) {

        pTemp->AuthMethod = pInTemp->AuthMethod;

        if (pInTemp->AuthMethod == IKE_SSPI) {

            pTemp->dwAuthInfoSize = 0;
            pTemp->pAuthInfo = NULL;

        }
        else {

            if (!(pInTemp->dwAuthInfoSize) || !(pInTemp->pAuthInfo)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            dwError = AllocateSPDMemory(
                          pInTemp->dwAuthInfoSize,
                          &(pTemp->pAuthInfo)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            pTemp->dwAuthInfoSize = pInTemp->dwAuthInfoSize;

            //
            // Need to catch the exception when the size of auth info
            // specified is more than the actual size. This can
            // not be checked earlier in the validation routine.
            //
            //

            memcpy(
                pTemp->pAuthInfo,
                pInTemp->pAuthInfo,
                pInTemp->dwAuthInfoSize
                );

        }

        pInTemp++;
        pTemp++;

    }

    *pdwNumAuthInfos = dwInNumAuthInfos;
    *ppAuthenticationInfo = pAuthenticationInfo;
    return (dwError);

error:

    if (pAuthenticationInfo) {
        FreeIniMMAuthInfos(
            i,
            pAuthenticationInfo
            );
    }

    *pdwNumAuthInfos = 0;
    *ppAuthenticationInfo = NULL;
    return (dwError);
}


VOID
FreeIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods
    )
{
    if (pIniMMAuthMethods) {

        FreeIniMMAuthInfos(
            pIniMMAuthMethods->dwNumAuthInfos,
            pIniMMAuthMethods->pAuthenticationInfo
            );

        FreeSPDMemory(pIniMMAuthMethods);

    }
}


VOID
FreeIniMMAuthInfos(
    DWORD dwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo
    )
{
    DWORD i = 0;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;


    if (pAuthenticationInfo) {

        pTemp = pAuthenticationInfo;

        for (i = 0; i < dwNumAuthInfos; i++) {
            if (pTemp->pAuthInfo) {
                FreeSPDMemory(pTemp->pAuthInfo);
            }
            pTemp++;
        }

        FreeSPDMemory(pAuthenticationInfo);

    }
}


DWORD
WINAPI
DeleteMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID
    )
/*++

Routine Description:

    This function deletes main mode auth methods from the SPD.

Arguments:

    pServerName - Server on which the main mode auth methods
                  are to be deleted.

    gMMAuthID - Main mode methods to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;


    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = FindMMAuthMethods(
                            gpIniMMAuthMethods,
                            gMMAuthID
                            );
    if (!pIniMMAuthMethods) {
        dwError = ERROR_IPSEC_MM_AUTH_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMAuthMethods->cRef) {
        dwError = ERROR_IPSEC_MM_AUTH_IN_USE;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMAuthMethods->bIsPersisted) {
        dwError = SPDPurgeMMAuthMethods(
                      gMMAuthID
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = DeleteIniMMAuthMethods(
                  pIniMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gMMAuthID),
                   POLICY_GUID_AUTH
                   );
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if ((dwError == ERROR_IPSEC_MM_AUTH_IN_USE) && gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gMMAuthID),
                   POLICY_GUID_AUTH
                   );
    }

    return (dwError);
}


DWORD
DeleteIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods
    )
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS * ppTemp = NULL;


    ppTemp = &gpIniMMAuthMethods;

    while (*ppTemp) {

        if (*ppTemp == pIniMMAuthMethods) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pIniMMAuthMethods->pNext;
    }

    if ((pIniMMAuthMethods->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {
        gpIniDefaultMMAuthMethods = NULL;
    }

    FreeIniMMAuthMethods(pIniMMAuthMethods);

    return (dwError);
}


DWORD
WINAPI
EnumMMAuthMethods(
    LPWSTR pServerName,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumAuthMethods,
    LPDWORD pdwResumeHandle
    )
/*++

Routine Description:

    This function enumerates main mode auth methods from the SPD.

Arguments:

    pServerName - Server on which the main mode auth methods are to
                  be enumerated.

    ppMMAuthMethods - Enumerated main mode auth methods returned to
                      the caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumAuthMethods - Number of main mode auth methods actually
                        enumerated.

    pdwResumeHandle - Handle to the location in the main mode auth
                      methods list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;
    DWORD i = 0;
    PINIMMAUTHMETHODS pTemp = NULL;
    DWORD dwNumAuthMethods = 0;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;
    PMM_AUTH_METHODS pTempMMAuthMethods = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_MMAUTH_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMAUTH_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = gpIniMMAuthMethods;

    for (i = 0; (i < dwResumeHandle) && (pIniMMAuthMethods != NULL); i++) {
        pIniMMAuthMethods = pIniMMAuthMethods->pNext;
    }

    if (!pIniMMAuthMethods) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pTemp = pIniMMAuthMethods;

    while (pTemp && (dwNumAuthMethods < dwNumToEnum)) {
        dwNumAuthMethods++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_AUTH_METHODS)*dwNumAuthMethods,
                  &pMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pTemp = pIniMMAuthMethods;
    pTempMMAuthMethods = pMMAuthMethods;

    for (i = 0; i < dwNumAuthMethods; i++) {

        dwError = CopyMMAuthMethods(
                      pTemp,
                      pTempMMAuthMethods
                      );
        BAIL_ON_LOCK_ERROR(dwError);

        pTemp = pTemp->pNext;
        pTempMMAuthMethods++;

    }

    *ppMMAuthMethods = pMMAuthMethods;
    *pdwResumeHandle = dwResumeHandle + dwNumAuthMethods;
    *pdwNumAuthMethods = dwNumAuthMethods;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if (pMMAuthMethods) {
        FreeMMAuthMethods(
            i,
            pMMAuthMethods
            );
    }

    *ppMMAuthMethods = NULL;
    *pdwResumeHandle = dwResumeHandle;
    *pdwNumAuthMethods = 0;

    return (dwError);
}


DWORD
WINAPI
SetMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS pMMAuthMethods
    )
/*++

Routine Description:

    This function updates main mode auth methods in the SPD.

Arguments:

    pServerName - Server on which the main mode auth methods are to
                  be updated.

    gMMAuthID - Guid of the main mode auth methods to be updated.

    pMMAuthMethods - New main mode auth methods which will replace
                     the existing methods.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;

    
    //
    // Validate main mode auth methods.
    //

    dwError = ValidateMMAuthMethods(
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = FindMMAuthMethods(
                            gpIniMMAuthMethods,
                            gMMAuthID
                            );
    if (!pIniMMAuthMethods) {
        dwError = ERROR_IPSEC_MM_AUTH_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = SetIniMMAuthMethods(
                  pIniMMAuthMethods,
                  pMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniMMAuthMethods->bIsPersisted) {
        dwError = PersistMMAuthMethods(
                      pMMAuthMethods
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    LEAVE_SPD_SECTION();

    (VOID) IKENotifyPolicyChange(
               &(pMMAuthMethods->gMMAuthID),
               POLICY_GUID_AUTH
               );

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    return (dwError);
}


DWORD
SetIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    DWORD dwNumAuthInfos = 0;
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;


    dwError = CreateIniMMAuthInfos(
                  pMMAuthMethods->dwNumAuthInfos,
                  pMMAuthMethods->pAuthenticationInfo,
                  &dwNumAuthInfos,
                  &pAuthenticationInfo
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    FreeIniMMAuthInfos(
        pIniMMAuthMethods->dwNumAuthInfos,
        pIniMMAuthMethods->pAuthenticationInfo
        );
    
    if ((pIniMMAuthMethods->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {
        gpIniDefaultMMAuthMethods = NULL;
    }

    pIniMMAuthMethods->dwFlags = pMMAuthMethods->dwFlags;
    pIniMMAuthMethods->dwNumAuthInfos = dwNumAuthInfos;
    pIniMMAuthMethods->pAuthenticationInfo = pAuthenticationInfo;

    if ((pIniMMAuthMethods->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {
        gpIniDefaultMMAuthMethods = pIniMMAuthMethods;
    }

error:

    return (dwError);
}


DWORD
WINAPI
GetMMAuthMethods(
    LPWSTR pServerName,
    GUID gMMAuthID,
    PMM_AUTH_METHODS * ppMMAuthMethods
    )
/*++

Routine Description:

    This function gets main mode auth methods from the SPD.

Arguments:

    pServerName - Server from which to get the main mode auth methods.

    gMMAuthID - Guid of the main mode auth methods to get.

    ppMMAuthMethods - Main mode auth methods found returned to the
                      caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;


    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = FindMMAuthMethods(
                            gpIniMMAuthMethods,
                            gMMAuthID
                            );
    if (!pIniMMAuthMethods) {
        dwError = ERROR_IPSEC_MM_AUTH_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniMMAuthMethods(
                  pIniMMAuthMethods,
                  &pMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppMMAuthMethods = pMMAuthMethods;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppMMAuthMethods = NULL;
    return (dwError);
}


DWORD
GetIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PMM_AUTH_METHODS * ppMMAuthMethods
    )
{
    DWORD dwError = 0;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(MM_AUTH_METHODS),
                  &pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyMMAuthMethods(
                  pIniMMAuthMethods,
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppMMAuthMethods = pMMAuthMethods;
    return (dwError);

error:

    if (pMMAuthMethods) {
        SPDApiBufferFree(pMMAuthMethods);
    }

    *ppMMAuthMethods = NULL;
    return (dwError);
}


DWORD
CopyMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;

    memcpy(
        &(pMMAuthMethods->gMMAuthID),
        &(pIniMMAuthMethods->gMMAuthID),
        sizeof(GUID)
        );

    pMMAuthMethods->dwFlags = pIniMMAuthMethods->dwFlags;

    dwError = CreateMMAuthInfos(
                  pIniMMAuthMethods->dwNumAuthInfos,
                  pIniMMAuthMethods->pAuthenticationInfo,
                  &(pMMAuthMethods->dwNumAuthInfos),
                  &(pMMAuthMethods->pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
CreateMMAuthInfos(
    DWORD dwInNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pInAuthenticationInfo,
    PDWORD pdwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;
    PIPSEC_MM_AUTH_INFO pInTemp = NULL;
    DWORD i = 0;


    //
    // Number of auth infos and the auth infos themselves 
    // have already been validated.
    // 

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_AUTH_INFO) * dwInNumAuthInfos,
                  &(pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pAuthenticationInfo;
    pInTemp = pInAuthenticationInfo;

    for (i = 0; i < dwInNumAuthInfos; i++) {

        pTemp->AuthMethod = pInTemp->AuthMethod;

        //
        // Auth info size and the auth info have already 
        // been validated.
        // 

        if (pInTemp->AuthMethod == IKE_SSPI) {

            pTemp->dwAuthInfoSize = 0;
            pTemp->pAuthInfo = NULL;

        }
        else {

            dwError = SPDApiBufferAllocate(
                          pInTemp->dwAuthInfoSize,
                          &(pTemp->pAuthInfo)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            pTemp->dwAuthInfoSize = pInTemp->dwAuthInfoSize;

            //
            // Need to catch the exception when the size of auth info
            // specified is more than the actual size. This can
            // not be checked earlier in the validation routine.
            //
            //

            memcpy(
                pTemp->pAuthInfo,
                pInTemp->pAuthInfo,
                pInTemp->dwAuthInfoSize
                );

        }

        pInTemp++;
        pTemp++;

    }

    *pdwNumAuthInfos = dwInNumAuthInfos;
    *ppAuthenticationInfo = pAuthenticationInfo;
    return (dwError);

error:

    if (pAuthenticationInfo) {
        FreeMMAuthInfos(
            i,
            pAuthenticationInfo
            );
    }

    *pdwNumAuthInfos = 0;
    *ppAuthenticationInfo = NULL;
    return (dwError);
}


VOID
FreeMMAuthInfos(
    DWORD dwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo
    )
{
    DWORD i = 0;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;


    if (pAuthenticationInfo) {

        pTemp = pAuthenticationInfo;

        for (i = 0; i < dwNumAuthInfos; i++) {
            if (pTemp->pAuthInfo) {
                SPDApiBufferFree(pTemp->pAuthInfo);
            }
            pTemp++;
        }

        SPDApiBufferFree(pAuthenticationInfo);

    }
}


VOID
FreeIniMMAuthMethodsList(
    PINIMMAUTHMETHODS pIniMMAuthMethodsList
    )
{
    PINIMMAUTHMETHODS pTemp = NULL;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;


    pTemp = pIniMMAuthMethodsList;

    while (pTemp) {

         pIniMMAuthMethods = pTemp;
         pTemp = pTemp->pNext;

         FreeIniMMAuthMethods(pIniMMAuthMethods);

    }
}


VOID
FreeMMAuthMethods(
    DWORD dwNumAuthMethods,
    PMM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD i = 0;

    if (pMMAuthMethods) {

        for (i = 0; i < dwNumAuthMethods; i++) {

            FreeMMAuthInfos(
                pMMAuthMethods[i].dwNumAuthInfos,
                pMMAuthMethods[i].pAuthenticationInfo
                );

        }

        SPDApiBufferFree(pMMAuthMethods);

    }
}


DWORD
LocateMMAuthMethods(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS * ppIniMMAuthMethods
    )
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;


    if ((pMMFilter->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {

        if (!gpIniDefaultMMAuthMethods) {
            dwError = ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pIniMMAuthMethods = gpIniDefaultMMAuthMethods;

    }
    else {

        pIniMMAuthMethods = FindMMAuthMethods(
                                gpIniMMAuthMethods,
                                pMMFilter->gMMAuthID
                                );
        if (!pIniMMAuthMethods) {
            dwError = ERROR_IPSEC_MM_AUTH_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    *ppIniMMAuthMethods = pIniMMAuthMethods;
    return (dwError);

error:

    *ppIniMMAuthMethods = NULL;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmf-load.h ===
DWORD
LoadPersistedMMFilters(
    HKEY hParentRegKey
    );

DWORD
SPDReadMMFilter(
    HKEY hParentRegKey,
    LPWSTR pszMMFilterUniqueID,
    PMM_FILTER * ppMMFilter
    );

DWORD
UnMarshallMMFilterBuffer(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PMM_FILTER pMMFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmf-load.c ===
#include "precomp.h"


DWORD
LoadPersistedMMFilters(
    HKEY hParentRegKey
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;
    WCHAR szMMFilterUniqueID[MAX_PATH];
    DWORD dwIndex = 0;
    PMM_FILTER pMMFilter = NULL;
    LPWSTR pszServerName = NULL;
    HANDLE hMMFilter = NULL;
    DWORD dwPersist = 0;


    dwPersist |= PERSIST_SPD_OBJECT;

    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  L"MM Filters",
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    while (1) {

        dwSize = MAX_PATH;
        szMMFilterUniqueID[0] = L'\0';

        dwError = RegEnumKeyExW(
                      hRegKey,
                      dwIndex,
                      szMMFilterUniqueID,
                      &dwSize,
                      NULL,
                      NULL,
                      0,
                      0
                      );

        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        }

        BAIL_ON_WIN32_ERROR(dwError);

        dwError = SPDReadMMFilter(
                      hRegKey,
                      szMMFilterUniqueID,
                      &pMMFilter
                      );

        if (dwError) {
            dwIndex++;
            continue;
        }

        dwError = AddMMFilter(
                      pszServerName,
                      dwPersist,
                      pMMFilter,
                      &hMMFilter
                      );

        if (pMMFilter) {
            FreeMMFilters(
                1,
                pMMFilter
                );
        }

        if (hMMFilter) {
            CloseMMFilterHandle(hMMFilter);
        }

        dwIndex++;

    }

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
SPDReadMMFilter(
    HKEY hParentRegKey,
    LPWSTR pszMMFilterUniqueID,
    PMM_FILTER * ppMMFilter
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    PMM_FILTER pMMFilter = NULL;
    LPWSTR pszFilterID = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    DWORD dwInterfaceType = 0;
    DWORD dwMirrored = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    LPWSTR pszPolicyID = NULL;
    LPWSTR pszAuthID = NULL;


    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  pszMMFilterUniqueID,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter = (PMM_FILTER) AllocSPDMem(
                                   sizeof(MM_FILTER)
                                   );
    if (!pMMFilter) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"FilterID",
                  REG_SZ,
                  (LPBYTE *)&pszFilterID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszFilterID,
        &pMMFilter->gFilterID
        );

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"FilterName",
                  REG_SZ,
                  (LPBYTE *)&pMMFilter->pszFilterName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"InterfaceType",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwInterfaceType,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->InterfaceType = (IF_TYPE) dwInterfaceType;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"Mirrored",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwMirrored,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->bCreateMirror = (BOOL) dwMirrored;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"Flags",
                  NULL,
                  &dwType,
                  (LPBYTE)&pMMFilter->dwFlags,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"MM Filter Buffer",
                  REG_BINARY,
                  (LPBYTE *)&pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallMMFilterBuffer(
                  pBuffer,
                  dwBufferSize,
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->dwDirection = 0;

    pMMFilter->dwWeight = 0;

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"PolicyID",
                  REG_SZ,
                  (LPBYTE *)&pszPolicyID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszPolicyID,
        &pMMFilter->gPolicyID
        );

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"AuthID",
                  REG_SZ,
                  (LPBYTE *)&pszAuthID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszAuthID,
        &pMMFilter->gMMAuthID
        );

    *ppMMFilter = pMMFilter;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszFilterID) {
        FreeSPDStr(pszFilterID);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    if (pszPolicyID) {
        FreeSPDStr(pszPolicyID);
    }

    if (pszAuthID) {
        FreeSPDStr(pszAuthID);
    }

    return (dwError);

error:

    *ppMMFilter = NULL;

    if (pMMFilter) {
        FreeMMFilters(
            1,
            pMMFilter
            );
    }

    goto cleanup;
}


DWORD
UnMarshallMMFilterBuffer(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    LPBYTE pMem = NULL;


    pMem = pBuffer;

    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);

    memcpy(
        (LPBYTE) &pMMFilter->SrcAddr,
        pMem,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        (LPBYTE) &pMMFilter->DesAddr,
        pMem,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmf-pers.h ===
DWORD
PersistMMFilter(
    GUID gFilterID,
    PMM_FILTER pMMFilter
    );

DWORD
SPDWriteMMFilter(
    HKEY hParentRegKey,
    GUID gFilterID,
    PMM_FILTER pMMFilter
    );

DWORD
MarshallMMFilterBuffer(
    PMM_FILTER pMMFilter,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    );

DWORD
SPDPurgeMMFilter(
    GUID gMMFilterID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmfilter.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmfilter.c

Abstract:

    This module contains all of the code to drive
    the main mode filter list management of IPSecSPD
    Service.

Author:


Environment: User Mode


Revision History:


--*/


#include "precomp.h"


DWORD
AddMMFilter(
    LPWSTR pServerName,
    DWORD dwFlags,
    PMM_FILTER pMMFilter,
    PHANDLE phMMFilter
    )
/*++

Routine Description:

    This function adds a generic MM filter to the SPD.

Arguments:

    pServerName - Server on which the MM filter is to be added.

    pMMFilter - MM Filter to be added.

    phMMFilter -  Handle to the filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMFILTER pIniExistsMMFilter = NULL;
    PINIMMFILTER pIniMMFilter = NULL;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;
    PINIMMPOLICY pIniMMPolicy = NULL;
    PINIMMSFILTER pIniMMSFilters = NULL;
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    BOOL bPersist = FALSE;


    bPersist = (BOOL) (dwFlags & PERSIST_SPD_OBJECT);

    if (!phMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external MM filter.
    //

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistsMMFilter = FindMMFilter(
                             gpIniMMFilter,
                             pMMFilter
                             );
    if (pIniExistsMMFilter) {
        dwError = ERROR_IPSEC_MM_FILTER_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniExistsMMFilter = FindMMFilterByGuid(
                             gpMMFilterHandle,
                             pMMFilter->gFilterID
                             );
    if (pIniExistsMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = LocateMMAuthMethods(
                  pMMFilter,
                  &pIniMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = LocateMMPolicy(
                  pMMFilter,
                  &pIniMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (bPersist && !gbLoadingPersistence) {
        dwError = PersistMMFilter(
                      pMMFilter->gFilterID,
                      pMMFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateIniMMFilter(
                  pMMFilter,
                  pIniMMAuthMethods,
                  pIniMMPolicy,
                  &pIniMMFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMFilter->bIsPersisted = bPersist;

    dwError = GetMatchingInterfaces(
                  pIniMMFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateIniMMSFilters(
                  pIniMMFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pIniMMSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateMMFilterHandle(
                  pIniMMFilter,
                  pMMFilter->gFilterID,
                  &pMMFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateSpecificMMFilterLinks(
                  pIniMMFilter,
                  pIniMMSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniMMAuthMethods) {
        LinkMMFilterToAuth(
            pIniMMAuthMethods,
            pIniMMFilter
            );
        LinkMMSpecificFiltersToAuth(
            pIniMMAuthMethods,
            pIniMMSFilters
            );
    }

    if (pIniMMPolicy) {
        LinkMMFilterToPolicy(
            pIniMMPolicy,
            pIniMMFilter
            );
        LinkMMSpecificFiltersToPolicy(
            pIniMMPolicy,
            pIniMMSFilters
            );
    }

    AddToSpecificMMList(
        &gpIniMMSFilter,
        pIniMMSFilters
        );

    pIniMMFilter->cRef = 1;
    pIniMMFilter->pNext = gpIniMMFilter;
    gpIniMMFilter = pIniMMFilter;

    pMMFilterHandle->pNext = gpMMFilterHandle;
    gpMMFilterHandle = pMMFilterHandle;

    *phMMFilter = (HANDLE) pMMFilterHandle;
    LEAVE_SPD_SECTION();

cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMMFilter && bPersist && !gbLoadingPersistence) {
        (VOID) SPDPurgeMMFilter(
                   pMMFilter->gFilterID
                   );
    }

    if (pIniMMFilter) {
        FreeIniMMFilter(pIniMMFilter);
    }

    if (pIniMMSFilters) {
        FreeIniMMSFilterList(pIniMMSFilters);
    }

    if (pMMFilterHandle) {
        FreeMMFilterHandle(pMMFilterHandle);
    }

    *phMMFilter = NULL;
    goto cleanup;
}


DWORD
ValidateMMFilter(
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function validates an external generic MM filter.

Arguments:

    pMMFilter - Filter to validate.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pMMFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pMMFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pMMFilter->SrcAddr,
                     pMMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilter->pszFilterName) || !(*(pMMFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->InterfaceType >= INTERFACE_TYPE_MAX) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->dwFlags &&
        !(pMMFilter->dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY) &&
        !(pMMFilter->dwFlags & IPSEC_MM_AUTH_DEFAULT_AUTH)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ApplyMulticastFilterValidation(
                  pMMFilter->DesAddr,
                  pMMFilter->bCreateMirror
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


PINIMMFILTER
FindMMFilterByGuid(
    PMM_FILTER_HANDLE pMMFilterHandleList,
    GUID gFilterID
    )
{
    BOOL bEqual = FALSE;
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;


    pMMFilterHandle = pMMFilterHandleList;

    while (pMMFilterHandle) {

        bEqual = AreGuidsEqual(
                     pMMFilterHandle->gFilterID,
                     gFilterID
                     );
        if (bEqual) {
            return (pMMFilterHandle->pIniMMFilter);
        }
        pMMFilterHandle = pMMFilterHandle->pNext;

    }

    return (NULL);
}


PINIMMFILTER
FindMMFilter(
    PINIMMFILTER pGenericMMList,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function looks for a filter in the filter list.

Arguments:

    pGenericMMList - Filter list in which to search.

    pMMFilter - Filter to search for in the filter list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    PINIMMFILTER pIniMMFilter = NULL;
    BOOL bEqual = FALSE;

    pIniMMFilter = pGenericMMList;

    while (pIniMMFilter) {

        bEqual = EqualMMFilterPKeys(
                     pIniMMFilter,
                     pMMFilter
                     );
        if (bEqual) {
            return (pIniMMFilter);
        }

        bEqual = EqualMirroredMMFilterPKeys(
                     pIniMMFilter,
                     pMMFilter
                     );
        if (bEqual) {
            return (pIniMMFilter);
        }

        pIniMMFilter = pIniMMFilter->pNext;

    }

    return (NULL);
}


BOOL
EqualMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function compares an internal and an external main mode
    filter for equality.

Arguments:

    pIniMMFilter - Filter to compare.

    pMMFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniMMFilter->SrcAddr, pMMFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniMMFilter->DesAddr, pMMFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniMMFilter->InterfaceType != pMMFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniMMFilter->bCreateMirror != pMMFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateIniMMFilter(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER * ppIniMMFilter
    )
/*++

Routine Description:

    This function creates an internal generic MM filter from
    the external filter.

Arguments:

    pMMFilter - External generic MM filter.

    pIniMMAuthMethods - MM Auth Methods corresponding to the filter.

    pIniMMPolicy - MM Policy corresponding to the filter.

    ppIniMMFilter - Internal generic MM filter created from
                    the external filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMFILTER pIniMMFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INIMMFILTER),
                    &pIniMMFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniMMFilter->cRef = 0;

    pIniMMFilter->bIsPersisted = FALSE;

    pIniMMFilter->bPendingDeletion = FALSE;

    CopyGuid(pMMFilter->gFilterID, &(pIniMMFilter->gFilterID));

    dwError = AllocateSPDString(
                  pMMFilter->pszFilterName,
                  &(pIniMMFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniMMFilter->InterfaceType = pMMFilter->InterfaceType;

    pIniMMFilter->bCreateMirror = pMMFilter->bCreateMirror;

    pIniMMFilter->dwFlags = pMMFilter->dwFlags;

    CopyAddresses(pMMFilter->SrcAddr, &(pIniMMFilter->SrcAddr));

    CopyAddresses(pMMFilter->DesAddr, &(pIniMMFilter->DesAddr));

    if (pIniMMAuthMethods) {
        CopyGuid(pIniMMAuthMethods->gMMAuthID, &(pIniMMFilter->gMMAuthID));
    }
    else {
        CopyGuid(pMMFilter->gMMAuthID, &(pIniMMFilter->gMMAuthID));
    }

    if (pIniMMPolicy) {
        CopyGuid(pIniMMPolicy->gPolicyID, &(pIniMMFilter->gPolicyID));
    }
    else {
        CopyGuid(pMMFilter->gPolicyID, &(pIniMMFilter->gPolicyID));
    }

    pIniMMFilter->pIniMMAuthMethods = NULL;

    pIniMMFilter->pIniMMPolicy = NULL;

    pIniMMFilter->dwNumMMSFilters = 0;

    pIniMMFilter->ppIniMMSFilters = NULL;

    pIniMMFilter->pNext = NULL;

    *ppIniMMFilter = pIniMMFilter;
    return (dwError);

error:

    if (pIniMMFilter) {
        FreeIniMMFilter(pIniMMFilter);
    }

    *ppIniMMFilter = NULL;
    return (dwError);
}


DWORD
CreateIniMMSFilters(
    PINIMMFILTER pIniMMFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINIMMSFILTER * ppIniMMSFilters
    )
/*++

Routine Description:

    This function expands a generic filter into a set of specific
    filters.

Arguments:

    pIniMMFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Count of local ip addresses in the list.

    ppIniMMSFilters - Expanded specific filters.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMSFILTER pSpecificFilters = NULL;
    PINIMMFILTER pMirroredFilter = NULL;
    PINIMMSFILTER pMirroredSpecificFilters = NULL;
    BOOL bEqual = FALSE;


    if (!dwAddrCnt) {
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    dwError = ApplyMMTransform(
                  pIniMMFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniMMFilter->bCreateMirror) {

        dwError = CreateIniMirroredMMFilter(
                      pIniMMFilter,
                      &pMirroredFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        bEqual = EqualIniMMFilterPKeys(
                     pIniMMFilter,
                     pMirroredFilter
                     );
        if (!bEqual) {

            dwError = ApplyMMTransform(
                          pMirroredFilter,
                          pMatchingAddresses,
                          dwAddrCnt,
                          &pMirroredSpecificFilters
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            AddToSpecificMMList(
                &pSpecificFilters,
                pMirroredSpecificFilters
                );

        }

    }

    *ppIniMMSFilters = pSpecificFilters;

cleanup:

    if (pMirroredFilter) {
        FreeIniMMFilter(pMirroredFilter);
    }

    return (dwError);

success:
error:

    if (pSpecificFilters) {
        FreeIniMMSFilterList(pSpecificFilters);
    }

    *ppIniMMSFilters = NULL;
    goto cleanup;
}


DWORD
CreateIniMirroredMMFilter(
    PINIMMFILTER pFilter,
    PINIMMFILTER * ppMirroredFilter
    )
/*++

Routine Description:

    This function creates a mirrored filter for the given filter.

Arguments:

    pFilter - Filter for which to create the mirror.

    ppMirroredFilter - Mirrored filter created for the given filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMFILTER pMirroredFilter = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INIMMFILTER),
                  &pMirroredFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->cRef = pFilter->cRef;

    pMirroredFilter->bIsPersisted = pFilter->bIsPersisted;

    pMirroredFilter->bPendingDeletion = pFilter->bPendingDeletion;

    CopyGuid(pFilter->gFilterID, &(pMirroredFilter->gFilterID));

    dwError = AllocateSPDString(
                  pFilter->pszFilterName,
                  &(pMirroredFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->InterfaceType = pFilter->InterfaceType;

    pMirroredFilter->bCreateMirror = pFilter->bCreateMirror;

    pMirroredFilter->dwFlags = pFilter->dwFlags;

    CopyAddresses(pFilter->DesAddr, &(pMirroredFilter->SrcAddr));

    CopyAddresses(pFilter->SrcAddr, &(pMirroredFilter->DesAddr));

    CopyGuid(pFilter->gMMAuthID, &(pMirroredFilter->gMMAuthID));

    CopyGuid(pFilter->gPolicyID, &(pMirroredFilter->gPolicyID));

    pMirroredFilter->pIniMMAuthMethods = NULL;

    pMirroredFilter->pIniMMPolicy = NULL;

    pMirroredFilter->dwNumMMSFilters = 0;

    pMirroredFilter->ppIniMMSFilters = NULL;

    pMirroredFilter->pNext = NULL;

    *ppMirroredFilter = pMirroredFilter;
    return (dwError);

error:

    if (pMirroredFilter) {
        FreeIniMMFilter(pMirroredFilter);
    }

    *ppMirroredFilter = NULL;
    return (dwError);
}


BOOL
EqualIniMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PINIMMFILTER pFilter
    )
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniMMFilter->SrcAddr, pFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniMMFilter->DesAddr, pFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniMMFilter->InterfaceType != pFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniMMFilter->bCreateMirror != pFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateMMFilterHandle(
    PINIMMFILTER pIniMMFilter,
    GUID gFilterID,
    PMM_FILTER_HANDLE * ppMMFilterHandle
    )
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(MM_FILTER_HANDLE),
                    &pMMFilterHandle
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilterHandle->pIniMMFilter= pIniMMFilter;
    CopyGuid(gFilterID, &(pMMFilterHandle->gFilterID));
    pMMFilterHandle->pNext = NULL;

    *ppMMFilterHandle = pMMFilterHandle;
    return (dwError);

error:

    *ppMMFilterHandle = NULL;
    return (dwError);
}


DWORD
CreateSpecificMMFilterLinks(
    PINIMMFILTER pIniMMFilter,
    PINIMMSFILTER pIniMMSFilters
    )
{
    DWORD dwError = 0;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwCnt = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniMMSFilters;

    while (pTemp) {
        dwCnt++;
        pTemp = pTemp->pNext;
    }

    if (!dwCnt) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIniMMFilter->ppIniMMSFilters = (PINIMMSFILTER *)
                                    AllocSPDMem(
                                        sizeof(PINIMMSFILTER)*dwCnt
                                        );
    if (!(pIniMMFilter->ppIniMMSFilters)) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);    
    }

    pTemp = pIniMMSFilters;
    ppIniMMSFilters = pIniMMFilter->ppIniMMSFilters;

    for (i = 0; i < dwCnt; i++) {
        *(ppIniMMSFilters + i) = pTemp; 
        pTemp = pTemp->pNext;
    }
    pIniMMFilter->dwNumMMSFilters = dwCnt;

error:

    return (dwError);
}


VOID
LinkMMFilterToPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER pIniMMFilter
    )
{
    pIniMMPolicy->cRef++;
    pIniMMFilter->pIniMMPolicy = pIniMMPolicy;
    return;
}


VOID
LinkMMFilterToAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMFILTER pIniMMFilter
    )
{
    pIniMMAuthMethods->cRef++;
    pIniMMFilter->pIniMMAuthMethods = pIniMMAuthMethods;
    return;
}


VOID
FreeIniMMFilterList(
    PINIMMFILTER pIniMMFilterList
    )
{
    PINIMMFILTER pFilter = NULL;
    PINIMMFILTER pTempFilter = NULL;

    pFilter = pIniMMFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniMMFilter(pTempFilter);
    }
}


VOID
FreeIniMMFilter(
    PINIMMFILTER pIniMMFilter
    )
{
    if (pIniMMFilter) {
        if (pIniMMFilter->pszFilterName) {
            FreeSPDString(pIniMMFilter->pszFilterName);
        }

        //
        // Must not ever free pIniMMFilter->pIniMMPolicy.
        //

        //
        // Must not ever free memory pointed by each of
        // the pointers in pIniMMFilter->ppIniMMSFilters.
        //

        if (pIniMMFilter->ppIniMMSFilters) {
            FreeSPDMemory(pIniMMFilter->ppIniMMSFilters);
        }

        FreeSPDMemory(pIniMMFilter);
    }
}


DWORD
DeleteMMFilter(
    HANDLE hMMFilter
    )
/*++

Routine Description:

    This function deletes a generic MM filter from the SPD.

Arguments:

    hMMFilter -  Handle to the filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pFilterHandle = NULL;
    PINIMMFILTER pIniMMFilter = NULL;
    GUID gFilterID;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PMM_FILTER_HANDLE) hMMFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMFilter = pFilterHandle->pIniMMFilter;

    if (!pIniMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMFilter->cRef > 1) {

        pIniMMFilter->cRef--;
        pIniMMFilter->bPendingDeletion = TRUE;

        RemoveMMFilterHandle(
            pFilterHandle
            );

        FreeMMFilterHandle(
            pFilterHandle
            );

        dwError = ERROR_SUCCESS;
        LEAVE_SPD_SECTION();
        return (dwError);

    }

    memcpy(&gFilterID, &pIniMMFilter->gFilterID, sizeof(GUID));

    if (pIniMMFilter->bIsPersisted) {
        dwError = SPDPurgeMMFilter(
                      pIniMMFilter->gFilterID
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = DeleteIniMMFilter(
                  pIniMMFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    //
    // Delete the filter handle from the list of MM handles.
    //

    RemoveMMFilterHandle(
        pFilterHandle
        );

    FreeMMFilterHandle(
        pFilterHandle
        );

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gFilterID),
                   POLICY_GUID_MM_FILTER
                   );
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    return (dwError);
}


DWORD
DeleteIniMMFilter(
    PINIMMFILTER pIniMMFilter
    )
/*++

Routine Description:

    This function physically deletes a mm filter and all the
    specific mm filters expanded out of it.

Arguments:

    pIniMMFilter - Generic filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    if (pIniMMFilter->pIniMMAuthMethods) {
        DelinkMMFilterFromAuth(
            pIniMMFilter->pIniMMAuthMethods,
            pIniMMFilter
            );
    }

    if (pIniMMFilter->pIniMMPolicy) {
        DelinkMMFilterFromPolicy(
            pIniMMFilter->pIniMMPolicy,
            pIniMMFilter
            );
    }

    DeleteIniMMSFilters(
        pIniMMFilter
        );

    RemoveIniMMFilter(
        pIniMMFilter
        );

    FreeIniMMFilter(pIniMMFilter);

    return (ERROR_SUCCESS);
}


VOID
DelinkMMFilterFromPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER pIniMMFilter
    )
{
    pIniMMPolicy->cRef--;
    pIniMMFilter->pIniMMPolicy = NULL;
    return;
}


VOID
DelinkMMFilterFromAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMFILTER pIniMMFilter
    )
{
    pIniMMAuthMethods->cRef--;
    pIniMMFilter->pIniMMAuthMethods = NULL;
    return;
}


VOID
DeleteIniMMSFilters(
    PINIMMFILTER pIniMMFilter
    )
{
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD dwNumMMSFilters = 0;
    DWORD i = 0;
    PINIMMSFILTER pIniMMSFilter = NULL;
    PINIMMSFILTER pIniRemoveMMSFilter = NULL;
    PINIMMSFILTER pTemp = NULL;


    ppIniMMSFilters = pIniMMFilter->ppIniMMSFilters;
    dwNumMMSFilters = pIniMMFilter->dwNumMMSFilters;

    for (i = 0; i < dwNumMMSFilters; i++) {

       //
       // Remove each entry from the MM Specific Filter List.
       //

        pIniMMSFilter =  *(ppIniMMSFilters + i);
        RemoveIniMMSFilter(pIniMMSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniMMSFilter->pNext = NULL;
        AddToSpecificMMList(
            &pIniRemoveMMSFilter,
            pIniMMSFilter
            );

    }

    //
    // Physically delete the removed list.
    //

    while (pIniRemoveMMSFilter) {
        pTemp = pIniRemoveMMSFilter;
        pIniRemoveMMSFilter = pIniRemoveMMSFilter->pNext;
        FreeIniMMSFilter(pTemp);
    }

    return;
}


VOID
RemoveIniMMFilter(
    PINIMMFILTER pIniMMFilter
    )
{
    PINIMMFILTER * ppTemp = NULL;

    ppTemp = &gpIniMMFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniMMFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniMMFilter->pNext;
    }

    return;
}


VOID
RemoveMMFilterHandle(
    PMM_FILTER_HANDLE pMMFilterHandle
    )
{
    PMM_FILTER_HANDLE * ppTemp = NULL;

    ppTemp = &gpMMFilterHandle;

    while (*ppTemp) {

        if (*ppTemp == pMMFilterHandle) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pMMFilterHandle->pNext;
    }

    return;
}


VOID
FreeMMFilterHandleList(
    PMM_FILTER_HANDLE pMMFilterHandleList
    )
{
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;
    PMM_FILTER_HANDLE pTemp = NULL;

    pMMFilterHandle = pMMFilterHandleList;

    while (pMMFilterHandle) {
        pTemp = pMMFilterHandle;
        pMMFilterHandle = pMMFilterHandle->pNext;
        FreeMMFilterHandle(pTemp);
    }
}


VOID
FreeMMFilterHandle(
    PMM_FILTER_HANDLE pMMFilterHandle
    )
{
    if (pMMFilterHandle) {
        FreeSPDMemory(pMMFilterHandle);
    }
    return;
}


DWORD
EnumMMFilters(
    LPWSTR pServerName,
    DWORD dwLevel,
    GUID gGenericFilterID,  
    PMM_FILTER * ppMMFilters,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMMFilters,
    LPDWORD pdwResumeHandle
    )
/*++

Routine Description:

    This function enumerates main mode filters from the SPD.

Arguments:

    pServerName - Server on which the filters are to be enumerated.

    dwLevel - Level to identify the type of enumeration desired:
              (i) enumerate generic mm filters or
              (ii) enumerate specific mm filters or
              (iii) enumerate specific mm filters for a generic mm
                    filter.

    gGenericFilterID - Filter id of the generic mm filter in the 
                       case when the specific mm filters for a
                       generic filter are to be enumerated.
 
    ppMMFilters - Enumerated Filters returned to the caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumMMFilters - Number of filters actually enumerated.

    pdwResumeHandle - Handle to the location in the filter list from
                      which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilters = 0;
    DWORD dwNumMMFilters = 0;
    PINIMMFILTER pIniMMFilter = NULL;


    if (!ppMMFilters || !pdwNumMMFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:

        dwError = EnumGenericMMFilters(
                      gpIniMMFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pMMFilters,
                      &dwNumMMFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SELECT_SPECIFIC_FILTERS:

        pIniMMFilter = FindMMFilterByGuid(
                           gpMMFilterHandle,
                           gGenericFilterID
                           );
        if (!pIniMMFilter) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        dwError = EnumSelectSpecificMMFilters(
                      pIniMMFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pMMFilters,
                      &dwNumMMFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SPECIFIC_FILTERS:

        dwError = EnumSpecificMMFilters(
                      gpIniMMSFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pMMFilters,
                      &dwNumMMFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    default:

        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    }

    *ppMMFilters = pMMFilters;
    *pdwNumMMFilters = dwNumMMFilters;
    *pdwResumeHandle = *pdwResumeHandle + dwNumMMFilters;

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;
    *pdwResumeHandle = *pdwResumeHandle;

    return (dwError);
}


DWORD
EnumGenericMMFilters(
    PINIMMFILTER pIniMMFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    )
/*++

Routine Description:

    This function creates enumerated generic filters.

Arguments:

    pIniMMFilterList - List of generic filters to enumerate.

    dwResumeHandle - Location in the generic filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppMMFilters - Enumerated filters returned to the caller.

    pdwNumMMFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINIMMFILTER pIniMMFilter = NULL;
    DWORD i = 0;
    PINIMMFILTER pTemp = NULL;
    DWORD dwNumMMFilters = 0;
    PMM_FILTER pMMFilters = 0;
    PMM_FILTER pMMFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_MMFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniMMFilter = pIniMMFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniMMFilter != NULL); i++) {
        pIniMMFilter = pIniMMFilter->pNext;
    }

    if (!pIniMMFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniMMFilter;

    while (pTemp && (dwNumMMFilters < dwNumToEnum)) {
        dwNumMMFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER)*dwNumMMFilters,
                  &pMMFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniMMFilter;
    pMMFilter = pMMFilters;

    for (i = 0; i < dwNumMMFilters; i++) {

        dwError = CopyMMFilter(
                      pTemp,
                      pMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pMMFilter++;

    }

    *ppMMFilters = pMMFilters;
    *pdwNumMMFilters = dwNumMMFilters;
    return (dwError);

error:

    if (pMMFilters) {
        FreeMMFilters(
            i,
            pMMFilters
            );
    }

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;

    return (dwError);
}


DWORD
CopyMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniMMFilter - Internal filter to copy.

    pMMFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    CopyGuid(pIniMMFilter->gFilterID, &(pMMFilter->gFilterID));

    dwError = CopyName(
                  pIniMMFilter->pszFilterName,
                  &(pMMFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->InterfaceType = pIniMMFilter->InterfaceType;

    pMMFilter->bCreateMirror = pIniMMFilter->bCreateMirror;

    pMMFilter->dwFlags = pIniMMFilter->dwFlags;

    CopyAddresses(pIniMMFilter->SrcAddr, &(pMMFilter->SrcAddr));

    CopyAddresses(pIniMMFilter->DesAddr, &(pMMFilter->DesAddr));

    pMMFilter->dwDirection = 0;

    pMMFilter->dwWeight = 0;

    CopyGuid(pIniMMFilter->gMMAuthID, &(pMMFilter->gMMAuthID));

    CopyGuid(pIniMMFilter->gPolicyID, &(pMMFilter->gPolicyID));

error:

    return (dwError);
}


VOID
FreeMMFilters(
    DWORD dwNumMMFilters,
    PMM_FILTER pMMFilters
    )
{
    DWORD i = 0;

    if (pMMFilters) {

        for (i = 0; i < dwNumMMFilters; i++) {

            if (pMMFilters[i].pszFilterName) {
                SPDApiBufferFree(pMMFilters[i].pszFilterName);
            }

        }

        SPDApiBufferFree(pMMFilters);

    }

}


DWORD
SetMMFilter(
    HANDLE hMMFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function sets (updates) a mm filter in the SPD.

Arguments:

    hMMFilter - Handle to the filter to be replaced.

    pMMFilter - Filter that will replace the existing filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pFilterHandle = NULL;
    PINIMMFILTER pIniMMFilter = NULL;
    BOOL bEqualPKeys = FALSE;
    GUID gFilterID;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PMM_FILTER_HANDLE) hMMFilter;

    pIniMMFilter = pFilterHandle->pIniMMFilter;

    if (!pIniMMFilter) {
        dwError = ERROR_IPSEC_MM_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMFilter->bPendingDeletion) {
        dwError = ERROR_IPSEC_MM_FILTER_PENDING_DELETION;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    bEqualPKeys = EqualMMFilterPKeys(
                      pIniMMFilter,
                      pMMFilter
                      );
    if (!bEqualPKeys) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    memcpy(&gFilterID, &pIniMMFilter->gFilterID, sizeof(GUID));

    dwError = SetIniMMFilter(
                  pIniMMFilter,
                  pMMFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniMMFilter->bIsPersisted) {
        dwError = PersistMMFilter(
                      pIniMMFilter->gFilterID,
                      pMMFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);
    }

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gFilterID),
                   POLICY_GUID_MM_FILTER
                   );
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    return (dwError);
}


DWORD
SetIniMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bEqualNonPKeys = FALSE;
    PINIMMAUTHMETHODS pIniNewMMAuthMethods = NULL;
    PINIMMPOLICY pIniNewMMPolicy = NULL;
    PINIMMFILTER pIniNewMMFilter = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINIMMSFILTER pIniNewMMSFilters = NULL;
    DWORD dwNumMMSFilters = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    LPWSTR pszFilterName = NULL;
    PINIMMSFILTER pIniCurMMSFilters = NULL;


    bEqualNonPKeys = EqualMMFilterNonPKeys(
                         pIniMMFilter,
                         pMMFilter
                         );
    if (bEqualNonPKeys) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = LocateMMAuthMethods(
                  pMMFilter,
                  &pIniNewMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LocateMMPolicy(
                  pMMFilter,
                  &pIniNewMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniMMFilter(
                  pMMFilter,
                  pIniNewMMAuthMethods,
                  pIniNewMMPolicy,
                  &pIniNewMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GetMatchingInterfaces(
                  pIniNewMMFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniMMSFilters(
                  pIniNewMMFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pIniNewMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateMMSFilterLinks(
                  pIniNewMMSFilters,
                  &dwNumMMSFilters,
                  &ppIniMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateSPDString(
                  pMMFilter->pszFilterName,
                  &pszFilterName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveMMSFilters(
        pIniMMFilter,
        &pIniCurMMSFilters
        );

    UpdateMMSFilterLinks(
        pIniMMFilter,
        dwNumMMSFilters,
        ppIniMMSFilters
        );

    if (pIniMMFilter->pIniMMAuthMethods) {
        DelinkMMFilterFromAuth(
            pIniMMFilter->pIniMMAuthMethods,
            pIniMMFilter
            );
    }

    if (pIniMMFilter->pIniMMPolicy) {
        DelinkMMFilterFromPolicy(
            pIniMMFilter->pIniMMPolicy,
            pIniMMFilter
            );
    }

    if (pIniNewMMAuthMethods) {
        LinkMMFilterToAuth(
            pIniNewMMAuthMethods,
            pIniMMFilter
            );
        LinkMMSpecificFiltersToAuth(
            pIniNewMMAuthMethods,
            pIniNewMMSFilters
            );
    }

    if (pIniNewMMPolicy) {
        LinkMMFilterToPolicy(
            pIniNewMMPolicy,
            pIniMMFilter
            );
        LinkMMSpecificFiltersToPolicy(
            pIniNewMMPolicy,
            pIniNewMMSFilters
            );
    }

    UpdateMMFilterNonPKeys(
        pIniMMFilter,
        pszFilterName,
        pMMFilter,
        pIniNewMMAuthMethods,
        pIniNewMMPolicy
        );

    AddToSpecificMMList(
        &gpIniMMSFilter,
        pIniNewMMSFilters
        );

    if (pIniCurMMSFilters) {
        FreeIniMMSFilterList(pIniCurMMSFilters);
    }

cleanup:

    if (pIniNewMMFilter) {
        FreeIniMMFilter(pIniNewMMFilter);
    }

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    if (pIniNewMMSFilters) {
        FreeIniMMSFilterList(pIniNewMMSFilters);
    }

    if (ppIniMMSFilters) {
        FreeSPDMemory(ppIniMMSFilters);
    }

    if (pszFilterName) {
        FreeSPDString(pszFilterName);
    }

    goto cleanup;
}


BOOL
EqualMMFilterNonPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
{
    if (_wcsicmp(
            pIniMMFilter->pszFilterName,
            pMMFilter->pszFilterName)) {
        return (FALSE);
    }

    if ((pIniMMFilter->dwFlags) != (pMMFilter->dwFlags)) {
        return (FALSE);
    }

    if (memcmp(
            &(pIniMMFilter->gMMAuthID),
            &(pMMFilter->gMMAuthID),
            sizeof(GUID))) {
        return (FALSE);
    }

    if (memcmp(
            &(pIniMMFilter->gPolicyID),
            &(pMMFilter->gPolicyID),
            sizeof(GUID))) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateMMSFilterLinks(
    PINIMMSFILTER pIniMMSFilters,
    PDWORD pdwNumMMSFilters,
    PINIMMSFILTER ** pppIniMMSFilters
    )
{
    DWORD dwError = 0;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwNumMMSFilters = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniMMSFilters;
    while (pTemp) {
        dwNumMMSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumMMSFilters) {
        ppIniMMSFilters = (PINIMMSFILTER *)
                          AllocSPDMem(
                              sizeof(PINIMMSFILTER)*
                              dwNumMMSFilters
                              );
        if (!ppIniMMSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    pTemp = pIniMMSFilters;
    for (i = 0; i < dwNumMMSFilters; i++) {
        *(ppIniMMSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    *pdwNumMMSFilters = dwNumMMSFilters;
    *pppIniMMSFilters = ppIniMMSFilters;
    return (dwError);

error:

    *pdwNumMMSFilters = 0;
    *pppIniMMSFilters = NULL;
    return (dwError);
}


VOID
RemoveMMSFilters(
    PINIMMFILTER pIniMMFilter,
    PINIMMSFILTER * ppIniCurMMSFilters 
    )
{
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD dwNumMMSFilters = 0;
    DWORD i = 0;
    PINIMMSFILTER pIniMMSFilter = NULL;
    PINIMMSFILTER pIniCurMMSFilters = NULL;


    ppIniMMSFilters = pIniMMFilter->ppIniMMSFilters;
    dwNumMMSFilters = pIniMMFilter->dwNumMMSFilters;

    for (i = 0; i < dwNumMMSFilters; i++) {

        //
        // Remove each entry from the MM Specific Filter List.
        //

        pIniMMSFilter =  *(ppIniMMSFilters + i);
        RemoveIniMMSFilter(pIniMMSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniMMSFilter->pNext = NULL;
        AddToSpecificMMList(
            &pIniCurMMSFilters,
            pIniMMSFilter
            );

    }

    *ppIniCurMMSFilters = pIniCurMMSFilters;
}


VOID
UpdateMMSFilterLinks(
    PINIMMFILTER pIniMMFilter,
    DWORD dwNumMMSFilters,
    PINIMMSFILTER * ppIniMMSFilters
    )
{
    if (pIniMMFilter->ppIniMMSFilters) {
        FreeSPDMemory(pIniMMFilter->ppIniMMSFilters);
    }

    pIniMMFilter->ppIniMMSFilters = ppIniMMSFilters;
    pIniMMFilter->dwNumMMSFilters = dwNumMMSFilters;
}


VOID
UpdateMMFilterNonPKeys(
    PINIMMFILTER pIniMMFilter,
    LPWSTR pszFilterName,
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy
    )
{
    if (pIniMMFilter->pszFilterName) {
        FreeSPDString(pIniMMFilter->pszFilterName);
    }
    pIniMMFilter->pszFilterName = pszFilterName;

    pIniMMFilter->dwFlags = pMMFilter->dwFlags;

    if (pIniMMAuthMethods) {
        CopyGuid(pIniMMAuthMethods->gMMAuthID, &(pIniMMFilter->gMMAuthID));
    }
    else {
        CopyGuid(pMMFilter->gMMAuthID, &(pIniMMFilter->gMMAuthID));
    }

    if (pIniMMPolicy) {
        CopyGuid(pIniMMPolicy->gPolicyID, &(pIniMMFilter->gPolicyID));
    }
    else {
        CopyGuid(pMMFilter->gPolicyID, &(pIniMMFilter->gPolicyID));
    }
}


DWORD
GetMMFilter(
    HANDLE hMMFilter,
    PMM_FILTER * ppMMFilter
    )
/*++

Routine Description:

    This function retrieves a mm filter from the SPD.

Arguments:

    hMMFilter - Handle to the filter to be retrieved.

    ppMMFilter -  Filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pFilterHandle = NULL;
    PINIMMFILTER pIniMMFilter = NULL;
    PMM_FILTER pMMFilter = NULL;


    if (!hMMFilter || !ppMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PMM_FILTER_HANDLE) hMMFilter;

    pIniMMFilter = pFilterHandle->pIniMMFilter;

    if (!pIniMMFilter) {
        dwError = ERROR_IPSEC_MM_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniMMFilter(
                  pIniMMFilter,
                  &pMMFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    *ppMMFilter = pMMFilter;
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppMMFilter = NULL;
    return (dwError);
}


DWORD
GetIniMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER * ppMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER),
                  &pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyMMFilter(
                  pIniMMFilter,
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppMMFilter = pMMFilter;
    return (dwError);

error:

    if (pMMFilter) {
        SPDApiBufferFree(pMMFilter);
    }

    *ppMMFilter = NULL;
    return (dwError);
}


DWORD
ApplyIfChangeToIniMMFilters(
    PDWORD pdwMMError,
    PIPSEC_INTERFACE pLatestIfList
    )
{
    DWORD dwError = 0;
    PINIMMFILTER pIniMMFilter = NULL;


    pIniMMFilter = gpIniMMFilter;

    while (pIniMMFilter) {

        dwError = UpdateIniMMFilterThruIfChange(
                      pIniMMFilter,
                      pLatestIfList
                      );
        if (dwError) {
            *pdwMMError = dwError;
        }

        pIniMMFilter = pIniMMFilter->pNext;

    }

    dwError = ERROR_SUCCESS;
    return (dwError);
}


DWORD
UpdateIniMMFilterThruIfChange(
    PINIMMFILTER pIniMMFilter,
    PIPSEC_INTERFACE pLatestIfList
    )
{
    DWORD dwError = 0;
    PINIMMSFILTER pLatestIniMMSFilters = NULL;
    DWORD dwNumMMSFilters = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    PINIMMSFILTER pCurIniMMSFilters = NULL;
    PINIMMSFILTER pNewIniMMSFilters = NULL;
    PINIMMSFILTER pOldIniMMSFilters = NULL;
 

    dwError = FormIniMMSFilters(
                  pIniMMFilter,
                  pLatestIfList,
                  &pLatestIniMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateMMSFilterLinks(
                  pLatestIniMMSFilters,
                  &dwNumMMSFilters,
                  &ppIniMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveMMSFilters(
        pIniMMFilter,
        &pCurIniMMSFilters
        );

    ProcessIniMMSFilters(
        &pLatestIniMMSFilters,
        &pCurIniMMSFilters,
        &pNewIniMMSFilters,
        &pOldIniMMSFilters
        );

    if (pIniMMFilter->pIniMMAuthMethods) {
        LinkMMSpecificFiltersToAuth(
            pIniMMFilter->pIniMMAuthMethods,
            pCurIniMMSFilters
            );
        LinkMMSpecificFiltersToAuth(
            pIniMMFilter->pIniMMAuthMethods,
            pNewIniMMSFilters
            );
    }

    if (pIniMMFilter->pIniMMPolicy) {
        LinkMMSpecificFiltersToPolicy(
            pIniMMFilter->pIniMMPolicy,
            pCurIniMMSFilters
            );
        LinkMMSpecificFiltersToPolicy(
            pIniMMFilter->pIniMMPolicy,
            pNewIniMMSFilters
            );
    }

    SetMMSFilterLinks(
        pCurIniMMSFilters,
        pNewIniMMSFilters,
        dwNumMMSFilters,
        ppIniMMSFilters
        );

    UpdateMMSFilterLinks(
        pIniMMFilter,
        dwNumMMSFilters,
        ppIniMMSFilters
        );

    AddToSpecificMMList(
        &gpIniMMSFilter,
        pCurIniMMSFilters
        );

    AddToSpecificMMList(
        &gpIniMMSFilter,
        pNewIniMMSFilters
        );

    if (pOldIniMMSFilters) {
        FreeIniMMSFilterList(pOldIniMMSFilters);
    }

    return (dwError);

error:

    if (pLatestIniMMSFilters) {
        FreeIniMMSFilterList(pLatestIniMMSFilters);
    }

    return (dwError);
}


DWORD
FormIniMMSFilters(
    PINIMMFILTER pIniMMFilter,
    PIPSEC_INTERFACE pIfList,
    PINIMMSFILTER * ppIniMMSFilters
    )
{
    DWORD dwError = 0;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINIMMSFILTER pIniMMSFilters = NULL;


    dwError = GetMatchingInterfaces(
                  pIniMMFilter->InterfaceType,
                  pIfList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniMMSFilters(
                  pIniMMFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pIniMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIniMMSFilters = pIniMMSFilters;

cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    *ppIniMMSFilters = NULL;

    goto cleanup;
}


VOID
ProcessIniMMSFilters(
    PINIMMSFILTER * ppLatestIniMMSFilters,
    PINIMMSFILTER * ppCurIniMMSFilters,
    PINIMMSFILTER * ppNewIniMMSFilters,
    PINIMMSFILTER * ppOldIniMMSFilters
    )
{
    PINIMMSFILTER pLatestIniMMSFilters = NULL;
    PINIMMSFILTER pCurIniMMSFilters = NULL;
    PINIMMSFILTER pTempCur = NULL;
    BOOL bEqual = FALSE;
    PINIMMSFILTER pTempLatest = NULL;
    PINIMMSFILTER pTemp = NULL;
    PINIMMSFILTER pNewIniMMSFilters = NULL;
    PINIMMSFILTER pOldIniMMSFilters = NULL;
    PINIMMSFILTER pTempPreToCur = NULL;
    PINIMMSFILTER pTempPreToLatest = NULL;


    pCurIniMMSFilters = *ppCurIniMMSFilters;
    pTempCur = *ppCurIniMMSFilters;

    while (pTempCur) {

        bEqual = FALSE;
        pTempLatest = *ppLatestIniMMSFilters;

        while (pTempLatest) {

            bEqual = EqualIniMMSFilterIfPKeys(
                         pTempLatest,
                         pTempCur
                         );
            if (bEqual) {
                break;
            }

            pTempLatest = pTempLatest->pNext;

        }

        if (bEqual) {
            pTempPreToCur  = pTempCur;
            pTempCur = pTempCur->pNext;
        }
        else {
            pTemp = pTempCur;
            pTempCur = pTempCur->pNext;
            if (pTempPreToCur) {
                pTempPreToCur->pNext = pTempCur;
            }
            else {
                pCurIniMMSFilters = pTempCur;
            }
            pTemp->pNext = NULL;
            AddToSpecificMMList(
                &pOldIniMMSFilters,
                pTemp
                );
        }

    }

    pLatestIniMMSFilters = *ppLatestIniMMSFilters;
    pTempLatest = *ppLatestIniMMSFilters;

    while (pTempLatest) {

        bEqual = FALSE;
        pTempCur = pCurIniMMSFilters;

        while (pTempCur) {

            bEqual = EqualIniMMSFilterIfPKeys(
                         pTempCur,
                         pTempLatest
                         );
            if (bEqual) {
                break;
            }

            pTempCur = pTempCur->pNext;

        }

        if (bEqual) {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniMMSFilters = pTempLatest;
            }
            FreeIniMMSFilter(pTemp);
        }
        else {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniMMSFilters = pTempLatest;
            }
            pTemp->pNext = NULL;
            AddToSpecificMMList(
                &pNewIniMMSFilters,
                pTemp
                );
        }

    }

    *ppLatestIniMMSFilters = pLatestIniMMSFilters;
    *ppCurIniMMSFilters = pCurIniMMSFilters;
    *ppNewIniMMSFilters = pNewIniMMSFilters;
    *ppOldIniMMSFilters = pOldIniMMSFilters;
}


BOOL
EqualIniMMSFilterIfPKeys(
    PINIMMSFILTER pExsIniMMSFilter,
    PINIMMSFILTER pNewIniMMSFilter
    )
{
    BOOL  bCmp = FALSE;


    //
    // No need to compare: gParentID, pszFilterName, dwFlags
    //                     cRef, dwWeight, gMMAuthID and gPolicyID.
    // They will be the same for both the filters.
    //

    if (pExsIniMMSFilter->InterfaceType != pNewIniMMSFilter->InterfaceType) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniMMSFilter->SrcAddr, pNewIniMMSFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniMMSFilter->DesAddr, pNewIniMMSFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if (pExsIniMMSFilter->dwDirection != pNewIniMMSFilter->dwDirection) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
AllocateMMSFilterLinks(
    PINIMMSFILTER pIniMMSFilters,
    PDWORD pdwNumMMSFilters,
    PINIMMSFILTER ** pppIniMMSFilters
    )
{
    DWORD dwError = 0;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwNumMMSFilters = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniMMSFilters;
    while (pTemp) {
        dwNumMMSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumMMSFilters) {
        ppIniMMSFilters = (PINIMMSFILTER *)
                          AllocSPDMem(
                              sizeof(PINIMMSFILTER)*
                              dwNumMMSFilters
                              );
        if (!ppIniMMSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    for (i = 0; i < dwNumMMSFilters; i++) {
        *(ppIniMMSFilters + i) = NULL;
    }

    *pdwNumMMSFilters = dwNumMMSFilters;
    *pppIniMMSFilters = ppIniMMSFilters;
    return (dwError);

error:

    *pdwNumMMSFilters = 0;
    *pppIniMMSFilters = NULL;
    return (dwError);
}


VOID
SetMMSFilterLinks(
    PINIMMSFILTER pCurIniMMSFilters,
    PINIMMSFILTER pNewIniMMSFilters,
    DWORD dwNumMMSFilters,
    PINIMMSFILTER * ppIniMMSFilters
    )
{
    PINIMMSFILTER pTemp = NULL;
    DWORD i = 0;
    DWORD j = 0;


    pTemp = pCurIniMMSFilters;
    for (i = 0; (i < dwNumMMSFilters) && (pTemp != NULL); i++) {
        *(ppIniMMSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    pTemp = pNewIniMMSFilters;
    for (j = i; (j < dwNumMMSFilters) && (pTemp != NULL); j++) {
        *(ppIniMMSFilters + j) = pTemp;
        pTemp = pTemp->pNext;
    }
}


DWORD
OpenMMFilterHandle(
    LPWSTR pServerName,
    PMM_FILTER pMMFilter,
    PHANDLE phMMFilter
    )
{
    DWORD dwError = 0;
    PINIMMFILTER pIniExistingMMFilter = NULL;
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;


    if (!phMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external MM filter.
    //

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingMMFilter = FindExactMMFilter(
                               gpIniMMFilter,
                               pMMFilter
                               );
    if (!pIniExistingMMFilter) {
        dwError = ERROR_IPSEC_MM_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniExistingMMFilter->bPendingDeletion) {
        dwError = ERROR_IPSEC_MM_FILTER_PENDING_DELETION;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateMMFilterHandle(
                  pIniExistingMMFilter,
                  pMMFilter->gFilterID,
                  &pMMFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingMMFilter->cRef++;

    pMMFilterHandle->pNext = gpMMFilterHandle;
    gpMMFilterHandle = pMMFilterHandle;

    *phMMFilter = (HANDLE) pMMFilterHandle;
    LEAVE_SPD_SECTION();

cleanup:

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMMFilterHandle) {
        FreeMMFilterHandle(pMMFilterHandle);
    }

    *phMMFilter = NULL;
    goto cleanup;
}


DWORD
CloseMMFilterHandle(
    HANDLE hMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pFilterHandle = NULL;
    PINIMMFILTER pIniMMFilter = NULL;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PMM_FILTER_HANDLE) hMMFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMFilter = pFilterHandle->pIniMMFilter;

    if (!pIniMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMFilter->cRef > 1) {

        pIniMMFilter->cRef--;

        RemoveMMFilterHandle(
            pFilterHandle
            );
        FreeMMFilterHandle(
            pFilterHandle
            );

        dwError = ERROR_SUCCESS;
        LEAVE_SPD_SECTION();
        return (dwError);

    }

    if (pIniMMFilter->bPendingDeletion) {

        if (pIniMMFilter->bIsPersisted) {
            dwError = SPDPurgeMMFilter(
                          pIniMMFilter->gFilterID
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        dwError = DeleteIniMMFilter(
                      pIniMMFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);

    }
    else {
        pIniMMFilter->cRef--;
    }

    RemoveMMFilterHandle(
        pFilterHandle
        );
    FreeMMFilterHandle(
        pFilterHandle
        );

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    return (dwError);
}


PINIMMFILTER
FindExactMMFilter(
    PINIMMFILTER pGenericMMList,
    PMM_FILTER pMMFilter
    )
{
    PINIMMFILTER pIniMMFilter = NULL;
    BOOL bEqual = FALSE;


    pIniMMFilter = pGenericMMList;

    while (pIniMMFilter) {

        bEqual = EqualMMFilterPKeys(
                     pIniMMFilter,
                     pMMFilter
                     );
        if (bEqual) {
            bEqual = EqualMMFilterNonPKeys(
                         pIniMMFilter,
                         pMMFilter
                         );
            if (bEqual) {
                return (pIniMMFilter);
            }
        }

        pIniMMFilter = pIniMMFilter->pNext;

    }

    return (NULL);
}


BOOL
EqualMirroredMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function compares an internal and an external main mode
    filter for equality.

Arguments:

    pIniMMFilter - Filter to compare.

    pMMFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniMMFilter->DesAddr, pMMFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniMMFilter->SrcAddr, pMMFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if ((pIniMMFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pMMFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pIniMMFilter->InterfaceType != pMMFilter->InterfaceType)) {
        return (FALSE);
    }

    if (!pIniMMFilter->bCreateMirror && !pMMFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmp-load.h ===
DWORD
LoadPersistedIPSecInformation(
    );

DWORD
LoadPersistedMMPolicies(
    HKEY hParentRegKey
    );

DWORD
SPDReadMMPolicy(
    HKEY hParentRegKey,
    LPWSTR pszMMPolicyUniqueID,
    PIPSEC_MM_POLICY * ppMMPolicy
    );

DWORD
UnMarshallMMOffers(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PIPSEC_MM_OFFER * ppOffers,
    PDWORD pdwOfferCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmf-pers.c ===
#include "precomp.h"


LPWSTR gpszIpsecMMFiltersKey = 
L"SOFTWARE\\Microsoft\\IPSec\\MM Filters";


DWORD
PersistMMFilter(
    GUID gFilterID,
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    DWORD dwDisposition = 0;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecMMFiltersKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegistryKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDWriteMMFilter(
                  hRegistryKey,
                  gFilterID,
                  pMMFilter
                  );    
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    if (hRegistryKey) {
        (VOID) SPDPurgeMMFilter(
                   gFilterID
                   );
    }

    goto cleanup;
}


DWORD
SPDWriteMMFilter(
    HKEY hParentRegKey,
    GUID gFilterID,
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    WCHAR szFilterID[MAX_PATH];
    WCHAR szPolicyID[MAX_PATH];
    WCHAR szAuthID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszPolicyUuid = NULL;
    LPWSTR pszAuthUuid = NULL;
    HKEY hRegKey = NULL;
    DWORD dwDisposition = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    DWORD dwInterfaceType = 0;
    DWORD dwMirrored = 0;


    szFilterID[0] = L'\0';
    szPolicyID[0] = L'\0';
    szAuthID[0] = L'\0';

    dwError = UuidToString(
                  &gFilterID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szFilterID, L"{");
    wcscat(szFilterID, pszStringUuid);
    wcscat(szFilterID, L"}");

    dwError = UuidToString(
                  &pMMFilter->gPolicyID,
                  &pszPolicyUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szPolicyID, L"{");
    wcscat(szPolicyID, pszPolicyUuid);
    wcscat(szPolicyID, L"}");

    dwError = UuidToString(
                  &pMMFilter->gMMAuthID,
                  &pszAuthUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szAuthID, L"{");
    wcscat(szAuthID, pszAuthUuid);
    wcscat(szAuthID, L"}");

    dwError = RegCreateKeyExW(
                  hParentRegKey,
                  szFilterID,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"FilterID",
                  0,
                  REG_SZ,
                  (LPBYTE) szFilterID,
                  (wcslen(szFilterID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"FilterName",
                  0,
                  REG_SZ,
                  (LPBYTE) pMMFilter->pszFilterName,
                  (wcslen(pMMFilter->pszFilterName) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwInterfaceType = (DWORD) pMMFilter->InterfaceType;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"InterfaceType",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwInterfaceType,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwMirrored = (DWORD) pMMFilter->bCreateMirror;
    dwError = RegSetValueExW(
                  hRegKey,
                  L"Mirrored",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwMirrored,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Flags",
                  0,
                  REG_DWORD,
                  (LPBYTE)&pMMFilter->dwFlags,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MarshallMMFilterBuffer(
                  pMMFilter,
                  &pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"MM Filter Buffer",
                  0,
                  REG_BINARY,
                  (LPBYTE) pBuffer,
                  dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"PolicyID",
                  0,
                  REG_SZ,
                  (LPBYTE) szPolicyID,
                  (wcslen(szPolicyID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"AuthID",
                  0,
                  REG_SZ,
                  (LPBYTE) szAuthID,
                  (wcslen(szAuthID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (pszPolicyUuid) {
        RpcStringFree(&pszPolicyUuid);
    }

    if (pszAuthUuid) {
        RpcStringFree(&pszAuthUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    return (dwError);

error:

    goto cleanup;
}


DWORD
MarshallMMFilterBuffer(
    PMM_FILTER pMMFilter,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    )
{
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    LPBYTE pMem = NULL;
    static const GUID GUID_IPSEC_MM_FILTER_VER1 =
    { 0xabcd0004, 0x0001, 0x0001, { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 } };


    dwBufferSize = sizeof(GUID) +
                   sizeof(DWORD) +
                   sizeof(ADDR) +
                   sizeof(ADDR);

    pBuffer = (LPBYTE) AllocSPDMem(
                           dwBufferSize
                           );
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMem = pBuffer;

    memcpy(
        pMem,
        (LPBYTE) &GUID_IPSEC_MM_FILTER_VER1,
        sizeof(GUID)
        );
    pMem += sizeof(GUID);

    memcpy(
        pMem,
        (LPBYTE) &dwBufferSize,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    memcpy(
        pMem,
        (LPBYTE) &pMMFilter->SrcAddr,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    memcpy(
        pMem,
        (LPBYTE) &pMMFilter->DesAddr,
        sizeof(ADDR)
        );
    pMem += sizeof(ADDR);

    *ppBuffer = pBuffer;
    *pdwBufferSize = dwBufferSize;

    return (dwError);

error:

    *ppBuffer = NULL;
    *pdwBufferSize = 0;

    return (dwError);
}


DWORD
SPDPurgeMMFilter(
    GUID gMMFilterID
    )
{
    DWORD dwError = 0;
    HKEY hParentRegKey = NULL;
    DWORD dwDisposition = 0;
    WCHAR szFilterID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecMMFiltersKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hParentRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szFilterID[0] = L'\0';

    dwError = UuidToString(
                  &gMMFilterID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szFilterID, L"{");
    wcscat(szFilterID, pszStringUuid);
    wcscat(szFilterID, L"}");

    dwError = RegDeleteKeyW(
                  hParentRegKey,
                  szFilterID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hParentRegKey) {
        RegCloseKey(hParentRegKey);
    }

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmp-pers.h ===
DWORD
PersistMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy
    );

DWORD
SPDWriteMMPolicy(
    HKEY hParentRegKey,
    PIPSEC_MM_POLICY pMMPolicy
    );

DWORD
MarshallMMOffers(
    PIPSEC_MM_OFFER pOffers,
    DWORD dwOfferCount,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    );

DWORD
SPDPurgeMMPolicy(
    GUID gMMPolicyID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmfilter.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmfilter.h

Abstract:

    This module contains all of the code prototypes to
    drive the main mode filter list management of
    IPSecSPD Service.

Author:


Environment: User Mode


Revision History:


--*/


typedef struct _inimmfilter {
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    DWORD cRef;
    BOOL bIsPersisted;
    BOOL bPendingDeletion;
    GUID gMMAuthID;
    GUID gPolicyID;
    PINIMMAUTHMETHODS pIniMMAuthMethods;
    PINIMMPOLICY pIniMMPolicy;
    DWORD dwNumMMSFilters;
    struct _inimmsfilter ** ppIniMMSFilters;
    struct _inimmfilter * pNext;
} INIMMFILTER, * PINIMMFILTER;


typedef struct _inimmsfilter {
    GUID gParentID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    DWORD dwFlags;
    ADDR SrcAddr;
    ADDR DesAddr;
    DWORD cRef;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gMMAuthID;
    GUID gPolicyID;
    PINIMMAUTHMETHODS pIniMMAuthMethods;
    PINIMMPOLICY pIniMMPolicy;
    struct _inimmsfilter * pNext;
} INIMMSFILTER, * PINIMMSFILTER;


typedef struct _mm_filter_handle {
    PINIMMFILTER pIniMMFilter;
    GUID gFilterID;
    struct _mm_filter_handle * pNext;
} MM_FILTER_HANDLE, * PMM_FILTER_HANDLE;


DWORD
ValidateMMFilter(
    PMM_FILTER pMMFilter
    );

PINIMMFILTER
FindMMFilterByGuid(
    PMM_FILTER_HANDLE pMMFilterHandleList,
    GUID gFilterID
    );
  
PINIMMFILTER
FindMMFilter(
    PINIMMFILTER pGenericMMList,
    PMM_FILTER pMMFilter
    );

BOOL
EqualMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );

DWORD
CreateIniMMFilter(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER * ppIniMMFilter
    );

DWORD
CreateIniMMSFilters(
    PINIMMFILTER pIniMMFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINIMMSFILTER * ppIniMMSFilters
    );

DWORD
CreateIniMirroredMMFilter(
    PINIMMFILTER pFilter,
    PINIMMFILTER * ppMirroredFilter
    );

BOOL
EqualIniMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PINIMMFILTER pFilter
    );

DWORD
CreateMMFilterHandle(
    PINIMMFILTER pIniMMFilter,
    GUID gFilterID,
    PMM_FILTER_HANDLE * ppMMFilterHandle
    );

DWORD
CreateSpecificMMFilterLinks(
    PINIMMFILTER pIniMMFilter,
    PINIMMSFILTER pIniMMSFilters
    );

VOID
LinkMMFilterToPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER pIniMMFilter
    );

VOID
LinkMMFilterToAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMFILTER pIniMMFilter
    );

VOID
FreeIniMMFilterList(
    PINIMMFILTER pIniMMFilterList
    );

VOID
FreeIniMMFilter(
    PINIMMFILTER pIniMMFilter
    );

DWORD
DeleteIniMMFilter(
    PINIMMFILTER   pIniMMFilter
    );

VOID
DelinkMMFilterFromPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER pIniMMFilter
    );

VOID
DelinkMMFilterFromAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMFILTER pIniMMFilter
    );

VOID
DeleteIniMMSFilters(
    PINIMMFILTER pIniMMFilter
    );

VOID
RemoveIniMMFilter(
    PINIMMFILTER pIniMMFilter
    );

VOID
RemoveMMFilterHandle(
    PMM_FILTER_HANDLE pMMFilterHandle
    );

VOID
FreeMMFilterHandleList(
    PMM_FILTER_HANDLE pMMFilterHandleList
    );

VOID
FreeMMFilterHandle(
    PMM_FILTER_HANDLE pMMFilterHandle
    );

DWORD
EnumGenericMMFilters(
    PINIMMFILTER pIniMMFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    );

DWORD
CopyMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );

VOID
FreeMMFilters(
    DWORD dwNumMMFilters,
    PMM_FILTER pMMFilters
    );

DWORD
SetIniMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );

BOOL
EqualMMFilterNonPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );

DWORD
CreateMMSFilterLinks(
    PINIMMSFILTER pIniMMSFilters,
    PDWORD pdwNumMMSFilters,
    PINIMMSFILTER ** pppIniMMSFilters
    );

VOID
RemoveMMSFilters(
    PINIMMFILTER pIniMMFilter,
    PINIMMSFILTER * ppIniCurMMSFilters 
    );

VOID
UpdateMMSFilterLinks(
    PINIMMFILTER pIniMMFilter,
    DWORD dwNumMMSFilters,
    PINIMMSFILTER * ppIniMMSFilters
    );

VOID
UpdateMMFilterNonPKeys(
    PINIMMFILTER pIniMMFilter,
    LPWSTR pszFilterName,
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy
    );

DWORD
GetIniMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER * ppMMFilter
    );

DWORD
ApplyIfChangeToIniMMFilters(
    PDWORD pdwMMError,
    PIPSEC_INTERFACE pLatestIfList
    );

DWORD
UpdateIniMMFilterThruIfChange(
    PINIMMFILTER pIniMMFilter,
    PIPSEC_INTERFACE pLatestIfList
    );

DWORD
FormIniMMSFilters(
    PINIMMFILTER pIniMMFilter,
    PIPSEC_INTERFACE pIfList,
    PINIMMSFILTER * ppIniMMSFilters
    );

VOID
ProcessIniMMSFilters(
    PINIMMSFILTER * ppLatestIniMMSFilters,
    PINIMMSFILTER * ppCurIniMMSFilters,
    PINIMMSFILTER * ppNewIniMMSFilters,
    PINIMMSFILTER * ppOldIniMMSFilters
    );

BOOL
EqualIniMMSFilterIfPKeys(
    PINIMMSFILTER pExsIniMMSFilter,
    PINIMMSFILTER pNewIniMMSFilter
    );

DWORD
AllocateMMSFilterLinks(
    PINIMMSFILTER pIniMMSFilters,
    PDWORD pdwNumMMSFilters,
    PINIMMSFILTER ** pppIniMMSFilters
    );

VOID
SetMMSFilterLinks(
    PINIMMSFILTER pCurIniMMSFilters,
    PINIMMSFILTER pNewIniMMSFilters,
    DWORD dwNumMMSFilters,
    PINIMMSFILTER * ppIniMMSFilters
    );

PINIMMFILTER
FindExactMMFilter(
    PINIMMFILTER pGenericMMList,
    PMM_FILTER pMMFilter
    );

BOOL
EqualMirroredMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmp-load.c ===
#include "precomp.h"


LPWSTR gpszIpsecPersistenceKey = 
L"SOFTWARE\\Microsoft\\IPSec";


DWORD
LoadPersistedIPSecInformation(
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;


    gbLoadingPersistence = TRUE;

    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecPersistenceKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LoadPersistedMMPolicies(
                  hRegistryKey
                  );

    dwError = LoadPersistedMMAuthMethods(
                  hRegistryKey
                  );

    dwError = LoadPersistedMMFilters(
                  hRegistryKey
                  );

    dwError = LoadPersistedQMPolicies(
                  hRegistryKey
                  );

    dwError = LoadPersistedTxFilters(
                  hRegistryKey
                  );

    dwError = LoadPersistedTnFilters(
                  hRegistryKey
                  );

    dwError = ERROR_SUCCESS;

error:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    gbLoadingPersistence = FALSE;

    return (dwError);
}


DWORD
LoadPersistedMMPolicies(
    HKEY hParentRegKey
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;
    WCHAR szMMPolicyUniqueID[MAX_PATH];
    DWORD dwIndex = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    LPWSTR pszServerName = NULL;
    DWORD dwPersist = 0;


    dwPersist |= PERSIST_SPD_OBJECT;

    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  L"MM Policies",
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    while (1) {

        dwSize = MAX_PATH;
        szMMPolicyUniqueID[0] = L'\0';

        dwError = RegEnumKeyExW(
                      hRegKey,
                      dwIndex,
                      szMMPolicyUniqueID,
                      &dwSize,
                      NULL,
                      NULL,
                      0,
                      0
                      );

        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        }

        BAIL_ON_WIN32_ERROR(dwError);

        dwError = SPDReadMMPolicy(
                      hRegKey,
                      szMMPolicyUniqueID,
                      &pMMPolicy
                      );

        if (dwError) {
            dwIndex++;
            continue;
        }

        dwError = AddMMPolicy(
                      pszServerName,
                      dwPersist,
                      pMMPolicy
                      );

        if (pMMPolicy) {
            FreeMMPolicies(
                1,
                pMMPolicy
                );
        }

        dwIndex++;

    }

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
SPDReadMMPolicy(
    HKEY hParentRegKey,
    LPWSTR pszMMPolicyUniqueID,
    PIPSEC_MM_POLICY * ppMMPolicy
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    LPWSTR pszPolicyID = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;


    dwError = RegOpenKeyExW(
                  hParentRegKey,
                  pszMMPolicyUniqueID,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMPolicy = (PIPSEC_MM_POLICY) AllocSPDMem(
                                   sizeof(IPSEC_MM_POLICY)
                                   );
    if (!pMMPolicy) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"PolicyID",
                  REG_SZ,
                  (LPBYTE *)&pszPolicyID,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wGUIDFromString(
        pszPolicyID,
        &pMMPolicy->gPolicyID
        );

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"PolicyName",
                  REG_SZ,
                  (LPBYTE *)&pMMPolicy->pszPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"Flags",
                  NULL,
                  &dwType,
                  (LPBYTE)&pMMPolicy->dwFlags,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"SoftSAExpirationTime",
                  NULL,
                  &dwType,
                  (LPBYTE)&pMMPolicy->uSoftSAExpirationTime,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"Offers",
                  REG_BINARY,
                  (LPBYTE *)&pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallMMOffers(
                  pBuffer,
                  dwBufferSize,
                  &pMMPolicy->pOffers,
                  &pMMPolicy->dwOfferCount
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppMMPolicy = pMMPolicy;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszPolicyID) {
        FreeSPDStr(pszPolicyID);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    return (dwError);

error:

    *ppMMPolicy = NULL;

    if (pMMPolicy) {
        FreeMMPolicies(
            1,
            pMMPolicy
            );
    }

    goto cleanup;
}


DWORD
UnMarshallMMOffers(
    LPBYTE pBuffer,
    DWORD dwBufferSize,
    PIPSEC_MM_OFFER * ppOffers,
    PDWORD pdwOfferCount
    )
{
    DWORD dwError = 0;
    LPBYTE pMem = NULL;
    PIPSEC_MM_OFFER pOffers = NULL;
    DWORD dwOfferCount = 0;


    pMem = pBuffer;

    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);

    memcpy(
        (LPBYTE) &dwOfferCount,
        pMem,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    pOffers = (PIPSEC_MM_OFFER) AllocSPDMem(
                                sizeof(IPSEC_MM_OFFER)*dwOfferCount
                                );
    if (!pOffers) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        (LPBYTE) pOffers,
        pMem,
        sizeof(IPSEC_MM_OFFER)*dwOfferCount
        );

    *ppOffers = pOffers;
    *pdwOfferCount = dwOfferCount;
    return (dwError);

error:

    *ppOffers = NULL;
    *pdwOfferCount = 0;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmp-pers.c ===
#include "precomp.h"


LPWSTR gpszIpsecMMPoliciesKey = 
L"SOFTWARE\\Microsoft\\IPSec\\MM Policies";


DWORD
PersistMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    DWORD dwDisposition = 0;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecMMPoliciesKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegistryKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDWriteMMPolicy(
                  hRegistryKey,
                  pMMPolicy
                  );    
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    if (hRegistryKey) {
        (VOID) SPDPurgeMMPolicy(
                   pMMPolicy->gPolicyID
                   );
    }

    goto cleanup;
}


DWORD
SPDWriteMMPolicy(
    HKEY hParentRegKey,
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;
    WCHAR szPolicyID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    HKEY hRegKey = NULL;
    DWORD dwDisposition = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;


    szPolicyID[0] = L'\0';

    dwError = UuidToString(
                  &pMMPolicy->gPolicyID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szPolicyID, L"{");
    wcscat(szPolicyID, pszStringUuid);
    wcscat(szPolicyID, L"}");

    dwError = RegCreateKeyExW(
                  hParentRegKey,
                  szPolicyID,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"PolicyID",
                  0,
                  REG_SZ,
                  (LPBYTE) szPolicyID,
                  (wcslen(szPolicyID) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"PolicyName",
                  0,
                  REG_SZ,
                  (LPBYTE) pMMPolicy->pszPolicyName,
                  (wcslen(pMMPolicy->pszPolicyName) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Flags",
                  0,
                  REG_DWORD,
                  (LPBYTE)&pMMPolicy->dwFlags,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"SoftSAExpirationTime",
                  0,
                  REG_DWORD,
                  (LPBYTE)&pMMPolicy->uSoftSAExpirationTime,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MarshallMMOffers(
                  pMMPolicy->pOffers,
                  pMMPolicy->dwOfferCount,
                  &pBuffer,
                  &dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                  hRegKey,
                  L"Offers",
                  0,
                  REG_BINARY,
                  (LPBYTE) pBuffer,
                  dwBufferSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pBuffer) {
        FreeSPDMem(pBuffer);
    }

    return (dwError);

error:

    goto cleanup;
}


DWORD
MarshallMMOffers(
    PIPSEC_MM_OFFER pOffers,
    DWORD dwOfferCount,
    LPBYTE * ppBuffer,
    PDWORD pdwBufferSize
    )
{
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    LPBYTE pMem = NULL;
    static const GUID GUID_IPSEC_MM_OFFER_VER1 =
    { 0xabcd0001, 0x0001, 0x0001, { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 } };


    dwBufferSize = sizeof(GUID) +
                   sizeof(DWORD) +
                   sizeof(DWORD) +
                   sizeof(IPSEC_MM_OFFER)*dwOfferCount;

    pBuffer = (LPBYTE) AllocSPDMem(
                           dwBufferSize
                           );
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMem = pBuffer;

    memcpy(
        pMem,
        (LPBYTE) &GUID_IPSEC_MM_OFFER_VER1,
        sizeof(GUID)
        );
    pMem += sizeof(GUID);

    memcpy(
        pMem,
        (LPBYTE) &dwBufferSize,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    memcpy(
        pMem,
        (LPBYTE) &dwOfferCount,
        sizeof(DWORD)
        );
    pMem += sizeof(DWORD);

    memcpy(
        pMem,
        (LPBYTE) pOffers,
        sizeof(IPSEC_MM_OFFER)*dwOfferCount
        );

    *ppBuffer = pBuffer;
    *pdwBufferSize = dwBufferSize;

    return (dwError);

error:

    *ppBuffer = NULL;
    *pdwBufferSize = 0;

    return (dwError);
}


DWORD
SPDPurgeMMPolicy(
    GUID gMMPolicyID
    )
{
    DWORD dwError = 0;
    HKEY hParentRegKey = NULL;
    DWORD dwDisposition = 0;
    WCHAR szPolicyID[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecMMPoliciesKey,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hParentRegKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szPolicyID[0] = L'\0';

    dwError = UuidToString(
                  &gMMPolicyID,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szPolicyID, L"{");
    wcscat(szPolicyID, pszStringUuid);
    wcscat(szPolicyID, L"}");

    dwError = RegDeleteKeyW(
                  hParentRegKey,
                  szPolicyID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hParentRegKey) {
        RegCloseKey(hParentRegKey);
    }

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmspecific.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmspecific.c

Abstract:

    This module contains all of the code to drive the
    mm specific filter list management of IPSecSPD Service.

Author:

    abhisheV    08-December-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
ApplyMMTransform(
    PINIMMFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINIMMSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function expands a generic mm filter into its
    corresponding specific filters.

Arguments:

    pFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppSpecificFilters - List of specific filters expanded for the
                        given generic filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMSFILTER pSpecificFilters = NULL;
    PINIMMSFILTER pOutboundSpecificFilters = NULL;
    PINIMMSFILTER pInboundSpecificFilters = NULL;

    PADDR pOutSrcAddrList = NULL;
    DWORD dwOutSrcAddrCnt = 0;
    PADDR pInSrcAddrList = NULL;
    DWORD dwInSrcAddrCnt = 0;

    PADDR pOutDesAddrList = NULL;
    DWORD dwOutDesAddrCnt = 0;
    PADDR pInDesAddrList = NULL;
    DWORD dwInDesAddrCnt = 0;


    // 
    // Form the outbound and inbound source and destination
    // address lists.
    // 

    dwError = FormMMOutboundInboundAddresses(
                  pFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pOutSrcAddrList,
                  &dwOutSrcAddrCnt,
                  &pInSrcAddrList,
                  &dwInSrcAddrCnt,
                  &pOutDesAddrList,
                  &dwOutDesAddrCnt,
                  &pInDesAddrList,
                  &dwInDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form outbound specific filters.
    //

    dwError = FormSpecificMMFilters(
                  pFilter,
                  pOutSrcAddrList,
                  dwOutSrcAddrCnt,
                  pOutDesAddrList,
                  dwOutDesAddrCnt,
                  FILTER_DIRECTION_OUTBOUND,
                  &pOutboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form inbound specific filters.
    //

    dwError = FormSpecificMMFilters(
                  pFilter,
                  pInSrcAddrList,
                  dwInSrcAddrCnt,
                  pInDesAddrList,
                  dwInDesAddrCnt,
                  FILTER_DIRECTION_INBOUND,
                  &pInboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    pSpecificFilters = pOutboundSpecificFilters;

    AddToSpecificMMList(
        &pSpecificFilters,
        pInboundSpecificFilters
        );


    *ppSpecificFilters = pSpecificFilters;

cleanup:

    if (pOutSrcAddrList) {
        FreeSPDMemory(pOutSrcAddrList);
    }

    if (pInSrcAddrList) {
        FreeSPDMemory(pInSrcAddrList);
    }

    if (pOutDesAddrList) {
        FreeSPDMemory(pOutDesAddrList);
    }

    if (pInDesAddrList) {
        FreeSPDMemory(pInDesAddrList);
    }

    return (dwError);

error:

    if (pOutboundSpecificFilters) {
        FreeIniMMSFilterList(pOutboundSpecificFilters);
    }

    if (pInboundSpecificFilters) {
        FreeIniMMSFilterList(pInboundSpecificFilters);
    }


    *ppSpecificFilters = NULL;
    goto cleanup;
}


DWORD
FormMMOutboundInboundAddresses(
    PINIMMFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PADDR * ppOutSrcAddrList,
    PDWORD pdwOutSrcAddrCnt,
    PADDR * ppInSrcAddrList,
    PDWORD pdwInSrcAddrCnt,
    PADDR * ppOutDesAddrList,
    PDWORD pdwOutDesAddrCnt,
    PADDR * ppInDesAddrList,
    PDWORD pdwInDesAddrCnt
    )
/*++

Routine Description:

    This function forms the outbound and inbound source and
    destination address sets for a generic filter.

Arguments:

    pFilter - Generic filter under consideration.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppOutSrcAddrList - List of outbound source addresses.

    pdwOutSrcAddrCnt - Number of addresses in the outbound
                       source address list.

    ppInSrcAddrList - List of inbound source addresses.

    pdwInSrcAddrCnt - Number of addresses in the inbound
                      source address list.

    ppOutDesAddrList - List of outbound destination addresses.

    pdwOutDesAddrCnt - Number of addresses in the outbound
                       destination address list.

    ppInDesAddrList - List of inbound destination addresses.

    pdwInDesAddrCnt - Number of addresses in the inbound
                      destination address list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    PADDR pSrcAddrList = NULL;
    DWORD dwSrcAddrCnt = 0;
    PADDR pDesAddrList = NULL;
    DWORD dwDesAddrCnt = 0;

    PADDR pOutSrcAddrList = NULL;
    DWORD dwOutSrcAddrCnt = 0;
    PADDR pInSrcAddrList = NULL;
    DWORD dwInSrcAddrCnt = 0;

    PADDR pOutDesAddrList = NULL;
    DWORD dwOutDesAddrCnt = 0;
    PADDR pInDesAddrList = NULL;
    DWORD dwInDesAddrCnt = 0;


    //
    // Replace wild card information to generate the new source
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->SrcAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pSrcAddrList,
                  &dwSrcAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Replace wild card information to generate the new destination
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->DesAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pDesAddrList,
                  &dwDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Separate the source address list into outbound and inbound 
    // source address sets based on the local machine's ip addresses.
    //

    dwError = SeparateAddrList(
                  pFilter->SrcAddr.AddrType,
                  pSrcAddrList,
                  dwSrcAddrCnt,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pOutSrcAddrList,
                  &dwOutSrcAddrCnt,
                  &pInSrcAddrList,
                  &dwInSrcAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Separate the destination address list into outbound and inbound
    // destination address sets based on the local machine's ip 
    // addresses.
    //

    dwError = SeparateAddrList(
                  pFilter->DesAddr.AddrType,
                  pDesAddrList,
                  dwDesAddrCnt,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pInDesAddrList,
                  &dwInDesAddrCnt,
                  &pOutDesAddrList,
                  &dwOutDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppOutSrcAddrList = pOutSrcAddrList;
    *pdwOutSrcAddrCnt = dwOutSrcAddrCnt;
    *ppInSrcAddrList = pInSrcAddrList;
    *pdwInSrcAddrCnt = dwInSrcAddrCnt;

    *ppOutDesAddrList = pOutDesAddrList;
    *pdwOutDesAddrCnt = dwOutDesAddrCnt;
    *ppInDesAddrList = pInDesAddrList;
    *pdwInDesAddrCnt = dwInDesAddrCnt;

cleanup:

    if (pSrcAddrList) {
        FreeSPDMemory(pSrcAddrList);
    }

    if (pDesAddrList) {
        FreeSPDMemory(pDesAddrList);
    }

    return (dwError);

error:

    if (pOutSrcAddrList) {
        FreeSPDMemory(pOutSrcAddrList);
    }

    if (pInSrcAddrList) {
        FreeSPDMemory(pInSrcAddrList);
    }

    if (pOutDesAddrList) {
        FreeSPDMemory(pOutDesAddrList);
    }

    if (pInDesAddrList) {
        FreeSPDMemory(pInDesAddrList);
    }

    *ppOutSrcAddrList = NULL;
    *pdwOutSrcAddrCnt = 0;
    *ppInSrcAddrList = NULL;
    *pdwInSrcAddrCnt = 0;

    *ppOutDesAddrList = NULL;
    *pdwOutDesAddrCnt = 0;
    *ppInDesAddrList = NULL;
    *pdwInDesAddrCnt = 0;

    goto cleanup;
}


DWORD
FormSpecificMMFilters(
    PINIMMFILTER pFilter,
    PADDR pSrcAddrList,
    DWORD dwSrcAddrCnt,
    PADDR pDesAddrList,
    DWORD dwDesAddrCnt,
    DWORD dwDirection,
    PINIMMSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function forms the specific main mode filters
    for the given generic filter and the source and 
    destination address sets.

Arguments:

    pFilter - Generic filter for which specific filters
              are to be created.

    pSrcAddrList - List of source addresses.

    dwSrcAddrCnt - Number of addresses in the source
                   address list.

    pDesAddrList - List of destination addresses.

    dwDesAddrCnt - Number of addresses in the destination
                   address list.

    ppSpecificFilters - Specific filters created for the given
                        generic filter and the given addresses.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMSFILTER pSpecificFilters = NULL;
    DWORD i = 0, j = 0;
    PINIMMSFILTER pSpecificFilter = NULL;



    for (i = 0; i < dwSrcAddrCnt; i++) {

        for (j = 0; j < dwDesAddrCnt; j++) {

            dwError = CreateSpecificMMFilter(
                          pFilter,
                          pSrcAddrList[i],
                          pDesAddrList[j],
                          &pSpecificFilter
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            //
            // Set the direction of the filter.
            //

            pSpecificFilter->dwDirection = dwDirection;

            AssignMMFilterWeight(pSpecificFilter);

            AddToSpecificMMList(
                &pSpecificFilters,
                pSpecificFilter
                );

        }

    }

    *ppSpecificFilters = pSpecificFilters;
    return (dwError);

error:

    if (pSpecificFilters) {
        FreeIniMMSFilterList(pSpecificFilters);
    }

    *ppSpecificFilters = NULL;
    return (dwError);
}


DWORD
CreateSpecificMMFilter(
    PINIMMFILTER pGenericFilter,
    ADDR SrcAddr,
    ADDR DesAddr,
    PINIMMSFILTER * ppSpecificFilter
    )
{
    DWORD dwError = 0; 
    PINIMMSFILTER pSpecificFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INIMMSFILTER),
                    &pSpecificFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->cRef = 0;

    CopyGuid(pGenericFilter->gFilterID, &(pSpecificFilter->gParentID));

    dwError = AllocateSPDString(
                  pGenericFilter->pszFilterName,
                  &(pSpecificFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->InterfaceType = pGenericFilter->InterfaceType;

    pSpecificFilter->dwFlags = pGenericFilter->dwFlags;

    CopyAddresses(SrcAddr, &(pSpecificFilter->SrcAddr));

    CopyAddresses(DesAddr, &(pSpecificFilter->DesAddr));

    //
    // Direction must be set in the calling routine.
    //

    pSpecificFilter->dwDirection = 0;

    //
    // Weight must be set in the calling routine.
    //

    pSpecificFilter->dwWeight = 0;

    CopyGuid(pGenericFilter->gMMAuthID, &(pSpecificFilter->gMMAuthID));

    CopyGuid(pGenericFilter->gPolicyID, &(pSpecificFilter->gPolicyID));

    pSpecificFilter->pIniMMAuthMethods = NULL;

    pSpecificFilter->pIniMMPolicy = NULL;

    pSpecificFilter->pNext = NULL;

    *ppSpecificFilter = pSpecificFilter;
    return (dwError);

error:

    if (pSpecificFilter) {
        FreeIniMMSFilter(pSpecificFilter);
    }

    *ppSpecificFilter = NULL;
    return (dwError);
}


VOID
AssignMMFilterWeight(
    PINIMMSFILTER pSpecificFilter
    )
/*++

Routine Description:

    Computes and assigns the weight to a specific mm filter.

    The mm filter weight consists of the following:

    31         16       12           8        0
    +-----------+--------+-----------+--------+
    |AddrMaskWgt|           Reserved          |
    +-----------+--------+-----------+--------+

Arguments:

    pSpecificFilter - Specific mm filter to which the weight 
                      is to be assigned.

Return Value:

    None.

--*/
{
    DWORD dwWeight = 0;
    ULONG SrcMask = 0;
    ULONG DesMask = 0;
    DWORD dwMaskWeight = 0;
    DWORD i = 0;


    //
    // Weight Rule:
    // A field with a more specific value gets a higher weight than
    // the same field with a lesser specific value.
    //

    //
    // IP addresses get the weight values based on their mask values.
    // In the address case, the weight is computed as a sum of the 
    // bit positions starting from the position that contains the 
    // first least significant non-zero bit to the most significant
    // bit position of the mask. 
    // All unique ip addresses have a mask of 0xFFFFFFFF and thus get
    // the same weight, which is 1 + 2 + .... + 32.
    // A subnet address has a mask with atleast the least significant
    // bit zero and thus gets weight in the range (2 + .. + 32) to 0.
    //
  
    DesMask = ntohl(pSpecificFilter->DesAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((DesMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         DesMask = DesMask >> 1;

    }


    SrcMask = ntohl(pSpecificFilter->SrcAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((SrcMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         SrcMask = SrcMask >> 1;

    }

    //
    // Move the mask weight to the set of bits in the overall weight
    // that it occupies.
    //

    dwMaskWeight = dwMaskWeight << 16;

    dwWeight += dwMaskWeight;

    pSpecificFilter->dwWeight = dwWeight;
}


VOID
AddToSpecificMMList(
    PINIMMSFILTER * ppSpecificMMFilterList,
    PINIMMSFILTER pSpecificMMFilters
    )
{
    PINIMMSFILTER pListOne = NULL;
    PINIMMSFILTER pListTwo = NULL;
    PINIMMSFILTER pListMerge = NULL;
    PINIMMSFILTER pLast = NULL;

    if (!(*ppSpecificMMFilterList) && !pSpecificMMFilters) {
        return;
    }

    if (!(*ppSpecificMMFilterList)) {
        *ppSpecificMMFilterList = pSpecificMMFilters;
        return;
    }

    if (!pSpecificMMFilters) {
        return;
    }

    pListOne = *ppSpecificMMFilterList;
    pListTwo = pSpecificMMFilters;

    while (pListOne && pListTwo) {

        if ((pListOne->dwWeight) > (pListTwo->dwWeight)) {

            if (!pListMerge) {
                pListMerge = pListOne;
                pLast = pListOne;
                pListOne = pListOne->pNext;
            }
            else {
                pLast->pNext = pListOne;
                pListOne = pListOne->pNext;
                pLast = pLast->pNext;
            }

        }
        else {

            if (!pListMerge) {
                pListMerge = pListTwo;
                pLast = pListTwo;
                pListTwo = pListTwo->pNext;
            }
            else {
                pLast->pNext = pListTwo;
                pListTwo = pListTwo->pNext;
                pLast = pLast->pNext;
            }

        }

    }

    if (pListOne) {
        pLast->pNext = pListOne;
    }
    else {
        pLast->pNext = pListTwo;
    }

    *ppSpecificMMFilterList = pListMerge;
    return;
}


VOID
FreeIniMMSFilterList(
    PINIMMSFILTER pIniMMSFilterList
    )
{
    PINIMMSFILTER pFilter = NULL;
    PINIMMSFILTER pTempFilter = NULL;

    pFilter = pIniMMSFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniMMSFilter(pTempFilter);
    }
}


VOID
FreeIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter
    )
{
    if (pIniMMSFilter) {
        if (pIniMMSFilter->pszFilterName) {
            FreeSPDString(pIniMMSFilter->pszFilterName);
        }

        //
        // Must not ever free pIniMMSFilter->pIniMMPolicy.
        //

        FreeSPDMemory(pIniMMSFilter);
    }
}


VOID
LinkMMSpecificFiltersToPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMSFILTER pIniMMSFilters
    )
{
    PINIMMSFILTER pTemp = NULL;

    pTemp = pIniMMSFilters;

    while (pTemp) {
        pTemp->pIniMMPolicy = pIniMMPolicy;
        pTemp = pTemp->pNext;
    }

    return;
}


VOID
LinkMMSpecificFiltersToAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMSFILTER pIniMMSFilters
    )
{
    PINIMMSFILTER pTemp = NULL;

    pTemp = pIniMMSFilters;

    while (pTemp) {
        pTemp->pIniMMAuthMethods = pIniMMAuthMethods;
        pTemp = pTemp->pNext;
    }

    return;
}


VOID
RemoveIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter
    )
{
    PINIMMSFILTER * ppTemp = NULL;

    ppTemp = &gpIniMMSFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniMMSFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniMMSFilter->pNext;
    }

    return;
}


DWORD
EnumSpecificMMFilters(
    PINIMMSFILTER pIniMMSFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters.

Arguments:

    pIniMMSFilterList - List of specific filters to enumerate.

    dwResumeHandle - Location in the specific filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppMMFilters - Enumerated filters returned to the caller.

    pdwNumMMFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINIMMSFILTER pIniMMSFilter = NULL;
    DWORD i = 0;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwNumMMFilters = 0;
    PMM_FILTER pMMFilters = 0;
    PMM_FILTER pMMFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_MMFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniMMSFilter = pIniMMSFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniMMSFilter != NULL); i++) {
        pIniMMSFilter = pIniMMSFilter->pNext;
    }

    if (!pIniMMSFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniMMSFilter;

    while (pTemp && (dwNumMMFilters < dwNumToEnum)) {
        dwNumMMFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER)*dwNumMMFilters,
                  &pMMFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniMMSFilter;
    pMMFilter = pMMFilters;

    for (i = 0; i < dwNumMMFilters; i++) {

        dwError = CopyMMSFilter(
                      pTemp,
                      pMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pMMFilter++;

    }

    *ppMMFilters = pMMFilters;
    *pdwNumMMFilters = dwNumMMFilters;
    return (dwError);

error:

    if (pMMFilters) {
        FreeMMFilters(
            i,
            pMMFilters
            );
    }

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;

    return (dwError);
}


DWORD
CopyMMSFilter(
    PINIMMSFILTER pIniMMSFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniMMSFilter - Internal filter to copy.

    pMMFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    CopyGuid(pIniMMSFilter->gParentID, &(pMMFilter->gFilterID));

    dwError = CopyName(
                  pIniMMSFilter->pszFilterName,
                  &(pMMFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->InterfaceType = pIniMMSFilter->InterfaceType;

    pMMFilter->bCreateMirror = FALSE;

    pMMFilter->dwFlags = pIniMMSFilter->dwFlags;

    CopyAddresses(pIniMMSFilter->SrcAddr, &(pMMFilter->SrcAddr));

    CopyAddresses(pIniMMSFilter->DesAddr, &(pMMFilter->DesAddr));

    pMMFilter->dwDirection = pIniMMSFilter->dwDirection;

    pMMFilter->dwWeight = pIniMMSFilter->dwWeight;

    CopyGuid(pIniMMSFilter->gMMAuthID, &(pMMFilter->gMMAuthID));

    CopyGuid(pIniMMSFilter->gPolicyID, &(pMMFilter->gPolicyID));

error:

    return (dwError);
}


DWORD
EnumSelectSpecificMMFilters(
    PINIMMFILTER pIniMMFilter,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters for
    the given generic filter.

Arguments:

    pIniMMFilter - Generic filter for which specific filters
                   are to be enumerated.

    dwResumeHandle - Location in the specific filter list for the
                     given generic filter from which to resume
                     enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppMMFilters - Enumerated filters returned to the caller.

    pdwNumMMFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    DWORD dwNumMMSFilters = 0; 
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD i = 0;
    DWORD dwNumMMFilters = 0;
    PMM_FILTER pMMFilters = 0;
    PMM_FILTER pMMFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_MMFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    dwNumMMSFilters = pIniMMFilter->dwNumMMSFilters;
    ppIniMMSFilters = pIniMMFilter->ppIniMMSFilters;

    if (!dwNumMMSFilters || (dwNumMMSFilters <= dwResumeHandle)) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumMMFilters = min((dwNumMMSFilters-dwResumeHandle),
                         dwNumToEnum);
 
    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER)*dwNumMMFilters,
                  &pMMFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter = pMMFilters;

    for (i = 0; i < dwNumMMFilters; i++) {

        dwError = CopyMMSFilter(
                      *(ppIniMMSFilters + (dwResumeHandle + i)),
                      pMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        pMMFilter++;

    }

    *ppMMFilters = pMMFilters;
    *pdwNumMMFilters = dwNumMMFilters;
    return (dwError);

error:

    if (pMMFilters) {
        FreeMMFilters(
            i,
            pMMFilters
            );
    }

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;

    return (dwError);
}


DWORD
MatchMMFilter(
    LPWSTR pServerName,
    PMM_FILTER pMMFilter,
    DWORD dwFlags,
    PMM_FILTER * ppMatchedMMFilters,
    PIPSEC_MM_POLICY * ppMatchedMMPolicies,
    PMM_AUTH_METHODS * ppMatchedMMAuthMethods,
    DWORD dwPreferredNumEntries,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle
    )
/*++

Routine Description:

    This function finds the matching mm filters for the given mm
    filter template. The matched filters can not be more specific
    than the given filter template.

Arguments:

    pServerName - Server on which a filter template is to be matched.

    pMMFilter - Filter template to match.

    dwFlags - Flags.

    ppMatchedMMFilters - Matched main mode filters returned to the
                         caller.

    ppMatchedMMPolicies - Main mode policies corresponding to the 
                          matched main mode filters returned to the
                          caller.

    ppMatchedMMAuthMethods - Main mode auth methods corresponding to the
                             matched main mode filters returned to the
                             caller.

    dwPreferredNumEntries - Preferred number of matched entries.

    pdwNumMatches - Number of filters actually matched.

    pdwResumeHandle - Handle to the location in the matched filter 
                      list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToMatch = 0;
    PINIMMSFILTER pIniMMSFilter = NULL;
    DWORD i = 0;
    BOOL bMatches = FALSE;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwNumMatches = 0;
    PINIMMSFILTER pLastMatchedFilter = NULL;
    PMM_FILTER pMatchedMMFilters = NULL;
    PIPSEC_MM_POLICY pMatchedMMPolicies = NULL;
    PMM_AUTH_METHODS pMatchedMMAuthMethods = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumPolicies = 0;
    DWORD dwNumAuthMethods = 0;
    PMM_FILTER pMatchedMMFilter = NULL;
    PIPSEC_MM_POLICY pMatchedMMPolicy = NULL;
    PMM_AUTH_METHODS pTempMMAuthMethods = NULL;


    dwError = ValidateMMFilterTemplate(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries) {
        dwNumToMatch = 1;
    }
    else if (dwPreferredNumEntries > MAX_MMFILTER_ENUM_COUNT) {
        dwNumToMatch = MAX_MMFILTER_ENUM_COUNT;
    }
    else {
        dwNumToMatch = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMSFilter = gpIniMMSFilter;

    while ((i < dwResumeHandle) && (pIniMMSFilter != NULL)) {
        bMatches = MatchIniMMSFilter(
                       pIniMMSFilter,
                       pMMFilter
                       );
        if (bMatches) {
            i++;
        }
        pIniMMSFilter = pIniMMSFilter->pNext;
    }

    if (!pIniMMSFilter) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyMMMatchDefaults(
                          &pMatchedMMFilters,
                          &pMatchedMMAuthMethods,
                          &pMatchedMMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    pTemp = pIniMMSFilter;

    while (pTemp && (dwNumMatches < dwNumToMatch)) {
        bMatches = MatchIniMMSFilter(
                       pTemp,
                       pMMFilter
                       );
        if (bMatches) {
            pLastMatchedFilter = pTemp;
            dwNumMatches++;
        }
        pTemp = pTemp->pNext;
    }

    if (!dwNumMatches) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyMMMatchDefaults(
                          &pMatchedMMFilters,
                          &pMatchedMMAuthMethods,
                          &pMatchedMMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER)*dwNumMatches,
                  &pMatchedMMFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_POLICY)*dwNumMatches,
                  &pMatchedMMPolicies
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_AUTH_METHODS)*dwNumMatches,
                  &pMatchedMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (dwNumMatches == 1) {

        dwError = CopyMMSFilter(
                      pLastMatchedFilter,
                      pMatchedMMFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        dwNumFilters++;

        if (pLastMatchedFilter->pIniMMPolicy) {
            dwError = CopyMMPolicy(
                          pLastMatchedFilter->pIniMMPolicy,
                          pMatchedMMPolicies
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            memset(pMatchedMMPolicies, 0, sizeof(IPSEC_MM_POLICY));
        }
        dwNumPolicies++;

        if (pLastMatchedFilter->pIniMMAuthMethods) {
            dwError = CopyMMAuthMethods(
                          pLastMatchedFilter->pIniMMAuthMethods,
                          pMatchedMMAuthMethods
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            memset(pMatchedMMAuthMethods, 0, sizeof(MM_AUTH_METHODS));
        }
        dwNumAuthMethods++;

    }
    else {

        pTemp = pIniMMSFilter;
        pMatchedMMFilter = pMatchedMMFilters;
        pMatchedMMPolicy = pMatchedMMPolicies;
        pTempMMAuthMethods = pMatchedMMAuthMethods;
        i = 0;

        while (i < dwNumMatches) {

            bMatches = MatchIniMMSFilter(
                           pTemp,
                           pMMFilter
                           );
            if (bMatches) {

                dwError = CopyMMSFilter(
                              pTemp,
                              pMatchedMMFilter
                              );
                BAIL_ON_LOCK_ERROR(dwError);
                pMatchedMMFilter++;
                dwNumFilters++;

                if (pTemp->pIniMMPolicy) {
                    dwError = CopyMMPolicy(
                                  pTemp->pIniMMPolicy,
                                  pMatchedMMPolicy
                                  );
                    BAIL_ON_LOCK_ERROR(dwError);
                }
                else {
                    memset(pMatchedMMPolicy, 0, sizeof(IPSEC_MM_POLICY));
                }
                pMatchedMMPolicy++;
                dwNumPolicies++;

                if (pTemp->pIniMMAuthMethods) {
                    dwError = CopyMMAuthMethods(
                                  pTemp->pIniMMAuthMethods,
                                  pTempMMAuthMethods
                                  );
                    BAIL_ON_LOCK_ERROR(dwError);
                }
                else {
                    memset(pTempMMAuthMethods, 0, sizeof(MM_AUTH_METHODS));
                }
                pTempMMAuthMethods++;
                dwNumAuthMethods++;

                i++;

            }

            pTemp = pTemp->pNext;

        }

    }

lock_success:

    LEAVE_SPD_SECTION();

    *ppMatchedMMFilters = pMatchedMMFilters;
    *ppMatchedMMPolicies = pMatchedMMPolicies;
    *ppMatchedMMAuthMethods = pMatchedMMAuthMethods;
    *pdwNumMatches = dwNumMatches;
    *pdwResumeHandle = dwResumeHandle + dwNumMatches;

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMatchedMMFilters) {
        FreeMMFilters(
            dwNumFilters,
            pMatchedMMFilters
            );
    }

    if (pMatchedMMPolicies) {
        FreeMMPolicies(
            dwNumPolicies,
            pMatchedMMPolicies
            );
    }

    if (pMatchedMMAuthMethods) {
        FreeMMAuthMethods(
            dwNumAuthMethods,
            pMatchedMMAuthMethods
            );
    }

    *ppMatchedMMFilters = NULL;
    *ppMatchedMMPolicies = NULL;
    *ppMatchedMMAuthMethods = NULL;
    *pdwNumMatches = 0;
    *pdwResumeHandle = dwResumeHandle;

    return (dwError);
}


DWORD
ValidateMMFilterTemplate(
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(pMMFilter->SrcAddr, TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(pMMFilter->DesAddr, TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pMMFilter->SrcAddr,
                     pMMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->dwDirection) {
        if ((pMMFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pMMFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
MatchIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter,
    PMM_FILTER pMMFilter
    )
{
    BOOL bMatches = FALSE;

    if (pMMFilter->dwDirection) {
        if (pMMFilter->dwDirection != pIniMMSFilter->dwDirection) {
            return (FALSE);
        }
    }

    bMatches = MatchAddresses(
                   pIniMMSFilter->SrcAddr,
                   pMMFilter->SrcAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniMMSFilter->DesAddr,
                   pMMFilter->DesAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CopyMMMatchDefaults(
    PMM_FILTER * ppMMFilters,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    PIPSEC_MM_POLICY * ppMMPolicies,
    PDWORD pdwNumMatches
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilters = NULL;
    PMM_AUTH_METHODS pMMAuthMethods = NULL;
    PIPSEC_MM_POLICY pMMPolicies = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumAuthMethods = 0;
    DWORD dwNumPolicies = 0;


    if (!gpIniDefaultMMPolicy) {
        dwError = ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!gpIniDefaultMMAuthMethods) {
        dwError = ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER),
                  &pMMFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_POLICY),
                  &pMMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_AUTH_METHODS),
                  &pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyDefaultMMFilter(
                  pMMFilters,
                  gpIniDefaultMMAuthMethods,
                  gpIniDefaultMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    dwNumFilters++;

    dwError = CopyMMPolicy(
                  gpIniDefaultMMPolicy,
                  pMMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pMMPolicies->dwFlags |= IPSEC_MM_POLICY_ON_NO_MATCH;
    dwNumPolicies++;

    dwError = CopyMMAuthMethods(
                  gpIniDefaultMMAuthMethods,
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pMMAuthMethods->dwFlags |= IPSEC_MM_AUTH_ON_NO_MATCH;
    dwNumAuthMethods++;

    *ppMMFilters = pMMFilters;
    *ppMMPolicies = pMMPolicies;
    *ppMMAuthMethods = pMMAuthMethods;
    *pdwNumMatches = 1;

    return (dwError);

error:

    if (pMMFilters) {
        FreeMMFilters(
            dwNumFilters,
            pMMFilters
            );
    }

    if (pMMPolicies) {
        FreeMMPolicies(
            dwNumPolicies,
            pMMPolicies
            );
    }

    if (pMMAuthMethods) {
        FreeMMAuthMethods(
            dwNumAuthMethods,
            pMMAuthMethods
            );
    }

    *ppMMFilters = NULL;
    *ppMMPolicies = NULL;
    *ppMMAuthMethods = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
CopyDefaultMMFilter(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy
    )
{
    DWORD dwError = 0;


    UuidCreate(&(pMMFilter->gFilterID));

    dwError = CopyName(
                  L"0",
                  &(pMMFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->InterfaceType = INTERFACE_TYPE_ALL;

    pMMFilter->bCreateMirror = TRUE;

    pMMFilter->dwFlags = 0;

    pMMFilter->dwFlags |= IPSEC_MM_POLICY_DEFAULT_POLICY;
    pMMFilter->dwFlags |= IPSEC_MM_AUTH_DEFAULT_AUTH;

    pMMFilter->SrcAddr.AddrType = IP_ADDR_SUBNET;
    pMMFilter->SrcAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pMMFilter->SrcAddr.uSubNetMask = SUBNET_MASK_ANY;

    pMMFilter->DesAddr.AddrType = IP_ADDR_SUBNET;
    pMMFilter->DesAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pMMFilter->DesAddr.uSubNetMask = SUBNET_MASK_ANY;

    pMMFilter->dwDirection = 0;

    pMMFilter->dwWeight = 0;

    CopyGuid(pIniMMAuthMethods->gMMAuthID, &(pMMFilter->gMMAuthID));

    CopyGuid(pIniMMPolicy->gPolicyID, &(pMMFilter->gPolicyID));

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\pamm-fil.h ===
//
// PAStore Interface types.
//

#define PASTORE_IF_TYPE_NONE    0x00000000
#define PASTORE_IF_TYPE_DIALUP  0xFFFFFFFF
#define PASTORE_IF_TYPE_LAN     0xFFFFFFFE
#define PASTORE_IF_TYPE_ALL     0xFFFFFFFD


typedef struct _mmfilterstate {
    GUID gFilterID;
    GUID gPolicyID;
    GUID gMMAuthID;
    HANDLE hMMFilter;
    struct _mmfilterstate * pNext;
} MMFILTERSTATE, * PMMFILTERSTATE;


DWORD
PAAddMMFilters(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PAAddMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
PACreateMMFilterState(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PMMFILTERSTATE * ppMMFilterState
    );

DWORD
PACreateMMFilter(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PMM_FILTER * ppSPDMMFilter
    );

VOID
PASetInterfaceType(
    DWORD dwInterfaceType,
    PIF_TYPE pInterfaceType
    );

VOID
PASetAddress(
    ULONG uMask,
    ULONG uAddr,
    PADDR pAddr
    );

VOID
PASetTunnelAddress(
    ULONG uAddr,
    PADDR pAddr
    );

VOID
PAFreeMMFilter(
    PMM_FILTER pSPDMMFilter
    );

DWORD
PADeleteAllMMFilters(
    );

VOID
PAFreeMMFilterStateList(
    PMMFILTERSTATE pMMFilterState
    );

DWORD
PADeleteMMFilters(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PADeleteMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
PADeleteMMFilter(
    GUID gFilterID
    );

VOID
PADeleteMMFilterState(
    PMMFILTERSTATE pMMFilterState
    );

PMMFILTERSTATE
FindMMFilterState(
    GUID gFilterID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\mmspecific.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmspecific.h

Abstract:

    This module contains all of the code prototypes to
    drive the specific mm filter list management of 
    IPSecSPD Service.

Author:


Environment


Revision History:


--*/


DWORD
ApplyMMTransform(
    PINIMMFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PINIMMSFILTER * ppSpecificFilters
    );

DWORD
FormMMOutboundInboundAddresses(
    PINIMMFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PADDR * ppOutSrcAddrList,
    PDWORD pdwOutSrcAddrCnt,
    PADDR * ppInSrcAddrList,
    PDWORD pdwInSrcAddrCnt,
    PADDR * ppOutDesAddrList,
    PDWORD pdwOutDesAddrCnt,
    PADDR * ppInDesAddrList,
    PDWORD pdwInDesAddrCnt
    );

DWORD
FormSpecificMMFilters(
    PINIMMFILTER pFilter,
    PADDR pSrcAddrList,
    DWORD dwSrcAddrCnt,
    PADDR pDesAddrList,
    DWORD dwDesAddrCnt,
    DWORD dwDirection,
    PINIMMSFILTER * ppSpecificFilters
    );

DWORD
CreateSpecificMMFilter(
    PINIMMFILTER pGenericFilter,
    ADDR SrcAddr,
    ADDR DesAddr,
    PINIMMSFILTER * ppSpecificFilter
    );

VOID
AssignMMFilterWeight(
    PINIMMSFILTER pSpecificFilter
    );

VOID
AddToSpecificMMList(
    PINIMMSFILTER * ppSpecificMMFilterList,
    PINIMMSFILTER pSpecificMMFilters
    );

VOID
FreeIniMMSFilterList(
    PINIMMSFILTER pIniMMSFilterList
    );

VOID
FreeIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter
    );

VOID
LinkMMSpecificFiltersToPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMSFILTER pIniMMSFilters
    );

VOID
LinkMMSpecificFiltersToAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMSFILTER pIniMMSFilters
    );

VOID
RemoveIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter
    );

DWORD
EnumSpecificMMFilters(
    PINIMMSFILTER pIniMMSFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    );

DWORD
CopyMMSFilter(
    PINIMMSFILTER pIniMMSFilter,
    PMM_FILTER pMMFilter
    );

DWORD
EnumSelectSpecificMMFilters(
    PINIMMFILTER pIniMMFilter,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    );

DWORD
ValidateMMFilterTemplate(
    PMM_FILTER pMMFilter
    );

BOOL
MatchIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter,
    PMM_FILTER pMMFilter
    );

DWORD
CopyMMMatchDefaults(
    PMM_FILTER * ppMMFilters,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    PIPSEC_MM_POLICY * ppMMPolicies,
    PDWORD pdwNumMatches
    );

DWORD
CopyDefaultMMFilter(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\pamm-pol.c ===
#include "precomp.h"

   
DWORD
PAAddMMPolicies(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    PIPSEC_MM_POLICY pSPDMMPolicy = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;


    for (i = 0; i < dwNumPolicies; i++) {

        dwError = PACreateMMPolicyState(
                      *(ppIpsecISAKMPData + i),
                      &pMMPolicyState
                      );
        if (dwError) {
            continue;
        }

        dwError = PACreateMMPolicy(
                      *(ppIpsecISAKMPData + i),
                      pMMPolicyState,
                      &pSPDMMPolicy
                      );
        if (dwError) {

            pMMPolicyState->bInSPD = FALSE;
            pMMPolicyState->dwErrorCode = dwError;

            pMMPolicyState->pNext = gpMMPolicyState;
            gpMMPolicyState = pMMPolicyState;

            continue;

        }

        dwError = AddMMPolicy(
                      pServerName,
                      dwPersist,
                      pSPDMMPolicy
                      );
        if (dwError) {
            pMMPolicyState->bInSPD = FALSE;
            pMMPolicyState->dwErrorCode = dwError;
        }
        else {
            pMMPolicyState->bInSPD = TRUE;
            pMMPolicyState->dwErrorCode = ERROR_SUCCESS;
        }

        pMMPolicyState->pNext = gpMMPolicyState;
        gpMMPolicyState = pMMPolicyState;

        PAFreeMMPolicy(pSPDMMPolicy);

    }

    return (dwError);
}


DWORD
PACreateMMPolicyState(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PMMPOLICYSTATE * ppMMPolicyState
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    WCHAR pszName[512];    


    dwError = AllocateSPDMemory(
                  sizeof(MMPOLICYSTATE),
                  &pMMPolicyState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pMMPolicyState->gPolicyID),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    wsprintf(pszName, L"%d", ++gdwMMPolicyCounter);

    dwError = AllocateSPDString(
                  pszName,
                  &(pMMPolicyState->pszPolicyName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMPolicyState->bInSPD = FALSE;
    pMMPolicyState->dwErrorCode = 0;
    pMMPolicyState->pNext = NULL;

    *ppMMPolicyState = pMMPolicyState;

    return (dwError);

error:

    if (pMMPolicyState) {
        PAFreeMMPolicyState(pMMPolicyState);
    }

    *ppMMPolicyState = NULL;

    return (dwError);
}


VOID
PAFreeMMPolicyState(
    PMMPOLICYSTATE pMMPolicyState
    )
{
    if (pMMPolicyState) {
        if (pMMPolicyState->pszPolicyName) {
            FreeSPDString(pMMPolicyState->pszPolicyName);
        }
        FreeSPDMemory(pMMPolicyState);
    }
}


DWORD
PACreateMMPolicy(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PMMPOLICYSTATE pMMPolicyState,
    PIPSEC_MM_POLICY * ppSPDMMPolicy
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pSPDMMPolicy = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_MM_POLICY),
                  &pSPDMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pSPDMMPolicy->gPolicyID),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    dwError = AllocateSPDString(
                  pMMPolicyState->pszPolicyName,
                  &(pSPDMMPolicy->pszPolicyName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSPDMMPolicy->dwFlags = 0;
    pSPDMMPolicy->dwFlags |= IPSEC_MM_POLICY_DEFAULT_POLICY;
    
    dwError = PACreateMMOffers(
                  pIpsecISAKMPData->dwNumISAKMPSecurityMethods,
                  pIpsecISAKMPData->pSecurityMethods,
                  &(pSPDMMPolicy->dwOfferCount),
                  &(pSPDMMPolicy->pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSPDMMPolicy->uSoftSAExpirationTime = 
    (pSPDMMPolicy->pOffers)->Lifetime.uKeyExpirationTime;

    *ppSPDMMPolicy = pSPDMMPolicy;

    return (dwError);

error:

    if (pSPDMMPolicy) {
        PAFreeMMPolicy(
            pSPDMMPolicy
            );
    }

    *ppSPDMMPolicy = NULL;

    return (dwError);
}


DWORD
PACreateMMOffers(
    DWORD dwNumISAKMPSecurityMethods,
    PCRYPTO_BUNDLE pSecurityMethods,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    DWORD dwOfferCount = 0;
    PIPSEC_MM_OFFER pOffers = NULL;
    PIPSEC_MM_OFFER pTempOffer = NULL;
    PCRYPTO_BUNDLE pTempBundle = NULL;
    DWORD i = 0;


    if (!dwNumISAKMPSecurityMethods || !pSecurityMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNumISAKMPSecurityMethods > IPSEC_MAX_MM_OFFERS) {
        dwOfferCount = IPSEC_MAX_MM_OFFERS;
    }
    else {
        dwOfferCount = dwNumISAKMPSecurityMethods;
    }

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_MM_OFFER)*dwOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTempOffer = pOffers;
    pTempBundle = pSecurityMethods;

    for (i = 0; i < dwOfferCount; i++) {

        PACopyMMOffer(
            pTempBundle,
            pTempOffer
            );

        pTempOffer++;
        pTempBundle++;

    }

    *pdwOfferCount = dwOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:

    if (pOffers) {
        PAFreeMMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


VOID
PACopyMMOffer(
    PCRYPTO_BUNDLE pBundle,
    PIPSEC_MM_OFFER pOffer
    )
{
    pOffer->Lifetime.uKeyExpirationKBytes = pBundle->Lifetime.KBytes;
    pOffer->Lifetime.uKeyExpirationTime = pBundle->Lifetime.Seconds;

    pOffer->dwFlags = 0;

    pOffer->dwQuickModeLimit = pBundle->QuickModeLimit;

    pOffer->dwDHGroup = pBundle->OakleyGroup;

    if ((pOffer->dwDHGroup != DH_GROUP_1) && 
        (pOffer->dwDHGroup != DH_GROUP_2)) {
         pOffer->dwDHGroup = DH_GROUP_1;
    }

    switch (pBundle->EncryptionAlgorithm.AlgorithmIdentifier) {

    case IPSEC_ESP_DES:
        pOffer->EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_DES;
        break;

    case IPSEC_ESP_DES_40:
        pOffer->EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_DES;
        break;

    case IPSEC_ESP_3_DES:
        pOffer->EncryptionAlgorithm.uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
        break;

    default:
        pOffer->EncryptionAlgorithm.uAlgoIdentifier= IPSEC_DOI_ESP_NONE;
        break;

    }

    pOffer->EncryptionAlgorithm.uAlgoKeyLen = 
    pBundle->EncryptionAlgorithm.KeySize;

    pOffer->EncryptionAlgorithm.uAlgoRounds = 
    pBundle->EncryptionAlgorithm.Rounds;

    switch(pBundle->HashAlgorithm.AlgorithmIdentifier) {

    case IPSEC_AH_MD5:
        pOffer->HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_MD5;
        break;

    case IPSEC_AH_SHA:
        pOffer->HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_SHA1;
        break;

    default:
        pOffer->HashingAlgorithm.uAlgoIdentifier = IPSEC_DOI_AH_NONE;
        break;

    }

    pOffer->HashingAlgorithm.uAlgoKeyLen = 
    pBundle->HashAlgorithm.KeySize;

    pOffer->HashingAlgorithm.uAlgoRounds = 
    pBundle->HashAlgorithm.Rounds;
}


VOID
PAFreeMMPolicy(
    PIPSEC_MM_POLICY pSPDMMPolicy
    )
{
    if (pSPDMMPolicy) {

        if (pSPDMMPolicy->pszPolicyName) {
            FreeSPDString(pSPDMMPolicy->pszPolicyName);
        }

        PAFreeMMOffers(
            pSPDMMPolicy->dwOfferCount,
            pSPDMMPolicy->pOffers
            );

        FreeSPDMemory(pSPDMMPolicy);

    }
}


VOID
PAFreeMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    if (pOffers) {
        FreeSPDMemory(pOffers);
    }
}


DWORD
PADeleteAllMMPolicies(
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    PMMPOLICYSTATE pTemp = NULL;
    PMMPOLICYSTATE pLeftMMPolicyState = NULL;


    pMMPolicyState = gpMMPolicyState;

    while (pMMPolicyState) {

        if (pMMPolicyState->bInSPD) {

            dwError = DeleteMMPolicy(
                          pServerName,
                          pMMPolicyState->pszPolicyName
                          );
            if (!dwError) {
                pTemp = pMMPolicyState;
                pMMPolicyState = pMMPolicyState->pNext;
                PAFreeMMPolicyState(pTemp);
            } 
            else {
                pMMPolicyState->dwErrorCode = dwError;

                pTemp = pMMPolicyState;
                pMMPolicyState = pMMPolicyState->pNext;

                pTemp->pNext = pLeftMMPolicyState;
                pLeftMMPolicyState = pTemp;
            }

        }
        else {

            pTemp = pMMPolicyState;
            pMMPolicyState = pMMPolicyState->pNext;
            PAFreeMMPolicyState(pTemp);

        }

    }

    gpMMPolicyState = pLeftMMPolicyState;
    
    return (dwError);
}


VOID
PAFreeMMPolicyStateList(
    PMMPOLICYSTATE pMMPolicyState
    )
{
    PMMPOLICYSTATE pTemp = NULL;


    while (pMMPolicyState) {

        pTemp = pMMPolicyState;
        pMMPolicyState = pMMPolicyState->pNext;
        PAFreeMMPolicyState(pTemp);

    }
}


PMMPOLICYSTATE
FindMMPolicyState(
    GUID gPolicyID
    )
{
    PMMPOLICYSTATE pMMPolicyState = NULL;


    pMMPolicyState = gpMMPolicyState;

    while (pMMPolicyState) {

        if (!memcmp(&(pMMPolicyState->gPolicyID), &gPolicyID, sizeof(GUID))) {
            return (pMMPolicyState);
        }

        pMMPolicyState = pMMPolicyState->pNext;

    }

    return (NULL);
}


DWORD
PADeleteMMPolicies(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    for (i = 0; i < dwNumPolicies; i++) {

        pIpsecISAKMPData = *(ppIpsecISAKMPData + i);

        dwError = PADeleteMMPolicy(
                      pIpsecISAKMPData->ISAKMPIdentifier
                      );

    }

    return (dwError);
}


DWORD
PADeleteMMPolicy(
    GUID gPolicyID
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    LPWSTR pServerName = NULL;


    pMMPolicyState = FindMMPolicyState(
                         gPolicyID
                         );
    if (!pMMPolicyState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pMMPolicyState->bInSPD) {

        dwError = DeleteMMPolicy(
                      pServerName,
                      pMMPolicyState->pszPolicyName
                      );
        if (dwError) {
            pMMPolicyState->dwErrorCode = dwError;
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteMMPolicyState(pMMPolicyState);

error:

    return (dwError);
}


VOID
PADeleteMMPolicyState(
    PMMPOLICYSTATE pMMPolicyState
    )
{
    PMMPOLICYSTATE * ppTemp = NULL;


    ppTemp = &gpMMPolicyState;

    while (*ppTemp) {

        if (*ppTemp == pMMPolicyState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pMMPolicyState->pNext;
    }

    PAFreeMMPolicyState(pMMPolicyState);

    return;
}


DWORD
PADeleteInUseMMPolicies(
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    PMMPOLICYSTATE pTemp = NULL;
    PMMPOLICYSTATE pLeftMMPolicyState = NULL;


    pMMPolicyState = gpMMPolicyState;

    while (pMMPolicyState) {

        if (pMMPolicyState->bInSPD &&
            (pMMPolicyState->dwErrorCode == ERROR_IPSEC_MM_POLICY_IN_USE)) {

            dwError = DeleteMMPolicy(
                          pServerName,
                          pMMPolicyState->pszPolicyName
                          );
            if (!dwError) {
                pTemp = pMMPolicyState;
                pMMPolicyState = pMMPolicyState->pNext;
                PAFreeMMPolicyState(pTemp);
            }
            else {
                pTemp = pMMPolicyState;
                pMMPolicyState = pMMPolicyState->pNext;

                pTemp->pNext = pLeftMMPolicyState;
                pLeftMMPolicyState = pTemp;
            }

        }
        else {

            pTemp = pMMPolicyState;
            pMMPolicyState = pMMPolicyState->pNext;

            pTemp->pNext = pLeftMMPolicyState;
            pLeftMMPolicyState = pTemp;

        }

    }

    gpMMPolicyState = pLeftMMPolicyState;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\pamm-pol.h ===
typedef struct _mmpolicystate {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    BOOL bInSPD;
    DWORD dwErrorCode;
    struct _mmpolicystate * pNext;
} MMPOLICYSTATE, * PMMPOLICYSTATE;


DWORD
PAAddMMPolicies(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    );

DWORD
PACreateMMPolicyState(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PMMPOLICYSTATE * ppMMPolicyState
    );

VOID
PAFreeMMPolicyState(
    PMMPOLICYSTATE pMMPolicyState
    );

DWORD
PACreateMMPolicy(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PMMPOLICYSTATE pMMPolicyState,
    PIPSEC_MM_POLICY * ppSPDMMPolicy
    );

DWORD
PACreateMMOffers(
    DWORD dwNumISAKMPSecurityMethods,
    PCRYPTO_BUNDLE pSecurityMethods,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    );

VOID
PACopyMMOffer(
    PCRYPTO_BUNDLE pBundle,
    PIPSEC_MM_OFFER pOffer
    );

VOID
PAFreeMMPolicy(
    PIPSEC_MM_POLICY pSPDMMPolicy
    );

VOID
PAFreeMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    );

DWORD
PADeleteAllMMPolicies(
    );

VOID
PAFreeMMPolicyStateList(
    PMMPOLICYSTATE pMMPolicyState
    );

PMMPOLICYSTATE
FindMMPolicyState(
    GUID gPolicyID
    );

DWORD
PADeleteMMPolicies(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    );

DWORD
PADeleteMMPolicy(
    GUID gPolicyID
    );

VOID
PADeleteMMPolicyState(
    PMMPOLICYSTATE pMMPolicyState
    );

DWORD
PADeleteInUseMMPolicies(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\pammauth.h ===
typedef struct _mmauthstate {
    GUID gMMAuthID;
    BOOL bInSPD;
    DWORD dwErrorCode;
    struct _mmauthstate * pNext;
} MMAUTHSTATE, * PMMAUTHSTATE;


DWORD
PAAddMMAuthMethods(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PACreateMMAuthState(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PMMAUTHSTATE * ppMMAuthState
    );

DWORD
PACreateMMAuthMethods(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PMM_AUTH_METHODS * ppSPDMMAuthMethods
    );

DWORD
PACreateMMAuthInfos(
    DWORD dwAuthMethodCount,
    PIPSEC_AUTH_METHOD * ppAuthMethods,
    PDWORD pdwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    );

VOID
PAFreeMMAuthMethods(
    PMM_AUTH_METHODS pSPDMMAuthMethods
    );

VOID
PAFreeMMAuthInfos(
    DWORD dwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo
    );

DWORD
PADeleteAllMMAuthMethods(
    );

VOID
PAFreeMMAuthStateList(
    PMMAUTHSTATE pMMAuthState
    );

PMMAUTHSTATE
FindMMAuthState(
    GUID gMMAuthID
    );

DWORD
PADeleteMMAuthMethods(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PADeleteMMAuthMethod(
    GUID gMMAuthID
    );

VOID
PADeleteMMAuthState(
    PMMAUTHSTATE pMMAuthState
    );

DWORD
PADeleteInUseMMAuthMethods(
    );

DWORD
EncodeName(
    LPWSTR pszSubjectName,
    PBYTE * ppEncodedName,
    PDWORD pdwEncodedLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\pamm-fil.c ===
#include "precomp.h"


DWORD
PAAddMMFilters(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;


    for (i = 0; i < dwNumNFACount; i++) {

        dwError = PAAddMMFilterSpecs(
                      pIpsecISAKMPData,
                      *(ppIpsecNFAData + i)
                      );

    }

    return (dwError);
}


DWORD
PAAddMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    PMMAUTHSTATE pMMAuthState = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PMMFILTERSTATE pMMFilterState = NULL;
    PMM_FILTER pSPDMMFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (IsClearOnly(pIpsecNegPolData->NegPolAction) ||
        IsBlocking(pIpsecNegPolData->NegPolAction)) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pMMPolicyState = FindMMPolicyState(
                         pIpsecISAKMPData->ISAKMPIdentifier
                         );
    if (!pMMPolicyState || !(pMMPolicyState->bInSPD)) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    pMMAuthState = FindMMAuthState(
                       pIpsecNFAData->NFAIdentifier
                       );
    if (!pMMAuthState || !(pMMAuthState->bInSPD)) {
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    

    for (i = 0; i < dwNumFilterSpecs; i++) {

        dwError = PACreateMMFilterState(
                      pIpsecISAKMPData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      &pMMFilterState
                      );
        if (dwError) {
            continue;
        }

        dwError = PACreateMMFilter(
                      pIpsecISAKMPData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      &pSPDMMFilter
                      );
        if (dwError) {

            pMMFilterState->hMMFilter = NULL;

            pMMFilterState->pNext = gpMMFilterState;
            gpMMFilterState = pMMFilterState;

            continue;

        }

        dwError = AddMMFilter(
                      pServerName,
                      dwPersist,
                      pSPDMMFilter,
                      &(pMMFilterState->hMMFilter)
                      );

        pMMFilterState->pNext = gpMMFilterState;
        gpMMFilterState = pMMFilterState;

        PAFreeMMFilter(pSPDMMFilter);

    }

    return (dwError);
}


DWORD
PACreateMMFilterState(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PMMFILTERSTATE * ppMMFilterState
    )
{
    DWORD dwError = 0;
    PMMFILTERSTATE pMMFilterState = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(MMFILTERSTATE),
                  &pMMFilterState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pMMFilterState->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    memcpy(
        &(pMMFilterState->gPolicyID),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pMMFilterState->gMMAuthID),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    pMMFilterState->hMMFilter = NULL;
    pMMFilterState->pNext = NULL;

    *ppMMFilterState = pMMFilterState;

    return (dwError);

error:

    *ppMMFilterState = NULL;

    return (dwError);
}


DWORD
PACreateMMFilter(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PMM_FILTER * ppSPDMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER pSPDMMFilter = NULL;
    WCHAR pszName[512];


    dwError = AllocateSPDMemory(
                  sizeof(MM_FILTER),
                  &pSPDMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pSPDMMFilter->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    if (pFilterSpec->pszDescription && *(pFilterSpec->pszDescription)) {

        dwError = AllocateSPDString(
                      pFilterSpec->pszDescription,
                      &(pSPDMMFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        wsprintf(pszName, L"%d", ++gdwMMFilterCounter);

        dwError = AllocateSPDString(
                      pszName,
                      &(pSPDMMFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PASetInterfaceType(
        pIpsecNFAData->dwInterfaceType,
        &(pSPDMMFilter->InterfaceType)
        );

    pSPDMMFilter->bCreateMirror = (BOOL) pFilterSpec->dwMirrorFlag;

    pSPDMMFilter->dwFlags = 0;

    if (!(pIpsecNFAData->dwTunnelFlags)) {

        PASetAddress(
            pFilterSpec->Filter.SrcMask,
            pFilterSpec->Filter.SrcAddr,
            &(pSPDMMFilter->SrcAddr)
            );

        PASetAddress(
            pFilterSpec->Filter.DestMask,
            pFilterSpec->Filter.DestAddr, 
            &(pSPDMMFilter->DesAddr)
            );
            
    }
    else {

        PASetAddress(
            IP_ADDRESS_MASK_NONE,
            IP_ADDRESS_ME,
            &(pSPDMMFilter->SrcAddr)
            );
        pSPDMMFilter->bCreateMirror = TRUE;
                           
        PASetTunnelAddress(
            ((ULONG) pIpsecNFAData->dwTunnelIpAddr),
            &(pSPDMMFilter->DesAddr)
            );

    }

    pSPDMMFilter->dwDirection = 0;

    pSPDMMFilter->dwWeight = 0;

    memcpy(
        &(pSPDMMFilter->gPolicyID),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pSPDMMFilter->gMMAuthID),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    *ppSPDMMFilter = pSPDMMFilter;

    return (dwError);

error:

    if (pSPDMMFilter) {
        PAFreeMMFilter(
            pSPDMMFilter
            );
    }

    *ppSPDMMFilter = NULL;

    return (dwError);
}


VOID
PASetInterfaceType(
    DWORD dwInterfaceType,
    PIF_TYPE pInterfaceType
    )
{
    if (dwInterfaceType == PASTORE_IF_TYPE_DIALUP) {
        *pInterfaceType = INTERFACE_TYPE_DIALUP;
    }
    else if (dwInterfaceType == PASTORE_IF_TYPE_LAN) {
        *pInterfaceType = INTERFACE_TYPE_LAN;
    }
    else {
        *pInterfaceType = INTERFACE_TYPE_ALL;
    }
}


VOID
PASetAddress(
    ULONG uMask,
    ULONG uAddr,
    PADDR pAddr
    )
{
    if (uMask == IP_ADDRESS_MASK_NONE) {
        pAddr->AddrType = IP_ADDR_UNIQUE;
        pAddr->uIpAddr = uAddr;
        pAddr->uSubNetMask = uMask;
    }
    else {
        pAddr->AddrType = IP_ADDR_SUBNET;
        pAddr->uIpAddr = uAddr;
        pAddr->uSubNetMask = uMask;
    }
}


VOID
PASetTunnelAddress(
    ULONG uAddr,
    PADDR pAddr
    )
{
    if (uAddr == SUBNET_ADDRESS_ANY) {
        pAddr->AddrType = IP_ADDR_SUBNET;
        pAddr->uIpAddr = uAddr;
        pAddr->uSubNetMask = SUBNET_MASK_ANY;
    }
    else {
        pAddr->AddrType = IP_ADDR_UNIQUE;
        pAddr->uIpAddr = uAddr;
        pAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
    }
}


VOID
PAFreeMMFilter(
    PMM_FILTER pSPDMMFilter
    )
{
    if (pSPDMMFilter) {

        if (pSPDMMFilter->pszFilterName) {
            FreeSPDString(pSPDMMFilter->pszFilterName);
        }

        FreeSPDMemory(pSPDMMFilter);

    }

    return;
}


DWORD
PADeleteAllMMFilters(
    )
{
    DWORD dwError = 0;
    PMMFILTERSTATE pMMFilterState = NULL;
    PMMFILTERSTATE pTemp = NULL;
    PMMFILTERSTATE pLeftMMFilterState = NULL;


    pMMFilterState = gpMMFilterState;

    while (pMMFilterState) {

        if (pMMFilterState->hMMFilter) {

            dwError = DeleteMMFilter(
                          pMMFilterState->hMMFilter
                          );
            if (!dwError) {
                pTemp = pMMFilterState;
                pMMFilterState = pMMFilterState->pNext;
                FreeSPDMemory(pTemp);
            } 
            else {
                pTemp = pMMFilterState;
                pMMFilterState = pMMFilterState->pNext;

                pTemp->pNext = pLeftMMFilterState;
                pLeftMMFilterState = pTemp;
            }

        }
        else {

            pTemp = pMMFilterState;
            pMMFilterState = pMMFilterState->pNext;
            FreeSPDMemory(pTemp);

        }

    }

    gpMMFilterState = pLeftMMFilterState;
    
    return (dwError);
}


VOID
PAFreeMMFilterStateList(
    PMMFILTERSTATE pMMFilterState
    )
{
    PMMFILTERSTATE pTemp = NULL;


    while (pMMFilterState) {

        pTemp = pMMFilterState;
        pMMFilterState = pMMFilterState->pNext;
        FreeSPDMemory(pTemp);

    }
}


DWORD
PADeleteMMFilters(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;


    for (i = 0; i < dwNumNFACount; i++) {

        dwError = PADeleteMMFilterSpecs(
                      pIpsecISAKMPData,
                      *(ppIpsecNFAData + i)
                      );

    }

    return (dwError);
}


DWORD
PADeleteMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (IsClearOnly(pIpsecNegPolData->NegPolAction) ||
        IsBlocking(pIpsecNegPolData->NegPolAction)) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    
    for (i = 0; i < dwNumFilterSpecs; i++) {

        pFilterSpec = *(ppFilterSpecs + i);

        dwError = PADeleteMMFilter(
                      pFilterSpec->FilterSpecGUID
                      );

    }

    return (dwError);
}


DWORD
PADeleteMMFilter(
    GUID gFilterID
    )
{
    DWORD dwError = 0;
    PMMFILTERSTATE pMMFilterState = NULL;


    pMMFilterState = FindMMFilterState(
                         gFilterID
                         );
    if (!pMMFilterState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pMMFilterState->hMMFilter) {

        dwError = DeleteMMFilter(
                      pMMFilterState->hMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteMMFilterState(pMMFilterState);

error:

    return (dwError);
}


VOID
PADeleteMMFilterState(
    PMMFILTERSTATE pMMFilterState
    )
{
    PMMFILTERSTATE * ppTemp = NULL;


    ppTemp = &gpMMFilterState;

    while (*ppTemp) {

        if (*ppTemp == pMMFilterState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pMMFilterState->pNext;
    }

    FreeSPDMemory(pMMFilterState);

    return;
}


PMMFILTERSTATE
FindMMFilterState(
    GUID gFilterID
    )
{
    PMMFILTERSTATE pMMFilterState = NULL;


    pMMFilterState = gpMMFilterState;

    while (pMMFilterState) {

        if (!memcmp(&(pMMFilterState->gFilterID), &gFilterID, sizeof(GUID))) {
            return (pMMFilterState);
        }

        pMMFilterState = pMMFilterState->pNext;

    }

    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\pammauth.c ===
#include "precomp.h"


DWORD
PAAddMMAuthMethods(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    PMM_AUTH_METHODS pSPDMMAuthMethods = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;


    for (i = 0; i < dwNumNFACount; i++) {

        dwError = PACreateMMAuthState(
                      *(ppIpsecNFAData + i),
                      &pMMAuthState
                      );
        if (dwError) {
            continue;
        }

        dwError = PACreateMMAuthMethods(
                      *(ppIpsecNFAData + i),
                      &pSPDMMAuthMethods
                      );
        if (dwError) {

            pMMAuthState->bInSPD = FALSE;
            pMMAuthState->dwErrorCode = dwError;

            pMMAuthState->pNext = gpMMAuthState;
            gpMMAuthState = pMMAuthState;

            continue;

        }

        dwError = AddMMAuthMethods(
                      pServerName,
                      dwPersist,
                      pSPDMMAuthMethods
                      );
        if (dwError) {
            pMMAuthState->bInSPD = FALSE;
            pMMAuthState->dwErrorCode = dwError;
        }
        else {
            pMMAuthState->bInSPD = TRUE;
            pMMAuthState->dwErrorCode = ERROR_SUCCESS;
        }

        pMMAuthState->pNext = gpMMAuthState;
        gpMMAuthState = pMMAuthState;

        PAFreeMMAuthMethods(pSPDMMAuthMethods);

    }

    return (dwError);
}


DWORD
PACreateMMAuthState(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PMMAUTHSTATE * ppMMAuthState
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(MMAUTHSTATE),
                  &pMMAuthState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pMMAuthState->gMMAuthID),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    pMMAuthState->bInSPD = FALSE;
    pMMAuthState->dwErrorCode = 0;
    pMMAuthState->pNext = NULL;

    *ppMMAuthState = pMMAuthState;

    return (dwError);

error:

    *ppMMAuthState = NULL;

    return (dwError);
}


DWORD
PACreateMMAuthMethods(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PMM_AUTH_METHODS * ppSPDMMAuthMethods
    )
{
    DWORD dwError = 0;
    DWORD dwAuthMethodCount = 0;
    PIPSEC_AUTH_METHOD * ppAuthMethods = NULL;
    PMM_AUTH_METHODS pSPDMMAuthMethods = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwAuthMethodCount = pIpsecNFAData->dwAuthMethodCount;
    ppAuthMethods = pIpsecNFAData->ppAuthMethods;

    if (!dwAuthMethodCount || !ppAuthMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    } 

    dwError = AllocateSPDMemory(
                  sizeof(MM_AUTH_METHODS),
                  &pSPDMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pSPDMMAuthMethods->gMMAuthID),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    pSPDMMAuthMethods->dwFlags = 0;

    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType),
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        pSPDMMAuthMethods->dwFlags |= IPSEC_MM_AUTH_DEFAULT_AUTH;
    }

    dwError = PACreateMMAuthInfos(
                  dwAuthMethodCount,
                  ppAuthMethods,
                  &(pSPDMMAuthMethods->dwNumAuthInfos),
                  &(pSPDMMAuthMethods->pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppSPDMMAuthMethods = pSPDMMAuthMethods;
    return (dwError);

error:

    if (pSPDMMAuthMethods) {
        PAFreeMMAuthMethods(pSPDMMAuthMethods);
    }

    *ppSPDMMAuthMethods = NULL;
    return (dwError);
}


DWORD
PACreateMMAuthInfos(
    DWORD dwAuthMethodCount,
    PIPSEC_AUTH_METHOD * ppAuthMethods,
    PDWORD pdwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;
    PIPSEC_AUTH_METHOD pAuthMethod = NULL;
    DWORD i = 0;


    //
    // dwAuthMethodCount is not zero at this point.
    // ppAuthMethods is not null at this point.
    //

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_MM_AUTH_INFO)*dwAuthMethodCount,
                  &(pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pAuthenticationInfo;

    for (i = 0; i < dwAuthMethodCount; i++) {

        pAuthMethod = *(ppAuthMethods + i);

        pTemp->AuthMethod = (MM_AUTH_ENUM) pAuthMethod->dwAuthType;

        switch(pTemp->AuthMethod) {

        case IKE_SSPI:

            pTemp->dwAuthInfoSize = 0;
            pTemp->pAuthInfo = NULL;
            break;

        case IKE_RSA_SIGNATURE:

            if (pAuthMethod->dwAltAuthLen && pAuthMethod->pAltAuthMethod) {

                dwError = AllocateSPDMemory(
                              pAuthMethod->dwAltAuthLen,
                              &(pTemp->pAuthInfo)
                              );
                BAIL_ON_WIN32_ERROR(dwError);
                pTemp->dwAuthInfoSize = pAuthMethod->dwAltAuthLen;

                //
                // Need to catch the exception when the size of auth info
                // specified is more than the actual size.
                //
                //

                memcpy(
                    pTemp->pAuthInfo,
                    pAuthMethod->pAltAuthMethod,
                    pAuthMethod->dwAltAuthLen
                    );
            }
            else {

                if (!(pAuthMethod->dwAuthLen) || !(pAuthMethod->pszAuthMethod)) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                dwError = EncodeName(
                              pAuthMethod->pszAuthMethod,
                              &pTemp->pAuthInfo,
                              &pTemp->dwAuthInfoSize
                              );
                BAIL_ON_WIN32_ERROR(dwError);

            }
            break;

        default:

            if (!(pAuthMethod->dwAuthLen) || !(pAuthMethod->pszAuthMethod)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            dwError = AllocateSPDMemory(
                          (pAuthMethod->dwAuthLen)*sizeof(WCHAR),
                          &(pTemp->pAuthInfo)
                          );
            BAIL_ON_WIN32_ERROR(dwError);
            pTemp->dwAuthInfoSize = (pAuthMethod->dwAuthLen)*sizeof(WCHAR);

            //
            // Need to catch the exception when the size of auth info
            // specified is more than the actual size.
            //
            //

            memcpy(
                pTemp->pAuthInfo,
                (LPBYTE) pAuthMethod->pszAuthMethod,
                (pAuthMethod->dwAuthLen)*sizeof(WCHAR)
                );
            break;

        }

        pTemp++;

    }

    *pdwNumAuthInfos = dwAuthMethodCount;
    *ppAuthenticationInfo = pAuthenticationInfo;
    return (dwError);

error:

    if (pAuthenticationInfo) {
        PAFreeMMAuthInfos(
            i,
            pAuthenticationInfo
            );
    }

    *pdwNumAuthInfos = 0;
    *ppAuthenticationInfo = NULL;
    return (dwError);
}


VOID
PAFreeMMAuthMethods(
    PMM_AUTH_METHODS pSPDMMAuthMethods
    )
{
    if (pSPDMMAuthMethods) {

        PAFreeMMAuthInfos(
            pSPDMMAuthMethods->dwNumAuthInfos,
            pSPDMMAuthMethods->pAuthenticationInfo
            );

        FreeSPDMemory(pSPDMMAuthMethods);

    }
}


VOID
PAFreeMMAuthInfos(
    DWORD dwNumAuthInfos,
    PIPSEC_MM_AUTH_INFO pAuthenticationInfo
    )
{
    DWORD i = 0;
    PIPSEC_MM_AUTH_INFO pTemp = NULL;


    if (pAuthenticationInfo) {

        pTemp = pAuthenticationInfo;

        for (i = 0; i < dwNumAuthInfos; i++) {
            if (pTemp->pAuthInfo) {
                FreeSPDMemory(pTemp->pAuthInfo);
            }
            pTemp++;
        }

        FreeSPDMemory(pAuthenticationInfo);

    }
}


DWORD
PADeleteAllMMAuthMethods(
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    LPWSTR pServerName = NULL;
    PMMAUTHSTATE pTemp = NULL;
    PMMAUTHSTATE pLeftMMAuthState = NULL;


    pMMAuthState = gpMMAuthState;

    while (pMMAuthState) {

        if (pMMAuthState->bInSPD) {

            dwError = DeleteMMAuthMethods(
                          pServerName,
                          pMMAuthState->gMMAuthID
                          );
            if (!dwError) {
                pTemp = pMMAuthState;
                pMMAuthState = pMMAuthState->pNext;
                FreeSPDMemory(pTemp);
            } 
            else {
                pMMAuthState->dwErrorCode = dwError;

                pTemp = pMMAuthState;
                pMMAuthState = pMMAuthState->pNext;

                pTemp->pNext = pLeftMMAuthState;
                pLeftMMAuthState = pTemp;
            }

        }
        else {

            pTemp = pMMAuthState;
            pMMAuthState = pMMAuthState->pNext;
            FreeSPDMemory(pTemp);

        }

    }

    gpMMAuthState = pLeftMMAuthState;
    
    return (dwError);
}


VOID
PAFreeMMAuthStateList(
    PMMAUTHSTATE pMMAuthState
    )
{
    PMMAUTHSTATE pTemp = NULL;


    while (pMMAuthState) {

        pTemp = pMMAuthState;
        pMMAuthState = pMMAuthState->pNext;
        FreeSPDMemory(pTemp);

    }
}


PMMAUTHSTATE
FindMMAuthState(
    GUID gMMAuthID
    )
{
    PMMAUTHSTATE pMMAuthState = NULL;


    pMMAuthState = gpMMAuthState;

    while (pMMAuthState) {

        if (!memcmp(&(pMMAuthState->gMMAuthID), &gMMAuthID, sizeof(GUID))) {
            return (pMMAuthState);
        }

        pMMAuthState = pMMAuthState->pNext;

    }

    return (NULL);
}


DWORD
PADeleteMMAuthMethods(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        dwError = PADeleteMMAuthMethod(
                      pIpsecNFAData->NFAIdentifier
                      );

    }

    return (dwError);
}


DWORD
PADeleteMMAuthMethod(
    GUID gMMAuthID
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    LPWSTR pServerName = NULL;


    pMMAuthState = FindMMAuthState(
                       gMMAuthID
                       );
    if (!pMMAuthState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pMMAuthState->bInSPD) {

        dwError = DeleteMMAuthMethods(
                      pServerName,
                      pMMAuthState->gMMAuthID
                      );
        if (dwError) {
            pMMAuthState->dwErrorCode = dwError;
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteMMAuthState(pMMAuthState);

error:

    return (dwError);
}


VOID
PADeleteMMAuthState(
    PMMAUTHSTATE pMMAuthState
    )
{
    PMMAUTHSTATE * ppTemp = NULL;


    ppTemp = &gpMMAuthState;

    while (*ppTemp) {

        if (*ppTemp == pMMAuthState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pMMAuthState->pNext;
    }

    FreeSPDMemory(pMMAuthState);

    return;
}


DWORD
PADeleteInUseMMAuthMethods(
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    LPWSTR pServerName = NULL;
    PMMAUTHSTATE pTemp = NULL;
    PMMAUTHSTATE pLeftMMAuthState = NULL;


    pMMAuthState = gpMMAuthState;

    while (pMMAuthState) {

        if (pMMAuthState->bInSPD &&
            (pMMAuthState->dwErrorCode == ERROR_IPSEC_MM_AUTH_IN_USE)) {

            dwError = DeleteMMAuthMethods(
                          pServerName,
                          pMMAuthState->gMMAuthID
                          );
            if (!dwError) {
                pTemp = pMMAuthState;
                pMMAuthState = pMMAuthState->pNext;
                FreeSPDMemory(pTemp);
            }
            else {
                pTemp = pMMAuthState;
                pMMAuthState = pMMAuthState->pNext;

                pTemp->pNext = pLeftMMAuthState;
                pLeftMMAuthState = pTemp;
            }

        }
        else {

            pTemp = pMMAuthState;
            pMMAuthState = pMMAuthState->pNext;

            pTemp->pNext = pLeftMMAuthState;
            pLeftMMAuthState = pTemp;

        }

    }

    gpMMAuthState = pLeftMMAuthState;

    return (dwError);
}


DWORD
EncodeName(
    LPWSTR pszSubjectName,
    PBYTE * ppEncodedName,
    PDWORD pdwEncodedLength
    )
{
    DWORD dwError = ERROR_SUCCESS;


    *ppEncodedName = NULL;
    *pdwEncodedLength = 0;


    if (!CertStrToName(
             X509_ASN_ENCODING,
             pszSubjectName,
             CERT_X500_NAME_STR,
             NULL,
             NULL,
             pdwEncodedLength,
             NULL)) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!*pdwEncodedLength) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AllocateSPDMemory(
                  *pdwEncodedLength,
                  (PVOID) ppEncodedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!CertStrToName(
             X509_ASN_ENCODING,
             pszSubjectName,
             CERT_X500_NAME_STR,
             NULL,
             (*ppEncodedName),
             pdwEncodedLength,
             NULL)) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    return (dwError);

error:

    if (*ppEncodedName) {
        FreeSPDMemory(*ppEncodedName);
        *ppEncodedName = NULL;
    }
    *pdwEncodedLength = 0;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\paqm-pol.h ===
typedef struct _qmpolicystate {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    GUID gNegPolType;
    GUID gNegPolAction;
    BOOL bAllowsSoft;
    DWORD cRef;
    BOOL bInSPD;
    DWORD dwErrorCode;
    struct _qmpolicystate * pNext;
} QMPOLICYSTATE, * PQMPOLICYSTATE;


DWORD
PAAddQMPolicies(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PACreateQMPolicyState(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE * ppQMPolicyState
    );

VOID
PAFreeQMPolicyState(
    PQMPOLICYSTATE pQMPolicyState
    );

BOOL
IsClearOnly(
    GUID gNegPolAction
    );

BOOL
IsBlocking(
    GUID gNegPolAction
    );

BOOL
IsInboundPassThru(
    GUID gNegPolAction
    );

DWORD
PACreateQMPolicy(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_QM_POLICY * ppSPDQMPolicy
    );

DWORD
PACreateQMOffers(
    DWORD dwSecurityMethodCount,
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods,
    PQMPOLICYSTATE pQMPolicyState,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    );

VOID
PACopyQMOffers(
    PIPSEC_SECURITY_METHOD pMethod,
    PIPSEC_QM_OFFER pOffer
    );

VOID
PAFreeQMPolicy(
    PIPSEC_QM_POLICY pSPDQMPolicy
    );

VOID
PAFreeQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    );

DWORD
PADeleteAllQMPolicies(
    );

VOID
PAFreeQMPolicyStateList(
    PQMPOLICYSTATE pQMPolicyState
    );

PQMPOLICYSTATE
FindQMPolicyState(
    GUID gPolicyID
    );

DWORD
PADeleteQMPolicies(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PADeleteQMPolicy(
    GUID gPolicyID
    );

VOID
PADeleteQMPolicyState(
    PQMPOLICYSTATE pQMPolicyState
    );

DWORD
PADeleteInUseQMPolicies(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\paqm-pol.c ===
#include "precomp.h"

   
DWORD
PAAddQMPolicies(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    PIPSEC_QM_POLICY pSPDQMPolicy = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;


    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);
        pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

        pQMPolicyState = FindQMPolicyState(
                             pIpsecNegPolData->NegPolIdentifier
                             );
        if (pQMPolicyState) {
            pQMPolicyState->cRef++;
            continue;
        }

        dwError = PACreateQMPolicyState(
                      *(ppIpsecNFAData + i),
                      &pQMPolicyState
                      );
        if (dwError) {
            continue;
        }

        if (IsClearOnly(pQMPolicyState->gNegPolAction) ||
            IsBlocking(pQMPolicyState->gNegPolAction)) {

            pQMPolicyState->bInSPD = FALSE;
            pQMPolicyState->dwErrorCode = 0;

            pQMPolicyState->pNext = gpQMPolicyState;
            gpQMPolicyState = pQMPolicyState;

            continue;

        }

        dwError = PACreateQMPolicy(
                      *(ppIpsecNFAData + i),
                      pQMPolicyState,
                      &pSPDQMPolicy
                      );
        if (dwError) {

            pQMPolicyState->bInSPD = FALSE;
            pQMPolicyState->dwErrorCode = dwError;

            pQMPolicyState->pNext = gpQMPolicyState;
            gpQMPolicyState = pQMPolicyState;

            continue;

        }

        dwError = AddQMPolicy(
                      pServerName,
                      dwPersist,
                      pSPDQMPolicy
                      );
        if (dwError) {
            pQMPolicyState->bInSPD = FALSE;
            pQMPolicyState->dwErrorCode = dwError;
        }
        else {
            pQMPolicyState->bInSPD = TRUE;
            pQMPolicyState->dwErrorCode = ERROR_SUCCESS;
        }

        pQMPolicyState->pNext = gpQMPolicyState;
        gpQMPolicyState = pQMPolicyState;

        PAFreeQMPolicy(pSPDQMPolicy);

    }

    return (dwError);
}


DWORD
PACreateQMPolicyState(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE * ppQMPolicyState
    )
{
    DWORD dwError = 0;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    WCHAR pszName[512];


    dwError = AllocateSPDMemory(
                  sizeof(QMPOLICYSTATE),
                  &pQMPolicyState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    memcpy(
        &(pQMPolicyState->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    if (pIpsecNegPolData->pszIpsecName && *(pIpsecNegPolData->pszIpsecName)) {

        dwError = AllocateSPDString(
                      pIpsecNegPolData->pszIpsecName,
                      &(pQMPolicyState->pszPolicyName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        wsprintf(pszName, L"%d", ++gdwQMPolicyCounter);

        dwError = AllocateSPDString(
                      pszName,
                      &(pQMPolicyState->pszPolicyName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    memcpy(
        &(pQMPolicyState->gNegPolType),
        &(pIpsecNegPolData->NegPolType),
        sizeof(GUID)
        );

    memcpy(
        &(pQMPolicyState->gNegPolAction),
        &(pIpsecNegPolData->NegPolAction),
        sizeof(GUID)
        );

    pQMPolicyState->bAllowsSoft = FALSE;

    pQMPolicyState->cRef = 1;

    pQMPolicyState->bInSPD = FALSE;
    pQMPolicyState->dwErrorCode = 0;

    pQMPolicyState->pNext = NULL;

    *ppQMPolicyState = pQMPolicyState;

    return (dwError);

error:

    if (pQMPolicyState) {
        PAFreeQMPolicyState(pQMPolicyState);
    }

    *ppQMPolicyState = NULL;

    return (dwError);
}


VOID
PAFreeQMPolicyState(
    PQMPOLICYSTATE pQMPolicyState
    )
{
    if (pQMPolicyState) {
        if (pQMPolicyState->pszPolicyName) {
            FreeSPDString(pQMPolicyState->pszPolicyName);
        }
        FreeSPDMemory(pQMPolicyState);
    }
}


BOOL
IsClearOnly(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_NO_IPSEC),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}


BOOL
IsBlocking(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_BLOCK),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}


BOOL
IsInboundPassThru(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}


DWORD
PACreateQMPolicy(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_QM_POLICY * ppSPDQMPolicy
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pSPDQMPolicy = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_QM_POLICY),
                  &pSPDQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pSPDQMPolicy->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    dwError = AllocateSPDString(
                  pQMPolicyState->pszPolicyName,
                  &(pSPDQMPolicy->pszPolicyName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);
            
    dwError = PACreateQMOffers(
                  pIpsecNegPolData->dwSecurityMethodCount,
                  pIpsecNegPolData->pIpsecSecurityMethods,
                  pQMPolicyState,
                  &(pSPDQMPolicy->dwOfferCount),
                  &(pSPDQMPolicy->pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSPDQMPolicy->dwFlags = 0;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType),
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        pSPDQMPolicy->dwFlags |= IPSEC_QM_POLICY_DEFAULT_POLICY;
    }

    if (pIpsecNFAData->dwTunnelFlags) {
        pSPDQMPolicy->dwFlags |= IPSEC_QM_POLICY_TUNNEL_MODE;
    }

    if (pQMPolicyState->bAllowsSoft) {
        pSPDQMPolicy->dwFlags |= IPSEC_QM_POLICY_ALLOW_SOFT;
    }

    *ppSPDQMPolicy = pSPDQMPolicy;

    return (dwError);

error:

    if (pSPDQMPolicy) {
        PAFreeQMPolicy(
            pSPDQMPolicy
            );
    }

    *ppSPDQMPolicy = NULL;

    return (dwError);
}


DWORD
PACreateQMOffers(
    DWORD dwSecurityMethodCount,
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods,
    PQMPOLICYSTATE pQMPolicyState,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    DWORD dwTempOfferCount = 0;
    PIPSEC_SECURITY_METHOD pTempMethod = NULL;
    BOOL bAllowsSoft = FALSE;
    DWORD i = 0;
    DWORD dwOfferCount = 0;
    PIPSEC_QM_OFFER pOffers = NULL;
    PIPSEC_QM_OFFER pTempOffer = NULL;


    if (!dwSecurityMethodCount || !pIpsecSecurityMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwSecurityMethodCount > IPSEC_MAX_QM_OFFERS) {
        dwTempOfferCount = IPSEC_MAX_QM_OFFERS;
    }
    else {
        dwTempOfferCount = dwSecurityMethodCount;
    }

    pTempMethod = pIpsecSecurityMethods;
 
    for (i = 0; i < dwTempOfferCount; i++) {

        if (pTempMethod->Count == 0) {
            bAllowsSoft = TRUE;
        }
        else {
            dwOfferCount++;
        }

        pTempMethod++;

    }

    if (!dwOfferCount) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_QM_OFFER)*dwOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTempOffer = pOffers;
    pTempMethod = pIpsecSecurityMethods;
    i = 0;

    while (i < dwOfferCount) {

        if (pTempMethod->Count) {

            PACopyQMOffers(
                pTempMethod,
                pTempOffer
                );

            i++;
            pTempOffer++;

        }

        pTempMethod++;

    }

    pQMPolicyState->bAllowsSoft = bAllowsSoft;

    *pdwOfferCount = dwOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:

    if (pOffers) {
        PAFreeQMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


VOID
PACopyQMOffers(
    PIPSEC_SECURITY_METHOD pMethod,
    PIPSEC_QM_OFFER pOffer
    )
{
    DWORD i = 0;
    DWORD j = 0;
    DWORD k = 0;


    pOffer->Lifetime.uKeyExpirationKBytes = pMethod->Lifetime.KeyExpirationBytes;
    pOffer->Lifetime.uKeyExpirationTime = pMethod->Lifetime.KeyExpirationTime;

    pOffer->dwFlags = pMethod->Flags;

    pOffer->bPFSRequired = pMethod->PfsQMRequired;

    if (pMethod->PfsQMRequired) {
        pOffer->dwPFSGroup = PFS_GROUP_MM;
    }
    else {
        pOffer->dwPFSGroup = PFS_GROUP_NONE;
    }

    i = 0;

    for (j = 0; (j < pMethod->Count) && (i < QM_MAX_ALGOS) ; j++) {

        switch (pMethod->Algos[j].operation) {

        case Auth:

            switch (pMethod->Algos[j].algoIdentifier) {

            case IPSEC_AH_MD5:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_AH_MD5;
                break;

            case IPSEC_AH_SHA:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_AH_SHA1;
                break;

            default:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_AH_NONE;
                break;

            }

            pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AH_NONE;
            pOffer->Algos[i].Operation = AUTHENTICATION;
            pOffer->Algos[i].uAlgoKeyLen = pMethod->Algos[j].algoKeylen;
            pOffer->Algos[i].uAlgoRounds = pMethod->Algos[j].algoRounds;
            pOffer->Algos[i].MySpi = 0;
            pOffer->Algos[i].PeerSpi = 0;

            i++;
            break;

        case Encrypt:

            switch (pMethod->Algos[j].algoIdentifier) {

            case IPSEC_ESP_DES:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_ESP_DES;
                break;

            case IPSEC_ESP_DES_40:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_ESP_DES;
                break;

            case IPSEC_ESP_3_DES:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_ESP_3_DES;
                break;

            default:
                pOffer->Algos[i].uAlgoIdentifier = IPSEC_DOI_ESP_NONE;
                break;

            }

            switch (pMethod->Algos[j].secondaryAlgoIdentifier) {

            case IPSEC_AH_MD5:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AH_MD5;
                break;

            case IPSEC_AH_SHA:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AH_SHA1;
                break;

            default:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AH_NONE;
                break;

            }

            pOffer->Algos[i].Operation = ENCRYPTION;
            pOffer->Algos[i].uAlgoKeyLen = pMethod->Algos[j].algoKeylen;
            pOffer->Algos[i].uAlgoRounds = pMethod->Algos[j].algoRounds;
            pOffer->Algos[i].MySpi = 0;
            pOffer->Algos[i].PeerSpi = 0;

            i++;
            break;

        case None:
        case Compress:
        default:
            break;

        }

    }

    for (k = i; k < QM_MAX_ALGOS; k++) {
         memset(&(pOffer->Algos[k]), 0, sizeof(IPSEC_QM_ALGO));
    }

    pOffer->dwNumAlgos = i;
}


VOID
PAFreeQMPolicy(
    PIPSEC_QM_POLICY pSPDQMPolicy
    )
{
    if (pSPDQMPolicy) {

        if (pSPDQMPolicy->pszPolicyName) {
            FreeSPDString(pSPDQMPolicy->pszPolicyName);
        }

        PAFreeQMOffers(
            pSPDQMPolicy->dwOfferCount,
            pSPDQMPolicy->pOffers
            );

        FreeSPDMemory(pSPDQMPolicy);

    }
}


VOID
PAFreeQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    if (pOffers) {
        FreeSPDMemory(pOffers);
    }
}


DWORD
PADeleteAllQMPolicies(
    )
{
    DWORD dwError = 0;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    PQMPOLICYSTATE pTemp = NULL;
    PQMPOLICYSTATE pLeftQMPolicyState = NULL;


    pQMPolicyState = gpQMPolicyState;

    while (pQMPolicyState) {

        if (pQMPolicyState->bInSPD) {

            dwError = DeleteQMPolicy(
                          pServerName,
                          pQMPolicyState->pszPolicyName
                          );
            if (!dwError) {
                pTemp = pQMPolicyState;
                pQMPolicyState = pQMPolicyState->pNext;
                PAFreeQMPolicyState(pTemp);
            } 
            else {
                pQMPolicyState->dwErrorCode = dwError;

                pTemp = pQMPolicyState;
                pQMPolicyState = pQMPolicyState->pNext;

                pTemp->pNext = pLeftQMPolicyState;
                pLeftQMPolicyState = pTemp;
            }

        }
        else {

            pTemp = pQMPolicyState;
            pQMPolicyState = pQMPolicyState->pNext;
            PAFreeQMPolicyState(pTemp);

        }

    }

    gpQMPolicyState = pLeftQMPolicyState;

    return (dwError);
}


VOID
PAFreeQMPolicyStateList(
    PQMPOLICYSTATE pQMPolicyState
    )
{
    PQMPOLICYSTATE pTemp = NULL;


    while (pQMPolicyState) {

        pTemp = pQMPolicyState;
        pQMPolicyState = pQMPolicyState->pNext;
        PAFreeQMPolicyState(pTemp);

    }
}


PQMPOLICYSTATE
FindQMPolicyState(
    GUID gPolicyID
    )
{
    PQMPOLICYSTATE pQMPolicyState = NULL;


    pQMPolicyState = gpQMPolicyState;

    while (pQMPolicyState) {

        if (!memcmp(&(pQMPolicyState->gPolicyID), &gPolicyID, sizeof(GUID))) {
            return (pQMPolicyState);
        }

        pQMPolicyState = pQMPolicyState->pNext;

    }

    return (NULL);
}


DWORD
PADeleteQMPolicies(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

        dwError = PADeleteQMPolicy(
                      pIpsecNegPolData->NegPolIdentifier
                      );

    }

    return (dwError);
}


DWORD
PADeleteQMPolicy(
    GUID gPolicyID
    )
{
    DWORD dwError = 0;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    LPWSTR pServerName = NULL;


    pQMPolicyState = FindQMPolicyState(
                         gPolicyID
                         );
    if (!pQMPolicyState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pQMPolicyState->cRef--;
    if (pQMPolicyState->cRef > 0) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pQMPolicyState->bInSPD) {

        dwError = DeleteQMPolicy(
                      pServerName,
                      pQMPolicyState->pszPolicyName
                      );
        if (dwError) {
            pQMPolicyState->cRef++;
            pQMPolicyState->dwErrorCode = dwError;
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteQMPolicyState(pQMPolicyState);

error:

    return (dwError);
}


VOID
PADeleteQMPolicyState(
    PQMPOLICYSTATE pQMPolicyState
    )
{
    PQMPOLICYSTATE * ppTemp = NULL;


    ppTemp = &gpQMPolicyState;

    while (*ppTemp) {

        if (*ppTemp == pQMPolicyState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pQMPolicyState->pNext;
    }

    PAFreeQMPolicyState(pQMPolicyState);

    return;
}


DWORD
PADeleteInUseQMPolicies(
    )
{
    DWORD dwError = 0;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    PQMPOLICYSTATE pTemp = NULL;
    PQMPOLICYSTATE pLeftQMPolicyState = NULL;


    pQMPolicyState = gpQMPolicyState;

    while (pQMPolicyState) {

        if (pQMPolicyState->bInSPD &&
            (pQMPolicyState->dwErrorCode == ERROR_IPSEC_QM_POLICY_IN_USE)) {

            dwError = DeleteQMPolicy(
                          pServerName,
                          pQMPolicyState->pszPolicyName
                          );
            if (!dwError) {
                pTemp = pQMPolicyState;
                pQMPolicyState = pQMPolicyState->pNext;
                PAFreeQMPolicyState(pTemp);
            }
            else {
                pTemp = pQMPolicyState;
                pQMPolicyState = pQMPolicyState->pNext;

                pTemp->pNext = pLeftQMPolicyState;
                pLeftQMPolicyState = pTemp;
            }

        }
        else {

            pTemp = pQMPolicyState;
            pQMPolicyState = pQMPolicyState->pNext;

            pTemp->pNext = pLeftQMPolicyState;
            pLeftQMPolicyState = pTemp;

        }

    }

    gpQMPolicyState = pLeftQMPolicyState;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\patn-fil.h ===
typedef struct _tnfilterstate {
    GUID gFilterID;
    GUID gPolicyID;
    HANDLE hTnFilter;
    struct _tnfilterstate * pNext;
} TNFILTERSTATE, * PTNFILTERSTATE;


DWORD
PAAddTnFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
PACreateTnFilterState(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PTNFILTERSTATE * ppTnFilterState
    );

DWORD
PACreateTnFilter(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PQMPOLICYSTATE pQMPolicyState,
    PTUNNEL_FILTER * ppSPDTnFilter
    );

VOID
PAFreeTnFilter(
    PTUNNEL_FILTER pSPDTnFilter
    );

DWORD
PADeleteAllTnFilters(
    );

VOID
PAFreeTnFilterStateList(
    PTNFILTERSTATE pTnFilterState
    );

DWORD
PADeleteTnFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
PADeleteTnFilter(
    GUID gFilterID
    );

VOID
PADeleteTnFilterState(
    PTNFILTERSTATE pTnFilterState
    );

PTNFILTERSTATE
FindTnFilterState(
    GUID gFilterID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\pastore.h ===
#define POLL_STATE_INITIAL             0
#define POLL_STATE_DS_DOWNLOADED       1
#define POLL_STATE_LOCAL_DOWNLOADED    2
#define POLL_STATE_CACHE_DOWNLOADED    3


typedef struct _IPSEC_POLICY_STATE {
    DWORD dwCurrentState;
    union {
        LPWSTR pszDirectoryPolicyDN;
        LPWSTR pszRegistryPolicyDN;
        LPWSTR pszCachePolicyDN;
    };
    DWORD CurrentPollingInterval;
    DWORD DefaultPollingInterval;
    DWORD DSIncarnationNumber;
    DWORD RegIncarnationNumber;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject;
    PIPSEC_POLICY_DATA pIpsecPolicyData;
} IPSEC_POLICY_STATE, * PIPSEC_POLICY_STATE;


VOID
InitializePolicyStateBlock(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
StartStatePollingManager(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
PlumbDirectoryPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
GetDirectoryPolicyDN(
    LPWSTR * ppszDirectoryPolicyDN
    );

DWORD
LoadDirectoryPolicy(
    LPWSTR pszDirectoryPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
PlumbCachePolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
GetCachePolicyDN(
    LPWSTR * ppszCachePolicyDN
    );

DWORD
LoadCachePolicy(
    LPWSTR pszCachePolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
PlumbRegistryPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
GetRegistryPolicyDN(
    LPWSTR * ppszRegistryPolicyDN
    );

DWORD
LoadRegistryPolicy(
    LPWSTR pszRegistryPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
AddPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
AddMMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
AddQMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
OnPolicyChanged(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
DeletePolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DeleteMMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DeleteQMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DeleteAllPolicyInformation(
    );

DWORD
DeleteAllMMPolicyInformation(
    );

DWORD
DeleteAllQMPolicyInformation(
    );

VOID
ClearPolicyStateBlock(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
OnPolicyPoll(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
ProcessDirectoryPolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
GetDirectoryIncarnationNumber(
    LPWSTR pszIpsecPolicyDN,
    DWORD * pdwIncarnationNumber
    );

DWORD
MigrateFromDSToCache(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
ProcessCachePolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
MigrateFromCacheToDS(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
UpdateFromCacheToDS(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
ProcessLocalPolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
HasRegistryPolicyChanged(
    LPWSTR pszCurrentPolicyDN,
    PBOOL pbChanged
    );

DWORD
GetRegistryIncarnationNumber(
    LPWSTR pszIpsecPolicyDN,
    DWORD *pdwIncarnationNumber
    );

DWORD
UpdatePolicyInformation(
    PIPSEC_POLICY_DATA pOldIpsecPolicyData,
    PIPSEC_POLICY_DATA pNewIpsecPolicyData
    );

DWORD
LoadDefaultISAKMPInformation(
    LPWSTR pszDefaultISAKMPDN
    );

VOID
UnLoadDefaultISAKMPInformation(
    LPWSTR pszDefaultISAKMPDN
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ipsec\spd\server\pastore.c ===
#include "precomp.h"


VOID
InitializePolicyStateBlock(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    memset(pIpsecPolicyState, 0, sizeof(IPSEC_POLICY_STATE));
    pIpsecPolicyState->DefaultPollingInterval = gDefaultPollingInterval;
}


DWORD
StartStatePollingManager(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;


    dwError = PlumbDirectoryPolicy(
                  pIpsecPolicyState
                  );

    if (dwError) {

        dwError = PlumbCachePolicy(
                      pIpsecPolicyState
                      );

        if (dwError) {

            dwError = PlumbRegistryPolicy(
                          pIpsecPolicyState
                          );
            BAIL_ON_WIN32_ERROR(dwError);

        }

    }

    //
    // The new polling interval has been set by either the
    // registry code or the DS code.
    //

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    return (dwError);

error:

    //
    // On error, set the state to INITIAL.
    //

    pIpsecPolicyState->dwCurrentState = POLL_STATE_INITIAL;

    gCurrentPollingInterval = pIpsecPolicyState->DefaultPollingInterval;

    return (dwError);
}


DWORD
PlumbDirectoryPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_DIRECTORY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    BOOL bIsActivePolicy = FALSE;


    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    bIsActivePolicy = TRUE;

    dwError = LoadDirectoryPolicy(
                  pszDirectoryPolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Plumb the DS policy.
    //

    dwError = AddPolicyInformation(
                  pIpsecPolicyData
                  );

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    if (pIpsecPolicyState->pszDirectoryPolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszDirectoryPolicyDN);
    }

    //
    // Delete the old cache and write the new one in.
    //

    DeleteRegistryCache();

    CacheDirectorytoRegistry(pIpsecPolicyObject);

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->pszDirectoryPolicyDN = pszDirectoryPolicyDN;

    //
    // Set the state to DS_DOWNLOADED.
    //

    pIpsecPolicyState->dwCurrentState = POLL_STATE_DS_DOWNLOADED;

    //
    // Compute the new polling interval.
    //

    pIpsecPolicyState->CurrentPollingInterval =  pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = pIpsecPolicyData->dwWhenChanged;

    pIpsecPolicyState->RegIncarnationNumber = 0;

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
    }
    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_APPLIED_DS_POLICY,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );
    return (dwError);

error:

    //
    // Check pszDirectoryPolicyDN for non-NULL.
    //

    if (bIsActivePolicy && pszDirectoryPolicyDN) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_DS_POLICY_APPLICATION,
            pszDirectoryPolicyDN,
            dwError,
            FALSE,
            TRUE
            );
    }

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
GetDirectoryPolicyDN(
    LPWSTR * ppszDirectoryPolicyDN
    )
{
    DWORD dwError = 0;
    HKEY hPolicyKey = NULL;
    LPWSTR pszIpsecPolicyName = NULL;
    DWORD dwSize = 0;
    LPWSTR pszPolicyDN = NULL;
    LPWSTR pszDirectoryPolicyDN = NULL;


    *ppszDirectoryPolicyDN = NULL;

    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hPolicyKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hPolicyKey,
                  L"DSIPSECPolicyPath",
                  REG_SZ,
                  (LPBYTE *)&pszIpsecPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Move by LDAP:// to get the real DN and allocate
    // this string.
    // Fix this by fixing the gpo extension.
    //

    pszPolicyDN = pszIpsecPolicyName + wcslen(L"LDAP://");

    pszDirectoryPolicyDN = AllocSPDStr(pszPolicyDN);

    if (!pszDirectoryPolicyDN) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszDirectoryPolicyDN = pszDirectoryPolicyDN;

error:

    if (pszIpsecPolicyName) {
        FreeSPDStr(pszIpsecPolicyName);
    }

    if (hPolicyKey) {
        CloseHandle(hPolicyKey);
    }

    return (dwError);
}


DWORD
LoadDirectoryPolicy(
    LPWSTR pszDirectoryPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszDefaultDirectory = NULL;
    HLDAP hLdapBindHandle = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;


    dwError = ComputeDefaultDirectory(
                  &pszDefaultDirectory
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = OpenDirectoryServerHandle(
                  pszDefaultDirectory,
                  389,
                  &hLdapBindHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadPolicyObjectFromDirectory(
                  hLdapBindHandle,
                  pszDirectoryPolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (pszDefaultDirectory) {
        FreeSPDStr(pszDefaultDirectory);
    }

    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }

    return (dwError);

error:

    *ppIpsecPolicyObject = NULL;

    goto cleanup;
}


DWORD
PlumbCachePolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszCachePolicyDN = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_REGISTRY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    BOOL bIsActivePolicy = FALSE;

    dwError = GetCachePolicyDN(
                  &pszCachePolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    bIsActivePolicy = TRUE;

    dwError = LoadCachePolicy(
                  pszCachePolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddPolicyInformation(
                  pIpsecPolicyData
                  );

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    if (pIpsecPolicyState->pszCachePolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszCachePolicyDN);
    }

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->pszCachePolicyDN = pszCachePolicyDN;

    //
    // Set the state to CACHE_DOWNLOADED.
    //
    //

    pIpsecPolicyState->dwCurrentState = POLL_STATE_CACHE_DOWNLOADED;

    //
    // Compute the new polling interval.
    //

    pIpsecPolicyState->CurrentPollingInterval = pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = 0;

    pIpsecPolicyState->RegIncarnationNumber = pIpsecPolicyData->dwWhenChanged;

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
    }
    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_APPLIED_CACHED_POLICY,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );
    return (dwError);

error:

    //
    // Check pszCachePolicyDN for non-NULL.
    //

    if (bIsActivePolicy && pszCachePolicyDN) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_CACHED_POLICY_APPLICATION,
            pszCachePolicyDN,
            dwError,
            FALSE,
            TRUE
            );
    }

    if (pszCachePolicyDN) {
        FreeSPDStr(pszCachePolicyDN);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
GetCachePolicyDN(
    LPWSTR * ppszCachePolicyDN
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    LPWSTR pszCachePolicyDN = NULL;


    *ppszCachePolicyDN = NULL;

    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyPolicyDSToFQRegString(
                  pszDirectoryPolicyDN,
                  &pszCachePolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppszCachePolicyDN = pszCachePolicyDN;

error:

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    return (dwError);
}


DWORD
LoadCachePolicy(
    LPWSTR pszCachePolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;


    dwError = OpenRegistryIPSECRootKey(
                  NULL,
                  gpszIpsecCachePolicyKey,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadPolicyObjectFromRegistry(
                  hRegistryKey,
                  pszCachePolicyDN,
                  gpszIpsecCachePolicyKey,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (hRegistryKey) {
        CloseHandle(hRegistryKey);
    }

    return (dwError);

error:

    *ppIpsecPolicyObject = NULL;

    goto cleanup;
}


DWORD
PlumbRegistryPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszRegistryPolicyDN = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_REGISTRY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    BOOL bIsActivePolicy = FALSE;

    dwError = GetRegistryPolicyDN(
                  &pszRegistryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    bIsActivePolicy = TRUE;

    dwError = LoadRegistryPolicy(
                  pszRegistryPolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddPolicyInformation(
                  pIpsecPolicyData
                  );

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    if (pIpsecPolicyState->pszRegistryPolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszRegistryPolicyDN);
    }

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->pszRegistryPolicyDN = pszRegistryPolicyDN;

    //
    // Set the state to LOCAL_DOWNLOADED.
    //

    pIpsecPolicyState->dwCurrentState = POLL_STATE_LOCAL_DOWNLOADED;

    //
    // Compute the new polling interval.
    //

    pIpsecPolicyState->CurrentPollingInterval = pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = 0;

    pIpsecPolicyState->RegIncarnationNumber = pIpsecPolicyData->dwWhenChanged;

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
    }
    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_APPLIED_LOCAL_POLICY,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );
    return (dwError);

error:

    //
    // Check pszRegistryPolicyDN for non-NULL.
    //

    if (bIsActivePolicy && pszRegistryPolicyDN) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_LOCAL_POLICY_APPLICATION,
            pszRegistryPolicyDN,
            dwError,
            FALSE,
            TRUE
            );
    }

    if (pszRegistryPolicyDN) {
        FreeSPDStr(pszRegistryPolicyDN);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
GetRegistryPolicyDN(
    LPWSTR * ppszRegistryPolicyDN
    )
{
    DWORD dwError = 0;
    HKEY hPolicyKey = NULL;
    LPWSTR pszIpsecPolicyName = NULL;
    DWORD dwSize = 0;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecLocalPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hPolicyKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hPolicyKey,
                  L"ActivePolicy",
                  REG_SZ,
                  (LPBYTE *)&pszIpsecPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pszIpsecPolicyName || !*pszIpsecPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszRegistryPolicyDN = pszIpsecPolicyName;

cleanup:

    if (hPolicyKey) {
        CloseHandle(hPolicyKey);
    }

    return (dwError);

error:

    if (pszIpsecPolicyName) {
        FreeSPDStr(pszIpsecPolicyName);
    }

    *ppszRegistryPolicyDN = NULL;

    goto cleanup;
}


DWORD
LoadRegistryPolicy(
    LPWSTR pszRegistryPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;


    dwError = OpenRegistryIPSECRootKey(
                  NULL,
                  gpszIpsecLocalPolicyKey,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadPolicyObjectFromRegistry(
                  hRegistryKey,
                  pszRegistryPolicyDN,
                  gpszIpsecLocalPolicyKey,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (hRegistryKey) {
        CloseHandle(hRegistryKey);
    }

    return (dwError);

error:

    *ppIpsecPolicyObject = NULL;

    goto cleanup;
}


DWORD
AddPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;


    dwError = AddMMPolicyInformation(pIpsecPolicyData);

    dwError = AddQMPolicyInformation(pIpsecPolicyData);

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
AddMMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;


    dwError = PAAddMMPolicies(
                  &(pIpsecPolicyData->pIpsecISAKMPData),
                  1
                  );

    dwError = PAAddMMAuthMethods(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    dwError = PAAddMMFilters(
                  pIpsecPolicyData->pIpsecISAKMPData,
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
AddQMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;


    dwError = PAAddQMPolicies(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    dwError = PAAddQMFilters(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
OnPolicyChanged(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;


    //
    // Remove all the old policy that was plumbed.
    //

    dwError = DeletePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData
                  );

    ClearPolicyStateBlock(
         pIpsecPolicyState
         );

    //
    // Calling the Initializer again.
    //

    dwError = StartStatePollingManager(
                  pIpsecPolicyState
                  );

    return (dwError);
}


DWORD
DeletePolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;


    if (!pIpsecPolicyData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = DeleteMMPolicyInformation(pIpsecPolicyData);

    dwError = DeleteQMPolicyInformation(pIpsecPolicyData);

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
DeleteMMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;


    dwError = PADeleteMMFilters(
                  pIpsecPolicyData->pIpsecISAKMPData,
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    dwError = PADeleteMMAuthMethods(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    dwError = PADeleteMMPolicies(
                  &(pIpsecPolicyData->pIpsecISAKMPData),
                  1
                  );

    return (dwError);
}


DWORD
DeleteQMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;


    dwError = PADeleteQMFilters(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    dwError = PADeleteQMPolicies(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    return (dwError);
}


DWORD
DeleteAllPolicyInformation(
    )
{
    DWORD dwError = 0;


    dwError = DeleteAllMMPolicyInformation();

    dwError = DeleteAllQMPolicyInformation();

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
DeleteAllMMPolicyInformation(
    )
{
    DWORD dwError = 0;


    dwError = PADeleteAllMMFilters();

    dwError = PADeleteAllMMAuthMethods();

    dwError = PADeleteAllMMPolicies();

    return (dwError);
}


DWORD
DeleteAllQMPolicyInformation(
    )
{
    DWORD dwError = 0;


    dwError = PADeleteAllTxFilters();

    dwError = PADeleteAllTnFilters();

    dwError = PADeleteAllQMPolicies();

    return (dwError);
}


VOID
ClearPolicyStateBlock(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyState->pIpsecPolicyObject
            );
        pIpsecPolicyState->pIpsecPolicyObject = NULL;
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(
            pIpsecPolicyState->pIpsecPolicyData
            );
        pIpsecPolicyState->pIpsecPolicyData = NULL;
    }

    if (pIpsecPolicyState->pszDirectoryPolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszDirectoryPolicyDN);
        pIpsecPolicyState->pszDirectoryPolicyDN = NULL;
    }

    pIpsecPolicyState->CurrentPollingInterval =  gDefaultPollingInterval;
    pIpsecPolicyState->DefaultPollingInterval =  gDefaultPollingInterval;
    pIpsecPolicyState->DSIncarnationNumber = 0;
    pIpsecPolicyState->RegIncarnationNumber = 0;
    pIpsecPolicyState->dwCurrentState = POLL_STATE_INITIAL;
}


DWORD
OnPolicyPoll(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;


    switch (pIpsecPolicyState->dwCurrentState) {

    case POLL_STATE_DS_DOWNLOADED:
        dwError = ProcessDirectoryPolicyPollState(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case POLL_STATE_CACHE_DOWNLOADED:
        dwError = ProcessCachePolicyPollState(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case POLL_STATE_LOCAL_DOWNLOADED:
        dwError = ProcessLocalPolicyPollState(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case POLL_STATE_INITIAL:
        dwError = OnPolicyChanged(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    //
    // Set the new polling interval.
    //

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    return (dwError);

error:

    //
    // If in any of the three states other than the initial state,
    // then there was an error in pulling down the incarnation number
    // or the IPSec Policy from either the directory or the registry
    // or there might not no longer be any IPSec policy assigned to 
    // this machine. So the  polling state must reset back to the 
    // start state through a forced policy change. This is also
    // necessary if the polling state is already in the initial state.
    //

    dwError = OnPolicyChanged(
                  pIpsecPolicyState
                  );

    return (dwError);
}


DWORD
ProcessDirectoryPolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    DWORD dwIncarnationNumber = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_DIRECTORY_PROVIDER;
    DWORD dwSlientErrorCode = 0;


    //
    // The directory policy DN has to be the same, otherwise the
    // IPSec extension in Winlogon would have already notified 
    // PA Store of the DS policy change.
    //

    dwError = GetDirectoryIncarnationNumber(
                   pIpsecPolicyState->pszDirectoryPolicyDN,
                   &dwIncarnationNumber
                   );
    if (dwError) {
        dwError = MigrateFromDSToCache(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        return (ERROR_SUCCESS);
    }

    if (dwIncarnationNumber == pIpsecPolicyState->DSIncarnationNumber) {

        //
        // The policy has not changed at all.
        //

        AuditEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_POLLING_NO_CHANGES,
            NULL,
            TRUE,
            TRUE
            );
        return (ERROR_SUCCESS);
    }

    //
    // The incarnation number is different, so there's a need to 
    // update the policy.
    //

    dwError = LoadDirectoryPolicy(
                  pIpsecPolicyState->pszDirectoryPolicyDN,
                  &pIpsecPolicyObject
                  );
    if (dwError) {
        dwError = MigrateFromDSToCache(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        return (ERROR_SUCCESS);
    }

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    if (dwError) {
        dwError = MigrateFromDSToCache(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        if (pIpsecPolicyObject) {
            FreeIpsecPolicyObject(pIpsecPolicyObject);
        }
        return (ERROR_SUCCESS);
    }

    dwError = UpdatePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData,
                  pIpsecPolicyData
                  );

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    //
    // Now delete the old cache and write the new one in.
    //

    DeleteRegistryCache();

    CacheDirectorytoRegistry(pIpsecPolicyObject);

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->CurrentPollingInterval = pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = dwIncarnationNumber;

    NotifyIpsecPolicyChange();

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
    }
    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_POLLING_APPLIED_CHANGES,
        NULL,
        TRUE,
        TRUE
        );
    return (dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
GetDirectoryIncarnationNumber(
    LPWSTR pszIpsecPolicyDN,
    DWORD * pdwIncarnationNumber
    )
{
    DWORD dwError = 0;
    LPWSTR pszDefaultDirectory = NULL;
    HLDAP hLdapBindHandle = NULL;
    LPWSTR Attributes[] = {L"whenChanged", NULL};
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    WCHAR **strvalues = NULL;
    DWORD dwCount = 0;
    DWORD dwWhenChanged = 0;


    *pdwIncarnationNumber = 0;

    //
    // Open the directory store.
    //

    dwError = ComputeDefaultDirectory(
                  &pszDefaultDirectory
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = OpenDirectoryServerHandle(
                  pszDefaultDirectory,
                  389,
                  &hLdapBindHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecPolicyDN,
                  LDAP_SCOPE_BASE,
                  L"(objectClass=*)",
                  Attributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapGetValues(
                  hLdapBindHandle,
                  e,
                  L"whenChanged",
                  (WCHAR ***)&strvalues,
                  (int *)&dwCount
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));

    *pdwIncarnationNumber = dwWhenChanged;

error:

    if (pszDefaultDirectory) {
        FreeSPDStr(pszDefaultDirectory);
    }

    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (strvalues) {
        LdapValueFree(strvalues);
    }

    return (dwError);
}


DWORD
MigrateFromDSToCache(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszCachePolicyDN = NULL;


    dwError = GetCachePolicyDN(
                  &pszCachePolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecPolicyState->pszDirectoryPolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszDirectoryPolicyDN);
        pIpsecPolicyState->pszDirectoryPolicyDN = NULL;
    }

    pIpsecPolicyState->pszCachePolicyDN = pszCachePolicyDN;

    //
    // Keep pIpsecPolicyState->pIpsecPolicyData.
    // Keep pIpsecPolicyState->pIpsecPolicyObject.
    // Change the incarnation numbers.
    //

    pIpsecPolicyState->RegIncarnationNumber = pIpsecPolicyState->DSIncarnationNumber;

    pIpsecPolicyState->DSIncarnationNumber = 0;

    pIpsecPolicyState->dwCurrentState = POLL_STATE_CACHE_DOWNLOADED;

    //
    // Keep pIpsecPolicyState->CurrentPollingInterval.
    // Keep pIpsecPolicyState->DefaultPollingInterval.
    //

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_MIGRATE_DS_TO_CACHE,
        NULL,
        TRUE,
        TRUE
        );

error:

    return (dwError);
}


DWORD
ProcessCachePolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    DWORD dwIncarnationNumber = 0;
    LPWSTR pszCachePolicyDN = NULL;


    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );

    if (!dwError) {

        dwError = GetDirectoryIncarnationNumber(
                      pszDirectoryPolicyDN,
                      &dwIncarnationNumber
                      );

        if (!dwError) {

            dwError = CopyPolicyDSToFQRegString(
                          pszDirectoryPolicyDN,
                          &pszCachePolicyDN
                          );

            if (!dwError) {

                if (!_wcsicmp(pIpsecPolicyState->pszCachePolicyDN, pszCachePolicyDN)) {

                    if (pIpsecPolicyState->RegIncarnationNumber == dwIncarnationNumber) {
                        dwError = MigrateFromCacheToDS(pIpsecPolicyState);
                    }
                    else {
                        dwError = UpdateFromCacheToDS(pIpsecPolicyState);
                    }

                    if (dwError) {
                        dwError = OnPolicyChanged(pIpsecPolicyState);
                    }

                }
                else {

                    dwError = OnPolicyChanged(pIpsecPolicyState);

                }

            }

        }

    }

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (pszCachePolicyDN) {
        FreeSPDStr(pszCachePolicyDN);
    }

    return (ERROR_SUCCESS);
}


DWORD
MigrateFromCacheToDS(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;


    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecPolicyState->pszCachePolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszCachePolicyDN);
        pIpsecPolicyState->pszCachePolicyDN = NULL;
    }

    pIpsecPolicyState->pszDirectoryPolicyDN = pszDirectoryPolicyDN; 

    //
    // Keep pIpsecPolicyState->pIpsecPolicyData.
    // Keep pIpsecPolicyState->pIpsecPolicyObject.
    // Change the incarnation numbers.
    //

    pIpsecPolicyState->DSIncarnationNumber = pIpsecPolicyState->RegIncarnationNumber;

    pIpsecPolicyState->RegIncarnationNumber = 0;

    pIpsecPolicyState->dwCurrentState = POLL_STATE_DS_DOWNLOADED;

    //
    // Keep pIpsecPolicyState->CurrentPollingInterval.
    // Keep pIpsecPolicyState->DefaultPollingInterval.
    //

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_MIGRATE_CACHE_TO_DS,
        NULL,
        TRUE,
        TRUE
        );

error:

    return (dwError);
}


DWORD
UpdateFromCacheToDS(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_DIRECTORY_PROVIDER;
    DWORD dwSlientErrorCode = 0;


    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LoadDirectoryPolicy(
                  pszDirectoryPolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UpdatePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData,
                  pIpsecPolicyData
                  );

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    if (pIpsecPolicyState->pszCachePolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszCachePolicyDN);
    }

    //
    // Now delete the old cache and write the new one in.
    //

    DeleteRegistryCache();

    CacheDirectorytoRegistry(pIpsecPolicyObject);

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    