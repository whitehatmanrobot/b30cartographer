me other
             * app, then open drive a: and activate winfile by clicking on the
             * menu.  This causes a sys modal msg box to come up just before
             * entering menu mode.  The user may have the mouse button up but
             * menu mode code thinks it is down...
             */

            /*
             * Need to notify the app we are exiting menu mode because we told
             * it we were entering menu mode just before entering this function
             * in xxxSysCommand()...
             */
            if (!ppopupmenu->fNoNotify) {
                ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);
                xxxSendNotifyMessage(ppopupmenu->spwndNotify, WM_EXITMENULOOP,
                    ((ppopupmenu->fIsTrackPopup && !ppopupmenu->fIsSysMenu) ? TRUE : FALSE), 0);
                ThreadUnlock(&tlpwndT);
            }
            goto ExitMenuLoop;
        }

        /*
         * Simulate a WM_LBUTTONDOWN message.
         */
        if (!ppopupmenu->fIsTrackPopup) {

            /*
             * For TrackPopupMenus, we do it in the TrackPopupMenu function
             * itself so we don't want to do it again.
             */
            if (!xxxMNStartMenu(ppopupmenu, MOUSEHOLD)) {
                goto ExitMenuLoop;
            }
        }

        if ((ppopupmenu->fRightButton)) {
            msg.message = (fDblClk ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN);
            msg.wParam = MK_RBUTTON;
        } else {
            msg.message = (fDblClk ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN);
            msg.wParam = MK_LBUTTON;
        }
        msg.lParam = lParam;
        msg.hwnd = HW(ppopupmenu->spwndPopupMenu);
        xxxHandleMenuMessages(&msg, pMenuState, ppopupmenu);
     }

    /*
     * If this is a modeless menu, release capture, mark it in the menu state
     *   and return. Decrement foreground lock count.
     */
     if (pMenuState->fModelessMenu) {
         xxxMNReleaseCapture();

         DecSFWLockCount();
         DBGDecModalMenuCount();
         return 0;
     }

    while (pMenuState->fInsideMenuLoop) {

        /*
         * Is a message waiting for us?
         */
        BOOL fPeek = xxxPeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_NOREMOVE);

        Validateppopupmenu(ppopupmenu);

        if (fPeek) {
            /*
             * Bail if we have been forced out of menu loop
             */
            if (ExitMenuLoop (pMenuState, ppopupmenu)) {
                goto ExitMenuLoop;
            }

            /*
             * Since we could have blocked in xxxWaitMessage (see last line
             * of loop) or xxxPeekMessage, reset the cached copy of
             * ptiCurrent()->pq: It could have changed if someone did a
             * DetachThreadInput() while we were away.
             */
            if ((!ppopupmenu->fIsTrackPopup &&
                    pti->pq->spwndActive != ppopupmenu->spwndNotify &&
                    ((pti->pq->spwndActive == NULL) || !_IsChild(pti->pq->spwndActive, ppopupmenu->spwndNotify)))) {

                /*
                 * End menu processing if we are no longer the active window.
                 * This is needed in case a system modal dialog box pops up
                 * while we are tracking the menu code for example.  It also
                 * helps out Tracer if a macro is executed while a menu is down.
                 */

                /*
                 * Also, end menu processing if we think the mouse button is
                 * down but it really isn't.  (Happens if a sys modal dialog int
                 * time dlg box comes up while we are in menu mode.)
                 */

                goto ExitMenuLoop;
            }

            if (ppopupmenu->fIsMenuBar && msg.message == WM_LBUTTONDBLCLK) {

                /*
                 * Was the double click on the system menu or caption?
                 */
                hit = FindNCHit(ppopupmenu->spwndNotify, (LONG)msg.lParam);
                if (hit == HTCAPTION) {
                    PWND pwnd;
                    PMENU pmenu;

                    /*
                     * Get the message out of the queue since we're gonna
                     * process it.
                     */
                    xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
                    if (ExitMenuLoop (pMenuState, ppopupmenu)) {
                        goto ExitMenuLoop;
                    } else {
                        pwnd = ppopupmenu->spwndNotify;
                        ThreadLockAlways(pwnd, &tlpwndT);
                        pmenu = xxxGetSysMenuHandle(pwnd);
                        UserAssert(pwnd == ppopupmenu->spwndNotify);

                        menuState = _GetMenuState(pmenu, SC_RESTORE & 0x0000FFF0,
                                MF_BYCOMMAND);

                        /*
                         * Only send the sys command if the item is valid.  If
                         * the item doesn't exist or is disabled, then don't
                         * post the syscommand.  Note that for win2 apps, we
                         * always send the sys command if it is a child window.
                         * This is so hosebag apps can change the sys menu.
                         */
                        if (!(menuState & MFS_GRAYED)) {
                            _PostMessage(pwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
                        }

                        /*
                         * Get out of menu mode.
                         */
                        ThreadUnlock(&tlpwndT);
                        goto ExitMenuLoop;
                    }
                }
            }

            fInQueue = (msg.message == WM_LBUTTONDOWN ||
                        msg.message == WM_RBUTTONDOWN ||
                        msg.message == WM_NCLBUTTONDOWN ||
                        msg.message == WM_NCRBUTTONDOWN);

            if (!fInQueue) {

                /*
                 * Note that we call xxxPeekMessage() with the filter
                 * set to the message we got from xxxPeekMessage() rather
                 * than simply 0, 0.  This prevents problems when
                 * xxxPeekMessage() returns something like a WM_TIMER,
                 * and after we get here to remove it a WM_LBUTTONDOWN,
                 * or some higher-priority input message, gets in the
                 * queue and gets removed accidently.  Basically we want
                 * to be sure we remove the right message in this case.
                 * NT bug 3852 was caused by this problem.
                 * Set the TIF_IGNOREPLAYBACKDELAY bit in case journal playback
                 * is happening: this allows us to proceed even if the hookproc
                 * incorrectly returns a delay now.  The bit will be cleared if
                 * this happens, so we can see why the Peek-Remove below fails.
                 * Lotus' Freelance Graphics tutorial does such bad journalling
                 */

                pti->TIF_flags |= TIF_IGNOREPLAYBACKDELAY;
                if (!xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE)) {
                    if (pti->TIF_flags & TIF_IGNOREPLAYBACKDELAY) {
                        pti->TIF_flags &= ~TIF_IGNOREPLAYBACKDELAY;
                        /*
                         * It wasn't a bad journal playback: something else
                         * made the previously peeked message disappear before
                         * we could peek it again to remove it.
                         */
                        RIPMSG1(RIP_WARNING, "Disappearing msg 0x%08lx", msg.message);
                        goto NoMsg;
                    }
                }
                pti->TIF_flags &= ~TIF_IGNOREPLAYBACKDELAY;
            }

            if (!_CallMsgFilter(&msg, MSGF_MENU)) {
                if (!xxxHandleMenuMessages(&msg, pMenuState, ppopupmenu)) {
                    xxxTranslateMessage(&msg, 0);
                    xxxDispatchMessage(&msg);
                }

                Validateppopupmenu(ppopupmenu);

                if (ExitMenuLoop (pMenuState, ppopupmenu)) {
                    goto ExitMenuLoop;
                }

                if (pti->pq->QF_flags & QF_ACTIVATIONCHANGE) {

                    /*
                     * Run away and exit menu mode if another window has become
                     * active while a menu was up.
                     */
                    RIPMSG0(RIP_WARNING, "Exiting menu mode: another window activated");
                    goto ExitMenuLoop;
                }

#if DBG
                /*
                 * Nobody should be able to steal capture from us.
                 */
                if (!pMenuState->fInDoDragDrop) {
                    UserAssert(pti->pq->QF_flags & QF_CAPTURELOCKED);
                    UserAssert(pti->pq->spwndCapture == ppopupmenu->spwndNotify);
                }
#endif

                /*
                 * If we get a system timer, then it's like we're idle
                 */
                if (msg.message == WM_SYSTIMER) {
                    goto NoMsg;
                }

                /*
                 * Don't set fSendIdle if we got these messages
                 */
                if ((msg.message == WM_TIMER) || (msg.message == WM_PAINT)) {
                    continue;
                }

            } else {
                if (fInQueue)
                    xxxPeekMessage(&msg, NULL, msg.message, msg.message,
                            PM_REMOVE);
            }

            /*
             * Reenable WM_ENTERIDLE messages.
             */
            fSendIdle = TRUE;

        } else {
NoMsg:
            /*
             * Bail if we have been forced out of menu loop
             */
            if (ExitMenuLoop (pMenuState, ppopupmenu)) {
                goto ExitMenuLoop;
            }

            UserAssert((ppopupmenu->spwndActivePopup == NULL)
                    || (TestWF(ppopupmenu->spwndActivePopup, WFVISIBLE)));


            /*
             * If a hierarchical popup has been destroyed, this is a
             *  good time to flush ppmDelayedFree
             */
            if (ppopupmenu->fFlushDelayedFree) {
                MNFlushDestroyedPopups (ppopupmenu, FALSE);
                ppopupmenu->fFlushDelayedFree = FALSE;
            }

            /*
             * We need to send the WM_ENTERIDLE message only the first time
             * there are no messages for us to process.  Subsequent times we
             * need to yield via WaitMessage().  This will allow other tasks to
             * get some time while we have a menu down.
             */
            if (fSendIdle) {
                if (ppopupmenu->spwndNotify != NULL) {
                    ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndT);
                    xxxSendMessage(ppopupmenu->spwndNotify, WM_ENTERIDLE, MSGF_MENU,
                        (LPARAM)HW(ppopupmenu->spwndActivePopup));
                    ThreadUnlock(&tlpwndT);
                }
                fSendIdle = FALSE;
            } else {
                /*
                 * If we're animating, sleep only 1 ms to reduce the chance
                 *  of jerky animation.
                 * When not animating, this is the same as a xxxWaitMessage call
                 */
#ifdef MESSAGE_PUMP_HOOK
                xxxWaitMessageEx(QS_ALLINPUT | QS_EVENT, pMenuState->hdcWndAni != NULL);
#else
                xxxSleepThread(QS_ALLINPUT | QS_EVENT, (pMenuState->hdcWndAni != NULL), TRUE);
#endif
            }

        } /* if (PeekMessage(&msg, NULL, 0, 0, PM_NOYIELD)) else */

    } /* end while (fInsideMenuLoop) */



ExitMenuLoop:
    pMenuState->fInsideMenuLoop = FALSE;
    pMenuState->fModelessMenu = FALSE;

    /*
     * Make sure that the menu has been ended/canceled
     */
    xxxEndMenuLoop (pMenuState, ppopupmenu);

    xxxMNReleaseCapture();

    // Throw in an extra peek here when we exit the menu loop to ensure that the input queue
    // for this thread gets unlocked if there is no more input left for him.
    xxxPeekMessage(&msg, NULL, WM_MOUSEMOVE, WM_MOUSEMOVE, PM_NOYIELD | PM_NOREMOVE);
    return(pMenuState->cmdLast);
} /* xxxMenuLoop() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mndstry.c ===
/**************************** Module Header ********************************\
* Module Name: mndstry.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Destruction Routines
*
* History:
* 10-10-90 JimA       Created.
* 02-11-91 JimA       Added access checks.
* 03-18-91 IanJa      Window revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* DestroyMenu
*
* Destroy a menu and free its memory.
*
* History:
* 10-11-90 JimA         Translated from ASM.
* 02-11-91 JimA         Added access checks.
\***************************************************************************/

BOOL _DestroyMenu(
    PMENU pMenu)
{
    PITEM pItem;
    int i;
    PDESKTOP rpdeskLock;

    if (pMenu == NULL)
        return FALSE;

    /*
     * If the object is locked, just mark it for destroy and don't
     * free it yet.
     */
    if (!HMMarkObjectDestroy(pMenu))
        return TRUE;

    /*
     * Go down the item list and free the items
     */
    pItem = pMenu->rgItems;
    for (i = pMenu->cItems; i--; ++pItem)
        MNFreeItem(pMenu, pItem, TRUE);

    /*
     * free the menu items
     */
    if (pMenu->rgItems)
        DesktopFree(pMenu->head.rpdesk, pMenu->rgItems);

    /*
     * Because menus are the only objects on the desktop owned
     * by the process and process cleanup is done after thread
     * cleanup, this may be the last reference to the desktop.
     * We must lock the desktop before unlocking
     * the parent desktop reference and freeing the menu to
     * ensure that the desktop will not be freed until after
     * the menu is freed.  Don't use static locks because
     * the pti for this thread will not be valid during
     * process cleanup.
     */
    rpdeskLock = NULL;
    LockDesktop(&rpdeskLock, pMenu->head.rpdesk, LDL_FN_DESTROYMENU, (ULONG_PTR)PtiCurrent());

    /*
     * Unlock all menu objects.
     */
    Unlock(&pMenu->spwndNotify);

    HMFreeObject(pMenu);

    UnlockDesktop(&rpdeskLock, LDU_FN_DESTROYMENU, (ULONG_PTR)PtiCurrent());

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mnpopup.c ===
/**************************** Module Header ********************************\
* Module Name: mnpopup.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Popup Menu Support
*
* History:
*  10-10-90 JimA    Cleanup.
*  03-18-91 IanJa   Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define RECT_ONLEFT     0
#define RECT_ONTOP      1
#define RECT_ONRIGHT    2
#define RECT_ONBOTTOM   3
#define RECT_ORG        4

BOOL TryRect(
        UINT        wRect,
        int         x,
        int         y,
        int         cx,
        int         cy,
        LPRECT      prcExclude,
        LPPOINT     ppt,
        PMONITOR    pMonitor);

/***************************************************************************\
* xxxTrackPopupMenuEx (API)
*
* Process a popup menu
*
* Revalidation Notes:
* o  if pwndOwner is always the owner of the popup menu windows, then we don't
*    really have to revalidate it: when it is destroyed the popup menu windows
*    are destroyed first because it owns them - this is detected in MenuWndProc
*    so we would only have to test pMenuState->fSabotaged.
* o  pMenuState->fSabotaged must be cleared before this top-level routine
*    returns, to be ready for next time menus are processed (unless we are
*    currently inside xxxMenuLoop())
* o  pMenuState->fSabotaged should be FALSE when we enter this routine.
* o  xxxMenuLoop always returns with pMenuState->fSabotaged clear.  Use
*    a UserAssert to verify this.
*
* History:
\***************************************************************************/

int xxxTrackPopupMenuEx(
    PMENU       pMenu,
    UINT        dwFlags,
    int         x,
    int         y,
    PWND        pwndOwner,
    CONST TPMPARAMS *lpTpm)
{
    PMENUSTATE      pMenuState;
    PWND            pwndHierarchy;
    PPOPUPMENU      ppopupMenuHierarchy;
    LONG            sizeHierarchy;
    int             cxPopup,
                    cyPopup;
    BOOL            fSync;
    int             cmd;
    BOOL            fButtonDown;
    TL              tlpwndHierarchy;
    TL              tlpwndT;
    RECT            rcExclude;
    PTHREADINFO     ptiCurrent,
                    ptiOwner;
    PMONITOR        pMonitor;
    POINT           pt;

    CheckLock(pMenu);
    CheckLock(pwndOwner);

    /*
     * Capture the things we care about in case lpTpm goes away.
     */
    if (lpTpm != NULL) {
        if (lpTpm->cbSize != sizeof(TPMPARAMS)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "TrackPopupMenuEx: cbSize is invalid");
            return(FALSE);
        }
        rcExclude = lpTpm->rcExclude;
    }

    ptiCurrent = PtiCurrent();
    ptiOwner = GETPTI(pwndOwner);

    /*
     * Win95 compatibility: pwndOwner must be owned by ptiCurrent.
     */
    if (ptiCurrent != ptiOwner) {
        RIPMSG0(RIP_WARNING, "xxxTrackPopupMenuEx: pwndOwner not owned by ptiCurrent");
        return FALSE;
    }

    UserAssert(pMenu != NULL);
    if (ptiCurrent->pMenuState != NULL) {

        if (dwFlags & TPM_RECURSE) {
            /*
             * Only allow recursion if:
             *  -The current menu mode is not about to exit
             *  -Both menus notify the same window
             *  -Only one thread is involved in the current menu mode
             * This will prevent us from getting into some random
             *  scenarios we don't want to deal with
             */
           ppopupMenuHierarchy = ptiCurrent->pMenuState->pGlobalPopupMenu;
           pwndHierarchy = ppopupMenuHierarchy->spwndNotify;
           if (ExitMenuLoop(ptiCurrent->pMenuState, ppopupMenuHierarchy)
                || (pwndHierarchy == NULL)
                || (pwndHierarchy != pwndOwner)
                || (ptiCurrent->pMenuState->ptiMenuStateOwner != GETPTI(pwndHierarchy))) {

               RIPMSG0(RIP_WARNING, "xxxTrackPopupMenuEx: Failing TPM_RECURSE request");
               return FALSE;
           }
           /*
            * Terminate any animation
            */
            MNAnimate(ptiCurrent->pMenuState, FALSE);
           /*
            * Cancel pending show timer if any. ie, the app wants to
            *  pop up a context menu on a popup before we drop it.
            */
           ppopupMenuHierarchy = ((ppopupMenuHierarchy->spwndActivePopup != NULL)
                                  ? ((PMENUWND)(ppopupMenuHierarchy->spwndActivePopup))->ppopupmenu
                                  : NULL);
           if ((ppopupMenuHierarchy != NULL) && ppopupMenuHierarchy->fShowTimer) {

                _KillTimer(ppopupMenuHierarchy->spwndPopupMenu, IDSYS_MNSHOW);
                ppopupMenuHierarchy->fShowTimer = FALSE;
           }
           /*
            * If we're currently on a modal menu, let's unlock the capture
            *  so the recursive menu can get it.
            */
           if (!ptiCurrent->pMenuState->fModelessMenu) {
               ptiCurrent->pq->QF_flags &= ~QF_CAPTURELOCKED;
           }
        } else {
            /*
             * Allow only one guy to have a popup menu up at a time...
             */
            RIPERR0(ERROR_POPUP_ALREADY_ACTIVE, RIP_VERBOSE, "");
            return FALSE;
       }
   }

    // Is button down?

    if (dwFlags & TPM_RIGHTBUTTON)
    {
        fButtonDown = (_GetKeyState(VK_RBUTTON) & 0x8000) != 0;
    } else {
        fButtonDown = (_GetKeyState(VK_LBUTTON) & 0x8000) != 0;
    }

    /*
     * Create the menu window.
     */
    pwndHierarchy = xxxNVCreateWindowEx(
            WS_EX_TOOLWINDOW | WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE,
            (PLARGE_STRING)MENUCLASS,
            NULL,
            WS_POPUP | WS_BORDER,
            x, y, 100, 100,
            TestMF(pMenu, MNS_MODELESS) ? pwndOwner : NULL,
            NULL, (HANDLE)pwndOwner->hModule,
            NULL,
            WINVER);

    if (pwndHierarchy == NULL) {
        return FALSE;
    }

    if (TestWF(pwndOwner, WEFLAYOUTRTL) || (dwFlags & TPM_LAYOUTRTL)) {
        SetWF(pwndHierarchy, WEFLAYOUTRTL);
    }

    //
    // Do this so that old apps don't get weird borders on tracked popups due
    // to the app hack used in CreateWindowEx32.
    //
    ClrWF(pwndHierarchy, WFOLDUI);

    ThreadLockAlways(pwndHierarchy, &tlpwndHierarchy);

#ifdef HAVE_MN_GETPPOPUPMENU
    ppopupMenuHierarchy = (PPOPUPMENU)xxxSendMessage(pwndHierarchy,
                                                MN_GETPPOPUPMENU, 0, 0);
#else
    ppopupMenuHierarchy = ((PMENUWND)pwndHierarchy)->ppopupmenu;
#endif


    ppopupMenuHierarchy->fDelayedFree = TRUE;
    Lock(&(ppopupMenuHierarchy->spwndNotify), pwndOwner);
    LockPopupMenu(ppopupMenuHierarchy, &ppopupMenuHierarchy->spmenu, pMenu);
    Lock(&(ppopupMenuHierarchy->spwndActivePopup), pwndHierarchy);
    ppopupMenuHierarchy->ppopupmenuRoot = ppopupMenuHierarchy;
    ppopupMenuHierarchy->fIsTrackPopup  = TRUE;
    ppopupMenuHierarchy->fFirstClick = fButtonDown;
    ppopupMenuHierarchy->fRightButton   = ((dwFlags & TPM_RIGHTBUTTON) != 0);
    if (SYSMET(MENUDROPALIGNMENT) || TestMF(pMenu, MFRTL)) {
       //
       // popup's below this one need to follow the same direction as
       // the other menu's on the desktop.
       //
       ppopupMenuHierarchy->fDroppedLeft = TRUE;
    }
    ppopupMenuHierarchy->fNoNotify      = ((dwFlags & TPM_NONOTIFY) != 0);

    if (fSync = (dwFlags & TPM_RETURNCMD))
        ppopupMenuHierarchy->fSynchronous = TRUE;

    ppopupMenuHierarchy->fIsSysMenu =  ((dwFlags & TPM_SYSMENU) != 0);

    // Set the GlobalPopupMenu variable so that EndMenu works for popupmenus so
    // that WinWart II people can continue to abuse undocumented functions.
    // This is nulled out in MNCancel.
    /*
     * This is actually needed for cleanup in case this thread ends
     *  execution before we can free the popup. (See xxxDestroyThreadInfo)
     *
     * Note that one thread might own pwndOwner and another one might call
     *  TrackPopupMenu (pretty normal if the two threads are attached). So
     *  properly setting (and initializing) pMenuState is a must here.
     */
    pMenuState = xxxMNAllocMenuState(ptiCurrent, ptiOwner, ppopupMenuHierarchy);
    if (pMenuState == NULL) {
        /*
         * Get out. The app never knew we were here so don't notify it
         */
        dwFlags |= TPM_NONOTIFY;
        goto AbortTrackPopupMenuEx;
    }

    /*
     * Notify the app we are entering menu mode.  wParam is 1 since this is a
     * TrackPopupMenu.
     */

    if (!ppopupMenuHierarchy->fNoNotify)
        xxxSendMessage(pwndOwner, WM_ENTERMENULOOP,
            (ppopupMenuHierarchy->fIsSysMenu ? FALSE : TRUE), 0);

    /*
     * Send off the WM_INITMENU, set ourselves up for menu mode etc...
     */
    if (!xxxMNStartMenu(ppopupMenuHierarchy, MOUSEHOLD)) {
        /*
         * ppopupMenuHierarchy has been destroyed already; let's bail
         */
        goto AbortTrackPopupMenuEx;
    }

    /*
     * If drag and drop, register the window as a target.
     */
    if (pMenuState->fDragAndDrop) {
        if (!SUCCEEDED(xxxClientRegisterDragDrop(HW(pwndHierarchy)))) {
            RIPMSG0(RIP_ERROR, "xxxTrackPopupMenuEx: xxxClientRegisterDragDrop failed");
        }
    }

    if (!ppopupMenuHierarchy->fNoNotify) {
        ThreadLock(ppopupMenuHierarchy->spwndNotify, &tlpwndT);
        xxxSendMessage(ppopupMenuHierarchy->spwndNotify, WM_INITMENUPOPUP,
            (WPARAM)PtoHq(pMenu), MAKELONG(0, (ppopupMenuHierarchy->fIsSysMenu ? 1: 0)));
        ThreadUnlock(&tlpwndT);
        ppopupMenuHierarchy->fSendUninit = TRUE;
    }

    /*
     * Size the menu window if needed...
     */
    sizeHierarchy = (LONG)xxxSendMessage(pwndHierarchy, MN_SIZEWINDOW, MNSW_SIZE, 0);

    if (!sizeHierarchy) {

AbortTrackPopupMenuEx:
        xxxWindowEvent(EVENT_SYSTEM_MENUEND, pwndOwner, OBJID_WINDOW, INDEXID_CONTAINER, 0);
        
        /*
         * Release the mouse capture we set when we called StartMenuState...
         */
        xxxMNReleaseCapture();

        /* Notify the app we have exited menu mode.  wParam is 1 for real
         * tracked popups, not sys menu.  Check wFlags since ppopupHierarchy
         * will be gone.
         */
        if (!(dwFlags & TPM_NONOTIFY))
            xxxSendMessage(pwndOwner, WM_EXITMENULOOP, ((dwFlags & TPM_SYSMENU) ?
                FALSE : TRUE), 0L);

        /*
         * Make sure we return failure
         */
        fSync = TRUE;
        cmd = FALSE;
        goto CleanupTrackPopupMenuEx;
    }

    if (glinp.dwFlags & LINP_KEYBOARD) {
        pMenuState->fUnderline = TRUE;
        SetMF(pMenu, MFUNDERLINE);
    } else {
        ClearMF(pMenu, MFUNDERLINE);
    }

    //
    // Setup popup window dimensions
    //
    cxPopup = LOWORD(sizeHierarchy) + 2*SYSMET(CXFIXEDFRAME);
    cyPopup = HIWORD(sizeHierarchy) + 2*SYSMET(CYFIXEDFRAME);

    //
    // Calculate the monitor BEFORE we adjust the point.  Otherwise, we might
    // move the point offscreen.  In which case, we will end up pinning the
    // popup to the primary display, which is wrong.
    //
    pt.x = x;
    pt.y = y;
    pMonitor = _MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);

    //
    // Horizontal alignment
    //
    if (TestWF(pwndOwner, WEFLAYOUTRTL) && !(dwFlags & TPM_CENTERALIGN)) {
        dwFlags = dwFlags ^ TPM_RIGHTALIGN;
    }

    if (dwFlags & TPM_RIGHTALIGN) {
#if DBG
        if (dwFlags & TPM_CENTERALIGN) {
            RIPMSG0(RIP_WARNING, "TrackPopupMenuEx:  TPM_CENTERALIGN ignored");
        }
#endif // DBG

        x -= cxPopup;
        ppopupMenuHierarchy->iDropDir = PAS_LEFT;
    } else if (dwFlags & TPM_CENTERALIGN) {
        x -= (cxPopup / 2);
    } else {
        ppopupMenuHierarchy->iDropDir = (ppopupMenuHierarchy->fDroppedLeft ? PAS_LEFT : PAS_RIGHT);
    }

    //
    // Vertical alignment
    //
    if (dwFlags & TPM_BOTTOMALIGN) {
#if DBG
        if (dwFlags & TPM_VCENTERALIGN) {
            RIPMSG0(RIP_WARNING, "TrackPopupMenuEx:  TPM_VCENTERALIGN ignored");
        }
#endif // DBG

        y -= cyPopup;
        ppopupMenuHierarchy->iDropDir |= PAS_UP;
    } else if (dwFlags & TPM_VCENTERALIGN) {
        y -= (cyPopup / 2);
    } else {
        ppopupMenuHierarchy->iDropDir |= PAS_DOWN;
    }
    /*
     * If the caller provided an animation direction, use that instead
     */
    if (dwFlags & TPM_ANIMATIONBITS) {
        ppopupMenuHierarchy->iDropDir = ((dwFlags >> TPM_FIRSTANIBITPOS) & (PAS_VERT | PAS_HORZ));
    }
    //
    // Get coords to move to.
    //
    sizeHierarchy = FindBestPos(
            x,
            y,
            cxPopup,
            cyPopup,
            ((lpTpm != NULL) ? &rcExclude : NULL),
            dwFlags,
            ppopupMenuHierarchy,
            pMonitor);

    if (TestWF(pwndOwner, WEFLAYOUTRTL) && (ppopupMenuHierarchy->iDropDir & PAS_HORZ)) {
        ppopupMenuHierarchy->iDropDir ^= PAS_HORZ;
    }

    /*
     * If we have an animation direction and the caller wants animation,
     *  set the bit to get it going.
     */
    if ((ppopupMenuHierarchy->iDropDir != 0) && !(dwFlags & TPM_NOANIMATION)) {
        ppopupMenuHierarchy->iDropDir |= PAS_OUT;
    }

    /*
     * Show the window. Modeless menus are not topmost and get activated.
     *  Modal menus are topmost but don't get activated.
     */
    PlayEventSound(USER_SOUND_MENUPOPUP);
    xxxSetWindowPos(pwndHierarchy,
            (pMenuState->fModelessMenu ? PWND_TOP : PWND_TOPMOST),
            GET_X_LPARAM(sizeHierarchy), GET_Y_LPARAM(sizeHierarchy), 0, 0,
            SWP_SHOWWINDOW | SWP_NOSIZE | SWP_NOOWNERZORDER
            | (pMenuState->fModelessMenu ? 0 : SWP_NOACTIVATE));

    xxxWindowEvent(EVENT_SYSTEM_MENUPOPUPSTART, pwndHierarchy, OBJID_CLIENT, INDEXID_CONTAINER, 0);
    
    /*
     * We need to return TRUE for compatibility w/ async TrackPopupMenu().
     * It is conceivable that a menu ID could have ID 0, in which case just
     * returning the cmd chosen would return FALSE instead of TRUE.
     */

    /*
     * If mouse is in client of popup, act like clicked down
     */
    pMenuState->fButtonDown = fButtonDown;

    cmd = xxxMNLoop(ppopupMenuHierarchy, pMenuState, 0, FALSE);

    /*
     * If this is a modeless menu, return without clenning up because
     *  the menu is up.
     */
    if (pMenuState->fModelessMenu) {
        ThreadUnlock(&tlpwndHierarchy);
        goto ReturnCmdOrTrue;
    }

CleanupTrackPopupMenuEx:

    if (ThreadUnlock(&tlpwndHierarchy)) {
        if (!TestWF(pwndHierarchy, WFDESTROYED)) {
            xxxDestroyWindow(pwndHierarchy);
        }
    }

    if (pMenuState != NULL) {
        xxxMNEndMenuState (TRUE);
    }

    /*
     * Capture must be unlocked if no menu is active.
     */
    UserAssert(!(ptiCurrent->pq->QF_flags & QF_CAPTURELOCKED)
            || ((ptiCurrent->pMenuState != NULL)
                && !ptiCurrent->pMenuState->fModelessMenu));


ReturnCmdOrTrue:
    return(fSync ? cmd : TRUE);
}

/***************************************************************************\
*
* FindBestPos()
*
* Gets best point to move popup menu window to, given exclusion area and
* screen real estate.  Note that for our purposes, we consider center
* alignment to be the same as left/top alignment.
*
* We try to pin the menu to a particular monitor, to avoid having it
* cross.
*
* We try four possibilities if the original position fails.  The order of
* these is determined by the alignment and "try" flags.  Basically, we try
* to move the rectangle out of the exclusion area by sliding it horizontally
* or vertically without going offscreen.  If we can't, then we know that
* sliding it in both dimensions will also fail.  So we use the original
* point, clipping on screen.
*
* Take the example of a top-left justified popup, which should be moved
* horizontally before vertically.  We'll try the original point.  Then
* we'll try to left-justify with the right edge of the exclude rect.  Then
* we'll try to top-justify with the bottom edge of the exclude rect.  Then
* we'll try to right-justify with the left edge of the exclude rect.  Then
* we'll try to bottom-justify with the top edge of the exclude rect.
* Finally, we'll use the original pos.
*
\***************************************************************************/

LONG
FindBestPos(
        int         x,
        int         y,
        int         cx,
        int         cy,
        LPRECT      prcExclude,
        UINT        wFlags,
        PPOPUPMENU  ppopupmenu,
        PMONITOR    pMonitor)
{
    int iRect;
    int iT;
    UINT awRect[4];
    POINT ptT;
    RECT rcExclude;
    //
    // Clip our coords on screen first.  We use the same algorithm to clip
    // as in Win3.1 for dudes with no exclude rect.
    //

    if (prcExclude!=NULL) {
        // Clip exclude rect to monitor!
        CopyRect(&rcExclude, prcExclude);
        IntersectRect(&rcExclude, &rcExclude, &pMonitor->rcMonitor);
    } else {
        SetRect(&rcExclude, x, y, x, y);
    }


    /*
     * Make sure popup fits completely on the screen
     * At least the x,y point will be on the screen.
     */
    if (x + cx > pMonitor->rcMonitor.right) {
        if ((wFlags & TPM_CENTERALIGN)
                || (x - cx < pMonitor->rcMonitor.left)
                || (x >= pMonitor->rcMonitor.right)) {
            x = pMonitor->rcMonitor.right - cx;
        } else {
            x -= cx;
        }
        if (ppopupmenu->iDropDir & PAS_HORZ) {
            COPY_FLAG(ppopupmenu->iDropDir, PAS_LEFT, PAS_HORZ);
        }
    }

    if (x < pMonitor->rcMonitor.left) {
        x += cx;
        if ((wFlags & TPM_CENTERALIGN)
                || (x >= pMonitor->rcMonitor.right)
                || (x < pMonitor->rcMonitor.left)) {
            x = pMonitor->rcMonitor.left;
        }
        if (ppopupmenu->iDropDir & PAS_HORZ) {
            COPY_FLAG(ppopupmenu->iDropDir, PAS_RIGHT, PAS_HORZ);
        }
    }

    /*
     * Make sure popup fits completely on the screen
     * At least the x+cx,y point will be on the screen
     * for right aligned menus.
     */
    if ((wFlags & TPM_RIGHTALIGN) 
            && (x + cx > pMonitor->rcMonitor.right)) {
        x = pMonitor->rcMonitor.right - cx;
    }


    if (y + cy > pMonitor->rcMonitor.bottom) {
        if ((wFlags & TPM_VCENTERALIGN)
                || (y - cy < pMonitor->rcMonitor.top)
                || (y >= pMonitor->rcMonitor.bottom)) {
            y = pMonitor->rcMonitor.bottom - cy;
        } else {
            y -= cy;
        }
        if (ppopupmenu->iDropDir & PAS_VERT) {
            COPY_FLAG(ppopupmenu->iDropDir, PAS_UP, PAS_VERT);
        }
    }

    if (y < pMonitor->rcMonitor.top) {
        y += cy;
        if ((wFlags & TPM_VCENTERALIGN)
                || (y >= pMonitor->rcMonitor.bottom)
                || (y < pMonitor->rcMonitor.top)) {
            y = pMonitor->rcMonitor.top;
        }
        if (ppopupmenu->iDropDir & PAS_VERT) {
            COPY_FLAG(ppopupmenu->iDropDir, PAS_DOWN, PAS_VERT);
        }
    }

    //
    // Try first point
    //
    if (TryRect(RECT_ORG, x, y, cx, cy, &rcExclude, &ptT, pMonitor))
        goto FOUND;

    //
    // Sort possibilities.  Get offset of horizontal rects.
    //
    iRect = (wFlags & TPM_VERTICAL) ? 2 : 0;

    //
    // Sort horizontally.  Note that we treat TPM_CENTERALIGN like
    // TPM_LEFTALIGN.
    //
    //
    // If we're right-aligned, try to right-align on left side first.
    // Otherwise, try to left-align on right side first.
    //
    iT = (wFlags & TPM_RIGHTALIGN) ? 0 : 2;

    awRect[0 + iRect] = RECT_ONLEFT + iT;
    awRect[1 + iRect] = RECT_ONRIGHT - iT;

    //
    // Sort vertically.  Note that we treat TPM_VCENTERALIGN like
    // TPM_TOPALIGN.
    //
    // If we're bottom-aligned, try to bottom-align with top of rect
    // first.  Otherwise, try to top-align with bottom of exclusion first.
    //
    iT = (wFlags & TPM_BOTTOMALIGN) ? 0 : 2;

    awRect[2 - iRect] = RECT_ONTOP + iT;
    awRect[3 - iRect] = RECT_ONBOTTOM - iT;

    //
    // Loop through sorted alternatives.  Note that TryRect fails immediately
    // if an exclusion coordinate is too close to screen edge.
    //

    for (iRect = 0; iRect < 4; iRect++) {
        if (TryRect(awRect[iRect], x, y, cx, cy, &rcExclude, &ptT, pMonitor)) {
            switch (awRect[iRect])
            {
                case RECT_ONTOP:
                    ppopupmenu->iDropDir = PAS_UP;
                    break;
                case RECT_ONLEFT:
                    ppopupmenu->iDropDir = PAS_LEFT;
                    break;
                case RECT_ONBOTTOM:
                    ppopupmenu->iDropDir = PAS_DOWN;
                    break;
                case RECT_ONRIGHT:
                    ppopupmenu->iDropDir = PAS_RIGHT;
                    break;
            }

            x = ptT.x;
            y = ptT.y;
            break;
        }
    }

FOUND:
    return MAKELONG(x, y);
}



/***************************************************************************\
*
*  TryRect()
*
*  Tries to fit rect on screen without covering exclusion area.  Returns
*  TRUE if success.
*
\***************************************************************************/

BOOL
TryRect(
        UINT        wRect,
        int         x,
        int         y,
        int         cx,
        int         cy,
        LPRECT      prcExclude,
        LPPOINT     ppt,
        PMONITOR    pMonitor)
{
    RECT rcTry;

    switch (wRect) {
        case RECT_ONRIGHT:
            x = prcExclude->right;
            if (x + cx > pMonitor->rcMonitor.right)
                return FALSE;
            break;

        case RECT_ONBOTTOM:
            y = prcExclude->bottom;
            if (y + cy > pMonitor->rcMonitor.bottom)
                return FALSE;
            break;

        case RECT_ONLEFT:
            x = prcExclude->left - cx;
            if (x < pMonitor->rcMonitor.left)
                return FALSE;
            break;

        case RECT_ONTOP:
            y = prcExclude->top - cy;
            if (y < pMonitor->rcMonitor.top)
                return FALSE;
            break;

        //
        // case RECT_ORG:
        //      NOP;
        //      break;
        //
    }

    ppt->x = x;
    ppt->y = y;

    rcTry.left      = x;
    rcTry.top       = y;
    rcTry.right     = x + cx;
    rcTry.bottom    = y + cy;

    return(!IntersectRect(&rcTry, &rcTry, prcExclude));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mnkey.c ===
/**************************** Module Header ********************************\
* Module Name: mnkey.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Keyboard Handling Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

int xxxClientFindMnemChar(
    PUNICODE_STRING pstrSrc,
    WCHAR ch,
    BOOL fFirst,
    BOOL fPrefix);

/* MenuSwitch commands */
#define CMDSWITCH   1
#define CMDQUERY    2

/***************************************************************************\
* FindNextValidMenuItem
*
* !
*
* History:
\***************************************************************************/

UINT MNFindNextValidItem(
    PMENU pMenu,
    int i,
    int dir,
    UINT flags)
{
    int iStart;
    BOOL cont = TRUE;
    int cItems = pMenu->cItems;
    PITEM pItem;

    if ((i < 0) && (dir > 0))
        // going forward from beginning -- stop after last menu item
        i = iStart = cItems;
    else if ((i >= cItems) && (dir < 0))
        // going backward from end -- stop after first menu item
        i = iStart = -1;
    else
        iStart = i;

    if (!cItems)
        return(MFMWFP_NOITEM);

    // b#8997 - if we have these conditions and enter
    // loop will go blistic ( infin )
    // fix: jump over code and come loop to i == iStart will now stop us
    if ( ( i == 0 ) && ( cItems == 1 ) && ( dir > 0 ) )
    {
        dir = 0;
        goto artsquickndirtybugfix;
    }

    //
    // Loop thru menu items til (1) we find a valid item
    //                       or (2) we make it back to the start item (iStart)
    while (TRUE) {
        i += dir;

        if ((i == iStart) || (dir == 0))
            // we made it back to start item -- return NOT FOUND
            return MFMWFP_NOITEM;

        // keep 'i' in the range: 0 <= i < cItems
        if (i >= cItems) {
            i = -1;
            continue;
        }
        else if (i < 0) {
            i = cItems;
            continue;
        }

artsquickndirtybugfix:
        pItem = pMenu->rgItems + i;

        // skip ownerdraw - seperators even though there not NULL
        if (TestMFT(pItem, MFT_SEPARATOR)) {
            //
            // Skip non-separator (if asked) empty items.  With hot-tracking,
            // it is acceptable for them to be selected.  In truth, it was possible
            // in Win3.1 too, but less likely.
            //
            if (!(flags & MNF_DONTSKIPSEPARATORS)) {
                continue;
            }
        } else if ((pItem->hbmp >= HBMMENU_MBARFIRST) && (pItem->hbmp <= HBMMENU_MBARLAST)) {
            /*
             * Skip close & minimize & restore buttons
             */
            continue;
        }

        // return index of found item
        return(i);
    }

    //
    // We should never get here!
    //
    UserAssert(FALSE);
}

/***************************************************************************\
* MKF_FindMenuItemInColumn
*
* Finds closest item in the pull-down menu's next "column".
*
* History:
\***************************************************************************/

UINT MNFindItemInColumn(
    PMENU pMenu,
    UINT idxB,
    int dir,
    BOOL fRoot)
{
    int dxMin;
    int dyMin;
    int dxMax;
    int dyMax;
    int xB;
    int yB;
    UINT idxE;
    UINT idxR;
    UINT cItems;
    PITEM pItem;

    cItems = pMenu->cItems;
    idxR = MFMWFP_NOITEM;
    idxE = MNFindNextValidItem(pMenu, MFMWFP_NOITEM, dir, 0);
    if (idxE == -1)
        goto End;

    dxMin = dyMin = 20000;

    if (idxB >= pMenu->cItems)
        return idxR;

    pItem = &pMenu->rgItems[idxB];
    xB = pItem->xItem;
    yB = pItem->yItem;

    while (cItems-- > 0 &&
            (idxB = MNFindNextValidItem(pMenu, idxB, dir, 0)) != idxE &&
            (idxB != MFMWFP_NOITEM)) {
        pItem = &pMenu->rgItems[idxB];
        dxMax = xB - pItem->xItem;
        dyMax = yB - pItem->yItem;

        if (dxMax < 0)
            dxMax = (-dxMax);
        if (dyMax < 0)
            dyMax = (-dyMax);

        // See if this item is nearer than the last item found
        // --------------------------------------------------------
        // (fRoot || dxMax) -- this condition means that if it's
        // not the actual menu bar menu that we're dealing with,
        // then the item below/above (same X value as) the selected
        // item is not a valid one to move to
        if ((dyMax < dyMin) && (fRoot || dxMax) && dxMax <= dxMin) {
            dxMin = dxMax;
            dyMin = dyMax;
            idxR = idxB;
        }
    }

End:
    return idxR;
}

/***************************************************************************\
* MKF_FindMenuChar
*
* Translates Virtual cursor key movements into pseudo-ascii values.  Maps a
* character to an item number.
*
* History:
\***************************************************************************/

UINT xxxMNFindChar(
    PMENU pMenu,
    UINT ch,
    int idxC,
    LPINT lpr)       /* Put match type here */
{
    int idxFirst = MFMWFP_NOITEM;
    int idxB;
    int idxF;
    int rT;
    LPWSTR lpstr;
    PITEM pItem;

    if (ch == 0)
        return 0;

    /*
     * First time thru go for the very first menu.
     */
    idxF = MFMWFP_NOITEM;
    rT = 0;
    idxB = idxC;

    if (idxB < 0)
//    if (idxB & 0x8000)
        idxB = MNFindNextValidItem(pMenu, pMenu->cItems, MFMWFP_NOITEM, MNF_DONTSKIPSEPARATORS);

    do {
        INT idxPrev;

        idxPrev = idxC;
        idxC = MNFindNextValidItem(pMenu, idxC, 1, MNF_DONTSKIPSEPARATORS);
        if (idxC == MFMWFP_NOITEM || idxC == idxFirst)
            break;
        if (idxFirst == MFMWFP_NOITEM)
            idxFirst = idxC;

        pItem = &pMenu->rgItems[idxC];

        if (pItem->lpstr != NULL) {
            if (pItem->cch != 0) {
                UNICODE_STRING strMnem;

                lpstr = TextPointer(pItem->lpstr);
                if (*lpstr == CH_HELPPREFIX) {

                    /*
                     * Skip help prefix if it is there so that we can mnemonic
                     * to the first character of a right justified string.
                     */
                    lpstr++;
                }

                RtlInitUnicodeString(&strMnem, lpstr);
                if (((rT = (UINT)xxxClientFindMnemChar(&strMnem,
                        (WCHAR)ch, TRUE, TRUE)) == 0x0080) &&
                        (idxF == MFMWFP_NOITEM))
                    idxF = idxC;
            }
        }
        if (idxC == idxPrev) {
            break;  // no progress - break inf. loop
        }
    } while (rT != 1 && idxB != idxC);

    *lpr = rT;

    if (rT == 1)
        return idxC;

    return idxF;
}


/***************************************************************************\
* xxxMenuKeyFilter
*
* !
*
* Revalidation notes:
* o Routine assumes it is called with pMenuState->hwndMenu non-NULL and valid.
* o If one or more of the popup menu windows is unexpectedly destroyed, this is
*   detected in xxxMenuWndProc(), which sets pMenuState->fSabotaged and calls
*   xxxKillMenuState().  Therefore, if we return from an xxxRoutine with
*   pMenuState->fSabotaged set, we must abort immediately.
* o If pMenuState->hwndMenu is unexpectedly destroyed, we abort only if we
*   need to use the corresponding pwndMenu.
* o pMenuState->hwndMenu may be supplied as a parameter to various routines
*   (eg:  xxxNextItem), whether valid or not.
* o Any label preceded with xxx (eg: xxxMKF_UnlockAndExit) may be reached with
*   pMenuState->hwndMenu invalid.
* o If this routine is not called while in xxxMenuLoop(), then it must
*   clear pMenuState->fSabotaged before returning.
*
* History:
\***************************************************************************/

void xxxMNKeyFilter(
    PPOPUPMENU ppopupMenu,
    PMENUSTATE pMenuState,
    UINT ch)
{
    BOOL fLocalInsideMenuLoop = pMenuState->fInsideMenuLoop;

    if (pMenuState->fButtonDown) {

        /*
         * Ignore keystrokes while the mouse is pressed (except ESC).
         */
        return;
    }

    if (!pMenuState->fInsideMenuLoop) {

        /*
         * Need to send the WM_INITMENU message before we pull down the menu.
         */
        if (!xxxMNStartMenu(ppopupMenu, KEYBDHOLD)) {
            return;
        }
        pMenuState->fInsideMenuLoop = TRUE;
    }


    switch (ch) {
    case 0:

        /*
         * If we get a WM_KEYDOWN alt key and then a KEYUP alt key, we need to
         * activate the first item on the menu.  ie.  user hits and releases alt
         * key so just select first item.  USER sends us a SC_KEYMENU with
         * lParam 0 when the user does this.
         */
        xxxMNSelectItem(ppopupMenu, pMenuState, 0);
        break;

    case MENUCHILDSYSMENU:
        if (!TestwndChild(ppopupMenu->spwndNotify)) {

            /*
             * Change made to fix MDI problem: child window gets a keymenu,
             * and pops up sysmenu of frame when maximized.  Need to act like
             * MENUCHAR if hwndMenu is a top-level.
             */
            goto MenuCharHandler;
        }

        /*
         * else fall through.
         */

    case MENUSYSMENU:
        if (!TestWF(ppopupMenu->spwndNotify, WFSYSMENU)) {
            xxxMessageBeep(0);
            goto MenuCancel;
        }

        /*
         * Popup any hierarchies we have.
         */
        xxxMNCloseHierarchy(ppopupMenu, pMenuState);
        if (!ppopupMenu->fIsSysMenu && ppopupMenu->spmenuAlternate)
            xxxMNSwitchToAlternateMenu(ppopupMenu);
        if (!ppopupMenu->fIsSysMenu) {
            /*
             * If no system menu, get out.
             */
            goto MenuCancel;
        }

        MNPositionSysMenu(ppopupMenu->spwndPopupMenu, ppopupMenu->spmenu);
        xxxMNSelectItem(ppopupMenu, pMenuState, 0);
        xxxMNOpenHierarchy(ppopupMenu, pMenuState);
        ppopupMenu->fToggle = FALSE;
        break;


    default:

        /*
         * Handle ALT-Character sequences for items on top level menu bar.
         * Note that fInsideMenuLoop may be set to false on return from this
         * function if the app decides to return 1 to the WM_MENUCHAR message.
         * We detect this and not enter MenuLoop if fInsideMenuLoop is reset
         * to false.
         */
MenuCharHandler:
        xxxMNChar(ppopupMenu, pMenuState, ch);
        if (ppopupMenu->posSelectedItem == MFMWFP_NOITEM) {
            /*
             * No selection found.
             */
            goto MenuCancel;
        }
        break;
    }

    if (!fLocalInsideMenuLoop && pMenuState->fInsideMenuLoop) {
        xxxMNLoop(ppopupMenu, pMenuState, 0, FALSE);
    }

    return;


MenuCancel:
    pMenuState->fModelessMenu = FALSE;
    if (!ppopupMenu->fInCancel) {
        xxxMNDismiss(pMenuState);
    }
    UserAssert(!pMenuState->fInsideMenuLoop && !pMenuState->fMenuStarted);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mnsel.c ===
/**************************** Module Header ********************************\
* Module Name: mnsel.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Selection Routines
*
* History:
*  10-10-90 JimA    Cleanup.
*  03-18-91 IanJa   Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxSendMenuSelect
*
* !
*
* Revalidation notes:
* o Assumes pMenuState->hwndMenu is non-NULL and valid
*
* Note: if pMenu==SMS_NOMENU, idx had better be MFMWFP_NOITEM!
*
* History:
\***************************************************************************/

void xxxSendMenuSelect(
    PWND pwndNotify,
    PWND pwndMenu,
    PMENU pMenu,
    int idx)
{
    UINT cmd;       // Menu ID if applicable.
    UINT flags;     // MF_ values if any
    MSG msg;
    PMENUSTATE pMenuState;

    CheckLock(pwndNotify);
    CheckLock(pwndMenu);


    /*
     * We must be hacking or passing valid things.
     */
    UserAssert((pMenu != SMS_NOMENU) || (idx == MFMWFP_NOITEM));


    if ((idx >= 0) && (pMenu->cItems > (UINT)idx)) {
        PITEM pItem = &(pMenu->rgItems[idx]);

        flags   = (pItem->fType  & MFT_OLDAPI_MASK) |
                  (pItem->fState & MFS_OLDAPI_MASK);

        if (pItem->spSubMenu != NULL)
            flags |= MF_POPUP;

        flags &= (~(MF_SYSMENU | MF_MOUSESELECT));

        /*
         * WARNING!
         * Under Windows the menu handle was always returned but additionally
         * if the menu was a pop-up the pop-up menu handle was returned
         * instead of the ID.  In NT we don't have enough space for 2 handles
         * and flags so if it is a pop-up we return the pop-up index
         * and the main Menu handle.
         */

        if (flags & MF_POPUP)
            cmd = idx;      // index of popup-menu
        else
            cmd = pItem->wID;

        pMenuState = GetpMenuState(pwndNotify);
        if (pMenuState != NULL) {
            if (pMenuState->mnFocus == MOUSEHOLD)
                flags |= MF_MOUSESELECT;

            if (pMenuState->fIsSysMenu)
                flags |= MF_SYSMENU;

        }
    } else {
        /*
         * idx assumed to be MFMWFP_NOITEM
         */
        if (pMenu == SMS_NOMENU) {

            /*
             * Hack so we can send MenuSelect messages with MFMWFP_MAINMENU
             * (loword(lparam)=-1) when the menu pops back up for the CBT people.
             */
            flags = MF_MAINMENU;
        } else {
            flags = 0;
        }

        cmd = 0;    // so MAKELONG(cmd, flags) == MFMWFP_MAINMENU
        pMenu = 0;
        idx = -1;   // so that idx+1 == 0, meaning nothing for zzzWindowEvent()
    }

    /*
     * Call msgfilter so help libraries can hook WM_MENUSELECT messages.
     */
    msg.hwnd = HW(pwndNotify);
    msg.message = WM_MENUSELECT;
    msg.wParam = (DWORD)MAKELONG(cmd, flags);
    msg.lParam = (LPARAM)PtoH(pMenu);
    if (!_CallMsgFilter((LPMSG)&msg, MSGF_MENU)) {
        xxxSendNotifyMessage(pwndNotify, WM_MENUSELECT, msg.wParam, msg.lParam);
    }

    if (pwndMenu) {
        xxxWindowEvent(EVENT_OBJECT_FOCUS, pwndMenu,
                ((pwndMenu != pwndNotify) ? OBJID_CLIENT : ((flags & MF_SYSMENU) ? OBJID_SYSMENU : OBJID_MENU)),
                idx+1, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mnsys.c ===
/**************************** Module Header ********************************\
* Module Name: mnsys.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* System Menu Routines
*
* History:
*  10-10-90 JimA    Cleanup.
*  03-18-91 IanJa   Window revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

void _SetCloseDefault(PMENU pSubMenu);
PWND FindFakeMDIChild(PWND pwndParent);

/***************************************************************************\
* LoadSysDesktopMenu
*
* Loads and locks a desktop system menu. Since we have to call the client
*  to load the menu, while thread 1 is loading the menu, thread 2
*  might grab the critical section, check pdesk->spmenu* and decide that
*  the menu needs to be loaded. Hence we could load the menu more than once.
*  this function handles that case to avoid leaking menus.
*
* 10/24/97 Gerardob     Created
\***************************************************************************/
#ifdef LAME_BUTTON
PMENU xxxLoadSysDesktopMenu (PMENU * ppmenu, UINT uMenuId, PWND pwnd)
#else
PMENU xxxLoadSysDesktopMenu (PMENU * ppmenu, UINT uMenuId)
#endif // LAME_BUTTON
{
    PMENU pmenu;
    /*
     * This should only be called when the menu hasn't been loaded
     */
    UserAssert(*ppmenu == NULL);

#ifdef LAME_BUTTON
    pmenu = xxxLoadSysMenu(uMenuId, pwnd);
#else
    pmenu = xxxLoadSysMenu(uMenuId);
#endif // LAME_BUTTON

    if (pmenu == NULL) {
        return NULL;
    }
    /*
     * If someone beat us loading the menu, destroy this one
     *  and return the one already loaded
     */
    if (*ppmenu != NULL) {
        UserAssert(TestMF(*ppmenu, MFSYSMENU));
        RIPMSG1(RIP_WARNING,
                "LoadSysDesktopMenu: Menu loaded during callback. ppmenu:%#p",
                ppmenu);
        _DestroyMenu(pmenu);
        return *ppmenu;
    }
    /*
     * Mark it, lock it and done
     */
    SetMF(pmenu, MFSYSMENU);
    LockDesktopMenu(ppmenu, pmenu);
    return pmenu;
}
/***************************************************************************\
* Lock/UnlockDesktopMenu
*
* These functions lock/unlock a pmenu into a desktop structure (spmenuSys or
*  spmenuDialogSys) and mark/clear it as such.
* We mark these menus so we can identify them quickly on single bit test.
* We also don't want any one to modify these menus or any submenu.
*
* Note that this assumes that there is only one submenu. If more are added,
*  these functions have to be fixed accordingly.
*
* 08/18/97 Gerardob     Created
\***************************************************************************/
PVOID LockDesktopMenu(PMENU * ppmenu, PMENU pmenu)
{
    PMENU pSubMenu;
    PTHREADINFO ptiDesktop;
    /*
     * We only load desktop sys menus once.
     */
    UserAssert(*ppmenu == NULL);

    if (pmenu == NULL) {
        return NULL;
    }

    SetMF(pmenu, MFDESKTOP);
    /*
     * This is awful but this is the real owner of this object. We used to set it
     *  to NULL but that was forcing us to handle the NULL owner all over the place
     */
    ptiDesktop = PtiCurrent()->rpdesk->rpwinstaParent->pTerm->ptiDesktop;
    HMChangeOwnerProcess(pmenu, ptiDesktop);

    pSubMenu = pmenu->rgItems->spSubMenu;
    UserAssert(pSubMenu != NULL);

    SetMF(pSubMenu, MFDESKTOP);
    HMChangeOwnerProcess(pSubMenu, ptiDesktop);

#if DBG
    {
        /*
         * Assert that there are no other submenus that would need to be
         *  marked as MFDESKTOP.
         */
        PITEM pitem;
        UINT uItems;

        UserAssert(pmenu->cItems == 1);

        pitem = pSubMenu->rgItems;
        uItems = pSubMenu->cItems;
        while (uItems--) {
            UserAssert(pitem->spSubMenu == NULL);
            pitem++;
        }
    }
#endif

    return Lock(ppmenu, pmenu);
}

PVOID UnlockDesktopMenu(PMENU * ppmenu)
{
    UserAssert(*ppmenu != NULL);
    UserAssert(TestMF(*ppmenu, MFDESKTOP));
    ClearMF(*ppmenu, MFDESKTOP);
    UserAssert(TestMF((*ppmenu)->rgItems->spSubMenu, MFDESKTOP));
    ClearMF((*ppmenu)->rgItems->spSubMenu, MFDESKTOP);
    return Unlock(ppmenu);
}
/***************************************************************************\
* GetSysMenuHandle
*
* Returns a handle to the system menu of the given window. NULL if
* the window doesn't have a system menu.
*
* History:
\***************************************************************************/

PMENU xxxGetSysMenuHandle(
    PWND pwnd)
{
    PMENU pMenu;

    CheckLock(pwnd);

    if (TestWF(pwnd, WFSYSMENU)) {
        pMenu = pwnd->spmenuSys;

        /*
         * If the window doesn't have a System Menu, use the default one.
         */
        if (pMenu == NULL) {

            /*
             * Grab the menu from the desktop.  If the desktop menu
             * has not been loaded and this is not a system thread,
             * load it now.  Callbacks cannot be made from a system
             * thread or when a thread is in cleanup.
             */
            pMenu = pwnd->head.rpdesk->spmenuSys;

            /*
             * Do not do callbacks if the thread is exiting.  We ran into this when
             * destroying a thread's window and the window it was promoting to
             * foreground was a hard error popup.
             */
            if (pMenu == NULL && !(PtiCurrent()->TIF_flags & (TIF_SYSTEMTHREAD | TIF_INCLEANUP))) {

#ifdef LAME_BUTTON
                pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuSys, ID_SYSMENU, pwnd);
#else
                pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuSys, ID_SYSMENU);
#endif // LAME_BUTTON
            }
        }
    } else {
        pMenu = NULL;
    }

    return pMenu;
}

/***************************************************************************\
*
*  GetSysMenu()
*
*  Sets up the system menu first, then returns it.
*
\***************************************************************************/
PMENU xxxGetSysMenu(PWND pwnd, BOOL fSubMenu)
{
    PMENU   pMenu;

    CheckLock(pwnd);
    xxxSetSysMenu(pwnd);
    if ((pMenu = xxxGetSysMenuHandle(pwnd)) != NULL) {
        if (fSubMenu)
            pMenu = _GetSubMenu(pMenu, 0);
    }

    return(pMenu);
}

/***************************************************************************\
* IsSmallerThanScreen
*
\***************************************************************************/

BOOL IsSmallerThanScreen(PWND pwnd)
{
    int dxMax, dyMax;
    PMONITOR pMonitor;

    pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
    dxMax = pMonitor->rcWork.right - pMonitor->rcWork.left;
    dyMax = pMonitor->rcWork.bottom - pMonitor->rcWork.top;

    if ((pwnd->rcWindow.right - pwnd->rcWindow.left < dxMax) ||
            (pwnd->rcWindow.bottom - pwnd->rcWindow.top < dyMax)) {
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
* SetSysMenu
*
* !
*
* History:
\***************************************************************************/

void xxxSetSysMenu(
    PWND pwnd)
{
    PMENU pMenu;
    UINT wSize;
    UINT wMinimize;
    UINT wMaximize;
    UINT wMove;
    UINT wRestore;
    UINT wDefault;
    BOOL fFramedDialogBox;
    TL tlmenu;

    CheckLock(pwnd);
    /*
     * Get the handle of the current system menu.
     */
    if ((pMenu = xxxGetSysMenuHandle(pwnd)) != NULL) {

        pMenu = _GetSubMenu(pMenu, 0);
        if (!pMenu)
            return;

        ThreadLockAlways(pMenu, &tlmenu);

        /*
         * System modal window: no size, icon, zoom, or move.
         */

// No system modal windows on NT.
//        wSize = wMaximize = wMinimize = wMove =
//            (UINT)((_GetSysModalWindow() == NULL) || hTaskLockInput ? 0: MFS_GRAYED);
        wSize = wMaximize = wMinimize = wMove =  0;
        wRestore = MFS_GRAYED;

        //
        // Default menu command is close.
        //
        wDefault = SC_CLOSE;

        /*
         * Minimized exceptions: no minimize, restore.
         */

        // we need to reverse these because VB has a "special" window
        // that is both minimized but without a minbox.
        if (TestWF(pwnd, WFMINIMIZED))
        {
            wRestore  = 0;
            wMinimize = MFS_GRAYED;
            wSize     = MFS_GRAYED;
            wDefault  = SC_RESTORE;

            if (IsTrayWindow(pwnd))
              wMove = MFS_GRAYED;
        }
        else if (!TestWF(pwnd, WFMINBOX))
            wMinimize = MFS_GRAYED;

        /*
         * Maximized exceptions: no maximize, restore.
         */
        if (!TestWF(pwnd, WFMAXBOX))
            wMaximize = MFS_GRAYED;
        else if (TestWF(pwnd, WFMAXIMIZED)) {
            wRestore = 0;

            /*
             * If the window is maximized but it isn't larger than the
             * screen, we allow the user to move the window around the
             * desktop (but we don't allow resizing).
             */
            wMove = MFS_GRAYED;
            if (!TestWF(pwnd, WFCHILD)) {
                if (IsSmallerThanScreen(pwnd)) {
                    wMove = 0;
                }
            }

            wSize     = MFS_GRAYED;
            wMaximize = MFS_GRAYED;
        }

        if (!TestWF(pwnd, WFSIZEBOX))
            wSize = MFS_GRAYED;

        /*
         * Are we dealing with a framed dialog box with a sys menu?
         * Dialogs with min/max/size boxes get a regular system menu
         *  (as opposed to the dialog menu)
         */
        fFramedDialogBox =
                (((TestWF(pwnd, WFBORDERMASK) == (BYTE)LOBYTE(WFDLGFRAME))
                        || (TestWF(pwnd, WEFDLGMODALFRAME)))
                    && !TestWF(pwnd, WFSIZEBOX | WFMINBOX | WFMAXBOX));

        if (!fFramedDialogBox) {
            xxxEnableMenuItem(pMenu, (UINT)SC_SIZE, wSize);
            if (!TestWF(pwnd, WEFTOOLWINDOW))
            {
                xxxEnableMenuItem(pMenu, (UINT)SC_MINIMIZE, wMinimize);
                xxxEnableMenuItem(pMenu, (UINT)SC_MAXIMIZE, wMaximize);
                xxxEnableMenuItem(pMenu, (UINT)SC_RESTORE, wRestore);
            }
        }

        xxxEnableMenuItem(pMenu, (UINT)SC_MOVE, wMove);

#if DBG
        /*
         * Assert that nobody managed to change the desktop menus.
         */
        if (TestMF(pMenu, MFSYSMENU)) {
            PITEM pItem = MNLookUpItem(pMenu, SC_CLOSE, FALSE, NULL);
            UserAssert((pItem != NULL) && !TestMFS(pItem, MFS_GRAYED));
        }
#endif

        if (wDefault == SC_CLOSE)
            _SetCloseDefault(pMenu);
        else
            _SetMenuDefaultItem(pMenu, wDefault, MF_BYCOMMAND);

        ThreadUnlock(&tlmenu);
    }
}


/***************************************************************************\
* GetSystemMenu
*
* !
*
* History:
\***************************************************************************/

PMENU xxxGetSystemMenu(
    PWND pwnd,
    BOOL fRevert)
{
    PMENU pmenu;
    CheckLock(pwnd);

    /*
     * Should we start with a fresh copy?
     */

    pmenu = pwnd->spmenuSys;
    if (fRevert) {

        /*
         * Destroy the old system menu.
         */
        if ((pmenu != NULL) && !TestMF(pmenu, MFSYSMENU)) {

            if (UnlockWndMenu(pwnd, &pwnd->spmenuSys)) {
                _DestroyMenu(pmenu);
            }
        }
    } else {

        /*
         * Do we need to load a new system menu?
         */
        if (((pmenu == NULL) || TestMF(pmenu, MFSYSMENU))
                && TestWF(pwnd, WFSYSMENU)) {

            PPOPUPMENU pGlobalPopupMenu;
            UINT uMenuId = (pwnd->spmenuSys == NULL ? ID_SYSMENU : ID_DIALOGSYSMENU);
#ifdef LAME_BUTTON
            pmenu = xxxLoadSysMenu(uMenuId, pwnd);
#else
            pmenu = xxxLoadSysMenu(uMenuId);
#endif // LAME_BUTTON
            if (pmenu == NULL) {
                RIPMSG1(RIP_WARNING, "_GetSystemMenu: xxxLoadSysMenu Failed. pwnd:%#p", pwnd);
            }
            LockWndMenu(pwnd, &pwnd->spmenuSys, pmenu);

            pmenu = pwnd->spmenuSys;
            pGlobalPopupMenu = GetpGlobalPopupMenu(pwnd);
            if ((pGlobalPopupMenu != NULL)
                    && !pGlobalPopupMenu->fIsTrackPopup
                    && (pGlobalPopupMenu->spwndPopupMenu == pwnd)) {

                UserAssert(pGlobalPopupMenu->spwndNotify == pwnd);
                if (pGlobalPopupMenu->fIsSysMenu) {
                    Lock(&pGlobalPopupMenu->spmenu, pmenu);
                } else {
                    Lock(&pGlobalPopupMenu->spmenuAlternate, pmenu);
                }
            }
        }
    }

    /*
     * Return the handle to the system menu.
     */
    if (pwnd->spmenuSys != NULL) {
        /*
         * The app is probably going to modify this menu and then we'll need to
         *  redraw the caption buttons. Hence we need to store the window pointer
         *  in this pmenu or we won't be able to know what window to repaint.
         * The bogus thing is that we cannot call LockWndMenu here because this is
         *  not the actual pmenuSys.
         */
        pmenu = _GetSubMenu(pwnd->spmenuSys, 0);
        if (pmenu) {
            SetMF(pmenu, MFAPPSYSMENU);
            Lock(&pmenu->spwndNotify, pwnd);
        }
        return pmenu;
    }

    return NULL;
}

/***************************************************************************\
* MenuItemState
*
* Sets the menu item flags identified by wMask to the states identified
* by wFlags.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

DWORD MenuItemState(
    PMENU pMenu,
    UINT wCmd,
    DWORD wFlags,
    DWORD wMask,
    PMENU *ppMenu)
{
    PITEM pItem;
    DWORD wRet;

    /*
     * Get a pointer the the menu item
     */
    if ((pItem = MNLookUpItem(pMenu, wCmd, (BOOL) (wFlags & MF_BYPOSITION), ppMenu)) == NULL)
        return (DWORD)-1;

    /*
     * Return previous state
     */
    wRet = pItem->fState & wMask;

    /*
     * Set new state
     */
    pItem->fState ^= ((wRet ^ wFlags) & wMask);

    return wRet;
}


/***************************************************************************\
* EnableMenuItem
*
* Enable, disable or gray a menu item.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

DWORD xxxEnableMenuItem(
    PMENU pMenu,
    UINT wIDEnableItem,
    UINT wEnable)
{
    DWORD dres;
    PMENU pRealMenu;
    PPOPUPMENU ppopup;

    CheckLock(pMenu);

    dres = MenuItemState(pMenu, wIDEnableItem, wEnable,
            MFS_GRAYED, &pRealMenu);

    /*
     * If enabling/disabling a system menu item, redraw the caption buttons
     */
    if (TestMF(pMenu, MFAPPSYSMENU) && (pMenu->spwndNotify != NULL) && (wEnable != dres)) {

        TL tlpwnd;

        switch (wIDEnableItem) {
        case SC_SIZE:
        case SC_MOVE:
        case SC_MINIMIZE:
        case SC_MAXIMIZE:
        case SC_CLOSE:
        case SC_RESTORE:
            ThreadLock(pMenu->spwndNotify, &tlpwnd);
            xxxRedrawTitle(pMenu->spwndNotify, DC_BUTTONS);
            ThreadUnlock(&tlpwnd);
        }
    }

    /* 367162: If the menu is already being displayed we need to redraw it */
    if(pRealMenu && (ppopup = MNGetPopupFromMenu(pRealMenu, NULL))){
        xxxMNUpdateShownMenu(ppopup, NULL, MNUS_DEFAULT);
    }

    return dres;
}


/***************************************************************************\
* CheckMenuItem (API)
*
* Check or un-check a popup menu item.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

DWORD _CheckMenuItem(
    PMENU pMenu,
    UINT wIDCheckItem,
    UINT wCheck)
{
    return MenuItemState(pMenu, wIDCheckItem, wCheck, (UINT)MF_CHECKED, NULL);
}


/***************************************************************************\
*
*  SetMenuDefaultItem() -
*
*  Sets the default item in the menu, by command or by position based on the
*  fByPosition flag.
*  We unset all the other items as the default, then set the given one.
*
*  The return value is TRUE if the given item was set as default, FALSE
*  if not.
*
\***************************************************************************/
BOOL _SetMenuDefaultItem(PMENU pMenu, UINT wID, BOOL fByPosition)
{
    UINT  iItem;
    UINT  cItems;
    PITEM pItem;
    PITEM pItemFound;
    PMENU   pMenuFound;

    //
    // We need to check if wId actually exists on this menu.  0xFFFF means
    // clear all default items.
    //

    if (wID != MFMWFP_NOITEM)
    {
        pItemFound = MNLookUpItem(pMenu, wID, fByPosition, &pMenuFound);

        // item must be on same menu and can't be a separator
        if ((pItemFound == NULL) || (pMenuFound != pMenu) || TestMFT(pItemFound, MFT_SEPARATOR))
            return(FALSE);

    }
    else
        pItemFound = NULL;

    pItem = pMenu->rgItems;
    cItems = pMenu->cItems;

    // Walk the menu list, clearing MFS_DEFAULT from all other items, and
    // setting MFS_DEFAULT on the requested one.
    for (iItem = 0; iItem < cItems; iItem++, pItem++) {
        //
        // Note we don't change the state of lpItemFound if it exists.  This
        // is so that below, where we try to set the default, we can tell
        // if we need to recalculate the underline.
        //

        if (TestMFS(pItem, MFS_DEFAULT) && (pItem != pItemFound))
        {
            //
            // We are changing the default item.  As such, it will be drawn
            // with a different font than the one used to calculate it, if
            // the menu has already been drawn once.  We need to ensure
            // that the underline gets drawn in the right place the next
            // time the menu comes up.  Cause it to recalculate.
            //
            // We do NOT do this if the item
            //      (a) isn't default--otherwise we'll recalculate the
            //  underline for every system menu item every time we go into
            //  menu mode because sysmenu init will call SetMenuDefaultItem.
            //      (b) isn't the item we're going to set as the default.
            //  That way we don't recalculate the underline when the item
            //  isn't changing state.
            //
            ClearMFS(pItem, MFS_DEFAULT);
            pItem->ulX = UNDERLINE_RECALC;
            pItem->ulWidth = 0;
        }
    }

    if (wID != MFMWFP_NOITEM)
    {
        if (!TestMFS(pItemFound, MFS_DEFAULT))
        {
            //
            // We are changing from non-default to default.  Clear out
            // the underline info.  If the menu has never painted, this
            // won't do anything.  But it matters a lot if it has.
            //
            SetMFS(pItemFound, MFS_DEFAULT);
            pItemFound->ulX = UNDERLINE_RECALC;
            pItemFound->ulWidth = 0;
        }
    }

    return(TRUE);
}

// --------------------------------------------------------------------------
//
//  SetCloseDefault()
//
//  Tries to find a close item in the first level of menu items.  Looks
//  for SC_CLOSE, then a couple other IDs.  We'd rather not do lstrstri's
//  for "Close", which is slow.
//
// --------------------------------------------------------------------------
void _SetCloseDefault(PMENU pSubMenu)
{
    if (!_SetMenuDefaultItem(pSubMenu, SC_CLOSE, MF_BYCOMMAND))
    {
        //
        // Let's try a couple other values.
        //      * Project   --  0x7000 less
        //      * FoxPro    --  0xC070
        //
        if (!_SetMenuDefaultItem(pSubMenu, SC_CLOSE - 0x7000, MF_BYCOMMAND))
            _SetMenuDefaultItem(pSubMenu, 0xC070, MF_BYCOMMAND);
    }
}


// --------------------------------------------------------------------------
//
//  FindFakeMDIChild()
//
//  Attempts to find first child visible child window in the zorder that
//  has a system menu or is maxed.  We can't check for an exact system
//  menu match because several apps make their own copy of the sys menu.
//
// --------------------------------------------------------------------------
PWND FindFakeMDIChild(PWND pwnd)
{
    PWND    pwndReturn;

    // Skip invisible windows and their descendants
    if (!TestWF(pwnd, WFVISIBLE))
        return(NULL);

    // Did we hit pay dirt?
    if (TestWF(pwnd, WFCHILD) && (TestWF(pwnd, WFMAXIMIZED) || (pwnd->spmenuSys)))
        return(pwnd);

    // Check our children
    for (pwnd = pwnd->spwndChild; pwnd; pwnd = pwnd->spwndNext)
    {
        pwndReturn = FindFakeMDIChild(pwnd);
        if (pwndReturn)
            return(pwndReturn);
    }

    return(NULL);
}



// --------------------------------------------------------------------------
//
//  SetupFakeMDIAppStuff()
//
//  For apps that mess around with their own MDI (Excel, Word, Project,
//      Quattro Pro), we want to make them a little more Chicago friendly.
//      Namely we:
//
//      (1) Set the default menu item to SC_CLOSE if there isn't one (this
//          won't help FoxPro, but they do so much wrong stuff it doesn't
//          really matter).
//          That way double-clicks will still work.
//
//      (2) Get the right small icon.
//
//  The way we do this is to go find the child window of the menu bar parent
//  who has a system menu that is this one.
//
//  If the system menu is the standard one, then we can't do (2).
//
// --------------------------------------------------------------------------
void SetupFakeMDIAppStuff(PMENU lpMenu, PITEM lpItem)
{
    PMENU   pSubMenu;
    PWND    pwndParent;
    PWND    pwndChild;

    if (!(pSubMenu = lpItem->spSubMenu))
        return;

    pwndParent = lpMenu->spwndNotify;

    //
    // Set up the default menu item.  Project and FoxPro renumber their
    // IDs so we do some special stuff for them, among others.
    //
    if (!TestWF(pwndParent, WFWIN40COMPAT))
    {
        if (_GetMenuDefaultItem(pSubMenu, TRUE, GMDI_USEDISABLED) == -1L)
            _SetCloseDefault(pSubMenu);
    }

    //
    // Don't touch the HIWORD if we don't find an HWND.  That way apps
    // like Excel which have starting-up maxed children can benefit a little.
    // The first time the menu bar is redrawn, the child isn't visible/
    // around (they add the item too early).  But if it redraws later, or
    // you max a child, the icon will kick in.
    //
    if (pwndChild = FindFakeMDIChild(pwndParent)) {
        lpItem->dwItemData = (ULONG_PTR)HWq(pwndChild);
//        lpItem->dwTypeData = MAKELONG(LOWORD(lpItem->dwTypeData), HW16(hwndChild));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mnstate.c ===
/**************************** Module Header ********************************\
* Module Name: mnstate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu State Routines
*
* History:
*  10-10-90 JimA      Cleanup.
*  03-18-91 IanJa     Windowrevalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PMENU xxxGetInitMenuParam(PWND pwndMenu, BOOL *lpfSystem);

/***************************************************************************\
* MNPositionSysMenu
*
* History:
* 4-25-91 Mikehar Port for 3.1 merge
\***************************************************************************/
VOID MNPositionSysMenu(
    PWND pwnd,
    PMENU pmenusys)
{
    RECT rc;
    PITEM pItem;

    if (pmenusys == NULL) {
        RIPERR0(ERROR_INVALID_HANDLE,
                RIP_WARNING,
                "Invalid menu handle pmenusys (NULL) to MNPositionSysMenu");

        return;
    }

    /*
     * Whoever positions the menu becomes the owner
     */
    if (pwnd != pmenusys->spwndNotify) {
        Lock(&pmenusys->spwndNotify, pwnd);
    }

    /*
     * Setup the SysMenu hit rectangle.
     */
    rc.top = rc.left = 0;

    if (TestWF(pwnd, WEFTOOLWINDOW)) {
        rc.right = SYSMET(CXSMSIZE);
        rc.bottom = SYSMET(CYSMSIZE);
    } else {
        rc.right = SYSMET(CXSIZE);
        rc.bottom = SYSMET(CYSIZE);
    }

    if (!TestWF(pwnd, WFMINIMIZED)) {
        int cBorders;

        cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        OffsetRect(&rc, cBorders*SYSMET(CXBORDER), cBorders*SYSMET(CYBORDER));
    }

    /*
     * Offset the System popup menu.
     */
    if (!TestMF(pmenusys, MF_POPUP) && (pmenusys->cItems > 0)) {
        pItem = pmenusys->rgItems;
        if (pItem) {
            pItem->yItem = rc.top;
            pItem->xItem = rc.left;
            pItem->cyItem = rc.bottom - rc.top;
            pItem->cxItem = rc.right - rc.left;
        }
    } else {
        // BOGUS -- MF_POPUP should never be set on a MENU -- only a MENU ITEM
        RIPMSG1(RIP_ERROR, "pmenu %#p has MF_POPUP set or 0 items", pmenusys);
    }
}

/***************************************************************************\
* MNFlushDestroyedPopups
*
* Walk the ppmDelayedFree list freeing those marked as destroyed.
*
* 05-14-96 GerardoB  Created
\***************************************************************************/
VOID MNFlushDestroyedPopups(
    PPOPUPMENU ppopupmenu,
    BOOL fUnlock)
{
    PPOPUPMENU ppmDestroyed, ppmFree;

    UserAssert(IsRootPopupMenu(ppopupmenu));

    /*
     * Walk ppmDelayedFree
     */
    ppmDestroyed = ppopupmenu;
    while (ppmDestroyed->ppmDelayedFree != NULL) {
        /*
         * If it's marked as destroyed, unlink it and free it
         */
        if (ppmDestroyed->ppmDelayedFree->fDestroyed) {
            ppmFree = ppmDestroyed->ppmDelayedFree;
            ppmDestroyed->ppmDelayedFree = ppmFree->ppmDelayedFree;
            UserAssert(ppmFree != ppmFree->ppopupmenuRoot);
            MNFreePopup(ppmFree);
        } else {
            /*
             * fUnlock is TRUE if the root popup is being destroyed; if
             * so, reset fDelayedFree and unlink it.
             */
            if (fUnlock) {
                /*
                 * This means that the root popup is going away before
                 * some of the hierarchical popups have been destroyed.
                 *
                 * This can happen if someone destroys one of the menu
                 * windows breaking the spwndNextPopup chain.
                 */
                ppmDestroyed->ppmDelayedFree->fDelayedFree = FALSE;

                /*
                 * Stop here so we can figure how this happened.
                 */
                UserAssert(ppmDestroyed->ppmDelayedFree->fDelayedFree);
                ppmDestroyed->ppmDelayedFree = ppmDestroyed->ppmDelayedFree->ppmDelayedFree;
            } else {
                /*
                 * Not fDestroyed so move to the next one.
                 */
                ppmDestroyed = ppmDestroyed->ppmDelayedFree;
            }
        }
    }
}

/***************************************************************************\
* MNAllocPopup
*
\***************************************************************************/
PPOPUPMENU MNAllocPopup(
    BOOL fForceAlloc)
{
    PPOPUPMENU ppm;

    if (!fForceAlloc && !TEST_PUDF(PUDF_POPUPINUSE)) {
        SET_PUDF(PUDF_POPUPINUSE);
        ppm = &gpopupMenu;
    } else {
        ppm = (PPOPUPMENU)UserAllocPoolWithQuota(sizeof(POPUPMENU), TAG_POPUPMENU);
    }

    if (ppm) {
        RtlZeroMemory(ppm, sizeof(POPUPMENU));
    }

    return ppm;
}

/***************************************************************************\
* MNFreePopup
*
\***************************************************************************/
VOID MNFreePopup(
    PPOPUPMENU ppopupmenu)
{

    Validateppopupmenu(ppopupmenu);

#if DBG
    if (ppopupmenu->fDesktopMenu && ppopupmenu->spwndPopupMenu) {
        PDESKTOP pdesk = PtiCurrent()->rpdesk;
        UserAssert(pdesk->dwDTFlags & DF_MENUINUSE);
        UserAssert(((PMENUWND)pdesk->spwndMenu)->ppopupmenu == ppopupmenu);
    }
#endif

    if (IsRootPopupMenu(ppopupmenu)) {
        MNFlushDestroyedPopups(ppopupmenu, TRUE);
    }

    if (!ppopupmenu->fDesktopMenu &&
        ppopupmenu->spwndPopupMenu != NULL &&
        GETFNID(ppopupmenu->spwndPopupMenu) == FNID_MENU &&
        ppopupmenu != &gpopupMenu) {
        ((PMENUWND)ppopupmenu->spwndPopupMenu)->ppopupmenu = NULL;
    }

    Unlock(&ppopupmenu->spwndPopupMenu);

    /*
     * If spwndNextPopup is not NULL, we're breaking the chain and spwndNext
     * won't get closed. I won't remove the unlock since it has always been
     * there.
     */
    UserAssert(ppopupmenu->spwndNextPopup == NULL);
    Unlock(&ppopupmenu->spwndNextPopup);

    Unlock(&ppopupmenu->spwndPrevPopup);
    UnlockPopupMenu(ppopupmenu, &ppopupmenu->spmenu);
    UnlockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate);
    Unlock(&ppopupmenu->spwndNotify);
    Unlock(&ppopupmenu->spwndActivePopup);

#if DBG
   if (!ppopupmenu->fDesktopMenu) {
       ppopupmenu->fFreed = TRUE;
   }
#endif

    if (ppopupmenu->fDesktopMenu) {
        PtiCurrent()->rpdesk->dwDTFlags &= ~DF_MENUINUSE;
        /*
         * The desktop menu window points to this popup so don't leave bogus
         * stuff in it.
         */
        ppopupmenu->ppopupmenuRoot = NULL;
    } else if (ppopupmenu == &gpopupMenu) {
        UserAssert(TEST_PUDF(PUDF_POPUPINUSE));
        CLEAR_PUDF(PUDF_POPUPINUSE);
    } else {
        UserFreePool(ppopupmenu);
    }
}

/***************************************************************************\
* MNEndMenuStateNotify
*
* spwndNotify might have been created by a thread other than the one
* the menu mode is running on. If this is the case, this function
* NULLs out pMenuState for the thread that owns spwndNotify.
*
* It returns TRUE if the menu state owner doesn't own the notification
* window (multiple threads involved).
*
* 05-21-96 GerardoB Created
\***************************************************************************/
BOOL MNEndMenuStateNotify(
    PMENUSTATE pMenuState)
{
    PTHREADINFO ptiNotify;

    if (pMenuState->pGlobalPopupMenu->spwndNotify != NULL) {
        ptiNotify = GETPTI(pMenuState->pGlobalPopupMenu->spwndNotify);
        if (ptiNotify != pMenuState->ptiMenuStateOwner) {
            /*
             * Later5.0 GerardoB. xxxMNStartMenuState no longer allows this.
             *  This is dead code that I'll remove eventually
             */
            UserAssert(ptiNotify == pMenuState->ptiMenuStateOwner);

            UserAssert(ptiNotify->pMenuState == pMenuState);
            UserAssert(pMenuState->pmnsPrev == NULL);
            ptiNotify->pMenuState = NULL;
            return TRUE;
        }
    }

    return FALSE;
}

/***************************************************************************\
* xxxMNEndMenuState
*
* This funtion must be called to clean up pMenuState after getting out
* of menu mode. It must be called by the same thread that initialized
* pMenuState either manually or by calling xxxMNStartMenuState.
*
* 05-20-96 GerardoB Created
\***************************************************************************/
VOID xxxMNEndMenuState(
    BOOL fFreePopup)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PMENUSTATE pMenuState;
    pMenuState = ptiCurrent->pMenuState;
    UserAssert(ptiCurrent->pMenuState != NULL);
    UserAssert(ptiCurrent == pMenuState->ptiMenuStateOwner);

    /*
     * If the menu is locked, someone doesn't want it to go just yet.
     */
    if (pMenuState->dwLockCount != 0) {
        RIPMSG1(RIP_WARNING, "xxxMNEndMenuState Locked:%#p", pMenuState);
        return;
    }

    MNEndMenuStateNotify(pMenuState);

    /*
     * pMenuState->pGlobalPopupMenu could be NULL if xxxMNAllocMenuState failed
     */
    if (pMenuState->pGlobalPopupMenu != NULL) {
        if (fFreePopup) {
            UserAssert(pMenuState->pGlobalPopupMenu->fIsMenuBar || pMenuState->pGlobalPopupMenu->fDestroyed);

            MNFreePopup(pMenuState->pGlobalPopupMenu);
        } else {
            /*
             * This means that we're ending the menustate but the popup menu
             *  window is still around. This can happen when called from
             *  xxxDestroyThreadInfo.
             */
            UserAssert(pMenuState->pGlobalPopupMenu->fIsTrackPopup);
            pMenuState->pGlobalPopupMenu->fDelayedFree = FALSE;
        }
    }

    /*
     * Unlock MFMWFP windows.
     */
    UnlockMFMWFPWindow(&pMenuState->uButtonDownHitArea);
    UnlockMFMWFPWindow(&pMenuState->uDraggingHitArea);

    /*
     * Restore the previous state, if any
     */
    ptiCurrent->pMenuState = pMenuState->pmnsPrev;

   /*
    * This (modal) menu mode is off
    */
   if (!pMenuState->fModelessMenu) {
       DecSFWLockCount();
       DBGDecModalMenuCount();
   }

    if (pMenuState->hbmAni != NULL) {
        MNDestroyAnimationBitmap(pMenuState);
    }

    /*
     * Free the menu state
     */
    if (pMenuState == &gMenuState) {
        UserAssert(TEST_PUDF(PUDF_MENUSTATEINUSE));
        CLEAR_PUDF(PUDF_MENUSTATEINUSE);
        GreSetDCOwner(gMenuState.hdcAni, OBJECT_OWNER_PUBLIC);
    } else {
        if (pMenuState->hdcAni != NULL) {
            GreDeleteDC(pMenuState->hdcAni);
        }
        UserFreePool(pMenuState);
    }

    /*
     * If returning to a modeless menu, make sure have activation
     * If returning to a modal menu, make sure we have capture
     */
   if (ptiCurrent->pMenuState != NULL) {
       if (ptiCurrent->pMenuState->fModelessMenu) {
           xxxActivateThisWindow(ptiCurrent->pMenuState->pGlobalPopupMenu->spwndActivePopup,
                                 0, 0);
       } else {
           xxxMNSetCapture(ptiCurrent->pMenuState->pGlobalPopupMenu);
       }
   }

#if DBG
    /*
     * If this thread is not in menu mode anymore, it must not be using
     * the desktop menu.
     */
    if ((ptiCurrent->pMenuState == NULL) && (ptiCurrent->rpdesk->spwndMenu != NULL)) {
        UserAssert(ptiCurrent != GETPTI(ptiCurrent->rpdesk->spwndMenu));
    }

#if 0
    /*
     * Now that we fake the code into thinking that the desktop menu's always
     * in use, this assertion doesn't hold.
     *
     * jasonsch - 2/23/01
     */
    /*
     * If someone is using the menu window, it must be in menu mode.
     */
    if (ptiCurrent->rpdesk->dwDTFlags & DF_MENUINUSE) {
        UserAssert(GetpMenuState(ptiCurrent->rpdesk->spwndMenu) != NULL);
    }
#endif // 0

    /*
     * No pti should point to this pMenuState anymore.
     * If guModalMenuStateCount is zero, all pMenuState must be NULL or
     * modeless.
     */
{
    PLIST_ENTRY pHead, pEntry;
    PTHREADINFO ptiT;

    pHead = &(ptiCurrent->rpdesk->PtiList);
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
       ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
       UserAssert(ptiT->pMenuState != pMenuState);
       if (guModalMenuStateCount == 0) {
           UserAssert(ptiT->pMenuState == NULL || ptiT->pMenuState->fModelessMenu);
       }
   }
}
#endif // DBG
}

/***************************************************************************\
* MNCreateAnimationBitmap
*
\***************************************************************************/
BOOL MNCreateAnimationBitmap(
    PMENUSTATE pMenuState,
    UINT cx,
    UINT cy)
{
    HBITMAP hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cx, cy);
    if (hbm == NULL) {
        RIPMSG0(RIP_WARNING, "MNSetupAnimationBitmap: Failed to create hbmAni");
        return FALSE;
    }

#if DBG
    if (pMenuState->hdcAni == NULL) {
        RIPMSG0(RIP_WARNING, "MNCreateAnimationBitmap: hdcAni is NULL");
    }
    if (pMenuState->hbmAni != NULL) {
        RIPMSG0(RIP_WARNING, "MNCreateAnimationBitmap: hbmAni already exists");
    }
#endif // DBG

    GreSelectBitmap(pMenuState->hdcAni, hbm);
    pMenuState->hbmAni = hbm;
    return TRUE;
}

/***************************************************************************\
* MNDestroyAnimationBitmap
*
\***************************************************************************/
VOID MNDestroyAnimationBitmap(
    PMENUSTATE pMenuState)
{
    GreSelectBitmap(pMenuState->hdcAni, GreGetStockObject(PRIV_STOCK_BITMAP));
    UserVerify(GreDeleteObject(pMenuState->hbmAni));
    pMenuState->hbmAni = NULL;
}

/***************************************************************************\
* MNSetupAnimationDC
*
* 9/20/96 GerardoB      Created
\***************************************************************************/
BOOL MNSetupAnimationDC(
    PMENUSTATE pMenuState)
{
    pMenuState->hdcAni = GreCreateCompatibleDC(gpDispInfo->hdcScreen);
    if (pMenuState->hdcAni == NULL) {
        RIPMSG0(RIP_WARNING, "MNSetupAnimationDC: Failed to create hdcAnimate");
        UserAssert(pMenuState != &gMenuState);
        return FALSE;
    }
    GreSelectFont(pMenuState->hdcAni, ghMenuFont);
    return TRUE;
}

/***************************************************************************\
* xxxUnlockMenuState
*
* 11/24/96 GerardoB      Created
\***************************************************************************/
BOOL xxxUnlockMenuState(
    PMENUSTATE pMenuState)
{
    UserAssert(pMenuState->dwLockCount != 0);

    (pMenuState->dwLockCount)--;
    if ((pMenuState->dwLockCount == 0) && ExitMenuLoop(pMenuState, pMenuState->pGlobalPopupMenu)) {
        xxxMNEndMenuState(TRUE);
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* xxxMNAllocMenuState
*
* Allocates and initializes a pMenuState.
*
* 5-21-96 GerardoB      Created
\***************************************************************************/
PMENUSTATE xxxMNAllocMenuState(
    PTHREADINFO ptiCurrent,
    PTHREADINFO ptiNotify,
    PPOPUPMENU ppopupmenuRoot)
{
    BOOL fAllocate;
    PMENUSTATE pMenuState;

    UserAssert(PtiCurrent() == ptiCurrent);
    UserAssert(ptiCurrent->rpdesk == ptiNotify->rpdesk);

    /*
     * If gMenuState is already taken, allocate one.
     */
    fAllocate = TEST_PUDF(PUDF_MENUSTATEINUSE);
    if (fAllocate) {
        pMenuState = (PMENUSTATE)UserAllocPoolWithQuota(sizeof(MENUSTATE), TAG_MENUSTATE);
        if (pMenuState == NULL) {
            return NULL;
        }
    } else {
        /*
         * Use chache global which already has the animation DC setup
         */
        SET_PUDF(PUDF_MENUSTATEINUSE);
        pMenuState = &gMenuState;
        UserAssert(gMenuState.hdcAni != NULL);
        GreSetDCOwner(gMenuState.hdcAni, OBJECT_OWNER_CURRENT);
    }

    /*
     * Prevent anyone from changing the foreground while this menu is active
     */
    IncSFWLockCount();
    DBGIncModalMenuCount();

    /*
     * Initialize pMenuState.
     * Animation DC stuff is already setup so don't zero init it.
     */
    RtlZeroMemory(pMenuState, sizeof(MENUSTATE) - sizeof(MENUANIDC));
    pMenuState->pGlobalPopupMenu = ppopupmenuRoot;
    pMenuState->ptiMenuStateOwner = ptiCurrent;

    /*
     * Save previous state, if any. Then set new state.
     */
    pMenuState->pmnsPrev = ptiCurrent->pMenuState;
    ptiCurrent->pMenuState = pMenuState;

    if (ptiNotify != ptiCurrent) {
        UserAssert(ptiNotify->pMenuState == NULL);
        ptiNotify->pMenuState = pMenuState;
    }

    /*
     * If the menustate was allocated, set up animation stuff.
     * This is done here because in case of failure, MNEndMenuState
     * will find ptiCurrent->pMenuState properly.
     */
    if (fAllocate) {
        RtlZeroMemory((PBYTE)pMenuState + sizeof(MENUSTATE) -
                sizeof(MENUANIDC), sizeof(MENUANIDC));
        if (!MNSetupAnimationDC(pMenuState)) {
            xxxMNEndMenuState(TRUE);
            return NULL;
        }
    }

    return pMenuState;
}

/***************************************************************************\
* xxxMNStartMenuState
*
* This function is called when the menu bar is about to be activated (the
*  app's main menu). It makes sure that the threads involved are not in
*  menu mode already, finds the owner/notification window, initializes
*  pMenuState and sends the WM_ENTERMENULOOP message.
* It successful, it returns a pointer to a pMenuState. If so, the caller
*  must call MNEndMenuState when done.
*
* History:
* 4-25-91 Mikehar       Port for 3.1 merge
* 5-20-96 GerardoB      Renamed and changed (Old name: xxxMNGetPopup)
\***************************************************************************/
PMENUSTATE xxxMNStartMenuState(
    PWND pwnd,
    DWORD cmd,
    LPARAM lParam)
{
    PPOPUPMENU ppopupmenu;
    PTHREADINFO ptiCurrent, ptiNotify;
    PMENUSTATE pMenuState;
    TL tlpwnd;
    PWND pwndT;

    CheckLock(pwnd);

    /*
     * Bail if the current thread is already in menu mode
     */
    ptiCurrent = PtiCurrent();
    if (ptiCurrent->pMenuState != NULL) {
        return NULL;
    }

    /*
     * If pwnd is not owned by ptiCurrent, the _PostMessage call below might
     *  send us in a loop
     */
    UserAssert(ptiCurrent == GETPTI(pwnd));

    /*
     * If this is not a child window, use the active window on its queue
     */
    if (!TestwndChild(pwnd)) {
        pwnd = GETPTI(pwnd)->pq->spwndActive;
    } else {
        /*
         * Search up the parents for a window with a System Menu.
         */
        while (TestwndChild(pwnd)) {
            if (TestWF(pwnd, WFSYSMENU)) {
                break;
            }
            pwnd = pwnd->spwndParent;
        }
    }

    if (pwnd == NULL) {
        return NULL;
    }

    if (!TestwndChild(pwnd) && (pwnd->spmenu != NULL)) {
        goto hasmenu;
    }

    if (!TestWF(pwnd, WFSYSMENU)) {
        return NULL;
    }

hasmenu:

    /*
     * If the owner/notification window was created by another thread,
     * make sure that it's not in menu mode already
     * This can happen if PtiCurrent() is attached to other threads, one of
     * which created pwnd.
     */
    ptiNotify = GETPTI(pwnd);
    if (ptiNotify->pMenuState != NULL) {
        return NULL;
    }

    /*
     * If the notification window is owned by another thread,
     * then the menu loop wouldn't get any keyboard or mouse
     * messages because we set capture to the notification window.
     * So we pass the WM_SYSCOMMAND to that thread and bail
     */
    if (ptiNotify != ptiCurrent) {
        RIPMSG2(RIP_WARNING, "Passing WM_SYSCOMMAND SC_*MENU from thread %#p to %#p", ptiCurrent, ptiNotify);
        _PostMessage(pwnd, WM_SYSCOMMAND, cmd, lParam);
        return NULL;
    }

    /*
     * Allocate ppoupmenu and pMenuState.
     */
    ppopupmenu = MNAllocPopup(FALSE);
    if (ppopupmenu == NULL) {
        return NULL;
    }

    pMenuState = xxxMNAllocMenuState(ptiCurrent, ptiNotify, ppopupmenu);
    if (pMenuState == NULL) {
        MNFreePopup(ppopupmenu);
        return NULL;
    }

    ppopupmenu->fIsMenuBar = TRUE;
    ppopupmenu->fHasMenuBar = TRUE;
    Lock(&(ppopupmenu->spwndNotify), pwnd);
    ppopupmenu->posSelectedItem = MFMWFP_NOITEM;
    Lock(&(ppopupmenu->spwndPopupMenu), pwnd);
    ppopupmenu->ppopupmenuRoot = ppopupmenu;

    pwndT = pwnd;
    while(TestwndChild(pwndT))
        pwndT = pwndT->spwndParent;

    if (pwndT->spmenu) {
        ppopupmenu->fRtoL = TestMF(pwndT->spmenu, MFRTL) ?TRUE:FALSE;
    } else {
        //
        // No way to know, no menu, but there is a system menu. Thus arrow
        // keys are really not important. However lets take the next best
        // thing just to be safe.
        //
        ppopupmenu->fRtoL = TestWF(pwnd, WEFRTLREADING) ?TRUE :FALSE;
    }

    /*
     * Notify the app we are entering menu mode. wParam is always 0 since this
     * procedure will only be called for menu bar menus not TrackPopupMenu
     * menus.
     */
    ThreadLockAlways(pwnd, &tlpwnd);
    xxxSendMessage(pwnd, WM_ENTERMENULOOP, 0, 0);
    ThreadUnlock(&tlpwnd);

    return pMenuState;
}


/***************************************************************************\
* xxxMNStartMenu
*
* Note that this function calls back many times so we might be forced
* out of menu mode at any time. We don't want to check this after
* each callback so we lock what we need and go on. Be careful.
*
* History:
* 4-25-91 Mikehar Port for 3.1 merge
\***************************************************************************/
BOOL xxxMNStartMenu(
    PPOPUPMENU ppopupmenu,
    int mn)
{
    PWND pwndMenu;
    PMENU pMenu;
    PMENUSTATE pMenuState;
    TL tlpwndMenu;
    TL tlpMenu;

    UserAssert(IsRootPopupMenu(ppopupmenu));

    if (ppopupmenu->fDestroyed) {
        return FALSE;
    }

    pwndMenu = ppopupmenu->spwndNotify;
    ThreadLock(pwndMenu, &tlpwndMenu);

    pMenuState = GetpMenuState(pwndMenu);
    if (pMenuState == NULL) {
        RIPMSG0(RIP_ERROR, "xxxMNStartMenu: pMenuState == NULL");
        ThreadUnlock(&tlpwndMenu);
        return FALSE;
    }
    pMenuState->mnFocus = mn;
    pMenuState->fMenuStarted = TRUE;
    pMenuState->fButtonDown =
    pMenuState->fButtonAlwaysDown = ((_GetKeyState(VK_LBUTTON) & 0x8000) != 0);

    xxxMNSetCapture(ppopupmenu);

    xxxSendMessage(pwndMenu, WM_SETCURSOR, (WPARAM)HWq(pwndMenu),
            MAKELONG(MSGF_MENU, 0));

    if (ppopupmenu->fIsMenuBar) {
        BOOL fSystemMenu;

        pMenu = xxxGetInitMenuParam(pwndMenu, &fSystemMenu);

        if (pMenu == NULL) {
            pMenuState->fMenuStarted = FALSE;
            xxxMNReleaseCapture();
            ThreadUnlock(&tlpwndMenu);
            return FALSE;
        }

        LockPopupMenu(ppopupmenu, &ppopupmenu->spmenu, pMenu);

        ppopupmenu->fIsSysMenu = (fSystemMenu != 0);
        if (!fSystemMenu) {
            pMenu = xxxGetSysMenu(pwndMenu, FALSE);
            LockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate, pMenu);
        }
    }

    pMenuState->fIsSysMenu = (ppopupmenu->fIsSysMenu != 0);

    if (!ppopupmenu->fNoNotify) {

        if (ppopupmenu->fIsTrackPopup && ppopupmenu->fIsSysMenu) {
            pMenu = xxxGetInitMenuParam(pwndMenu, NULL);
        } else {
            pMenu = ppopupmenu->spmenu;
        }

        xxxSendMessage(pwndMenu, WM_INITMENU, (WPARAM)PtoH(pMenu), 0L);
    }

    if (!ppopupmenu->fIsTrackPopup) {
        if (ppopupmenu->fIsSysMenu) {
            MNPositionSysMenu(pwndMenu, ppopupmenu->spmenu);
        } else if (ppopupmenu->fIsMenuBar) {
            ThreadLockMenuNoModify(ppopupmenu->spmenu, &tlpMenu);
            xxxMNRecomputeBarIfNeeded(pwndMenu, ppopupmenu->spmenu);
            ThreadUnlockMenuNoModify(&tlpMenu);
            MNPositionSysMenu(pwndMenu, ppopupmenu->spmenuAlternate);
        }
    }

    /*
     * If returning TRUE, set menu style in pMenuState
     */
    if (!ppopupmenu->fDestroyed) {
        if (TestMF(ppopupmenu->spmenu, MNS_MODELESS)) {
            pMenuState->fModelessMenu = TRUE;
        }

        if (TestMF(ppopupmenu->spmenu, MNS_DRAGDROP)) {
            if (NT_SUCCESS(xxxClientLoadOLE())) {
                pMenuState->fDragAndDrop = TRUE;
            }
        }

        if (TestMF(ppopupmenu->spmenu, MNS_AUTODISMISS)) {
            pMenuState->fAutoDismiss = TRUE;
        }

        if (TestMF(ppopupmenu->spmenu, MNS_NOTIFYBYPOS)) {
            pMenuState->fNotifyByPos = TRUE;
        }

    }

    /*
     * Bogus!  We don't always know that this is the system menu.  We
     * will frequently pass on an OBJID_MENU even when you hit Alt+Space.
     *
     * Hence, MNSwitchToAlternate will send a EVENT_SYSTEM_MENUEND for the
     * menu bar and an EVENT_SYSTEM_MENUSTART for the sysmenu when we "switch".
     */
    xxxWindowEvent(EVENT_SYSTEM_MENUSTART, pwndMenu,
            (ppopupmenu->fIsSysMenu ? OBJID_SYSMENU : (ppopupmenu->fIsMenuBar ? OBJID_MENU : OBJID_WINDOW)),
            INDEXID_CONTAINER, 0);

    ThreadUnlock(&tlpwndMenu);

    return !ppopupmenu->fDestroyed;
}

/***************************************************************************\
* xxxGetInitMenuParam
*
* Gets the HMENU sent as the wParam of WM_INITMENU, and for menu bars, is
* the actual menu to be interacted with.
*
* History:
* ????
\***************************************************************************/
PMENU xxxGetInitMenuParam(
    PWND pwndMenu,
    BOOL *lpfSystem)
{
    //
    // Find out what menu we should be sending in WM_INITMENU:
    //      If minimized/child/empty menubar, use system menu
    //
    CheckLock(pwndMenu);

    if (TestWF(pwndMenu, WFMINIMIZED) ||
        TestwndChild(pwndMenu) ||
        (pwndMenu->spmenu == NULL) ||
        !pwndMenu->spmenu->cItems) {
        if (lpfSystem != NULL)
            *lpfSystem = TRUE;

        return xxxGetSysMenu(pwndMenu, FALSE);
    } else {
        if (lpfSystem != NULL) {
            *lpfSystem = FALSE;
        }

        return pwndMenu->spmenu;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\movesize.c ===
/****************************************************************************\
* Module Name: movesize.c  (formerly wmmove.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains Window Moving and Sizing Routines
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
* 13-Feb-1991 IanJa     HWND revalidation added
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define DRAG_START    0
#define DRAG_MOVE     1
#define DRAG_END      2

/****************************************************************************\
* These values are indexes that represent rect sides. These indexes are
* used as indexes into rgimpiwx and rgimpiwy (which are indexes into the
* the rect structure) which tell the move code where to store the new x & y
* coordinates. Notice that when two of these values that represent sides
* are added together, we get a unique list of contiguous values starting at
* 1 that represent all the ways we can size a rect. That also leaves 0 free
* a initialization value.
*
* The reason we need rgimpimpiw is for the keyboard interface - we
* incrementally decide what our 'move command' is. With the mouse interface
* we know immediately because we registered a mouse hit on the segment(s)
* we're moving.
*
*       4           5
*        \ ___3___ /
*         |       |
*         1       2
*         |_______|
*        /    6    \
*       7           8
*
\****************************************************************************/

static const int rgimpimpiw[] = {1, 3, 2, 6};
static const int rgimpiwx[]   = {0,  0,  2, -1, 0, 2, -1, 0, 2, 0};
static const int rgimpiwy[]   = {0, -1, -1,  1, 1, 1,  3, 3, 3, 1};
static const int rgcmdmpix[]  = {0, 1, 2, 0, 1, 2, 0, 1, 2, 1};
static const int rgcmdmpiy[]  = {0, 0, 0, 3, 3, 3, 6, 6, 6, 3};

/***************************************************************************\
* GetMonitorMaxArea
*
* Return the rectangle on a monitor which should be used to
* maximize to, the work rect or the monitor rect.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

void
GetMonitorMaxArea(PWND pwnd, PMONITOR pMonitor, LPRECT * pprc)
{
    if (    !TestWF(pwnd, WFMAXBOX) ||
            !TestWF(pwnd, WFCPRESENT) ||
            pMonitor->cFullScreen) {

        *pprc = &pMonitor->rcMonitor;
    } else {
        *pprc = &pMonitor->rcWork;
    }
}


/***************************************************************************\
* SizeRect
*
* Match corner or side (defined by cmd) to pt.
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3 asm code
\***************************************************************************/

BOOL SizeRect(
    PMOVESIZEDATA pmsd,
    DWORD         pt)
{
    int  ax;
    int  dx;
    int  index;
    int  indexOpp;
    PINT psideDragCursor = ((PINT)(&pmsd->rcDragCursor));
    PINT psideParent     = ((PINT)(&pmsd->rcParent));


    /*
     * DO HORIZONTAL
     */

    /*
     * We know what part of the rect we're moving based on
     * what's in cmd.  We use cmd as an index into rgimpiw? which
     * tells us what part of the rect we're dragging.
     */

    /*
     * Get the approriate array entry.
     */
    index = (int)rgimpiwx[pmsd->cmd];   // AX

    /*
     * Is it one of the entries we don't map (i.e.  -1)?
     */
    if (index < 0)
        goto mrLoopBottom;

    psideDragCursor[index] = LOSHORT(pt);

    indexOpp = index ^ 0x2;

    /*
     * Now check to see if we're below the min or above the max. Get the width
     * of the rect in this direction (either x or y) and see if it's bad. If
     * so, map the side we're moving to the min or max.
     */
    ax = psideDragCursor[index] - psideDragCursor[indexOpp];

    if (indexOpp & 0x2)
        ax = -ax;

    if ((ax >= (dx = pmsd->ptMinTrack.x)) &&
        (ax <= (dx = pmsd->ptMaxTrack.x))) {

        /*
         * Only test for the parent's client boundary if we are a child
         * window...Otherwise we are bound to the client of the desktop
         * which causes strange drag problems.
         */
        if (!TestWF(pmsd->spwnd,WFCHILD))
            goto mrLoopBottom;

        /*
         * Now see if we're extending beyond our parent's client rect.
         * Compute the size the rect can be expanded to in this direction.
         */
        dx = abs(psideParent[index] - psideDragCursor[indexOpp]);

        if (ax <= dx)
            goto mrLoopBottom;

        /*
         * The width is invalid - map the side we're moving to the other
         * side +/- the width.
         */
    }

    if (indexOpp & 0x2)
        dx = -dx;

    psideDragCursor[index] = dx + psideDragCursor[indexOpp];

mrLoopBottom:

    /*
     * DO VERTICAL
     */

    /*
     * We know what part of the rect we're moving based on
     * what's in cmd.  We use cmd as an index into rgimpiw? which
     * tells us what part of the rect we're dragging.
     */

    /*
     * Get the approriate array entry.
     */
    index = (int)rgimpiwy[pmsd->cmd];   // AX

    /*
     * Is it one of the entries we don't map (i.e.  -1)?
     */
    if (index < 0)
        return TRUE;

    psideDragCursor[index] = HISHORT(pt);

    indexOpp = index ^ 0x2;

    /*
     * Now check to see if we're below the min or above the max. Get the width
     * of the rect in this direction (either x or y) and see if it's bad. If
     * so, map the side we're moving to the min or max.
     */
    ax = psideDragCursor[index] - psideDragCursor[indexOpp];

    if (indexOpp & 0x2)
        ax = -ax;

    if ((ax >= (dx = pmsd->ptMinTrack.y)) &&
        (ax <= (dx = pmsd->ptMaxTrack.y))) {

        /*
         * Only test for the parent's client boundary if we are a child
         * window...Otherwise we are bound to the client of the desktop
         * which causes strange drag problems.
         */
        if (!TestWF(pmsd->spwnd,WFCHILD))
            return TRUE;

        /*
         * Now see if we're extending beyond our parent's client rect.
         * Compute the size the rect can be expanded to in this direction.
         */
        dx = abs(psideParent[index] - psideDragCursor[indexOpp]);

        if (ax <= dx)
            return TRUE;

        /*
         * The width is invalid - map the side we're moving to the other
         * side +/- the width.
         */
    }

    if (indexOpp & 0x2)
        dx = -dx;

    psideDragCursor[index] = dx + psideDragCursor[indexOpp];

    return TRUE;
}

/***************************************************************************\
* MoveRect
*
* Move the rect to pt, make sure we're not going out of the parent rect.
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3 asm code
\***************************************************************************/

BOOL MoveRect(
    PMOVESIZEDATA pmsd,
    DWORD         pt)
{
    RECT rcAnd;

    OffsetRect(&pmsd->rcDragCursor,
               LOSHORT(pt) - pmsd->rcDragCursor.left,
               HISHORT(pt) - pmsd->rcDragCursor.top);

    /*
     * Don't move the entire rectangle off the screen.
     * However, if the window started offscreen completely, let it move.
     */
    if (pmsd->fOffScreen)
        return TRUE;

    if (pmsd->spwnd->spwndParent->hrgnClip) {
        return GreRectInRegion(
                pmsd->spwnd->spwndParent->hrgnClip, &pmsd->rcDragCursor);
    }

    return IntersectRect(&rcAnd, &pmsd->rcDragCursor, &pmsd->rcParent);
}

/***************************************************************************\
* xxxTM_MoveDragRect
*
* History:
* 12-Nov-1990 MikeHar      Ported from win3
\***************************************************************************/

VOID xxxTM_MoveDragRect(
    PMOVESIZEDATA pmsd,
    LPARAM        lParam)
{
    UINT msg;
    RECT rc;

    UserAssert(pmsd == PtiCurrent()->pmsd);
    UserAssert(pmsd->cmd != WMSZ_KEYSIZE);

    CopyRect(&pmsd->rcDragCursor, &pmsd->rcDrag);

    if (pmsd->cmd == WMSZ_MOVE) {

        if (!MoveRect(pmsd, (DWORD)lParam))
            return;

        msg = WM_MOVING;

    } else {

        if (!SizeRect(pmsd, (DWORD)lParam))
            return;

        msg = WM_SIZING;
    }

    CopyRect(&rc, &pmsd->rcDragCursor);
    xxxSendMessage(pmsd->spwnd, msg, pmsd->cmd, (LPARAM)(LPRECT)&rc);
    xxxDrawDragRect(pmsd, &rc, DRAG_MOVE);

    if (pmsd->cmd == WMSZ_MOVE) {

        /*
         * Keep dxMouse & dxMouse relative to the offset from the top left
         * corner, the rectangle could've changed on WM_MOVING
         */
        pmsd->dxMouse += (rc.left - LOSHORT(lParam));
        pmsd->dyMouse += (rc.top - HISHORT(lParam));
    }
}

/***************************************************************************\
* CkptRestore
*
* Positions are always relative to the origin of the monitor's working
* area that the window is on, except for rcNormal.  That way, windows will
* maximize to the working area of the monitor they find themselves on, and
* not to a random place.
*
* This allows us to keep information in a reasonably independent fashion,
* information that doesn't go out of date when a window moves or the
* monitors are configured differently.
*
* rcNormal is different because that does need to be absolute.  It's where
* the window should come up the first time in a normal state.
*
* History:
* 14-Nov-1990 DarrinM   Ported from Win 3.0 sources.
\***************************************************************************/

PCHECKPOINT CkptRestore(
    PWND    pwnd,
    LPCRECT lprcWindow)
{
    PCHECKPOINT pcp;

    /*
     * Don't return or create a checkpoint if the window is dying.
     */
    if (HMIsMarkDestroy(pwnd))
        return NULL;

    /*
     * If it doesn't exist, create it.
     */
    if ((pcp = (PCHECKPOINT)_GetProp(pwnd,
                                     PROP_CHECKPOINT,
                                     PROPF_INTERNAL)) == NULL) {

        if ((pcp = (PCHECKPOINT)UserAllocPoolWithQuota(sizeof(CHECKPOINT),
                                                       TAG_CHECKPT)) == NULL) {
            return NULL;
        }

        if (!InternalSetProp(pwnd,
                             PROP_CHECKPOINT,
                             (HANDLE)pcp,
                             PROPF_INTERNAL)) {

            UserFreePool(pcp);
            return NULL;
        }

        /*
         * Initialize it to -1 so first minimize will park the icon.
         */
        pcp->ptMin.x = -1;
        pcp->ptMin.y = -1;
        pcp->ptMax.x = -1;
        pcp->ptMax.y = -1;

        /*
         * Initialize pwndTitle to NULL so we create a title window on the
         * first minimize of the window
         */
        pcp->fDragged                     = FALSE;
        pcp->fWasMaximizedBeforeMinimized = FALSE;
        pcp->fWasMinimizedBeforeMaximized = FALSE;
        pcp->fMinInitialized              = FALSE;
        pcp->fMaxInitialized              = FALSE;

        /*
         * BOGUS!  We're going to copy this twice if the window isn't
         * minimized or maximized.  But if it isn't, we're going to get
         * a weird size in rcNormal...
         */
        CopyRect(&pcp->rcNormal, lprcWindow);
    }

    /*
     * If the window is minimized/maximized, then set the min/max
     * point.  Otherwise use checkpoint the window-size.
     */
    if (TestWF(pwnd, WFMINIMIZED)) {
        pcp->fMinInitialized = TRUE;
        pcp->ptMin.x = lprcWindow->left;
        pcp->ptMin.y = lprcWindow->top;
    } else if (TestWF(pwnd, WFMAXIMIZED)) {
        pcp->fMaxInitialized = TRUE;

        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            if (TestWF(pwnd, WFREALLYMAXIMIZABLE)) {
                pcp->fMaxInitialized = FALSE;
                pcp->ptMax.x = -1;
                pcp->ptMax.y = -1;
            } else {
                PMONITOR pMonitor;
                LPRECT   lprc;

                pMonitor = _MonitorFromRect(lprcWindow, MONITOR_DEFAULTTOPRIMARY);
                GetMonitorMaxArea(pwnd, pMonitor, &lprc);
                pcp->ptMax.x = lprcWindow->left - lprc->left;
                pcp->ptMax.y = lprcWindow->top - lprc->top;
            }
        } else {
            pcp->ptMax.x = lprcWindow->left;
            pcp->ptMax.y = lprcWindow->top;
        }
    } else {
        CopyRect(&pcp->rcNormal, lprcWindow);
    }

    return pcp;
}

/***************************************************************************\
* xxxMS_TrackMove
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
\***************************************************************************/

void xxxMS_TrackMove(
    PWND          pwnd,
    UINT          message,
    WPARAM        wParam,
    LPARAM        lParam,
    PMOVESIZEDATA pmsd)
{
    int         dxMove;
    int         dyMove;
    POINT       pt;
    BOOL        fSlower;
    RECT        rc;
    PCHECKPOINT pcp;
    LPWORD      ps;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());
    UserAssert(pmsd == ptiCurrent->pmsd);

    pt.x = LOSHORT(lParam);
    pt.y = HISHORT(lParam);

    switch (message) {
    case WM_LBUTTONUP:

        /*
         * Do final move!
         */
        xxxTM_MoveDragRect(pmsd, lParam);


        /*
         * Don't reset the mouse position when done.
         */
        pmsd->fmsKbd = FALSE;

Accept:

        /*
         * Turn off rect, unlock screen, release capture, and stop tracking.
         * 1 specifies end and accept drag.
         */
        bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
        if (ptiCurrent->TIF_flags & TIF_TRACKRECTVISIBLE) {
            xxxDrawDragRect(pmsd, NULL, DDR_ENDACCEPT);
            ptiCurrent->TIF_flags &= ~TIF_TRACKRECTVISIBLE;
        }

TrackMoveCancel:

        /*
         * Revalidation: if pwnd is unexpectedly deleted, jump here to cleanup.
         * If pwnd is/becomes invalid between here and return, continue with
         * cleanup as best as possible.
         */
        zzzClipCursor((LPRECT)NULL);
        LockWindowUpdate2(NULL, TRUE);
        xxxReleaseCapture();

        /*
         * First unlock task and reset cursor.
         */
        pmsd->fTrackCancelled = TRUE;

        /*
         * If using the keyboard, restore the initial mouse position.
         */
        if (pmsd->fmsKbd) {
            /*
             * No DeferWinEventNotify required - xxx calls above & below
             */
            zzzInternalSetCursorPos(pmsd->ptRestore.x,
                                 pmsd->ptRestore.y
                                 );
        }

        /*
         * Move to new location relative to parent.
         */
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            rc.left = rc.top = 0;
        } else {
            rc.left = pwnd->spwndParent->rcClient.left;
            rc.top = pwnd->spwndParent->rcClient.top;
        }

        if (!EqualRect(&pmsd->rcDrag, &pmsd->rcWindow)) {

            if (!xxxCallHook(HCBT_MOVESIZE,
                             (WPARAM)HWq(pwnd),
                             (LPARAM)&pmsd->rcDrag,
                             WH_CBT)) {

                RECT rcT;

                if (pmsd->cmd != WMSZ_MOVE) {

                    if (TestWF(pwnd, WFMINIMIZED)) {

                        CopyOffsetRect(&rcT,
                                       &pmsd->rcWindow,
                                       -rc.left,
                                       -rc.top);

                        /*
                         * Save the minimized position.
                         */
                        CkptRestore(pwnd, &rcT);
                        SetMinimize(pwnd, SMIN_CLEAR);

                    } else if (TestWF(pwnd, WFMAXIMIZED)) {
                        ClrWF(pwnd, WFMAXIMIZED);
                    }

                } else if (TestWF(pwnd, WFMINIMIZED)) {

                    CopyOffsetRect(&rcT,
                                   &pmsd->rcWindow,
                                   -rc.left,
                                   -rc.top);


                    if (pcp = CkptRestore(pwnd, &rcT))
                        pcp->fDragged = TRUE;
                }

            } else {
                CopyRect(&pmsd->rcDrag, &pmsd->rcWindow);
            }
        }

        /*
         * Move to new location relative to parent.
         */
        if (TestWF(pwnd->spwndParent,WEFLAYOUTRTL)) {
            /*
             * If this is a mirrored window, then measure the client
             * coordinates from the parent's right edge, not the left one.
             */
            int iLeft;

            OffsetRect(&pmsd->rcDrag, -pwnd->spwndParent->rcClient.right, -rc.top);
            iLeft = pmsd->rcDrag.left;
            pmsd->rcDrag.left  = (pmsd->rcDrag.right * -1);
            pmsd->rcDrag.right = (iLeft * -1);
        } else {
            OffsetRect(&pmsd->rcDrag, -rc.left, -rc.top);
        }

        /*
         * For top level windows, make sure at least part of the caption
         * caption is always visible in the desktop area.  This will
         * ensure that once moved, the window can be moved back.
         */
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {

            int         dy;
            BOOL        fMonitor;
            PMONITOR    pMonitor;

            UserAssert(HIBYTE(WEFTOPMOST) == HIBYTE(WEFTOOLWINDOW));
            fMonitor = TestWF(pwnd, WEFTOPMOST | WEFTOOLWINDOW);
            dy = (TestWF(pwnd, WEFTOOLWINDOW) ?
                    SYSMET(CYSMCAPTION) : SYSMET(CYCAPTION)) - SYSMET(CYBORDER);

            if (gpDispInfo->cMonitors == 1) {
                pMonitor = GetPrimaryMonitor();
            } else {
                int     y;
                LPRECT  lprc;

                y = pmsd->rcDrag.top + dy;

                /*
                 * Make sure that some part of the caption is showing on some
                 * monitor...
                 */
                for (   pMonitor = gpDispInfo->pMonitorFirst;
                        pMonitor;
                        pMonitor = pMonitor->pMonitorNext) {

                    if (!(pMonitor->dwMONFlags & MONF_VISIBLE))
                        continue;

                    if (fMonitor) {
                        lprc = &pMonitor->rcMonitor;
                    } else {
                        lprc = &pMonitor->rcWork;
                    }

                    /*
                     * Is the Y coordinate visible on screen somewhere?
                     */
                    if (y >= lprc->top && y < lprc->bottom)
                        goto AllSet;
                }

                /*
                 * Oops, have to move the window so that some part of
                 * the caption is visible on screen.
                 */
                pMonitor = _MonitorFromRect(&pmsd->rcDrag, MONITOR_DEFAULTTONEAREST);
            }

            if (fMonitor) {
                pmsd->rcDrag.top = max(pmsd->rcDrag.top, pMonitor->rcMonitor.top - dy);
            } else {
                pmsd->rcDrag.top = max(pmsd->rcDrag.top, pMonitor->rcWork.top - dy);
            }

AllSet:
            ;
        }

        /*
         * OR in SWP_NOSIZE so it doesn't redraw if we're just moving.
         */
        xxxSetWindowPos(
                pwnd,
                NULL,
                pmsd->rcDrag.left,
                pmsd->rcDrag.top,
                pmsd->rcDrag.right - pmsd->rcDrag.left,
                pmsd->rcDrag.bottom - pmsd->rcDrag.top,
                (DWORD)((pmsd->cmd == (int)WMSZ_MOVE) ? SWP_NOSIZE : 0));

        if (TestWF(pwnd, WFMINIMIZED)) {
            CkptRestore(pwnd, &pmsd->rcDrag);
        }

        xxxWindowEvent(EVENT_SYSTEM_MOVESIZEEND, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);

        /*
         * Send this message for winoldapp support
         */
        xxxSendMessage(pwnd, WM_EXITSIZEMOVE, 0L, 0L);
        break;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:

        /*
         * Assume we're not moving the drag rectangle.
         */
        dxMove =
        dyMove = 0;

        /*
         * We move or size slower if the control key is down.
         */
        fSlower = (_GetKeyState(VK_CONTROL) < 0);

        switch (wParam) {
        case VK_RETURN:
            lParam = _GetMessagePos();
            goto Accept;

        case VK_ESCAPE:

            /*
             * 2 specifies end and cancel drag.
             */
            bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
            if (ptiCurrent->TIF_flags & TIF_TRACKRECTVISIBLE) {
                xxxDrawDragRect(pmsd, NULL, DDR_ENDCANCEL);
                ptiCurrent->TIF_flags &= ~TIF_TRACKRECTVISIBLE;
            }

            CopyRect(&pmsd->rcDrag, &pmsd->rcWindow);

            goto TrackMoveCancel;

        case VK_LEFT:
        case VK_RIGHT:

            if (pmsd->impx == 0) {

                pmsd->impx = rgimpimpiw[wParam - VK_LEFT];
                goto NoOffset;

            } else {

                dxMove = (fSlower ? 1 : max(SYSMET(CXSIZE) / 2, 1));

                if (wParam == VK_LEFT)
                    dxMove = -dxMove;

                goto KeyMove;
            }

        case VK_UP:
        case VK_DOWN:

            if (pmsd->impy == 0) {

                pmsd->impy = rgimpimpiw[wParam - VK_LEFT];
NoOffset:
                pmsd->dxMouse = pmsd->dyMouse = 0;

            } else {

                dyMove = (fSlower ? 1 : max(SYSMET(CYSIZE) / 2, 1));

                if (wParam == VK_UP) {
                    dyMove = -dyMove;
                }
            }

KeyMove:
            if (pmsd->cmd == WMSZ_MOVE) {

                /*
                 * Use the current rect position as the current mouse
                 * position
                 */
                lParam = (DWORD)(POINTTOPOINTS(*((POINT *)&pmsd->rcDrag)));

            } else {

                /*
                 * Get the current mouse position
                 */
                lParam = _GetMessagePos();
            }

            /*
             * Calc the new 'mouse' pos
             */
            if (pmsd->impx != 0) {
                ps = ((WORD *)(&lParam)) + 0;
                *ps = (WORD)(*((int *)&pmsd->rcDragCursor +
                             rgimpiwx[pmsd->impx])        +
                             dxMove);
            }

            if (pmsd->impy != 0) {
                ps = ((WORD *)(&lParam)) + 1;
                *ps = (WORD)(*((int *)&pmsd->rcDragCursor +
                             rgimpiwy[pmsd->impy])        +
                             dyMove);
            }

            if (pmsd->cmd != WMSZ_MOVE) {

                /*
                 * Calculate the new move command.
                 */
                pmsd->cmd = pmsd->impx + pmsd->impy;

                /*
                 * Change the mouse cursor for this condition.
                 */
                xxxSendMessage(
                        pwnd,
                        WM_SETCURSOR,
                        (WPARAM)HW(pwnd),
                        MAKELONG((SHORT)(pmsd->cmd + HTSIZEFIRST - WMSZ_SIZEFIRST), WM_MOUSEMOVE));
            }

            /*
             * We don't want to call zzzInternalSetCursorPos() if the
             * rect position is outside of rcParent because that'll
             * generate a mouse move which will jerk the rect back
             * again.  This is here so we can move rects partially off
             * screen without regard to the mouse position.
             */
            pt.x = LOSHORT(lParam) - pmsd->dxMouse;
            pt.y = HISHORT(lParam) - pmsd->dyMouse;

            if (pwnd->spwndParent->hrgnClip) {
                if (GrePtInRegion(pwnd->spwndParent->hrgnClip, pt.x, pt.y)) {
                    zzzInternalSetCursorPos(pt.x, pt.y);
                }
            } else {
                if (PtInRect(&pmsd->rcParent, pt)) {
                    zzzInternalSetCursorPos(pt.x, pt.y);
                }
            }

            /*
             * Move or size the rect using lParam as our mouse
             * coordinates
             */
            xxxTM_MoveDragRect(pmsd, lParam);
            break;

        }  // of inner switch
        break;

    case WM_MOUSEMOVE:
        xxxTM_MoveDragRect(pmsd, lParam);
        break;
    }
}

/***************************************************************************\
* xxxMS_FlushWigglies
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
\***************************************************************************/

VOID xxxMS_FlushWigglies(VOID)
{
    MSG msg;

    /*
     * HACK!
     *
     * Calling zzzInternalSetCursorPos() while initializing the cursor
     * position appears to be posting a bogus MouseMove
     * message...  don't really have the time
     * now to figure out why...  so spit out all the mouse move messages
     * before entering the main move/size loop.  CraigC.
     */
    while (xxxPeekMessage(&msg,
                          NULL,
                          WM_MOUSEMOVE,
                          WM_MOUSEMOVE,
                          PM_REMOVE | PM_NOYIELD));
}

/***************************************************************************\
* xxxTrackInitSize
*
* NOTE: to recover from hwnd invalidation, just return and let ?
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
\***************************************************************************/

BOOL xxxTrackInitSize(
    PWND          pwnd,
    UINT          message,
    WPARAM        wParam,
    LPARAM        lParam,
    PMOVESIZEDATA pmsd)
{
    int   ht;
    POINT pt;
    RECT  rc;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(pmsd == ptiCurrent->pmsd);
    UserAssert(IsWinEventNotifyDeferredOK());

    POINTSTOPOINT(pt, lParam);

    _ClientToScreen(pwnd, (LPPOINT)&pt);
    ht = FindNCHit(pwnd, POINTTOPOINTS(pt));

    switch (message) {

    case WM_KEYDOWN:
        if (pmsd->cmd == WMSZ_MOVE) {
            xxxSendMessage(pwnd,
                           WM_SETCURSOR,
                           (WPARAM)HW(pwnd),
                           MAKELONG(WMSZ_KEYSIZE, WM_MOUSEMOVE));
        }
        /* keys below are only allowed */
        switch (wParam) {
        case VK_RETURN:
        case VK_ESCAPE:
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            pmsd->fInitSize = FALSE;
            break;
        }
        return TRUE;

    case WM_LBUTTONDOWN:
        if (!PtInRect(&pmsd->rcDrag, pt)) {

            /*
             *** FALL THRU ***
             */

    case WM_LBUTTONUP:

            /*
             * Cancel everything.
             */
            {
                PTHREADINFO ptiCurrent = PtiCurrent();

                bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
                if (ptiCurrent->TIF_flags & TIF_TRACKRECTVISIBLE) {
                    xxxDrawDragRect(pmsd, NULL, DDR_ENDCANCEL);
                    ptiCurrent->TIF_flags &= ~TIF_TRACKRECTVISIBLE;
                }

                pmsd->fInitSize = FALSE;
                zzzClipCursor(NULL);
            }

            xxxReleaseCapture();
            pmsd->fTrackCancelled = TRUE;
            return FALSE;

        } else {

            /*
             * Now start hit testing for a border.
             */
            goto CheckFrame;
        }

    case WM_MOUSEMOVE:

        /*
         * The mouse is down, hit test for a border on mouse moves.
         */
        if (wParam == MK_LBUTTON) {

CheckFrame:

            switch (pmsd->cmd) {
            case WMSZ_MOVE:

                /*
                 * If we are on the caption bar, exit.
                 */
                if (ht == HTCAPTION) {

                    /*
                     * Change the mouse cursor.
                     */
                    xxxSendMessage(pwnd,
                                   WM_SETCURSOR,
                                   (WPARAM)HW(pwnd),
                                   MAKELONG(WMSZ_KEYSIZE, WM_MOUSEMOVE));

                    pmsd->dxMouse   = pmsd->rcWindow.left - pt.x;
                    pmsd->dyMouse   = pmsd->rcWindow.top - pt.y;
                    pmsd->fInitSize = FALSE;
                    return TRUE;
                }
                break;

            case WMSZ_KEYSIZE:

                /*
                 * If we are on a frame control, change the cursor and exit.
                 */
                if (ht >= HTSIZEFIRST && ht <= HTSIZELAST) {

                    /*
                     * Change the mouse cursor
                     */
                    xxxSendMessage(pwnd,
                                   WM_SETCURSOR,
                                   (WPARAM)HW(pwnd),
                                   MAKELONG(ht, WM_MOUSEMOVE));

                    pmsd->fInitSize = FALSE;

                    /*
                     * Set the proper cmd for SizeRect().
                     *
                     * HACK! Depends on order of HTSIZE* defines!
                     */
                    pmsd->impx = rgcmdmpix[ht - HTSIZEFIRST + 1];
                    pmsd->impy = rgcmdmpiy[ht - HTSIZEFIRST + 1];
                    pmsd->cmd  = pmsd->impx + pmsd->impy;

                    pmsd->dxMouse = *((UINT FAR *)&pmsd->rcWindow + rgimpiwx[pmsd->cmd]) - pt.x;
                    pmsd->dyMouse = *((UINT FAR *)&pmsd->rcWindow + rgimpiwy[pmsd->cmd]) - pt.y;

                    return TRUE;
                }
            }

        } else {

            /*
             * If button not down, and we are moving the window, change the
             * cursor shape depending upon where the mouse is pointing.  This
             * allows the cursor to change to the arrows when over the window
             * frame.
             */
            CopyRect(&rc, &pwnd->rcWindow);
            if (PtInRect(&rc, pt)) {
                if ((ht >= HTSIZEFIRST) && (ht <= HTSIZELAST)) {
                    xxxSendMessage(pwnd,
                                   WM_SETCURSOR,
                                   (WPARAM)HW(pwnd),
                                   MAKELONG(ht, WM_MOUSEMOVE));

                    break;
                }
            }

            zzzSetCursor(SYSCUR(SIZEALL));
        }
        break;
    }

    return TRUE;
}

/***************************************************************************\
* xxxMoveSize
*
* History:
* 12-Nov-1990 MikeHar   Ported from win3
\***************************************************************************/

VOID xxxMoveSize(
    PWND  pwnd,
    UINT  cmdMove,
    DWORD wptStart)
{
    MSG             msg;
    int             x;
    int             y;
    int             i;
    RECT            rcSys;
    PTHREADINFO     ptiCurrent = PtiCurrent();
    PMOVESIZEDATA   pmsd;
    TL              tlpwndT;
    PWND            pwndT;
    POINT           ptStart;
    MINMAXINFO      mmi;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Don't allow the app to track a window
     * from another queue.
     */
    if (GETPTI(pwnd)->pq != ptiCurrent->pq)
        return;

    if (ptiCurrent->pmsd != NULL)
        return;

    /*
     * If the window with the focus is a combobox, hide the dropdown
     * listbox before tracking starts.  The dropdown listbox is not a
     * child of the window being moved, therefore it won't be moved along
     * with the window.
     *
     * NOTE: Win 3.1 doesn't perform this check.
     */
    if ((pwndT = ptiCurrent->pq->spwndFocus) != NULL) {

        if (GETFNID(pwndT) == FNID_COMBOBOX) {
            ;
        } else if ((pwndT->spwndParent != NULL) &&
                (GETFNID(pwndT->spwndParent) == FNID_COMBOBOX)) {

            pwndT = pwndT->spwndParent;
        } else {
            pwndT = NULL;
        }

        if (pwndT != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwndT, &tlpwndT);
            xxxSendMessage(pwndT, CB_SHOWDROPDOWN, FALSE, 0);
            ThreadUnlock(&tlpwndT);
        }
    }

    /*
     * Allocate and zero the movesize data structure
     */
    pmsd = (PMOVESIZEDATA)UserAllocPoolWithQuotaZInit(
            sizeof(MOVESIZEDATA), TAG_MOVESIZE);

    if (pmsd == NULL)
        return;

    /*
     * Assign the move data into the pti.  If the thread is destroyed before
     * we free the data the DestroyThreadInfo() routine will free the move data
     */
    ptiCurrent->pmsd = pmsd;

    Lock(&(pmsd->spwnd), pwnd);

    /*
     * Set fForeground so we know whether to draw or not.
     */
    pmsd->fForeground = (ptiCurrent->pq == gpqForeground) ? TRUE : FALSE;

    /*
     * Lower the priority of the thread doing the dragging to make sure
     * that we don't starve other threads and they get to repaint more often.
     */
    if (ptiCurrent == gptiForeground) {
        SetForegroundPriority(ptiCurrent, FALSE);
    }

    /*
     * Get the client and window rects.
     */
    CopyRect(&pmsd->rcWindow, &pwnd->rcWindow);

    if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
        if (    TestWF(pwnd, WEFTOPMOST) ||
                TestWF(pwnd, WEFTOOLWINDOW) ||
                gpDispInfo->cMonitors > 1) {

            pmsd->rcParent = gpDispInfo->rcScreen;
         } else {
            pmsd->rcParent = GetPrimaryMonitor()->rcWork;
         }
    } else {
        CopyRect(&pmsd->rcParent, &pwnd->spwndParent->rcClient);

        /*
         * If the parent does have a region, intersect with its bounding rect.
         */
        if (pwnd->spwndParent->hrgnClip != NULL) {

            RECT rcT;

            GreGetRgnBox(pwnd->spwndParent->hrgnClip, &rcT);
            IntersectRect(&pmsd->rcParent, &pmsd->rcParent, &rcT);
        }
    }

    /*
     * This works for multiple monitors _and_ regional windows
     */
    if (pwnd->spwndParent->hrgnClip) {
        pmsd->fOffScreen = !GreRectInRegion(pwnd->spwndParent->hrgnClip, &pmsd->rcWindow);
    } else {
        pmsd->fOffScreen = !IntersectRect(&rcSys, &pmsd->rcWindow, &pmsd->rcParent);
    }

    /*
     * No need to DeferWinEventNotify(), judging by xxxInitSendValidateMinMaxInfo below
     */
    zzzClipCursor(&pmsd->rcParent);
    CopyRect(&rcSys, &pmsd->rcWindow);

    if (TestWF(pwnd, WFMINIMIZED)) {

        /*
         * No need to send WM_GETMINMAXINFO since we know the minimized size.
         */
        pmsd->ptMinTrack.x = pmsd->ptMaxTrack.x = SYSMET(CXMINIMIZED);
        pmsd->ptMinTrack.y = pmsd->ptMaxTrack.y = SYSMET(CYMINIMIZED);

    } else {
        xxxInitSendValidateMinMaxInfo(pwnd, &mmi);
        pmsd->ptMinTrack = mmi.ptMinTrackSize;
        pmsd->ptMaxTrack = mmi.ptMaxTrackSize;
    }

    /*
     * Set up the drag rectangle.
     */
    CopyRect(&pmsd->rcDrag, &pmsd->rcWindow);
    CopyRect(&pmsd->rcDragCursor, &pmsd->rcDrag);

    ptStart.x = LOSHORT(wptStart);
    ptStart.y = HISHORT(wptStart);

    /*
     * Assume Move/Size from mouse.
     */
    pmsd->fInitSize = FALSE;
    pmsd->fmsKbd = FALSE;

    /*
     * Get the mouse position for this move/size command.
     */
    switch (pmsd->cmd = cmdMove) {
    case WMSZ_KEYMOVE:
        pmsd->cmd = cmdMove = WMSZ_MOVE;

        /*
         ** FALL THRU **
         */

    case WMSZ_KEYSIZE:
        /*
         * No need to DeferWinEventNotify() - pmsd won't go away, and pwnd is locked
         */
        zzzSetCursor(SYSCUR(SIZEALL));

        if (!TestWF(pwnd, WFMINIMIZED))
            pmsd->fInitSize = TRUE;

        /*
         * Workaround: always behave as if the command is
         * issued using keyboard.
         * if it's found as the wrong way, the behavior is defined as:
         * if (mnFocus == KEYBDHOLD) ||
         *   ((mnFocus == MOUSEHOLD) && TestWF(pwnd, WFMINIMIZED))) {
         * In order to do this, mnFocus should be saved somewhere.
         * originally, mnFocus was saved in MenuState.
         */
        pmsd->fmsKbd      = TRUE;
        pmsd->ptRestore.x = LOSHORT(wptStart);
        pmsd->ptRestore.y = HISHORT(wptStart);

        /*
         * Center cursor in caption area of window
         */

        /*
         * Horizontally
         */
        ptStart.x = (pmsd->rcDrag.left + pmsd->rcDrag.right) / 2;

        /*
         * Vertically
         */
        if (TestWF(pwnd,WFMINIMIZED) || (pmsd->cmd != WMSZ_MOVE)) {
            ptStart.y = (pmsd->rcDrag.top + pmsd->rcDrag.bottom) / 2;
        } else {
            int dy;

            dy = GetCaptionHeight(pwnd);
            ptStart.y = pmsd->rcDrag.top + SYSMET(CYFIXEDFRAME) + dy / 2;
        }

        zzzInternalSetCursorPos(ptStart.x, ptStart.y);
        xxxMS_FlushWigglies();
        break;

    default:
        break;
    }

    pmsd->fDragFullWindows = TEST_BOOL_PUDF(PUDF_DRAGFULLWINDOWS);
    SET_OR_CLEAR_PUDF(PUDF_DRAGGINGFULLWINDOW, pmsd->fDragFullWindows);

    /*
     * If we hit with the mouse, set up impx and impy so that we
     * can use the keyboard too.
     */
    pmsd->impx = rgcmdmpix[cmdMove];
    pmsd->impy = rgcmdmpiy[cmdMove];

    /*
     * Setup dxMouse and dyMouse - If we're sizing with the keyboard these
     * guys are set to zero down in the keyboard code.
     */
    if ((i = rgimpiwx[cmdMove]) != (-1))
        pmsd->dxMouse = *((int *)&pmsd->rcWindow + (short)i) - ptStart.x;

    if ((i = rgimpiwy[cmdMove]) != (-1))
        pmsd->dyMouse = *((int *)&pmsd->rcWindow + (short)i) - ptStart.y;

    /*
     * Tell Gdi the width of the drag rect (if its a special size)
     * Turn the drag rect on.  0 specifies start drag.
     */
    if (!TestWF(pwnd, WFSIZEBOX))
        bSetDevDragWidth(gpDispInfo->hDev, 1);

    xxxWindowEvent(EVENT_SYSTEM_MOVESIZESTART, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);

    xxxDrawDragRect(pmsd, NULL, DDR_START);
    ptiCurrent->TIF_flags |= TIF_TRACKRECTVISIBLE;

    msg.lParam = MAKELONG(ptStart.x, ptStart.y);

    /*
     * Right here win3.1 calls LockWindowUpdate(). This calls zzzSetFMouseMoved()
     * which ensures that the next message in the queue is a mouse message.
     * We need that mouse message as the first message because the first
     * call to TrackInitSize() assumes that lParam is an x, y from a mouse
     * message - scottlu.
     */
    zzzSetFMouseMoved();

    /*
     * Send this message for winoldapp support
     */
    xxxSendMessage(pwnd, WM_ENTERSIZEMOVE, 0L, 0L);
    xxxCapture(ptiCurrent, pwnd, CLIENT_CAPTURE_INTERNAL);

    /*
     * Show the move cursor for non-mouse systems.
     */
    zzzShowCursor(TRUE);

    while (!(pmsd->fTrackCancelled)) {

        /*
         * Let other messages not related to dragging be dispatched
         * to the application window.
         * In the case of clock, clock will now receive messages to
         * update the time displayed instead of having the time display
         * freeze while we are dragging.
         */
        while (ptiCurrent->pq->spwndCapture == pwnd) {

            if (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                if ((msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST)
                    || (msg.message == WM_QUEUESYNC)
                    || (msg.message >= WM_KEYFIRST && msg.message <= WM_KEYLAST)) {

                    break;
                }

                if (_CallMsgFilter(&msg, cmdMove == WMSZ_MOVE ? MSGF_MOVE : MSGF_SIZE)) {
                    continue;
                }

                xxxTranslateMessage(&msg, 0);
                /*
                 * To prevent applications from doing
                 * a PeekMessage loop and getting the mouse move messages that
                 * are destined for the xxxMoveSize PeekMessage loop, we OR in
                 * this flag. See comments in input.c for xxxInternalGetMessage.
                 */
                ptiCurrent->TIF_flags |= TIF_MOVESIZETRACKING;
                xxxDispatchMessage(&msg);
                ptiCurrent->TIF_flags &= ~TIF_MOVESIZETRACKING;

            } else {
                /*
                 * If we've been cancelled by someone else, or our pwnd
                 * has been destroyed, blow out of here.
                 */
                if (pmsd->fTrackCancelled)
                    break;

                if (!xxxWaitMessage())
                    break;
            }
        }

        /*
         * If we've lost capture while tracking,
         * cancel the move/size operation.
         */
        if (ptiCurrent->pq->spwndCapture != pwnd) {

            /*
             * Fake a key-down of the escape key to cancel.
             */
            xxxMS_TrackMove(pwnd, WM_KEYDOWN, (DWORD)VK_ESCAPE, 1, pmsd);
            goto MoveSizeCleanup;
        }

        /*
         * If we've been cancelled by someone else, or our pwnd
         * has been destroyed, blow out of here.
         */
        if (pmsd->fTrackCancelled) {
            pmsd->fTrackCancelled = FALSE;
            goto MoveSizeCleanup;
        }

        /*
         * If we get a WM_QUEUESYNC, let the CBT hook know.
         */
        if (msg.message == WM_QUEUESYNC) {
            xxxCallHook(HCBT_QS, 0, 0, WH_CBT);
        }

        if (pmsd->fInitSize) {
            if (!xxxTrackInitSize(pwnd, msg.message, msg.wParam, msg.lParam,
                    pmsd)) {
                break;
            }
        }

        /*
         * Convert captured mouse into screen coordinates.
         */
        x = msg.pt.x + pmsd->dxMouse;
        y = msg.pt.y + pmsd->dyMouse;

        /*
         * This is checked twice so the same message is not processed both
         * places.
         */
        if (!pmsd->fInitSize) {
            xxxMS_TrackMove(pwnd, msg.message, msg.wParam, MAKELONG(x, y),
                    pmsd);
        }
    }

MoveSizeCleanup:

    /*
     * Reset priority if still in the foreground thread.
     */

    if (ptiCurrent == gptiForeground) {
        SetForegroundPriority(ptiCurrent, TRUE);
    }

    /*
     * Reset the border size if it was abnormal
     */

    if (!TestWF(pwnd, WFSIZEBOX))
        bSetDevDragWidth(gpDispInfo->hDev, gpsi->gclBorder + BORDER_EXTRA);

    /*
     * Revalidation: If pwnd is deleted unexpectedly, jump here to cleanup.
     */

    bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
    ptiCurrent->TIF_flags &= ~(TIF_TRACKRECTVISIBLE);

    if (pmsd->fDragFullWindows) {
        if (ghrgnUpdateSave != NULL) {
            GreDeleteObject(ghrgnUpdateSave);
            ghrgnUpdateSave = NULL;
            gnUpdateSave = 0;
        }
    }

    CLEAR_PUDF(PUDF_DRAGGINGFULLWINDOW);

    ptiCurrent->pmsd = NULL;

    Unlock(&pmsd->spwnd);


    zzzShowCursor(FALSE);

    /*
     * Free the move/size data structure
     */
    UserFreePool(pmsd);
}

/***************************************************************************\
* This calls xxxRedrawHungWindow() on windows that do not belong to this thread.
*
* History:
* 27-May-1994 johannec
\***************************************************************************/

VOID xxxUpdateOtherThreadsWindows(
    PWND pwnd,
    HRGN hrgnFullDrag)
{
    PWND        pwndChild;
    TL          tlpwndChild;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);

    xxxRedrawHungWindow(pwnd, hrgnFullDrag);

    /*
     * If the parent window does not have the flag WFCLIPCHILDREN set,
     * there is no need to redraw its children.
     */
    if (!TestWF(pwnd, WFCLIPCHILDREN))
        return;

    pwndChild = pwnd->spwndChild;
    ThreadLockNever(&tlpwndChild);
    while (pwndChild != NULL) {
        ThreadLockExchangeAlways(pwndChild, &tlpwndChild);
        xxxUpdateOtherThreadsWindows(pwndChild, hrgnFullDrag);
        pwndChild = pwndChild->spwndNext;
    }

    ThreadUnlock(&tlpwndChild);
}

/***************************************************************************\
* This calls UpdateWindow() on every window that is owned by this thread
* and calls xxxRedrawHungWindow() for windows owned by other threads.
*
* History:
* 28-Sep-1993 mikeke   Created
\***************************************************************************/

VOID xxxUpdateThreadsWindows(
    PTHREADINFO pti,
    PWND        pwnd,
    HRGN        hrgnFullDrag)
{
    TL   tlpwnd;

    CheckLock(pwnd);

    ThreadLockNever(&tlpwnd);
    while (pwnd != NULL) {
        ThreadLockExchangeAlways(pwnd, &tlpwnd);
        if (GETPTI(pwnd) == pti) {
            xxxUpdateWindow(pwnd);
        } else {
            xxxUpdateOtherThreadsWindows(pwnd, hrgnFullDrag);
        }

        pwnd = pwnd->spwndNext;
    }

    ThreadUnlock(&tlpwnd);
}

/***************************************************************************\
* xxxDrawDragRect
*
* Draws the drag rect for sizing and moving windows.  When moving windows,
* can move full windows including client area.  lprc new rect to move to.
* if lprc is null, flags specify why.
*
* flags:  DDR_START     0 - start drag.
*         DDR_ENDACCEPT 1 - end and accept
*         DDR_ENDCANCEL 2 - end and cancel.
*
* History:
* 07-29-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxDrawDragRect(
    PMOVESIZEDATA pmsd,
    LPRECT        lprc,
    UINT          type)
{
    HDC  hdc;
    int  lvBorder;
    HRGN hrgnClip;

    /*
     * If we're dragging an icon, or we're not foreground, don't draw
     * the dragging rect.
     */
    if (!pmsd->fForeground) {

        if (lprc != NULL)
            CopyRect(&pmsd->rcDrag, lprc);

        return;
    }

    /*
     * If it already equals, just return.
     */
    if ((lprc != NULL) && EqualRect(&pmsd->rcDrag, lprc))
        return;

    if (!(pmsd->fDragFullWindows)) {

        /*
         * If we were not able to lock the screen (because some other process
         * or thread had the screen locked), then get a dc but make sure
         * it is totally clipped to nothing.
         * NO longer a posibility
         */

        /*
         * Clip to client rect of parent.  (Client given in screen coords.)
         */
        hrgnClip = GreCreateRectRgnIndirect(&pmsd->rcParent);

        /*
         * Clip to the parent's window clipping rgn if it has one.
         */
        if (hrgnClip != NULL && pmsd->spwnd->spwndParent->hrgnClip != NULL)
            IntersectRgn(hrgnClip,
                         hrgnClip,
                         pmsd->spwnd->spwndParent->hrgnClip);

        if (hrgnClip == NULL)
            hrgnClip = HRGN_FULL;

        /*
         * If lprc == NULL, just draw rcDrag once.  If lprc != NULL,
         * undraw *lprc, draw rcDrag, copy in *lprc.
         */

        /*
         * Use size 1 for minimized or non-sizeable windows.  Otherwise
         * use the # of borders (2 for outer edge, 1 for border, clBorder for
         * size border.
         */
        if (TestWF(pmsd->spwnd, WFMINIMIZED) || !TestWF(pmsd->spwnd, WFSIZEBOX))
            lvBorder = 1;
        else
            lvBorder = 3 + gpsi->gclBorder;

        /*
         * Get a screen DC clipped to the parent, select in a gray brush.
         */
        hdc = _GetDCEx(
                PWNDDESKTOP(pmsd->spwnd),
                hrgnClip,
                DCX_WINDOW | DCX_CACHE | DCX_INTERSECTRGN | DCX_LOCKWINDOWUPDATE);

        if (lprc != NULL) {

            /*
             * Move the frame to a new location by delta drawing
             */
            GreLockDisplay(gpDispInfo->hDev);
            bMoveDevDragRect(gpDispInfo->hDev, (PRECTL) lprc);
            CopyRect(&pmsd->rcDrag, lprc);
            GreUnlockDisplay(gpDispInfo->hDev);

        } else {

            if (type == DDR_START) {
                bSetDevDragRect(gpDispInfo->hDev,
                                (PRECTL)&pmsd->rcDrag,
                                (PRECTL)&pmsd->rcParent);
            }
        }

        /*
         * Release the DC & delete hrgnClip
         */
        _ReleaseDC(hdc);

    } else {

        RECT        rcSWP;
        HRGN        hrgnFullDragNew;
        HRGN        hrgnFullDragOld;
        PTHREADINFO ptiCancel = GETPTI(pmsd->spwnd);
        PTHREADINFO ptiCurrent = PtiCurrent();
        PWND        pwnd;
        TL          tlpwnd;

#if DBG
        /*
         * If ptiCancel != ptiCurrent, we must have come from xxxCancelTracking,
         * which has already locked ptiCancel.
         */
        if (ptiCancel != ptiCurrent) {
            CheckLock(ptiCancel);
        }
#endif

        /*
         * To prevent applications (like Micrografx Draw) from doing
         * a PeekMessage loop and getting the mouse move messages that
         * are destined for the xxxMoveSize PeekMessage loop, we OR in
         * this flag. See comments in input.c for xxxInternalGetMessage.
         */
        ptiCancel->TIF_flags |= TIF_MOVESIZETRACKING;

        if (lprc != NULL)
            CopyRect(&(pmsd->rcDrag), lprc);

        CopyRect(&rcSWP, &(pmsd->rcDrag));

        /*
         * Convert coordinates to client if the window is a child window or
         * if it's a popup-with parent.  The test for the popup is necessary
         * to solve a problem where a popup was assigned a parent of a MDI-
         * CLIENT window.
         */
        if (pmsd->spwnd->spwndParent != NULL && !FTopLevel(pmsd->spwnd)) {
            _ScreenToClient(pmsd->spwnd->spwndParent, (LPPOINT)&rcSWP);
            _ScreenToClient(pmsd->spwnd->spwndParent, ((LPPOINT)&rcSWP)+1);

            //
            // If the parent of this window is mirrored, then mirror the
            // rectangle coordinates so that child MDI windows work
            // properly
            //
            if( TestWF(pmsd->spwnd->spwndParent,WEFLAYOUTRTL) )
            {
              int iLeft   = rcSWP.left;
              rcSWP.left  = rcSWP.right;
              rcSWP.right = iLeft;
            }
        }

        /*
         * Don't bother being optimal here.  There's one case where we
         * really shouldn't blow away the SPB--the window is being sized
         * bigger.  We do want to do this when moving or sizing the window
         * smaller.  Why bother detecting the first case?
         */
        if (TestWF(pmsd->spwnd, WFHASSPB)){

            PSPB pspb;
            RECT rc;

            /*
             * If we're intersecting the original window rect and the window
             * has an SPB saved onboard, then just free it.  Otherwise the
             * window will move, the entire SPB will blt over it, we'll
             * invalidate the intersection, and the window will repaint,
             * causing mad flicker.
             */
            pspb = FindSpb(pmsd->spwnd);

            CopyRect(&rc, &pmsd->spwnd->rcWindow);
            if (lprc && IntersectRect(&rc, &rc, lprc)){
                FreeSpb(pspb);
            }
        }

        hrgnFullDragOld = GreCreateRectRgnIndirect(&pmsd->spwnd->rcWindow);

        if (pmsd->spwnd->hrgnClip != NULL)
            IntersectRgn(hrgnFullDragOld,
                         hrgnFullDragOld,
                         pmsd->spwnd->hrgnClip);

        xxxSetWindowPos(pmsd->spwnd,
                        NULL,
                        rcSWP.left, rcSWP.top,
                        rcSWP.right-rcSWP.left, rcSWP.bottom-rcSWP.top,
                        SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER);

        /*
         * We locked ptiCancel, so ptiCancel->pmsd has not been unexpectedly
         * freed in DeleteThreadInfo(), but xxxMoveSize() may have terminated
         * during our callback to xxxSetWindowPos and freed the pmsd there.
         */
        if (ptiCancel->pmsd != pmsd) {
            RIPMSG3(RIP_ERROR,
                    "xxxDrawDragRect: ptiCancel(%#p)->pmsd(%#p) != pmsd(%#p)\n",
                    ptiCancel, ptiCancel->pmsd, pmsd);
            goto CleanupAfterPmsdDisappearance;
        }
        hrgnFullDragNew = GreCreateRectRgnIndirect(&pmsd->spwnd->rcWindow);

        if (pmsd->spwnd->hrgnClip != NULL) {
            IntersectRgn(hrgnFullDragNew,
                         hrgnFullDragNew,
                         pmsd->spwnd->hrgnClip);
        }

        /*
         * Set the full drag update region that is used in xxxRedrawHungWindow.
         */
        if (hrgnFullDragNew == NULL) {

            /*
             * We couldn't create the new full drag region so don't
             * use the full drag region to xxxRedrawHungWindow. Using
             * NULL with force a redraw of the entire window's hrgnUpdate.
             * (which is what we used to do, overdrawing but at least
             * covering the invalidated areas).
             */
            if (hrgnFullDragOld != NULL) {
                GreDeleteObject(hrgnFullDragOld);
                hrgnFullDragOld = NULL;
            }

        } else {

            if (hrgnFullDragOld != NULL) {

                /*
                 * Subtract the new window rect from the old window rect
                 * to create the update region caused by the drag.
                 */
                SubtractRgn(hrgnFullDragOld, hrgnFullDragOld, hrgnFullDragNew);
            }
        }

        pwnd = PWNDDESKTOP(pmsd->spwnd)->spwndChild;
        ThreadLock(pwnd, &tlpwnd);
        xxxUpdateThreadsWindows(ptiCurrent, pwnd, hrgnFullDragOld);
        ThreadUnlock(&tlpwnd);

        GreDeleteObject(hrgnFullDragNew);

CleanupAfterPmsdDisappearance:
        GreDeleteObject(hrgnFullDragOld);

        ptiCancel->TIF_flags &= ~TIF_MOVESIZETRACKING;
    }
}

/***************************************************************************\
* xxxCancelTrackingForThread
*
*
\***************************************************************************/

VOID xxxCancelTrackingForThread(
    PTHREADINFO ptiCancel)
{
    PMOVESIZEDATA pmsdCancel;

    UserAssert(ptiCancel);

    /*
     * If this thread isn't around any more, skip it.
     */
    if (ptiCancel == NULL)
        return;

    if ((pmsdCancel = ptiCancel->pmsd) != NULL) {

        /*
         * Found one, now stop tracking.
         */
        pmsdCancel->fTrackCancelled = TRUE;

        /*
         * Only remove the tracking rectangle if it's
         * been made visible.
         */
        if (ptiCancel->TIF_flags & TIF_TRACKRECTVISIBLE) {
            bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);
            if (!(pmsdCancel->fDragFullWindows)) {
                xxxDrawDragRect(pmsdCancel, NULL, DDR_ENDCANCEL);
            }
        }

        /*
         * Leave TIF_TRACKING set to prevent xxxMoveSize()
         * recursion.
         */
        ptiCancel->TIF_flags &= ~TIF_TRACKRECTVISIBLE;
        if (ptiCancel->pq) {
            SetWakeBit(ptiCancel, QS_MOUSEMOVE);
        }

        /*
         * If the tracking window is still in menuloop, send the
         * WM_CANCELMODE message so that it can exit the menu.
         * This fixes the bug where we have 2 icons with their
         * system menu up.
         * 8/5/94 johannec
         */
        if (IsInsideMenuLoop(ptiCancel) && ptiCancel->pmsd)
            _PostMessage(ptiCancel->pmsd->spwnd, WM_CANCELMODE, 0, 0);

        /*
         * Turn off capture
         */
        xxxCapture(ptiCancel, NULL, NO_CAP_CLIENT);
    }
}

/***************************************************************************\
* xxxCancelTracking
*
*
\***************************************************************************/

#define MAX_THREADS 12

VOID xxxCancelTracking(VOID)
{
    PTHREADINFO pti;
    PTHREADINFO ptiList[MAX_THREADS];
    TL          tlptiList[MAX_THREADS];
    TL          tlspwndList[MAX_THREADS];
    UINT        cThreads = 0;
    INT         i;
    PLIST_ENTRY pHead;
    PLIST_ENTRY pEntry;
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * Build a list of threads that we need to look at. We can't just
     * walk the pointer list while we're doing the work, because we
     * might leave the critical section and the pointer could get
     * deleted out from under us.
     */
    pHead = &grpdeskRitInput->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {

        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

        if (pti->pmsd != NULL) {

            UserAssert(cThreads < MAX_THREADS);

            if (cThreads < MAX_THREADS) {
                ThreadLockPti(ptiCurrent, pti, &tlptiList[cThreads]);
                ThreadLockAlwaysWithPti(ptiCurrent, pti->pmsd->spwnd, &tlspwndList[cThreads]);
                ptiList[cThreads++] = pti;
            }
        }
    }

    /*
     * Walk the list backwards so the unlocks will be done in the right order.
     */
    for (i = cThreads - 1; i >= 0; i--) {
        if (!(ptiList[i]->TIF_flags & TIF_INCLEANUP)) {
            xxxCancelTrackingForThread(ptiList[i]);
        }

        ThreadUnlock(&tlspwndList[i]);
        ThreadUnlockPti(ptiCurrent, &tlptiList[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\multimon.c ===
/****************************** Module Header ******************************\
* Module Name: multimon.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multimonitor APIs.
*
* History:
* 27-Sep-1996 adams     Stub implementation for NT 5.
* 20-Feb-1997 adams     Port from NT4 SP3.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/* last monitor the cursor was clipped to */
PMONITOR gpMonitorMouse;

/***************************************************************************\
* ClipPointToDesktop
*
* Clips the point the nearest monitor on the desktop.
*
* Arguments:
*     lppt - The point to clip.
*
* History:
* 22-Sep-1996 adams     Created.
* 04-Sep-1998 MCostea   Use _MonitorFromPoint()
\***************************************************************************/

void
ClipPointToDesktop(LPPOINT lppt)
{
    PMONITOR        pMonitor;

    UserAssert(!gpDispInfo->fDesktopIsRect &&
               "You shouldn't call this function if the desktop is a rectangle.\n"
               "Just clip to gpsi->rcScreen instead.");

    /*
     * Optimization: The cursor is likely to be on the monitor it was last on,
     * so check for that case.
     */
    if (gpMonitorMouse != NULL && PtInRect(&gpMonitorMouse->rcMonitor, *lppt)) {
        return;
    }

    pMonitor = _MonitorFromPoint(*lppt, MONITOR_DEFAULTTONEAREST);

    /*
     * Remember the monitor the cursor is on.
     */
    gpMonitorMouse = pMonitor;

    if (lppt->x < pMonitor->rcMonitor.left) {
        lppt->x = pMonitor->rcMonitor.left;
    } else if (lppt->x >= pMonitor->rcMonitor.right) {
        lppt->x = pMonitor->rcMonitor.right-1;
    }
    if (lppt->y < pMonitor->rcMonitor.top) {
        lppt->y = pMonitor->rcMonitor.top;
    } else if (lppt->y >= pMonitor->rcMonitor.bottom) {
        lppt->y = pMonitor->rcMonitor.bottom-1;
    }
}

/***************************************************************************\
* xxxEnumDisplayMonitors
*
* Enumerates the monitors in a display.
*
* Arguments:
*     hdcPaint  - An HDC with a particular visible region. The HDC
*         passed to lpfnEnum will have the capabilities of that monitor,
*         with its visible region clipped to the monitor and hdcPaint.
*         If hdcPaint is NULL, the hdcMonitor passed to lpfnEnum will be NULL.
*
*     lprcClip  - A rectangle to clip the area to. If hdcPaint is non-NULL,
*         the coordinates have the origin of hdcPaint. If hdcPaint is NULL,
*         the coordinates are virtual screen coordinates. If lprcClip is NULL,
*         no clipping is performed.
*
*     lpfnEnum  - The enumeration function.
*
*     dwData    - Application-defined data that is passed through to the
*         enumeration function.
*
*     fInternal - TRUE if the callback is in the kernel, FALSE otherwise.
*
* History:
* 22-Sep-1996 adams     Created.
\***************************************************************************/

BOOL
xxxEnumDisplayMonitors(
    HDC             hdcPaint,
    LPRECT          lprcPaint,
    MONITORENUMPROC lpfnEnum,
    LPARAM          lData,
    BOOL            fInternal)
{
    RECT            rcPaint;
    POINT           ptOrg;
    RECT            rcMonitorPaint;
    BOOL            fReturn;
    PMONITOR        pMonitor;
    TL              tlpMonitor;
    PTHREADINFO     ptiCurrent = PtiCurrent();
    PDCE            pdcePaint;
    HDC             hdcMonitor;
    PWND            pwndOrg;

    /*
     * Validate the DC passed in.
     */
    if (hdcPaint) {

        if ((pdcePaint = LookupDC(hdcPaint)) == NULL) {
            RIPMSG0(RIP_WARNING, "EnumDisplayMonitors: LookupDC failed");
            return FALSE;
        }

        pwndOrg = pdcePaint->pwndOrg;

        /*
         * Intersect the painting area with the clipbox.  If there
         * isn't anything, bail out now.
         */
        if (GreGetClipBox(hdcPaint, &rcPaint, FALSE) == NULLREGION)
            return TRUE;

        if (lprcPaint && !IntersectRect(&rcPaint, &rcPaint, lprcPaint))
            return TRUE;

        /*
         * rcPaint is in dc coordinates.  We must convert to screen
         * coords so we can intersect with monitors.
         */
        GreGetDCOrg(hdcPaint, &ptOrg);
        OffsetRect(&rcPaint, ptOrg.x, ptOrg.y);
    } else {
        CopyRect(&rcPaint, &gpDispInfo->rcScreen);
        if (lprcPaint && !IntersectRect(&rcPaint, &rcPaint, lprcPaint))
            return TRUE;
    }

    fReturn = TRUE;

    for (pMonitor = gpDispInfo->pMonitorFirst; pMonitor != NULL;
                pMonitor = pMonitor->pMonitorNext) {

        /*
         * Note: the check for MONF_VISIBLE was removed to allow mirror drivers
         * to see monitor specific updates.
         */
        if (!IntersectRect(&rcMonitorPaint, &rcPaint, &pMonitor->rcMonitor)) {
            continue;
        }

        if (hdcPaint) {

            if ((hdcMonitor = GetMonitorDC(pdcePaint, pMonitor)) == NULL) {
                RIPMSG0(RIP_WARNING, "EnumDisplayMonitors: GetMonitorDC failed");
                return FALSE;
            }

            OffsetRect(&rcMonitorPaint, -ptOrg.x, -ptOrg.y);
            GreIntersectClipRect(
                    hdcMonitor,
                    rcMonitorPaint.left,
                    rcMonitorPaint.top,
                    rcMonitorPaint.right,
                    rcMonitorPaint.bottom);
        } else {

            hdcMonitor = NULL;
        }

        ThreadLockAlwaysWithPti(ptiCurrent, pMonitor, &tlpMonitor);

        if (fInternal) {
            fReturn = (*lpfnEnum) (
                    (HMONITOR) pMonitor,
                    hdcMonitor,
                    &rcMonitorPaint,
                    lData);

        } else {
            fReturn = xxxClientMonitorEnumProc(
                    PtoH(pMonitor),
                    hdcMonitor,
                    &rcMonitorPaint,
                    lData,
                    lpfnEnum);
        }

        /*
         * We just called back and the monitor has been freed if
         * ThreadUnlock returns NULL. The entire monitor configuration may
         * have changed, the monitors may have been rearranged, so just stop
         * enumerating at this point.
         */
        if (ThreadUnlock(&tlpMonitor) == NULL) {
            fReturn = FALSE;
        }

        if (hdcMonitor)
            ReleaseCacheDC(hdcMonitor, FALSE);

        if (!fReturn)
            break;

        /*
         * Revalidate hdcPaint, since it could have been messed with
         * in the callback.
         */
        if (hdcPaint) {
            if ((pdcePaint = LookupDC(hdcPaint)) == NULL) {
                RIPMSG0(RIP_WARNING, "EnumDisplayMonitors: LookupDC failed");
                return FALSE;
            }

            if (pdcePaint->pwndOrg != pwndOrg) {
                RIPMSG0(RIP_WARNING, "EnumDisplayMonitors: wrong window");
                return FALSE;
            }
        }
    }

    return fReturn;
}

/***************************************************************************\
* DestroyMonitor
*
* This function doesn't keep track of the visible monitors count because
* it assumes that after it was called the count will be recalculated, such
* as the case during mode changes. For a final unlock the monitor will have
* been removed from the monitor list already, so the count doesn't need to
* be recalculated.
*
* 5-May-1998    vadimg      created
\***************************************************************************/

void DestroyMonitor(PMONITOR pMonitor)
{
    UserAssert(pMonitor);

    /*
     * Remove references to this monitor from the global data.
     */
    if (pMonitor == gpMonitorMouse) {
        gpMonitorMouse = NULL;
    }

    /*
     * Remove from the monitor list.
     */
    REMOVE_FROM_LIST(MONITOR, gpDispInfo->pMonitorFirst, pMonitor, pMonitorNext);

    /*
     * Make sure the primary monitor points to a valid monitor. During the
     * mode changes the primary monitor will be recalculated as appropriate.
     */
    if (pMonitor == gpDispInfo->pMonitorPrimary) {
        gpDispInfo->pMonitorPrimary = gpDispInfo->pMonitorFirst;
    }

    if (HMMarkObjectDestroy(pMonitor)) {

        if (pMonitor->hrgnMonitor) {
           GreDeleteObject(pMonitor->hrgnMonitor);
        }
    
        HMFreeObject(pMonitor);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\newmouse.c ===
/****************************** Module Header ******************************\
* Module Name: newmouse.c
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Implements new mouse acceleration algorithm.
*
* History:
* 10-12-2000 JasonSch       Adapted code from StevieB
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef SUBPIXEL_MOUSE

/*
 * Globals.
 */
BOOL gbNewMouseInit;

#define MIN_REFRESH 60
#define MIN_RESOLUTION 96

/*
 * Constants for FixedPoint Math.
 */
#define FP_SHIFT        16    // number of binary decimal digits
#define FP_SCALE        65536 // (2^(32-FP_SHIFT)), used during conversion of
                              // floats
#define FP_MASK         0x0000ffff // mask to retrieve the remainder

#define FIXP2INT(n)  ((INT)((n) >> FP_SHIFT))
#define FIXP_REM(n)  ((n) & FP_MASK)
#define INT2FIXP(n)  ((FIXPOINT)((n) << FP_SHIFT))

/*
 * This function divides two fixed point numbers and returns the result.
 * Notice how the final result is shifted back.
 */
__inline FIXPOINT Div_Fixed(FIXPOINT f1, FIXPOINT f2)
{
    return ((f1 << FP_SHIFT) / f2);
}

/*
 * This function mulitplies two fixed point numbers and returns the result.
 * Notice how the final result is shifted back.
 */
__inline FIXPOINT Mul_Fixed(FIXPOINT f1, FIXPOINT f2)
{
    return (f1 * f2) >> FP_SHIFT;
}

/*
 * This function adds two fixed point numbers and returns the result.
 * Notice how no shifting is necessary.
 */
__inline FIXPOINT Add_Fixed(FIXPOINT f1, FIXPOINT f2)
{
    return f1 + f2;
}

/*
 * Build the curves at boot and when the user changes the setting in the UI.
 * The algorithm uses the speedscale, the screenscale, and mousescale to
 * interpolate the new curves. 
 */
VOID
BuildMouseAccelerationCurve(
    PMONITOR pMonitor)
{
    int i, res, vrefresh;
    HDC hdc;
    FIXPOINT ScreenScale, SpeedScale;
    /*
     * 229376 is 3.5 in FP. This is strong magic, so don't sweat it too much!
     * Ideally we'd calculate this number, but USB mice don't report their
     * refresh rate, which we'd need:
     *
     * MouseScale = Div_Fixed(INT2FIXP(MouseRefresh), INT2FIXP(MouseDPI));
     */
    FIXPOINT MouseScale = 229376;

    if (!gbNewMouseInit) {
        return;
    }

    /*
     * Dividing by 10 is somewhat ad hoc -- this divisor controls the
     * overall "height" of the curves, but does not affect the shape.
     */
    SpeedScale = INT2FIXP(gMouseSensitivity) / 10;

    hdc = GreCreateDisplayDC(pMonitor->hDev, DCTYPE_DIRECT, FALSE);
    res = GreGetDeviceCaps(hdc, LOGPIXELSX);
    if (res < MIN_RESOLUTION) {
        /*
         * While there is no evidence that display drivers can return bogus
         * values for the resolution, we have no reason to think they won't
         * (see below). So we clamp the value to a reasonable minimum.
         */
        RIPMSG2(RIP_WARNING,
                "GreGetDeviceCaps(0x%p, LOGPIXELSX) returned 0n%d", hdc, res);
        res = MIN_RESOLUTION;
    }

    /*
     * Some video cards lie to us and tell us the refresh rate is 1. There are
     * probably others that lie in different ways, so let's make sure there's
     * some sane mimimum value, or the mouse will be entirely too slow.
     * ALL YOUR REFRESH ARE BELONG TO US!
     */
    vrefresh = GreGetDeviceCaps(hdc, VREFRESH);
    if (vrefresh < MIN_REFRESH) {
        vrefresh = MIN_REFRESH;
    }
    ScreenScale = INT2FIXP(vrefresh) / res;
    GreDeleteDC(hdc);

    for (i = 0; i < ARRAY_SIZE(pMonitor->xTxf); i++) {
        pMonitor->yTxf[i] = Mul_Fixed(Mul_Fixed(gDefyTxf[i], ScreenScale), SpeedScale);
        pMonitor->xTxf[i] = Mul_Fixed(gDefxTxf[i], MouseScale);
    }

    /*
     * Build the new curves in a slope-intercept format.
     */
    for (i = 1; i < ARRAY_SIZE(pMonitor->xTxf); i++) {
        /*
         * Make sure we don't divide by zero (this could happen if bogus values
         * are in the registry).
         */
        if ((pMonitor->xTxf[i] - pMonitor->xTxf[i-1]) == 0) {
            RIPMSG1(RIP_ERROR, "Bad data in registry for new mouse (i = %d)", i);
            pMonitor->slope[i-1] = pMonitor->yint[i-1] = 0;
            continue;
        }

        pMonitor->slope[i-1] = Div_Fixed(pMonitor->yTxf[i] - pMonitor->yTxf[i-1], pMonitor->xTxf[i] - pMonitor->xTxf[i-1]);
        pMonitor->yint[i-1] = pMonitor->yTxf[i-1] - Mul_Fixed(pMonitor->slope[i-1], pMonitor->xTxf[i-1]);
    }
}

VOID
DoNewMouseAccel(
    INT *dx,
    INT *dy)
{
    static FIXPOINT fpDxAcc = 0, fpDyAcc = 0;
    static int i_last = 0;
    int i = 0;
    PMONITOR pMonitor = _MonitorFromPoint(gptCursorAsync, MONITOR_DEFAULTTOPRIMARY);
    FIXPOINT accel, fpDxyMag;
	
    /*
     * Convert Mouse X and Y to FixedPoint.
     */
    FIXPOINT fpDx = INT2FIXP(*dx);
    FIXPOINT fpDy = INT2FIXP(*dy);

    /*
     * During TS operations it's possible for a mouse move to be queued up but
     * for gpDispInfo->pMonitorFirst/Primary to be NULL. Let's try not to fault
     * in that case. Windows Bug #413159.
     */
    if (pMonitor == NULL) {
        RIPMSG0(RIP_WARNING, "Ignoring mouse movement w/ no monitor set.");
        return;
    }

    // Get the magnitude
    fpDxyMag = max(abs(fpDx), abs(fpDy)) + (min(abs(fpDx), abs(fpDy)) / 2);

    /*
     * Ensure we don't divide by 0.
     */
    if (fpDxyMag != 0) {
        /*
         * Find the position MagXY from the interpolate acceleration curves.
         * It's possible we won't find one so we'll just use the biggest (i.e.,
         * the last entry in the array).
         */
        while (i < (ARRAY_SIZE(pMonitor->xTxf) - 1) && fpDxyMag > pMonitor->xTxf[i]) {
            ++i;
        }
        --i;


        accel = Div_Fixed(Add_Fixed(Mul_Fixed(pMonitor->slope[i], fpDxyMag), pMonitor->yint[i]), fpDxyMag);

        /*
         * If change of slope from last time then average the accel value using
         * i_last and the current i.
         */
        if (i_last != i) {
            accel = (accel + Div_Fixed((Mul_Fixed(pMonitor->slope[i_last], fpDxyMag) + pMonitor->yint[i_last]), fpDxyMag)) / 2;
            i_last = i;
        }

        /*
         * Calculate the multiplier for the mouse data.
         */
        fpDx = Mul_Fixed(accel, fpDx) + fpDxAcc;
        fpDy = Mul_Fixed(accel, fpDy) + fpDyAcc;

        /*
         * Store the remainder of the calculated X and Y. This gets added in
         * next time. 
         */
        fpDxAcc = FIXP_REM(fpDx);
        fpDyAcc = FIXP_REM(fpDy);

        /*
         * Convert back to integer.
         */
        *dx = FIXP2INT(fpDx);
        *dy = FIXP2INT(fpDy);
    }
}

VOID
ReadDefaultAccelerationCurves(
    PUNICODE_STRING pProfileUserName)
{
    FIXPOINT xTxf[SM_POINT_CNT], yTxf[SM_POINT_CNT];
    DWORD cbSizeX, cbSizeY;

    /*
     * The default curves will reside in the .DEFAULT user profile but can be
     * overridden on a per-user basis.
     */
    cbSizeX = FastGetProfileValue(pProfileUserName, PMAP_MOUSE,
                                  (LPWSTR)STR_SMOOTHMOUSEXCURVE, NULL,
                                  (LPBYTE)&xTxf, sizeof(xTxf), 0);

    cbSizeY = FastGetProfileValue(pProfileUserName, PMAP_MOUSE,
                                  (LPWSTR)STR_SMOOTHMOUSEYCURVE, NULL,
                                  (LPBYTE)&yTxf, sizeof(yTxf), 0);

    /* 
     * Check if we successfully read the correct amount of data from both keys.
     * If not, and we're reading the .DEFAULT profile, copy in the default
     * values.
     */
    if (cbSizeX == sizeof(xTxf) && cbSizeY == sizeof(yTxf)) {
        RtlCopyMemory(gDefxTxf, xTxf, sizeof(xTxf));
        RtlCopyMemory(gDefyTxf, yTxf, sizeof(yTxf));
    } else if (!gbNewMouseInit) {
        /*
         * Default values.
         */
        static FIXPOINT _xTxf[SM_POINT_CNT] = {0x0, 0x6E15, 0x14000, 0x3DC29, 0x280000};
        static FIXPOINT _yTxf[SM_POINT_CNT] = {0x0, 0x15EB8, 0x54CCD, 0x184CCD, 0x2380000};

        RtlCopyMemory(gDefxTxf, _xTxf, sizeof(_xTxf));
        RtlCopyMemory(gDefyTxf, _yTxf, sizeof(_yTxf));
    }

    gbNewMouseInit = TRUE;
}

VOID
ResetMouseAccelerationCurves(
    VOID)
{
    PMONITOR pMonitor = gpDispInfo->pMonitorFirst;

    CheckCritIn();
    for (; pMonitor != NULL; pMonitor = pMonitor->pMonitorNext) {
        BuildMouseAccelerationCurve(pMonitor);
    }
}

#endif // SUBPIXEL_MOUSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\msgbeep.c ===
/****************************** Module Header ******************************\
* Module Name: msgbeep.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the xxxMessageBox API and related functions.
*
* History:
*  6-26-91 NigelT      Created it with some wood and a few nails
*  7 May 92 SteveDav   Getting closer to the real thing
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <ntddbeep.h>
#include <mmsystem.h>

/***************************************************************************\
* xxxOldMessageBeep (API)
*
* Send a beep to the beep device
*
* History:
* 09-25-91 JimA         Created.
\***************************************************************************/

BOOL xxxOldMessageBeep()
{
    BOOL b;
    if (TEST_PUDF(PUDF_BEEP)) {
        LeaveCrit();
        b = UserBeep(440, 125);
        EnterCrit();
        return b;
    } else {
        _UserSoundSentryWorker();
    }

    return TRUE;
}

/***************************************************************************\
* xxxMessageBeep (API)
*
*
* History:
*  6-26-91  NigelT      Wrote it.
* 24-Mar-92 SteveDav    Changed interface - no passing of strings
*                       If WINMM cannot be found or loaded, then use speaker
\***************************************************************************/

BOOL xxxMessageBeep(
    UINT dwType)
{
    UINT sndid;
    PTHREADINFO  pti = PtiCurrent();

    if (pti->TIF_flags & TIF_SYSTEMTHREAD) {
        xxxOldMessageBeep();
        return TRUE;
    }

    if (!TEST_PUDF(PUDF_BEEP)) {
        _UserSoundSentryWorker();
        return TRUE;
    }

    switch(dwType & MB_ICONMASK) {
    case MB_ICONHAND:
        sndid = USER_SOUND_SYSTEMHAND;
        break;

    case MB_ICONQUESTION:
        sndid = USER_SOUND_SYSTEMQUESTION;
        break;

    case MB_ICONEXCLAMATION:
        sndid = USER_SOUND_SYSTEMEXCLAMATION;
        break;

    case MB_ICONASTERISK:
        sndid = USER_SOUND_SYSTEMASTERISK;
        break;

    default:
        sndid = USER_SOUND_DEFAULT;
        break;
    }

    if (gspwndLogonNotify) {
        _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, LOGON_PLAYEVENTSOUND, sndid);
    }

    _UserSoundSentryWorker();

    return TRUE;
}

/***************************************************************************\
* xxxPlayEventSound
*
* Play a sound
*
* History:
* 09-25-91 JimA         Created.
\***************************************************************************/

VOID PlayEventSound(UINT idSound)
{
    PTHREADINFO    pti = PtiCurrent();

    if (!TEST_PUDF(PUDF_EXTENDEDSOUNDS))
        return;

    if (pti->TIF_flags & TIF_SYSTEMTHREAD)
        return;

    if (gspwndLogonNotify) {
        _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, LOGON_PLAYEVENTSOUND, idSound);
    }

//  NOTE -- we should only flash SoundSentry if a sound is played.  With the
//  new technique of posting to WinLogon, we can't determine this here.
//   _UserSoundSentryWorker();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\paint.c ===
/****************************** Module Header ******************************\
* Module Name: paint.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the APIs used to begin and end window painting.
*
* History:
* 27-Oct-1990 DarrinM   Created.
* 12-Feb-1991 IanJa     HWND revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxFillWindow (not an API)
*
* pwndBrush - The brush is aligned with with client rect of this window.
*             It is usually either pwndPaint or pwndPaint's parent.
*
* pwndPaint - The window to paint.
* hdc       - The DC to paint in.
* hbr       - The brush to use.
*
* Returns TRUE if successful, FALSE if not.
*
* History:
* 15-Nov-1990 DarrinM   Ported from Win 3.0 sources.
* 21-Jan-1991 IanJa     Prefix '_' denoting exported function.
\***************************************************************************/

BOOL xxxFillWindow(
    PWND   pwndBrush,
    PWND   pwndPaint,
    HDC    hdc,
    HBRUSH hbr)
{
    RECT rc;

    CheckLock(pwndBrush);
    CheckLock(pwndPaint);

    /*
     * If there is no pwndBrush (sometimes the parent), use pwndPaint.
     */
    if (pwndBrush == NULL)
        pwndBrush = pwndPaint;

    if (UT_GetParentDCClipBox(pwndPaint, hdc, &rc))
        return xxxPaintRect(pwndBrush, pwndPaint, hdc, hbr, &rc);

    return TRUE;
}

/***************************************************************************\
* xxxPaintRect
*
* pwndBrush - The brush is aligned with with client rect of this window.
*             It is usually either pwndPaint or pwndPaint's parent.
*
* pwndPaint - The window to paint in.
* hdc       - The DC to paint in.
* hbr       - The brush to use.
* lprc      - The rectangle to paint.
*
* History:
* 15-Nov-1990 DarrinM   Ported from Win 3.0 sources.
* 21-Jan-1991 IanJa     Prefix '_' denoting exported function.
\***************************************************************************/

BOOL xxxPaintRect(
    PWND   pwndBrush,
    PWND   pwndPaint,
    HDC    hdc,
    HBRUSH hbr,
    LPRECT lprc)
{
    POINT ptOrg;

    CheckLock(pwndBrush);
    CheckLock(pwndPaint);

    if (pwndBrush == NULL) {
        pwndBrush = PtiCurrent()->rpdesk->pDeskInfo->spwnd;
    }

    if (pwndBrush == PWNDDESKTOP(pwndBrush)) {
        GreSetBrushOrg(
                hdc,
                0,
                0,
                &ptOrg);
    } else {
        GreSetBrushOrg(
                hdc,
                pwndBrush->rcClient.left - pwndPaint->rcClient.left,
                pwndBrush->rcClient.top - pwndPaint->rcClient.top,
                &ptOrg);
    }

    /*
     * If hbr < CTLCOLOR_MAX, it isn't really a brush but is one of our
     * special color values.  Translate it to the appropriate WM_CTLCOLOR
     * message and send it off to get back a real brush.  The translation
     * process assumes the CTLCOLOR*** and WM_CTLCOLOR*** values map directly.
     */
    if (hbr < (HBRUSH)CTLCOLOR_MAX) {
        hbr = xxxGetControlColor(pwndBrush,
                                 pwndPaint,
                                 hdc,
                                 HandleToUlong(hbr) + WM_CTLCOLORMSGBOX);
    }

    FillRect(hdc, lprc, hbr);

    GreSetBrushOrg(hdc, ptOrg.x, ptOrg.y, NULL);


    return TRUE;
}

/***************************************************************************\
* DeleteMaybeSpecialRgn
*
* Deletes a GDI region, making sure it is not a special region.
*
* History:
* 26-Feb-1992 MikeKe    from win3.1
\***************************************************************************/

VOID DeleteMaybeSpecialRgn(
    HRGN hrgn)
{
    if (hrgn > HRGN_SPECIAL_LAST) {
        GreDeleteObject(hrgn);
    }
}



/***************************************************************************\
* GetNCUpdateRgn
*
* Gets the update region which includes the non-client area.
*
* History:
* 26-Feb-1992 MikeKe    From win3.1
\***************************************************************************/

HRGN GetNCUpdateRgn(
    PWND pwnd,
    BOOL fValidateFrame)
{
    HRGN hrgnUpdate;

    if (pwnd->hrgnUpdate > HRGN_FULL) {

        /*
         * We must make a copy of our update region, because
         * it could change if we send a message, and we want to
         * make sure the whole thing is used for drawing our
         * frame and background.  We can't use a global
         * temporary region, because more than one app may
         * be calling this routine.
         */
        hrgnUpdate = CreateEmptyRgnPublic();

        if (hrgnUpdate == NULL) {
            hrgnUpdate = HRGN_FULL;
        } else if (CopyRgn(hrgnUpdate, pwnd->hrgnUpdate) == ERROR) {
            GreDeleteObject(hrgnUpdate);
            hrgnUpdate = HRGN_FULL;
        }

        if (fValidateFrame) {

            /*
             * Now that we've taken care of any frame drawing,
             * intersect the update region with the window's
             * client area.  Otherwise, apps that do ValidateRects()
             * to draw themselves (e.g., WinWord) won't ever
             * subtract off the part of the update region that
             * overlaps the frame but not the client.
             */
            CalcWindowRgn(pwnd, ghrgnInv2, TRUE);

            switch (IntersectRgn(pwnd->hrgnUpdate,
                                 pwnd->hrgnUpdate,
                                 ghrgnInv2)) {
            case ERROR:
                /*
                 * If an error occured, we can't leave things as
                 * they are: invalidate the whole window and let
                 * BeginPaint() take care of it.
                 */
                GreDeleteObject(pwnd->hrgnUpdate);
                pwnd->hrgnUpdate = HRGN_FULL;
                break;

            case NULLREGION:
                /*
                 * There is nothing in the client area to repaint.
                 * Blow the region away, and decrement the paint count
                 * if possible.
                 */
                GreDeleteObject(pwnd->hrgnUpdate);
                pwnd->hrgnUpdate = NULL;
                ClrWF(pwnd, WFUPDATEDIRTY);
                if (!TestWF(pwnd, WFINTERNALPAINT))
                    DecPaintCount(pwnd);
                break;
            }
        }

    } else {
        hrgnUpdate = pwnd->hrgnUpdate;
    }

    return hrgnUpdate;
}

/***************************************************************************\
* xxxSendNCPaint
*
* Sends a WM_NCPAINT message to a window.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxSendNCPaint(
    PWND pwnd,
    HRGN hrgnUpdate)
{
    CheckLock(pwnd);

    /*
     * Clear the WFSENDNCPAINT bit...
     */
    ClrWF(pwnd, WFSENDNCPAINT);

    /*
     * If the window is active, but its FRAMEON bit hasn't
     * been set yet, set it and make sure that the entire frame
     * gets redrawn when we send the NCPAINT.
     */
    if ((pwnd == PtiCurrent()->pq->spwndActive) && !TestWF(pwnd, WFFRAMEON)) {
        SetWF(pwnd, WFFRAMEON);
        hrgnUpdate = HRGN_FULL;
        ClrWF(pwnd, WFNONCPAINT);
    }

    /*
     * If PixieHack() has set the WM_NCPAINT bit, we must be sure
     * to send with hrgnClip == HRGN_FULL.  (see PixieHack() in wmupdate.c)
     */
    if (TestWF(pwnd, WFPIXIEHACK)) {
        ClrWF(pwnd, WFPIXIEHACK);
        hrgnUpdate = HRGN_FULL;
    }

    if (hrgnUpdate)
        xxxSendMessage(pwnd, WM_NCPAINT, (WPARAM)hrgnUpdate, 0L);
}



/***************************************************************************\
* xxxSendChildNCPaint
*
* Sends WM_NCPAINT message to the immediate children of a window.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxSendChildNCPaint(
    PWND pwnd)
{
    TL tlpwnd;

    CheckLock(pwnd);

    ThreadLockNever(&tlpwnd);
    pwnd = pwnd->spwndChild;
    while (pwnd != NULL) {
        if ((pwnd->hrgnUpdate == NULL) && TestWF(pwnd, WFSENDNCPAINT)) {
            ThreadLockExchangeAlways(pwnd, &tlpwnd);
            xxxSendNCPaint(pwnd, HRGN_FULL);
        }

        pwnd = pwnd->spwndNext;
    }

    ThreadUnlock(&tlpwnd);
}

/***************************************************************************\
* xxxBeginPaint
*
* Revalidation Note:
* We MUST return NULL if the window is deleted during xxxBeginPaint because
* its DCs are released upon deletion, and we shouldn't return a *released* DC!
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

HDC xxxBeginPaint(
    PWND          pwnd,
    LPPAINTSTRUCT lpps)
{
    HRGN hrgnUpdate;
    HDC  hdc;
    BOOL fSendEraseBkgnd;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if (TEST_PUDF(PUDF_DRAGGINGFULLWINDOW))
        SetWF(pwnd, WFSTARTPAINT);

    /*
     * We're processing a WM_PAINT message: clear this flag.
     */
    ClrWF(pwnd, WFPAINTNOTPROCESSED);

    /*
     * If this bit gets set while we are drawing the frame we will need
     * to redraw it.
     *
     * If necessary, send our WM_NCPAINT message now.
     *
     * please heed these notes
     *
     * We have to send this message BEFORE we diddle hwnd->hrgnUpdate,
     * because an app may call ValidateRect or InvalidateRect in its
     * handler, and it expects what it does to affect what gets drawn
     * in the later WM_PAINT.
     *
     * It is possible to get an invalidate when we leave the critical
     * section below, therefore we loop until UPDATEDIRTY is clear
     * meaning there were no additional invalidates.
     */
    if (TestWF(pwnd, WFSENDNCPAINT)) {

        do {
            ClrWF(pwnd, WFUPDATEDIRTY);
            hrgnUpdate = GetNCUpdateRgn(pwnd, FALSE);
            xxxSendNCPaint(pwnd, hrgnUpdate);
            DeleteMaybeSpecialRgn(hrgnUpdate);
        } while (TestWF(pwnd, WFUPDATEDIRTY));

    } else {
        ClrWF(pwnd, WFUPDATEDIRTY);
    }

    /*
     * Hide the caret if needed.  Do this before we get the DC so
     * that if HideCaret() gets and releases a DC we will be able
     * to reuse it later here.
     * No need to DeferWinEventNotify() since pwnd is locked.
     */
    if (pwnd == PtiCurrent()->pq->caret.spwnd)
        zzzInternalHideCaret();

    /*
     * Send the check for sending an WM_ERASEBKGND to the
     * window.
     */
    if (fSendEraseBkgnd = TestWF(pwnd, WFSENDERASEBKGND)) {
        ClrWF(pwnd, WFERASEBKGND);
        ClrWF(pwnd, WFSENDERASEBKGND);
    }

    /*
     * Validate the entire window.
     */
    if (NEEDSPAINT(pwnd))
        DecPaintCount(pwnd);

    ClrWF(pwnd, WFINTERNALPAINT);

    hrgnUpdate = pwnd->hrgnUpdate;
    pwnd->hrgnUpdate = NULL;

    if (TestWF(pwnd, WFDONTVALIDATE)) {

        if (ghrgnUpdateSave == NULL) {
            ghrgnUpdateSave = CreateEmptyRgn();
        }

        if (ghrgnUpdateSave != NULL) {
            UnionRgn(ghrgnUpdateSave, ghrgnUpdateSave, hrgnUpdate);
            gnUpdateSave++;
        }
    }

    /*
     * Clear these flags for backward compatibility
     */
    lpps->fIncUpdate =
    lpps->fRestore   = FALSE;

    lpps->hdc =
    hdc       = _GetDCEx(pwnd,
                         hrgnUpdate,
                         DCX_USESTYLE | DCX_INTERSECTRGN);

    if (UT_GetParentDCClipBox(pwnd, hdc, &lpps->rcPaint)) {

        /*
         * If necessary, erase our background, and possibly deal with
         * our children's frames and backgrounds.
         */
        if (fSendEraseBkgnd)
            xxxSendEraseBkgnd(pwnd, hdc, hrgnUpdate);
    }

    /*
     * Now that we're completely erased, see if there are any children
     * that couldn't draw their own frames because their update regions
     * got deleted.
     */
    xxxSendChildNCPaint(pwnd);

    /*
     * The erase and frame operation has occured. Clear the WFREDRAWIFHUNG
     * bit here. We don't want to clear it until we know the erase and
     * frame has occured, so we know we always have a consistent looking
     * window.
     */
    ClearHungFlag(pwnd, WFREDRAWIFHUNG);

    lpps->fErase = (TestWF(pwnd, WFERASEBKGND) != 0);

    return hdc;
}

/***************************************************************************\
* xxxEndPaint (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxEndPaint(
    PWND          pwnd,
    LPPAINTSTRUCT lpps)
{
    CheckLock(pwnd);

    ReleaseCacheDC(lpps->hdc, TRUE);

    if (TestWF(pwnd, WFDONTVALIDATE)) {

        if (ghrgnUpdateSave != NULL) {

            InternalInvalidate3(pwnd,
                                ghrgnUpdateSave,
                                RDW_INVALIDATE | RDW_ERASE);

            if (--gnUpdateSave == 0) {
                GreDeleteObject(ghrgnUpdateSave);
                ghrgnUpdateSave = NULL;
            }
        }

        ClrWF(pwnd, WFDONTVALIDATE);
    }

    ClrWF(pwnd, WFWMPAINTSENT);

    /*
     * This used to check that the update-region was empty before
     * doing the clear.  However, this caused a problem with WOW
     * amipro/approach hanging.  They were invalidating rects in
     * their WM_PAINT handler, and allowing the defwindowproc to
     * perform the validation for them.  Since we were blocking
     * the BeginPaint in this case, it sent them into a infinite
     * loop (see bug 19036).
     */
    ClrWF(pwnd, WFSTARTPAINT);

    /*
     * Reshow the caret if needed, but AFTER we've released the DC.
     * This way ShowCaret() can reuse the DC we just released.
     */
    if (pwnd == PtiCurrent()->pq->caret.spwnd)
        zzzInternalShowCaret();

    return TRUE;
}

/***************************************************************************\
* GetLastChild
*
\***************************************************************************/

PWND GetLastChild(PWND pwnd)
{
    PWND pwndLast;

    pwnd = pwnd->spwndChild;
    pwndLast = pwnd;

    while (pwnd != NULL) {
        pwndLast = pwnd;
        pwnd = pwnd->spwndNext;
    }

    return pwndLast;
}

/***************************************************************************\
* xxxCompositedTraverse
*
* Uses pre-order traversal starting with the last child to render the
* windows in a bottom-up order.
*
* 9/30/1999       vadimg      created
\***************************************************************************/

BOOL xxxCompositedTraverse(PWND pwnd)
{
    TL tlpwnd;
    BOOL fPainted = FALSE;

    CheckLock(pwnd);

    if (NEEDSPAINT(pwnd)) {
        xxxSendMessage(pwnd, WM_PAINT, 0, 0);
        fPainted = TRUE;
    }

    pwnd = GetLastChild(pwnd);
    ThreadLock(pwnd, &tlpwnd);

    while (pwnd != NULL) {

        if (xxxCompositedTraverse(pwnd)) {
            fPainted = TRUE;
        }
        pwnd = pwnd->spwndPrev;

        if (ThreadLockExchange(pwnd, &tlpwnd) == NULL) {
            break;
        }
    }

    ThreadUnlock(&tlpwnd);
    return fPainted;
}

/***************************************************************************\
* xxxCompositedPaint
*
* 9/30/1999       vadimg      created
\***************************************************************************/

VOID xxxCompositedPaint(PWND pwnd)
{
    BOOL fPainted;
    HBITMAP hbm, hbmOld;
    PREDIRECT prdr;
    HDC hdc;
    LPRECT prc;
    SIZE size;
    POINT pt;

    CheckLock(pwnd);
    UserAssert(TestWF(pwnd, WEFCOMPOSITED));

    SetWF(pwnd, WEFPCOMPOSITING);

    /*
     * Render the child windows in a bottom-up order.
     */
    fPainted = xxxCompositedTraverse(pwnd);

    ClrWF(pwnd, WEFPCOMPOSITING);

    /*
     * While we were compositing, an invalid region may have accumulated.
     * So, let's go and invalidate that area of the window.
     */
    BEGINATOMICCHECK();
    prdr = _GetProp(pwnd, PROP_LAYER, TRUE);
    if (prdr != NULL && prdr->hrgnComp != NULL) {

        xxxInternalInvalidate(pwnd, prdr->hrgnComp, RDW_INVALIDATE |
                RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);

        if (prdr->hrgnComp != HRGN_FULL) {
            GreDeleteObject(prdr->hrgnComp);
        }

        prdr->hrgnComp = NULL;
    }
    ENDATOMICCHECK();

#ifdef REDIRECTION
    if (TestWF(pwnd, WEFEXTREDIRECTED)) {
        return;
    }
#endif // REDIRECTION

    BEGINATOMICCHECK();

    if (fPainted && TestWF(pwnd, WEFPREDIRECTED)) {

        prdr = (PREDIRECT)_GetProp(pwnd, PROP_LAYER, TRUE);
        prc = &prdr->rcUpdate;
        hbm = prdr->hbm;
        UserAssert(hbm != NULL);

        if (TestWF(pwnd, WEFLAYERED)) {

            hbmOld = GreSelectBitmap(ghdcMem, hbm);

            size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
            size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

            pt.x = pt.y = 0;
            GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL, NULL,
                    &size, ghdcMem, &pt, 0, NULL, ULW_DEFAULT_ATTRIBUTES, prc);

            GreSelectBitmap(ghdcMem, hbmOld);
        } else {

            /*
             * Temporarily clear the redirected bit so that we can get the dc
             * with proper screen clipping.
             */
            ClrWF(pwnd, WEFPREDIRECTED);

            hbmOld = GreSelectBitmap(ghdcMem, hbm);
            hdc = _GetDCEx(pwnd, NULL, DCX_USESTYLE | DCX_WINDOW | DCX_CACHE);
    
            /*
             * Transfer the bits for the window from the redirection bitmap
             * to the screen.
             */
            GreBitBlt(hdc, prc->left, prc->top, prc->right - prc->left,
                    prc->bottom - prc->top, ghdcMem,
                    prc->left, prc->top, SRCCOPY, 0);
    
            _ReleaseDC(hdc);
            GreSelectBitmap(ghdcMem, hbmOld);
    
            /*
             * Restore the redirection bit on the window.
             */
            SetWF(pwnd, WEFPREDIRECTED);
        }

        SetRectEmpty(prc);
    }

    ENDATOMICCHECK();
}

/***************************************************************************\
* InternalDoPaint
*
* Return a window equal to or below pwnd, created by the current thread,
* which needs painting.
*
* pwnd       - Window to start searching from. Search is depth first.
* ptiCurrent - The current thread.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PWND xxxInternalDoPaint(
    PWND        pwnd,
    PTHREADINFO ptiCurrent)
{
    PWND pwndT;
    TL tlpwnd;

    /*
     * Enumerate all windows, top-down, looking for one that
     * needs repainting.  Skip windows of other tasks.
     */
    while (pwnd != NULL) {

        if (GETPTI(pwnd) == ptiCurrent) {

            if (TestWF(pwnd, WEFCOMPOSITED)) {

                ThreadLock(pwnd, &tlpwnd);

                xxxCompositedPaint(pwnd);
                pwnd = pwnd->spwndNext;

                if (ThreadUnlock(&tlpwnd) == NULL) {
                    return NULL;
                }
                continue;

            } else if (NEEDSPAINT(pwnd)) {

                /*
                 * If this window is transparent, we don't want to
                 * send it a WM_PAINT until all its siblings below it
                 * have been repainted.  If we find an unpainted sibling
                 * below, return it instead.
                 */
                if (TestWF(pwnd, WEFTRANSPARENT)) {

                    pwndT = pwnd;
                    while ((pwndT = pwndT->spwndNext) != NULL) {

                        /*
                         * Make sure sibling window belongs to same app
                         */
                        if ((GETPTI(pwndT) == ptiCurrent) && NEEDSPAINT(pwndT)) {

                            if (TestWF(pwndT, WEFTRANSPARENT))
                                continue;

                            return pwndT;
                        }
                    }
                }

                return pwnd;
            }
        }

        if (pwnd->spwndChild &&
                (pwndT = xxxInternalDoPaint(pwnd->spwndChild, ptiCurrent))) {

            return pwndT;
        }

        pwnd = pwnd->spwndNext;
    }

    return pwnd;
}

/***************************************************************************\
* DoPaint
*
* Looks at all the desktops for the window needing a paint and places a
* WM_PAINT in its queue.
*
* History:
* 16-Jul-91 DarrinM     Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxDoPaint(
    PWND  pwndFilter,
    LPMSG lpMsg)
{
    PWND        pwnd;
    PWND        pwndT;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwndFilter);

#if 0 // CHRISWIL: WIN95 SPECIFIC

    /*
     * If there is a system modal up and it is attached to another task,
     * DON'T do paints.  We don't want to return a message for a window in
     * another task!
     */
    if (hwndSysModal && (hwndSysModal->hq != hqCurrent)) {

        /*
         * Poke this guy so he wakes up at some point in the future,
         * otherwise he may never wake up to realize he should paint.
         * Causes hangs - e.g. Photoshop installation program
         *   PostThreadMessage32(Lpq(hqCurrent)->idThread, WM_NULL, 0, 0, 0);
         */
        return FALSE;
    }

#endif

    /*
     * If this is a system thread, then walk the windowstation desktop-list
     * to find the window which needs painting.  For other threads, we
     * reference off the thread-desktop.
     */
    if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD) {

        PWINDOWSTATION pwinsta;
        PDESKTOP       pdesk;

        if ((pwinsta = ptiCurrent->pwinsta) == NULL) {
            RIPMSG0(RIP_ERROR, "DoPaint: SYSTEMTHREAD does not have (pwinsta)");
            return FALSE;
        }

        pwnd = pwinsta->pTerm->spwndDesktopOwner;
        if (!NEEDSPAINT(pwnd)) {

            pwnd = NULL;
            for(pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
    
                if (pwnd = xxxInternalDoPaint(pdesk->pDeskInfo->spwnd, ptiCurrent))
                    break;
            }
        }

    } else {

        pwnd = xxxInternalDoPaint(ptiCurrent->rpdesk->pDeskInfo->spwnd,
                                  ptiCurrent);
    }

    if (pwnd != NULL) {

        if (!CheckPwndFilter(pwnd, pwndFilter))
            return FALSE;

        /*
         * We're returning a WM_PAINT message, so clear WFINTERNALPAINT so
         * it won't get sent again later.
         */
        if (TestWF(pwnd, WFINTERNALPAINT)) {

            ClrWF(pwnd, WFINTERNALPAINT);

            /*
             * If there is no update region, then no more paint for this
             * window.
             */
            if (pwnd->hrgnUpdate == NULL)
                DecPaintCount(pwnd);
        }

        /*
         * Set the STARTPAINT so that any other calls to BeginPaint while
         * painting is begin performed, will prevent painting on those
         * windows.
         *
         * Clear the UPDATEDIRTY since some apps (DBFast) don't call
         * GetUpdateRect, BeginPaint/EndPaint.
         */
        ClrWF(pwnd, WFSTARTPAINT);
        ClrWF(pwnd, WFUPDATEDIRTY);

        /*
         * If we get an invalidate between now and the time the app calls
         * BeginPaint() and the windows parent is not CLIPCHILDREN, then
         * the parent will paint in the wrong order.  So we are going to
         * cause the child to paint again.  Look in beginpaint and internal
         * invalidate for other parts of this fix.
         *
         * Set a flag to signify that we are in the bad zone.
         *
         * Must go up the parent links to make sure all parents have
         * WFCLIPCHILDREN set otherwise set the WFWMPAINTSENT flag.
         * This is to fix Excel spreadsheet and fulldrag. The speadsheet
         * parent window (class XLDESK) has WFCLIPCHILDREN set but it's
         * parent (class XLMAIN) doesn't. So the main window erases  the
         * background after the child window paints.
         *
         * JOHANNEC : 27-Jul-1994
         */
        
        /*
         * NT Bug 400167: As we walk up the tree, we need to stop short of
         * desktop windows and mother desktop windows.  We can't do a test
         * for WFCLIPCHILDREN on the mother desktop window's parent because
         * it doesn't exist.  This means that no desktop window will get 
         * WFWMPAINTSENT set, but the message window will be able to get 
         * WFWMPAINTSENT set.
         */
        
        pwndT = pwnd;
        while (pwndT && (GETFNID(pwndT) != FNID_DESKTOP)) {

            if (!TestWF(pwndT->spwndParent, WFCLIPCHILDREN)) {
                SetWF(pwnd, WFWMPAINTSENT);
                break;
            }

            pwndT = pwndT->spwndParent;
        }

        /*
         * If the top level "tiled" owner/parent of this window is iconed,
         * send a WM_PAINTICON rather than a WM_PAINT.  The wParam
         * is TRUE if this is the tiled window and FALSE if it is a
         * child/owned popup of the minimized window.
         *
         * BACKWARD COMPATIBILITY HACK
         *
         * 3.0 sent WM_PAINTICON with wParam == TRUE for no apparent
         * reason.  Lotus Notes 2.1 depends on this for some reason
         * to properly change its icon when new mail arrives.
         */
        if (!TestWF(pwnd, WFWIN40COMPAT) &&
            TestWF(pwnd, WFMINIMIZED)    &&
            (pwnd->pcls->spicn != NULL)) {

            StoreMessage(lpMsg, pwnd, WM_PAINTICON, (DWORD)TRUE, 0L, 0L);

        } else {

            StoreMessage(lpMsg, pwnd, WM_PAINT, 0, 0L, 0L);
        }

        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* xxxSimpleDoSyncPaint
*
* Process the sync-paint for this window.  This can send either a NCPAINT
* or an ERASEBKGND.  This assumes no recursion and flags == 0.
*
* History:
* 26-Oct-1993 MikeKe    Created
\***************************************************************************/

VOID xxxSimpleDoSyncPaint(
    PWND pwnd)
{
    HRGN  hrgnUpdate;
    DWORD flags = 0;

    CheckLock(pwnd);

    /*
     * No syncpaints for composited windows, it messes up their painting
     * since erasebkgnds and ncpaints will be sent in the wrong order.
     */
    if (GetStyleWindow(pwnd, WEFCOMPOSITED) != NULL)
        return;

    /*
     * Since we're taking care of the frame drawing, we can consider
     * this WM_PAINT message processed.
     */
    ClrWF(pwnd, WFPAINTNOTPROCESSED);

    /*
     * Make copies of these flags, because their state might
     * change after we send a message, and we don't want
     * to "lose" them.
     */
    if (TestWF(pwnd, WFSENDNCPAINT))
        flags |= DSP_FRAME;

    if (TestWF(pwnd, WFSENDERASEBKGND))
        flags |= DSP_ERASE;

    if (flags & (DSP_ERASE | DSP_FRAME)) {

        if (!TestWF(pwnd, WFVISIBLE)) {

            /*
             * If there is no update region, just clear the bits.
             */
            ClrWF(pwnd, WFSENDNCPAINT);
            ClrWF(pwnd, WFSENDERASEBKGND);
            ClrWF(pwnd, WFPIXIEHACK);
            ClrWF(pwnd, WFERASEBKGND);
            ClearHungFlag(pwnd, WFREDRAWIFHUNG);

        } else {

            PTHREADINFO ptiCurrent = PtiCurrent();

            /*
             * If there is no update region, we don't have to
             * do any erasing, but we may need to send an NCPAINT.
             */
            if (pwnd->hrgnUpdate == NULL) {
                ClrWF(pwnd, WFSENDERASEBKGND);
                ClrWF(pwnd, WFERASEBKGND);
                flags &= ~DSP_ERASE;
            }

            /*
             * Only mess with windows owned by the current thread.
             * NOTE: This means that WM_NCPAINT and WM_ERASEBKGND are
             *       only sent intra-thread.
             */
            if (GETPTI(pwnd) == ptiCurrent) {

                hrgnUpdate = GetNCUpdateRgn(pwnd, TRUE);

                if (flags & DSP_FRAME) {

                    /*
                     * If the message got sent before we got here then do
                     * nothing.
                     */
                    if (TestWF(pwnd, WFSENDNCPAINT))
                        xxxSendNCPaint(pwnd, hrgnUpdate);
                }

                if (flags & DSP_ERASE) {

                    if (TestWF(pwnd, WFSENDNCPAINT)) {
                        /*
                         * If we got another invalidate during the NCPAINT
                         * callback get the new update region
                         */
                        DeleteMaybeSpecialRgn(hrgnUpdate);
                        hrgnUpdate = GetNCUpdateRgn(pwnd, FALSE);
                    }

                    /*
                     * If the message got sent before we got here
                     * (e.g.: an UpdateWindow() inside WM_NCPAINT handler,
                     * for example), don't do anything.
                     *
                     * WINPROJ.EXE (version 1.0) calls UpdateWindow() in
                     * the WM_NCPAINT handlers for its subclassed listboxes
                     * in the open dialog.
                     */
                    if (TestWF(pwnd, WFSENDERASEBKGND)) {
                        ClrWF(pwnd, WFSENDERASEBKGND);
                        ClrWF(pwnd, WFERASEBKGND);
                        xxxSendEraseBkgnd(pwnd, NULL, hrgnUpdate);
                    }

                    /*
                     * The erase and frame operation has occured. Clear the
                     * WFREDRAWIFHUNG bit here. We don't want to clear it until we
                     * know the erase and frame has occured, so we know we always
                     * have a consistent looking window.
                     */
                    ClearHungFlag(pwnd, WFREDRAWIFHUNG);
                }

                DeleteMaybeSpecialRgn(hrgnUpdate);

            } else if (!TestwndChild(pwnd)                         &&
                       (pwnd != grpdeskRitInput->pDeskInfo->spwnd) &&
                       FHungApp(GETPTI(pwnd), CMSHUNGAPPTIMEOUT)   &&
                       TestWF(pwnd, WFREDRAWIFHUNG)) {

                ClearHungFlag(pwnd, WFREDRAWIFHUNG);
                xxxRedrawHungWindow(pwnd, NULL);
            }
        }
    }
}

/***************************************************************************\
* xxxInternalDoSyncPaint
*
* Mostly the same functionality as the old xxxDoSyncPaint.
*
*
* This function is called to erase the background of a window, and
* possibly frame and erase the children too.
*
* WM_SYNCPAINT(wParam)/DoSyncPaint(flags) values:
*
* DSP_ERASE               - Erase background
* DSP_FRAME               - Draw child frames
* DSP_ENUMCLIPPEDCHILDREN - Recurse if children are clipped
* DSP_NOCHECKPARENTS      - Don't check
*
*
* Normally, only the DSP_ENUMCLIPPEDCHILDREN bit of flags is
* significant on entry.  If DSP_WM_SYNCPAINT is set, then hrgnUpdate
* and the rest of the flags bits are valid.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxInternalDoSyncPaint(
    PWND  pwnd,
    DWORD flags)
{
    CheckLock(pwnd);

    /*
     * Do the paint for this window.
     */
    xxxSimpleDoSyncPaint(pwnd);

    /*
     * Normally we like to enumerate all of this window's children and have
     * them erase their backgrounds synchronously.  However, this is a bad
     * thing to do if the window is NOT CLIPCHLIDREN.  Here's the scenario
     * we want to to avoid:
     *
     * 1) Window 'A' is invalidated
     * 2) 'A' erases itself (or not, doesn't matter)
     * 3) 'A's children are enumerated and they erase themselves.
     * 4) 'A' paints over its children (remember, 'A' isn't CLIPCHILDREN)
     * 5) 'A's children paint but their backgrounds aren't their ERASEBKND
     *    color (because 'A' painted over them) and everything looks like
     *    dirt.
     */
    if ((flags & DSP_ALLCHILDREN) ||
        ((flags & DSP_ENUMCLIPPEDCHILDREN) && TestWF(pwnd, WFCLIPCHILDREN))) {

        TL   tlpwnd;
        PBWL pbwl;
        HWND *phwnd;

        if (pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL)) {

            PTHREADINFO ptiCurrent = PtiCurrent();
            HWND        hwnd;

            /*
             * If the client dies during a callback, the hwnd list
             * will be freed in xxxDestroyThreadInfo.
             */
            for (phwnd = pbwl->rghwnd; (hwnd = *phwnd) != (HWND)1; phwnd++) {

                if (hwnd == NULL)
                    continue;

                if ((pwnd = (PWND)RevalidateHwnd(hwnd)) == NULL)
                    continue;

                /*
                 * Note: testing if a window is a child automatically
                 * excludes the desktop window.
                 */
                if (TestWF(pwnd, WFCHILD) && (ptiCurrent != GETPTI(pwnd))) {

                    /*
                     * Don't cause any more intertask sendmessages cause it
                     * does bad things to cbt's windowproc hooks.  (Due to
                     * SetParent allowing child windows in the topwindow
                     * hierarchy.
                     */
                    continue;
                }

                /*
                 * Note that we pass only certain bits down as we recurse:
                 * the other bits pertain to the current window only.
                 */
                ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
                xxxInternalDoSyncPaint(pwnd, flags);
                ThreadUnlock(&tlpwnd);
            }

            FreeHwndList(pbwl);
        }
    }
}

/***************************************************************************\
* DoQueuedSyncPaint
*
* Queues WM_SYNCPAINT messages for top level windows not of the specified
* thread.
*
* History:
\***************************************************************************/

VOID DoQueuedSyncPaint(
    PWND        pwnd,
    DWORD       flags,
    PTHREADINFO pti)
{
    PTHREADINFO ptiPwnd = GETPTI(pwnd);

    if ((ptiPwnd != pti)          &&
        TestWF(pwnd, WFSENDNCPAINT)    &&
        TestWF(pwnd, WFSENDERASEBKGND) &&
        TestWF(pwnd, WFVISIBLE)) {

        PSMS psms = ptiPwnd->psmsReceiveList;

        /*
         * If this window already has a WM_SYNCPAINT queue'd up, then there's
         * no need to send another one.  Also protects our heap from getting
         * chewed up.
         */
        while (psms != NULL) {

            if ((psms->message == WM_SYNCPAINT) && (psms->spwnd == pwnd)) {
                break;
            }

            psms = psms->psmsReceiveNext;
        }

        if (psms == NULL) {
            /*
             * This will give this message the semantics of a notify
             * message (sendmessage no wait), without calling back
             * the WH_CALLWNDPROC hook. We don't want to do that
             * because that'll let all these processes with invalid
             * windows to process paint messages before they process
             * "synchronous" erasing or framing needs.
             *
             * Hi word of wParam must be zero or wow will drop it
             *
             * LATER mikeke
             * Do we need to send down the flags with DWP_ERASE and DSP_FRAME
             * in it?
             */
            UserAssert(HIWORD(flags) == 0);
            QueueNotifyMessage(pwnd, WM_SYNCPAINT, flags, 0);

            /*
             * Set our syncpaint-pending flag, since we queued one up.  This
             * will be used to check when we validate-parents for windows
             * without clipchildren.
             */
            SetWF(pwnd, WFSYNCPAINTPENDING);
        }

        /*
         * If we posted a WM_SYNCPAINT for a top-level window that is not
         * of the current thread we're done; we'll pick up the children
         * when we process the message for real.  If we're the desktop
         * however make sure we get all it children.
         */
        if (pwnd != PWNDDESKTOP(pwnd))
            return;
    }

    /*
     * Normally we like to enumerate all of this window's children and have
     * them erase their backgrounds synchronously.  However, this is a bad
     * thing to do if the window is NOT CLIPCHLIDREN.  Here's the scenario
     * we want to to avoid:
     *
     * 1.  Window 'A' is invalidated
     * 2.  'A' erases itself (or not, doesn't matter)
     * 3.  'A's children are enumerated and they erase themselves.
     * 4.  'A' paints over its children (remember, 'A' isn't CLIPCHILDREN)
     * 5.  'A's children paint but their backgrounds aren't their ERASEBKND
     *    color (because 'A' painted over them) and everything looks like
     *    dirt.
     */
    if ((flags & DSP_ALLCHILDREN) ||
        ((flags & DSP_ENUMCLIPPEDCHILDREN) && TestWF(pwnd, WFCLIPCHILDREN))) {

        PWND pwndT;

        for (pwndT = pwnd->spwndChild; pwndT; pwndT = pwndT->spwndNext) {

            /*
             * Don't cause any more intertask sendmessages cause it does
             * bad things to cbt's windowproc hooks.  (Due to SetParent
             * allowing child windows in the topwindow hierarchy.
             * The child bit also catches the desktop window; we want to
             */
            if (TestWF(pwndT, WFCHILD) && (pti != GETPTI(pwndT)))
                continue;

            /*
             * Note that we pass only certain bits down as we recurse:
             * the other bits pertain to the current window only.
             */
            DoQueuedSyncPaint(pwndT, flags, pti);
        }
    }
}

/***************************************************************************\
* xxxDoSyncPaint
*
* This funstion is only called for the initial syncpaint so we always
* queue syncpaints to other threads in this funtion.
*
* History:
\***************************************************************************/

VOID xxxDoSyncPaint(
    PWND  pwnd,
    DWORD flags)
{
    CheckLock(pwnd);

    /*
     * If any of our non-clipchildren parents have an update region, don't
     * do anything.  This way we won't redraw our background or frame out
     * of order, only to have it get obliterated when our parent erases his
     * background.
     */
    if (ParentNeedsPaint(pwnd))
        return;

    /*
     * First of all if we are going to be queueing any WM_SYNCPAINT messages
     * to windows of another thread do it first while the window's update
     * regions are still in sync.  This way there is no chance the update
     * region will be incorrect (through window movement during callbacks of
     * the WM_ERASEBKGND|WM_NCPAINT messages).
     */
    DoQueuedSyncPaint(pwnd, flags, PtiCurrent());
    xxxInternalDoSyncPaint(pwnd, flags);
}

/***************************************************************************\
* ParentNeedsPaint
*
* Return a non-zero PWND if a non-CLIPCHILDREN parent requires a WM_PAINT
* message.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PWND ParentNeedsPaint(
    PWND pwnd)
{
    while ((pwnd = pwnd->spwndParent) != NULL) {

        if (TestWF(pwnd, WFCLIPCHILDREN))
            break;

        if (NEEDSPAINT(pwnd))
            return pwnd;
    }

    return NULL;
}

/***************************************************************************\
* xxxSendEraseBkgnd
*
* Sends a WM_ERASEBKGROUND event to the window.  This contains the paintDC
* with the update-region selected into it.  If there's no update region
* then we prevent this event from making it to the window.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 15-Dec-1996 ChrisWil  Merged Chicago Functionality (no erase on min).
\***************************************************************************/

BOOL xxxSendEraseBkgnd(
    PWND pwnd,
    HDC  hdcBeginPaint,
    HRGN hrgnUpdate)
{
    PTHREADINFO ptiCurrent;
    BOOL        fErased;
    HDC         hdc;

    CheckLock(pwnd);

    /*
     * For minimized dudes in win3.1, we would've sent an
     * WM_ICONERASEBKGND and cleared the erase bit.  Now that min
     * windows in 4.0 are all nonclient, don't bother erasing at
     * all.  Pretend like we did.
     *
     * NOTE:
     * For < 4.0 windows, we may have to send a fake WM_ICONERASEKBGND
     * to keep 'em happy.  Saves time not to though.  Getting a DC and
     * sending the message ain't speedy.
     */
    if ((hrgnUpdate == NULL) || TestWF(pwnd, WFMINIMIZED))
        return FALSE;

    /*
     * If a DC to use was not passed in, get one.
     * We want one clipped to this window's update region.
     */
    if (hdcBeginPaint == NULL) {

       hdc = _GetDCEx(pwnd,
                      hrgnUpdate,
                      DCX_USESTYLE | DCX_INTERSECTRGN | DCX_NODELETERGN);
    } else {

        hdc = hdcBeginPaint;
    }

    /*
     * If we're send the WM_ERASEBKGND to another process
     * we need to change the DC owner.
     *
     * We'd like to change the owner to pwnd->pti->idProcess, but
     * GDI won't let us assign ownership back to ourselves later.
     */
    ptiCurrent = PtiCurrent();

    if (GETPTI(pwnd)->ppi != ptiCurrent->ppi)
        GreSetDCOwner(hdc, OBJECT_OWNER_PUBLIC);

    /*
     * Send the event to the window.  This contains the DC clipped to
     * the update-region.
     */
    fErased = (BOOL)xxxSendMessage(pwnd, WM_ERASEBKGND, (WPARAM)hdc, 0L);

    /*
     * If we've changed the DC owner, change it back to
     * the current process.
     */
    if (GETPTI(pwnd)->ppi != ptiCurrent->ppi)
        GreSetDCOwner(hdc, OBJECT_OWNER_CURRENT);

    /*
     * If the WM_ERASEBKGND message did not erase the
     * background, then set this flag to let BeginPaint()
     * know to ask the caller to do it via the fErase
     * flag in the PAINTSTRUCT.
     */
    if (!fErased) {
        SetWF(pwnd, WFERASEBKGND);
        if (!TestWF(pwnd, WFWIN31COMPAT))
            SetWF(pwnd, WFSENDERASEBKGND);
    }

    /*
     * If we got a cache DC in this routine, release it.
     */
    if (hdcBeginPaint == NULL) {
        ReleaseCacheDC(hdc, TRUE);
    }

    return fErased;
}

/***************************************************************************\
* IncPaintCount
*
* EFFECTS:
* If cPaintsReady changes from 0 to 1, the QS_PAINT bit is set for
* associated queue and we wake up task so repaint will occur.
*
* IMPLEMENTATION:
* Get the queue handle from the window handle, bump the paint count, and
* if paint count is one, Set the wakebit.
*
* History:
* 17-Jul-1991 DarrinM   Translated Win 3.1 ASM code.
\***************************************************************************/

VOID IncPaintCount(
    PWND pwnd)
{
    PTHREADINFO pti = GETPTI(pwnd);

    if (pti->cPaintsReady++ == 0)
        SetWakeBit(pti, QS_PAINT);
}

/***************************************************************************\
* DecPaintCount
*
* EFFECTS:
* If cPaintsReady changes from 1 to 0, the QS_PAINT bit is cleared so
* that no more paints will occur.
*
* IMPLEMENTATION:
* Get the queue handle from the window handle, decrement the paint count,
* and if paint count is zero, clear the wakebit.
*
* History:
* 17-Jul-1991 DarrinM   Translated Win 3.1 ASM code.
\***************************************************************************/

VOID DecPaintCount(
    PWND pwnd)
{
    PTHREADINFO pti = GETPTI(pwnd);

    if (--pti->cPaintsReady == 0) {
        pti->pcti->fsWakeBits   &= ~QS_PAINT;
        pti->pcti->fsChangeBits &= ~QS_PAINT;
    }
}

/***************************************************************************\
* UT_GetParentDCClipBox
*
* Return rectangle coordinates of the parent clip-rect.  If the window
* isn't using a parentDC for drawing then return normal clipbox.
*
* History:
* 31-Oct-1990 DarrinM   Ported from Win 3.0 sources.
\***************************************************************************/

int UT_GetParentDCClipBox(
    PWND   pwnd,
    HDC    hdc,
    LPRECT lprc)
{
    RECT rc;

    if (GreGetClipBox(hdc, lprc, TRUE) == NULLREGION)
        return FALSE;

    if ((pwnd == NULL) || !TestCF(pwnd, CFPARENTDC))
        return TRUE;

    GetRect(pwnd, &rc, GRECT_CLIENT | GRECT_CLIENTCOORDS);

    return IntersectRect(lprc, lprc, &rc);
}

/***************************************************************************\
* UserRedrawDesktop
*
* Redraw the desktop and its children.  This is called from GDI for DCI
* related unlocks, so that all visrgns are recalculated for the apps.
*
* History:
* 08-Jan-1996 ChrisWil  Created.
\***************************************************************************/

VOID UserRedrawDesktop(VOID)
{
    TL   tlpwnd;
    PWND pwndDesk;

    EnterCrit();

    pwndDesk = PtiCurrent()->rpdesk->pDeskInfo->spwnd;

    ThreadLockAlways(pwndDesk, &tlpwnd);

    xxxInternalInvalidate(pwndDesk,
                          HRGN_FULL,
                          RDW_INVALIDATE |
                              RDW_ERASE  |
                              RDW_FRAME  |
                              RDW_ALLCHILDREN);

    ThreadUnlock(&tlpwnd);

    LeaveCrit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\palette.c ===
/**************************** Module Header ********************************\
* Module Name: palette.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Palette Handling Routines
*
* History:
* 24-May-1993 MikeKe    From win3.1
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* IsTopmostRealApp
*
* Returns true if current process is the shell process and this window
* is the first non-shell/user one we find in zorder.  If so, we consider
* him to be the "palette foreground".
*
* History:
\***************************************************************************/

BOOL IsTopmostRealApp(
    PWND pwnd)
{
    PTHREADINFO  ptiCurrent = PtiCurrent();
    PDESKTOPINFO pdeskinfo = pwnd->head.rpdesk->pDeskInfo;
    if ((pdeskinfo->spwndShell == NULL) ||
        (GETPTI(pdeskinfo->spwndShell)->pq != gpqForeground)) {

        return FALSE;
    }

    return (pwnd == NextTopWindow(ptiCurrent,
                                  NULL,
                                  NULL,
                                  NTW_IGNORETOOLWINDOW));
}

/***************************************************************************\
* _SelectPalette
*
* Selects palette into DC.  This is a wrapper to gdi where we can perform
* checks to see if it's a foreground dc.
*
* History:
\***************************************************************************/

HPALETTE _SelectPalette(
    HDC      hdc,
    HPALETTE hpal,
    BOOL     fForceBackground)
{
    PWND pwndTop;
    BOOL fBackgroundPalette = TRUE;
    PWND pwnd = NULL;
    /*
     * If we are not forcing palette into background, find out where it does
     * actually belong. Don't ever select the default palette in as a
     * foreground palette because this confuses gdi. Many apps do a
     * (oldPal = SelectPalette) (myPal); Draw; SelectObject(oldPal).
     * and we don't want to allow this to go through.
     */
    if (!fForceBackground     &&
        TEST_PUSIF(PUSIF_PALETTEDISPLAY) &&
        (hpal != GreGetStockObject(DEFAULT_PALETTE))) {

        if (pwnd = WindowFromCacheDC(hdc)) {

            PWND pwndActive;

            /*
             * don't "select" palette unless on a palette device
             */
            pwndTop = GetTopLevelWindow(pwnd);

            if (!TestWF(pwndTop, WFHASPALETTE)) {

                if (pwndTop != _GetDesktopWindow())
                    GETPTI(pwndTop)->TIF_flags |= TIF_PALETTEAWARE;

                SetWF(pwndTop, WFHASPALETTE);
            }

            /*
             * Hack-o-rama:
             * Windows get foreground use of the palette if
             *      * They are the foreground's active window
             *      * The current process is the shell and they are the
             * topmost valid non-toolwindow in the zorder.
             *
             * This makes our tray friendly on palettized displays.
             * Currently, if you run a palette app and click on the tray,
             * the palette app goes all weird.  Broderbund apps go
             * completely black.  This is because they get forced to be
             * background always, even though the shell isn't really
             * palettized.
             *
             * Note: this palette architecture isn't very good.  Apps get forced to
             * be background palette users even if the foreground thread
             * couldn't care less about the palette.  Should go by zorder
             * if so, but in a more clean way than this.
             *
             * We really only care about the tray && the background.
             * Cabinet dudes don't matter so much.
             */
            pwndActive = (gpqForeground ? gpqForeground->spwndActive : NULL);

#if 0
            if (pwndActive                                            &&
                (pwndTop != pwnd->head.rpdesk->pDeskInfo->spwndShell) &&
                ((pwndActive == pwnd) || _IsChild(pwndActive, pwnd) || IsTopmostRealApp(pwnd)) &&
                !TestWF(pwnd, WEFTOOLWINDOW)) {

                fBackgroundPalette = FALSE;
            }
#else
            if ((pwndTop != pwndTop->head.rpdesk->pDeskInfo->spwnd)      &&
                (pwndTop != pwndTop->head.rpdesk->pDeskInfo->spwndShell) &&
                (pwndActive != NULL)                                     &&
                ((pwndActive == pwnd)          ||
                    _IsChild(pwndActive, pwnd) ||
                    IsTopmostRealApp(pwnd))                              &&
                !TestWF(pwnd, WEFTOOLWINDOW)) {

                fBackgroundPalette = FALSE;
            }
#endif
        }
    }

    return GreSelectPalette(hdc, hpal, fBackgroundPalette);
}

/***************************************************************************\
* xxxRealizePalette
*
* Realizes palette to the DC.  This is a wrapper to gdi so that we can
* check for changes prior to sending notifications.
*
* History:
\***************************************************************************/

int xxxRealizePalette(
    HDC hdc)
{
    PWND           pwnd;
    DWORD          dwNumChanged;
    PWINDOWSTATION pwinsta;
    PDESKTOP       pdesk;
    TL             tlpwnd;

    dwNumChanged = GreRealizePalette(hdc);

    if (HIWORD(dwNumChanged) && IsDCCurrentPalette(hdc)) {

        pwnd = WindowFromCacheDC(hdc);

        /*
         * if there is no associated window, don't send the palette change
         * messages since this is a memory hdc.
         */
        if (pwnd != NULL) {
            /*
             * Ok, send WM_PALETTECHANGED message to everyone. The wParam
             * contains a handle to the currently active window.  Send
             * message to the desktop also, so things on the desktop bitmap
             * will paint ok.
             */
             ThreadLock(pwnd, &tlpwnd);
             xxxBroadcastPaletteChanged(pwnd, FALSE);
             ThreadUnlock(&tlpwnd);

            /*
             * Mark all other desktops as needing to send out
             * WM_PALETTECHANGED messages.
             */

            pwinsta = grpWinStaList;

            while (pwinsta != NULL) {
                pdesk = pwinsta->rpdeskList;
                while (pdesk != NULL) {
                    if (pdesk != pwnd->head.rpdesk) {
                        pdesk->dwDTFlags |= DTF_NEEDSPALETTECHANGED;
                    }
                    pdesk = pdesk->rpdeskNext;
                }
                pwinsta = pwinsta->rpwinstaNext;
            }

            GreRealizePalette(hdc);
        }
    }

    /*
     * Walk through the SPB list (the saved bitmaps under windows with the
     * CS_SAVEBITS style) discarding all bitmaps
     */
    if (HIWORD(dwNumChanged)) {
        FreeAllSpbs();
    }

    return LOWORD(dwNumChanged);
}

/***************************************************************************\
* xxxFlushPalette
*
* This resets the palette and lets the next foreground app grab the
* foreground palette.  This is called in such instances when we
* minimize a window.
*
* History:
* 31-Aug-1995  ChrisWil    Created.
\***************************************************************************/

VOID xxxFlushPalette(
    PWND pwnd)
{
    CheckLock(pwnd);
    /*
     * Broadcast the palette changed messages.
     */
    GreRealizeDefaultPalette(gpDispInfo->hdcScreen, TRUE);
    xxxBroadcastPaletteChanged(pwnd, TRUE);
}

/***************************************************************************\
* xxxBroadcastPaletteChanged
*
* RealizePalette passes FALSE for fForceDesktopso so that it does not
* cause a loop in case RealizePalette was called by the desktop window.
* In such a case we don't want to call RealizeDesktop. In all other cases
* we do want to go to RealizeDesktop to give the desktop a chance to
* reailze its palette or possibly just repaint.
*
* 04/22/97      vadimg      created
\***************************************************************************/

VOID xxxBroadcastPaletteChanged(PWND pwnd, BOOL fForceDesktop)
{
    PWND pwndDesk;
    HWND hwnd = HWq(pwnd);

    CheckLock(pwnd);

    pwndDesk = PWNDDESKTOP(pwnd);
    if (fForceDesktop || pwnd != pwndDesk) {
        TL tlpwndDesk;
        ThreadLockAlways(pwndDesk, &tlpwndDesk);
        xxxRealizeDesktop(pwndDesk);
        ThreadUnlock(&tlpwndDesk);
    }

    xxxSendNotifyMessage(PWND_BROADCAST, WM_PALETTECHANGED, (WPARAM)hwnd, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\ntimm.c ===
/**************************************************************************\
* Module Name: ntimm.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains IMM functionality
*
* History:
* 21-Dec-1995 wkwok
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


static CONST WCHAR wszDefaultIme[] = L"Default IME";

#if DBG
BOOL CheckOwnerCirculate(PWND pwnd)
{
    PWND pwndT = pwnd->spwndOwner;

    while (pwndT) {
        UserAssert(pwndT->spwndOwner != pwnd);
        pwndT = pwndT->spwndOwner;
    }
    return TRUE;
}
#endif

/**************************************************************************\
* CreateInputContext
*
* Create input context object.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

PIMC CreateInputContext(
    ULONG_PTR dwClientImcData)
{
    PTHREADINFO    ptiCurrent;
    PIMC           pImc;
    PDESKTOP       pdesk = NULL;

    ptiCurrent = PtiCurrentShared();

    /*
     * Only for thread that wants IME processing.
     */
    if ((ptiCurrent->TIF_flags & TIF_DISABLEIME) || !IS_IME_ENABLED()) {
        RIPMSG1(RIP_VERBOSE, "CreateInputContext: TIF_DISABLEIME or !IME Enabled. pti=%#p", ptiCurrent);
        return NULL;
    }

    /*
     * If pti->spDefaultImc is NULL (means this is the first instance)
     * but dwClientImcData is not 0, some bogus application like NtCrash
     * has tried to trick the kernel. Just bail out.
     */
    if (dwClientImcData != 0 && ptiCurrent->spDefaultImc == NULL) {
        RIPMSG2(RIP_WARNING, "CreateInputContext: bogus value(0x%08x) is passed. pti=%#p",
                dwClientImcData, ptiCurrent);
        return NULL;
    }

    /*
     * If the windowstation has been initialized, allocate from
     * the current desktop.
     */
    pdesk = ptiCurrent->rpdesk;
#ifdef LATER
    RETURN_IF_ACCESS_DENIED(ptiCurrent->amdesk, DESKTOP_CREATEINPUTCONTEXT, NULL);
#else
    if (ptiCurrent->rpdesk == NULL) {
        return NULL;
    }
#endif

    pImc = HMAllocObject(ptiCurrent, pdesk, TYPE_INPUTCONTEXT, sizeof(IMC));

    if (pImc == NULL) {
        RIPMSG0(RIP_WARNING, "CreateInputContext: out of memory");
        return NULL;
    }

    if (dwClientImcData == 0) {
        /*
         * We are creating default input context for current thread.
         * Initialize the default input context as head of the
         * per-thread IMC list.
         */
        UserAssert(ptiCurrent->spDefaultImc == NULL);
        Lock(&ptiCurrent->spDefaultImc, pImc);
        pImc->pImcNext = NULL;
    }
    else {
        /*
         * Link it to the per-thread IMC list.
         */
        UserAssert(ptiCurrent->spDefaultImc != NULL);
        pImc->pImcNext = ptiCurrent->spDefaultImc->pImcNext;
        ptiCurrent->spDefaultImc->pImcNext = pImc;
    }

    pImc->dwClientImcData = dwClientImcData;

    return pImc;
}


/**************************************************************************\
* DestroyInputContext
*
* Destroy the specified input context object.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

BOOL DestroyInputContext(
    IN PIMC pImc)
{
    PTHREADINFO ptiImcOwner;
    PBWL        pbwl;
    PWND        pwnd;
    HWND       *phwnd;
    PHE         phe;

    ptiImcOwner = GETPTI(pImc);

    /*
     * Cannot destroy input context from other thread.
     */
    if (ptiImcOwner != PtiCurrent()) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING,
              "DestroyInputContext: pImc not of current pti");
        return FALSE;
    }

    /*
     * Cannot destroy default input context.
     */
    if (pImc == ptiImcOwner->spDefaultImc) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
              "DestroyInputContext: can't destroy default Imc");
        return FALSE;
    }

    /*
     * Cleanup destroyed input context from each associated window.
     */
    pbwl = BuildHwndList(ptiImcOwner->rpdesk->pDeskInfo->spwnd->spwndChild,
                             BWL_ENUMLIST|BWL_ENUMCHILDREN, ptiImcOwner);

    if (pbwl != NULL) {

        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
            /*
             * Make sure this hwnd is still around.
             */
            if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                continue;

            /*
             * Cleanup by associating the default input context.
             */
            if (pwnd->hImc == (HIMC)PtoH(pImc))
                AssociateInputContext(pwnd, ptiImcOwner->spDefaultImc);
        }

        FreeHwndList(pbwl);
    }

    phe = HMPheFromObject(pImc);

    /*
     * Make sure this object isn't already marked to be destroyed - we'll
     * do no good if we try to destroy it now since it is locked.
     */
    if (!(phe->bFlags & HANDLEF_DESTROY))
        HMDestroyUnlockedObject(phe);

    return TRUE;
}


/**************************************************************************\
* FreeInputContext
*
* Free up the specified input context object.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

VOID FreeInputContext(
    IN PIMC pImc)
{
    PIMC pImcT;

    /*
     * Mark it for destruction.  If it the object is locked it can't
     * be freed right now.
     */
    if (!HMMarkObjectDestroy((PVOID)pImc))
        return;

    /*
     * Unlink it.
     */
    pImcT = GETPTI(pImc)->spDefaultImc;

    while (pImcT != NULL && pImcT->pImcNext != pImc)
        pImcT = pImcT->pImcNext;

    if (pImcT != NULL)
        pImcT->pImcNext = pImc->pImcNext;

    /*
     * We're really going to free the input context.
     */
    HMFreeObject((PVOID)pImc);

    return;
}


/**************************************************************************\
* UpdateInputContext
*
* Update the specified input context object according to UpdateType.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

BOOL UpdateInputContext(
    IN PIMC pImc,
    IN UPDATEINPUTCONTEXTCLASS UpdateType,
    IN ULONG_PTR UpdateValue)
{
    PTHREADINFO ptiCurrent, ptiImcOwner;

    ptiCurrent = PtiCurrent();
    ptiImcOwner = GETPTI(pImc);

    /*
     * Cannot update input context from other process.
     */
    if (ptiImcOwner->ppi != ptiCurrent->ppi) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "UpdateInputContext: pImc not of current ppi");
        return FALSE;
    }


    switch (UpdateType) {

    case UpdateClientInputContext:
        if (pImc->dwClientImcData != 0) {
            RIPERR0(RIP_WARNING, RIP_WARNING, "UpdateInputContext: pImc->dwClientImcData != 0");
            return FALSE;
        }
        pImc->dwClientImcData = UpdateValue;
        break;

    case UpdateInUseImeWindow:
        pImc->hImeWnd = (HWND)UpdateValue;
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/**************************************************************************\
* AssociateInputContext
*
* Associate input context object to the specified window.
*
* History:
* 21-Dec-1995 wkwok       Created
\**************************************************************************/

HIMC AssociateInputContext(
    IN PWND  pWnd,
    IN PIMC  pImc)
{
    HIMC hImcRet = pWnd->hImc;
    pWnd->hImc = (HIMC)PtoH(pImc);

    return hImcRet;
}

AIC_STATUS AssociateInputContextEx(
    IN PWND  pWnd,
    IN PIMC  pImc,
    IN DWORD dwFlag)
{
    PTHREADINFO ptiWnd = GETPTI(pWnd);
    PWND pWndFocus = ptiWnd->pq->spwndFocus;
    BOOL fIgnoreNoContext = (dwFlag & IACE_IGNORENOCONTEXT) == IACE_IGNORENOCONTEXT;
    AIC_STATUS Status = AIC_SUCCESS;

    if (dwFlag & IACE_DEFAULT) {
        /*
         * use default input context.
         */
        pImc = ptiWnd->spDefaultImc;

    } else if (pImc != NULL && GETPTI(pImc) != ptiWnd) {
        /*
         * Cannot associate input context to window created
         * by other thread.
         */
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING,
                "AssociateInputContextEx: pwnd not of Imc pti");
        return AIC_ERROR;
    }

    /*
     * Cannot do association under different process context.
     */
    if (GETPTI(pWnd)->ppi != PtiCurrent()->ppi) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING,
                "AssociateInputContextEx: pwnd not of current ppi");
        return AIC_ERROR;
    }

    /*
     * Finally, make sure they are on the same desktop.
     */
    if (pImc != NULL && pImc->head.rpdesk != pWnd->head.rpdesk) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING,
                "AssociateInputContextEx: no desktop access");
        return AIC_ERROR;
    }

    /*
     * If IACE_CHILDREN is specified, associate the input context
     * to the child windows of pWnd as well.
     */
    if ((dwFlag & IACE_CHILDREN) && pWnd->spwndChild != NULL) {
        PBWL        pbwl;
        PWND        pwndT;
        HWND       *phwndT;

        pbwl = BuildHwndList(pWnd->spwndChild,
                   BWL_ENUMLIST|BWL_ENUMCHILDREN, ptiWnd);

        if (pbwl != NULL) {

            for (phwndT = pbwl->rghwnd; *phwndT != (HWND)1; phwndT++) {
                /*
                 * Make sure this hwnd is still around.
                 */
                if ((pwndT = RevalidateHwnd(*phwndT)) == NULL)
                    continue;

                if (pwndT->hImc == (HIMC)PtoH(pImc))
                    continue;

                if (pwndT->hImc == NULL_HIMC && fIgnoreNoContext)
                    continue;

                AssociateInputContext(pwndT, pImc);

                if (pwndT == pWndFocus)
                    Status = AIC_FOCUSCONTEXTCHANGED;
            }

            FreeHwndList(pbwl);
        }
    }

    /*
     * Associate the input context to pWnd.
     */
    if (pWnd->hImc != NULL_HIMC || !fIgnoreNoContext) {
        if (pWnd->hImc != (HIMC)PtoH(pImc)) {
            AssociateInputContext(pWnd, pImc);
            if (pWnd == pWndFocus)
                Status = AIC_FOCUSCONTEXTCHANGED;
        }
    }

    return Status;
}


/**************************************************************************\
* xxxFocusSetInputContext
*
* Set active input context upon focus change.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

VOID xxxFocusSetInputContext(
    IN PWND pWnd,
    IN BOOL fActivate,
    IN BOOL fQueueMsg)
{
    PTHREADINFO pti;
    PWND        pwndDefaultIme;
    TL          tlpwndDefaultIme;

    CheckLock(pWnd);

    pti = GETPTI(pWnd);

    /*
     * CS_IME class or "IME" class windows can not be SetActivated to hImc.
     * WinWord 6.0 US Help calls ShowWindow with the default IME window.
     * HELPMACROS get the default IME window by calling GetNextWindow().
     */
    if (TestCF(pWnd, CFIME) ||
            (pWnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]))
        return;

    /*
     * Do nothing if the thread does not have default IME window.
     */
    if ((pwndDefaultIme = pti->spwndDefaultIme) == NULL)
        return;

    /*
     * If the thread is going away or the default IME window is being vanished,
     * then do nothing.
     */
    if (pti->TIF_flags & TIF_INCLEANUP)
        return;

    UserAssert(!TestWF(pwndDefaultIme, WFDESTROYED));

    ThreadLockAlways(pwndDefaultIme, &tlpwndDefaultIme);

    if (fQueueMsg) {
        xxxSendMessageCallback(pwndDefaultIme, WM_IME_SYSTEM,
                fActivate ? IMS_ACTIVATECONTEXT : IMS_DEACTIVATECONTEXT,
                (LPARAM)HWq(pWnd), NULL, 1L, 0);
    } else {
        xxxSendMessage(pwndDefaultIme, WM_IME_SYSTEM,
                fActivate ? IMS_ACTIVATECONTEXT : IMS_DEACTIVATECONTEXT,
                (LPARAM)HWq(pWnd));
    }

#if _DBG
    if (pti->spwndDefaultIme != pwndDefaultIme) {
        RIPMSG1(RIP_WARNING, "pti(%#p)->spwndDefaultIme got freed during the callback.", pti);
    }
#endif

    ThreadUnlock(&tlpwndDefaultIme);

    return;
}


/**************************************************************************\
* BuildHimcList
*
* Retrieve the list of input context handles created by given thread.
*
* History:
* 21-Feb-1995 wkwok       Created
\**************************************************************************/

UINT BuildHimcList(
    PTHREADINFO pti,
    UINT cHimcMax,
    HIMC *ccxphimcFirst)
{
    PIMC pImcT;
    UINT i = 0;

    if (pti == NULL) {
        /*
         * Build the list which contains all IMCs created by calling process.
         */
        for (pti = PtiCurrent()->ppi->ptiList; pti != NULL; pti = pti->ptiSibling) {
            pImcT = pti->spDefaultImc;
            while (pImcT != NULL) {
                if (i < cHimcMax) {
                    try {
                        ccxphimcFirst[i] = (HIMC)PtoH(pImcT);
                    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                    }
                }
                i++;
                pImcT = pImcT->pImcNext;
            }
        }
    }
    else {
        /*
         * Build the list which contains all IMCs created by specified thread.
         */
        pImcT = pti->spDefaultImc;
        while (pImcT != NULL) {
            if (i < cHimcMax) {
                try {
                    ccxphimcFirst[i] = (HIMC)PtoH(pImcT);
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                }
            }
            i++;
            pImcT = pImcT->pImcNext;
        }
    }

    return i;
}


/**************************************************************************\
* xxxCreateDefaultImeWindow
*
* Create per-thread based default IME window.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

PWND xxxCreateDefaultImeWindow(
    IN PWND pwnd,
    IN ATOM atomT,
    IN HANDLE hInst)
{
    LARGE_STRING strWindowName;
    PWND pwndDefaultIme;
    TL tlpwnd;
    PIMEUI pimeui;
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    LPWSTR pwszDefaultIme;

    UserAssert(ptiCurrent == GETPTI(pwnd) && ptiCurrent->spwndDefaultIme == NULL);

    /*
     * Those conditions should have been checked by WantImeWindow()
     * before xxxCreateDefaultImeWindow gets called.
     */
    UserAssert(!(ptiCurrent->TIF_flags & TIF_DISABLEIME));
    UserAssert(!TestWF(pwnd, WFSERVERSIDEPROC));

    /*
     * The first Winlogon thread starts without default input context.
     * Create it now.
     */
    if (ptiCurrent->spDefaultImc == NULL &&
            PsGetThreadProcessId(ptiCurrent->pEThread) == gpidLogon)
        CreateInputContext(0);

    /*
     * No default IME window for thread that doesn't have
     * default input context
     */
    if (ptiCurrent->spDefaultImc == NULL)
        return (PWND)NULL;

    /*
     * Avoid recursion
     */
    if (atomT == gpsi->atomSysClass[ICLS_IME] || TestCF(pwnd, CFIME))
        return (PWND)NULL;

    /*
     * B#12165-win95b
     * Yet MFC does another nice. We need to avoid to give an IME window
     * to the child of desktop window which is in different process.
     */
    if (TestwndChild(pwnd) && GETPTI(pwnd->spwndParent)->ppi != ptiCurrent->ppi &&
            !(pwnd->style & WS_VISIBLE))
        return (PWND)NULL;

    if (ptiCurrent->rpdesk->pheapDesktop == NULL)
        return (PWND)NULL;

    /*
     * Allocate storage for L"Default IME" string from desktop heap
     * so that it can be referenced from USER32.DLL in user mode.
     */
    pwszDefaultIme = (LPWSTR)DesktopAlloc(ptiCurrent->rpdesk,
                                          sizeof(wszDefaultIme),
                                          DTAG_IMETEXT);
    if (pwszDefaultIme == NULL)
        return (PWND)NULL;

    RtlCopyMemory(pwszDefaultIme, wszDefaultIme, sizeof(wszDefaultIme));

    RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&strWindowName,
                              pwszDefaultIme,
                              (UINT)-1);

    ThreadLock(pwnd, &tlpwnd);

    pwndDefaultIme = xxxNVCreateWindowEx( (DWORD)0,
                             (PLARGE_STRING)gpsi->atomSysClass[ICLS_IME],
                             (PLARGE_STRING)&strWindowName,
                             WS_POPUP | WS_DISABLED,
                             0, 0, 0, 0,
                             pwnd, (PMENU)NULL,
                             hInst, NULL, VER40);


    if (pwndDefaultIme != NULL) {
        pimeui = ((PIMEWND)pwndDefaultIme)->pimeui;
        UserAssert(pimeui != NULL && (LONG_PTR)pimeui != (LONG_PTR)-1);
        try {
            ProbeForWrite(pimeui, sizeof *pimeui, sizeof(DWORD));
            pimeui->fDefault = TRUE;
            if (TestwndChild(pwnd) && GETPTI(pwnd->spwndParent) != ptiCurrent) {
                pimeui->fChildThreadDef = TRUE;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }
    }

    ThreadUnlock(&tlpwnd);

    DesktopFree(ptiCurrent->rpdesk, pwszDefaultIme);

    return pwndDefaultIme;
}


/**************************************************************************\
* xxxImmActivateThreadsLayout
*
* Activate keyboard layout for multiple threads.
*
* Return:
*     TRUE if at least one thread has changed its active keyboard layout.
*     FALSE otherwise
*
* History:
* 11-Apr-1996 wkwok       Created
\**************************************************************************/

BOOL xxxImmActivateThreadsLayout(
    PTHREADINFO pti,
    PTLBLOCK    ptlBlockPrev,
    PKL         pkl)
{
    TLBLOCK     tlBlock;
    PTHREADINFO ptiCurrent, ptiT;
    UINT        cThreads = 0;
    INT         i;

    CheckLock(pkl);

    ptiCurrent = PtiCurrentShared();

    /*
     * Build a list of threads that we need to update their active layouts.
     * We can't just walk the ptiT list while we're doing the work, because
     * for IME based keyboard layout, we will do callback to client side
     * and the ptiT could get deleted out while we leave the critical section.
     */
    for (ptiT = pti; ptiT != NULL; ptiT = ptiT->ptiSibling) {
        /*
         * Skip all the *do nothing* cases in xxxImmActivateLayout
         * so as to minimize the # of TLBLOCK required.
         */
        if (ptiT->spklActive == pkl || (ptiT->TIF_flags & TIF_INCLEANUP))
            continue;

        UserAssert(ptiT->pClientInfo != NULL);
        UserAssert(ptiT->ppi == PpiCurrent()); // can't access pClientInfo of other process

        if (ptiT->spwndDefaultIme == NULL) {
            /*
             * Keyboard layout is being switched but there's no way to callback
             * the client side to activate&initialize input context now.
             * Let's do hkl switching only in the kernel side for this thread
             * but remember the input context needs to be re-initialized
             * when this GUI thread recreates the default IME window later.
             */
            ptiT->hklPrev = ptiT->spklActive->hkl;
            Lock(&ptiT->spklActive, pkl);
            if (ptiT->spDefaultImc) {
                ptiT->pClientInfo->CI_flags |= CI_INPUTCONTEXT_REINIT;
                RIPMSG1(RIP_VERBOSE, "xxxImmActivateThreadsLayout: ptiT(%08p) will be re-initialized.", ptiT);
            }
            UserAssert((ptiT->TIF_flags & TIF_INCLEANUP) == 0);
            ptiT->pClientInfo->hKL = pkl->hkl;
            ptiT->pClientInfo->CodePage = pkl->CodePage;
            continue;
        }

        ThreadLockPti(ptiCurrent, ptiT, &tlBlock.list[cThreads].tlpti);
        tlBlock.list[cThreads++].pti = ptiT;

        if (cThreads == THREADS_PER_TLBLOCK)
            break;
    }

    /*
     * Return FALSE if all the threads already had the pkl active.
     */
    if (ptlBlockPrev == NULL && ptiT == NULL && cThreads == 0)
        return FALSE;

    /*
     * If we can't service all the threads in this run,
     * call ImmActivateThreadsLayout() again for a new TLBLOCK.
     */
    if (ptiT != NULL && ptiT->ptiSibling != NULL) {
        tlBlock.ptlBlockPrev = ptlBlockPrev;
        return xxxImmActivateThreadsLayout(ptiT->ptiSibling, &tlBlock, pkl);
    }

    /*
     * Finally, we can do the actual keyboard layout activation
     * starting from this run. Work on current TLBLOCK first.
     * We walk the list backwards so that the pti unlocks will
     * be done in the right order.
     */

    tlBlock.ptlBlockPrev = ptlBlockPrev;
    ptlBlockPrev = &tlBlock;

    while (ptlBlockPrev != NULL) {
        for (i = cThreads - 1; i >= 0; --i) {
            if ((ptlBlockPrev->list[i].pti->TIF_flags & TIF_INCLEANUP) == 0) {
                ptiT = ptlBlockPrev->list[i].pti;
                UserAssert(ptiT);
                xxxImmActivateLayout(ptiT, pkl);
                if ((ptiT->TIF_flags & TIF_INCLEANUP) == 0) {
                    ptiT->pClientInfo->hKL = pkl->hkl;
                    ptiT->pClientInfo->CodePage = pkl->CodePage;
                }
            }
            ThreadUnlockPti(ptiCurrent, &ptlBlockPrev->list[i].tlpti);
        }
        ptlBlockPrev = ptlBlockPrev->ptlBlockPrev;
        cThreads = THREADS_PER_TLBLOCK;
    }

    return TRUE;
}

VOID xxxImmActivateAndUnloadThreadsLayout(
    IN PTHREADINFO *ptiList,
    IN UINT         nEntries,
    IN PTLBLOCK     ptlBlockPrev,
    PKL             pklCurrent,
    DWORD           dwHklReplace)
{
    TLBLOCK     tlBlock;
    PTHREADINFO ptiCurrent;
    int         i, cThreads;
    enum { RUN_ACTIVATE = 1, RUN_UNLOAD = 2, RUN_FLAGS_MASK = RUN_ACTIVATE | RUN_UNLOAD, RUN_INVALID = 0xffff0000 };

    CheckLock(pklCurrent);

    ptiCurrent = PtiCurrentShared();

    tlBlock.ptlBlockPrev = ptlBlockPrev;

    /*
     * Build a list of threads that we need to unload their IME DLL(s).
     * We can't just walk the ptiList while we're doing the work, because
     * for IME based keyboard layout, we will do callback to client side
     * and the pti could get deleted out while we leave the critical section.
     */
    for (i = 0, cThreads = 0; i < (INT)nEntries; i++) {
        DWORD dwFlags = 0;

        /*
         * Skip all the *do nothing* cases in xxxImmActivateLayout
         * so as to minimize the # of TLBLOCKs required.
         */
        if (ptiList[i]->TIF_flags & TIF_INCLEANUP) {
            dwFlags = RUN_INVALID;
        }
        else if (ptiList[i]->spklActive != pklCurrent) {
            if (ptiList[i]->spwndDefaultIme == NULL) {
                BOOLEAN fAttached = FALSE;

                Lock(&ptiList[i]->spklActive, pklCurrent);
                if (ptiList[i]->pClientInfo != ptiCurrent->pClientInfo &&
                        ptiList[i]->ppi != ptiCurrent->ppi) {
                    /*
                     * If the thread is in another process, attach
                     * to that process so that we can access its ClientInfo.
                     */
                    KeAttachProcess(PsGetProcessPcb(ptiList[i]->ppi->Process));
                    fAttached = TRUE;
                }

                try {
                    ptiList[i]->pClientInfo->CodePage = pklCurrent->CodePage;
                    ptiList[i]->pClientInfo->hKL = pklCurrent->hkl;
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                      dwFlags = RUN_INVALID;
                }
                if (fAttached) {
                    KeDetachProcess();
                }
            } else {
                dwFlags = RUN_ACTIVATE;
            }
        }

        /*
         * Skip all the *do nothing* cases in xxxImmUnloadLayout()
         * so as to minimize the # of TLBLOCK required.
         * (#99321)
         */
        if (ptiList[i]->spwndDefaultIme != NULL &&
                ptiList[i]->spklActive != NULL &&
                (dwHklReplace != IFL_DEACTIVATEIME ||
                 IS_IME_KBDLAYOUT(ptiList[i]->spklActive->hkl)
#ifdef CUAS_ENABLE
                 ||
                 IS_CICERO_ENABLED_AND_NOT16BIT()
#endif // CUAS_ENABLE
                ) &&
                dwFlags != RUN_INVALID) {
            dwFlags |= RUN_UNLOAD;
        }

        if (dwFlags && dwFlags != RUN_INVALID) {
            ThreadLockPti(ptiCurrent, ptiList[i], &tlBlock.list[cThreads].tlpti);
#if DBG
            tlBlock.list[cThreads].dwUnlockedCount = 0;
#endif
            tlBlock.list[cThreads].pti = ptiList[i];
            tlBlock.list[cThreads++].dwFlags = dwFlags;

            if (cThreads == THREADS_PER_TLBLOCK) {
                i++;   // 1 more before exit the loop.
                break;
            }
        }
    }

    /*
     * If we can't service all the threads in this run,
     * call xxxImmActivateAndUnloadThreadsLayout again for a new TLBLOCK.
     */
    if (i < (INT)nEntries) {
        ptiList  += i;
        nEntries -= i;
        xxxImmActivateAndUnloadThreadsLayout(ptiList, nEntries, &tlBlock, pklCurrent, dwHklReplace);
        return;
    }

    /*
     * Finally, we can do the actual keyboard layout activation
     * starting from this run. Work on current TLBLOCK first.
     * We walk the list backwards so that the pti unlocks will
     * be done in the right order.
     */
    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev != NULL; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; i--) {
            if ((ptlBlockPrev->list[i].dwFlags & RUN_ACTIVATE) &&
                    !(ptlBlockPrev->list[i].pti->TIF_flags & TIF_INCLEANUP)) {
                xxxImmActivateLayout(ptlBlockPrev->list[i].pti, pklCurrent);
            }

            // unlock the thread if the thread is only locked for the first run
            if ((ptlBlockPrev->list[i].dwFlags & RUN_FLAGS_MASK) == RUN_ACTIVATE) {
                ThreadUnlockPti(ptiCurrent, &ptlBlockPrev->list[i].tlpti);
#if DBG
                ptlBlockPrev->list[i].dwUnlockedCount++;
#endif
            }
        }
        i = THREADS_PER_TLBLOCK - 1;
    }

    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev != NULL; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; --i) {
            if (ptlBlockPrev->list[i].dwFlags & RUN_UNLOAD) {
                if (!(ptlBlockPrev->list[i].pti->TIF_flags & TIF_INCLEANUP)) {
                    xxxImmUnloadLayout(ptlBlockPrev->list[i].pti, dwHklReplace);
                }
                else {
                    RIPMSG1(RIP_WARNING, "xxxImmActivateAndUnloadThreadsLayout: thread %#p is cleaned up.",
                            ptlBlockPrev->list[i].pti);
                }
                // unlock the thread
                UserAssert((ptlBlockPrev->list[i].dwFlags & RUN_FLAGS_MASK) != RUN_ACTIVATE);
                UserAssert(ptlBlockPrev->list[i].dwUnlockedCount == 0);
                ThreadUnlockPti(ptiCurrent, &ptlBlockPrev->list[i].tlpti);
#if DBG
                ptlBlockPrev->list[i].dwUnlockedCount++;
#endif
            }
        }
        i = THREADS_PER_TLBLOCK - 1;
    }

#if DBG
    // Check if all the locked thread is properly unlocked
    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; --i) {
            UserAssert(ptlBlockPrev->list[i].dwUnlockedCount == 1);
        }
        i = THREADS_PER_TLBLOCK - 1;
    }
#endif

    return;
}

/**************************************************************************\
* xxxImmActivateLayout
*
* Activate IME based keyboard layout.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

VOID xxxImmActivateLayout(
    IN PTHREADINFO pti,
    IN PKL pkl)
{
    TL tlpwndDefaultIme;
    PTHREADINFO ptiCurrent;

    CheckLock(pkl);

    /*
     * Do nothing if it's already been the current active layout.
     */
    if (pti->spklActive == pkl)
        return;

    if (pti->spwndDefaultIme == NULL) {
        /*
         * Only activate kernel side keyboard layout if this pti
         * doesn't have the default IME window.
         */
        Lock(&pti->spklActive, pkl);
        return;
    }

    ptiCurrent = PtiCurrentShared();

    /*
     * Activate client side IME based keyboard layout.
     */
    ThreadLockAlwaysWithPti(ptiCurrent, pti->spwndDefaultIme, &tlpwndDefaultIme);
    xxxSendMessage(pti->spwndDefaultIme, WM_IME_SYSTEM,
                (WPARAM)IMS_ACTIVATETHREADLAYOUT, (LPARAM)pkl->hkl);
    ThreadUnlock(&tlpwndDefaultIme);

    Lock(&pti->spklActive, pkl);

    return;
}


VOID xxxImmUnloadThreadsLayout(
    IN PTHREADINFO *ptiList,
    IN UINT         nEntries,
    IN PTLBLOCK     ptlBlockPrev,
    IN DWORD        dwFlag)
{
    TLBLOCK     tlBlock;
    PTHREADINFO ptiCurrent;
    INT         i, cThreads;
    BOOLEAN     fPerformUnlock;

    ptiCurrent = PtiCurrentShared();
    tlBlock.ptlBlockPrev = ptlBlockPrev;

    /*
     * Build a list of threads that we need to unload their IME DLL(s).
     * We can't just walk the ptiList while we're doing the work, because
     * for IME based keyboard layout, we will do callback to client side
     * and the pti could get deleted out while we leave the critical section.
     */
    for (i = 0, cThreads = 0; i < (INT)nEntries; i++) {
        /*
         * Skip all the *do nothing* cases in xxxImmUnloadLayout()
         * so as to minimize the # of TLBLOCK required.
         */
        if ((ptiList[i]->TIF_flags & TIF_INCLEANUP) || ptiList[i]->spwndDefaultIme == NULL)
            continue;

        if (ptiList[i]->spklActive == NULL)
            continue;

#if !defined(CUAS_ENABLE)
        if (dwFlag == IFL_DEACTIVATEIME &&
                !IS_IME_KBDLAYOUT(ptiList[i]->spklActive->hkl)) // #99321
            continue;
#else
        if (dwFlag == IFL_DEACTIVATEIME &&
                ((! IS_CICERO_ENABLED() && ! IS_IME_KBDLAYOUT(ptiList[i]->spklActive->hkl)) ||
                 (  IS_CICERO_ENABLED() && (PtiCurrent()->TIF_flags & TIF_16BIT)))
           ) // #99321
            continue;
#endif

#if DBG
        tlBlock.list[cThreads].dwUnlockedCount = 0;
#endif
        ThreadLockPti(ptiCurrent, ptiList[i], &tlBlock.list[cThreads].tlpti);
        tlBlock.list[cThreads++].pti = ptiList[i];
        if (cThreads == THREADS_PER_TLBLOCK) {
            i++;   // 1 more before exit the loop.
            break;
        }
    }

    if (i < (INT)nEntries) {
        ptiList  += i;
        nEntries -= i;
        xxxImmUnloadThreadsLayout(ptiList, nEntries, &tlBlock, dwFlag);
        return;
    }

    UserAssert(dwFlag == IFL_UNLOADIME || dwFlag == IFL_DEACTIVATEIME);
    if (dwFlag == IFL_UNLOADIME) {
        dwFlag = IFL_DEACTIVATEIME;
        fPerformUnlock = FALSE;
    } else {
        fPerformUnlock = TRUE;
    }
RepeatForUnload:
    /*
     * Finally, we can unload the IME based keyboard layout
     * starting from this run. Work on current TLBLOCK first.
     * We walk the list backwards so that the pti unlocks will
     * be done in the right order.
     */
    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; --i) {
            if (!(ptlBlockPrev->list[i].pti->TIF_flags & TIF_INCLEANUP)) {
                xxxImmUnloadLayout(ptlBlockPrev->list[i].pti, dwFlag);
            }
            else {
                RIPMSG2(RIP_WARNING, "Thread %#p is cleaned during the loop for %x!", ptlBlockPrev->list[i].pti, dwFlag);
            }

            if (fPerformUnlock) {
#if DBG
                ptlBlockPrev->list[i].dwUnlockedCount++;
#endif
                ThreadUnlockPti(ptiCurrent, &ptlBlockPrev->list[i].tlpti);
            }
        }
        i = THREADS_PER_TLBLOCK - 1;
    }

    if (!fPerformUnlock) {
        fPerformUnlock = TRUE;
        dwFlag = IFL_UNLOADIME;
        goto RepeatForUnload;
    }

#if DBG
    // Check if all the locked thread is properly unlocked
    i = cThreads - 1;
    for (ptlBlockPrev = &tlBlock; ptlBlockPrev; ptlBlockPrev = ptlBlockPrev->ptlBlockPrev) {
        for ( ; i >= 0; --i) {
            UserAssert(ptlBlockPrev->list[i].dwUnlockedCount == 1);
        }
        i = THREADS_PER_TLBLOCK - 1;
    }
#endif

    return;
}



VOID xxxImmUnloadLayout(
    IN PTHREADINFO pti,
    IN DWORD dwFlag)
{
    TL tlpwndDefaultIme;
    PTHREADINFO ptiCurrent;
    ULONG_PTR dwResult;
    LRESULT r;

    /*
     * Do nothing if the thread does not have default IME window.
     */
    if (pti->spwndDefaultIme == NULL)
        return;

    if (pti->spklActive == NULL)
        return;

#if !defined(CUAS_ENABLE)
    if (dwFlag == IFL_DEACTIVATEIME &&
            !IS_IME_KBDLAYOUT(pti->spklActive->hkl))
        return;
#else
    if (dwFlag == IFL_DEACTIVATEIME &&
            ((! IS_CICERO_ENABLED() && !IS_IME_KBDLAYOUT(pti->spklActive->hkl)) ||
             (  IS_CICERO_ENABLED() && (PtiCurrent()->TIF_flags & TIF_16BIT)))
       )
        return;
#endif

    ptiCurrent = PtiCurrentShared();

    ThreadLockAlwaysWithPti(ptiCurrent, pti->spwndDefaultIme, &tlpwndDefaultIme);
    r = xxxSendMessageTimeout(pti->spwndDefaultIme, WM_IME_SYSTEM,
                          IMS_UNLOADTHREADLAYOUT, (LONG)dwFlag,
                          SMTO_NOTIMEOUTIFNOTHUNG, CMSHUNGAPPTIMEOUT, &dwResult);

    if (!r) {
        RIPMSG1(RIP_WARNING, "Timeout in xxxImmUnloadLayout: perhaps this thread (0x%x) is not pumping messages.",
                GETPTIID(pti));
    }

    ThreadUnlock(&tlpwndDefaultIme);

    return;
}

/**************************************************************************\
* xxxImmLoadLayout
*
* Retrieves extended IMEINFO for the given IME based keyboard layout.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

PIMEINFOEX xxxImmLoadLayout(
    IN HKL hKL)
{
    PIMEINFOEX  piiex;
    PTHREADINFO ptiCurrent;
    TL          tlPool;

    /*
     * No IMEINFOEX for non-IME based keyboard layout.
     */
#if !defined(CUAS_ENABLE)
    if (!IS_IME_KBDLAYOUT(hKL))
        return (PIMEINFOEX)NULL;
#else
    if ((! IS_CICERO_ENABLED() && !IS_IME_KBDLAYOUT(hKL)) ||
        (  IS_CICERO_ENABLED() && (PtiCurrent()->TIF_flags & TIF_16BIT))
       )
        return (PIMEINFOEX)NULL;
#endif

    piiex = (PIMEINFOEX)UserAllocPool(sizeof(IMEINFOEX), TAG_IME);

    if (piiex == NULL) {
        RIPMSG1(RIP_WARNING,
              "xxxImmLoadLayout: failed to create piiex for hkl = %lx", hKL);
        return (PIMEINFOEX)NULL;
    }

    ptiCurrent = PtiCurrent();

    /*
     * Lock this allocations since we are going to the client side
     */
    ThreadLockPool(ptiCurrent, piiex, &tlPool);

    if (!ClientImmLoadLayout(hKL, piiex)) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlPool);
        return (PIMEINFOEX)NULL;
    }

    ThreadUnlockPool(ptiCurrent, &tlPool);

    return piiex;
}


/**************************************************************************\
* GetImeInfoEx
*
* Query extended IMEINFO.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

BOOL GetImeInfoEx(
    PWINDOWSTATION pwinsta,
    PIMEINFOEX piiex,
    IMEINFOEXCLASS SearchType)
{
    PKL pkl, pklFirst;

    /*
     * Note: this check was forced to insert due to winmm.dll who indirectly
     * loads imm32.dll in CSRSS context. CSRSS is not always bound to
     * specific window station, thus pwinsta could be NULL.
     * This has been avoided by not loading imm32.dll.
     * After winmm.dll gets removed from CSRSS, this if statement should be
     * removed, or substituted as an assertion.
     */
    if (pwinsta == NULL) {
        return FALSE;
    }

    /*
     * Keyboard layer has not been initialized.
     */
    if (pwinsta->spklList == NULL)
        return FALSE;

    pkl = pklFirst = pwinsta->spklList;

    switch (SearchType) {
    case ImeInfoExKeyboardLayout:
        do {
            if (pkl->hkl == piiex->hkl) {

                if (pkl->piiex == NULL)
                    break;

                RtlCopyMemory(piiex, pkl->piiex, sizeof(IMEINFOEX));
                return TRUE;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklFirst);
        break;

    case ImeInfoExImeFileName:
        do {
            if (pkl->piiex != NULL &&
                !_wcsnicmp(pkl->piiex->wszImeFile, piiex->wszImeFile, IM_FILE_SIZE)) {

                RtlCopyMemory(piiex, pkl->piiex, sizeof(IMEINFOEX));
                return TRUE;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklFirst);
        break;

    default:
        break;
    }

    return FALSE;
}


/**************************************************************************\
* SetImeInfoEx
*
* Set extended IMEINFO.
*
* History:
* 21-Mar-1996 wkwok       Created
\**************************************************************************/

BOOL SetImeInfoEx(
    PWINDOWSTATION pwinsta,
    PIMEINFOEX piiex)
{
    PKL pkl, pklFirst;

    if (pwinsta == NULL) {
        return FALSE;
    }

    UserAssert(pwinsta->spklList != NULL);

    pkl = pklFirst = pwinsta->spklList;

    do {
        if (pkl->hkl == piiex->hkl) {

            /*
             * Error out for non-IME based keyboard layout.
             */
            if (pkl->piiex == NULL)
                return FALSE;

            /*
             * Update kernel side IMEINFOEX for this keyboard layout
             * only if this is its first loading.
             */
            if (pkl->piiex->fLoadFlag == IMEF_NONLOAD) {
                RtlCopyMemory(pkl->piiex, piiex, sizeof(IMEINFOEX));
            }

            return TRUE;
        }
        pkl = pkl->pklNext;

    } while (pkl != pklFirst);

    return FALSE;
}


/***************************************************************************\
* xxxImmProcessKey
*
*
* History:
* 03-03-96 TakaoK             Created.
\***************************************************************************/

DWORD xxxImmProcessKey(
    IN PQ   pq,
    IN PWND pwnd,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    UINT  uVKey;
    PKL   pkl;
    DWORD dwHotKeyID;
    DWORD dwReturn = 0;
    PIMC  pImc = NULL;
    BOOL  fDBERoman = FALSE;
    PIMEHOTKEYOBJ pImeHotKeyObj;
    HKL hklTarget;

    CheckLock(pwnd);

    //
    // we're interested in only keyboard messages.
    //
    if ( message != WM_KEYDOWN    &&
         message != WM_SYSKEYDOWN &&
         message != WM_KEYUP      &&
         message != WM_SYSKEYUP ) {

        return dwReturn;
    }

    //
    // Check if it's IME hotkey. This must be done before checking
    // the keyboard layout because IME hotkey handler should be
    // called even if current keyboard layout is non-IME layout.
    //
    pkl = GETPTI(pwnd)->spklActive;
    if ( pkl == NULL ) {
        return dwReturn;
    }

    uVKey = (UINT)wParam & 0xff;

    pImeHotKeyObj = CheckImeHotKey(pq, uVKey, lParam);
    if (pImeHotKeyObj) {
        dwHotKeyID = pImeHotKeyObj->hk.dwHotKeyID;
        hklTarget = pImeHotKeyObj->hk.hKL;
    }
    else {
        dwHotKeyID = IME_INVALID_HOTKEY;
        hklTarget = (HKL)NULL;
    }

    //
    // Handle Direct KL switching here.
    //
    if (dwHotKeyID >= IME_HOTKEY_DSWITCH_FIRST && dwHotKeyID <= IME_HOTKEY_DSWITCH_LAST) {
        UserAssert(hklTarget != NULL);
        if (pkl->hkl != hklTarget) {
            //
            // Post the message only if the new Keyboard Layout is different from
            // the current Keyboard Layout.
            //
            _PostMessage(pwnd, WM_INPUTLANGCHANGEREQUEST,
                         (pkl->dwFontSigs & gSystemFS) ? INPUTLANGCHANGE_SYSCHARSET : 0,
                         (LPARAM)hklTarget);
        }
        if (GetAppImeCompatFlags(GETPTI(pwnd)) & IMECOMPAT_HYDRACLIENT) {
            return 0;
        }
        return IPHK_HOTKEY;
    }

    if (!IS_IME_ENABLED()) {
        //
        // Since IMM is disabled, no need to process further.
        // Just bail out.
        //
        return 0;
    }

    if ( dwHotKeyID != IME_INVALID_HOTKEY ) {
        //
        // if it's a valid hotkey, go straight and call back
        // the IME in the client side.
        //
        goto ProcessKeyCallClient;
    }

    //
    // if it's not a hotkey, we may want to check something
    // before calling back.
    //
    if ( pkl->piiex == NULL ) {
        return dwReturn;
    }

    //
    // Check input context
    //
    pImc = HtoP(pwnd->hImc);
    if ( pImc == NULL ) {
        return dwReturn;
    }

#ifdef LATER
    //
    // If there is an easy way to check the input context open/close status
    // from the kernel side, IME_PROP_NO_KEYS_ON_CLOSE checking should be
    // done here in kernel side.  [ 3/10/96 takaok]
    //

    //
    // Check IME_PROP_NO_KEYS_ON_CLOSE bit
    //
    // if the current imc is not open and IME doesn't need
    // keys when being closed, we don't pass any keyboard
    // input to ime except hotkey and keys that change
    // the keyboard status.
    //
    if ( (piix->ImeInfo.fdwProperty & IME_PROP_NO_KEYS_ON_CLOSE) &&
         (!pimc->fdwState & IMC_OPEN)                            &&
         uVKey != VK_SHIFT                                       &&  // 0x10
         uVKey != VK_CONTROL                                     &&  // 0x11
         uVKey != VK_CAPITAL                                     &&  // 0x14
         uVKey != VK_KANA                                        &&  // 0x15
         uVKey != VK_NUMLOCK                                     &&  // 0x90
         uVKey != VK_SCROLL )                                        // 0x91
    {
      // Check if Korea Hanja conversion mode
      if( !(pimc->fdwConvMode & IME_CMODE_HANJACONVERT) ) {
          return dwReturn;
      }
    }
#endif

    //
    // if the IME doesn't need key up messages, we don't call ime.
    //
    if ( lParam & 0x80000000 && // set if key up, clear if key down
         pkl->piiex->ImeInfo.fdwProperty & IME_PROP_IGNORE_UPKEYS )
    {
        return dwReturn;
    }

    //
    // we don't want to handle sys keys since many functions for
    // acceelerators won't work without this
    //
    fDBERoman = (BOOL)( (uVKey == VK_DBE_ROMAN)            ||
                        (uVKey == VK_DBE_NOROMAN)          ||
                        (uVKey == VK_DBE_HIRAGANA)         ||
                        (uVKey == VK_DBE_KATAKANA)         ||
                        (uVKey == VK_DBE_CODEINPUT)        ||
                        (uVKey == VK_DBE_NOCODEINPUT)      ||
                        (uVKey == VK_DBE_IME_WORDREGISTER) ||
                        (uVKey == VK_DBE_IME_DIALOG) );

    if (message == WM_SYSKEYDOWN || message == WM_SYSKEYUP ) {
        //
        // IME may be waiting for VK_MENU, VK_F10 or VK_DBE_xxx
        //
        if ( uVKey != VK_MENU && uVKey != VK_F10 && !fDBERoman ) {
            return dwReturn;
        }
    }

    //
    // check if the IME doesn't need ALT key
    //
    if ( !(pkl->piiex->ImeInfo.fdwProperty & IME_PROP_NEED_ALTKEY) ) {
        //
        // IME doesn't need ALT key
        //
        // we don't pass the ALT and ALT+xxx except VK_DBE_xxx keys.
        //
        if ( ! fDBERoman &&
             (uVKey == VK_MENU || (lParam & 0x20000000))  // KF_ALTDOWN
           )
        {
            return dwReturn;
        }
    }

    //
    // finaly call back the client
    //

ProcessKeyCallClient:

    if ((uVKey & 0xff) == VK_PACKET) {
        //
        // need to retrieve UNICODE character from pti
        //
        uVKey = MAKELONG(wParam, PtiCurrent()->wchInjected);
    }
    dwReturn = ClientImmProcessKey( PtoH(pwnd),
                                    pkl->hkl,
                                    uVKey,
                                    lParam,
                                    dwHotKeyID);

    //
    // Hydra server wants to see the IME hotkeys.
    //
    if (GetAppImeCompatFlags(GETPTI(pwnd)) & IMECOMPAT_HYDRACLIENT) {
        dwReturn &= ~IPHK_HOTKEY;
    }
    return dwReturn;
}


/**************************************************************************\
* ImeCanDestroyDefIME
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

BOOL ImeCanDestroyDefIME(
    PWND pwndDefaultIme,
    PWND pwndDestroy)
{
    PWND   pwnd;
    PIMEUI pimeui;

    pimeui = ((PIMEWND)pwndDefaultIme)->pimeui;

    if (pimeui == NULL || (LONG_PTR)pimeui == (LONG_PTR)-1)
        return FALSE;

    try {
        if (ProbeAndReadStructure(pimeui, IMEUI).fDestroy) {
            return FALSE;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }

    /*
     * If the pwndDestroy has no owner/ownee relationship with
     * pwndDefaultIme, don't bother to change anything.
     *
     * If pwndDefaultIme->spwndOwner is NULL, this means we need
     * to search for a new good owner window.
     */
    if ( pwndDefaultIme->spwndOwner != NULL ) {
        for (pwnd = pwndDefaultIme->spwndOwner;
             pwnd != pwndDestroy && pwnd != NULL; pwnd = pwnd->spwndOwner) ;

        if (pwnd == NULL)
            return FALSE;
    }

    /*
     * If the destroying window is IME or UI window, do nothing
     */
    pwnd = pwndDestroy;

    while (pwnd != NULL) {
        if (TestCF(pwnd, CFIME) ||
                pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
            return FALSE;

        pwnd = pwnd->spwndOwner;
    }

    ImeSetFutureOwner(pwndDefaultIme, pwndDestroy);

    /*
     * If new owner is lower z-order than IME class window,
     * we need to check topmost to change z-order.
     */
    pwnd = pwndDefaultIme->spwndOwner;
    while (pwnd != NULL && pwnd != pwndDefaultIme)
        pwnd = pwnd->spwndNext;

    if (pwnd == pwndDefaultIme)
        ImeCheckTopmost(pwndDefaultIme);

#if DBG
    CheckOwnerCirculate(pwndDefaultIme);
#endif

    /*
     * If ImeSetFutureOwner can not find the owner window any
     * more, this IME window should be destroyed.
     */
    if (pwndDefaultIme->spwndOwner == NULL ||
            pwndDestroy == pwndDefaultIme->spwndOwner) {

//        RIPMSG1(RIP_WARNING, "ImeCanDestroyDefIME: TRUE for pwnd=%#p", pwndDestroy);
        Unlock(&pwndDefaultIme->spwndOwner);

        /*
         * Return TRUE! Please destroy me.
         */
        return TRUE;
    }

    return FALSE;
}


/**************************************************************************\
* IsChildSameThread (IsChildSameQ)
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

BOOL IsChildSameThread(
    PWND pwndParent,
    PWND pwndChild)
{
    PWND pwnd;
    PTHREADINFO ptiChild = GETPTI(pwndChild);

    for (pwnd = pwndParent->spwndChild; pwnd; pwnd = pwnd->spwndNext) {
        /*
         * If pwnd is not child window, we need to skip MENU window and
         * IME related window.
         */
        if (!TestwndChild(pwnd)) {
            PWND pwndOwner = pwnd;
            BOOL fFoundOwner = FALSE;

            /*
             * Skip MENU window.
             */
            if (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_MENU])
                continue;

            while (pwndOwner != NULL) {
                /*
                 * CS_IME class or "IME" class windows can not be the owner of
                 * IME windows.
                 */
                if (TestCF(pwndOwner, CFIME) ||
                        pwndOwner->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
                    fFoundOwner = TRUE;
                    break;
                }

                pwndOwner = pwndOwner->spwndOwner;
            }

            if (fFoundOwner)
                continue;
        }

        /*
         * We need to skip pwndChild.
         */
        if (pwnd == pwndChild)
            continue;

        /*
         * pwnd and pwndChild are on same thread?
         */
        if (GETPTI(pwnd) == ptiChild) {
            PWND pwndT = pwnd;
            BOOL fFoundImeWnd = FALSE;

            /*
             * Check again. If hwndT is children or ownee of
             * IME related window, skip it.
             */
            if (TestwndChild(pwndT)) {

                for (; TestwndChild(pwndT) && GETPTI(pwndT) == ptiChild;
                        pwndT = pwndT->spwndParent) {
                    if (TestCF(pwndT, CFIME) ||
                            pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
                        fFoundImeWnd = TRUE;
                }
            }

            if (!TestwndChild(pwndT)) {

                for (; pwndT != NULL && GETPTI(pwndT) == ptiChild;
                        pwndT = pwndT->spwndOwner) {
                    if (TestCF(pwndT, CFIME) ||
                            pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
                        fFoundImeWnd = TRUE;
                }
            }

            if (!fFoundImeWnd)
                return TRUE;
        }
    }

    return FALSE;
}


/**************************************************************************\
* ImeCanDestroyDefIMEforChild
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

BOOL ImeCanDestroyDefIMEforChild(
    PWND pwndDefaultIme,
    PWND pwndDestroy)
{
    PWND pwnd;
    PIMEUI pimeui;

    pimeui = ((PIMEWND)pwndDefaultIme)->pimeui;

    /*
     * If this window is not for Child Thread.....
     */
    if (pimeui == NULL || (LONG_PTR)pimeui == (LONG_PTR)-1)
        return FALSE;

    try {
        if (!ProbeAndReadStructure(pimeui, IMEUI).fChildThreadDef) {
            return FALSE;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }

    /*
     * If parent belongs to different thread,
     * we don't need to check any more...
     */
    if (pwndDestroy->spwndParent == NULL ||
            GETPTI(pwndDestroy) == GETPTI(pwndDestroy->spwndParent))
        return FALSE;

    pwnd = pwndDestroy;

    while (pwnd != NULL && pwnd != PWNDDESKTOP(pwnd)) {
        if (IsChildSameThread(pwnd->spwndParent, pwndDestroy))
            return FALSE;
        pwnd = pwnd->spwndParent;
    }

    /*
     * We could not find any other window created by GETPTI(pwndDestroy).
     * Let's destroy the default IME window of this Q.
     */
    return TRUE;
}


/**************************************************************************\
* ImeCheckTopmost
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

VOID ImeCheckTopmost(
    PWND pwndIme)
{
    if (pwndIme->spwndOwner) {
        PWND pwndInsertBeforeThis;
        /*
         * The ime window have to be same topmost tyle with the owner window.
         * If the Q of this window is not foreground Q, we don't need to
         * forground the IME window.
         * But the topmost attribute of owner was changed, this IME window
         * should be re-calced.
         */
        if (GETPTI(pwndIme) == gptiForeground) {
            pwndInsertBeforeThis = NULL;
        } else {
            pwndInsertBeforeThis = pwndIme->spwndOwner;
        }

        ImeSetTopmost(pwndIme, TestWF(pwndIme->spwndOwner, WEFTOPMOST) != 0, pwndInsertBeforeThis);
    }
}


/**************************************************************************\
* ImeSetFutureOwner
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

VOID ImeSetFutureOwner(
    PWND pwndIme,
    PWND pwndOrgOwner)
{
    PWND pwnd, pwndOwner;
    PTHREADINFO ptiImeWnd = GETPTI(pwndIme);

    if (pwndOrgOwner == NULL || TestWF(pwndOrgOwner, WFCHILD))
        return;

    pwnd = pwndOrgOwner;

    /*
     * Get top of owner created by the same thread.
     */
    while ((pwndOwner = pwnd->spwndOwner) != NULL &&
            GETPTI(pwndOwner) == ptiImeWnd)
        pwnd = pwndOwner;

    /*
     * Bottom window can not be the owner of IME window easily...
     */
    if (TestWF(pwnd, WFBOTTOMMOST) && !TestWF(pwndOrgOwner, WFBOTTOMMOST))
        pwnd = pwndOrgOwner;

    /*
     * CS_IME class or "IME" class windows can not be the owner of
     * IME windows.
     */
    if (TestCF(pwnd, CFIME) ||
            pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
        pwnd = pwndOrgOwner;

    /*
     * If hwndOrgOwner is a top of owner, we start to search
     * another top owner window in same queue.
     */
    if (pwndOrgOwner == pwnd && pwnd->spwndParent != NULL) {
        PWND pwndT;

        for (pwndT = pwnd->spwndParent->spwndChild;
                pwndT != NULL; pwndT = pwndT->spwndNext) {

            if (GETPTI(pwnd) != GETPTI(pwndT))
                continue;

            if (pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_MENU])
                continue;

            /*
             * CS_IME class or "IME" class windows can not be the owner of
             * IME windows.
             */
            if (TestCF(pwndT, CFIME) ||
                    pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])
                continue;

            // We don't like the window that is being destroyed.
            if (TestWF(pwndT, WFINDESTROY))
                continue;

            /*
             * !!!!WARNING!!!!!
             * Is hwndT a good owner of hIMEwnd??
             *  1. Of cource, it should no CHILD window!
             *  2. If it is hwnd,.. I know it and find next!
             *  3. Does hwndT have owner in the same thread?
             */
            if (!TestWF(pwndT, WFCHILD) && pwnd != pwndT &&
                    (pwndT->spwndOwner == NULL ||
                     GETPTI(pwndT) != GETPTI(pwndT->spwndOwner))) {
                UserAssert(GETPTI(pwndIme) == GETPTI(pwndT));
                pwnd = pwndT;
                break;
            }
        }
    }

    UserAssert(!TestCF(pwnd, CFIME));
    Lock(&pwndIme->spwndOwner, pwnd);

    return;
}


/**************************************************************************\
* ImeSetTopmostChild
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

VOID ImeSetTopmostChild(
    PWND pwndParent,
    BOOL fMakeTopmost)
{
    PWND pwnd = pwndParent->spwndChild;

    while (pwnd != NULL) {
        if (fMakeTopmost)
            SetWF(pwnd, WEFTOPMOST);
        else
            ClrWF(pwnd, WEFTOPMOST);

        ImeSetTopmostChild(pwnd, fMakeTopmost);

        pwnd = pwnd->spwndNext;
    }

    return;
}


/**************************************************************************\
*
*  GetLastTopMostWindowNoIME() -
*
*  Get the last topmost window which is not the ownee of pwndRoot (IME window).
*
\**************************************************************************/

PWND GetLastTopMostWindowNoIME(PWND pwndRoot)
{
    PWND pwndT = _GetDesktopWindow();
    PWND pwndRet = NULL;

    /*
     * pwndRoot should not be NULL, and should be IME window.
     */
    UserAssert(pwndRoot && pwndRoot->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]);

    if (pwndT == NULL || pwndT->spwndChild == NULL) {
#if _DBG
        if (pwndT == NULL) {
            RIPMSG0(RIP_WARNING, "GetLastTopMostWindowNoIME: there's no desktop window !!");
        }
        else {
            RIPMSG0(RIP_WARNING, "GetLastTopMostWindowNoIME: there is no toplevel window !!");
        }
#endif
        return NULL;
    }

    /*
     * Get the first child of the desktop window.
     */
    pwndT = pwndT->spwndChild;

    /*
     * Loop through the toplevel windows while they are topmost.
     */
    while (TestWF(pwndT, WEFTOPMOST)) {
        PWND pwndOwner = pwndT;
        BOOL fOwned = FALSE;

        /*
         * If pwndT is a IME related window, track the owner. If pwndRoot is not
         * pwndT's owner, remember pwndT as a candidate.
         */
        if (TestCF(pwndT,CFIME) || (pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])) {
            while (pwndOwner != NULL) {
                if (pwndRoot == pwndOwner) {
                    fOwned = TRUE;
                    break;
                }
                pwndOwner = pwndOwner->spwndOwner;
            }
        }
        if (!fOwned)
            pwndRet = pwndT;

        /*
         * Next toplevel window.
         */
        pwndT = pwndT->spwndNext;
        UserAssert(pwndT->spwndParent == _GetDesktopWindow());
    }

    return pwndRet;
}


#if DBG
void ImeCheckSetTopmostLink(PWND pwnd, PWND pwndInsFirst, PWND pwndIns)
{
    PWND pwndDebT0 = pwndInsFirst;
    BOOL fFound = FALSE;

    if (pwndDebT0) {
        while (pwndDebT0 && (pwndDebT0 != pwndIns)) {
            if (pwndDebT0 == pwnd)
                fFound = TRUE;

            pwndDebT0 = pwndDebT0->spwndNext;
        }

        if (pwndDebT0 == NULL) {
            RIPMSG3(RIP_ERROR, "pwndIns(%#p) is upper that pwndInsFirst(%#p) pwnd is (%#p)", pwndIns, pwndInsFirst, pwnd);
        } else if (fFound) {
            RIPMSG3(RIP_ERROR, "pwnd(%#p) is between pwndInsFirst(%#p) and pwndIns(%#p)", pwnd, pwndInsFirst, pwndIns);
        }
    } else if (pwndIns) {
        pwndDebT0 = pwnd->spwndParent->spwndChild;

        while (pwndDebT0 && (pwndDebT0 != pwndIns)) {
            if (pwndDebT0 == pwnd)
                fFound = TRUE;

            pwndDebT0 = pwndDebT0->spwndNext;
        }

        if (fFound) {
            RIPMSG3(RIP_ERROR, "pwnd(%#p) is between TOPLEVEL pwndInsFirst(%#p) and pwndIns(%#p)", pwnd, pwndInsFirst, pwndIns);
        }
    }
}
#endif

/**************************************************************************\
* ImeSetTopmost
*
* History:
* 02-Apr-1996 wkwok       Ported from FE Win95 (imeclass.c)
\**************************************************************************/

VOID ImeSetTopmost(
    PWND pwndRootIme,
    BOOL fMakeTopmost,
    PWND pwndInsertBefore)
{
    PWND pwndParent = pwndRootIme->spwndParent;
    PWND pwndInsert = PWND_TOP; // pwnd which should be prior to pwndRootIme.
    PWND pwnd, pwndT;
    PWND pwndInsertFirst;
    BOOLEAN fFound;

    if (pwndParent == NULL)
        return;

    pwnd = pwndParent->spwndChild;

    if (!fMakeTopmost) {
        /*
         * Get the last topmost window. This should be after unlink pwndRootIme
         * because pwndRootIme may be the last topmost window.
         */
        pwndInsert = GetLastTopMostWindowNoIME(pwndRootIme);

        if (pwndInsertBefore) {

            fFound = FALSE;
            pwndT = pwndInsert;

            while (pwndT != NULL && pwndT->spwndNext != pwndInsertBefore) {
                if (pwndT == pwndRootIme)
                    fFound = TRUE;
                pwndT = pwndT->spwndNext;
            }

            if (pwndT == NULL || fFound)
                return;

            pwndInsert = pwndT;
        }

        if (TestWF(pwndRootIme->spwndOwner, WFBOTTOMMOST)) {
            pwndT = pwndInsert;

            while (pwndT != NULL && pwndT != pwndRootIme->spwndOwner) {
                if (!TestCF(pwndT, CFIME) &&
                        pwndT->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME]) {
                    pwndInsert = pwndT;
                }
                pwndT = pwndT->spwndNext;
            }
        }
    }

    pwndInsertFirst = pwndInsert;

    /*
     * Enum the all toplevel windows and if the owner of the window is same as
     * the owner of pwndRootIme, the window should be changed the position of
     * window link.
     */
    while (pwnd != NULL) {
        /*
         * Get the next window before calling ImeSetTopmost.
         * Because the next window will be changed in LinkWindow.
         */
        PWND pwndNext = pwnd->spwndNext;

        /*
         * the owner relation between IME and UI window is in same thread.
         */
        if (GETPTI(pwnd) != GETPTI(pwndRootIme))
            goto ist_next;

        /*
         * pwnd have to be CS_IME class or "IME" class.
         */
        if (!TestCF(pwnd, CFIME) &&
                pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME])
            goto ist_next;

        /*
         * If pwnd is pwndInsert, we don't need to do anything...
         */
        if (pwnd == pwndInsert)
            goto ist_next;

        pwndT = pwnd;
        while (pwndT != NULL) {
            if (pwndT == pwndRootIme) {
                /*
                 * Found!!
                 * pwnd is the ownee of pwndRootIme.
                 */

                UserAssert(GETPTI(pwnd) == GETPTI(pwndRootIme));
                UserAssert(TestCF(pwnd,CFIME) ||
                            (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]));
                UserAssert(pwnd != pwndInsert);

                UnlinkWindow(pwnd, pwndParent);

                if (fMakeTopmost) {
                    if (pwndInsert != PWND_TOP)
                        UserAssert(TestWF(pwndInsert, WEFTOPMOST));
                    SetWF(pwnd, WEFTOPMOST);
                }
                else {
                    if (pwndInsert == PWND_TOP) {
                        /*
                         * In rare cases, the first toplevel window could be the one we'll look next,
                         * who may still have obscure topmost flag.
                         */
                        UserAssert(pwndParent->spwndChild == pwndNext || !TestWF(pwndParent->spwndChild, WEFTOPMOST));
                    }
                    else if (pwndInsert->spwndNext != NULL) {
                        /*
                         * In rare cases, pwndInsert->spwndNext could be the one we'll look next,
                         * who may still have obscure topmost flag.
                         */
                        UserAssert(pwndInsert->spwndNext == pwndNext || !TestWF(pwndInsert->spwndNext, WEFTOPMOST));
                    }
                    ClrWF(pwnd, WEFTOPMOST);
                }

                LinkWindow(pwnd, pwndInsert, pwndParent);
#if 0   // Let's see what happens if we disable this
                ImeSetTopmostChild(pwnd, fMakeTopmost);
#endif

                pwndInsert = pwnd;
                break;  // goto ist_next;
            }
            pwndT = pwndT->spwndOwner;
        }
ist_next:
        pwnd = pwndNext;

        /*
         * Skip the windows that were inserted before.
         */
        if (pwnd != NULL && pwnd == pwndInsertFirst)
            pwnd = pwndInsert->spwndNext;

#if DBG
        if (pwnd)
            ImeCheckSetTopmostLink(pwnd, pwndInsertFirst, pwndInsert);
#endif
    }
}


/**************************************************************************\
* ProbeAndCaptureSoftKbdData
*
* Captures SoftKbdData that comes from user mode.
*
* 23-Apr-1996 wkwok     created
\**************************************************************************/

PSOFTKBDDATA ProbeAndCaptureSoftKbdData(
    PSOFTKBDDATA Source)
{
    PSOFTKBDDATA Destination = NULL;
    DWORD        cbSize;
    UINT         uCount;

    try {
        uCount = ProbeAndReadUlong((PULONG)Source);

#if defined(_X86_)
        ProbeForReadBuffer(&Source->wCode, uCount, sizeof(BYTE));
#else
        ProbeForReadBuffer(&Source->wCode, uCount, sizeof(WORD));
#endif

        cbSize = FIELD_OFFSET(SOFTKBDDATA, wCode[0])
               + uCount * sizeof(WORD) * 256;

        Destination = (PSOFTKBDDATA)UserAllocPool(cbSize, TAG_IME);

        if (Destination != NULL) {
            RtlCopyMemory(Destination, Source, cbSize);
        } else {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }

    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {

        if (Destination != NULL) {
            UserFreePool(Destination);
        }

        return NULL;
    }

    return Destination;
}

//
// ported from Win95:ctxtman.c\SetConvMode()
//
VOID  SetConvMode( PTHREADINFO pti, DWORD dwConversion )
{
    if ( pti->spklActive == NULL )
        return;

    switch ( PRIMARYLANGID(HandleToUlong(pti->spklActive->hkl)) ) {
    case LANG_JAPANESE:

        ClearKeyStateDown(pti->pq, VK_DBE_ALPHANUMERIC);
        ClearKeyStateToggle(pti->pq, VK_DBE_ALPHANUMERIC);
        ClearKeyStateDown(pti->pq, VK_DBE_KATAKANA);
        ClearKeyStateToggle(pti->pq, VK_DBE_KATAKANA);
        ClearKeyStateDown(pti->pq, VK_DBE_HIRAGANA);
        ClearKeyStateToggle(pti->pq, VK_DBE_HIRAGANA);

        if ( dwConversion & IME_CMODE_NATIVE ) {
            if ( dwConversion & IME_CMODE_KATAKANA ) {
                SetKeyStateDown( pti->pq, VK_DBE_KATAKANA);
                SetKeyStateToggle( pti->pq, VK_DBE_KATAKANA);
            } else {
                SetKeyStateDown( pti->pq, VK_DBE_HIRAGANA);
                SetKeyStateToggle( pti->pq, VK_DBE_HIRAGANA);
            }
        } else {
            SetKeyStateDown( pti->pq, VK_DBE_ALPHANUMERIC);
            SetKeyStateToggle( pti->pq, VK_DBE_ALPHANUMERIC);
        }

        if ( dwConversion & IME_CMODE_FULLSHAPE ) {
            SetKeyStateDown( pti->pq, VK_DBE_DBCSCHAR);
            SetKeyStateToggle( pti->pq, VK_DBE_DBCSCHAR);
            ClearKeyStateDown(pti->pq, VK_DBE_SBCSCHAR);
            ClearKeyStateToggle(pti->pq, VK_DBE_SBCSCHAR);
        } else {
            SetKeyStateDown( pti->pq, VK_DBE_SBCSCHAR);
            SetKeyStateToggle( pti->pq, VK_DBE_SBCSCHAR);
            ClearKeyStateDown(pti->pq, VK_DBE_DBCSCHAR);
            ClearKeyStateToggle(pti->pq, VK_DBE_DBCSCHAR);
        }

        if ( dwConversion & IME_CMODE_ROMAN ) {
            SetKeyStateDown( pti->pq, VK_DBE_ROMAN);
            SetKeyStateToggle( pti->pq, VK_DBE_ROMAN);
            ClearKeyStateDown(pti->pq, VK_DBE_NOROMAN);
            ClearKeyStateToggle(pti->pq, VK_DBE_NOROMAN);
        } else {
            SetKeyStateDown( pti->pq, VK_DBE_NOROMAN);
            SetKeyStateToggle( pti->pq, VK_DBE_NOROMAN);
            ClearKeyStateDown(pti->pq, VK_DBE_ROMAN);
            ClearKeyStateToggle(pti->pq, VK_DBE_ROMAN);
        }

        if ( dwConversion & IME_CMODE_CHARCODE ) {
            SetKeyStateDown( pti->pq, VK_DBE_CODEINPUT);
            SetKeyStateToggle( pti->pq, VK_DBE_CODEINPUT);
            ClearKeyStateDown(pti->pq, VK_DBE_NOCODEINPUT);
            ClearKeyStateToggle(pti->pq, VK_DBE_NOCODEINPUT);
        } else {
            SetKeyStateDown( pti->pq, VK_DBE_NOCODEINPUT);
            SetKeyStateToggle( pti->pq, VK_DBE_NOCODEINPUT);
            ClearKeyStateDown(pti->pq, VK_DBE_CODEINPUT);
            ClearKeyStateToggle(pti->pq, VK_DBE_CODEINPUT);
        }
        break;

    case LANG_KOREAN:
        if ( dwConversion & IME_CMODE_NATIVE) {
            SetKeyStateToggle( pti->pq, VK_HANGUL);
        } else {
            ClearKeyStateToggle( pti->pq, VK_HANGUL);
        }

        if ( dwConversion & IME_CMODE_FULLSHAPE ) {
            SetKeyStateToggle( pti->pq, VK_JUNJA);
        } else {
            ClearKeyStateToggle( pti->pq, VK_JUNJA);
        }

        if ( dwConversion & IME_CMODE_HANJACONVERT ) {
            SetKeyStateToggle( pti->pq, VK_HANJA);
        } else {
            ClearKeyStateToggle( pti->pq, VK_HANJA);
        }
        break;

    default:
        break;
    }
    return;
}

//
// called by IMM32 client when:
//
//      input focus is switched
//   or IME open status is changed
//   or IME conversion status is changed
//
//
VOID xxxNotifyIMEStatus(
                       IN PWND pwnd,
                       IN DWORD dwOpen,
                       IN DWORD dwConversion )
{
    PTHREADINFO pti;

    CheckLock(pwnd);

    if ( (pti = GETPTI(pwnd)) != NULL && gptiForeground != NULL ) {
        if ( pti == gptiForeground || pti->pq == gptiForeground->pq ) {

            if ( gHimcFocus != pwnd->hImc   ||
                 gdwIMEOpenStatus != dwOpen ||
                 gdwIMEConversionStatus != dwConversion ) {

                //
                // save the new status
                //
                gHimcFocus = pwnd->hImc;
                if ( gHimcFocus != (HIMC)NULL ) {

                    RIPMSG2(RIP_VERBOSE, "xxxNotifyIMEStatus: newOpen=%x newConv=%x",
                            dwOpen, dwConversion);
                    gdwIMEOpenStatus = dwOpen;
                    gdwIMEConversionStatus = dwConversion;

                    //
                    // set keyboard states that are related to IME conversion status
                    //
                    SetConvMode(pti, dwOpen ? dwConversion : 0);
                }

                //
                // notify shell the IME status change
                //
                // Implementation note: [takaok 9/5/96]
                //
                // Using HSHELL_LANGUAGE is not the best way to inform shell
                // IME status change because we didn't change the keyboard layout.
                // ( The spec says HSHELL_LANGUAGE is for keyboard layout change.
                //  Also passing window handle as WPARAM is not documented )
                //
                // This is same as what Win95 does. I won't change this for now
                // because in the future shell will be developed by a different
                // group in MS.
                //
                // Currently only Korean Windows is interested in getting
                // the conversion status change.
                //
                if (IsHooked(pti, WHF_SHELL)) {
                    HKL hkl = NULL;

                    if (pti->spklActive != NULL) {
                        hkl = pti->spklActive->hkl;
                    }
                    xxxCallHook(HSHELL_LANGUAGE, (WPARAM)HWq(pwnd), (LPARAM)hkl, WH_SHELL);
                }

                //
                // notify keyboard driver
                //
                NlsKbdSendIMENotification(dwOpen,dwConversion);
            }
        }
    }
}

//---------------------------------------------------------------------------
//
// xxxCheckImeShowStatus() -
//
// Only one Status Window should be shown in the System.
// This functsion enums all IME window and check the show status of them.
//
// If pti is NULL, check all toplevel windows regardless their owners.
// If pti is not NULL, check only windows belong to the thread.
//
//----------------------------------------------------------------------------

BOOL xxxCheckImeShowStatus(PWND pwndIme, PTHREADINFO pti)
{
    PBWL pbwl;
    PHWND phwnd;
    BOOL fRet = FALSE;
    PTHREADINFO ptiCurrent = PtiCurrent();

    if (TestWF(pwndIme, WFINDESTROY)) {
        return FALSE;
    }

    // Parent window of IME window should be the desktop window
    UserAssert(pwndIme);
    UserAssert(pwndIme->spwndParent == GETPTI(pwndIme)->pDeskInfo->spwnd);

    pbwl = BuildHwndList(pwndIme->spwndParent->spwndChild, BWL_ENUMLIST, NULL);
    if (pbwl != NULL) {
        fRet = TRUE;
        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
            PWND pwndT = RevalidateHwnd(*phwnd);

            // If pwndT is the current active IME window, we should skip it
            // since it's the only one window allowed to show status, and
            // we've already taken care of it.
            if (pwndT == NULL || (/*pwndIme && */pwndIme == pwndT)) {   // Can skip pwndIme != NULL test
                continue;
            }

            // We are going to touch IME windows only
            if (pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME] &&
                    !TestWF(pwndT, WFINDESTROY)) {

                PIMEUI pimeui = ((PIMEWND)pwndT)->pimeui;

                if (pimeui == NULL || pimeui == (PIMEUI)-1) {
                    continue;
                }

                if (pti == NULL || pti == GETPTI(pwndT)) {
                    BOOLEAN fAttached = FALSE;
                    PWND    pwndIMC;

                    // If pwndT is not a window of the current process, we have to138163
                    // attach the process to get access to pimeui.
                    if (GETPTI(pwndT)->ppi != ptiCurrent->ppi) {
                        RIPMSG0(RIP_VERBOSE, "Attaching process in xxxCheckImeShowStatus");
                        KeAttachProcess(PsGetProcessPcb(GETPTI(pwndT)->ppi->Process));
                        fAttached = TRUE;
                    }

                    try {
                        if (ProbeAndReadStructure(pimeui, IMEUI).fShowStatus) {
                            if (pti == NULL) {
                                RIPMSG0(RIP_VERBOSE, "xxxCheckImeShowStatus: the status window is shown !!");
                            }
                            if ((pwndIMC = RevalidateHwnd(pimeui->hwndIMC)) != NULL) {
                                pimeui->fShowStatus = FALSE;
                            }
                        } else {
                            pwndIMC = NULL;
                        }

                    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                          pwndIMC = NULL;
                    }
                    if (fAttached) {
                        KeDetachProcess();
                    }

                    if (pwndIMC && GETPTI(pwndIMC) && !(GETPTI(pwndIMC)->TIF_flags & TIF_INCLEANUP)) {
                        TL tl;

                        ThreadLockAlways(pwndIMC, &tl);
                        RIPMSG1(RIP_VERBOSE, "Sending WM_IME_NOTIFY to %#p, IMN_CLOSESTATUSWINDOW", pwndIMC);
                        xxxSendMessage(pwndIMC, WM_IME_NOTIFY, IMN_CLOSESTATUSWINDOW, 0L);
                        ThreadUnlock(&tl);
                    }

                }
            }
        }
        FreeHwndList(pbwl);
    }
    return fRet;
}

LRESULT xxxSendMessageToUI(
    PTHREADINFO ptiIme,
    PIMEUI pimeui,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    PWND  pwndUI;
    LRESULT lRet = 0L;
    TL    tl;
    BOOL  fAttached = FALSE;

    CheckCritIn();

    if (ptiIme != PtiCurrent()) {
        fAttached = TRUE;
        KeAttachProcess(PsGetProcessPcb(ptiIme->ppi->Process));
    }

    try {
        pwndUI = RevalidateHwnd(ProbeAndReadStructure(pimeui, IMEUI).hwndUI);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        pwndUI = NULL;
    }

    if (pwndUI != NULL){
        try {
            ProbeAndReadUlong((PULONG)&pimeui->nCntInIMEProc);
            InterlockedIncrement(&pimeui->nCntInIMEProc);   // Mark to avoid recursion.
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
              goto skip_it;
        }
        if (fAttached) {
            KeDetachProcess();
        }

        ThreadLockAlways(pwndUI, &tl);
        RIPMSG3(RIP_VERBOSE, "Sending message UI pwnd=%#p, msg:%x to wParam=%#p", pwndUI, message, wParam);
        lRet = xxxSendMessage(pwndUI, message, wParam, lParam);
        ThreadUnlock(&tl);

        if (fAttached) {
            KeAttachProcess(PsGetProcessPcb(ptiIme->ppi->Process));
        }
        try {
            InterlockedDecrement(&pimeui->nCntInIMEProc);   // Mark to avoid recursion.
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }
    }
skip_it:
    if (fAttached) {
        KeDetachProcess();
    }

    return lRet;
}

VOID xxxSendOpenStatusNotify(
    PTHREADINFO ptiIme,
    PIMEUI pimeui,
    PWND   pwndApp,
    BOOL   fOpen)
{
    WPARAM wParam = fOpen ? IMN_OPENSTATUSWINDOW : IMN_CLOSESTATUSWINDOW;

    UserAssert(GETPTI(pwndApp));

    if (LOWORD(GETPTI(pwndApp)->dwExpWinVer >= VER40) && pwndApp->hImc != NULL) {
        TL tl;
        ThreadLockAlways(pwndApp, &tl);
        RIPMSG2(RIP_VERBOSE, "Sending %s to pwnd=%#p",
                fOpen ? "IMN_OPENSTATUSWINDOW" : "IMN_CLOSESTATUSWINDOW",
                pwndApp);
        xxxSendMessage(pwndApp, WM_IME_NOTIFY, wParam, 0L);
        ThreadUnlock(&tl);
    }
    else {
        xxxSendMessageToUI(ptiIme, pimeui, WM_IME_NOTIFY, wParam, 0L);
    }

    return;
}

VOID xxxNotifyImeShowStatus(PWND pwndIme)
{
    PIMEUI pimeui;
    BOOL fShow;
    PWND pwnd;
    PTHREADINFO ptiIme, ptiCurrent;
    BOOL fSendOpenStatusNotify = FALSE;

    if (!IS_IME_ENABLED() || TestWF(pwndIme, WFINDESTROY)) {
        RIPMSG0(RIP_WARNING, "IME is not enabled or in destroy.");
        return;
    }

    ptiCurrent = PtiCurrent();
    ptiIme = GETPTI(pwndIme);

    if (ptiIme != ptiCurrent) {
        RIPMSG1(RIP_VERBOSE, "Attaching pti=%#p", ptiIme);
        KeAttachProcess(PsGetProcessPcb(GETPTI(pwndIme)->ppi->Process));
    }

    try {
        pimeui = ((PIMEWND)pwndIme)->pimeui;
        fShow = gfIMEShowStatus && ProbeAndReadStructure(pimeui, IMEUI).fCtrlShowStatus;

        pwnd = RevalidateHwnd(pimeui->hwndIMC);

        if (pwnd != NULL || (pwnd = GETPTI(pwndIme)->pq->spwndFocus) != NULL) {
            RIPMSG0(RIP_VERBOSE, "Setting new show status.");
            fSendOpenStatusNotify = TRUE;
            pimeui->fShowStatus = fShow;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
          if (ptiIme != ptiCurrent) {
              KeDetachProcess();
          }
          return;
    }
    if (ptiIme != ptiCurrent) {
        KeDetachProcess();
    }

    if (fSendOpenStatusNotify) {
        RIPMSG1(RIP_VERBOSE, "Sending OpenStatus fShow=%d", fShow);
        xxxSendOpenStatusNotify(ptiIme, pimeui, pwnd, fShow);
    }

    // Check the show status of all IME windows in the system.
    if (!TestWF(pwndIme, WFINDESTROY)) {
        xxxCheckImeShowStatus(pwndIme, NULL);
    }
}


/***************************************************************************\
* xxxSetIMEShowStatus() -
*
* Set IME Status windows' show status. Called from SystemParametersInfo()
* handler.
*
\***************************************************************************/

BOOL xxxSetIMEShowStatus(IN BOOL fShow)
{
    CheckCritIn();

    UserAssert(fShow == FALSE || fShow == TRUE);

    if (gfIMEShowStatus == fShow) {
        return TRUE;
    }

    if (gfIMEShowStatus == IMESHOWSTATUS_NOTINITIALIZED) {
        /*
         * Called for the first time after logon.
         * No need to write the value to the registry.
         */
        gfIMEShowStatus = fShow;
    }
    else {
        /*
         * We need to save the new fShow status to the registry.
         */
        TL tlName;
        PUNICODE_STRING pProfileUserName;
        BOOL fOK = FALSE;

        pProfileUserName = CreateProfileUserName(&tlName);
        if (pProfileUserName) {
            UserAssert(pProfileUserName != NULL);
            fOK = UpdateWinIniInt(pProfileUserName, PMAP_INPUTMETHOD, STR_SHOWIMESTATUS, fShow);
            FreeProfileUserName(pProfileUserName, &tlName);
        }
        if (!fOK) {
            return FALSE;
        }
        gfIMEShowStatus = fShow;
    }

    /*
     * If IME is not enabled, further processing is not needed
     */
    if (!IS_IME_ENABLED()) {
        return TRUE;
    }

    /*
     * Let the current active IME window know the change.
     */
    if (gpqForeground && gpqForeground->spwndFocus) {
        PTHREADINFO ptiFocus = GETPTI(gpqForeground->spwndFocus);
        TL tl;

        UserAssert(ptiFocus);

        if (ptiFocus->spwndDefaultIme && !(ptiFocus->TIF_flags & TIF_INCLEANUP)) {
            ThreadLockAlways(ptiFocus->spwndDefaultIme, &tl);
            xxxNotifyImeShowStatus(ptiFocus->spwndDefaultIme);
            ThreadUnlock(&tl);
        }
    }

    return TRUE;
}

/***************************************************************************\
* xxxBroadcastImeShowStatusChange() -
*
* Let all IME windows in the desktop, including myself  know about the
* status change.
* This routine does not touch the registry, assuming internat.exe updated
* the registry.
*
\***************************************************************************/

VOID xxxBroadcastImeShowStatusChange(PWND pwndIme, BOOL fShow)
{
    CheckCritIn();

    gfIMEShowStatus = !!fShow;
    xxxNotifyImeShowStatus(pwndIme);
}

/***************************************************************************\
* xxxCheckImeShowStatusInThread() -
*
* Let all IME windows in the same thread know about the status change.
* Called from ImeSetContextHandler().
*
\***************************************************************************/
VOID xxxCheckImeShowStatusInThread(PWND pwndIme)
{
    if (IS_IME_ENABLED()) {
        UserAssert(pwndIme);

        if (!TestWF(pwndIme, WFINDESTROY)) {
            xxxCheckImeShowStatus(pwndIme, GETPTI(pwndIme));
        }
    }
}

BOOL _GetIMEShowStatus(VOID)
{
    return gfIMEShowStatus != FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\ntinput.c ===
/****************************** Module Header ******************************\
* Module Name: ntinput.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains low-level input code specific to the NT
* implementation of Win32 USER, which is mostly the interfaces to the
* keyboard and mouse device drivers.
*
* History:
* 11-26-90 DavidPe      Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <ntddmou.h>


PKWAIT_BLOCK  gWaitBlockArray;

KEYBOARD_UNIT_ID_PARAMETER kuid;
MOUSE_UNIT_ID_PARAMETER muid;

typedef struct tagSCANCODEFLEXIBLEMAP {
    struct {
        BYTE bScanCode;
        BYTE bPrefix;
        BYTE abModifiers[6];
    } Orig;
    struct {
        BYTE bScanCode;
        BYTE bPrefix;
        BYTE abModifiers[6];
    } Target;
} SCANCODEFLEXIBLEMAP, FAR *LPSCANCODEFLEXIBLEMAP;

BYTE bLastVKDown = 0;
int iLastMatchedTarget = -1;


SCANCODEFLEXIBLEMAP* gpFlexMap;
DWORD gdwFlexMapSize;



VOID ProcessQueuedMouseEvents(VOID);
#ifndef SUBPIXEL_MOUSE
LONG DoMouseAccel(LONG delta);
#endif
VOID GetMouseCoord(LONG dx, LONG dy, DWORD dwFlags, LONG time, ULONG_PTR ExtraInfo, PPOINT ppt);
VOID xxxMoveEventAbsolute(LONG x, LONG y, ULONG_PTR dwExtraInfo,
#ifdef GENERIC_INPUT
            HANDLE hDevice,
            PMOUSE_INPUT_DATA pmei,
#endif
            DWORD time,
            BOOL bInjected);

VOID ProcessKeyboardInputWorker(PKEYBOARD_INPUT_DATA pkei,
#ifdef GENERIC_INPUT
                                PDEVICEINFO pDeviceInfo,
#endif
                                BOOL fProcessRemap);


INT  idxRemainder, idyRemainder;

BYTE gbVKLastDown;

/*
 * Mouse/Kbd diagnostics for #136483 etc. Remove when PNP is stable (IanJa)
 */
#ifdef DIAGNOSE_IO
ULONG    gMouseProcessMiceInputTime = 0;  // tick at start of ProcessMiceInput
ULONG    gMouseQueueMouseEventTime = 0;   // tick at start of QueueMouseEvent
ULONG    gMouseUnqueueMouseEventTime = 0; // tick at start of UnqueueMouseEvent

// Return a value as close as possible to the system's tick count,
// yet guaranteed to be larger than the value returned last time.
// (useful for sequencing events)
// BUG: when NtGetTickCount overflows, the value returned by MonotonicTick
// will not track system tick count well: instead it will increase by one
// each time until it too overflows. (considerd harmless for IO DIAGNOSTICS)
ULONG MonotonicTick()
{
    static ULONG lasttick = 0;
    ULONG newtick;

    newtick = NtGetTickCount();
    if (newtick > lasttick) {
        lasttick = newtick;  // use the new tick since it is larger
    } else {
        lasttick++;          // artificially bump the tick up one.
    }
    return lasttick;
}

#endif

/*
 * Parameter Constants for xxxButtonEvent()
 */
#define MOUSE_BUTTON_LEFT   0x0001
#define MOUSE_BUTTON_RIGHT  0x0002
#define MOUSE_BUTTON_MIDDLE 0x0004
#define MOUSE_BUTTON_X1     0x0008
#define MOUSE_BUTTON_X2     0x0010

#define ID_INPUT       0
#define ID_MOUSE       1

#define ID_TIMER       2
#define ID_HIDCHANGE   3
#define ID_SHUTDOWN    4

#ifdef GENERIC_INPUT
#define ID_TRUEHIDCHANGE                5
#define ID_WDTIMER                      6
#define ID_NUMBER_HYDRA_REMOTE_HANDLES  7
#else   // GENERIC_INPUT
#define ID_WDTIMER                      5
#define ID_NUMBER_HYDRA_REMOTE_HANDLES  6
#endif  // GENERIC_INPUT

PKTIMER gptmrWD;

PVOID *apObjects;


/***************************************************************************\
* fAbsoluteMouse
*
* Returns TRUE if the mouse event has absolute coordinates (as apposed to the
* standard delta values we get from MS and PS2 mice)
*
* History:
* 23-Jul-1992 JonPa     Created.
\***************************************************************************/
#define fAbsoluteMouse( pmei )      \
        (((pmei)->Flags & MOUSE_MOVE_ABSOLUTE) != 0)

/***************************************************************************\
* ConvertToMouseDriverFlags
*
* Converts SendInput kind of flags to mouse driver flags as GetMouseCoord
* needs them.
* As mouse inputs are more frequent than send inputs, we penalize the later.
*
* History:
* 17-dec-1997 MCostea     Created.
\***************************************************************************/
#if ((MOUSEEVENTF_ABSOLUTE >> 15) ^ MOUSE_MOVE_ABSOLUTE) || \
    ((MOUSEEVENTF_VIRTUALDESK >> 13) ^ MOUSE_VIRTUAL_DESKTOP)
#   error("Bit mapping broken: fix ConvertToMouseDriverFlags")
#endif

#define ConvertToMouseDriverFlags( Flags )      \
        (((Flags) & MOUSEEVENTF_ABSOLUTE) >> 15 | \
         ((Flags) & MOUSEEVENTF_VIRTUALDESK) >> 13)

#define VKTOMODIFIERS(Vk) ((((Vk) >= VK_SHIFT) && ((Vk) <= VK_MENU)) ? \
                           (MOD_SHIFT >> ((Vk) - VK_SHIFT)) :           \
                           0)
#if (VKTOMODIFIERS(VK_SHIFT) != MOD_SHIFT) || \
    (VKTOMODIFIERS(VK_CONTROL) != MOD_CONTROL) || \
    (VKTOMODIFIERS(VK_MENU) != MOD_ALT)
#   error("VKTOMODIFIERS broken")
#endif


/***************************************************************************\
* xxxInitInput
*
* This function is called from CreateTerminalInput() and gets USER setup to
* process keyboard and mouse input.  It starts the RIT for that terminal.
* History:
* 11-26-90 DavidPe      Created.
\***************************************************************************/
BOOL xxxInitInput(
    PTERMINAL pTerm)
{
    NTSTATUS Status;
    USER_API_MSG m;
    RIT_INIT initData;

UserAssert(pTerm != NULL);

#ifdef MOUSE_LOCK_CODE
    /*
     * Lock RIT pages into memory
     */
    LockMouseInputCodePages();
#endif

    initData.pTerm = pTerm;
    initData.pRitReadyEvent = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (initData.pRitReadyEvent == NULL) {
        return FALSE;
    }
    /*
     * Create the RIT and let it run.
     */

    if (!InitCreateSystemThreadsMsg(&m, CST_RIT, &initData, 0, FALSE)) {
        FreeKernelEvent(&initData.pRitReadyEvent);
        return FALSE;
    }
    /*
     * Be sure that we are not in CSRSS context.
     * WARNING: If for any reason we changed this to run in CSRSS context then we have to use
     * LpcRequestPort instead of LpcRequestWaitReplyPort.
     */
    UserAssert (!ISCSRSS());

    LeaveCrit();
    Status = LpcRequestWaitReplyPort(CsrApiPort, (PPORT_MESSAGE)&m, (PPORT_MESSAGE)&m);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    KeWaitForSingleObject(initData.pRitReadyEvent, WrUserRequest,
            KernelMode, FALSE, NULL);
Exit:
    FreeKernelEvent(&initData.pRitReadyEvent);
    EnterCrit();

    return (gptiRit != NULL);
}


/***************************************************************************\
* InitScancodeMap
*
* Fetches the scancode map from the registry, allocating space as required.
*
* A scancode map is used to convert unusual OEM scancodes into standard
* "Scan Code Set 1" values.  This is to support KB3270 keyboards, but can
* be used for other types too.
*
* History:
* 96-04-18 IanJa      Created.
\***************************************************************************/



const WCHAR gwszScancodeMap[] = L"Scancode Map";
const WCHAR gwszScancodeMapEx[] = L"Scancode Map Ex";


VOID InitScancodeMap(
    PUNICODE_STRING pProfileName)
{
    DWORD dwBytes;
    UINT idSection;
    PUNICODE_STRING pPN;
    LPBYTE pb;

    TAGMSG2(DBGTAG_KBD, "InitScancodeMap with pProfileName=%#p, \"%S\"", pProfileName,
            pProfileName ? pProfileName->Buffer : L"");

    if (gpScancodeMap) {
        UserFreePool(gpScancodeMap);
        gpScancodeMap = NULL;
    }

    if (!IsRemoteConnection()) {
        /*
         * Read basic scancode mapping information.
         * Firstly try per user, and then per system.
         */
        idSection = PMAP_UKBDLAYOUT;
        pPN = pProfileName;
        dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMap, NULL, NULL, 0, 0);
        if (dwBytes == 0) {
            idSection = PMAP_KBDLAYOUT;
            pPN = NULL;
            dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMap, NULL, NULL, 0, 0);
        }
        if (dwBytes > sizeof(SCANCODEMAP)) {
            pb = UserAllocPoolZInit(dwBytes, TAG_SCANCODEMAP);
            if (pb) {
                dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMap, NULL, pb, dwBytes, 0);
                gpScancodeMap = (SCANCODEMAP*)pb;
            }
        }
    }

    /*
     * Read extended scancode mapping information.
     * Firstly try per user, then per system.
     */
    if (gpFlexMap) {
        UserFreePool(gpFlexMap);
        gpFlexMap = NULL;
        gdwFlexMapSize = 0;
    }

    if (!IsRemoteConnection()) {
        idSection = PMAP_UKBDLAYOUT;
        pPN = pProfileName;
        dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMapEx, NULL, NULL, 0, 0);
        if (dwBytes == 0) {
            TAGMSG0(DBGTAG_KBD, "InitScancodeMap: mapex is not in per-user profile. will use the system's");
            idSection = PMAP_KBDLAYOUT;
            pPN = NULL;
            dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMapEx, NULL, NULL, 0, 0);
        }
        if (dwBytes >= sizeof(SCANCODEFLEXIBLEMAP) && dwBytes % sizeof(SCANCODEFLEXIBLEMAP) == 0) {
            if ((pb = UserAllocPoolZInit(dwBytes, TAG_SCANCODEMAP)) != NULL) {
                dwBytes = FastGetProfileValue(pPN, idSection, gwszScancodeMapEx, NULL, pb, dwBytes, 0);
                gpFlexMap = (SCANCODEFLEXIBLEMAP*)pb;
                gdwFlexMapSize = dwBytes / sizeof(SCANCODEFLEXIBLEMAP);
            }
        }
#if DBG
        else if (dwBytes != 0) {
            TAGMSG1(DBGTAG_KBD, "InitScancodeMap: incorrect dwSize(0x%x) specified.", dwBytes);
        }
#endif
    }
}

/***************************************************************************\
* MapScancode
*
* Converts a scancode (and it's prefix, if any) to a different scancode
* and prefix.
*
* Parameters:
*   pbScanCode = address of Scancode byte, the scancode may be changed
*   pbPrefix   = address of Prefix byte, The prefix may be changed
*
* Return value:
*   TRUE  - mapping was found, scancode was altered.
*   FALSE - no mapping found, scancode was not altered.
*
* Note on scancode map table format:
*     A table entry DWORD of 0xE0450075 means scancode 0x45, prefix 0xE0
*     gets mapped to scancode 0x75, no prefix
*
* History:
* 96-04-18 IanJa      Created.
\***************************************************************************/

PKBDTABLES GetCurrentKbdTables()
{
    PKBDTABLES pKbdTbl;
    PTHREADINFO pti;

    CheckCritIn();
    if (gpqForeground == NULL) {
        TAGMSG0(DBGTAG_KBD, "GetCurrentKbdTables: NULL gpqForeground\n");
        return NULL;
    }

    pti = PtiKbdFromQ(gpqForeground);
    UserAssert(pti);
    if (pti->spklActive) {
        pKbdTbl = pti->spklActive->spkf->pKbdTbl;
    } else {
        RIPMSG0(RIP_WARNING, "SendKeyUpDown: NULL spklActive\n");
        pKbdTbl = gpKbdTbl;
    }
    UserAssert(pKbdTbl);

    return pKbdTbl;
}

VOID SendKeyUpDown(
    CONST BYTE bVK,
    CONST BOOLEAN fBreak)
{
    KE ke;
    PKBDTABLES pKbdTbl;

    CheckCritIn();

    ke.dwTime = 0;
    ke.usFlaggedVk = bVK | KBDMAPPEDVK;
    if (fBreak) {
        ke.usFlaggedVk |= KBDBREAK;
    }

    //
    // If scancode is not specified (==0), we need to
    // find the scancode value from the virtual key code.
    //
    pKbdTbl = GetCurrentKbdTables();
    if (pKbdTbl) {
        ke.bScanCode = (BYTE)InternalMapVirtualKeyEx(bVK, 0, pKbdTbl);
    }

    TAGMSG1(DBGTAG_KBD, "Sending Key for VK=%04x", ke.usFlaggedVk);

    xxxProcessKeyEvent(&ke, 0, TRUE);
}

__inline VOID SendKeyDown(
    CONST BYTE bVK)
{
    SendKeyUpDown(bVK, FALSE);
}

__inline VOID SendKeyUp(
    CONST BYTE bVK)
{
    SendKeyUpDown(bVK, TRUE);
}

BOOL IsKeyDownSpecified(CONST BYTE bVK, CONST BYTE* pbMod)
{
    int i;

    for (i = 0; i < sizeof((SCANCODEFLEXIBLEMAP*)NULL)->Orig.abModifiers && pbMod[i]; ++i) {
        if (bVK == pbMod[i]) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL MapFlexibleKeys(PKE pke, CONST BYTE bPrefix
#ifdef GENERIC_INPUT
                     , PDEVICEINFO pDeviceInfo
#endif
                     )
{
    UINT i;
    static const BYTE abModifiers[] = {
        VK_LCONTROL,    VK_RCONTROL,
        VK_LSHIFT,      VK_RSHIFT,
        VK_LMENU,       VK_RMENU,
        VK_LWIN,        VK_RWIN,
        VK_APPS,        VK_CAPITAL,
    };

    for (i = 0; i < gdwFlexMapSize; ++i) {
        if (gpFlexMap[i].Orig.bPrefix == bPrefix && gpFlexMap[i].Orig.bScanCode == pke->bScanCode) {
            UINT j;

            if ((pke->usFlaggedVk & KBDBREAK) && i == (UINT)iLastMatchedTarget) {
                //
                // If this is a keyup event, and if it matches the last substituted
                // key, we want to send keyup event right away.
                //
                iLastMatchedTarget = -1;
                break;
            }

            for (j = 0; j < ARRAY_SIZE(abModifiers); ++j) {
                BYTE bVK = abModifiers[j];

                if (bVK == bLastVKDown) {
                    //
                    // Ignore the key if it's previously substituted by us.
                    //
                    bLastVKDown = 0;
                    continue;
                }
                if (!TestKeyDownBit(gafRawKeyState, bVK) == IsKeyDownSpecified(bVK, gpFlexMap[i].Orig.abModifiers)) {
                    TAGMSG1(DBGTAG_KBD, "MapFlexibleKeys: not match by vk=%02x", bVK);
                    // No match!
                    break;
                }
            }

            if (j >= ARRAY_SIZE(abModifiers)) {
                // We found the match. Now break the loop.
                TAGMSG1(DBGTAG_KBD, "MapFlexibleKeys: found a match for sc=%02x", gpFlexMap[i].Orig.bScanCode);
                break;
            }
        }
    }

    if (i < gdwFlexMapSize) {
        KEYBOARD_INPUT_DATA kei;
        UINT j, nUp = 0, nDown = 0;
        BYTE bVKModUp[ARRAY_SIZE(((SCANCODEFLEXIBLEMAP*)NULL)->Orig.abModifiers)];
        BYTE bVKModDown[ARRAY_SIZE(((SCANCODEFLEXIBLEMAP*)NULL)->Target.abModifiers)];

        // We found it.
        // Yes, this key.
        TAGMSG3(DBGTAG_KBD, "MapFlexibleKeys: found a match %d (prefix=%x, sc=%x).", i, gpFlexMap[i].Orig.bPrefix, gpFlexMap[i].Orig.bScanCode);

        //
        // If this is a keydown event, we want to simulate
        // the modifier keys.
        //
        if ((pke->usFlaggedVk & KBDBREAK) == 0) {
            //
            // Now we need to adjust the down state of the modifieres, which is currently
            // pressed but not specified in the substitute.
            // For instance, if CTRL key is pressed now, but if CTRL is not specified in the substitute
            // modifiers list, we need to make an artificial keyup so that we'll be able to fake the
            // situation. Of cource, we need to push CTRL key after we finish remapping.
            //
            for (j = 0; j < ARRAY_SIZE(gpFlexMap[i].Orig.abModifiers) && gpFlexMap[i].Orig.abModifiers[j]; ++j) {
                if (!IsKeyDownSpecified(gpFlexMap[i].Orig.abModifiers[j], gpFlexMap[i].Target.abModifiers)) {
                    //
                    // We need to send UP key for this one.
                    //
                    bVKModUp[nUp++] = gpFlexMap[i].Orig.abModifiers[j];
                    SendKeyUp(gpFlexMap[i].Orig.abModifiers[j]);
                }
            }
            for (j = 0; j < ARRAY_SIZE(gpFlexMap[i].Target.abModifiers) && gpFlexMap[i].Target.abModifiers[i]; ++j) {
                if (!IsKeyDownSpecified(gpFlexMap[i].Target.abModifiers[j], gpFlexMap[i].Orig.abModifiers)) {
                    //
                    // We need to send DOWN key for this one.
                    //
                    bVKModDown[nDown++] = gpFlexMap[i].Target.abModifiers[j];
                    SendKeyDown(gpFlexMap[i].Target.abModifiers[j]);
                }
            }
        }

        //
        // Now we are ready to send the substituted key.
        //
        kei.ExtraInformation = 0;
        kei.Flags = 0;
        if (gpFlexMap[i].Target.bPrefix == 0xE0) {
            kei.Flags |= KEY_E0;
        } else if (gpFlexMap[i].Target.bPrefix == 0xE1) {
            kei.Flags |= KEY_E1;
        }
        if (pke->usFlaggedVk & KBDBREAK) {
            kei.Flags |= KEY_BREAK;
        }
        kei.MakeCode = gpFlexMap[i].Target.bScanCode;

        kei.UnitId = 0; // LATER:

        TAGMSG2(DBGTAG_KBD, "MapFlexibleKeys: injecting sc=%02x (flag=%x)",
                kei.MakeCode, kei.Flags);

        ProcessKeyboardInputWorker(&kei,
#ifdef GENERIC_INPUT
                                   pDeviceInfo,
#endif
                                   FALSE);

        if ((pke->usFlaggedVk & KBDBREAK) == 0) {
            //
            // Remember the last down key generated by me.
            // This will be used when matching the UP key.
            //
            bLastVKDown = gbVKLastDown;
            iLastMatchedTarget = i;
        }


        //
        // Restore the orignial modifier state.
        //
        for (j = 0; j < nUp; ++j) {
            SendKeyDown(bVKModUp[j]);
        }
        for (j = 0; j < nDown; ++j) {
            SendKeyUp(bVKModDown[j]);
        }

        //
        // Tell the caller we processed this key. The caller should
        // not continue handling this key if this function returns FALSE.
        //
        return FALSE;
    }

    return TRUE;
}

BOOL
MapScancode(
    PKE pke,
    PBYTE pbPrefix
#ifdef GENERIC_INPUT
    ,
    PDEVICEINFO pDeviceInfo
#endif
    )
{
    if (gpScancodeMap) {
        DWORD *pdw;
        WORD wT = MAKEWORD(pke->bScanCode, *pbPrefix);

        CheckCritIn();
        UserAssert(gpScancodeMap != NULL);

        for (pdw = &(gpScancodeMap->dwMap[0]); *pdw; pdw++) {
            if (HIWORD(*pdw) == wT) {
                wT = LOWORD(*pdw);
                pke->bScanCode = LOBYTE(wT);
                *pbPrefix = HIBYTE(wT);
                break;
            }
        }
    }

    return MapFlexibleKeys(pke, *pbPrefix
#ifdef GENERIC_INPUT
                           , pDeviceInfo
#endif
                           );
}



/***************************************************************************\
* InitMice
*
* This function initializes the data and settings before we start enumerating
* the mice.
*
* History:
* 11-18-97 IanJa      Created.
\***************************************************************************/

VOID InitMice()
{
    CLEAR_ACCF(ACCF_MKVIRTUALMOUSE);
    CLEAR_GTERMF(GTERMF_MOUSE);
    SYSMET(MOUSEPRESENT) = FALSE;
    SYSMET(CMOUSEBUTTONS) = 0;
    SYSMET(MOUSEWHEELPRESENT) = FALSE;
}

/***************************************************************************\
* FreeDeviceInfo
*
* Unlinks a DEVICEINFO struct from the gpDeviceInfoList list and frees the
* allocated memory UNLESS the device is actively being read (GDIF_READING) or
* has a PnP thread waiting for it in RequestDeviceChange() (GDIAF_PNPWAITING)
* If the latter, then wake the PnP thread via pkeHidChangeCompleted so that it
* can free the structure itself.
*
* Returns a pointer to the next DEVICEINFO struct, or NULL if the device was
* not found in the gpDeviceInfoList.
*
* History:
* 11-18-97 IanJa      Created.
\***************************************************************************/
PDEVICEINFO FreeDeviceInfo(PDEVICEINFO pDeviceInfo)
{
    PDEVICEINFO *ppDeviceInfo;

    CheckDeviceInfoListCritIn();

    TAGMSG1(DBGTAG_PNP, "FreeDeviceInfo(%#p)", pDeviceInfo);

    /*
     * We cannot free the device since we still have a read pending.
     * Mark it GDIAF_FREEME so that it will be freed when the APC is made
     * (see InputApc), or when the next read request is about to be issued
     * (see StartDeviceRead).
     */
    if (pDeviceInfo->bFlags & GDIF_READING) {
#if DIAGNOSE_IO
        pDeviceInfo->bFlags |= GDIF_READERMUSTFREE;
#endif
        TAGMSG1(DBGTAG_PNP, "** FreeDeviceInfo(%#p) DEFERRED : reader must free", pDeviceInfo);
        pDeviceInfo->usActions |= GDIAF_FREEME;
#ifdef TRACK_PNP_NOTIFICATION
        if (gfRecordPnpNotification) {
            RecordPnpNotification(PNP_NTF_FREEDEVICEINFO_DEFERRED, pDeviceInfo, pDeviceInfo->usActions);
        }
#endif
        return pDeviceInfo->pNext;
    }

    /*
     * If a PnP thread is waiting in RequestDeviceChange for some action to be
     * performed on this device, just mark it for freeing and signal that PnP
     * thread with the pkeHidChangeCompleted so that it will free it
     */
#ifdef GENERIC_INPUT
    /*
     * Now that pDeviceInfo is handle based, if we don't own the user critical section.
     * we mark it to be freed later on and have to bail out,
     */
    if ((pDeviceInfo->usActions & GDIAF_PNPWAITING) || !ExIsResourceAcquiredExclusiveLite(gpresUser))
#else
    if (pDeviceInfo->usActions & GDIAF_PNPWAITING)
#endif
    {
#if DIAGNOSE_IO
        pDeviceInfo->bFlags |= GDIF_PNPMUSTFREE;
#endif
        TAGMSG1(DBGTAG_PNP, "** FreeDeviceInfo(%#p) DEFERRED : PnP must free", pDeviceInfo);
        pDeviceInfo->usActions |= GDIAF_FREEME;
        KeSetEvent(pDeviceInfo->pkeHidChangeCompleted, EVENT_INCREMENT, FALSE);
        return pDeviceInfo->pNext;
    }

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        RecordPnpNotification(PNP_NTF_FREEDEVICEINFO, pDeviceInfo, pDeviceInfo->usActions);
    }
#endif


#ifdef GENERIC_INPUT
    CheckCritIn();
#endif

    ppDeviceInfo = &gpDeviceInfoList;

    while (*ppDeviceInfo) {
        if (*ppDeviceInfo == pDeviceInfo
#ifdef GENERIC_INPUT
            && HMMarkObjectDestroy(pDeviceInfo)
#endif
            ) {
            /*
             * Found the DEVICEINFO struct, so free it and its members.
             */
            if (pDeviceInfo->pkeHidChangeCompleted != NULL) {
                // N.b. the timing could be pretty critical around this
                FreeKernelEvent(&pDeviceInfo->pkeHidChangeCompleted);
            }
            if (pDeviceInfo->ustrName.Buffer != NULL) {
                UserFreePool(pDeviceInfo->ustrName.Buffer);
            }
#ifdef GENERIC_INPUT
            if (pDeviceInfo->type == DEVICE_TYPE_HID) {
                CheckCritIn();
                /*
                 * Unlock the device request list
                 */
                UserAssert(pDeviceInfo->hid.pTLCInfo);
                if (--pDeviceInfo->hid.pTLCInfo->cDevices == 0) {
                    if (!HidTLCActive(pDeviceInfo->hid.pTLCInfo)) {
                        // Nobody is interested in this device anymore
                        FreeHidTLCInfo(pDeviceInfo->hid.pTLCInfo);
                    }
                }
                /*
                 * Unlock the HID descriptor
                 */
                UserAssert(pDeviceInfo->hid.pHidDesc);
                FreeHidDesc(pDeviceInfo->hid.pHidDesc);
            }
#endif

            *ppDeviceInfo = pDeviceInfo->pNext;

#ifdef GENERIC_INPUT
            TAGMSG1(DBGTAG_PNP, "FreeDeviceInfo: freeing deviceinfo=%#p", pDeviceInfo);
            HMFreeObject(pDeviceInfo);
#else
            UserFreePool(pDeviceInfo);
#endif

            return *ppDeviceInfo;
        }
        ppDeviceInfo = &(*ppDeviceInfo)->pNext;
    }
    RIPMSG1(RIP_ERROR, "pDeviceInfo %#p not found in gpDeviceInfoList", pDeviceInfo);

    return NULL;
}

/***************************************************************************\
* UpdateMouseInfo
*
* This function updates mouse information for a remote session.
*
* History:
* 05-22-98 clupu      Created.
\***************************************************************************/
VOID UpdateMouseInfo(
    VOID)
{
    DEVICEINFO *pDeviceInfo;
    CheckCritIn();               // expect no surprises

    UserAssert(IsRemoteConnection());

    if (ghRemoteMouseChannel == NULL) {
        return;
    }

    UserAssert(gnMice == 1);

    /*
     * Mark the mice and signal the RIT to do the work asynchronously
     */
    EnterDeviceInfoListCrit();
    for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
        if (pDeviceInfo->type == DEVICE_TYPE_MOUSE) {
            TAGMSG1(DBGTAG_PNP, "UpdateMouseInfo(): pDeviceInfo %#p ARRIVED", pDeviceInfo);
            RequestDeviceChange(pDeviceInfo, GDIAF_ARRIVED | GDIAF_RECONNECT, TRUE);
        }
    }
    LeaveDeviceInfoListCrit();
}


NTSTATUS DeviceNotify(IN PPLUGPLAY_NOTIFY_HDR, IN PDEVICEINFO);


/*
 * The below two routines are transplanted from i8042prt
 * to get the BIOS NumLock status.
 */
typedef struct _LED_INFO {
    USHORT usLedFlags;
    BOOLEAN fFound;
} LED_INFO, *PLED_INFO;


/****************************************************************************
 *
 * Routine Description:
 *
 *    This is the callout routine sent as a parameter to
 *    IoQueryDeviceDescription.  It grabs the keyboard peripheral configuration
 *    information.
 *
 * Arguments:
 *
 *     Context - Context parameter that was passed in by the routine
 *         that called IoQueryDeviceDescription.
 *
 *     PathName - The full pathname for the registry key.
 *
 *     BusType - Bus interface type (Isa, Eisa, Mca, etc.).
 *
 *     BusNumber - The bus sub-key (0, 1, etc.).
 *
 *     BusInformation - Pointer to the array of pointers to the full value
 *         information for the bus.
 *
 *     ControllerType - The controller type (should be KeyboardController).
 *
 *     ControllerNumber - The controller sub-key (0, 1, etc.).
 *
 *     ControllerInformation - Pointer to the array of pointers to the full
 *         value information for the controller key.
 *
 *     PeripheralType - The peripheral type (should be KeyboardPeripheral).
 *
 *     PeripheralNumber - The peripheral sub-key.
 *
 *     PeripheralInformation - Pointer to the array of pointers to the full
 *         value information for the peripheral key.
 *
 *
 * Return Value:
 *
 *     None.  If successful, will have the following side-effects:
 *
 *         - Sets DeviceObject->DeviceExtension->HardwarePresent.
 *         - Sets configuration fields in
 *           DeviceObject->DeviceExtension->Configuration.
 *
 ****************************************************************************/
NTSTATUS
KeyboardDeviceSpecificCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation)
{
    PUCHAR                          pPeripheralData;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDesc;
    PCM_KEYBOARD_DEVICE_DATA        pKbdDeviceData;
    PLED_INFO    pInfo;
    ULONG                           i, listCount;

    TAGMSG0(DBGTAG_KBD, "KeyboardDeviceSpecificCallout: called.");

    UNREFERENCED_PARAMETER(PathName);
    UNREFERENCED_PARAMETER(BusType);
    UNREFERENCED_PARAMETER(BusNumber);
    UNREFERENCED_PARAMETER(BusInformation);
    UNREFERENCED_PARAMETER(ControllerType);
    UNREFERENCED_PARAMETER(ControllerNumber);
    UNREFERENCED_PARAMETER(ControllerInformation);
    UNREFERENCED_PARAMETER(PeripheralType);
    UNREFERENCED_PARAMETER(PeripheralNumber);

    pInfo = (PLED_INFO)Context;

    if (pInfo->fFound) {
        return STATUS_SUCCESS;
    }

    //
    // Look through the peripheral's resource list for device-specific
    // information.
    //
    if (PeripheralInformation[IoQueryDeviceConfigurationData]->DataLength != 0) {
        pPeripheralData =
            ((PUCHAR)(PeripheralInformation[IoQueryDeviceConfigurationData])) +
                PeripheralInformation[IoQueryDeviceConfigurationData]->DataOffset;

        pPeripheralData += FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR, PartialResourceList);

        listCount = ((PCM_PARTIAL_RESOURCE_LIST)pPeripheralData)->Count;

        pResDesc = ((PCM_PARTIAL_RESOURCE_LIST)pPeripheralData)->PartialDescriptors;

        for (i = 0; i < listCount; i++, pResDesc++) {
            if (pResDesc->Type == CmResourceTypeDeviceSpecific) {
                //
                // Get the keyboard type, subtype, and the initial
                // settings for the LEDs.
                //
                pKbdDeviceData = (PCM_KEYBOARD_DEVICE_DATA)
                                       (((PUCHAR) pResDesc) + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                TAGMSG1(DBGTAG_KBD, "KeyboardDeviceSpecificCallout: specific data is %p\n", pKbdDeviceData);

#ifdef LATER
                if (pKbdDeviceData->Type <= NUM_KNOWN_KEYBOARD_TYPES) {
                    pInfo->KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Type =
                    pKbdDeviceData->Type;
                }

                pInfo->KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Subtype =
                pKbdDeviceData->Subtype;
#endif

                pInfo->usLedFlags = (pKbdDeviceData->KeyboardFlags >> 4) &
                                  (KEYBOARD_SCROLL_LOCK_ON | KEYBOARD_NUM_LOCK_ON | KEYBOARD_CAPS_LOCK_ON);

                TAGMSG1(DBGTAG_KBD, "KeyboardDeviceSpecificCallout: LED %04x", pInfo->usLedFlags);

                pInfo->fFound = TRUE;
                break;
            }
        }
    }

    return STATUS_SUCCESS;
}

VOID GetBiosNumLockStatus(
    VOID)
{
    LED_INFO info;
    INTERFACE_TYPE interfaceType;
    CONFIGURATION_TYPE controllerType = KeyboardController;
    CONFIGURATION_TYPE peripheralType = KeyboardPeripheral;
    ULONG i;

    info.usLedFlags = 0;
    info.fFound = FALSE;

    for (i = 0; i < MaximumInterfaceType; i++) {
        //
        // Get the registry information for this device.
        //
        interfaceType = i;
        IoQueryDeviceDescription(&interfaceType,
                                 NULL,
                                 &controllerType,
                                 NULL,
                                 &peripheralType,
                                 NULL,
                                 KeyboardDeviceSpecificCallout,
                                 (PVOID)&info);
        if (info.fFound) {
            gklpBootTime.LedFlags = info.usLedFlags;
            return;
        }
    }

    RIPMSG0(RIP_WARNING, "GetBiosNumLockStatus: could not find the BIOS LED info!!!");
}

/***************************************************************************\
* InitKeyboardState
*
* This function clears the keyboard down state. It will be required
* when the system resumes from hybernation.
* states.
*
* History:
* 12-12-00 Hiroyama
\***************************************************************************/
VOID InitKeyboardState(
    VOID)
{
    TAGMSG0(DBGTAG_KBD, "InitKeyboardState >>>>>");

    /*
     * Clear the cached modifier state for the hotkey.
     * (WindowsBug #252051)
     */
    ClearCachedHotkeyModifiers();

    TAGMSG0(DBGTAG_KBD, "InitKeyboardState <<<<<<");
}

/***************************************************************************\
* InitKeyboard
*
* This function gets information about the keyboard and initialize the internal
* states.
*
* History:
* 11-26-90 DavidPe      Created.
* XX-XX-00 Hiroyama
\***************************************************************************/

VOID InitKeyboard(VOID)
{
    if (!IsRemoteConnection()) {
        /*
         * Get the BIOS Numlock status.
         */
        GetBiosNumLockStatus();

        /*
         * Initialize the keyboard state.
         */
        InitKeyboardState();
    }

    UpdatePerUserKeyboardMappings(NULL);
}

VOID UpdatePerUserKeyboardMappings(PUNICODE_STRING pProfileUserName)
{
    /*
     * Get or clean the Scancode Mapping, if any.
     */
    InitScancodeMap(pProfileUserName);
}


HKL GetActiveHKL()
{
    CheckCritIn();
    if (gpqForeground && gpqForeground->spwndActive) {
        PTHREADINFO ptiForeground = GETPTI(gpqForeground->spwndActive);
        if (ptiForeground && ptiForeground->spklActive) {
            return ptiForeground->spklActive->hkl;
        }
    }
    return _GetKeyboardLayout(0L);
}

VOID FinalizeKoreanImeCompStrOnMouseClick(PWND pwnd)
{
    PTHREADINFO ptiWnd = GETPTI(pwnd);

    /*
     * 274007: MFC flushes mouse related messages if keyup is posted
     * while it's in context help mode.
     */
    if (gpqForeground->spwndCapture == NULL &&
            /*
             * Hack for OnScreen Keyboard: no finalization on button event.
             */
            (GetAppImeCompatFlags(ptiWnd) & IMECOMPAT_NOFINALIZECOMPSTR) == 0) {

        if (LOWORD(ptiWnd->dwExpWinVer) > VER40) {
            PWND pwndIme = ptiWnd->spwndDefaultIme;

            if (pwndIme && !TestWF(pwndIme, WFINDESTROY)) {
                /*
                 * For new applications, we no longer post hacky WM_KEYUP.
                 * Instead, we use private IME_SYSTEM message.
                 */
                _PostMessage(pwndIme, WM_IME_SYSTEM, IMS_FINALIZE_COMPSTR, 0);
            }
        } else {
            /*
             * For the backward compatibility w/NT4, we post WM_KEYUP to finalize
             * the composition string.
             */
            PostInputMessage(gpqForeground, NULL, WM_KEYUP, VK_PROCESSKEY, 0, 0, 0);
        }
    }
}


#ifdef GENERIC_INPUT
#ifdef GI_SINK

__inline VOID FillRawMouseInput(
    PHIDDATA pHidData,
    PMOUSE_INPUT_DATA pmei)
{
    /*
     * Set the data.
     */
    pHidData->rid.data.mouse.usFlags = pmei->Flags;
    pHidData->rid.data.mouse.ulButtons = pmei->Buttons;
    pHidData->rid.data.mouse.ulRawButtons = pmei->RawButtons;
    pHidData->rid.data.mouse.lLastX = pmei->LastX;
    pHidData->rid.data.mouse.lLastY = pmei->LastY;
    pHidData->rid.data.mouse.ulExtraInformation = pmei->ExtraInformation;
}


BOOL PostRawMouseInput(
    PQ pq,
    DWORD dwTime,
    HANDLE hDevice,
    PMOUSE_INPUT_DATA pmei)
{
    PHIDDATA pHidData;
    PWND pwnd;
    PPROCESS_HID_TABLE pHidTable;

    if (pmei->UnitId == INVALID_UNIT_ID) {
        TAGMSG1(DBGTAG_PNP, "PostRawMouseInput: MOUSE_INPUT_DATA %p is already handled.", pmei);
        return TRUE;
    }

    if (pq) {
        pHidTable = PtiMouseFromQ(pq)->ppi->pHidTable;
    } else {
        pHidTable = NULL;
    }

    if (pHidTable && pHidTable->fRawMouse) {
        UserAssert(PtiMouseFromQ(pq)->ppi->pHidTable);
        pwnd = PtiMouseFromQ(pq)->ppi->pHidTable->spwndTargetMouse;
        if (pwnd) {
            pq = GETPTI(pwnd)->pq;
        }

        pHidData = AllocateHidData(hDevice, RIM_TYPEMOUSE, sizeof(RAWMOUSE), RIM_INPUT, pwnd);

        UserAssert(pq);

        if (pHidData == NULL) {
            // failed to allocate
            RIPMSG0(RIP_WARNING, "PostRawMouseInput: filed to allocate HIDDATA.");
            return FALSE;
        }

        UserAssert(pmei);

        FillRawMouseInput(pHidData, pmei);

        PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoH(pHidData), dwTime, pmei->ExtraInformation);
    }

#if DBG
    pHidData = NULL;
#endif

    if (IsMouseSinkPresent()) {
        /*
         * Walk through the global sink list.
         */
        PLIST_ENTRY pList = gHidRequestTable.ProcessRequestList.Flink;

        for (; pList != &gHidRequestTable.ProcessRequestList; pList = pList->Flink) {
            PPROCESS_HID_TABLE pProcessHidTable = CONTAINING_RECORD(pList, PROCESS_HID_TABLE, link);
            PPROCESSINFO ppiForeground;

            if (pq) {
                ppiForeground = PtiMouseFromQ(pq)->ppi;
            } else {
                ppiForeground = NULL;
            }

            UserAssert(pProcessHidTable);
            if (pProcessHidTable->fRawMouseSink) {
                /*
                 * Sink is specified. Let's check out if it's the legid receiver.
                 */

                UserAssert(pProcessHidTable->spwndTargetMouse);   // shouldn't be NULL.

                if (pProcessHidTable->spwndTargetMouse == NULL ||
                        TestWF(pProcessHidTable->spwndTargetMouse, WFINDESTROY) ||
                        TestWF(pProcessHidTable->spwndTargetMouse, WFDESTROYED)) {
                    /*
                     * This guy doesn't have a legit spwndTarget or the window is
                     * halfly destroyed.
                     */
#ifdef LATER
                    pProcessHidTable->fRawMouse = pProcessHidTable->fRawMouseSink =
                        pProcessHidTable->fNoLegacyMouse = FALSE;
#endif
                    continue;
                }

                if (pProcessHidTable->spwndTargetMouse->head.rpdesk != grpdeskRitInput) {
                    /*
                     * This guy belongs to the other desktop, let's skip it.
                     */
                    continue;
                }

                if (GETPTI(pProcessHidTable->spwndTargetMouse)->ppi == ppiForeground) {
                    /*
                     * Should be already handled, let's skip it.
                     */
                    continue;
                }

                /*
                 * Let's post the message to this guy.
                 */
                pHidData = AllocateHidData(hDevice, RIM_TYPEMOUSE, sizeof(RAWMOUSE), RIM_INPUTSINK, pProcessHidTable->spwndTargetMouse);

                if (pHidData == NULL) {
                    RIPMSG1(RIP_WARNING, "PostInputMessage: failed to allocate HIDDATA for sink: %p", pProcessHidTable);
                    return FALSE;
                }

                FillRawMouseInput(pHidData, pmei);
                pwnd = pProcessHidTable->spwndTargetMouse;
                PostInputMessage(GETPTI(pwnd)->pq,
                                 pwnd,
                                 WM_INPUT,
                                 RIM_INPUTSINK,
                                 (LPARAM)PtoH(pHidData),
                                 dwTime,
                                 pmei->ExtraInformation);
            }
        }
    }

    /*
     * Mark this raw input as processed.
     */
    pmei->UnitId = INVALID_UNIT_ID;

    return TRUE;
}

#else   // GI_SINK

// original code

BOOL PostRawMouseInput(
    PQ pq,
    DWORD dwTime,
    HANDLE hDevice,
    PMOUSE_INPUT_DATA pmei)
{
    PHIDDATA pHidData;
    PWND pwnd;

    UserAssert(PtiMouseFromQ(pq)->ppi->pHidTable);
    if (pmei->UnitId == INVALID_UNIT_ID) {
        TAGMSG1(DBGTAG_PNP, "PostRawMouseInput: MOUSE_INPUT_DATA %p is already handled.", pmei);
        return TRUE;
    }
    pwnd = PtiMouseFromQ(pq)->ppi->pHidTable->spwndTargetMouse;
    if (pwnd) {
        pq = GETPTI(pwnd)->pq;
    }

    pHidData = AllocateHidData(hDevice, RIM_TYPEMOUSE, sizeof(RAWMOUSE), RIM_INPUT, pwnd);

    UserAssert(pq);

    if (pHidData == NULL) {
        // failed to allocate
        RIPMSG0(RIP_WARNING, "PostRawMouseInput: filed to allocate HIDDATA.");
        return FALSE;
    }

    UserAssert(hDevice);
    UserAssert(pmei);
    pHidData->rid.data.mouse.usFlags = pmei->Flags;
    pHidData->rid.data.mouse.ulButtons = pmei->Buttons;
    pHidData->rid.data.mouse.ulRawButtons = pmei->RawButtons;
    pHidData->rid.data.mouse.lLastX = pmei->LastX;
    pHidData->rid.data.mouse.lLastY = pmei->LastY;
    pHidData->rid.data.mouse.ulExtraInformation = pmei->ExtraInformation;

    /*
     * Mark this raw input as processed.
     */
    pmei->UnitId = INVALID_UNIT_ID;

    PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoH(pHidData), dwTime, pmei->ExtraInformation);

    return TRUE;
}
#endif  // GI_SINK

BOOL RawInputRequestedForMouse(PTHREADINFO pti)
{
#ifdef GI_SINK
    return gHidCounters.cMouseSinks > 0 || TestRawInputMode(pti, RawMouse);
#else
    return TestRawInputMode(pti, RawKeyboard);
#endif
}

#endif  // GENERIC_INPUT

/***************************************************************************\
* xxxButtonEvent (RIT)
*
* Button events from the mouse driver go here.  Based on the location of
* the cursor the event is directed to specific window.  When a button down
* occurs, a mouse owner window is established.  All mouse events up to and
* including the corresponding button up go to the mouse owner window.  This
* is done to best simulate what applications want when doing mouse capturing.
* Since we're processing these events asynchronously, but the application
* calls SetCapture() in response to it's synchronized processing of input
* we have no other way to get this functionality.
*
* The async keystate table for VK_*BUTTON is updated here.
*
* History:
* 10-18-90 DavidPe     Created.
* 01-25-91 IanJa       xxxWindowHitTest change
* 03-12-92 JonPa       Make caller enter crit instead of this function
\***************************************************************************/

VOID xxxButtonEvent(
    DWORD ButtonNumber,
    POINT ptPointer,
    BOOL  fBreak,
    DWORD time,
    ULONG_PTR ExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    BOOL  bInjected,
    BOOL  fDblClk)
{
    UINT    message, usVK, usOtherVK, wHardwareButton;
    PWND    pwnd;
    LPARAM  lParam;
    WPARAM  wParam;
    int     xbutton;
    TL      tlpwnd;
    PHOOK   pHook;
#ifdef GENERIC_INPUT
    BOOL    fMouseExclusive = FALSE;
#endif

#ifdef REDIRECTION
    PWND    pwndStart;
#endif // REDIRECTION

    CheckCritIn();


    /*
     * Cancel Alt-Tab if the user presses a mouse button
     */
    if (gspwndAltTab != NULL) {
        xxxCancelCoolSwitch();
    }

    /*
     * Grab the mouse button before we process any button swapping.
     * This is so we won't get confused if someone calls
     * SwapMouseButtons() inside a down-click/up-click.
     */
    wHardwareButton = (UINT)ButtonNumber;

    /*
     * If this is the left or right mouse button, we have to handle mouse
     * button swapping.
     */
    if (ButtonNumber & (MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT)) {
        /*
         * If button swapping is on, swap the mouse buttons
         */
        if (SYSMET(SWAPBUTTON)) {
            ButtonNumber ^= (MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT);
        }

        /*
         * Figure out VK
         */
        if (ButtonNumber == MOUSE_BUTTON_RIGHT) {
            usVK = VK_RBUTTON;
            usOtherVK = VK_LBUTTON;
        } else if (ButtonNumber == MOUSE_BUTTON_LEFT) {
            usVK = VK_LBUTTON;
            usOtherVK = VK_RBUTTON;
        } else {
            RIPMSG1(RIP_ERROR, "Unexpected Button number %d", ButtonNumber);
        }

        /*
         * If the mouse buttons have recently been swapped AND the button
         * transition doesn't match what we have in our keystate, then swap the
         * button to match.
         * This is to fix the ruler (tabs and margins) in Word 97 SR1, which
         * calls SwapMouseButtons(0) to determine if button swapping is on, and
         * if so then calls SwapMouseButtons(1) to restore it: if we receive a
         * button event between these two calls, we may swap incorrectly, and
         * be left with a mouse button stuck down or see the wrong button going
         * down. This really messed up single/double button tab/margin setting!
         * The same bug shows up under Windows '95, although very infrequently:
         * Word 9 will use GetSystemMetrics(SM_SWAPBUTTON) instead according to
         * to Mark Walker (MarkWal).                            (IanJa) #165157
         */
        if (gbMouseButtonsRecentlySwapped) {
            if ((!fBreak == !!TestAsyncKeyStateDown(usVK)) &&
                    (fBreak == !!TestAsyncKeyStateDown(usOtherVK))) {
                RIPMSG4(RIP_WARNING, "Correct %s %s to %s %s",
                         ButtonNumber == MOUSE_BUTTON_LEFT ? "Left" : "Right",
                         fBreak ? "Up" : "Down",
                         ButtonNumber == MOUSE_BUTTON_LEFT ? "Right" : "Left",
                         fBreak ? "Up" : "Down");
                ButtonNumber ^= (MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT);
                usVK = usOtherVK;
            }
            gbMouseButtonsRecentlySwapped = FALSE;
        }
    }

    xbutton = 0;
    switch (ButtonNumber) {
    case MOUSE_BUTTON_RIGHT:
        if (fBreak) {
            message = WM_RBUTTONUP;
        } else {
            if (ISTS() && fDblClk)
                message = WM_RBUTTONDBLCLK;
            else
                message = WM_RBUTTONDOWN;
        }
        break;

    case MOUSE_BUTTON_LEFT:
        if (fBreak) {
            message = WM_LBUTTONUP;
        } else {
            if (ISTS() && fDblClk)
                message = WM_LBUTTONDBLCLK;
            else
                message = WM_LBUTTONDOWN;
        }
        break;

    case MOUSE_BUTTON_MIDDLE:
        if (fBreak) {
            message = WM_MBUTTONUP;
        } else {
            if (ISTS() && fDblClk)
                message = WM_MBUTTONDBLCLK;
            else
                message = WM_MBUTTONDOWN;
        }
        usVK = VK_MBUTTON;
        break;

    case MOUSE_BUTTON_X1:
    case MOUSE_BUTTON_X2:
        if (fBreak) {
            message = WM_XBUTTONUP;
        } else {
            if (ISTS() && fDblClk)
                message = WM_XBUTTONDBLCLK;
            else
                message = WM_XBUTTONDOWN;
        }

        if (ButtonNumber == MOUSE_BUTTON_X1) {
            usVK = VK_XBUTTON1;
            xbutton = XBUTTON1;
        } else {
            usVK = VK_XBUTTON2;
            xbutton = XBUTTON2;
        }
        break;

    default:
        /*
         * Unknown button.  Since we don't
         * have messages for these buttons, ignore them.
         */
        return;
    }
    UserAssert(usVK != 0);

    /*
     * Check for click-lock
     */
    if (TestEffectUP(MOUSECLICKLOCK)) {
        if (message == WM_LBUTTONDOWN) {
            if (gfStartClickLock) {
                /*
                 * Already inside click-lock, so just throw this message away
                 * and turn click-lock off.
                 */
                gfStartClickLock        = FALSE;
                return;
            } else {
                /*
                 * Start click-lock and record the time.
                 */
                gfStartClickLock        = TRUE;
                gdwStartClickLockTick   = time;
            }
        } else if (message == WM_LBUTTONUP) {
            if (gfStartClickLock) {
                DWORD dwDeltaTick = time - gdwStartClickLockTick;
                if (dwDeltaTick > UPDWORDValue(SPI_GETMOUSECLICKLOCKTIME)) {
                    /*
                     * Inside a potential click-lock, so throw this message away
                     * if waited beyond the click-lock period.
                     */
                    return;
                } else {
                    /*
                     * The mouse up occurred before the click-lock period completed,
                     * so cancel the click-lock.
                     */

                    gfStartClickLock = FALSE;
                }
            }
        }
    }

    wParam = MAKEWPARAM(0, xbutton);

    /*
     * Call low level mouse hooks to see if they allow this message
     * to pass through USER
     */
    if ((pHook = PhkFirstValid(PtiCurrent(), WH_MOUSE_LL)) != NULL) {
        MSLLHOOKSTRUCT mslls;
        BOOL           bAnsiHook;

        mslls.pt          = ptPointer;
        mslls.mouseData   = (LONG)wParam;
        mslls.flags       = bInjected;
        mslls.time        = time;
        mslls.dwExtraInfo = ExtraInfo;

        if (xxxCallHook2(pHook, HC_ACTION, (DWORD)message, (LPARAM)&mslls, &bAnsiHook)) {
            return;
        }
    }


#ifdef GENERIC_INPUT
    UserAssert(gpqForeground == NULL || PtiMouseFromQ(gpqForeground));
    if (gpqForeground) {
        if (hDevice && RawInputRequestedForMouse(PtiMouseFromQ(gpqForeground))) {
            PostRawMouseInput(gpqForeground, time, hDevice, pmei);
        }
    }
#endif


    /*
     * This is from HYDRA
     */
    UserAssert(grpdeskRitInput != NULL);

#ifdef GENERIC_INPUT
    if (gpqForeground && TestRawInputMode(PtiMouseFromQ(gpqForeground), CaptureMouse)) {
        fMouseExclusive = TRUE;
        pwnd = PtiMouseFromQ(gpqForeground)->ppi->pHidTable->spwndTargetMouse;
        UserAssert(pwnd);
        if (pwnd) {
            goto KeyStatusUpdate;
        }
        // Something bad happened to our HidTable, but
        // not let it AV because of that.
    }
#endif
#ifdef REDIRECTION
    /*
     * Call the speed hit test hook
     */
    pwndStart = xxxCallSpeedHitTestHook(&ptPointer);
    if (pwndStart == NULL) {
        pwndStart = grpdeskRitInput->pDeskInfo->spwnd;
    }

    pwnd = SpeedHitTest(pwndStart, ptPointer);
#else
    pwnd = SpeedHitTest(grpdeskRitInput->pDeskInfo->spwnd, ptPointer);
#endif // REDIRECTION

    /*
     * Only post the message if we actually hit a window.
     */
    if (pwnd == NULL) {
        return;
    }

    /*
     * Assign the message to a window.
     */
    lParam = MAKELONG((SHORT)ptPointer.x, (SHORT)ptPointer.y);

    /*
     * KOREAN:
     *  Send VK_PROCESSKEY to finalize current composition string (NT4 behavior)
     *  Post private message to let IMM finalize the composition string (NT5)
     */
    if (IS_IME_ENABLED() &&
            !fBreak &&
            KOREAN_KBD_LAYOUT(GetActiveHKL()) &&
            !TestCF(pwnd, CFIME) &&
            gpqForeground != NULL) {
        FinalizeKoreanImeCompStrOnMouseClick(pwnd);
    }

    /*
     * If screen capture is active do it
     */
    if (gspwndScreenCapture != NULL)
        pwnd = gspwndScreenCapture;

    /*
     * If this is a button down event and there isn't already
     * a mouse owner, setup the mouse ownership globals.
     */
    if (gspwndMouseOwner == NULL) {
        if (!fBreak) {
            PWND pwndCapture;

            /*
             * BIG HACK: If the foreground window has the capture
             * and the mouse is outside the foreground queue then
             * send a buttondown/up pair to that queue so it'll
             * cancel it's modal loop.
             */
            if (pwndCapture = PwndForegroundCapture()) {

                if (GETPTI(pwnd)->pq != GETPTI(pwndCapture)->pq) {
                    PQ pqCapture;

                    pqCapture = GETPTI(pwndCapture)->pq;
                    PostInputMessage(pqCapture, pwndCapture, message,
                            0, lParam, 0, 0);
                    PostInputMessage(pqCapture, pwndCapture, message + 1,
                            0, lParam, 0, 0);

                    /*
                     * EVEN BIGGER HACK: To maintain compatibility
                     * with how tracking deals with this, we don't
                     * pass this event along.  This prevents mouse
                     * clicks in other windows from causing them to
                     * become foreground while tracking.  The exception
                     * to this is when we have the sysmenu up on
                     * an iconic window.
                     */
                    if ((GETPTI(pwndCapture)->pmsd != NULL) &&
                            !IsMenuStarted(GETPTI(pwndCapture))) {
                        return;
                    }
                }
            }

            Lock(&(gspwndMouseOwner), pwnd);
            gwMouseOwnerButton |= wHardwareButton;
            glinp.ptLastClick = gpsi->ptCursor;
        } else {

            /*
             * The mouse owner must have been destroyed or unlocked
             * by a fullscreen switch.  Keep the button state in sync.
             */
            gwMouseOwnerButton &= ~wHardwareButton;
        }

    } else {

        /*
         * Give any other button events to the mouse-owner window
         * to be consistent with old capture semantics.
         */
        if (gspwndScreenCapture == NULL)  {
            /*
             * NT5 Foreground and Drag Drop.
             * If the mouse goes up on a different thread
             * make the mouse up thread the owner of this click
             */
            if (fBreak && (GETPTI(pwnd) != GETPTI(gspwndMouseOwner))) {
                glinp.ptiLastWoken = GETPTI(pwnd);
                TAGMSG1(DBGTAG_FOREGROUND, "xxxButtonEvent. ptiLastWoken %#p", glinp.ptiLastWoken);
            }
            pwnd = gspwndMouseOwner;
        }

        /*
         * If this is the button-up event for the mouse-owner
         * clear gspwndMouseOwner.
         */
        if (fBreak) {
            gwMouseOwnerButton &= ~wHardwareButton;
            if (!gwMouseOwnerButton)
                Unlock(&gspwndMouseOwner);
        } else {
            gwMouseOwnerButton |= wHardwareButton;
        }
    }

KeyStatusUpdate:
    /*
     * Only update the async keystate when we know which window this
     * event goes to (or else we can't keep the thread specific key
     * state in sync).
     */
    UserAssert(usVK != 0);
    UpdateAsyncKeyState(GETPTI(pwnd)->pq, usVK, fBreak);

#ifdef GENERIC_INPUT
    if (fMouseExclusive) {
        /*
         * If the foreground application requests mouse exclusive
         * raw input, let's not post the activate messages etc.
         * The mouse exclusiveness requires no activation,
         * even within the same app.
         */
        return;
    }
#endif

    /*
     * Put pwnd into the foreground if this is a button down event
     * and it isn't already the foreground window.
     */
    if (!fBreak && GETPTI(pwnd)->pq != gpqForeground) {
        /*
         * If this is an WM_*BUTTONDOWN on a desktop window just do
         * cancel-mode processing.  Check to make sure that there
         * wasn't already a mouse owner window.  See comments below.
         */
        if ((gpqForeground != NULL) && (pwnd == grpdeskRitInput->pDeskInfo->spwnd) &&
                ((gwMouseOwnerButton & wHardwareButton) ||
                (gwMouseOwnerButton == 0))) {
            PostEventMessage(gpqForeground->ptiMouse,
                    gpqForeground, QEVENT_CANCELMODE, NULL, 0, 0, 0);

        } else if ((gwMouseOwnerButton & wHardwareButton) ||
                (gwMouseOwnerButton == 0)) {

            /*
             * Don't bother setting the foreground window if there's
             * already mouse owner window from a button-down different
             * than this event.  This prevents weird things from happening
             * when the user starts a tracking operation with the left
             * button and clicks the right button during the tracking
             * operation.
             */
            /*
             * If pwnd is a descendent of a WS_EX_NOACTIVATE window, then we
             * won't set it to the  foreground
             */
            PWND pwndTopLevel = GetTopLevelWindow(pwnd);
            if (!TestWF(pwndTopLevel, WEFNOACTIVATE)) {
                ThreadLockAlways(pwnd, &tlpwnd);
                xxxSetForegroundWindow2(pwnd, NULL, 0);
                /*
                 * Ok to unlock right away: the above didn't really leave the crit sec.
                 * We lock here for consistency so the debug macros work ok.
                 */
                ThreadUnlock(&tlpwnd);

            }
        }
    }

#ifdef GENERIC_INPUT
    if (TestRawInputMode(PtiMouseFromQ(GETPTI(pwnd)->pq), NoLegacyMouse)) {
        return;
    }
#endif

    if (GETPTI(pwnd)->pq->QF_flags & QF_MOUSEMOVED) {
        PostMove(GETPTI(pwnd)->pq);
    }

    PostInputMessage(GETPTI(pwnd)->pq, pwnd, message, wParam, lParam, time, ExtraInfo);

    /*
     * If this is a mouse up event and stickykeys is enabled all latched
     * keys will be released.
     */
    if (fBreak && (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) ||
                   TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON))) {
        xxxHardwareMouseKeyUp(ButtonNumber);
    }

    if (message == WM_LBUTTONDOWN) {
        PDESKTOP pdesk = GETPTI(pwnd)->rpdesk;
        if (pdesk != NULL && pdesk->rpwinstaParent != NULL) {

            UserAssert(!(pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

#ifdef HUNGAPP_GHOSTING
            if (FHungApp(GETPTI(pwnd), CMSHUNGAPPTIMEOUT)) {
                SignalGhost(pwnd);
            }
#endif // HUNGAPP_GHOSTING
        }
    }
}

/***************************************************************************\
*
* The Button-Click Queue is protected by the semaphore gcsMouseEventQueue
*
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, QueueMouseEvent)
#endif

/***************************************************************************\
* QueueMouseEvent
*
* Params:
*     ButtonFlags - button flags from the driver in MOUSE_INPUT_DATA.ButtonFlags
*
*     ButtonData  - data from the driver in MOUSE_INPUT_DATA.ButtonData
*                   Stores the wheel delta
*
*     ExtraInfo - extra information from the driver in MOUSE_INPUT_DATA.ExtraInfo
*     ptMouse - mouse delta
*     time - tick count at time of event
*     bInjected - injected by SendInput?
*     bWakeRIT - wake the RIT?
*
\***************************************************************************/

VOID QueueMouseEvent(
    USHORT  ButtonFlags,
    USHORT  ButtonData,
    ULONG_PTR ExtraInfo,
    POINT   ptMouse,
    LONG    time,
#ifdef GENERIC_INPUT
    HANDLE  hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    BOOL    bInjected,
    BOOL    bWakeRIT
    )
{
    CheckCritOut();

    EnterMouseCrit();

    LOGTIME(gMouseQueueMouseEventTime);

    /*
     * Button data must always be accompanied by a flag to interpret it.
     */
    UserAssert(ButtonData == 0 || ButtonFlags != 0);

    /*
     * We can coalesce this mouse event with the previous event if there is a
     * previous event, and if the previous event and this event involve no
     * key transitions.
     */
    if ((gdwMouseEvents == 0) ||
            (ButtonFlags != 0) ||
            (gMouseEventQueue[gdwMouseQueueHead].ButtonFlags != 0)) {
        /*
         * Can't coalesce: must add a new mouse event
         */
        if (gdwMouseEvents >= NELEM_BUTTONQUEUE) {
            /*
             * But no more room!
             */
            LeaveMouseCrit();
            UserBeep(440, 125);
            return;
        }

        gdwMouseQueueHead = (gdwMouseQueueHead + 1) % NELEM_BUTTONQUEUE;
        gMouseEventQueue[gdwMouseQueueHead].ButtonFlags = ButtonFlags;
        gMouseEventQueue[gdwMouseQueueHead].ButtonData  = ButtonData;
        gdwMouseEvents++;
    }

    gMouseEventQueue[gdwMouseQueueHead].ExtraInfo = ExtraInfo;
    gMouseEventQueue[gdwMouseQueueHead].ptPointer = ptMouse;
    gMouseEventQueue[gdwMouseQueueHead].time      = time;
    gMouseEventQueue[gdwMouseQueueHead].bInjected = bInjected;
#ifdef GENERIC_INPUT
    gMouseEventQueue[gdwMouseQueueHead].hDevice   = hDevice;
    if (pmei) {
        gMouseEventQueue[gdwMouseQueueHead].rawData = *pmei;
    } else {
        /*
         * To indicate the rawData is invalid, set INVALID_UNIT_ID.
         */
        gMouseEventQueue[gdwMouseQueueHead].rawData.UnitId = INVALID_UNIT_ID;
    }
#endif

    LeaveMouseCrit();

    if (bWakeRIT) {
        /*
         * Signal RIT to complete the mouse input processing
         */
        KeSetEvent(gpkeMouseData, EVENT_INCREMENT, FALSE);
    }
}

/*****************************************************************************\
*
* Gets mouse events out of the queue
*
* Returns:
*   TRUE  - a mouse event is obtained in *pme
*   FALSE - no mouse event available
*
\*****************************************************************************/

BOOL UnqueueMouseEvent(
    PMOUSEEVENT pme
    )
{
    DWORD dwTail;

    EnterMouseCrit();

    LOGTIME(gMouseUnqueueMouseEventTime);

    if (gdwMouseEvents == 0) {
        LeaveMouseCrit();
        return FALSE;
    } else {
        dwTail = (gdwMouseQueueHead - gdwMouseEvents + 1) % NELEM_BUTTONQUEUE;
        *pme = gMouseEventQueue[dwTail];
        gdwMouseEvents--;
    }

    LeaveMouseCrit();
    return TRUE;
}

VOID xxxDoButtonEvent(PMOUSEEVENT pme)
{
    ULONG   dwButtonMask;
    ULONG   dwButtonState;
    LPARAM  lParam;
    BOOL    fWheel;
    PHOOK   pHook;
    ULONG   dwButtonData = (ULONG) pme->ButtonData;

    CheckCritIn();

    dwButtonState = (ULONG) pme->ButtonFlags;
    fWheel = dwButtonState & MOUSE_WHEEL;
    dwButtonState &= ~MOUSE_WHEEL;

    for(    dwButtonMask = 1;
            dwButtonState != 0;
            dwButtonData >>= 2, dwButtonState >>= 2, dwButtonMask <<= 1) {

        if (dwButtonState & 1) {
            xxxButtonEvent(dwButtonMask, pme->ptPointer, FALSE,
                pme->time, pme->ExtraInfo,
#ifdef GENERIC_INPUT
                pme->hDevice,
                &pme->rawData,
#endif
                pme->bInjected,
                gbClientDoubleClickSupport && (dwButtonData & 1));
        }

        if (dwButtonState & 2) {
            xxxButtonEvent(dwButtonMask, pme->ptPointer, TRUE,
                pme->time, pme->ExtraInfo,
#ifdef GENERIC_INPUT
                pme->hDevice,
                &pme->rawData,
#endif
                pme->bInjected ,FALSE);
        }
    }

    /*
     * Handle the wheel msg.
     */
    if (fWheel && pme->ButtonData != 0 && gpqForeground) {

        lParam = MAKELONG((SHORT)pme->ptPointer.x, (SHORT)pme->ptPointer.y);

        /*
         * Call low level mouse hooks to see if they allow this message
         * to pass through USER
         */
        if ((pHook = PhkFirstValid(PtiCurrent(), WH_MOUSE_LL)) != NULL) {
            MSLLHOOKSTRUCT mslls;
            BOOL           bAnsiHook;

            mslls.pt          = pme->ptPointer;
            mslls.mouseData   = MAKELONG(0, pme->ButtonData);
            mslls.flags       = pme->bInjected;
            mslls.time        = pme->time;
            mslls.dwExtraInfo = pme->ExtraInfo;

            if (xxxCallHook2(pHook, HC_ACTION, (DWORD)WM_MOUSEWHEEL,
                    (LPARAM)&mslls, &bAnsiHook)) {
                return;
            }
        }

#ifdef GENERIC_INPUT
        UserAssert(gpqForeground == NULL || PtiMouseFromQ(gpqForeground));
        if (gpqForeground && RawInputRequestedForMouse(PtiMouseFromQ(gpqForeground))) {
            PostRawMouseInput(gpqForeground, pme->time, pme->hDevice, &pme->rawData);
        }

        if (gpqForeground && !TestRawInputMode(PtiMouseFromQ(gpqForeground), NoLegacyMouse)) {
#endif
            PostInputMessage(
                    gpqForeground,
                    NULL,
                    WM_MOUSEWHEEL,
                    MAKELONG(0, pme->ButtonData),
                    lParam, pme->time,
                    pme->ExtraInfo);
#ifdef GENERIC_INPUT
        }
#endif

        return;
    }
}

VOID NTAPI InputApc(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PDEVICEINFO pDeviceInfo = (PDEVICEINFO)ApcContext;
    UNREFERENCED_PARAMETER(Reserved);

    /*
     * Check if the RIT is being terminated.
     * If we hit this assertion, the RIT was killed by someone inadvertently.
     * Not much can be done if it once happens.
     */
    UserAssert(gptiRit);
    UserAssert((gptiRit->TIF_flags & TIF_INCLEANUP) == 0);


#ifdef DIAGNOSE_IO
    pDeviceInfo->nReadsOutstanding--;
#endif

    /*
     * If this device needs freeing, abandon reading now and request the free.
     * (Don't even process the input that we received in this APC)
     */
    if (pDeviceInfo->usActions & GDIAF_FREEME) {
#ifdef GENERIC_INPUT
        CheckCritOut();
        EnterCrit();
#endif
        EnterDeviceInfoListCrit();
        pDeviceInfo->bFlags &= ~GDIF_READING;
        FreeDeviceInfo(pDeviceInfo);
        LeaveDeviceInfoListCrit();
#ifdef GENERIC_INPUT
        LeaveCrit();
#endif
        return;
    }

    if (NT_SUCCESS(IoStatusBlock->Status) && pDeviceInfo->handle) {
        PDEVICE_TEMPLATE pDevTpl = &aDeviceTemplate[pDeviceInfo->type];
        pDevTpl->DeviceRead(pDeviceInfo);
    }

    if (IsRemoteConnection()) {

        PoSetSystemState(ES_SYSTEM_REQUIRED);

    }

    StartDeviceRead(pDeviceInfo);
}

/***************************************************************************\
* ProcessMouseInput
*
* This function is called whenever a mouse event occurs.  Once the event
* has been processed by USER, StartDeviceRead() is called again to request
* the next mouse event.
*
* When this routin returns, InputApc will start another read.
*
* History:
* 11-26-90 DavidPe      Created.
* 07-23-92 Mikehar      Moved most of the processing to _InternalMouseEvent()
* 11-08-92 JonPa        Rewrote button code to work with new mouse drivers
* 11-18-97 IanJa        Renamed from MouseApcProcedure etc, for multiple mice
\***************************************************************************/
VOID ProcessMouseInput(
    PDEVICEINFO pMouseInfo)
{
    PMOUSE_INPUT_DATA pmei, pmeiNext;
    LONG              time;
    POINT             ptLastMove;

    /*
     * This is an APC, so we don't need the DeviceInfoList Critical Section
     * In fact, we don't want it either. We will not remove the device until
     * ProcessMouseInput has signalled that it is OK to do so. (TBD)
     */
    CheckCritOut();
    CheckDeviceInfoListCritOut();

    UserAssert(pMouseInfo);
    UserAssert((PtiCurrentShared() == gTermIO.ptiDesktop) ||
               (PtiCurrentShared() == gTermNOIO.ptiDesktop));

    LOGTIME(gMouseProcessMiceInputTime);

    if (gptiBlockInput != NULL) {
        return;
    }

    if (TEST_ACCF(ACCF_ACCESSENABLED)) {
        /*
         * Any mouse movement resets the count of consecutive shift key
         * presses.  The shift key is used to enable & disable the
         * stickykeys accessibility functionality.
         */
        gStickyKeysLeftShiftCount = 0;
        gStickyKeysRightShiftCount = 0;

        /*
         * Any mouse movement also cancels the FilterKeys activation timer.
         * Entering critsect here breaks non-jerky mouse movement
         */
        if (gtmridFKActivation != 0) {
            EnterCrit();
            KILLRITTIMER(NULL, gtmridFKActivation);
            gtmridFKActivation = 0;
            gFilterKeysState = FKMOUSEMOVE;
            LeaveCrit();
            return;
        }
    }

#ifdef MOUSE_IP
    /*
     * Any mouse movement stops the sonar.
     */
    if (IS_SONAR_ACTIVE()) {
        EnterCrit();
        if (IS_SONAR_ACTIVE()) {
            StopSonar();
            CLEAR_SONAR_LASTVK();
        }
        LeaveCrit();
    }
#endif

    if (!NT_SUCCESS(pMouseInfo->iosb.Status)) {
        /*
         * If we get a bad status, we abandon reading this mouse.
         */

        if (!IsRemoteConnection())
            if (pMouseInfo->iosb.Status != STATUS_DELETE_PENDING) {
                RIPMSG3(RIP_ERROR, "iosb.Status %lx for mouse %#p (id %x) tell IanJa x63321",
                        pMouseInfo->iosb.Status,
                        pMouseInfo, pMouseInfo->mouse.Attr.MouseIdentifier);
            }
        return;
    }

    /*
     * get the last move point from ptCursorAsync
     */
    ptLastMove = gptCursorAsync;

    pmei = pMouseInfo->mouse.Data;
    while (pmei != NULL) {

        time = NtGetTickCount();

        /*
         * Figure out where the next event is.
         */
        pmeiNext = pmei + 1;
        if ((PUCHAR)pmeiNext >=
            (PUCHAR)(((PUCHAR)pMouseInfo->mouse.Data) + pMouseInfo->iosb.Information)) {

            /*
             * If there isn't another event set pmeiNext to
             * NULL so we exit the loop and don't get confused.
             */
            pmeiNext = NULL;
        }

        /*
         * If a PS/2 mouse was plugged in, evaluate the (new) mouse and
         * the skip the input record.
         */
        if (pmei->Flags & MOUSE_ATTRIBUTES_CHANGED) {
            RequestDeviceChange(pMouseInfo, GDIAF_REFRESH_MOUSE, FALSE);
            goto NextMouseInputRecord;
        }

        /*
         * First process any mouse movement that occured.
         * It is important to process movement before button events, otherwise
         * absolute coordinate pointing devices like touch-screens and tablets
         * will produce button clicks at old coordinates.
         */
        if (pmei->LastX || pmei->LastY) {

            /*
             * Get the actual point that will be injected.
             */
            GetMouseCoord(pmei->LastX,
                          pmei->LastY,
                          pmei->Flags,
                          time,
                          pmei->ExtraInformation,
                          &ptLastMove);

            /*
             * If this is a move-only event, and the next one is also a
             * move-only event, skip/coalesce it.
             */
            if (    (pmeiNext != NULL) &&
                    (pmei->ButtonFlags == 0) &&
                    (pmeiNext->ButtonFlags == 0) &&
                    (fAbsoluteMouse(pmei) == fAbsoluteMouse(pmeiNext))) {

                pmei = pmeiNext;

                continue;
            }

#ifdef GENERIC_INPUT
            UserAssert(sizeof(HANDLE) == sizeof(pMouseInfo));
#endif
            /*
             * Moves the cursor on the screen and updates gptCursorAsync
             * Call directly xxxMoveEventAbsolute because we already did the
             * acceleration sensitivity and clipping.
             */
            xxxMoveEventAbsolute(
                    ptLastMove.x,
                    ptLastMove.y,
                    pmei->ExtraInformation,
#ifdef GENERIC_INPUT
                    PtoHq(pMouseInfo),
                    pmei,
#endif
                    time,
                    FALSE
                    );

            /*
             * Now update ptLastMove with ptCursorAsync because ptLastMove
             * doesn't reflect the clipping.
             */
            ptLastMove = gptCursorAsync;
        }

        /*
         * Queue mouse event for the other thread to pick up when it finishes
         * with the USER critical section.
         * If pmeiNext == NULL, there is no more mouse input yet, so wake RIT.
         */
        QueueMouseEvent(
                pmei->ButtonFlags,
                pmei->ButtonData,
                pmei->ExtraInformation,
                gptCursorAsync,
                time,
#ifdef GENERIC_INPUT
                PtoH(pMouseInfo),
                pmei,
#endif
                FALSE,
                (pmeiNext == NULL));

NextMouseInputRecord:
        pmei = pmeiNext;
    }
}


/***************************************************************************\
* IsHexNumpadKeys (RIT) inline
*
* If you change this code, you may need to change
* xxxInternalToUnicode() as well.
\***************************************************************************/
__inline BOOL IsHexNumpadKeys(
    BYTE Vk,
    WORD wScanCode)
{
    return (wScanCode >= SCANCODE_NUMPAD_FIRST && wScanCode <= SCANCODE_NUMPAD_LAST && aVkNumpad[wScanCode - SCANCODE_NUMPAD_FIRST] != 0xff) ||
        (Vk >= L'A' && Vk <= L'F') ||
        (Vk >= L'0' && Vk <= L'9');
}


/***************************************************************************\
* LowLevelHexNumpad (RIT) inline
*
* If you change this code, you may need to change
* xxxInternalToUnicode() as well.
\***************************************************************************/
VOID LowLevelHexNumpad(
    WORD wScanCode,
    BYTE Vk,
    BOOL fBreak,
    USHORT usExtraStuff)
{
    if (!TestAsyncKeyStateDown(VK_MENU)) {
        if (gfInNumpadHexInput & NUMPAD_HEXMODE_LL) {
            gfInNumpadHexInput &= ~NUMPAD_HEXMODE_LL;
        }
    } else {
        if (!fBreak) {  // if it's key down
            if ((gfInNumpadHexInput & NUMPAD_HEXMODE_LL) ||
                    wScanCode == SCANCODE_NUMPAD_PLUS || wScanCode == SCANCODE_NUMPAD_DOT) {
                if ((usExtraStuff & KBDEXT) == 0) {
                    /*
                     * We need to check whether the input is escape character
                     * of hex input mode.
                     * This should be equivalent code as in xxxInternalToUnicode().
                     * If you change this code, you may need to change
                     * xxxInternalToUnicode() as well.
                     */
                    WORD wModBits = 0;

                    wModBits |= TestAsyncKeyStateDown(VK_MENU) ? KBDALT : 0;
                    wModBits |= TestAsyncKeyStateDown(VK_SHIFT) ? KBDSHIFT : 0;
                    wModBits |= TestAsyncKeyStateDown(VK_KANA) ? KBDKANA : 0;

                    if (MODIFIER_FOR_ALT_NUMPAD(wModBits)) {
                        if ((gfInNumpadHexInput & NUMPAD_HEXMODE_LL) == 0) {
                            /*
                             * Only if it's not a hotkey, we enter hex Alt+Numpad mode.
                             */
                            UINT wHotKeyMod = 0;

                            wHotKeyMod |= (wModBits & KBDSHIFT) ? MOD_SHIFT : 0;
                            wHotKeyMod |= TestAsyncKeyStateDown(VK_CONTROL) ? MOD_CONTROL : 0;
                            UserAssert(wModBits & KBDALT);
                            wHotKeyMod |= MOD_ALT;
                            wHotKeyMod |= TestAsyncKeyStateDown(VK_LWIN) || TestAsyncKeyStateDown(VK_RWIN) ?
                                            MOD_WIN : 0;

                            if (IsHotKey(wHotKeyMod, Vk) == NULL) {
                                UserAssert(wScanCode == SCANCODE_NUMPAD_PLUS || wScanCode == SCANCODE_NUMPAD_DOT);
                                gfInNumpadHexInput |= NUMPAD_HEXMODE_LL;
                            }
                        } else if (!IsHexNumpadKeys(Vk, wScanCode)) {
                             gfInNumpadHexInput &= ~NUMPAD_HEXMODE_LL;
                        }
                    } else {
                        gfInNumpadHexInput &= ~NUMPAD_HEXMODE_LL;
                    }
                } else {
                    gfInNumpadHexInput &= ~NUMPAD_HEXMODE_LL;
                }
            } else {
                UserAssert((gfInNumpadHexInput & NUMPAD_HEXMODE_LL) == 0);
            }
        }
    }
}


#ifdef GENERIC_INPUT
#if defined(GI_SINK)

__inline VOID FillRawKeyboardInput(
    PHIDDATA pHidData,
    PKEYBOARD_INPUT_DATA pkei,
    UINT message,
    USHORT vkey)
{
    /*
     * Set the data.
     */
    pHidData->rid.data.keyboard.MakeCode = pkei->MakeCode;
    pHidData->rid.data.keyboard.Flags = pkei->Flags;
    pHidData->rid.data.keyboard.Reserved = pkei->Reserved;
    pHidData->rid.data.keyboard.Message = message;
    pHidData->rid.data.keyboard.VKey = vkey;
    pHidData->rid.data.keyboard.ExtraInformation = pkei->ExtraInformation;
}

BOOL PostRawKeyboardInput(
    PQ pq,
    DWORD dwTime,
    HANDLE hDevice,
    PKEYBOARD_INPUT_DATA pkei,
    UINT message,
    USHORT vkey)
{
    PPROCESS_HID_TABLE pHidTable = PtiKbdFromQ(pq)->ppi->pHidTable;
    PHIDDATA pHidData;
    PWND pwnd;
    WPARAM wParam = RIM_INPUT;

    if (pHidTable && pHidTable->fRawKeyboard) {
        PTHREADINFO pti;

        UserAssert(PtiKbdFromQ(pq)->ppi->pHidTable);
        pti = PtiKbdFromQ(pq);
        pwnd = pti->ppi->pHidTable->spwndTargetKbd;

        if (pwnd == NULL) {
            pwnd = pq->spwndFocus;
        } else {
            pq = GETPTI(pwnd)->pq;
        }

        if (TestRawInputModeNoCheck(pti, RawKeyboard)) {
            wParam = RIM_INPUT;
        }

        pHidData = AllocateHidData(hDevice, RIM_TYPEKEYBOARD, sizeof(RAWKEYBOARD), wParam, pwnd);

        UserAssert(pq);

        if (pHidData == NULL) {
            // failed to allocate
            RIPMSG0(RIP_WARNING, "PostRawKeyboardInput: failed to allocate HIDDATA.");
            return FALSE;
        }

        UserAssert(pkei);

        FillRawKeyboardInput(pHidData, pkei, message, vkey);

        if (!PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoHq(pHidData), dwTime, pkei->ExtraInformation)) {
            FreeHidData(pHidData);
        }
    }

#if DBG
    pHidData = NULL;
#endif

    if (IsKeyboardSinkPresent()) {
        /*
         * Walk through the global sink list.
         */
        PLIST_ENTRY pList = gHidRequestTable.ProcessRequestList.Flink;
        PPROCESSINFO ppiForeground = PtiKbdFromQ(pq)->ppi;

        for (; pList != &gHidRequestTable.ProcessRequestList; pList = pList->Flink) {
            PPROCESS_HID_TABLE pProcessHidTable = CONTAINING_RECORD(pList, PROCESS_HID_TABLE, link);

            UserAssert(pProcessHidTable);
            if (pProcessHidTable->fRawKeyboardSink) {
                /*
                 * Sink is specified. Let's check out if it's the legid receiver.
                 */

                UserAssert(pProcessHidTable->spwndTargetKbd);   // shouldn't be NULL.

                if (pProcessHidTable->spwndTargetKbd == NULL ||
                        TestWF(pProcessHidTable->spwndTargetKbd, WFINDESTROY) ||
                        TestWF(pProcessHidTable->spwndTargetKbd, WFDESTROYED)) {
                    /*
                     * This guy doesn't have a legit spwndTarget or the window is
                     * halfly destroyed.
                     */
#ifdef LATER
                    pProcessHidTable->fRawKeyboard = pProcessHidTable->fRawKeyboardSink =
                        pProcessHidTable->fNoLegacyKeyboard = FALSE;
#endif
                    continue;
                }

                if (pProcessHidTable->spwndTargetKbd->head.rpdesk != grpdeskRitInput) {
                    /*
                     * This guy belongs to the other desktop, let's skip it.
                     */
                    continue;
                }

                if (GETPTI(pProcessHidTable->spwndTargetKbd)->ppi == ppiForeground) {
                    /*
                     * Should be already handled, let's skip it.
                     */
                    continue;
                }

                /*
                 * Let's post the message to this guy.
                 */
                pHidData = AllocateHidData(hDevice, RIM_TYPEKEYBOARD, sizeof(RAWKEYBOARD), RIM_INPUTSINK, pProcessHidTable->spwndTargetKbd);

                if (pHidData == NULL) {
                    RIPMSG1(RIP_WARNING, "PostInputMessage: failed to allocate HIDDATA for sink: %p", pProcessHidTable);
                    return FALSE;
                }

                FillRawKeyboardInput(pHidData, pkei, message, vkey);
                pwnd = pProcessHidTable->spwndTargetKbd;
                pq = GETPTI(pwnd)->pq;
                PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUTSINK, (LPARAM)PtoHq(pHidData), dwTime, pkei->ExtraInformation);
            }
        }
    }

    return TRUE;
}

#else   // GI_SINK

BOOL PostRawKeyboardInput(
    PQ pq,
    DWORD dwTime,
    HANDLE hDevice,
    PKEYBOARD_INPUT_DATA pkei,
    UINT message,
    USHORT vkey)
{
    PHIDDATA pHidData;
    PWND pwnd;

    UserAssert(PtiKbdFromQ(pq)->ppi->pHidTable);
    pwnd = PtiKbdFromQ(pq)->ppi->pHidTable->spwndTargetKbd;

    if (pwnd == NULL) {
        pwnd = pq->spwndFocus;
    } else {
        pq = GETPTI(pwnd)->pq;
    }

    pHidData = AllocateHidData(hDevice, RIM_TYPEKEYBOARD, sizeof(RAWKEYBOARD), RIM_INPUT, pwnd);

    UserAssert(pq);

    if (pHidData == NULL) {
        // failed to allocate
        RIPMSG0(RIP_WARNING, "PostRawKeyboardInput: failed to allocate HIDDATA.");
        return FALSE;
    }

    UserAssert(hDevice);
    UserAssert(pkei);

    /*
     * Set the data.
     */
    pHidData->rid.data.keyboard.MakeCode = pkei->MakeCode;
    pHidData->rid.data.keyboard.Flags = pkei->Flags;
    pHidData->rid.data.keyboard.Reserved = pkei->Reserved;
    pHidData->rid.data.keyboard.Message = message;
    pHidData->rid.data.keyboard.VKey = vkey;
    pHidData->rid.data.keyboard.ExtraInformation = pkei->ExtraInformation;

    PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoHq(pHidData), dwTime, pkei->ExtraInformation);

    return TRUE;
}

#endif  // GI_SINK

BOOL RawInputRequestedForKeyboard(PTHREADINFO pti)
{
#ifdef GI_SINK
    return IsKeyboardSinkPresent() || TestRawInputMode(pti, RawKeyboard);
#else
    return TestRawInputMode(pti, RawKeyboard);
#endif
}

#endif  // GENERIC_INPUT

/***************************************************************************\
* xxxKeyEvent (RIT)
*
* All events from the keyboard driver go here.  We receive a scan code
* from the driver and convert it to a virtual scan code and virtual
* key.
*
* The async keystate table and keylights are also updated here.  Based
* on the 'focus' window we direct the input to a specific window.  If
* the ALT key is down we send the events as WM_SYSKEY* messages.
*
* History:
* 10-18-90 DavidPe      Created.
* 11-13-90 DavidPe      WM_SYSKEY* support.
* 11-30-90 DavidPe      Added keylight updating support.
* 12-05-90 DavidPe      Added hotkey support.
* 03-14-91 DavidPe      Moved most lParam flag support to xxxCookMessage().
* 06-07-91 DavidPe      Changed to use gpqForeground rather than pwndFocus.
\***************************************************************************/

VOID xxxKeyEvent(
    USHORT    usFlaggedVk,
    WORD      wScanCode,
    DWORD     time,
    ULONG_PTR ExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE    hDevice,
    PKEYBOARD_INPUT_DATA pkei,
#endif
    BOOL      bInjected)
{
    USHORT        message, usExtraStuff;
    BOOL          fBreak;
    BYTE          VkHanded;
    BYTE          Vk;
    TL            tlpwndActivate;
    DWORD         fsReserveKeys;
    static BOOL   fMakeAltUpASysKey;
    PHOOK         pHook;
    PTHREADINFO   ptiCurrent = PtiCurrent();
#ifdef GENERIC_INPUT
    PTHREADINFO   ptiKbd;   // N.b. needs revalidation every time
                            // it leaves the critsec.
    BOOL          fSASHandled = FALSE;
#endif

    CheckCritIn();

    fBreak = usFlaggedVk & KBDBREAK;
    gpsi->bLastRITWasKeyboard = TRUE;

    /*
     * Is this a keyup or keydown event?
     */
    message = fBreak ? WM_KEYUP : WM_KEYDOWN;

    VkHanded = (BYTE)usFlaggedVk;    // get rid of state bits - no longer needed
    usExtraStuff = usFlaggedVk & KBDEXT;

    /*
     * Convert Left/Right Ctrl/Shift/Alt key to "unhanded" key.
     * ie: if VK_LCONTROL or VK_RCONTROL, convert to VK_CONTROL etc.
     * Update this "unhanded" key's state if necessary.
     */
    if ((VkHanded >= VK_LSHIFT) && (VkHanded <= VK_RMENU)) {
        BYTE VkOtherHand = VkHanded ^ 1;

        Vk = (BYTE)((VkHanded - VK_LSHIFT) / 2 + VK_SHIFT);
        if (!fBreak || !TestAsyncKeyStateDown(VkOtherHand)) {
            if ((gptiBlockInput == NULL) || (gptiBlockInput != ptiCurrent)) {
                UpdateAsyncKeyState(gpqForeground, Vk, fBreak);
            }
        }
    } else {
        Vk = VkHanded;
    }

    /*
     * Maintain gfsSASModifiersDown to indicate which of Ctrl/Shift/Alt
     * are really truly physically down
     */
    if (!bInjected && ((wScanCode & SCANCODE_SIMULATED) == 0)) {
        if (fBreak) {
            gfsSASModifiersDown &= ~VKTOMODIFIERS(Vk);
        } else {
            gfsSASModifiersDown |= VKTOMODIFIERS(Vk);
        }
    }

#ifdef GENERIC_INPUT
    ptiKbd = ValidatePtiKbd(gpqForeground);
#endif

    /*
     * Call low level keyboard hook to see if it allows this
     * message to pass
     */
    if ((pHook = PhkFirstValid(ptiCurrent, WH_KEYBOARD_LL)) != NULL) {
        KBDLLHOOKSTRUCT kbds;
        BOOL            bAnsiHook;
        USHORT          msg = message;
        USHORT          usExtraLL = usExtraStuff;

#ifdef GENERIC_INPUT
        UserAssert(GETPTI(pHook));
        if (ptiKbd && ptiKbd->ppi == GETPTI(pHook)->ppi) {
            // Skip LL hook call if the foreground application has
            // a LL keyboard hook and the raw input enabled
            // at the same time.
            if (TestRawInputMode(ptiKbd, RawKeyboard)) {
                goto skip_llhook;
            }
        }
#endif

        /*
         * Check if this is a WM_SYS* message
         */
        if (TestRawKeyDown(VK_MENU) &&
            !TestRawKeyDown(VK_CONTROL)) {

            msg += (WM_SYSKEYDOWN - WM_KEYDOWN);
            usExtraLL |= 0x2000;  // ALT key down
        }

        kbds.vkCode      = (DWORD)VkHanded;
        kbds.scanCode    = (DWORD)wScanCode;
        kbds.flags       = HIBYTE(usExtraLL | (bInjected ? (LLKHF_INJECTED << 8) : 0));
        kbds.flags      |= (fBreak ? (KBDBREAK >> 8) : 0);
        kbds.time        = time;
        kbds.dwExtraInfo = ExtraInfo;

        if (xxxCallHook2(pHook, HC_ACTION, (DWORD)msg, (LPARAM)&kbds, &bAnsiHook)) {

            UINT fsModifiers;

            /*
             * We can't let low level hooks or BlockInput() eat SAS
             * or someone could write a trojan winlogon look alike.
             */
            if (IsSAS(VkHanded, &fsModifiers)) {
                RIPMSG0(RIP_WARNING, "xxxKeyEvent: SAS ignore bad response from low level hook");
            } else {
                return;
            }
        }
    }

#ifdef GENERIC_INPUT
skip_llhook:
#endif

    /*
     * If someone is blocking input and it's not us, don't allow this input
     */
    if (gptiBlockInput && (gptiBlockInput != ptiCurrent)) {
        UINT fsModifiers;
        if (IsSAS(VkHanded, &fsModifiers)) {
            RIPMSG0(RIP_WARNING, "xxxKeyEvent: SAS unblocks BlockInput");
            gptiBlockInput = NULL;
        } else {
            return;
        }
    }

    UpdateAsyncKeyState(gpqForeground, VkHanded, fBreak);

    /*
     * Clear gfInNumpadHexInput if Menu key is up.
     */
    if (gfEnableHexNumpad && gpqForeground
#ifdef GENERIC_INPUT
        && !TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard)
#endif
        ) {
        LowLevelHexNumpad(wScanCode, Vk, fBreak, usExtraStuff);
    }

    /*
     * If this is a make and the key is one linked to the keyboard LEDs,
     * update their state.
     */

    if (!fBreak &&
            ((Vk == VK_CAPITAL) || (Vk == VK_NUMLOCK) || (Vk == VK_SCROLL) ||
             (Vk == VK_KANA && JAPANESE_KBD_LAYOUT(GetActiveHKL())))) {
        /*
         * Only Japanese keyboard layout could generate VK_KANA.
         *
         * [Comments for before]
         *  Since NT 3.x, UpdatesKeyLisghts() had been called for VK_KANA
         * at both of 'make' and 'break' to support NEC PC-9800 Series
         * keyboard hardware, but for NT 4.0, thier keyboard driver emurate
         * PC/AT keyboard hardware, then this is changed to
         * "Call UpdateKeyLights() only at 'make' for VK_KANA"
         */
        UpdateKeyLights(bInjected);
    }

    /*
     * check for reserved keys
     */
    fsReserveKeys = 0;
    if (gptiForeground != NULL)
        fsReserveKeys = gptiForeground->fsReserveKeys;

    /*
     *  Check the RIT's queue to see if it's doing the cool switch thing.
     *  Cancel if the user presses any other key.
     */
    if (gspwndAltTab != NULL && (!fBreak) &&
            Vk != VK_TAB && Vk != VK_SHIFT && Vk != VK_MENU) {

        /*
         * Remove the Alt-tab window
         */
        xxxCancelCoolSwitch();

        /*
         * eat VK_ESCAPE if the app doesn't want it
         */
        if ((Vk == VK_ESCAPE) && !(fsReserveKeys & CONSOLE_ALTESC)) {
            return;
        }
    }

    /*
     * Check for hotkeys.
     */
    if (xxxDoHotKeyStuff(Vk, fBreak, fsReserveKeys)) {

#ifdef GENERIC_INPUT
        UINT fsModifiers;

        /*
         * Windows Bug 268903: DI folks want the DEL key reported
         * even though it's already handled --- for the compatibility
         * with the LL hook.
         */
        if (IsSAS(VkHanded, &fsModifiers)) {
            fSASHandled = TRUE;
        } else {
#endif
            /*
             * The hotkey was processed so don't pass on the event.
             */
            return;
#ifdef GENERIC_INPUT
        }
#endif
    }

#ifdef GENERIC_INPUT
    /*
     * If the foreground thread wants RawInput, post it here.
     */

    ptiKbd = ValidatePtiKbd(gpqForeground);

    if (pkei && ptiKbd && RawInputRequestedForKeyboard(ptiKbd)) {
        DWORD msg = message;
#if POST_EXTRALL
        DWORD usExtraLL = usExtraStuff;
#endif

        /*
         * Check if this is a WM_SYS* message
         */
        if (TestRawKeyDown(VK_MENU) &&
            !TestRawKeyDown(VK_CONTROL)) {

            msg += (WM_SYSKEYDOWN - WM_KEYDOWN);
#if POST_EXTRA_LL
            usExtraLL |= 0x2000;  // ALT key down
#endif
        }

        TAGMSG3(DBGTAG_PNP, "xxxKeyEvent: posting to pwnd=%#p, vk=%02x, flag=%04x", gpqForeground->spwndFocus, Vk, pkei->Flags);
        PostRawKeyboardInput(gpqForeground, time, hDevice, pkei, msg, (USHORT)Vk);
    }

    /*
     * If SAS key is handled, this is a special case, just bail out.
     */
    if (fSASHandled) {
        return;
    }

    /*
     * If the foreground thread does not want the legacy input, bail out.
     */
    if (ptiKbd) {
        if (VkHanded == 0) {
            TAGMSG0(DBGTAG_PNP, "xxxKeyEvent: vkHanded is zero, bail out.");
            return;
        }

        if (TestRawInputMode(ptiKbd, NoLegacyKeyboard)) {
            if (Vk == VK_MENU || Vk == VK_TAB || gspwndAltTab != NULL) {
                /*
                 * Special case for fast switching. We should always
                 * handle these hotkeys.
                 */
                TAGMSG0(DBGTAG_PNP, "xxxKeyEvent: we'll do Alt+Tab even if the FG thread requests NoLegacy");
            } else if ((TestRawInputMode(ptiKbd, AppKeys)) && 
                       (Vk >= VK_APPCOMMAND_FIRST && Vk <= VK_APPCOMMAND_LAST)) {
                TAGMSG0(DBGTAG_PNP, "xxxKeyEvent: we'll do app commands if the FG thread requests NoLegacy and AppKeys");
            } else {
                TAGMSG0(DBGTAG_PNP, "xxxKeyEvent: FG thread doen't want legacy kbd. bail out");
                return;
            }
        }
    }

#endif  // GENERIC_INPUT

    /*
     * If the ALT key is down and the CTRL key
     * isn't, this is a WM_SYS* message.
     */
    if (TestAsyncKeyStateDown(VK_MENU) && !TestAsyncKeyStateDown(VK_CONTROL) && Vk != VK_JUNJA) {
        // VK_JUNJA is ALT+'+'. Since all KOR VKs are not converted to IME hotkey IDs and
        // should be passed directly to IME, KOR related VKs are not treated as SYSKEYDOWN.
        message += (WM_SYSKEYDOWN - WM_KEYDOWN);
        usExtraStuff |= 0x2000;

        /*
         * If this is the ALT-down set this flag, otherwise
         * clear it since we got a key inbetween the ALT-down
         * and ALT-up.  (see comment below)
         */
        if (Vk == VK_MENU) {
            fMakeAltUpASysKey = TRUE;
            /*
             * Unlock SetForegroundWindow (if locked) when the ALT key went down.
             */
            if (!fBreak) {
                gppiLockSFW = NULL;
            }
        } else {
            fMakeAltUpASysKey = FALSE;
        }

    } else if (Vk == VK_MENU) {
        if (fBreak) {
            /*
             * End our switch if we are in the middle of one.
             */
            if (fMakeAltUpASysKey) {

               /*
                * We don't make the keyup of the ALT key a WM_SYSKEYUP if any
                * other key is typed while the ALT key was down.  I don't know
                * why we do this, but it's been here since version 1 and any
                * app that uses SDM relies on it (eg - opus).
                *
                * The Alt bit is not set for the KEYUP message either.
                */
               message += (WM_SYSKEYDOWN - WM_KEYDOWN);
           }

           if (gspwndAltTab != NULL) {

               /*
                * Send the alt up message before we change queues
                */
               if (gpqForeground != NULL) {
#ifdef GENERIC_INPUT
                    if (!TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard)) {
#endif
                        /*
                         * Set this flag so that we know we're doing a tab-switch.
                         * This makes sure that both cases where the ALT-KEY is released
                         * before or after the TAB-KEY is handled.  It is checked in
                         * xxxDefWindowProc().
                         */
                        gpqForeground->QF_flags |= QF_TABSWITCHING;

                        PostInputMessage(gpqForeground, NULL, message, (DWORD)Vk,
                               MAKELONG(1, (wScanCode | usExtraStuff)),
                               time, ExtraInfo);
#ifdef GENERIC_INPUT
                    }
#endif
               }

               /*
                * Remove the Alt-tab window
                */
               xxxCancelCoolSwitch();

               if (gspwndActivate != NULL) {
                   /*
                    * Make our selected window active and destroy our
                    * switch window.  If the new window is minmized,
                    * restore it.  If we are switching in the same
                    * queue, we clear out gpqForeground to make
                    * xxxSetForegroundWindow2 to change the pwnd
                    * and make the switch.  This case will happen
                    * with WOW and Console apps.
                    */
                   if (gpqForeground == GETPTI(gspwndActivate)->pq) {
                       gpqForeground = NULL;
                   }

                   /*
                    * Make the selected window thread the owner of the last input;
                    *  since the user has selected him, he owns the ALT-TAB.
                    */
                   glinp.ptiLastWoken = GETPTI(gspwndActivate);


                   ThreadLockAlways(gspwndActivate, &tlpwndActivate);
                   xxxSetForegroundWindow2(gspwndActivate, NULL,
                           SFW_SWITCH | SFW_ACTIVATERESTORE);
                   /*
                    * Win3.1 calls SetWindowPos() with activate, which z-orders
                    * first regardless, then activates. Our code relies on
                    * xxxActivateThisWindow() to z-order, and it'll only do
                    * it if the window does not have the child bit set (regardless
                    * that the window is a child of the desktop).
                    *
                    * To be compatible, we'll just force z-order here if the
                    * window has the child bit set. This z-order is asynchronous,
                    * so this'll z-order after the activate event is processed.
                    * That'll allow it to come on top because it'll be foreground
                    * then. (Grammatik has a top level window with the child
                    * bit set that wants to be come the active window).
                    */
                   if (TestWF(gspwndActivate, WFCHILD)) {
                       xxxSetWindowPos(gspwndActivate, (PWND)HWND_TOP, 0, 0, 0, 0,
                               SWP_NOSIZE | SWP_NOMOVE | SWP_ASYNCWINDOWPOS);
                   }
                   ThreadUnlock(&tlpwndActivate);

                   Unlock(&gspwndActivate);
               }
               return;
           }
        } else {
            /*
             * The ALT key is down, unlock SetForegroundWindow (if locked)
             */
            gppiLockSFW = NULL;
        }
    }

    /*
     * Handle switching.  Eat the Key if we are doing switching.
     */
    if (!FJOURNALPLAYBACK() && !FJOURNALRECORD() && (!fBreak) &&
            (TestAsyncKeyStateDown(VK_MENU)) &&
            (!TestAsyncKeyStateDown(VK_CONTROL)) && //gpqForeground &&
            (((Vk == VK_TAB) && !(fsReserveKeys & CONSOLE_ALTTAB)) ||
            ((Vk == VK_ESCAPE) && !(fsReserveKeys & CONSOLE_ALTESC)))) {

            xxxNextWindow(gpqForeground ? gpqForeground : gptiRit->pq, Vk);

    } else if (gpqForeground != NULL) {
        PQMSG pqmsgPrev = gpqForeground->mlInput.pqmsgWriteLast;
        DWORD wParam = (DWORD)Vk;
        LONG lParam;

#ifdef GENERIC_INPUT
        if (TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard)) {
            if (!TestRawInputMode(PtiKbdFromQ(gpqForeground), AppKeys) ||
                !(Vk >= VK_APPCOMMAND_FIRST && Vk <= VK_APPCOMMAND_LAST)) {
            return;
            }
        }
#endif

        /*
         * We have a packet containing a Unicode character
         * This is injected by Pen via SendInput
         */
        if ((Vk == VK_PACKET) && (usFlaggedVk & KBDUNICODE)) {
            wParam |= (wScanCode << 16);
            wScanCode = 0;
        }
        lParam = MAKELONG(1, (wScanCode | usExtraStuff));

        /*
         * WM_*KEYDOWN messages are left unchanged on the queue except the
         * repeat count field (LOWORD(lParam)) is incremented.
         */
        if (pqmsgPrev != NULL &&
                pqmsgPrev->msg.message == message &&
                (message == WM_KEYDOWN || message == WM_SYSKEYDOWN) &&
                pqmsgPrev->msg.wParam == wParam &&
                HIWORD(pqmsgPrev->msg.lParam) == HIWORD(lParam)) {
#ifdef GENERIC_INPUT
            /*
             * We shouldn't be here for a generic input keyboard that
             * doesn't want legacy support.
             */
            UserAssert(!TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard));
#endif
            /*
             * Increment the queued message's repeat count.  This could
             * conceivably overflow but Win 3.0 doesn't deal with it
             * and anyone who buffers up 65536 keystrokes is a chimp
             * and deserves to have it wrap anyway.
             */
            pqmsgPrev->msg.lParam = MAKELONG(LOWORD(pqmsgPrev->msg.lParam) + 1,
                    HIWORD(lParam));

            WakeSomeone(gpqForeground, message, pqmsgPrev);

        } else {
            /*
             * check if these are speedracer keys - bug 339877
             * for the speedracer keys we want to post an event message and generate the
             * wm_appcommand in xxxprocesseventmessage
             * Since SpeedRacer software looks for the hotkeys we want to let those through
             * It is going in here since we don't want the ability to eat up tons of pool memory
             * so we post the event message here and then post the input message for the wm_keydown
             * below - that way if the key is repeated then there is coalescing done above and no more
             * qevent_appcommands are posted to the input queue.
             */
            if (VK_APPCOMMAND_FIRST <= Vk && Vk <= VK_APPCOMMAND_LAST) {
                /*
                 * Only send wm_appcommands for wm_keydown (& wm_syskeydown) messages -
                 * essentially we ignore wm_keyup for those vk's defined for wm_appcommand messages
                 */
                if (!fBreak && gpqForeground) {
                    /*
                     * post an event message so we can syncronize with normal types of input
                     * send through the vk - we will construct the message in xxxProcessEventMessage
                     */
                    PostEventMessage(gpqForeground->ptiKeyboard, gpqForeground, QEVENT_APPCOMMAND,
                                     NULL, 0, (WPARAM)0, Vk);
                }
#ifdef GENERIC_INPUT
                if (TestRawInputMode(PtiKbdFromQ(gpqForeground), NoLegacyKeyboard)) {
                    return;
                }
#endif
            }
            /*
             * We let the key go through since we want wm_keydowns/ups to get generated for these
             * SpeedRacer keys
             */

            if (gpqForeground->QF_flags & QF_MOUSEMOVED) {
                PostMove(gpqForeground);
            }

            PostInputMessage(gpqForeground, NULL, message, wParam,
                    lParam, time, ExtraInfo);
        }
    }
}

/**************************************************************************\
* GetMouseCoord
*
* Calculates the coordinates of the point that will be injected.
*
* History:
* 11-01-96 CLupu     Created.
* 12-18-97 MCostea   MOUSE_VIRTUAL_DESKTOP support
\**************************************************************************/
VOID GetMouseCoord(
    LONG   dx,
    LONG   dy,
    DWORD  dwFlags,
    LONG   time,
    ULONG_PTR  ExtraInfo,
    PPOINT ppt)
{
    if (dwFlags & MOUSE_MOVE_ABSOLUTE) {

        LONG cxMetric, cyMetric;

        /*
         * If MOUSE_VIRTUAL_DESKTOP was specified, map to entire virtual screen
         */
        if (dwFlags & MOUSE_VIRTUAL_DESKTOP) {
            cxMetric = SYSMET(CXVIRTUALSCREEN);
            cyMetric = SYSMET(CYVIRTUALSCREEN);
        } else {
            cxMetric = SYSMET(CXSCREEN);
            cyMetric = SYSMET(CYSCREEN);
        }

        /*
         * Absolute pointing device used: deltas are actually the current
         * position.  Update the global mouse position.
         *
         * Note that the position is always reported in units of
         * (0,0)-(0xFFFF,0xFFFF) which corresponds to
         * (0,0)-(SYSMET(CXSCREEN), SYSMET(CYSCREEN)) in pixels.
         * We must first scale it to fit on the screen using the formula:
         *     ptScreen = ptMouse * resPrimaryMonitor / 64K
         *
         * The straightforward algorithm coding of this algorithm is:
         *
         *     ppt->x = (dx * SYSMET(CXSCREEN)) / (long)0x0000FFFF;
         *     ppt->y = (dy * SYSMET(CYSCREEN)) / (long)0x0000FFFF;
         *
         * On x86, with 14 more bytes we can avoid the division function with
         * the following code.
         */

        ppt->x = dx * cxMetric;
        if (ppt->x >= 0) {
            ppt->x = HIWORD(ppt->x);
        } else {
            ppt->x = - (long) HIWORD(-ppt->x);
        }

        ppt->y = dy * cyMetric;
        if (ppt->y >= 0) {
            ppt->y = HIWORD(ppt->y);
        } else {
            ppt->y = - (long) HIWORD(-ppt->y);
        }

        /*
         * (0, 0) must map to the leftmost point on the desktop
         */
        if (dwFlags & MOUSE_VIRTUAL_DESKTOP) {
            ppt->x +=  SYSMET(XVIRTUALSCREEN);
            ppt->y +=  SYSMET(YVIRTUALSCREEN);
        }

        /*
         * Reset the mouse sensitivity remainder.
         */
        idxRemainder = idyRemainder = 0;

        /*
         * Save the absolute coordinates in the global array
         * for GetMouseMovePointsEx.
         */
        SAVEPOINT(dx, dy, 0xFFFF, 0xFFFF, time, ExtraInfo);
    } else {
        /*
         * Is there any mouse acceleration to do?
         */
        if (gMouseSpeed != 0) {
#ifdef SUBPIXEL_MOUSE
            DoNewMouseAccel(&dx, &dy);
#else
            dx = DoMouseAccel(dx);
            dy = DoMouseAccel(dy);
#endif
        } else if (gMouseSensitivity != MOUSE_SENSITIVITY_DEFAULT) {
            int iNumerator;

            /*
             * Does the mouse sensitivity need to be adjusted?
             */

            if (dx != 0) {
                iNumerator   = dx * gMouseSensitivityFactor + idxRemainder;
                dx           = iNumerator / 256;
                idxRemainder = iNumerator % 256;
                if ((iNumerator < 0) && (idxRemainder > 0)) {
                    dx++;
                    idxRemainder -= 256;
                }
            }

            if (dy != 0) {
                iNumerator   = dy * gMouseSensitivityFactor + idyRemainder;
                dy           = iNumerator / 256;
                idyRemainder = iNumerator % 256;
                if ((iNumerator < 0) && (idyRemainder > 0)) {
                    dy++;
                    idyRemainder -= 256;
                }
            }
        }

        ppt->x += dx;
        ppt->y += dy;

        /*
         * Save the absolute coordinates in the global array
         * for GetMouseMovePointsEx.
         */
        SAVEPOINT(ppt->x, ppt->y,
                  SYSMET(CXVIRTUALSCREEN) - 1, SYSMET(CYVIRTUALSCREEN) - 1,
                  time, ExtraInfo);
    }
}

/***************************************************************************\
* xxxMoveEventAbsolute (RIT)
*
* Mouse move events from the mouse driver are processed here.  If there is a
* mouse owner window setup from xxxButtonEvent() the event is automatically
* sent there, otherwise it's sent to the window the mouse is over.
*
* Mouse acceleration happens here as well as cursor clipping (as a result of
* the ClipCursor() API).
*
* History:
* 10-18-90 DavidPe     Created.
* 11-29-90 DavidPe     Added mouse acceleration support.
* 01-25-91 IanJa       xxxWindowHitTest change
*          IanJa       non-jerky mouse moves
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, xxxMoveEventAbsolute)
#endif

VOID xxxMoveEventAbsolute(
    LONG         x,
    LONG         y,
    ULONG_PTR    dwExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE       hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    DWORD        time,
    BOOL         bInjected
    )
{
    CheckCritOut();

    if (IsHooked(gptiRit, WHF_FROM_WH(WH_MOUSE_LL))) {
        MSLLHOOKSTRUCT mslls;
        BOOL           bEatEvent = FALSE;
        BOOL           bAnsiHook;
        PHOOK pHook;

        mslls.pt.x        = x;
        mslls.pt.y        = y;
        mslls.mouseData   = 0;
        mslls.flags       = bInjected;
        mslls.time        = time;
        mslls.dwExtraInfo = dwExtraInfo;

        /*
         * Call low level mouse hooks to see if they allow this message
         * to pass through USER
         */

        EnterCrit();

        /*
         * Check again to see if we still have the hook installed. Fix for 80477.
         */
        if ((pHook = PhkFirstValid(gptiRit, WH_MOUSE_LL)) != NULL) {
            PTHREADINFO ptiCurrent;

            bEatEvent = (xxxCallHook2(pHook, HC_ACTION, WM_MOUSEMOVE, (LPARAM)&mslls, &bAnsiHook) != 0);
            ptiCurrent = PtiCurrent();
            if (ptiCurrent->pcti->fsChangeBits & ptiCurrent->pcti->fsWakeMask & ~QS_SMSREPLY) {
                RIPMSG1(RIP_WARNING, "xxxMoveEventAbsolute: applying changed wake bits (0x%x) during the LL hook callback",
                        ptiCurrent->pcti->fsChangeBits & ~QS_SMSREPLY);
                SetWakeBit(ptiCurrent, ptiCurrent->pcti->fsChangeBits & ~QS_SMSREPLY);
            }

        }

        LeaveCrit();

        if (bEatEvent) {
            return;
        }
    }

#ifdef GENERIC_INPUT
    if (pmei && gpqForeground && RawInputRequestedForMouse(PtiMouseFromQ(gpqForeground))) {
        EnterCrit();

        PostRawMouseInput(gpqForeground, time, hDevice, pmei);
        LeaveCrit();
    }
#endif

    /*
     * Blow off the event if WH_JOURNALPLAYBACK is installed.  Do not
     * use FJOURNALPLAYBACK() because this routine may be called from
     * multiple desktop threads and the hook check must be done
     * for the rit thread, not the calling thread.
     */
    if (IsGlobalHooked(gptiRit, WHF_FROM_WH(WH_JOURNALPLAYBACK))) {
        return;
    }

    gptCursorAsync.x = x;
    gptCursorAsync.y = y;

    BoundCursor(&gptCursorAsync);

    /*
     * Move the screen pointer.
     * Pass an event source parameter as the flags so that TS
     * can correctly send a mouse update to the client if the mouse
     * move is originating from a shadow client.
     */
    GreMovePointer(gpDispInfo->hDev, gptCursorAsync.x, gptCursorAsync.y,
#ifdef GENERIC_INPUT
                   (pmei && (pmei->Flags & MOUSE_TERMSRV_SRC_SHADOW)) ?
                   MP_TERMSRV_SHADOW : MP_NORMAL);
#else
                   MP_NORMAL);
#endif


    /*
     * Save the time stamp in a global so we can use it in PostMove
     */
    gdwMouseMoveTimeStamp = time;

    /*
     * Set the number of trails to hide to gMouseTrails + 1 to avoid calling
     * GreMovePointer while the mouse is moving, look at HideMouseTrails().
     */
    if (GETMOUSETRAILS()) {
        InterlockedExchange(&gMouseTrailsToHide, gMouseTrails + 1);
    }
}


/***************************************************************************\
* xxxMoveEvent (RIT)
*
* The dwFlags can be
*   0 relative move
*   MOUSEEVENTF_ABSOLUTE absolute move
*   MOUSEEVENTF_VIRTUALDESK the absolute coordinates will be maped
*   to the entire virtual desktop.  This flag makes sense only with MOUSEEVENTF_ABSOLUTE
*
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, xxxMoveEvent)
#endif

VOID xxxMoveEvent(
    LONG         dx,
    LONG         dy,
    DWORD        dwFlags,
    ULONG_PTR    dwExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE       hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    DWORD        time,
    BOOL         bInjected)
{
    POINT ptLastMove = gptCursorAsync;

    CheckCritOut();

    /*
     * Get the actual point that will be injected.
     */
    GetMouseCoord(dx, dy, ConvertToMouseDriverFlags(dwFlags),
                  time, dwExtraInfo, &ptLastMove);

    /*
     * move the mouse
     */
    xxxMoveEventAbsolute(
            ptLastMove.x,
            ptLastMove.y,
            dwExtraInfo,
#ifdef GENERIC_INPUT
            hDevice,
            pmei,
#endif
            time,
            bInjected);
}


/***************************************************************************\
* UpdateRawKeyState
*
* A helper routine for ProcessKeyboardInput.
* Based on a VK and a make/break flag, this function will update the physical
* keystate table.
*
* History:
* 10-13-91 IanJa        Created.
\***************************************************************************/
VOID UpdateRawKeyState(
    BYTE Vk,
    BOOL fBreak)
{
    CheckCritIn();

    if (fBreak) {
        ClearRawKeyDown(Vk);
    } else {

        /*
         * This is a key make.  If the key was not already down, update the
         * physical toggle bit.
         */
        if (!TestRawKeyDown(Vk)) {
            ToggleRawKeyToggle(Vk);
        }

        /*
         * This is a make, so turn on the physical key down bit.
         */
        SetRawKeyDown(Vk);
    }
}


VOID CleanupResources(
    VOID)
{
    PPCLS       ppcls;
    PTHREADINFO pti;

    UserAssert(!gbCleanedUpResources);

    gbCleanedUpResources = TRUE;

    HYDRA_HINT(HH_CLEANUPRESOURCES);

    /*
     * Prevent power callouts.
     */
    CleanupPowerRequestList();

    /*
     * Destroy the system classes also
     */
    ppcls = &gpclsList;
    while (*ppcls != NULL) {
        DestroyClass(ppcls);
    }

    /*
     * Unlock the cursor from all the CSRSS's threads.
     * We do this here because RIT might not be the only
     * CSRSS process running at this time and we want
     * to prevent the change of thread ownership
     * after RIT is gone.
     */
    pti = PpiCurrent()->ptiList;

    while (pti != NULL) {

        if (pti->pq != NULL) {
            LockQCursor(pti->pq, NULL);
        }
        pti = pti->ptiSibling;
    }

    UnloadCursorsAndIcons();

    /*
     * Cleanup the GDI globals in USERK
     */
    CleanupGDI();
}

#if 0    // Temporariry

typedef struct _EX_RUNDOWN_WAIT_BLOCK {
    ULONG Count;
    KEVENT WakeEvent;
} EX_RUNDOWN_WAIT_BLOCK, *PEX_RUNDOWN_WAIT_BLOCK;


//NTKERNELAPI
VOID
FASTCALL
__ExWaitForRundownProtectionRelease (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Wait till all outstanding rundown protection calls have exited

Arguments:

    RunRef - Pointer to a rundown structure

Return Value:

    None

--*/
{
    EX_RUNDOWN_WAIT_BLOCK WaitBlock;
    PKEVENT Event;
    ULONG_PTR Value, NewValue;
    ULONG WaitCount;
#if 1
    LARGE_INTEGER liTimeout;
    NTSTATUS Status;
    ULONG counter;
#endif

    PAGED_CODE ();

    //
    // Fast path. this should be the normal case. If Value is zero then there are no current accessors and we have
    // marked the rundown structure as rundown. If the value is EX_RUNDOWN_ACTIVE then the structure has already
    // been rundown and ExRundownCompleted. This second case allows for callers that might initiate rundown
    // multiple times (like handle table rundown) to have subsequent rundowns become noops.
    //

    Value = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                           (PVOID) EX_RUNDOWN_ACTIVE,
                                                           (PVOID) 0);
    if (Value == 0 || Value == EX_RUNDOWN_ACTIVE) {
#if 1
        RIPMSG1(RIP_WARNING, "__ExWaitForRundownProtectionRelease: rundown finished in session %d", gSessionId);
#endif
        return;
    }

    //
    // Slow path
    //
    Event = NULL;
#if 1
    counter = 0;
#endif
    do {

        //
        // Extract total number of waiters. Its biased by 2 so we can hanve the rundown active bit.
        //
        WaitCount = (ULONG) (Value >> EX_RUNDOWN_COUNT_SHIFT);

        //
        // If there are some accessors present then initialize and event (once only).
        //
        if (WaitCount > 0 && Event == NULL) {
            Event = &WaitBlock.WakeEvent;
            KeInitializeEvent (Event, SynchronizationEvent, FALSE);
        }
        //
        // Store the wait count in the wait block. Waiting threads will start to decrement this as they exit
        // if our exchange succeeds. Its possible for accessors to come and go between our initial fetch and
        // the interlocked swap. This doesn't matter so long as there is the same number of outstanding accessors
        // to wait for.
        //
        WaitBlock.Count = WaitCount;

        NewValue = ((ULONG_PTR) &WaitBlock) | EX_RUNDOWN_ACTIVE;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            if (WaitCount > 0) {
#if 1
                /*
                 * NT Base calls take time values in 100 nanosecond units.
                 * Make it relative (negative)...
                 * Timeout in 20 minutes.
                 */
                liTimeout.QuadPart = Int32x32To64(-10000, 300000 * 4);
                Status = KeWaitForSingleObject (Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       &liTimeout);

                if (Status == STATUS_TIMEOUT) {
                    FRE_RIPMSG1(RIP_ERROR, "__ExWaitForRundownProtectionRelease: Rundown wait time out in session %d", gSessionId);
                }
#endif

                ASSERT (WaitBlock.Count == 0);

            }
            return;
        }
        Value = NewValue;

        ASSERT ((Value&EX_RUNDOWN_ACTIVE) == 0);

#if 1
#define THRESHOLD   (50000)
        if (++counter > THRESHOLD) {
            FRE_RIPMSG2(RIP_ERROR, "__ExWaitForRundownProtectionRelease: Rundown wait loop over %d in session %d", THRESHOLD, gSessionId);
            counter = 0;
        }
#endif
    } while (TRUE);
}
#endif

VOID WaitForWinstaRundown(
    PKEVENT pRundownEvent)
{
    if (pRundownEvent) {
        KeSetEvent(pRundownEvent, EVENT_INCREMENT, FALSE);
    }

    /*
     * Wait for any WindowStation objects to get freed.
     */

#if 0
    /*
      * HACK ALERT!
      * Tentatively, we call our own copy of WaitForRundown
      * to let it timeout in the target session.
      */
    __ExWaitForRundownProtectionRelease(&gWinstaRunRef);
#endif

    ExWaitForRundownProtectionRelease(&gWinstaRunRef);
    ExRundownCompleted (&gWinstaRunRef);
}

VOID SetWaitForWinstaRundown(
    VOID)
{
    OBJECT_ATTRIBUTES   obja;
    NTSTATUS            Status;
    HANDLE              hProcess = NULL;
    HANDLE              hThreadWinstaRundown = NULL;
    PKEVENT             pRundownEvent = NULL;

    pRundownEvent = CreateKernelEvent(SynchronizationEvent, FALSE);

    InitializeObjectAttributes(&obja,
                               NULL,
                               0,
                               NULL,
                               NULL);

    UserAssert(gpepCSRSS != NULL);

    Status = ObOpenObjectByPointer(
                 gpepCSRSS,
                 0,
                 NULL,
                 PROCESS_CREATE_THREAD,
                 NULL,
                 KernelMode,
                 &hProcess);

    if (!NT_SUCCESS(Status)) {
        goto ExitClean;
    }

    UserAssert(hProcess != NULL);


    Status = PsCreateSystemThread(
                    &hThreadWinstaRundown,
                    THREAD_ALL_ACCESS,
                    &obja,
                    hProcess,
                    NULL,
                    (PKSTART_ROUTINE)WaitForWinstaRundown,
                    pRundownEvent);
    if (!NT_SUCCESS(Status)) {
        goto ExitClean;
    }

    if (pRundownEvent) {
        KeWaitForSingleObject(pRundownEvent, WrUserRequest,
                KernelMode, FALSE, NULL);
    } else {
        UserSleep(100);
    }

ExitClean:
    if (pRundownEvent) {
        FreeKernelEvent(&pRundownEvent);
    }

    if (hProcess) {
        ZwClose(hProcess);
    }

    if (hThreadWinstaRundown) {
        ZwClose(hThreadWinstaRundown);
    }
}

/***************************************************************
* NumHandles
*
* This function returns the number of handles of an Ob Object.
*
* History:
* 03/29/2001    MohamB    Created.
****************************************************************/
ULONG NumHandles(
    HANDLE hObjectHandle)
{
    NTSTATUS        Status;
    OBJECT_BASIC_INFORMATION Obi;

    if (hObjectHandle != NULL) {
        Status = ZwQueryObject(hObjectHandle,
                               ObjectBasicInformation,
                               &Obi,
                               sizeof (OBJECT_BASIC_INFORMATION),
                               NULL);
        if (Status == STATUS_SUCCESS) {
            if (Obi.HandleCount > 1) {
               HYDRA_HINT(HH_DTWAITONHANDLES);
            }
            return Obi.HandleCount;
        }
    }

    return 0;
}


/***************************************************************************\
* InitiateWin32kCleanup (RIT)
*
* This function starts the cleanup of a win32k
*
* History:
* 04-Dec-97 clupu      Created.
\***************************************************************************/
BOOL InitiateWin32kCleanup(
    VOID)
{
    PTHREADINFO     ptiCurrent;
    PWINDOWSTATION  pwinsta;
    BOOLEAN         fWait = TRUE;
    PDESKTOP        pdesk;
    UNICODE_STRING  ustrName;
    WCHAR           szName[MAX_SESSION_PATH];
    HANDLE          hevtRitExited;
    OBJECT_ATTRIBUTES obja;
    NTSTATUS        Status;
    LARGE_INTEGER   timeout;
    NTSTATUS        Reason;
    BOOL            fFirstTimeout = TRUE;

    TRACE_HYDAPI(("InitiateWin32kCleanup\n"));

    TAGMSG0(DBGTAG_RIT, "Exiting Win32k ...");

    SetWaitForWinstaRundown();

#if 0
    /*
     * From now on we are failing desktop open
     *
     * This causes xxxSetThreadDesktop to fail, which is needed during shutdown.
     * See 365290 & 412993
     */
    gbFailDeskopOpen = TRUE;
#endif


    /*
     * Prevent power callouts.
     */
    CleanupPowerRequestList();

    if (!gbRemoteSession) {
        /*
         * Cleanup device class notifications
         */
        xxxUnregisterDeviceClassNotifications();
    }

    EnterCrit();

    HYDRA_HINT(HH_INITIATEWIN32KCLEANUP);

    ptiCurrent = PtiCurrent();

    UserAssert(ptiCurrent != NULL);

    pwinsta = ptiCurrent->pwinsta;

    /*
     * Give DTs 5 minutes to go away
     */
    timeout.QuadPart = Int32x32To64(-10000, 600000);

    /*
     * Wait for all desktops to exit other than the disconnected desktop.
     */
    while (fWait) {

        /*
         * If things are left on the destroy list or the disconnected desktop is
         * not the current desktop (at the end we should always switch to the
         * disconnected desktop), then wait.
         */
        pdesk = pwinsta->rpdeskList;

        if (pdesk == NULL) {
            break;
        }

        fWait = pdesk != gspdeskDisconnect
                 || pdesk->rpdeskNext != NULL
                 || pwinsta->pTerm->rpdeskDestroy != NULL
                 || NumHandles(ghDisconnectDesk) > 1;

        if (fWait) {

            LeaveCrit();

            Reason = KeWaitForSingleObject(gpevtDesktopDestroyed, WrUserRequest,
                                           KernelMode, FALSE, &timeout);

            if (Reason == STATUS_TIMEOUT) {
#if 0

                /*
                 * The first time we timeout might be because winlogon died
                 * before calling ExitWindowsEx. In that case there may be processes
                 * w/ GUI threads running and those threads will have an hdesk
                 * in the THREADINFO structure. Thus the desktop threads will not exit.
                 * In this situation we signal the event 'EventRitStuck' so that
                 * csrss can tell termsrv to start killing the remaining processes
                 * calling NtTerminateProcess on them. csrss signals that to termsrv
                 * by closing the LPC port in ntuser\server\api.c (W32WinStationTerminate)
                 */

                if (fFirstTimeout) {

                    HANDLE hevtRitStuck;

                    FRE_RIPMSG0(RIP_ERROR,
                            "Timeout in RIT waiting for gpevtDesktopDestroyed. Signal EventRitStuck...");

                    swprintf(szName, L"\\Sessions\\%ld\\BaseNamedObjects\\EventRitStuck",
                             gSessionId);

                    RtlInitUnicodeString(&ustrName, szName);

                    InitializeObjectAttributes(&obja,
                                               &ustrName,
                                               OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                               NULL,
                                               NULL);

                    Status = ZwCreateEvent(&hevtRitStuck,
                                           EVENT_ALL_ACCESS,
                                           &obja,
                                           SynchronizationEvent,
                                           FALSE);

                    UserAssert((! gbRemoteSession) || NT_SUCCESS(Status));

                    if (NT_SUCCESS(Status)) {
                        ZwSetEvent(hevtRitStuck, NULL);
                        ZwClose(hevtRitStuck);

                        fFirstTimeout = FALSE;
                    }

                } else {
                    FRE_RIPMSG0(RIP_WARNING,
                            "Timeout in RIT waiting for gpevtDesktopDestroyed.\n"
                            "There are still GUI threads (assigned to a desktop) running !");
                }

                RIPMSG0(RIP_WARNING,
                        "Timeout in RIT waiting for gpevtDesktopDestroyed. Signal EventRitStuck...");
                {
                    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;
                    NTSTATUS Status;

                    Status = ZwQuerySystemInformation(SystemKernelDebuggerInformation,
                            &KernelDebuggerInfo, sizeof(KernelDebuggerInfo), NULL);
                    if (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled)
                         DbgBreakPoint();
                }
#endif
            }

            EnterCrit();
        }
    }
    TAGMSG0(DBGTAG_RIT, "All other desktops exited...");

    Unlock(&gspwndLogonNotify);

    /*
     * Set ExitInProgress -- this will prevent us from posting any
     * device reads in the future.
     */
    gbExitInProgress = TRUE;

    TAGMSG2(DBGTAG_RIT, "Shutting down ptiCurrent %lx cWindows %d",
           ptiCurrent, ptiCurrent->cWindows);

    /*
     * Clear out some values so some operations won't be possible.
     */
    gpqCursor = NULL;
    UserAssert(gspwndScreenCapture == NULL);
    Unlock(&gspwndMouseOwner);
    UserAssert(gspwndMouseOwner == NULL);
    UserAssert(gspwndInternalCapture == NULL);

    /*
     * Free any SPBs.
     */
    if (gpDispInfo) {
        FreeAllSpbs();
    }

    /*
     * Close the disconnected desktop.
     */
    if (ghDisconnectWinSta) {
        UserVerify(NT_SUCCESS(ZwClose(ghDisconnectWinSta)));
        ghDisconnectWinSta = NULL;
    }

    if (ghDisconnectDesk) {
        CloseProtectedHandle(ghDisconnectDesk);
        ghDisconnectDesk = NULL;
    }

    UserAssert(pwinsta->rpdeskList == NULL);

    /*
     * Unlock the logon desktop from the global variable
     */
    UnlockDesktop(&grpdeskLogon, LDU_DESKLOGON, 0);

    /*
     * Unlock the disconnect logon
     *
     * This was referenced when we created it, so free it now.
     * This is also a flag since the disconnect code checks to see if
     * the disconnected desktop is still around.
     */
    UnlockDesktop(&gspdeskDisconnect, LDU_DESKDISCONNECT, 0);

    /*
     * Unlock any windows still locked in the SMS list. We need to do
     * this here because if we don't, we end up with zombie windows in the
     * desktop thread that we'll try to assign to RIT but RIT will be gone.
     */
    {
        PSMS psms = gpsmsList;

        while (psms != NULL) {
            if (psms->spwnd != NULL) {
                UserAssert(psms->message == WM_CLIENTSHUTDOWN);

                RIPMSG1(RIP_WARNING, "Window %#p locked in the SMS list",
                        psms->spwnd);

                Unlock(&psms->spwnd);
            }
            psms = psms->psmsNext;
        }
    }

    TAGMSG0(DBGTAG_RIT, "posting WM_QUIT to the IO DT");

    UserAssert(pwinsta->pTerm->ptiDesktop != NULL);
    UserAssert(pwinsta->pTerm == &gTermIO);

    UserVerify(_PostThreadMessage(gTermIO.ptiDesktop, WM_QUIT, 0, 0));

    HYDRA_HINT(HH_DTQUITPOSTED);

    {
        /*
         * Wait for desktop thread(s) to exit.
         * This thread (RIT) is used to assign
         * objects if the orginal thread leaves.  So it should be
         * the last one to go.  Hopefully, if the desktop thread
         * exits, there shouldn't be any objects in use.
         */
        PVOID  aDT[2];
        ULONG  objects = 1;

        aDT[0] = gTermIO.ptiDesktop->pEThread;

        ObReferenceObject(aDT[0]);

        if (gTermNOIO.ptiDesktop != NULL) {
            aDT[1] = gTermNOIO.ptiDesktop->pEThread;
            ObReferenceObject(aDT[1]);
            objects++;

            UserVerify(_PostThreadMessage(gTermNOIO.ptiDesktop, WM_QUIT, 0, 0));
        }

        LeaveCrit();

        TAGMSG0(DBGTAG_RIT, "waiting on desktop thread(s) destruction ...");

        /*
         * Give DTs 5 minutes to go away
         */
        timeout.QuadPart = Int32x32To64(-10000, 300000);
WaitAgain:

        Reason =

        KeWaitForMultipleObjects(objects,
                                 aDT,
                                 WaitAll,
                                 WrUserRequest,
                                 KernelMode,
                                 TRUE,
                                 &timeout,
                                 NULL);

        if (Reason == STATUS_TIMEOUT) {
            FRE_RIPMSG0(RIP_ERROR,
                    "InitiateWin32kCleanup: Timeout in RIT waiting for desktop threads to go away.");
            goto WaitAgain;
        }

        TAGMSG0(DBGTAG_RIT, "Desktop thread(s) destroyed");

        ObDereferenceObject(aDT[0]);

        if (objects > 1) {
            ObDereferenceObject(aDT[1]);
        }

        EnterCrit();
    }

    HYDRA_HINT(HH_ALLDTGONE);

    /*
     * If still connected, tell the miniport driver to disconnect
     */
    if (gbConnected) {
        if (!gfRemotingConsole) {

            bDrvDisconnect(gpDispInfo->hDev, ghRemoteThinwireChannel,
                           gThinwireFileObject);
        } else{

            ASSERT(!IsRemoteConnection());
            ASSERT(gConsoleShadowhDev != NULL);
            bDrvDisconnect(gConsoleShadowhDev, ghConsoleShadowThinwireChannel,
                           gConsoleShadowThinwireFileObject);
        }
    }

    UnlockDesktop(&grpdeskRitInput, LDU_DESKRITINPUT, 0);
    UnlockDesktop(&gspdeskShouldBeForeground, LDU_DESKSHOULDBEFOREGROUND, 0);

    /*
     * Free outstanding timers
     */
    while (gptmrFirst != NULL) {
        FreeTimer(gptmrFirst);
    }

    /*
     * Kill the csr port so no hard errors are services after this point
     */
    if (CsrApiPort != NULL) {
        ObDereferenceObject(CsrApiPort);
        CsrApiPort = NULL;
    }

    Unlock(&gspwndCursor);

    /*
     * set this to NULL
     */
    gptiRit = NULL;

    TAGMSG0(DBGTAG_RIT, "TERMINATING !!!");

#if DBG
    {
        PPROCESSINFO ppi = gppiList;

        KdPrint(("Processes still running:\n"));
        KdPrint(("-------------------------\n"));

        while (ppi) {

            PTHREADINFO pti;

            KdPrint(("ppi '%s' %#p threads: %d\n",
                     PsGetProcessImageFileName(ppi->Process),
                     ppi,
                     ppi->cThreads));

            KdPrint(("\tGUI threads\n"));

            pti = ppi->ptiList;

            while (pti) {
                KdPrint(("\t%#p\n", pti));
                pti = pti->ptiSibling;
            }

            ppi = ppi->ppiNextRunning;
        }
        KdPrint(("-------------------------\n"));
    }
#endif // DBG

    LeaveCrit();

    if (gbRemoteSession) {
        swprintf(szName, L"\\Sessions\\%ld\\BaseNamedObjects\\EventRitExited",
                 gSessionId);

        RtlInitUnicodeString(&ustrName, szName);

        InitializeObjectAttributes(&obja,
                                   &ustrName,
                                   OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                   NULL,
                                   NULL);

        Status = ZwCreateEvent(&hevtRitExited,
                               EVENT_ALL_ACCESS,
                               &obja,
                               SynchronizationEvent,
                               FALSE);

        if (NT_SUCCESS(Status)) {
            ZwSetEvent(hevtRitExited, NULL);
            ZwClose(hevtRitExited);
        } else {
            RIPMSG1(RIP_ERROR, "RIT unable to create EventRitExited: 0x%x\n", Status);
        }
    }

    /*
     * Clear TIF_PALETTEAWARE or else we will AV in xxxDestroyThreadInfo
     * MCostea #412136
     */
    ptiCurrent->TIF_flags &= ~TIF_PALETTEAWARE;

    HYDRA_HINT(HH_RITGONE);

    return TRUE;
}

/***************************************************************************\
* RemoteSyncToggleKeys (RIT)
*
* This function is called whenever a remote client needs to synchronize the
* current toggle key state of the server.  If the keys are out of sync, it
* injects the correct toggle key sequences.
*
* History:
* 11-12-98 JParsons     Created.
\***************************************************************************/
VOID RemoteSyncToggleKeys(
    ULONG toggleKeys)
{
    KE ke;
    BOOL bInjected;

    CheckCritIn();
    gSetLedReceived = toggleKeys | KEYBOARD_LED_INJECTED;

#ifdef GENERIC_INPUT
    ke.hDevice = NULL;
#endif

    // Key injection only works if there is a ready application queue.
    if (gpqForeground != NULL) {

        bInjected = gSetLedReceived & KEYBOARD_SHADOW ? TRUE : FALSE;

        if (!(gSetLedReceived & KEYBOARD_CAPS_LOCK_ON) != !TestRawKeyToggle(VK_CAPITAL)) {
            ke.bScanCode = (BYTE)(0x3a);
            ke.usFlaggedVk = VK_CAPITAL;
            xxxProcessKeyEvent(&ke, 0, bInjected);

            ke.bScanCode = (BYTE)(0xba & 0x7f);
            ke.usFlaggedVk = VK_CAPITAL | KBDBREAK;
            xxxProcessKeyEvent(&ke, 0, bInjected);
        }

        if (!(gSetLedReceived & KEYBOARD_NUM_LOCK_ON) != !TestRawKeyToggle(VK_NUMLOCK)) {
            ke.bScanCode = (BYTE)(0x45);
            ke.usFlaggedVk = VK_NUMLOCK;
            xxxProcessKeyEvent(&ke, 0, bInjected);

            ke.bScanCode = (BYTE)(0xc5 & 0x7f);
            ke.usFlaggedVk = VK_NUMLOCK | KBDBREAK;
            xxxProcessKeyEvent(&ke, 0, bInjected);
        }

        if (!(gSetLedReceived & KEYBOARD_SCROLL_LOCK_ON) != !TestRawKeyToggle(VK_SCROLL)) {
            ke.bScanCode = (BYTE)(0x46);
            ke.usFlaggedVk = VK_SCROLL;
            xxxProcessKeyEvent(&ke, 0, bInjected);

            ke.bScanCode = (BYTE)(0xc6 & 0x7f);
            ke.usFlaggedVk = VK_SCROLL | KBDBREAK;
            xxxProcessKeyEvent(&ke, 0, bInjected);
        }

        if (JAPANESE_KBD_LAYOUT(GetActiveHKL())) {
            if (!(gSetLedReceived & KEYBOARD_KANA_LOCK_ON) != !TestRawKeyToggle(VK_KANA)) {
                ke.bScanCode = (BYTE)(0x70);
                ke.usFlaggedVk = VK_KANA;
                xxxProcessKeyEvent(&ke, 0, bInjected);

                ke.bScanCode = (BYTE)(0xf0 & 0x7f);
                ke.usFlaggedVk = VK_KANA | KBDBREAK;
                xxxProcessKeyEvent(&ke, 0, bInjected);
            }
        }

        gSetLedReceived = 0;
    }
}


/***************************************************************************\
* ProcessKeyboardInput (RIT)
*
* This function is called whenever a keyboard input is ready to be consumed.
* It calls xxxProcessKeyEvent() for every input event, and once all the events
* have been consumed, calls StartDeviceRead() to request more keyboard events.
*
* Return value: "OK to continue walking gpDeviceInfoList"
* TRUE  - processed input without leaving gpresDeviceInfoList critical section
* FALSE - had to leave the gpresDeviceInfoList critical section
*
* History:
* 11-26-90 DavidPe      Created.
\***************************************************************************/
VOID ProcessKeyboardInputWorker(
    PKEYBOARD_INPUT_DATA pkei,
#ifdef GENERIC_INPUT
    PDEVICEINFO pDeviceInfo,
#endif
    BOOL fProcessRemap)
{
    BYTE Vk;
    BYTE bPrefix;
    KE ke;

#ifdef GENERIC_INPUT
    /*
     * Set the device handle and raw data
     */
    ke.hDevice = PtoH(pDeviceInfo);
    UserAssert(pkei);
    ke.data = *pkei;
#endif

    /*
     * Remote terminal server clients occationally need to be able to set
     * the server's toggle key state to match the client.  All other
     * standard keyboard inputs are processed below since this is the most
     * frequent code path.
     */
    if ((pkei->Flags & (KEY_TERMSRV_SET_LED | KEY_TERMSRV_VKPACKET)) == 0) {

        // Process any deferred remote key sync requests
        if (!(gSetLedReceived & KEYBOARD_LED_INJECTED)) {
            goto ProcessKeys;
        } else {
            RemoteSyncToggleKeys(gSetLedReceived);
        }

ProcessKeys:
        if (pkei->Flags & KEY_E0) {
            bPrefix = 0xE0;
        } else if (pkei->Flags & KEY_E1) {
            bPrefix = 0xE1;
        } else {
            bPrefix = 0;
        }

        if (pkei->MakeCode == 0xFF) {
            /*
             * Kbd overrun (kbd hardware and/or keyboard driver) : Beep!
             * (some DELL keyboards send 0xFF if keys are hit hard enough,
             * presumably due to keybounce)
             */
            LeaveCrit();
            UserBeep(440, 125);
            EnterCrit();
            return;
        }

        ke.bScanCode = (BYTE)(pkei->MakeCode & 0x7F);
        if (fProcessRemap && (gpScancodeMap || gpFlexMap)) {
            ke.usFlaggedVk = 0;
            if (pkei->Flags & KEY_BREAK) {
                ke.usFlaggedVk |= KBDBREAK;
            }
            if (!MapScancode(&ke, &bPrefix
#ifdef GENERIC_INPUT
                             , pDeviceInfo
#endif
                             )) {
                /*
                 * If the input is all processed within MapScancode, go to the
                 * next one.
                 */
                return;
            }
        }

        gbVKLastDown = Vk = VKFromVSC(&ke, bPrefix, gafRawKeyState);



        if (Vk == 0
#ifdef GENERIC_INPUT
            && gpqForeground && !RawInputRequestedForKeyboard(PtiKbdFromQ(gpqForeground))
#endif
            ) {
            return;
        }

        if (pkei->Flags & KEY_BREAK) {
            ke.usFlaggedVk |= KBDBREAK;
        }


        /*
         * We don't know if the client system or the host should get the
         * windows key, so the choice is to not support it on the host.
         * (The windows key is a local key.)
         *
         * The other practical problem is that the local shell intercepts
         * the "break" of the windows key and switches to the start menu.
         * The client never sees the "break" so the host thinks the
         * windows key is always depressed.
         *
         * Newer clients may indicate they support the windows key.
         * If the client has indicated this through the gfEnableWindowsKey,
         * then we allow it to be processed here on the host.
         */
        if (IsRemoteConnection()) {
            BYTE CheckVk = (BYTE)ke.usFlaggedVk;

            if (CheckVk == VK_LWIN || CheckVk == VK_RWIN) {
                if (!gfEnableWindowsKey) {
                    return;
                }
            }
        }

        //
        // Keep track of real modifier key state.  Conveniently, the values for
        // VK_LSHIFT, VK_RSHIFT, VK_LCONTROL, VK_RCONTROL, VK_LMENU and
        // VK_RMENU are contiguous.  We'll construct a bit field to keep track
        // of the current modifier key state.  If a bit is set, the corresponding
        // modifier key is down.  The bit field has the following format:
        //
        //     +---------------------------------------------------+
        //     | Right | Left  |  Right  |  Left   | Right | Left  |
        //     |  Alt  |  Alt  | Control | Control | Shift | Shift |
        //     +---------------------------------------------------+
        //         5       4        3         2        1       0     Bit
        //
        // Add bit 7 -- VK_RWIN
        //     bit 6 -- VK_LWIN

        switch (Vk) {
        case VK_LSHIFT:
        case VK_RSHIFT:
        case VK_LCONTROL:
        case VK_RCONTROL:
        case VK_LMENU:
        case VK_RMENU:
            gCurrentModifierBit = 1 << (Vk & 0xf);
            break;
        case VK_LWIN:
            gCurrentModifierBit = 0x40;
            break;
        case VK_RWIN:
            gCurrentModifierBit = 0x80;
            break;
        default:
            gCurrentModifierBit = 0;
        }
        if (gCurrentModifierBit) {
            /*
             * If this is a break of a modifier key then clear the bit value.
             * Otherwise, set it.
             */
            if (pkei->Flags & KEY_BREAK) {
                gPhysModifierState &= ~gCurrentModifierBit;
            } else {
                gPhysModifierState |= gCurrentModifierBit;
            }
        }

        if (!TEST_ACCF(ACCF_ACCESSENABLED)) {
            xxxProcessKeyEvent(&ke, (ULONG_PTR)pkei->ExtraInformation,
                pkei->Flags & KEY_TERMSRV_SHADOW ? TRUE : FALSE);
        } else {
            if ((gtmridAccessTimeOut != 0) && TEST_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON)) {
                gtmridAccessTimeOut = InternalSetTimer(
                                                 NULL,
                                                 gtmridAccessTimeOut,
                                                 (UINT)gAccessTimeOut.iTimeOutMSec,
                                                 xxxAccessTimeOutTimer,
                                                 TMRF_RIT | TMRF_ONESHOT
                                                 );
            }
            if (AccessProceduresStream(&ke, pkei->ExtraInformation, 0)) {
                xxxProcessKeyEvent(&ke, (ULONG_PTR)pkei->ExtraInformation,
                    pkei->Flags & KEY_TERMSRV_SHADOW ? TRUE : FALSE);
            }
        }
    } else {
        // Special toggle key synchronization for Terminal Server
        if (pkei->Flags & KEY_TERMSRV_SET_LED) {
            if (pkei->Flags & KEY_TERMSRV_SHADOW) {
                pkei->ExtraInformation |= KEYBOARD_SHADOW;
            }
            RemoteSyncToggleKeys(pkei->ExtraInformation);
        }

        if (pkei->Flags & KEY_TERMSRV_VKPACKET) {
            ke.wchInjected = (WCHAR)pkei->MakeCode;
            ke.usFlaggedVk = VK_PACKET | KBDUNICODE |
                ((pkei->Flags & KEY_BREAK) ? KBDBREAK : 0);
            xxxProcessKeyEvent(
                &ke, 0,
                pkei->Flags & KEY_TERMSRV_SHADOW ? TRUE : FALSE
                );
        }
    }

}

VOID SearchAndSetKbdTbl(
    PDEVICEINFO pDeviceInfo,
    DWORD dwType,
    DWORD dwSubType)
{
    PKBDFILE pkf = gpKL->spkfPrimary;
    UINT i;

    if (pkf->pKbdTbl->dwType == dwType && pkf->pKbdTbl->dwSubType == dwSubType) {
        goto primary_match;
    }

    if ((pDeviceInfo->bFlags & GDIF_NOTPNP) == 0) {
        TAGMSG2(DBGTAG_KBD, "SearchAndSetKbdTbl: new type 0x%x:0x%x", dwType, dwSubType);

        /*
         * Search for matching keyboard layout in the current KL
         */
        for (i = 0; i < gpKL->uNumTbl; ++i) {
            TAGMSG2(DBGTAG_KBD, "SearchAndSetKbdTbl: searching 0x%x:0x%x",
                gpKL->pspkfExtra[i]->pKbdTbl->dwType,
                gpKL->pspkfExtra[i]->pKbdTbl->dwSubType);
            if (gpKL->pspkfExtra[i]->pKbdTbl->dwType == dwType &&
                    gpKL->pspkfExtra[i]->pKbdTbl->dwSubType == dwSubType) {
                TAGMSG2(DBGTAG_KBD, "SearchAndSetKbdTbl: new layout for 0x%x:0x%x",
                        gpKL->pspkfExtra[i]->pKbdTbl->dwType,
                        gpKL->pspkfExtra[i]->pKbdTbl->dwSubType);
                pkf = gpKL->pspkfExtra[i];
                break;
            }
        }

        if (i >= gpKL->uNumTbl) {
            /*
             * Unknown type to this KL.
             */
            TAGMSG0(DBGTAG_KBD, "ProcessKeyboardInput: cannot find the matching KL. Reactivating primary.");
        }

    } else {
        TAGMSG0(DBGTAG_KBD, "ProcessKeyboardInput: The new keyboard is not PnP. Use primary.");
    }

primary_match:
    if (gpKL->spkf != pkf) {
        Lock(&gpKL->spkf, pkf);
        SetGlobalKeyboardTableInfo(gpKL);
    }
}

VOID ProcessKeyboardInput(PDEVICEINFO pDeviceInfo)
{
    PKEYBOARD_INPUT_DATA pkei;
    PKEYBOARD_INPUT_DATA pkeiStart, pkeiEnd;

    EnterCrit();
    UserAssert(pDeviceInfo->type == DEVICE_TYPE_KEYBOARD);
    UserAssert(pDeviceInfo->iosb.Information);
    UserAssert(NT_SUCCESS(pDeviceInfo->iosb.Status));

    /*
     * Switch the keyboard layout table, if the current KL has multiple
     * tables.
     */
    if (gpKL && gpKL->uNumTbl > 0 &&
                (gpKL->dwLastKbdType != GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo) ||
                 gpKL->dwLastKbdSubType != GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo))) {
        SearchAndSetKbdTbl(pDeviceInfo,
                           GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo),
                           GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo));
        /*
         * Whether or not we found the match, cache the type/subtype so that
         * we will not try to find the same type/subtype for a while.
         */
        gpKL->dwLastKbdType = GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo);
        gpKL->dwLastKbdSubType = GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo);
    }

    pkeiStart = pDeviceInfo->keyboard.Data;
    pkeiEnd   = (PKEYBOARD_INPUT_DATA)((PBYTE)pkeiStart + pDeviceInfo->iosb.Information);
    for (pkei = pkeiStart; pkei < pkeiEnd; pkei++) {
        ProcessKeyboardInputWorker(pkei,
#ifdef GENERIC_INPUT
                                   pDeviceInfo,
#endif
                                   TRUE);
    }

    LeaveCrit();
}


/***************************************************************************\
* xxxProcessKeyEvent (RIT)
*
* This function is called to process an individual keystroke (up or down).
* It performs some OEM, language and layout specific processing which
* discards or modifies the keystroke or introduces additional keystrokes.
* The RawKeyState is updated here, also termination of screen saver and video
* power down is initiated here.
* xxxKeyEvent() is called for each resulting keystroke.
*
* History:
* 11-26-90 DavidPe      Created.
\***************************************************************************/

VOID xxxProcessKeyEvent(
    PKE pke,
    ULONG_PTR ExtraInformation,
    BOOL bInjected)
{
    BYTE Vk;

    CheckCritIn();

    Vk = (BYTE)pke->usFlaggedVk;

    /*
     * KOREAN:
     * Check this is Korean keyboard layout, or not..
     *
     * NOTE:
     *  It would be better check this by "keyboard hardware" or
     * "keyboard layout" ???
     *
     * 1. Check by hardware :
     *
     *   if (KOREAN_KEYBOARD(gKeyboardInfo.KeyboardIdentifier)) {
     *
     * 2. Check by layout :
     *
     *   if (KOREAN_KBD_LAYOUT(_GetKeyboardLayout(0L))) {
     */
    if (KOREAN_KBD_LAYOUT(GetActiveHKL())) {
        if ((pke->usFlaggedVk & KBDBREAK) &&
            !(pke->usFlaggedVk & KBDUNICODE) &&
            (pke->bScanCode == 0xF1 || pke->bScanCode == 0xF2) &&
            !TestRawKeyDown(Vk)) {
            /*
             * This is actually a keydown with a scancode of 0xF1 or 0xF2 from a
             * Korean keyboard. Korean IMEs and apps want a WM_KEYDOWN with a
             * scancode of 0xF1 or 0xF2. They don't mind not getting the WM_KEYUP.
             * Don't update physical keystate to allow a real 0x71/0x72 keydown.
             */
            pke->usFlaggedVk &= ~KBDBREAK;
        } else {
            UpdateRawKeyState(Vk, pke->usFlaggedVk & KBDBREAK);
        }
    } else {
        UpdateRawKeyState(Vk, pke->usFlaggedVk & KBDBREAK);
    }

    /*
     * Convert Left/Right Ctrl/Shift/Alt key to "unhanded" key.
     * ie: if VK_LCONTROL or VK_RCONTROL, convert to VK_CONTROL etc.
     */
    if ((Vk >= VK_LSHIFT) && (Vk <= VK_RMENU)) {
        Vk = (BYTE)((Vk - VK_LSHIFT) / 2 + VK_SHIFT);
        UpdateRawKeyState(Vk, pke->usFlaggedVk & KBDBREAK);
    }

    /*
     * Setup to shutdown screen saver and exit video power down mode.
     */
    if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
        /*
         * Call video driver here to exit power down mode.
         */
        TAGMSG0(DBGTAG_Power, "Exit video power down mode");
        DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
    }
    glinp.dwFlags = (glinp.dwFlags & ~(LINP_INPUTTIMEOUTS | LINP_INPUTSOURCES)) | LINP_KEYBOARD;
    
    gpsi->dwLastRITEventTickCount = NtGetTickCount();
    if (!gbBlockSendInputResets || !bInjected) {
	    glinp.timeLastInputMessage = gpsi->dwLastRITEventTickCount;
    }    
    
    if (gpsi->dwLastRITEventTickCount - gpsi->dwLastSystemRITEventTickCountUpdate > SYSTEM_RIT_EVENT_UPDATE_PERIOD) {
        SharedUserData->LastSystemRITEventTickCount = gpsi->dwLastRITEventTickCount;
        gpsi->dwLastSystemRITEventTickCountUpdate = gpsi->dwLastRITEventTickCount;
    }

    if (!bInjected || (pke->dwTime == 0)) {
        pke->dwTime = glinp.timeLastInputMessage;
    }

#ifdef MOUSE_IP
    /*
     * Sonar
     */
    CheckCritIn();
#ifdef KBDMAPPEDVK
    if ((pke->usFlaggedVk & KBDMAPPEDVK) == 0) {
#endif
        /*
         * Sonar is not activated for simulated modifier keys
         */
        if ((pke->usFlaggedVk & KBDBREAK) == 0) {
            /*
             * Key down:
             * When the key is down, sonar needs to be stopped.
             */
            if (IS_SONAR_ACTIVE()) {
                StopSonar();
            }
            /*
             * Do not process the repeated keys...
             * If this key is not pressed before, remember it for the key up event.
             */
            if (gbLastVkForSonar != Vk) {
                gbLastVkForSonar = Vk;
            }
        } else {
            /*
             * Key up:
             */
            if ((BYTE)Vk == gbVkForSonarKick && (BYTE)Vk == gbLastVkForSonar && TestUP(MOUSESONAR)) {
                /*
                 * If this is keyup and it is the Sonar key, and it's the last key downed,
                 * kick the sonar now.
                 */
                StartSonar();
            }
            /*
             * Clear the last VK for the next key event.
             */
            CLEAR_SONAR_LASTVK();
        }
#ifdef KBDMAPPEDVK
    }
#endif
#endif

    /*
     * Now call all the OEM- and Locale- specific KEProcs.
     * If KEProcs return FALSE, the keystroke has been discarded, in
     * which case don't pass the key event on to xxxKeyEvent().
     */
    if (pke->usFlaggedVk & KBDUNICODE) {
        xxxKeyEvent(pke->usFlaggedVk, pke->wchInjected,
                    pke->dwTime, ExtraInformation,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    bInjected);
    } else {
        if (KEOEMProcs(pke) && xxxKELocaleProcs(pke) && xxxKENLSProcs(pke,ExtraInformation)) {
            xxxKeyEvent(pke->usFlaggedVk, pke->bScanCode,
                        pke->dwTime, ExtraInformation,
#ifdef GENERIC_INPUT
                        pke->hDevice,
                        &pke->data,
#endif
                        bInjected);
        }
    }
}

#ifndef SUBPIXEL_MOUSE
/***************************************************************************\
* DoMouseAccel (RIT)
*
* History:
* 11-29-90 DavidPe      Created.
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, DoMouseAccel)
#endif

LONG DoMouseAccel(
    LONG Delta)
{
    LONG newDelta = Delta;

    if (abs(Delta) > gMouseThresh1) {
        newDelta *= 2;

        if ((abs(Delta) > gMouseThresh2) && (gMouseSpeed == 2)) {
            newDelta *= 2;
        }
    }

    return newDelta;
}
#endif


/***************************************************************************\
* PwndForegroundCapture
*
* History:
* 10-23-91 DavidPe      Created.
\***************************************************************************/

PWND PwndForegroundCapture(VOID)
{
    if (gpqForeground != NULL) {
        return gpqForeground->spwndCapture;
    }

    return NULL;
}


/***************************************************************************\
* SetKeyboardRate
*
* This function calls the keyboard driver to set a new keyboard repeat
* rate and delay.  It limits the values to the min and max given by
* the driver so it won't return an error when we call it.
*
* History:
* 11-29-90 DavidPe      Created.
\***************************************************************************/
VOID SetKeyboardRate(
    UINT                nKeySpeedAndDelay
    )
{
    UINT nKeyDelay;
    UINT nKeySpeed;

    nKeyDelay = (nKeySpeedAndDelay & KDELAY_MASK) >> KDELAY_SHIFT;

    nKeySpeed = KSPEED_MASK & nKeySpeedAndDelay;

    gktp.Rate = (USHORT)( ( gKeyboardInfo.KeyRepeatMaximum.Rate -
                   gKeyboardInfo.KeyRepeatMinimum.Rate
                 ) * nKeySpeed / KSPEED_MASK
               ) +
               gKeyboardInfo.KeyRepeatMinimum.Rate;

    gktp.Delay = (USHORT)( ( gKeyboardInfo.KeyRepeatMaximum.Delay -
                    gKeyboardInfo.KeyRepeatMinimum.Delay
                  ) * nKeyDelay / (KDELAY_MASK >> KDELAY_SHIFT)
                ) +
                gKeyboardInfo.KeyRepeatMinimum.Delay;

    /*
     * Hand off the IOCTL to the RIT, since only the system process can
     * access keyboard handles
     */
    gdwUpdateKeyboard |= UPDATE_KBD_TYPEMATIC;
}


/***************************************************************************\
* UpdateKeyLights
*
* This function calls the keyboard driver to set the keylights into the
* current state specified by the async keystate table.
*
* bInjected: (explanation from John Parsons via email)
* Set this TRUE if you do something on the server to asynchronously change the
* indicators behind the TS client's back, to get this reflected back to the
* client.  Examples are toggling num lock or caps lock programatically, or our
* favorite example is the automatic spelling correction on Word: if you type
* "tHE mouse went up the clock", Word will fix it by automagically pressing
* CAPS LOCK, then retyping the T  -- if the client is not informed, the keys
* get out of sync.
* Set this to FALSE for indicator changes initiated by the client (let's say by
* pressing CAPS LOCK) in which case we don't loop back the indicator change
* since the client has already changed state locally.
*
* History:
* 11-29-90 DavidPe      Created.
\***************************************************************************/

VOID UpdateKeyLights(BOOL bInjected)
{
    /*
     * Looking at async keystate.  Must be in critical section.
     */
    CheckCritIn();

    /*
     * Based on the toggle bits in the async keystate table,
     * set the key lights.
     */
    gklp.LedFlags = 0;
    if (TestAsyncKeyStateToggle(VK_CAPITAL)) {
        gklp.LedFlags |= KEYBOARD_CAPS_LOCK_ON;
        SetRawKeyToggle(VK_CAPITAL);
    } else {
        ClearRawKeyToggle(VK_CAPITAL);
    }

    if (TestAsyncKeyStateToggle(VK_NUMLOCK)) {
        gklp.LedFlags |= KEYBOARD_NUM_LOCK_ON;
        SetRawKeyToggle(VK_NUMLOCK);
    } else {
        ClearRawKeyToggle(VK_NUMLOCK);
    }

    if (TestAsyncKeyStateToggle(VK_SCROLL)) {
        gklp.LedFlags |= KEYBOARD_SCROLL_LOCK_ON;
        SetRawKeyToggle(VK_SCROLL);
    } else {
        ClearRawKeyToggle(VK_SCROLL);
    }

    /*
     * Only "Japanese keyboard hardware" has "KANA" LEDs, and switch to
     * "KANA" state.
     */
    if (JAPANESE_KEYBOARD(gKeyboardInfo.KeyboardIdentifier)) {
        if (TestAsyncKeyStateToggle(VK_KANA)) {
            gklp.LedFlags |= KEYBOARD_KANA_LOCK_ON;
            SetRawKeyToggle(VK_KANA);
        } else {
            ClearRawKeyToggle(VK_KANA);
        }
    }

    /*
     * On terminal server, we need to tell the WD about application injected
     * toggle keys so it can update the client accordingly.
     */

    if (IsRemoteConnection()) {
        if (bInjected)
            gklp.LedFlags |= KEYBOARD_LED_INJECTED;
        else
            gklp.LedFlags &= ~KEYBOARD_LED_INJECTED;
    }


    if (PtiCurrent() != gptiRit) {
        /*
         * Hand off the IOCTL to the RIT, since only the system process can
         * access the keyboard handles.  Happens when applying user's profile.
         * IanJa: Should we check PpiCurrent() == gptiRit->ppi instead?
         */
        gdwUpdateKeyboard |= UPDATE_KBD_LEDS;
    } else {
        /*
         * Do it immediately (avoids a small delay between keydown and LED
         * on when typing)
         */
        PDEVICEINFO pDeviceInfo;

        EnterDeviceInfoListCrit();
        for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
            if ((pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) && (pDeviceInfo->handle)) {
                ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                        &giosbKbdControl, IOCTL_KEYBOARD_SET_INDICATORS,
                        (PVOID)&gklp, sizeof(gklp), NULL, 0);
            }
        }
        LeaveDeviceInfoListCrit();

        if (gfRemotingConsole) {
            ZwDeviceIoControlFile(ghConsoleShadowKeyboardChannel, NULL, NULL, NULL,
                    &giosbKbdControl, IOCTL_KEYBOARD_SET_INDICATORS,
                    (PVOID)&gklp, sizeof(gklp), NULL, 0);
        }
    }
}


/*
 * _GetKeyboardType is obsolete API. The API cannot
 * deal with the multiple keyboards attached.
 * This API returns the best guess that older apps
 * would expect.
 */
int _GetKeyboardType(int nTypeFlag)
{

    switch (nTypeFlag) {
    case 0:
        if (gpKL) {
            DWORD dwType;

            //
            // If there's gpKL, use its primary
            // type info rather than the one used
            // last time.
            //
            UserAssert(gpKL->spkfPrimary);
            UserAssert(gpKL->spkfPrimary->pKbdTbl);
            dwType = gpKL->spkfPrimary->pKbdTbl->dwType;
            if (dwType != 0 && dwType != KEYBOARD_TYPE_UNKNOWN) {
                return dwType;
            }
        }
        return gKeyboardInfo.KeyboardIdentifier.Type;

    case 1:
    // FE_SB
    {
        int OEMId = 0;
        DWORD dwSubType;
        PKBDNLSTABLES pKbdNlsTbl = gpKbdNlsTbl;

        //
        // If there's gpKL, use its primary value
        // rather than the one used last time.
        //
        if (gpKL) {
            UserAssert(gpKL->spkfPrimary);
            if (gpKL->spkfPrimary->pKbdNlsTbl) {
                pKbdNlsTbl =gpKL->spkfPrimary->pKbdNlsTbl;
            }
            UserAssert(gpKL->spkfPrimary->pKbdTbl);
            dwSubType = gpKL->spkfPrimary->pKbdTbl->dwSubType;
        } else {
            dwSubType = gKeyboardInfo.KeyboardIdentifier.Subtype;
        }

        //
        // If this keyboard layout is compatible with 101 or 106
        // Japanese keyboard, we just return 101 or 106's keyboard
        // id, not this keyboard's one to let application handle
        // this keyboard as 101 or 106 Japanese keyboard.
        //
        if (pKbdNlsTbl) {
            if (pKbdNlsTbl->LayoutInformation & NLSKBD_INFO_EMURATE_101_KEYBOARD) {
                return MICROSOFT_KBD_101_TYPE;
            }
            if (pKbdNlsTbl->LayoutInformation & NLSKBD_INFO_EMURATE_106_KEYBOARD) {
                return MICROSOFT_KBD_106_TYPE;
            }
        }

        //
        // PSS ID Number: Q130054
        // Article last modified on 05-16-1995
        //
        // 3.10 1.20 | 3.50 1.20
        // WINDOWS   | WINDOWS NT
        //
        // ---------------------------------------------------------------------
        // The information in this article applies to:
        // - Microsoft Windows Software Development Kit (SDK) for Windows
        //   version 3.1
        // - Microsoft Win32 Software Development Kit (SDK) version 3.5
        // - Microsoft Win32s version 1.2
        // ---------------------------------------------------------------------
        // SUMMARY
        // =======
        // Because of the variety of computer manufacturers (NEC, Fujitsu, IBMJ, and
        // so on) in Japan, sometimes Windows-based applications need to know which
        // OEM (original equipment manufacturer) manufactured the computer that is
        // running the application. This article explains how.
        //
        // MORE INFORMATION
        // ================
        // There is no documented way to detect the manufacturer of the computer that
        // is currently running an application. However, a Windows-based application
        // can detect the type of OEM Windows by using the return value of the
        // GetKeyboardType() function.
        //
        // If an application uses the GetKeyboardType API, it can get OEM ID by
        // specifying "1" (keyboard subtype) as argument of the function. Each OEM ID
        // is listed here:
        //
        // OEM Windows       OEM ID
        // ------------------------------
        // Microsoft         00H (DOS/V)
        // all AX            01H
        // EPSON             04H
        // Fujitsu           05H
        // IBMJ              07H
        // Matsushita        0AH
        // NEC               0DH
        // Toshiba           12H
        //
        // Application programs can use these OEM IDs to distinguish the type of OEM
        // Windows. Note, however, that this method is not documented, so Microsoft
        // may not support it in the future version of Windows.
        //
        // As a rule, application developers should write hardware-independent code,
        // especially when making Windows-based applications. If they need to make a
        // hardware-dependent application, they must prepare the separated program
        // file for each different hardware architecture.
        //
        // Additional reference words: 3.10 1.20 3.50 1.20 kbinf
        // KBCategory: kbhw
        // KBSubcategory: wintldev
        // =============================================================================
        // Copyright Microsoft Corporation 1995.

        if (pKbdNlsTbl) {
            //
            // Get OEM (Windows) ID.
            //
            OEMId = ((int)pKbdNlsTbl->OEMIdentifier) << 8;
        }
        //
        // The format of KeyboardIdentifier.Subtype :
        //
        // 0 - 3 bits = keyboard subtype
        // 4 - 7 bits = kernel mode kerboard driver provider id.
        //
        // Kernel mode keyboard dirver provier | ID
        // ------------------------------------+-----
        // Microsoft                           | 00H
        // all AX                              | 01H
        // Toshiba                             | 02H
        // EPSON                               | 04H
        // Fujitsu                             | 05H
        // IBMJ                                | 07H
        // Matsushita                          | 0AH
        // NEC                                 | 0DH
        //

        //
        // And here is the format of return value.
        //
        // 0  -  7 bits = Keyboard Subtype.
        // 8  - 15 bits = OEM (Windows) Id.
        // 16 - 31 bits = not used.
        //
        return (int)(OEMId | (dwSubType & 0x0f));
    }

    case 2:
        return gKeyboardInfo.NumberOfFunctionKeys;
    }
    return 0;
}

/**************************************************************************\
* xxxMouseEventDirect
*
* Mouse event inserts a mouse event into the input stream.
*
* The parameters are the same as the fields of the MOUSEINPUT structure
* used in SendInput.
*
*    dx           Delta x
*    dy           Delta y
*    mouseData    Mouse wheel movement or xbuttons
*    dwMEFlags    Mouse event flags
*    dwExtraInfo  Extra info from driver.
*
* History:
* 07-23-92 Mikehar      Created.
* 01-08-93 JonPa        Made it work with new mouse drivers
\**************************************************************************/

BOOL xxxMouseEventDirect(
   DWORD dx,
   DWORD dy,
   DWORD mouseData,
   DWORD dwMEFlags,
   DWORD dwTime,
   ULONG_PTR dwExtraInfo)
{
    DWORD   dwDriverMouseFlags;
    DWORD   dwDriverMouseData;
#ifdef GENERIC_INPUT
    MOUSE_INPUT_DATA mei;
#endif

    PTHREADINFO pti = PtiCurrent();
    if (dwTime == 0) {
        dwTime = NtGetTickCount();
    }

    /*
     * The calling thread must be on the active desktop
     * and have journal playback access to that desktop.
     */
    if (pti->rpdesk == grpdeskRitInput) {
        UserAssert(!(pti->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));
        if (!CheckGrantedAccess(pti->amdesk, DESKTOP_JOURNALPLAYBACK)) {

            RIPNTERR0(STATUS_ACCESS_DENIED, RIP_WARNING,
                      "mouse_event(): No DESKTOP_JOURNALPLAYBACK access to input desktop.");
            return FALSE;
        }
    } else {
        /*
         * 3/22/95 BradG - Only allow below HACK for pre 4.0 applications
         */
        if (LOWORD(pti->dwExpWinVer) >= VER40) {
            RIPMSG0(RIP_VERBOSE,"mouse_event(): Calls not forwarded for 4.0 or greater apps.");
            return FALSE;
        } else {
            BOOL fAccessToDesktop;

            /*
             * 3/22/95 BradG - Bug #9314: Screensavers are not deactivated by mouse_event()
             *    The main problem is the check above, since screensavers run on their own
             *    desktop.  This causes the above check to fail because the process using
             *    mouse_event() is running on another desktop.  The solution is to determine
             *    if we have access to the input desktop by calling _OpenDesktop for the
             *    current input desktop, grpdeskRitInput, with a request for DESKTOP_JOURNALPLAYBACK
             *    access.  If this succeeds, we can allow this mouse_event() request to pass
             *    through, otherwise return.
             */
            UserAssert(grpdeskRitInput != NULL);

            UserAssert(!(grpdeskRitInput->rpwinstaParent->dwWSF_Flags & WSF_NOIO));
            fAccessToDesktop = AccessCheckObject(grpdeskRitInput,
                    DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS | DESKTOP_JOURNALPLAYBACK,
                    KernelMode,
                    &DesktopMapping);
            if (!fAccessToDesktop) {
                RIPMSG0(RIP_VERBOSE, "mouse_event(): Call NOT forwarded to input desktop" );
                return FALSE;
            }

            /*
             * We do have access to the desktop, so
             * let this mouse_event() call go through.
             */
            RIPMSG0( RIP_VERBOSE, "mouse_event(): Call forwarded to input desktop" );
        }
    }

    /*
     * This process is providing input so it gets the right to
     *  call SetForegroundWindow
     */
    gppiInputProvider = pti->ppi;

    /*
     * The following code assumes that MOUSEEVENTF_MOVE == 1,
     * that MOUSEEVENTF_ABSOLUTE > all button flags, and that the
     * mouse_event button flags are defined in the same order as the
     * MOUSE_INPUT_DATA button bits.
     */
#if MOUSEEVENTF_MOVE != 1
#   error("MOUSEEVENTF_MOVE != 1")
#endif
#if MOUSEEVENTF_LEFTDOWN != MOUSE_LEFT_BUTTON_DOWN * 2
#   error("MOUSEEVENTF_LEFTDOWN != MOUSE_LEFT_BUTTON_DOWN * 2")
#endif
#if MOUSEEVENTF_LEFTUP != MOUSE_LEFT_BUTTON_UP * 2
#   error("MOUSEEVENTF_LEFTUP != MOUSE_LEFT_BUTTON_UP * 2")
#endif
#if MOUSEEVENTF_RIGHTDOWN != MOUSE_RIGHT_BUTTON_DOWN * 2
#   error("MOUSEEVENTF_RIGHTDOWN != MOUSE_RIGHT_BUTTON_DOWN * 2")
#endif
#if MOUSEEVENTF_RIGHTUP != MOUSE_RIGHT_BUTTON_UP * 2
#   error("MOUSEEVENTF_RIGHTUP != MOUSE_RIGHT_BUTTON_UP * 2")
#endif
#if MOUSEEVENTF_MIDDLEDOWN != MOUSE_MIDDLE_BUTTON_DOWN * 2
#   error("MOUSEEVENTF_MIDDLEDOWN != MOUSE_MIDDLE_BUTTON_DOWN * 2")
#endif
#if MOUSEEVENTF_MIDDLEUP != MOUSE_MIDDLE_BUTTON_UP * 2
#   error("MOUSEEVENTF_MIDDLEUP != MOUSE_MIDDLE_BUTTON_UP * 2")
#endif
#if MOUSEEVENTF_WHEEL != MOUSE_WHEEL * 2
#   error("MOUSEEVENTF_WHEEL != MOUSE_WHEEL * 2")
#endif

    /* set legal values */
    dwDriverMouseFlags = dwMEFlags & MOUSEEVENTF_BUTTONMASK;

    /* remove MOUSEEVENTF_XDOWN/UP because we are going to add
       MOUSEEVENTF_DRIVER_X1/2DOWN/UP later */
    dwDriverMouseFlags &= ~(MOUSEEVENTF_XDOWN | MOUSEEVENTF_XUP);

    dwDriverMouseData = 0;

    /*
     * Handle mouse wheel and xbutton inputs.
     *
     * Note that MOUSEEVENTF_XDOWN/UP and MOUSEEVENTF_MOUSEWHEEL cannot both
     * be specified since they share the mouseData field
     */
    if (    ((dwMEFlags & (MOUSEEVENTF_XDOWN | MOUSEEVENTF_WHEEL)) == (MOUSEEVENTF_XDOWN | MOUSEEVENTF_WHEEL)) ||
            ((dwMEFlags & (MOUSEEVENTF_XUP   | MOUSEEVENTF_WHEEL)) == (MOUSEEVENTF_XUP | MOUSEEVENTF_WHEEL))) {

        RIPMSG1(RIP_WARNING, "Can't specify both MOUSEEVENTF_XDOWN/UP and MOUSEEVENTF_WHEEL in call to SendInput, dwFlags=0x%.8X", dwMEFlags);
        dwDriverMouseFlags &= ~(MOUSEEVENTF_XDOWN | MOUSEEVENTF_XUP | MOUSEEVENTF_WHEEL);
    } else if (dwMEFlags & MOUSEEVENTF_WHEEL) {
        /*
         * Force the value to a short. We cannot fail if it is out of range
         * because we accepted a 32 bit value in NT 4.
         */
        dwDriverMouseData = min(max(SHRT_MIN, (LONG)mouseData), SHRT_MAX);
    } else {

        /* don't process xbuttons if mousedata has invalid buttons */
        if (~XBUTTON_MASK & mouseData) {
            RIPMSG1(RIP_WARNING, "Invalid xbutton specified in SendInput, mouseData=0x%.8X", mouseData);
        } else {
            if (dwMEFlags & MOUSEEVENTF_XDOWN) {
                if (mouseData & XBUTTON1) {
                    dwDriverMouseFlags |= MOUSEEVENTF_DRIVER_X1DOWN;
                }
                if (mouseData & XBUTTON2) {
                    dwDriverMouseFlags |= MOUSEEVENTF_DRIVER_X2DOWN;
                }
            }
            if (dwMEFlags & MOUSEEVENTF_XUP) {
                if (mouseData & XBUTTON1) {
                    dwDriverMouseFlags |= MOUSEEVENTF_DRIVER_X1UP;
                }
                if (mouseData & XBUTTON2) {
                    dwDriverMouseFlags |= MOUSEEVENTF_DRIVER_X2UP;
                }
            }
        }
    }

    /* Convert the MOUSEEVENTF_ flags to MOUSE_BUTTON flags sent by the driver */
    dwDriverMouseFlags >>= 1;

#ifdef GENERIC_INPUT
    mei.UnitId = INJECTED_UNIT_ID;
    if (dwMEFlags & MOUSEEVENTF_ABSOLUTE) {
        mei.Flags = MOUSE_MOVE_ABSOLUTE;
    } else {
        mei.Flags = MOUSE_MOVE_RELATIVE;
    }
    if (dwMEFlags & MOUSEEVENTF_VIRTUALDESK) {
        mei.Flags |= MOUSE_VIRTUAL_DESKTOP;
    }
    mei.Buttons = dwDriverMouseFlags;
    if (dwDriverMouseData) {
        mei.ButtonData = (USHORT)dwDriverMouseData;
    }
    mei.RawButtons = 0; // LATER...
    mei.LastX = dx;
    mei.LastY = dy;
    mei.ExtraInformation = (ULONG)dwExtraInfo;
#endif

    LeaveCrit();

    /*
     * Process coordinates first.  This is especially useful for absolute
     * pointing devices like touch-screens and tablets.
     */
    if (dwMEFlags & MOUSEEVENTF_MOVE) {
        TAGMSG2(DBGTAG_PNP, "xxxMouseEventDirect: posting mouse move msg: Flag=%04x MouseData=%04x",
                mei.Flags, mei.Buttons);
        xxxMoveEvent(dx, dy, dwMEFlags, dwExtraInfo,
#ifdef GENERIC_INPUT
                    /*
                     * This is a simulated input from SendInput API.
                     * There is no real mouse device associated with this input,
                     * so we can only pass NULL as a hDevice.
                     */
                     NULL,
                     &mei,
#endif
                     dwTime, TRUE);
    }

    TAGMSG2(DBGTAG_PNP, "xxxMoveEvent: queueing mouse msg: Flag=%04x MouseData=%04x",
            mei.Flags, mei.Buttons);
    QueueMouseEvent(
            (USHORT) dwDriverMouseFlags,
            (USHORT) dwDriverMouseData,
            dwExtraInfo,
            gptCursorAsync,
            dwTime,
#ifdef GENERIC_INPUT
            NULL,
            &mei,
#endif
            TRUE,
            FALSE
            );

    ProcessQueuedMouseEvents();

    EnterCrit();

    return TRUE;
}

/**************************************************************************\
* xxxInternalKeyEventDirect
*
* key event inserts a key event into the input stream.
*
* History:
* 07-23-92 Mikehar      Created.
\**************************************************************************/
BOOL xxxInternalKeyEventDirect(
   BYTE  bVk,
   WORD  wScan,
   DWORD dwFlags,
   DWORD dwTime,
   ULONG_PTR dwExtraInfo)
{
    PTHREADINFO pti = PtiCurrent();
    KE KeyEvent;

    /*
     * The calling thread must be on the active desktop
     * and have journal playback access to that desktop.
     */
    if (pti->rpdesk != grpdeskRitInput ||
        !(ISCSRSS() ||
          RtlAreAllAccessesGranted(pti->amdesk, DESKTOP_JOURNALPLAYBACK))) {

        RIPNTERR0(STATUS_ACCESS_DENIED, RIP_WARNING,
                  "Injecting key failed: Non active desktop or access denied");

        return FALSE;
    }
    UserAssert(!(pti->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

    KeyEvent.bScanCode = (BYTE)wScan;
#ifdef GENERIC_INPUT
    /*
     * This is a injected key, no real device is associated with this...
     */
    KeyEvent.hDevice = NULL;
#endif

    if (dwFlags & KEYEVENTF_SCANCODE) {
        bVk = VKFromVSC(&KeyEvent,
                        (BYTE)(dwFlags & KEYEVENTF_EXTENDEDKEY ? 0xE0 : 0),
                        gafRawKeyState);
        KeyEvent.usFlaggedVk = (USHORT)bVk;
    } else {
        KeyEvent.usFlaggedVk = bVk | KBDINJECTEDVK;
    }

    if (dwFlags & KEYEVENTF_KEYUP)
        KeyEvent.usFlaggedVk |= KBDBREAK;

    if (dwFlags & KEYEVENTF_UNICODE) {
        KeyEvent.usFlaggedVk |= KBDUNICODE;
        KeyEvent.wchInjected = wScan;
    } else if (dwFlags & KEYEVENTF_EXTENDEDKEY) {
        KeyEvent.usFlaggedVk |= KBDEXT;
    } else {
        // Is it from the numeric keypad?
        if (((bVk >= VK_NUMPAD0) && (bVk <= VK_NUMPAD9)) || (bVk == VK_DECIMAL)) {
            KeyEvent.usFlaggedVk |= KBDNUMPAD;
        } else {
            int i;
            for (i = 0; ausNumPadCvt[i] != 0; i++) {
                if (bVk == LOBYTE(ausNumPadCvt[i])) {
                    KeyEvent.usFlaggedVk |= KBDNUMPAD;
                    break;
                }
            }
        }
    }

#ifdef GENERIC_INPUT
    /*
     * Let's simulate the input as far as we can.
     */
    KeyEvent.data.MakeCode = (BYTE)wScan;
    if (dwFlags & KEYEVENTF_KEYUP) {
        KeyEvent.data.Flags = KEY_BREAK;
    } else {
        KeyEvent.data.Flags = KEY_MAKE;
    }
    if (dwFlags & KEYEVENTF_EXTENDEDKEY) {
        KeyEvent.data.Flags |= KEY_E0;
    }
    KeyEvent.data.Reserved = 0;
    KeyEvent.data.UnitId = INJECTED_UNIT_ID;
    KeyEvent.data.ExtraInformation = (ULONG)dwExtraInfo;
#endif

    /*
     * This process is providing input so it gets the right to
     *  call SetForegroundWindow
     */
    gppiInputProvider = pti->ppi;

    KeyEvent.dwTime = dwTime;
    xxxProcessKeyEvent(&KeyEvent, dwExtraInfo, TRUE);

    return TRUE;
}


/*****************************************************************************\
*
*  _BlockInput()
*
*  This disables/enables input into USER via keyboard or mouse
*  If input is enabled and the caller
*  is disabling it, the caller gets the 'input cookie.'  This means two
*  things:
*      (a) Only the caller's thread can reenable input
*      (b) Only the caller's thread can fake input messages by calling
*          SendInput().
*
*  This guarantees a sequential uninterrupted input stream.
*
*  It can be used in conjunction with a journal playback hook however,
*  since USER still does some processing in *_event functions before
*  noticing a journal playback hook is around.
*
*  Note that the disabled state can be suspended, and will be, when the
*  fault dialog comes up.  ForceInputState() will save away the enabled
*  status, so input is cleared, then whack back the old stuff when done.
*  We do the same thing for capture, modality, blah blah.  This makes sure
*  that if somebody is hung, the end user can still type Ctrl+Alt+Del and
*  interact with the dialog.
*
\*****************************************************************************/
BOOL
_BlockInput(BOOL fBlockIt)
{
    PTHREADINFO ptiCurrent;

    ptiCurrent = PtiCurrent();

    /*
     * The calling thread must be on the active desktop and have journal
     * playback access to that desktop if it wants to block input.
     * (Unblocking is less restricted)
     */
    if (fBlockIt &&
            (ptiCurrent->rpdesk != grpdeskRitInput ||
            !RtlAreAllAccessesGranted(ptiCurrent->amdesk, DESKTOP_JOURNALPLAYBACK))) {

        RIPNTERR0(STATUS_ACCESS_DENIED, RIP_WARNING,
                  "BlockInput failed: Non active desktop or access denied");
        return FALSE;
    }
    UserAssert(!(ptiCurrent->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

    /*
     * If we are enabling input
     *      * Is it disabled?  No, then fail the call
     *      * Is it disabled but we aren't the dude in control?  Yes, then
     *              fail the call.
     * If we are disabling input
     *      * Is it enabled?  No, then fail the call
     *      * Set us up as the dude in control
     */

    if (fBlockIt) {
        /*
         * Is input blocked right now?
         */
        if (gptiBlockInput != NULL) {
            return FALSE;
        }

        /*
         * Is this thread exiting?  If so, fail the call now.  User's
         * cleanup code won't get a chance to whack this back if so.
         */
        if (ptiCurrent->TIF_flags & TIF_INCLEANUP) {
            return FALSE;
        }

        /*
         * Set blocking on.
         */
        gptiBlockInput = ptiCurrent;
    } else {
        /*
         * Fail if input is not blocked, or blocked by another thread
         */
        if (gptiBlockInput != ptiCurrent) {
            return FALSE;
        }

        /*
         * This thread was blocking input, so now clear the block.
         */
        gptiBlockInput = NULL;
    }

    return TRUE;
}


/**************************************************************************\
* xxxSendInput
*
* input injection
*
* History:
* 11-01-96 CLupu      Created.
\**************************************************************************/
UINT xxxSendInput(
   UINT    nInputs,
   LPINPUT pInputs)
{
    UINT    nEv;
    LPINPUT pEvent;
    BOOLEAN fCanDiscontinue = Is510Compat(PtiCurrent()->dwExpWinVer);

    for (nEv = 0, pEvent = pInputs; nEv < nInputs; nEv++) {

        switch (pEvent->type) {
        case INPUT_MOUSE:
            if (!xxxMouseEventDirect(
                        pEvent->mi.dx,
                        pEvent->mi.dy,
                        pEvent->mi.mouseData,
                        pEvent->mi.dwFlags,
                        pEvent->mi.time,
                        pEvent->mi.dwExtraInfo) &&
                    fCanDiscontinue) {
                /*
                 * Note: the error code should have been assigned in
                 * xxx.*EventDirect routines, so we should just
                 * bail out.
                 */
                RIPMSG0(RIP_WARNING, "xxxMouseEventDirect: failed");
                goto discontinue;
            }
            break;

        case INPUT_KEYBOARD:
            if ((pEvent->ki.dwFlags & KEYEVENTF_UNICODE) &&
                    (pEvent->ki.wVk == 0) &&
                    ((pEvent->ki.dwFlags & ~(KEYEVENTF_KEYUP | KEYEVENTF_UNICODE)) == 0)) {
                if (!xxxInternalKeyEventDirect(
                            VK_PACKET,
                            pEvent->ki.wScan,   // actually a Unicode character
                            pEvent->ki.dwFlags,
                            pEvent->ki.time,
                            pEvent->ki.dwExtraInfo) &&
                        fCanDiscontinue) {
                    goto discontinue;
                }
            } else {
                if (!xxxInternalKeyEventDirect(
                            LOBYTE(pEvent->ki.wVk),
                            LOBYTE(pEvent->ki.wScan),
                            pEvent->ki.dwFlags,
                            pEvent->ki.time,
                            pEvent->ki.dwExtraInfo) &&
                        fCanDiscontinue) {
                    goto discontinue;
                }
            }
            break;

        case INPUT_HARDWARE:
            if (fCanDiscontinue) {
                /*
                 * Not supported on NT.
                 */
                RIPERR0(ERROR_CALL_NOT_IMPLEMENTED, RIP_WARNING, "xxxSendInput: INPUT_HARDWARE is for 9x only.");
                goto discontinue;
            }
            break;
        }

        pEvent++;
    }

discontinue:
    return nEv;
}

/**************************************************************************\
* _SetConsoleReserveKeys
*
* Sets the reserved keys field in the console's pti.
*
* History:
* 02-17-93 JimA         Created.
\**************************************************************************/

BOOL _SetConsoleReserveKeys(
    PWND pwnd,
    DWORD fsReserveKeys)
{
    GETPTI(pwnd)->fsReserveKeys = fsReserveKeys;
    return TRUE;
}

/**************************************************************************\
* _GetMouseMovePointsEx
*
* Gets the last nPoints mouse moves from the global buffer starting with
* ppt. Returns -1 if it doesn't find it. It uses the timestamp if it was
* provided to differentiate between mouse points with the same coordinates.
*
* History:
* 03-17-97 CLupu        Created.
\**************************************************************************/
int _GetMouseMovePointsEx(
    CONST MOUSEMOVEPOINT* ppt,
    MOUSEMOVEPOINT*       ccxpptBuf,
    UINT                  nPoints,
    DWORD                 resolution)
{
    UINT  uInd, uStart, nPointsRetrieved, i;
    BOOL  bFound = FALSE;
    int   x, y;
    DWORD resX, resY;

    /*
     * Search the point in the global buffer and get the first occurance.
     */
    uInd = uStart = PREVPOINT(gptInd);


    do {
        /*
         * The resolutions can be zero only if the buffer is still not full
         */
        if (HIWORD(gaptMouse[uInd].x) == 0 || HIWORD(gaptMouse[uInd].y) == 0) {
            break;
        }

        resX = (DWORD)HIWORD(gaptMouse[uInd].x) + 1;
        resY = (DWORD)HIWORD(gaptMouse[uInd].y) + 1;

        if ((int)resX != SYSMET(CXVIRTUALSCREEN)) {
            UserAssert(resX == 0x10000);
            x = LOWORD(gaptMouse[uInd].x) * SYSMET(CXVIRTUALSCREEN) / resX;
        } else {
            x = LOWORD(gaptMouse[uInd].x);
        }

        if ((int)resY != SYSMET(CYVIRTUALSCREEN)) {
            UserAssert(resY == 0x10000);
            y = LOWORD(gaptMouse[uInd].y) * SYSMET(CYVIRTUALSCREEN) / resY;
        } else {
            y = LOWORD(gaptMouse[uInd].y);
        }

        if (x == ppt->x && y == ppt->y) {
            /*
             * If the timestamp was provided check to see if it's the right
             * timestamp.
             */
            if (ppt->time != 0 && ppt->time != gaptMouse[uInd].time) {
                uInd = PREVPOINT(uInd);
                RIPMSG4(RIP_VERBOSE,
                        "GetMouseMovePointsEx: Found point (%x, %x) but timestamp %x diff from %x",
                        x, y, ppt->time, gaptMouse[uInd].time);
                continue;
            }

            bFound = TRUE;
            break;
        }
        uInd = PREVPOINT(uInd);
    } while (uInd != uStart);

    /*
     * The point might not be in the buffer anymore.
     */
    if (!bFound) {
        RIPERR2(ERROR_POINT_NOT_FOUND, RIP_VERBOSE,
                  "GetMouseMovePointsEx: point not found (%x, %x)", ppt->x, ppt->y);
        return -1;
    }

    /*
     * See how many points we can retrieve.
     */
    nPointsRetrieved = (uInd <= uStart ? uInd + MAX_MOUSEPOINTS - uStart : uInd - uStart);

    nPointsRetrieved = min(nPointsRetrieved, nPoints);

    /*
     * Copy the points to the app buffer.
     */
    try {
        for (i = 0; i < nPointsRetrieved; i++) {
            resX = (DWORD)HIWORD(gaptMouse[uInd].x) + 1;
            resY = (DWORD)HIWORD(gaptMouse[uInd].y) + 1;

            /*
             * If one of the resolutions is 0 then we're done.
             */
            if (HIWORD(gaptMouse[uInd].x) == 0 || HIWORD(gaptMouse[uInd].y) == 0) {
                break;
            }

            /*
             * LOWORD(gaptMouse[uInd].x) contains the x point on the scale
             * specified by HIWORD(gaptMouse[uInd].x).
             */
            if (resolution == GMMP_USE_HIGH_RESOLUTION_POINTS) {
                ccxpptBuf[i].x = (DWORD)LOWORD(gaptMouse[uInd].x) * 0xFFFF / (resX - 1);
                ccxpptBuf[i].y = (DWORD)LOWORD(gaptMouse[uInd].y) * 0xFFFF / (resY - 1);

            } else {
                UserAssert(resolution == GMMP_USE_DISPLAY_POINTS);

                ccxpptBuf[i].x = LOWORD(gaptMouse[uInd].x) * SYSMET(CXVIRTUALSCREEN) / resX;
                ccxpptBuf[i].y = LOWORD(gaptMouse[uInd].y) * SYSMET(CYVIRTUALSCREEN) / resY;
            }
            ccxpptBuf[i].time = gaptMouse[uInd].time;
            ccxpptBuf[i].dwExtraInfo = gaptMouse[uInd].dwExtraInfo;

            uInd = PREVPOINT(uInd);
        }
    } except(W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }

    return i;
}


/**************************************************************************\
* ProcessQueuedMouseEvents
*
* Process mouse events.
*
* History:
* 11-01-96 CLupu        Created.
\**************************************************************************/
VOID ProcessQueuedMouseEvents(
    VOID)
{
    MOUSEEVENT MouseEvent;
    static POINT ptCursorLast = {0,0};

    while (UnqueueMouseEvent(&MouseEvent)) {

        EnterCrit();

        // Setup to shutdown screen saver and exit video power down mode.
        if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
            // Call video driver here to exit power down mode.
            TAGMSG0(DBGTAG_Power, "Exit video power down mode");
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
        }
        glinp.dwFlags &= ~(LINP_INPUTTIMEOUTS | LINP_INPUTSOURCES);
        
        gpsi->dwLastRITEventTickCount = MouseEvent.time;
        if (!gbBlockSendInputResets || !MouseEvent.bInjected) {
	        glinp.timeLastInputMessage = MouseEvent.time;
        }
        
        if (gpsi->dwLastRITEventTickCount - gpsi->dwLastSystemRITEventTickCountUpdate > SYSTEM_RIT_EVENT_UPDATE_PERIOD) {
            SharedUserData->LastSystemRITEventTickCount = gpsi->dwLastRITEventTickCount;
            gpsi->dwLastSystemRITEventTickCountUpdate = gpsi->dwLastRITEventTickCount;
        }

        gpsi->bLastRITWasKeyboard = FALSE;

        gpsi->ptCursor = MouseEvent.ptPointer;

#ifdef GENERIC_INPUT
        if ((gpqForeground && TestRawInputMode(PtiMouseFromQ(gpqForeground), RawMouse))
#ifdef GI_SINK
            || IsMouseSinkPresent()
#endif
            ) {
            PostRawMouseInput(gpqForeground, MouseEvent.time, MouseEvent.hDevice, &MouseEvent.rawData);
        }
#endif

        if ((ptCursorLast.x != gpsi->ptCursor.x) ||
            (ptCursorLast.y != gpsi->ptCursor.y)) {

            /*
             * This mouse move ExtraInfo is global (as ptCursor
             * was) and is associated with the current ptCursor
             * position. ExtraInfo is sent from the driver - pen
             * win people use it.
             */
            gdwMouseMoveExtraInfo = MouseEvent.ExtraInfo;

            ptCursorLast = gpsi->ptCursor;

            /*
             * Wake up someone. xxxSetFMouseMoved() clears
             * dwMouseMoveExtraInfo, so we must then restore it.
             */
#ifdef GENERIC_INPUT
#ifdef GI_SINK
            if (IsMouseSinkPresent()) {
                PostRawMouseInput(gpqForeground, MouseEvent.time, MouseEvent.hDevice, &MouseEvent.rawData);
            }
#endif
            if (gpqForeground == NULL || !TestRawInputMode(PtiMouseFromQ(gpqForeground), NoLegacyMouse)) {
                zzzSetFMouseMoved();
            }
#else
            zzzSetFMouseMoved();
#endif

            gdwMouseMoveExtraInfo = MouseEvent.ExtraInfo;
        }

        if (MouseEvent.ButtonFlags != 0) {
            xxxDoButtonEvent(&MouseEvent);
        }

        LeaveCrit();
    }
}

/***************************************************************************\
* RawInputThread (RIT)
*
* This is the RIT.  It gets low-level/raw input from the device drivers
* and posts messages the appropriate queue.  It gets the input via APC
* calls requested by calling NtReadFile() for the keyboard and mouse
* drivers.  Basically it makes the first calls to Start*Read() and then
* sits in an NtWaitForSingleObject() loop which allows the APC calls to
* occur.
*
* All functions called exclusively on the RIT will have (RIT) next to
* the name in the header.
*
* History:
* 10-18-90 DavidPe      Created.
* 11-26-90 DavidPe      Rewrote to stop using POS layer.
\***************************************************************************/
#if DBG
DWORD gBlockDelay = 0;
DWORD gBlockSleep = 0;
#endif

VOID RawInputThread(
    PRIT_INIT pInitData)
{
    KPRIORITY      Priority;
    NTSTATUS       Status;
    UNICODE_STRING strRIT;
    PKEVENT        pEvent;
    UINT           NumberOfHandles = ID_NUMBER_HYDRA_REMOTE_HANDLES;
    PTERMINAL      pTerm;
    PMONITOR       pMonitorPrimary;
    HANDLE         hevtShutDown;
    static DWORD   nLastRetryReadInput = 0;

    /*
     * Session 0  Console session does not need the shutdown event
     */


    pTerm = pInitData->pTerm;

    /*
     * Initialize GDI accelerators.  Identify this thread as a server thread.
     */
    apObjects = UserAllocPoolNonPaged(NumberOfHandles * sizeof(PVOID), TAG_SYSTEM);

    gWaitBlockArray = UserAllocPoolNonPagedNS(NumberOfHandles * sizeof(KWAIT_BLOCK),
                                             TAG_SYSTEM);

    if (apObjects == NULL || gWaitBlockArray == NULL) {
        RIPMSG0(RIP_WARNING, "RIT failed to allocate memory");
        goto Exit;
    }

    RtlZeroMemory(apObjects, NumberOfHandles * sizeof(PVOID));

    /*
     * Set the priority of the RIT to maximum allowed.
     * LOW_REALTIME_PRIORITY - 1 is chosen so that the RIT
     * does not block the Mm Working set trimmer thread
     * in the memory starvation situation.
     */
#ifdef W2K_COMPAT_PRIORITY
    Priority = LOW_REALTIME_PRIORITY + 3;
#else
    Priority = LOW_REALTIME_PRIORITY - 1;
#endif

    ZwSetInformationThread(NtCurrentThread(),
                           ThreadPriority,
                           &Priority,
                           sizeof(KPRIORITY));

    RtlInitUnicodeString(&strRIT, L"WinSta0_RIT");

    /*
     * Create an event for signalling mouse/kbd attach/detach and device-change
     * notifications such as QueryRemove, RemoveCancelled etc.
     */
    aDeviceTemplate[DEVICE_TYPE_KEYBOARD].pkeHidChange =
            apObjects[ID_HIDCHANGE] =
            CreateKernelEvent(SynchronizationEvent, FALSE);
    aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange =
            CreateKernelEvent(SynchronizationEvent, FALSE);

#ifdef GENERIC_INPUT
    gpkeHidChange =
    apObjects[ID_TRUEHIDCHANGE] =
    aDeviceTemplate[DEVICE_TYPE_HID].pkeHidChange = CreateKernelEvent(SynchronizationEvent, FALSE);
#endif

    /*
     * Create an event for desktop threads to pass mouse input to RIT
     */
    apObjects[ID_MOUSE] = CreateKernelEvent(SynchronizationEvent, FALSE);
    gpkeMouseData = apObjects[ID_MOUSE];

    if (aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange == NULL ||
            apObjects[ID_HIDCHANGE] == NULL ||
            gpkeMouseData == NULL
#ifdef GENERIC_INPUT
            || gpkeHidChange == NULL
#endif
        ) {
        RIPMSG0(RIP_WARNING, "RIT failed to create a required input event");
        goto Exit;
    }

    /*
     * Initialize keyboard device driver.
     */
    EnterCrit();
    InitKeyboard();
    InitMice();
    LeaveCrit();

    Status = InitSystemThread(&strRIT);

    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "RIT failed InitSystemThread");
        goto Exit;
    }

    UserAssert(gpepCSRSS != NULL);

    /*
     * Allow the system to read the screen
     */
    ((PW32PROCESS)PsGetProcessWin32Process(gpepCSRSS))->W32PF_Flags |= (W32PF_READSCREENACCESSGRANTED|W32PF_IOWINSTA);

    /*
     * Initialize the cursor clipping rectangle to the screen rectangle.
     */
    UserAssert(gpDispInfo != NULL);
    grcCursorClip = gpDispInfo->rcScreen;

    /*
     * Initialize gpsi->ptCursor and gptCursorAsync
     */
    pMonitorPrimary = GetPrimaryMonitor();

    UserAssert(gpsi != NULL);

    gpsi->ptCursor.x = pMonitorPrimary->rcMonitor.right / 2;
    gpsi->ptCursor.y = pMonitorPrimary->rcMonitor.bottom / 2;
    gptCursorAsync = gpsi->ptCursor;

    /*
     * The hung redraw list should already be set to NULL by the compiler,
     * linker & loader since it is an uninitialized global variable. Memory will
     * be allocated the first time a pwnd is added to this list (hungapp.c)
     */
    UserAssert(gpvwplHungRedraw == NULL);

    /*
     * Initialize the pre-defined hotkeys
     */
    EnterCrit();
    _RegisterHotKey(PWND_INPUTOWNER, IDHOT_WINDOWS, MOD_WIN, VK_NONE);
    SetDebugHotKeys();
    LeaveCrit();

    /*
     * Create a timer for timers.
     */
    gptmrMaster = UserAllocPoolNonPagedNS(sizeof(KTIMER),
                                        TAG_SYSTEM);
    if (gptmrMaster == NULL) {
        RIPMSG0(RIP_WARNING, "RIT failed to create gptmrMaster");
        goto Exit;
    }

    KeInitializeTimer(gptmrMaster);
    apObjects[ID_TIMER] = gptmrMaster;

    /*
     * Create an event for mouse device reads to signal the desktop thread to
     * move the pointer and QueueMouseEvent().
     * We should do this *before* we have any devices.
     */
    UserAssert(gpDeviceInfoList == NULL);


    if (!gbRemoteSession) {
        gptmrWD = UserAllocPoolNonPagedNS(sizeof(KTIMER), TAG_SYSTEM);

        if (gptmrWD == NULL) {
            Status = STATUS_NO_MEMORY;
            RIPMSG0(RIP_WARNING, "RemoteConnect failed to create gptmrWD");
            goto Exit;
        }
        KeInitializeTimerEx(gptmrWD, SynchronizationTimer);
    }


    /*
     * At this point, the WD timer must already have been initialized by RemoteConnect
     */



    UserAssert(gptmrWD != NULL);
    apObjects[ID_WDTIMER] = gptmrWD;

    if (IsRemoteConnection() ) {
        BOOL   fSuccess=TRUE;
        fSuccess &= !!HDXDrvEscape(gpDispInfo->hDev,
                                   ESC_SET_WD_TIMEROBJ,
                                   (PVOID)gptmrWD,
                                   sizeof(gptmrWD));

        if (!fSuccess) {
            Status = STATUS_UNSUCCESSFUL;
            RIPMSG0(RIP_WARNING, "RemoteConnect failed to pass gptmrWD to display driver");
            goto Exit;
        }
    }

    if (IsRemoteConnection()) {

        UNICODE_STRING    ustrName;
        BOOL              fSuccess = TRUE;



        RtlInitUnicodeString(&ustrName, NULL);

        /*
         * Pass a pointer to the timer to the WD via the display driver
         */
        EnterCrit();

        fSuccess &= !!CreateDeviceInfo(DEVICE_TYPE_MOUSE, &ustrName, 0);
        fSuccess &= !!CreateDeviceInfo(DEVICE_TYPE_KEYBOARD, &ustrName, 0);

        LeaveCrit();

        if (!fSuccess) {
            RIPMSG0(RIP_WARNING,
                    "RIT failed HDXDrvEscape or the creation of input devices");
            goto Exit;
        }
    } else {
        EnterCrit();

        /*
         * Register for Plug and Play devices.
         * If any PnP devices are already attached, these will be opened and
         * we will start reading them at this time.
         */
        xxxRegisterForDeviceClassNotifications();

        LeaveCrit();
    }

    if (gbRemoteSession) {
        WCHAR             szName[MAX_SESSION_PATH];
        UNICODE_STRING    ustrName;
        OBJECT_ATTRIBUTES obja;
        /*
         * Create the shutdown event. This event will be signaled
         * from W32WinStationTerminate.
         * This is a named event opend by CSR to signal that win32k should
         * go away. It's used in ntuser\server\api.c
         */
        swprintf(szName, L"\\Sessions\\%ld\\BaseNamedObjects\\EventShutDownCSRSS",
                 gSessionId);
        RtlInitUnicodeString(&ustrName, szName);

        InitializeObjectAttributes(&obja,
                                   &ustrName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = ZwCreateEvent(&hevtShutDown,
                               EVENT_ALL_ACCESS,
                               &obja,
                               SynchronizationEvent,
                               FALSE);

        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "RIT failed to create EventShutDownCSRSS");
            goto Exit;
        }

        ObReferenceObjectByHandle(hevtShutDown,
                                  EVENT_ALL_ACCESS,
                                  *ExEventObjectType,
                                  KernelMode,
                                  &apObjects[ID_SHUTDOWN],
                                  NULL);
    } else {

        hevtShutDown = NULL;

        Status = PoRequestShutdownEvent(&apObjects[ID_SHUTDOWN]);
        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "RIT failed to get shutdown event");
            goto Exit;
        }
    }

    /*
     * Get the rit-thread.
     */
    gptiRit = PtiCurrentShared();

    HYDRA_HINT(HH_RITCREATED);

    /*
     * Don't allow this thread to get involved with journal synchronization.
     */
    gptiRit->TIF_flags |= TIF_DONTJOURNALATTACH;

    /*
     * Also wait on our input event so the cool switch window can
     * receive messages.
     */
    apObjects[ID_INPUT] = gptiRit->pEventQueueServer;

    /*
     * Signal that the rit has been initialized
     */
    KeSetEvent(pInitData->pRitReadyEvent, EVENT_INCREMENT, FALSE);

    /*
     * Since this is a SYSTEM-THREAD, we should set the pwinsta
     * pointer in the SystemInfoThread to assure that if any
     * paints occur from the input-thread, we can process them
     * in DoPaint().
     *
     * Set the winsta after the first desktop is created.
     */
    gptiRit->pwinsta = NULL;

    pEvent = pTerm->pEventInputReady;

    /*
     * Wait until the first desktop is created.
     */
    ObReferenceObjectByPointer(pEvent,
                               EVENT_ALL_ACCESS,
                               *ExEventObjectType,
                               KernelMode);

    KeWaitForSingleObject(pEvent, WrUserRequest, KernelMode, FALSE, NULL);
    ObDereferenceObject(pEvent);

    /*
     * Switch to the first desktop if no switch has been
     * performed.
     */
    EnterCrit();

    if (gptiRit->rpdesk == NULL) {
        UserVerify(xxxSwitchDesktop(gptiRit->pwinsta, gptiRit->pwinsta->rpdeskList, 0));
    }
#ifdef BUG365290
    /*
     * The io desktop thread is supposed to be created at this point.
     * The xxxSwitchDesktop call is expected to set the io desktop thread to run in grpdeskritinput
     */
    if ((pTerm->ptiDesktop == NULL) || (pTerm->ptiDesktop->rpdesk != grpdeskRitInput)) {
        FRE_RIPMSG0(RIP_ERROR, "RawInputThread: Desktop thread not running on grpdeskRitInput");
    }
#endif // BUG365290

    /*
     * Create a timer for hung app detection/redrawing.
     */
    StartTimers();

    LeaveCrit();

    /*
     * Go into a wait loop so we can process input events and APCs as
     * they occur.
     */
    while (TRUE) {

        CheckCritOut();

        Status = KeWaitForMultipleObjects(NumberOfHandles,
                                          apObjects,
                                          WaitAny,
                                          WrUserRequest,
                                          KernelMode,
                                          TRUE,
                                          NULL,
                                          gWaitBlockArray);

        UserAssert(NT_SUCCESS(Status));

        if (gdwUpdateKeyboard != 0) {
            /*
             * Here's our opportunity to process pending IOCTLs for the kbds:
             * These are asynchronous IOCTLS, so be sure any buffers passed
             * in to ZwDeviceIoControlFile are not in the stack!
             * Using gdwUpdateKeyboard to tell the RIT to issue these IOCTLS
             * renders the action asynchronous (delayed until next apObjects
             * event), but the IOCTL was asynch anyway
             */
            PDEVICEINFO pDeviceInfo;
            EnterDeviceInfoListCrit();
            for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
                if ((pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) && (pDeviceInfo->handle)) {
                    if (gdwUpdateKeyboard & UPDATE_KBD_TYPEMATIC) {
                        ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                                &giosbKbdControl, IOCTL_KEYBOARD_SET_TYPEMATIC,
                                (PVOID)&gktp, sizeof(gktp), NULL, 0);
                    }
                    if (gdwUpdateKeyboard & UPDATE_KBD_LEDS) {
                        ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                                &giosbKbdControl, IOCTL_KEYBOARD_SET_INDICATORS,
                                (PVOID)&gklp, sizeof(gklp), NULL, 0);
                    }
                }
            }
            LeaveDeviceInfoListCrit();
            if ((gdwUpdateKeyboard & UPDATE_KBD_LEDS) && gfRemotingConsole) {
                    ZwDeviceIoControlFile(ghConsoleShadowKeyboardChannel, NULL, NULL, NULL,
                            &giosbKbdControl, IOCTL_KEYBOARD_SET_INDICATORS,
                            (PVOID)&gklp, sizeof(gklp), NULL, 0);
            }
            gdwUpdateKeyboard &= ~(UPDATE_KBD_TYPEMATIC | UPDATE_KBD_LEDS);
        }

        if (Status == ID_MOUSE) {
            /*
             * A desktop thread got some Mouse input for us. Process it.
             */
            ProcessQueuedMouseEvents();

        } else if (Status == ID_HIDCHANGE) {
            TAGMSG0(DBGTAG_PNP | RIP_THERESMORE, "RIT wakes for HID Change");
            EnterCrit();
            ProcessDeviceChanges(DEVICE_TYPE_KEYBOARD);
            LeaveCrit();
        }
#ifdef GENERIC_INPUT
        else if (Status == ID_TRUEHIDCHANGE) {
            TAGMSG0(DBGTAG_PNP | RIP_THERESMORE, "RIT wakes for True HID Change");
            EnterCrit();
            ProcessDeviceChanges(DEVICE_TYPE_HID);
            LeaveCrit();
        }
#endif
        else if (Status == ID_SHUTDOWN) {

            InitiateWin32kCleanup();

            if (hevtShutDown) {
                ZwClose(hevtShutDown);
            }

            break;

        } else if (Status == ID_WDTIMER) {
            //LARGE_INTEGER liTemp;

            EnterCrit();


            /*
             * Call the TShare display driver to flush the frame buffer
             */

            if (IsRemoteConnection()) {
                if (!HDXDrvEscape(gpDispInfo->hDev, ESC_TIMEROBJ_SIGNALED, NULL, 0)) {
                    UserAssert(FALSE);
                }
            } else {
                if (gfRemotingConsole && gConsoleShadowhDev != NULL) {
                    ASSERT(gConsoleShadowhDev != NULL);
                    if (!HDXDrvEscape(gConsoleShadowhDev, ESC_TIMEROBJ_SIGNALED, NULL, 0)) {
                        UserAssert(FALSE);
                    }
                }
            }

            LeaveCrit();

        } else {
            /*
             * If the master timer has expired, then process the timer
             * list. Otherwise, an APC caused the raw input thread to be
             * awakened.
             */
            if (Status == ID_TIMER) {
                TimersProc();
                /*
                 * If an input degvice read failed due to insufficient resources,
                 * we retry by signalling the proper thread: ProcessDeviceChanges
                 * will call RetryReadInput().
                 */
                if (gnRetryReadInput != nLastRetryReadInput) {
                    nLastRetryReadInput = gnRetryReadInput;
                    KeSetEvent(aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange, EVENT_INCREMENT, FALSE);
                    KeSetEvent(aDeviceTemplate[DEVICE_TYPE_KEYBOARD].pkeHidChange, EVENT_INCREMENT, FALSE);
                }
            }

#if DBG
            /*
             * In the debugger set gBlockSleep to n:
             * The RIT will sleep n millicseconds, then n timer ticks later
             * will sleep n milliseconds again.
             */
            if (gBlockDelay) {
                gBlockDelay--;
            } else if ((gBlockDelay == 0) && (gBlockSleep != 0)) {
                UserSleep(gBlockSleep);
                gBlockDelay = 100 * gBlockSleep;
            }
#endif

            /*
             * if in cool task switcher window, dispose of the messages
             * on the queue
             */
            if (gspwndAltTab != NULL) {
                EnterCrit();
                xxxReceiveMessages(gptiRit);
                LeaveCrit();
            }
        }
    }

    return;

Exit:

    UserAssert(gptiRit == NULL);

    /*
     * Signal that the rit has been initialized
     */
    KeSetEvent(pInitData->pRitReadyEvent, EVENT_INCREMENT, FALSE);

    RIPMSG0(RIP_WARNING, "RIT initialization failure");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\pool.c ===
/**************************** Module Header ********************************\
* Module Name: pool.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Pool reallocation routines
*
* History:
* 03-04-95 JimA       Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL gdwPoolFlags;
DWORD gSessionPoolMask;

#ifdef POOL_INSTR

    /*
     * Globals used by RecordStackTrace
     */

    PVOID     gRecordedStackTrace[RECORD_STACK_TRACE_SIZE];
    PEPROCESS gpepRecorded;
    PETHREAD  gpetRecorded;


    DWORD gdwAllocFailIndex;        // the index of the allocation that's
                                    // going to fail

    DWORD gdwAllocsToFail = 1;      // how many allocs to fail

    DWORD gdwFreeRecords;

    /*
     * Targeted tag failures
     */
    LPDWORD gparrTagsToFail;
    SIZE_T  gdwTagsToFailCount;

    /*
     * Support to keep records of failed pool allocations
     */
    DWORD gdwFailRecords;
    DWORD gdwFailRecordCrtIndex;
    DWORD gdwFailRecordTotalFailures;

    PPOOLRECORD gparrFailRecord;

    /*
     * Support to keep records of pool free
     */
    DWORD gdwFreeRecords;
    DWORD gdwFreeRecordCrtIndex;
    DWORD gdwFreeRecordTotalFrees;

    PPOOLRECORD gparrFreeRecord;

    FAST_MUTEX* gpAllocFastMutex;   // mutex to syncronize pool allocations

    Win32AllocStats gAllocList;

    CONST char gszTailAlloc[] = "Win32kAlloc";

#define USESESSION(dwFlags) (((dwFlags & DAP_NONSESSION) != 0) ? 0 : gSessionPoolMask)

#endif // POOL_INSTR



PVOID Win32AllocPoolWithTagZInit(SIZE_T uBytes, ULONG uTag)
{
    PVOID   pv;

    pv = Win32AllocPool(uBytes, uTag);
    if (pv) {
        RtlZeroMemory(pv, uBytes);
    }

    return pv;
}

PVOID Win32AllocPoolWithQuotaTagZInit(SIZE_T uBytes, ULONG uTag)
{
    PVOID   pv;

    pv = Win32AllocPoolWithQuota(uBytes, uTag);
    if (pv) {
        RtlZeroMemory(pv, uBytes);
    }

    return pv;
}

PVOID UserReAllocPoolWithTag(
    PVOID pSrc,
    SIZE_T uBytesSrc,
    SIZE_T uBytes,
    ULONG iTag)
{
    PVOID pDest;

    pDest = UserAllocPool(uBytes, iTag);
    if (pDest != NULL) {

        /*
         * If the block is shrinking, don't copy too many bytes.
         */
        if (uBytesSrc > uBytes) {
            uBytesSrc = uBytes;
        }

        RtlCopyMemory(pDest, pSrc, uBytesSrc);

        UserFreePool(pSrc);
    }

    return pDest;
}

PVOID UserReAllocPoolWithQuotaTag(
    PVOID pSrc,
    SIZE_T uBytesSrc,
    SIZE_T uBytes,
    ULONG iTag)
{
    PVOID pDest;

    pDest = UserAllocPoolWithQuota(uBytes, iTag);
    if (pDest != NULL) {

        /*
         * If the block is shrinking, don't copy too many bytes.
         */
        if (uBytesSrc > uBytes)
            uBytesSrc = uBytes;

        RtlCopyMemory(pDest, pSrc, uBytesSrc);

        UserFreePool(pSrc);
    }

    return pDest;
}

/*
 * Allocation routines for rtl functions
 */

PVOID UserRtlAllocMem(
    SIZE_T uBytes)
{
    return UserAllocPool(uBytes, TAG_RTL);
}

VOID UserRtlFreeMem(
    PVOID pMem)
{
    UserFreePool(pMem);
}

#ifdef POOL_INSTR

VOID RecordStackTrace(
    VOID)
{
    RtlZeroMemory(gRecordedStackTrace, RECORD_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(gRecordedStackTrace, RECORD_STACK_TRACE_SIZE, 0);

    gpepRecorded = PsGetCurrentProcess();
    gpetRecorded = PsGetCurrentThread();
}

/***************************************************************************\
* RecordFailAllocation
*
* Records failed allocations
*
* 3-22-99 CLupu      Created.
\***************************************************************************/
VOID RecordFailAllocation(
    ULONG  tag,
    SIZE_T size)
{
    UserAssert(gdwPoolFlags & POOL_KEEP_FAIL_RECORD);

    gparrFailRecord[gdwFailRecordCrtIndex].ExtraData = LongToPtr( tag );
    gparrFailRecord[gdwFailRecordCrtIndex].size = size;

    gdwFailRecordTotalFailures++;

    RtlZeroMemory(gparrFailRecord[gdwFailRecordCrtIndex].trace,
                  RECORD_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(gparrFailRecord[gdwFailRecordCrtIndex].trace,
                      RECORD_STACK_TRACE_SIZE,
                      0);

    gdwFailRecordCrtIndex++;

    if (gdwFailRecordCrtIndex >= gdwFailRecords) {
        gdwFailRecordCrtIndex = 0;
    }
}

/***************************************************************************\
* RecordFreePool
*
* Records free pool
*
* 3-22-99 CLupu      Created.
\***************************************************************************/
VOID RecordFreePool(
    PVOID  p,
    SIZE_T size)
{
    UserAssert(gdwPoolFlags & POOL_KEEP_FREE_RECORD);

    gparrFreeRecord[gdwFreeRecordCrtIndex].ExtraData = p;
    gparrFreeRecord[gdwFreeRecordCrtIndex].size = size;

    gdwFreeRecordTotalFrees++;

    RtlZeroMemory(gparrFreeRecord[gdwFreeRecordCrtIndex].trace,
                  RECORD_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(gparrFreeRecord[gdwFreeRecordCrtIndex].trace,
                      RECORD_STACK_TRACE_SIZE,
                      0);

    gdwFreeRecordCrtIndex++;

    if (gdwFreeRecordCrtIndex >= gdwFreeRecords) {
        gdwFreeRecordCrtIndex = 0;
    }
}

/***************************************************************************\
* HeavyAllocPool
*
* This will make UserAllocPool to fail if we do not provide enough memory
* for the specified tag.
*
* 12-02-96 CLupu      Created.
\***************************************************************************/
PVOID HeavyAllocPool(
    SIZE_T uBytes,
    ULONG  tag,
    DWORD  dwFlags)
{
    DWORD*         p;
    PWin32PoolHead ph;

    /*
     * Make instrumentations faster for the main session if POOL_ONLY_HEAVY_REMOTE
     * is used
     */
    if (!(gdwPoolFlags & POOL_HEAVY_ALLOCS)) {
        if (dwFlags & DAP_USEQUOTA) {
            if (dwFlags & DAP_NONPAGEDPOOL) {
                p = ExAllocatePoolWithQuotaTag(USESESSION(dwFlags) | NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                               uBytes,
                                               tag);
            } else {
                p = ExAllocatePoolWithQuotaTag(
                                       gSessionPoolMask | PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                       uBytes,
                                       tag);
            }
        } else {
            if (dwFlags & DAP_NONPAGEDPOOL) {
                p = ExAllocatePoolWithTag(USESESSION(dwFlags) | NonPagedPool, uBytes, tag);
            } else {
                p = ExAllocatePoolWithTag(gSessionPoolMask | PagedPool, uBytes, tag);
            }
        }

        if (p != NULL && (dwFlags & DAP_ZEROINIT)) {
            RtlZeroMemory(p, uBytes);
        }

        return p;
    }

    /*
     * Check for overflow
     */
    if (uBytes >= MAXULONG - sizeof(Win32PoolHead) - sizeof(gszTailAlloc)) {

        if (gdwPoolFlags & POOL_KEEP_FAIL_RECORD) {
            RecordFailAllocation(tag, 0);
        }
        return NULL;
    }

    /*
     * Acquire the mutex when we play with the list of allocations
     */
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpAllocFastMutex);

#ifdef POOL_INSTR_API
    /*
     * Fail the allocation if the flag is set
     * Don't fail allocations that will certainly get us to bugchecking in DBG (i.e. GLOBALTHREADLOCK)
     */
    if (gdwPoolFlags & POOL_FAIL_ALLOCS
#if DBG
        && (tag != TAG_GLOBALTHREADLOCK)
#endif // DBG
        ) {


        SIZE_T dwInd;

        for (dwInd = 0; dwInd < gdwTagsToFailCount; dwInd++) {
            if (tag == gparrTagsToFail[dwInd]) {
                break;
            }
        }

        if (dwInd < gdwTagsToFailCount) {
            if (gdwPoolFlags & POOL_KEEP_FAIL_RECORD) {
                RecordFailAllocation(tag, uBytes);
            }

            RIPMSG0(RIP_WARNING, "Pool allocation failed because of global restriction");
            p = NULL;
            goto exit;
        }
    }
#endif // POOL_INSTR_API

#if DBG
    if ((gdwPoolFlags & POOL_FAIL_BY_INDEX) && (tag != TAG_GLOBALTHREADLOCK)) {

        /*
         * Count the calls to HeavyAllocPool
         */
        gdwAllocCrt++;

        if (gdwAllocCrt >= gdwAllocFailIndex &&
            gdwAllocCrt < gdwAllocFailIndex + gdwAllocsToFail) {

            RecordStackTrace();

            KdPrint(("\n--------------------------------------------------\n"));
            KdPrint((
                    "\nPool allocation %d failed because of registry settings",
                    gdwAllocCrt));
            KdPrint(("\n--------------------------------------------------\n\n"));

            if (gdwPoolFlags & POOL_KEEP_FAIL_RECORD) {
                RecordFailAllocation(tag, uBytes);
            }
            p = NULL;
            goto exit;
        }
    }
#endif // DBG

    /*
     * Reserve space for the header
     */
    uBytes += sizeof(Win32PoolHead);

    if (gdwPoolFlags & POOL_TAIL_CHECK) {
        uBytes += sizeof(gszTailAlloc);
    }

    if (dwFlags & DAP_USEQUOTA) {
        if (dwFlags & DAP_NONPAGEDPOOL) {
            p = ExAllocatePoolWithQuotaTag(USESESSION(dwFlags) | NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                           uBytes,
                                           tag);
        } else {
            p = ExAllocatePoolWithQuotaTag(
                                   gSessionPoolMask | PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                   uBytes,
                                   tag);
        }
    } else {
        if (dwFlags & DAP_NONPAGEDPOOL) {
            p = ExAllocatePoolWithTag(USESESSION(dwFlags)| NonPagedPool, uBytes, tag);
        } else {
            p = ExAllocatePoolWithTag(gSessionPoolMask | PagedPool, uBytes, tag);
        }
    }

    /*
     * Return if ExAllocate... failed.
     */
    if (p == NULL) {

        if (gdwPoolFlags & POOL_KEEP_FAIL_RECORD) {

            uBytes -= sizeof(Win32PoolHead);

            if (gdwPoolFlags & POOL_TAIL_CHECK) {
                uBytes -= sizeof(gszTailAlloc);
            }

            RecordFailAllocation(tag, uBytes);
        }

        goto exit;
    }

    uBytes -= sizeof(Win32PoolHead);

    if (gdwPoolFlags & POOL_TAIL_CHECK) {
        uBytes -= sizeof(gszTailAlloc);

        RtlCopyMemory(((BYTE*)p) + uBytes, gszTailAlloc, sizeof(gszTailAlloc));
    }

    /*
     * get the pointer to the header
     */
    ph = (PWin32PoolHead)p;

    p += (sizeof(Win32PoolHead) / sizeof(DWORD));

    /*
     * Update the global allocations info.
     */
    gAllocList.dwCrtMem += uBytes;

    if (gAllocList.dwMaxMem < gAllocList.dwCrtMem) {
        gAllocList.dwMaxMem = gAllocList.dwCrtMem;
    }

    (gAllocList.dwCrtAlloc)++;

    if (gAllocList.dwMaxAlloc < gAllocList.dwCrtAlloc) {
        gAllocList.dwMaxAlloc = gAllocList.dwCrtAlloc;
    }

    /*
     * Grab the stack traces if the flags say so
     */
    if (gdwPoolFlags & POOL_CAPTURE_STACK) {
        ph->pTrace = ExAllocatePoolWithTag(gSessionPoolMask | PagedPool,
                                           POOL_ALLOC_TRACE_SIZE * sizeof(PVOID),
                                           TAG_STACK);

        if (ph->pTrace != NULL) {
            RtlZeroMemory(ph->pTrace, POOL_ALLOC_TRACE_SIZE * sizeof(PVOID));
            RtlWalkFrameChain(ph->pTrace, POOL_ALLOC_TRACE_SIZE, 0);
        }
    } else {
        ph->pTrace = NULL;
    }

    /*
     * Save the info in the header and return the pointer after the header.
     */
    ph->size = uBytes;

    /*
     * now, link it into the list for this tag (if any)
     */
    ph->pPrev = NULL;
    ph->pNext = gAllocList.pHead;

    if (gAllocList.pHead != NULL) {
        gAllocList.pHead->pPrev = ph;
    }

    gAllocList.pHead = ph;

    if (dwFlags & DAP_ZEROINIT) {
        RtlZeroMemory(p, uBytes);
    }

exit:
    /*
     * Release the mutex
     */
    ExReleaseFastMutexUnsafe(gpAllocFastMutex);
    KeLeaveCriticalRegion();

    return p;
}

/***************************************************************************\
* HeavyFreePool
*
* 12-02-96 CLupu      Created.
\***************************************************************************/
VOID HeavyFreePool(
    PVOID p)
{
    SIZE_T         uBytes;
    PWin32PoolHead ph;

    /*
     * If POOL_HEAVY_ALLOCS is not defined
     * then the pointer is what we allocated
     */
    if (!(gdwPoolFlags & POOL_HEAVY_ALLOCS)) {
        ExFreePool(p);
        return;
    }

    /*
     * Acquire the mutex when we play with the list of allocations
     */
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpAllocFastMutex);

    ph = (PWin32PoolHead)((DWORD*)p - (sizeof(Win32PoolHead) / sizeof(DWORD)));

    uBytes = ph->size;

    /*
     * Check the tail
     */
    if (gdwPoolFlags & POOL_TAIL_CHECK) {
        if (!RtlEqualMemory((BYTE*)p + uBytes, gszTailAlloc, sizeof(gszTailAlloc))) {
            RIPMSG1(RIP_ERROR, "POOL CORRUPTION for %#p", p);
        }
    }

    gAllocList.dwCrtMem -= uBytes;

    UserAssert(gAllocList.dwCrtAlloc > 0);

    (gAllocList.dwCrtAlloc)--;

    /*
     * now, remove it from the linked list
     */
    if (ph->pPrev == NULL) {
        if (ph->pNext == NULL) {

            UserAssert(gAllocList.dwCrtAlloc == 0);

            gAllocList.pHead = NULL;
        } else {
            ph->pNext->pPrev = NULL;
            gAllocList.pHead = ph->pNext;
        }
    } else {
        ph->pPrev->pNext = ph->pNext;
        if (ph->pNext != NULL) {
            ph->pNext->pPrev = ph->pPrev;
        }
    }

    /*
     * Free the stack traces
     */
    if (ph->pTrace != NULL) {
        ExFreePool(ph->pTrace);
    }

    if (gdwPoolFlags & POOL_KEEP_FREE_RECORD) {
        RecordFreePool(ph, ph->size);
    }

    ExFreePool(ph);

    /*
     * Release the mutex
     */
    ExReleaseFastMutexUnsafe(gpAllocFastMutex);
    KeLeaveCriticalRegion();
}

/***************************************************************************\
* CleanupPoolAllocations
*
* 12-02-96 CLupu      Created.
\***************************************************************************/
VOID CleanupPoolAllocations(
    VOID)
{
    PWin32PoolHead pHead;
    PWin32PoolHead pNext;

    if (gAllocList.dwCrtAlloc != 0) {

        if ((gdwPoolFlags & POOL_BREAK_FOR_LEAKS) &&
            KdDebuggerEnabled) {

            /*
             * The below is as is because it is intended to work on both
             * free and checked builds.
             */
            #undef DbgPrint
            DbgPrint("\n------------------------\n"
                     "There is still pool memory not freed in win32k.sys !!!\n"
                     "Use !dpa -vs to dump it\n"
                     "-------------------------\n");
            DbgBreakPoint();
        }

        pHead = gAllocList.pHead;

        while (pHead != NULL) {

            pNext = pHead->pNext;

            UserFreePool(pHead + 1);

            pHead = pNext;
        }
    }
}

/***************************************************************************\
* CleanUpPoolLimitations
*
\***************************************************************************/
VOID CleanUpPoolLimitations(
    VOID)
{
    if (gpAllocFastMutex != NULL) {
        ExFreePool(gpAllocFastMutex);
        gpAllocFastMutex = NULL;
    }

    if (gparrFailRecord != NULL) {
        ExFreePool(gparrFailRecord);
        gparrFailRecord = NULL;
    }

    if (gparrFreeRecord != NULL) {
        ExFreePool(gparrFreeRecord);
        gparrFreeRecord = NULL;
    }

    if (gparrTagsToFail != NULL) {
        ExFreePool(gparrTagsToFail);
        gparrTagsToFail = NULL;
    }

}

/***************************************************************************\
* InitPoolLimitations
*
* 12-02-96 CLupu      Created.
\***************************************************************************/
NTSTATUS InitPoolLimitations(
    VOID)
{
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              hkey;
    NTSTATUS            Status;
    WCHAR               achKeyName[512];
    WCHAR               achKeyValue[512];
    DWORD               dwData;
    ULONG               ucb;

    /*
     * Initialize a critical section structure that will be used to protect
     * all the HeavyAllocPool and HeavyFreePool calls
     */
    gpAllocFastMutex = ExAllocatePoolWithTag(NonPagedPool,
                                             sizeof(FAST_MUTEX),
                                             TAG_DEBUG);

    if (gpAllocFastMutex == NULL) {
        RIPMSG0(RIP_WARNING, "InitPoolLimitations failed to allocate mutex");
        return STATUS_NO_MEMORY;
    }

    ExInitializeFastMutex(gpAllocFastMutex);

    /*
     * Default settings
     */

    if (SharedUserData->NtProductType != VER_NT_WORKSTATION) {

       gSessionPoolMask = SESSION_POOL_MASK;

       if (gbRemoteSession) {
           gdwPoolFlags = POOL_HEAVY_ALLOCS;

   #if DBG
           gdwPoolFlags |= (POOL_CAPTURE_STACK | POOL_BREAK_FOR_LEAKS);
   #endif // DBG
       }
    } else {
        //
        // For  TS on workstation, allocate out of global pool.
        //
        gSessionPoolMask = 0;
#if DBG

        if (gbRemoteSession) {
            gdwPoolFlags = (POOL_HEAVY_ALLOCS| POOL_CAPTURE_STACK | POOL_BREAK_FOR_LEAKS);
        }
#else
       //
       // For retail TS on workstation, disable pool tracking
       //

       gdwPoolFlags = 0;
#endif
    }

    /*
     * Open the key containing the limits.
     */
    RtlInitUnicodeString(
            &UnicodeString,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\SubSystems\\Pool");

    InitializeObjectAttributes(
            &ObjectAttributes, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = ZwOpenKey(&hkey, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {

#if DBG
        /*
         * More default settings if the Pool key doesn't exist
         */
        if (gbRemoteSession) {

            gparrFailRecord = ExAllocatePoolWithTag(PagedPool,
                                                    32 * sizeof(POOLRECORD),
                                                    TAG_DEBUG);

            if (gparrFailRecord != NULL) {
                gdwFailRecords = 32;
                gdwPoolFlags |= POOL_KEEP_FAIL_RECORD;
            }

            gparrFreeRecord = ExAllocatePoolWithTag(PagedPool,
                                                    32 * sizeof(POOLRECORD),
                                                    TAG_DEBUG);

            if (gparrFreeRecord != NULL) {
                gdwFreeRecords = 32;
                gdwPoolFlags |= POOL_KEEP_FREE_RECORD;
            }
        }
#endif // DBG

        return STATUS_SUCCESS;
    }

    if (gbRemoteSession) {

        /*
         * Break in the debugger for memory leaks ?
         */
        RtlInitUnicodeString(&UnicodeString, L"BreakForPoolLeaks");

        Status = ZwQueryValueKey(
                hkey,
                &UnicodeString,
                KeyValuePartialInformation,
                &achKeyValue,
                sizeof(achKeyValue),
                &ucb);

        if (NT_SUCCESS(Status) &&
                ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

            dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

            if (dwData != 0) {
                gdwPoolFlags |= POOL_BREAK_FOR_LEAKS;
            } else {
                gdwPoolFlags &= ~POOL_BREAK_FOR_LEAKS;
            }
        }

        /*
         * Heavy allocs/frees for remote sessions ?
         */
        RtlInitUnicodeString(&UnicodeString, L"HeavyRemoteSession");

        Status = ZwQueryValueKey(
                hkey,
                &UnicodeString,
                KeyValuePartialInformation,
                &achKeyValue,
                sizeof(achKeyValue),
                &ucb);

        if (NT_SUCCESS(Status) &&
                ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

            dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

            if (dwData == 0) {
                gdwPoolFlags &= ~POOL_HEAVY_ALLOCS;
            }
        }
    } else {

        /*
         * Heavy allocs/frees for main session ?
         */
        RtlInitUnicodeString(&UnicodeString, L"HeavyConsoleSession");

        Status = ZwQueryValueKey(
                hkey,
                &UnicodeString,
                KeyValuePartialInformation,
                &achKeyValue,
                sizeof(achKeyValue),
                &ucb);

        if (NT_SUCCESS(Status) &&
                ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

            dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

            if (dwData != 0) {
                gdwPoolFlags |= POOL_HEAVY_ALLOCS;
            }
        }
    }

    if (!(gdwPoolFlags & POOL_HEAVY_ALLOCS)) {
        ZwClose(hkey);
        return STATUS_SUCCESS;
    }

    /*
     * Check for stack traces
     */
    RtlInitUnicodeString(&UnicodeString, L"StackTraces");

    RtlZeroMemory(achKeyName, sizeof(achKeyName));

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            &achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

        if (dwData == 0) {
            gdwPoolFlags &= ~POOL_CAPTURE_STACK;
        } else {
            gdwPoolFlags |= POOL_CAPTURE_STACK;
        }
    }

    /*
     * Use tail checks ?
     */
    RtlInitUnicodeString(&UnicodeString, L"UseTailString");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            &achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        dwData = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);

        if (dwData != 0) {
            gdwPoolFlags |= POOL_TAIL_CHECK;
        }
    }

    /*
     * Keep a record of frees ? By default keep the last 32.
     */
#if DBG
    gdwFreeRecords = 32;
#endif // DBG

    RtlInitUnicodeString(&UnicodeString, L"KeepFreeRecords");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            &achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        gdwFreeRecords = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);
    }

    if (gdwFreeRecords != 0) {

        gparrFreeRecord = ExAllocatePoolWithTag(PagedPool,
                                                gdwFreeRecords * sizeof(POOLRECORD),
                                                TAG_DEBUG);

        if (gparrFreeRecord != NULL) {
            gdwPoolFlags |= POOL_KEEP_FREE_RECORD;
        }
    }

    /*
     * Keep a record of failed allocations ? By default keep the last 32.
     */
#if DBG
    gdwFailRecords = 32;
#endif // DBG

    RtlInitUnicodeString(&UnicodeString, L"KeepFailRecords");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            &achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        gdwFailRecords = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);
    }

    if (gdwFailRecords != 0) {

        gparrFailRecord = ExAllocatePoolWithTag(PagedPool,
                                                gdwFailRecords * sizeof(POOLRECORD),
                                                TAG_DEBUG);

        if (gparrFailRecord != NULL) {
            gdwPoolFlags |= POOL_KEEP_FAIL_RECORD;
        }
    }

#if DBG
    /*
     * Open the key containing the allocation that should fail.
     */
    RtlInitUnicodeString(&UnicodeString, L"AllocationIndex");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            &achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        gdwAllocFailIndex = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);
    }


    RtlInitUnicodeString(&UnicodeString, L"AllocationsToFail");

    Status = ZwQueryValueKey(
            hkey,
            &UnicodeString,
            KeyValuePartialInformation,
            &achKeyValue,
            sizeof(achKeyValue),
            &ucb);

    if (NT_SUCCESS(Status) &&
            ((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Type == REG_DWORD) {

        gdwAllocsToFail = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)achKeyValue)->Data);
    }

    if (gdwAllocFailIndex != 0 && gdwAllocsToFail > 0) {
        gdwPoolFlags |= POOL_FAIL_BY_INDEX;
    }
#endif // DBG

    ZwClose(hkey);

    return STATUS_SUCCESS;
}
#endif // POOL_INSTR

#ifdef POOL_INSTR_API

BOOL _Win32PoolAllocationStats(
    LPDWORD  parrTags,
    SIZE_T   tagsCount,
    SIZE_T*  lpdwMaxMem,
    SIZE_T*  lpdwCrtMem,
    LPDWORD  lpdwMaxAlloc,
    LPDWORD  lpdwCrtAlloc)
{
    BOOL bRet = FALSE;

    /*
     * Do nothing if heavy allocs/frees are disabled
     */
    if (!(gdwPoolFlags & POOL_HEAVY_ALLOCS)) {
        return FALSE;
    }

    *lpdwMaxMem   = gAllocList.dwMaxMem;
    *lpdwCrtMem   = gAllocList.dwCrtMem;
    *lpdwMaxAlloc = gAllocList.dwMaxAlloc;
    *lpdwCrtAlloc = gAllocList.dwCrtAlloc;

    /*
     * Acquire the mutex when we play with the list of allocations
     */
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpAllocFastMutex);

    if (gparrTagsToFail != NULL) {
        ExFreePool(gparrTagsToFail);
        gparrTagsToFail = NULL;
        gdwTagsToFailCount = 0;
    }

    if (tagsCount != 0) {
        gdwPoolFlags |= POOL_FAIL_ALLOCS;

        if (tagsCount > MAX_TAGS_TO_FAIL) {
            gdwTagsToFailCount = 0xFFFFFFFF;
            RIPMSG0(RIP_WARNING, "All pool allocations in WIN32K.SYS will fail !!!");
            bRet = TRUE;
            goto exit;
        }

    } else {
        gdwPoolFlags &= ~POOL_FAIL_ALLOCS;

        RIPMSG0(RIP_WARNING, "Pool allocations in WIN32K.SYS back to normal !");
        bRet = TRUE;
        goto exit;
    }

    gparrTagsToFail = ExAllocatePoolWithTag(PagedPool,
                                            sizeof(DWORD) * tagsCount,
                                            TAG_DEBUG);

    if (gparrTagsToFail == NULL) {
        gdwPoolFlags &= ~POOL_FAIL_ALLOCS;
        RIPMSG0(RIP_WARNING, "Pool allocations in WIN32K.SYS back to normal !");
        goto exit;
    }

    try {
        ProbeForRead(parrTags, sizeof(DWORD) * tagsCount, DATAALIGN);

        RtlCopyMemory(gparrTagsToFail, parrTags, sizeof(DWORD) * tagsCount);

    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {

          if (gparrTagsToFail != NULL) {
              ExFreePool(gparrTagsToFail);
              gparrTagsToFail = NULL;

              gdwPoolFlags &= ~POOL_FAIL_ALLOCS;
              RIPMSG0(RIP_WARNING, "Pool allocations in WIN32K.SYS back to normal !");
              goto exit;
          }
    }
    gdwTagsToFailCount = tagsCount;

    RIPMSG0(RIP_WARNING, "Specific pool allocations in WIN32K.SYS will fail !!!");

exit:
    /*
     * Release the mutex
     */
    ExReleaseFastMutexUnsafe(gpAllocFastMutex);
    KeLeaveCriticalRegion();

    return TRUE;
}

#endif // POOL_INSTR_API

#ifdef TRACE_MAP_VIEWS

FAST_MUTEX*   gpSectionFastMutex;
PWin32Section gpSections;

#define EnterSectionCrit()                          \
    KeEnterCriticalRegion();                        \
    ExAcquireFastMutexUnsafe(gpSectionFastMutex);

#define LeaveSectionCrit()                          \
    ExReleaseFastMutexUnsafe(gpSectionFastMutex);   \
    KeLeaveCriticalRegion();


/***************************************************************************\
* CleanUpSections
*
\***************************************************************************/
VOID CleanUpSections(
    VOID)
{
    if (gpSectionFastMutex) {
        ExFreePool(gpSectionFastMutex);
        gpSectionFastMutex = NULL;
    }
}

NTSTATUS InitSectionTrace(
    VOID)
{
    gpSectionFastMutex = ExAllocatePoolWithTag(NonPagedPool,
                                               sizeof(FAST_MUTEX),
                                               TAG_DEBUG);

    if (gpSectionFastMutex == NULL) {
        RIPMSG0(RIP_WARNING, "InitSectionTrace failed to allocate mutex");
        return STATUS_NO_MEMORY;
    }

    ExInitializeFastMutex(gpSectionFastMutex);

    return STATUS_SUCCESS;
}

NTSTATUS _Win32CreateSection(
    PVOID*              pSectionObject,
    ACCESS_MASK         DesiredAccess,
    POBJECT_ATTRIBUTES  ObjectAttributes,
    PLARGE_INTEGER      pInputMaximumSize,
    ULONG               SectionPageProtection,
    ULONG               AllocationAttributes,
    HANDLE              FileHandle,
    PFILE_OBJECT        FileObject,
    DWORD               SectionTag)
{
    PWin32Section pSection;
    NTSTATUS      Status;

    Status = MmCreateSection(
                    pSectionObject,
                    DesiredAccess,
                    ObjectAttributes,
                    pInputMaximumSize,
                    SectionPageProtection,
                    AllocationAttributes,
                    FileHandle,
                    FileObject);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "MmCreateSection failed with Statu %x", Status);
        *pSectionObject = NULL;
        return Status;
    }

    pSection = UserAllocPoolZInit(sizeof(Win32Section), TAG_SECTION);

    if (pSection == NULL) {
        ObDereferenceObject(*pSectionObject);
        RIPMSG0(RIP_WARNING, "Failed to allocate memory for section");
        *pSectionObject = NULL;
        return STATUS_UNSUCCESSFUL;
    }

    EnterSectionCrit();

    pSection->pNext = gpSections;
    if (gpSections != NULL) {
        UserAssert(gpSections->pPrev == NULL);
        gpSections->pPrev = pSection;
    }

    pSection->SectionObject = *pSectionObject;
    pSection->SectionSize   = *pInputMaximumSize;
    pSection->SectionTag    = SectionTag;

    gpSections = pSection;

#ifdef MAP_VIEW_STACK_TRACE
    RtlZeroMemory(pSection->trace, MAP_VIEW_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(pSection->trace, MAP_VIEW_STACK_TRACE_SIZE, 0);

#endif // MAP_VIEW_STACK_TRACE

    LeaveSectionCrit();

    return STATUS_SUCCESS;

}

VOID _Win32DestroySection(
    PVOID Section)
{
    PWin32Section ps;

    EnterSectionCrit();

    ps = gpSections;

    while (ps != NULL) {
        if (ps->SectionObject == Section) {

            /*
             * Make sure there is no view mapped for this section
             */
            if (ps->pFirstView != NULL) {
                RIPMSG1(RIP_ERROR, "Section %#p still has views", ps);
            }

            /*
             * now, remove it from the linked list of this tag
             */
            if (ps->pPrev == NULL) {

                UserAssert(ps == gpSections);

                gpSections = ps->pNext;

                if (ps->pNext != NULL) {
                    ps->pNext->pPrev = NULL;
                }
            } else {
                ps->pPrev->pNext = ps->pNext;
                if (ps->pNext != NULL) {
                    ps->pNext->pPrev = ps->pPrev;
                }
            }
            ObDereferenceObject(Section);
            UserFreePool(ps);
            LeaveSectionCrit();
            return;
        }
        ps = ps->pNext;
    }

    RIPMSG1(RIP_ERROR, "Cannot find Section %#p", Section);
    LeaveSectionCrit();
}

NTSTATUS _Win32MapViewInSessionSpace(
    PVOID   Section,
    PVOID*  pMappedBase,
    PSIZE_T pViewSize)
{
    NTSTATUS      Status;
    PWin32Section ps;
    PWin32MapView pMapView;

    /*
     * First try to map the view
     */
    Status = MmMapViewInSessionSpace(Section, pMappedBase, pViewSize);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "MmMapViewInSessionSpace failed with Status %x",
                Status);
        *pMappedBase = NULL;
        return Status;
    }

    /*
     * Now add a record for this view
     */
    pMapView = UserAllocPoolZInit(sizeof(Win32MapView), TAG_SECTION);

    if (pMapView == NULL) {
        RIPMSG0(RIP_WARNING, "_Win32MapViewInSessionSpace: Memory failure");

        MmUnmapViewInSessionSpace(*pMappedBase);
        *pMappedBase = NULL;
        return STATUS_NO_MEMORY;
    }

    pMapView->pViewBase = *pMappedBase;
    pMapView->ViewSize  = *pViewSize;

    EnterSectionCrit();

    ps = gpSections;

    while (ps != NULL) {
        if (ps->SectionObject == Section) {

            pMapView->pSection = ps;

            pMapView->pNext = ps->pFirstView;

            if (ps->pFirstView != NULL) {
                ps->pFirstView->pPrev = pMapView;
            }
            ps->pFirstView = pMapView;

#ifdef MAP_VIEW_STACK_TRACE
            RtlZeroMemory(pMapView->trace, MAP_VIEW_STACK_TRACE_SIZE * sizeof(PVOID));

            RtlWalkFrameChain(pMapView->trace, MAP_VIEW_STACK_TRACE_SIZE, 0);

#endif // MAP_VIEW_STACK_TRACE

            LeaveSectionCrit();
            return STATUS_SUCCESS;
        }
        ps = ps->pNext;
    }

    RIPMSG1(RIP_ERROR, "_Win32MapViewInSessionSpace: Could not find section for %#p",
            Section);

    LeaveSectionCrit();

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS _Win32UnmapViewInSessionSpace(
    PVOID MappedBase)
{
    PWin32Section ps;
    PWin32MapView pv;
    NTSTATUS      Status;

    EnterSectionCrit();

    ps = gpSections;

    while (ps != NULL) {

        pv = ps->pFirstView;

        while (pv != NULL) {

            UserAssert(pv->pSection == ps);

            if (pv->pViewBase == MappedBase) {
                /*
                 * now, remove it from the linked list
                 */
                if (pv->pPrev == NULL) {

                    UserAssert(pv == ps->pFirstView);

                    ps->pFirstView = pv->pNext;

                    if (pv->pNext != NULL) {
                        pv->pNext->pPrev = NULL;
                    }
                } else {
                    pv->pPrev->pNext = pv->pNext;
                    if (pv->pNext != NULL) {
                        pv->pNext->pPrev = pv->pPrev;
                    }
                }

                UserFreePool(pv);

                Status = MmUnmapViewInSessionSpace(MappedBase);

                LeaveSectionCrit();

                return Status;
            }
            pv = pv->pNext;
        }
        ps = ps->pNext;
    }

    RIPMSG1(RIP_ERROR, "_Win32UnmapViewInSessionSpace: Could not find view for %#p",
            MappedBase);

    LeaveSectionCrit();

    return STATUS_UNSUCCESSFUL;
}

#endif // TRACE_MAP_VIEWS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\pnp.c ===
/****************************** Module Header ******************************\
* Module Name: pnp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module tracks device interface changes so we can keep track of know how many mice and
* keyboards and mouse
* and mouse reports.
*
* History:
* 97-10-16   IanJa   Interpreted from a dream that Ken Ray had.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL gFirstConnectionDone = FALSE;

DEVICE_TEMPLATE aDeviceTemplate[DEVICE_TYPE_MAX + 1] = {
    // DEVICE_TYPE_MOUSE
    {
        sizeof(GENERIC_DEVICE_INFO)+sizeof(MOUSE_DEVICE_INFO),    // cbDeviceInfo
        &GUID_CLASS_MOUSE,                                        // pClassGUID
        PMAP_MOUCLASS_PARAMS,                                     // uiRegistrySection
        L"mouclass",                                              // pwszClassName
        DD_MOUSE_DEVICE_NAME_U L"0",                              // pwszDefDevName
        DD_MOUSE_DEVICE_NAME_U L"Legacy0",                        // pwszLegacyDevName
        IOCTL_MOUSE_QUERY_ATTRIBUTES,                             // IOCTL_Attr
        FIELD_OFFSET(DEVICEINFO, mouse.Attr),                     // offAttr
        sizeof((PDEVICEINFO)NULL)->mouse.Attr,                    // cbAttr
        FIELD_OFFSET(DEVICEINFO, mouse.Data),                     // offData
        sizeof((PDEVICEINFO)NULL)->mouse.Data,                    // cbData
        ProcessMouseInput,                                        // Reader routine
        NULL                                                      // pkeHidChange
    },
    // DEVICE_TYPE_KEYBOARD
    {
        sizeof(GENERIC_DEVICE_INFO)+sizeof(KEYBOARD_DEVICE_INFO), // cbDeviceInfo
        &GUID_CLASS_KEYBOARD,                                     // pClassGUID
        PMAP_KBDCLASS_PARAMS,                                     // uiRegistrySection
        L"kbdclass",                                              // pwszClassName
        DD_KEYBOARD_DEVICE_NAME_U L"0",                           // pwszDefDevName
        DD_KEYBOARD_DEVICE_NAME_U L"Legacy0",                     // pwszLegacyDevName
        IOCTL_KEYBOARD_QUERY_ATTRIBUTES,                          // IOCTL_Attr
        FIELD_OFFSET(DEVICEINFO, keyboard.Attr),                  // offAttr
        sizeof((PDEVICEINFO)NULL)->keyboard.Attr,                 // cbAttr
        FIELD_OFFSET(DEVICEINFO, keyboard.Data),                  // offData
        sizeof((PDEVICEINFO)NULL)->keyboard.Data,                 // cbData
        ProcessKeyboardInput,                                     // Reader routine
        NULL                                                      // pkeHidChange
    },
#ifdef GENERIC_INPUT
    // DEVICE_TYPE_HID
    {
        sizeof(GENERIC_DEVICE_INFO)+sizeof(HID_DEVICE_INFO),        // cbDeviceInfo
        &GUID_CLASS_INPUT,                                          // pClassGUID
        0,                                                          // uiRegistrySection. LATER: add real one
        L"hid",                                                     // pwszClassName
        L"",                                                        // pwszDefDevName
        L"",                                                        // pwszLegacyDevName
        0,                                                          // IOCTL_ATTR
        0,                                                          // offAttr
        0,                                                          // cbAttr
        0,                                                          // offData
        0,                                                          // cbData
        ProcessHidInput,                                            // Reader routine
        NULL,                                                       // pkeHidChange,
        DT_HID,                                                     // dwFlags
    },
#endif
    // Add new input device type template here
};

//
// We need to remember device class notification entries since we need
// them to unregister the device class notification when we disconnect
// from the console.
//

PVOID aDeviceClassNotificationEntry[DEVICE_TYPE_MAX + 1];

#ifdef DIAGNOSE_IO
NTSTATUS gKbdIoctlLEDSStatus = -1;   // last IOCTL_KEYBOARD_QUERY_INDICATORS
#endif

typedef struct _CDROM_NOTIFY {
    LIST_ENTRY                   Entry;
    ULONG                        Size;
    PVOID                        RegistrationHandle;
    ULONG                        Event;
    // Must be last field
    MOUNTMGR_DRIVE_LETTER_TARGET DeviceName;
} CDROM_NOTIFY, *PCDROM_NOTIFY;

PVOID gCDROMClassRegistrationEntry;
LIST_ENTRY gCDROMNotifyList;
LIST_ENTRY gMediaChangeList;
PFAST_MUTEX gMediaChangeMutex;
HANDLE gpEventMediaChange     = NULL;
UCHAR DriveLetterChange[26];
#define EVENT_CDROM_MEDIA_ARRIVAL 1
#define EVENT_CDROM_MEDIA_REMOVAL 2
#define MAX_RETRIES_TO_OPEN 30

/***************************************************************************\
* Win32kPnPDriverEntry
*
* This is the callback function when we call IoCreateDriver to create a
* PnP Driver Object.  In this function, we need to remember the DriverObject.
*
* Parameters:
*   DriverObject - Pointer to the driver object created by the system.
*   RegistryPath - is NULL.
*
* Return Value: STATUS_SUCCESS
*
* History:
* 10-20-97  IanJa   Taken from ntos\io\pnpinit.c
\***************************************************************************/

NTSTATUS
Win32kPnPDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING pustrRegistryPath
    )

{
    TAGMSG2(DBGTAG_PNP,
            "Win32kPnPDriverEntry(DriverObject = %lx, pustrRegistryPath = %#p)",
            DriverObject, pustrRegistryPath);

    //
    // File the pointer to our driver object away
    //
    gpWin32kDriverObject = DriverObject;
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pustrRegistryPath);
}


/***************************************************************************\
* Initialize the global event used in notifying CSR that media has changed.
*
* Execution Context:
*
* History:
\***************************************************************************/

VOID
InitializeMediaChange(HANDLE hMediaRequestEvent)
{
    if (!IsRemoteConnection()) {

        InitializeListHead(&gCDROMNotifyList);

        InitializeListHead(&gMediaChangeList);

        ObReferenceObjectByHandle(hMediaRequestEvent,
                                  EVENT_ALL_ACCESS,
                                  *ExEventObjectType,
                                  KernelMode,
                                  &gpEventMediaChange,
                                  NULL);

        gMediaChangeMutex = UserAllocPoolNonPaged(sizeof(FAST_MUTEX), TAG_PNP);

        if (gMediaChangeMutex) {
            ExInitializeFastMutex(gMediaChangeMutex);
        }
    }
}

VOID
CleanupMediaChange(
    VOID
    )
{
    if (gMediaChangeMutex) {
        UserFreePool(gMediaChangeMutex);
        gMediaChangeMutex = 0;
    }
}

__inline VOID EnterMediaCrit() {
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gMediaChangeMutex);
}

__inline VOID LeaveMediaCrit() {
    ExReleaseFastMutexUnsafe(gMediaChangeMutex);
    KeLeaveCriticalRegion();
}



/***************************************************************************\
* Routines to support CDROM driver letters.
*
* Execution Context:
*
* History:
\***************************************************************************/

ULONG GetDeviceChangeInfo()
{
    UNICODE_STRING                      name;
    PFILE_OBJECT                        FileObject;
    PDEVICE_OBJECT                      DeviceObject;
    KEVENT                              event;
    PIRP                                irp;
    MOUNTMGR_DRIVE_LETTER_INFORMATION   output;
    IO_STATUS_BLOCK                     ioStatus;
    NTSTATUS                            status;
    PCDROM_NOTIFY                       pContext = 0;

    ULONG retval = 0;

    if (!(ISCSRSS())) {
        return 0;
    }

    EnterMediaCrit();
    if (!IsListEmpty(&gMediaChangeList)) {
        pContext = (PCDROM_NOTIFY) RemoveTailList(&gMediaChangeList);
    }
    LeaveMediaCrit();

    if (pContext == NULL) {
        return 0;
    }

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name,
                                      FILE_READ_ATTRIBUTES,
                                      &FileObject,
                                      &DeviceObject);

    if (NT_SUCCESS(status)) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER,
                                            DeviceObject,
                                            &pContext->DeviceName,
                                            sizeof(MOUNTMGR_DRIVE_LETTER_TARGET) +
                                                pContext->DeviceName.DeviceNameLength,
                                            &output,
                                            sizeof(output),
                                            FALSE,
                                            &event,
                                            &ioStatus);
        if (irp) {

            status = IoCallDriver(DeviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                status = ioStatus.Status;
            }
            if ((status == STATUS_SUCCESS) && (output.CurrentDriveLetter)) {
                UserAssert((output.CurrentDriveLetter - 'A') < 30);
                retval = 1 << (output.CurrentDriveLetter - 'A');

                if (pContext->Event & EVENT_CDROM_MEDIA_ARRIVAL) {
                    retval |= HMCE_ARRIVAL;
                }
            }
        }

        ObDereferenceObject(FileObject);
    }

    //
    // Allways free the request
    //

    UserFreePool(pContext);

    return retval;
}

/***************************************************************************\
* Handle device notifications such as MediaChanged
*
* Execution Context:
*
* History:
\***************************************************************************/
NTSTATUS DeviceCDROMNotify(
    IN PTARGET_DEVICE_CUSTOM_NOTIFICATION Notification,
    IN PCDROM_NOTIFY pContext)
{
    PCDROM_NOTIFY pNew;

    CheckCritOut();


    if (IsRemoteConnection()) {
        return STATUS_SUCCESS;
    }
    UserAssert(pContext);

    if (IsEqualGUID(&Notification->Event, &GUID_IO_MEDIA_ARRIVAL))
    {
        pContext->Event = EVENT_CDROM_MEDIA_ARRIVAL;
    }
    else if (IsEqualGUID(&Notification->Event, &GUID_IO_MEDIA_REMOVAL))
    {
        pContext->Event = EVENT_CDROM_MEDIA_REMOVAL;
    }
    else if (IsEqualGUID(&Notification->Event, &GUID_TARGET_DEVICE_REMOVE_COMPLETE))
    {
        EnterMediaCrit();
        if (!gCDROMClassRegistrationEntry) {
            // This is being cleaned up by xxxUnregisterDeviceNotifications
            LeaveMediaCrit();
            return STATUS_SUCCESS;
        }
        RemoveEntryList(&pContext->Entry);
        LeaveMediaCrit();
        IoUnregisterPlugPlayNotification(pContext->RegistrationHandle);
        UserFreePool(pContext);
        return STATUS_SUCCESS;
    }
#ifdef AUTORUN_CURSOR
    else if (IsEqualGUID(&Notification->Event, &GUID_IO_DEVICE_BECOMING_READY)) {
        PDEVICE_EVENT_BECOMING_READY pdebr = (DEVICE_EVENT_BECOMING_READY*)Notification->CustomDataBuffer;
        ShowAutorunCursor(pdebr->Estimated100msToReady * 10);
        return STATUS_SUCCESS;
    }
#endif // AUTORUN_CURSOR
    else
    {
        return STATUS_SUCCESS;
    }

    //
    // Process the arrival or removal
    //
    // We must queue this otherwise we end up bugchecking on Terminal Server
    // This is due to opening a handle from within the system process which
    // requires us to do an attach process.
    //

    pNew = UserAllocPoolNonPaged(pContext->Size, TAG_PNP);
    if (pNew)
    {
        RtlCopyMemory(pNew, pContext, pContext->Size);

        EnterMediaCrit();
        InsertHeadList(&gMediaChangeList, &pNew->Entry);
        LeaveMediaCrit();

        KeSetEvent(gpEventMediaChange, EVENT_INCREMENT, FALSE);
    }

    return STATUS_SUCCESS;
}



/***************************************************************************\
* DeviceClassCDROMNotify
*
* This gets called when CDROM appears or disappears
*
\***************************************************************************/
NTSTATUS
DeviceClassCDROMNotify (
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION classChange,
    IN PVOID Unused
    )
{
    NTSTATUS       Status = STATUS_SUCCESS;
    PFILE_OBJECT   FileObject;
    PDEVICE_OBJECT DeviceObject;
    PCDROM_NOTIFY  pContext;
    ULONG          Size;

    UNREFERENCED_PARAMETER(Unused);

    CheckCritOut();

    /*
     * Sanity check the DeviceType, and that it matches the InterfaceClassGuid
     */
    UserAssert(IsEqualGUID(&classChange->InterfaceClassGuid, &CdRomClassGuid));

    if (IsEqualGUID(&classChange->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        Status = IoGetDeviceObjectPointer(classChange->SymbolicLinkName,
                                          FILE_READ_ATTRIBUTES,
                                          &FileObject,
                                          &DeviceObject);

        if (NT_SUCCESS(Status)) {

            Size = sizeof(CDROM_NOTIFY) + classChange->SymbolicLinkName->Length;

            pContext = (PCDROM_NOTIFY) UserAllocPool(Size, TAG_PNP);

            //
            // Register For MediaChangeNotifications on all the CDROMs.
            //

            if (pContext) {

                pContext->Size = Size;
                pContext->DeviceName.DeviceNameLength = classChange->SymbolicLinkName->Length;
                RtlCopyMemory(pContext->DeviceName.DeviceName,
                              classChange->SymbolicLinkName->Buffer,
                              pContext->DeviceName.DeviceNameLength);

                if (NT_SUCCESS(IoRegisterPlugPlayNotification (
                        EventCategoryTargetDeviceChange,
                        0,
                        FileObject,
                        gpWin32kDriverObject,
                        DeviceCDROMNotify,
                        pContext,
                        &(pContext->RegistrationHandle)))) {
                    EnterMediaCrit();
                    InsertHeadList(&gCDROMNotifyList, &pContext->Entry);
                    LeaveMediaCrit();
                } else {
                    RIPMSG2(RIP_WARNING, "Failed to register CDROM Device Notification '%.*ws'.",
                            pContext->DeviceName.DeviceNameLength, pContext->DeviceName.DeviceName);
                    UserFreePool(pContext);
                }

            } else {
                RIPMSG2(RIP_WARNING, "Failed to allocate pool block for CDROM Device Notification '%.*ws'.",
                        pContext->DeviceName.DeviceNameLength, pContext->DeviceName.DeviceName);
            }

            ObDereferenceObject(FileObject);
        }
    } else if (IsEqualGUID(&classChange->Event, &GUID_DEVICE_INTERFACE_REMOVAL)) {

        //
        // Do nothing - we already remove the registration.
        //

    } else {
        RIPMSG0(RIP_ERROR, "unrecognized Event GUID");
    }

    return STATUS_SUCCESS;
}

#ifdef TRACK_PNP_NOTIFICATION

PPNP_NOTIFICATION_RECORD gpPnpNotificationRecord;
DWORD gdwPnpNotificationRecSize = 256;

UINT giPnpSeq;
BOOL gfRecordPnpNotification = TRUE;

VOID CleanupPnpNotificationRecord(
    VOID)
{
    CheckDeviceInfoListCritIn();

    gfRecordPnpNotification = FALSE;
    if (gpPnpNotificationRecord) {
        UserFreePool(gpPnpNotificationRecord);
        gpPnpNotificationRecord = NULL;
    }
}

VOID RecordPnpNotification(
    PNP_NOTIFICATION_TYPE type,
    PDEVICEINFO pDeviceInfo,
    ULONG_PTR NotificationCode)
{
    UINT iIndex;
    UINT i = 0;
    PUNICODE_STRING pName = NULL;
    HANDLE hDeviceInfo = NULL;

    CheckDeviceInfoListCritIn();
    UserAssert(gfRecordPnpNotification);

    if (gpPnpNotificationRecord == NULL) {
        gpPnpNotificationRecord = UserAllocPoolZInit(sizeof *gpPnpNotificationRecord * gdwPnpNotificationRecSize, TAG_PNP);
    }
    if (gpPnpNotificationRecord == NULL) {
        return;
    }

    iIndex = giPnpSeq % gdwPnpNotificationRecSize;

    gpPnpNotificationRecord[iIndex].pKThread = PsGetCurrentThread();
    gpPnpNotificationRecord[iIndex].iSeq = ++giPnpSeq; // the first record is numbered as 1.
    gpPnpNotificationRecord[iIndex].type = type;
    /*
     * If there is a pathname, copy it here.
     */
    switch (type) {
    case PNP_NTF_CLASSNOTIFY:
        /*
         * pDeviceInfo is actually a pUnicodeString.
         */
        pName = (PUNICODE_STRING)pDeviceInfo;
        pDeviceInfo = NULL;
        break;
    case PNP_NTF_DEVICENOTIFY_UNLISTED:
        /*
         * pDeviceInfo is invalid, cannot be looked up.
         */
        UserAssert(pName == NULL);
        break;
    default:
        if (pDeviceInfo) {
            pName = &pDeviceInfo->ustrName;
            hDeviceInfo = PtoHq(pDeviceInfo);
        }
        break;
    }
    UserAssert(i == 0);
    if (pName) {
        for ( ; i < ARRAY_SIZE(gpPnpNotificationRecord[iIndex].szPathName) - 1 && i < (UINT)pName->Length / sizeof(WCHAR); ++i) {
            gpPnpNotificationRecord[iIndex].szPathName[i] = (UCHAR)pName->Buffer[i];
        }
    }
    gpPnpNotificationRecord[iIndex].szPathName[i] = 0;

    /*
     * Store the rest of information
     */
    gpPnpNotificationRecord[iIndex].pDeviceInfo = pDeviceInfo;
    gpPnpNotificationRecord[iIndex].hDeviceInfo = hDeviceInfo;
    gpPnpNotificationRecord[iIndex].NotificationCode = NotificationCode;

    /*
     * Store the stack trace.
     */
    RtlWalkFrameChain(gpPnpNotificationRecord[iIndex].trace,
                      ARRAY_SIZE(gpPnpNotificationRecord[iIndex].trace),
                      0);
}

#endif // TRACK_PNP_NOTIFICATION


/***************************************************************************\
* CreateDeviceInfo
*
* This creates an instance of an input device for USER.  To do this it:
*  - Allocates a DEVICEINFO struct
*  - Adds it to USER's list of input devices
*  - Initializes some of the fields
*  - Signals the input servicing thread to open and read the new device.
*
* Type - the device type (DEVICE_TYPE_MOUSE, DEVICE_TYPE_KEYBOARD)
* Name - the device name.
*        When trying to open a HYDRA client's mouse, Name is NULL.
* bFlags - some initial flags to set (eg: GDIF_NOTPNP)
*
* THIS FUNCTION IS CALLED IN THE CONTEXT OF THE KERNEL PROCESS
* so we mustn't open the mouse here, else the handle we get will not belong
* to the Win32k process.
*
* History:
* 11-26-90 DavidPe      Created.
* 01-07-98 IanJa        Plug & Play
\***************************************************************************/

PDEVICEINFO CreateDeviceInfo(DWORD DeviceType, PUNICODE_STRING pustrName, BYTE bFlags)
{
    PDEVICEINFO pDeviceInfo = NULL;

    CheckCritIn();
    BEGINATOMICCHECK();

    UserAssert(pustrName != NULL);

    TAGMSG3(DBGTAG_PNP, "CreateDeviceInfo(%d, %S, %x)", DeviceType, pustrName->Buffer, bFlags);

    if (DeviceType > DEVICE_TYPE_MAX) {
        RIPMSG1(RIP_ERROR, "Unknown DeviceType %lx", DeviceType);
    }

#ifdef GENERIC_INPUT
    pDeviceInfo = (PDEVICEINFO)HMAllocObject(NULL, NULL, (BYTE)TYPE_DEVICEINFO, (DWORD)aDeviceTemplate[DeviceType].cbDeviceInfo);
#else
    pDeviceInfo = UserAllocPoolZInit(aDeviceTemplate[DeviceType].cbDeviceInfo, TAG_PNP);
#endif

    if (pDeviceInfo == NULL) {
        RIPMSG0(RIP_WARNING, "CreateDeviceInfo() out of memory allocating DEVICEINFO");
        EXITATOMICCHECK();
        return NULL;
    }

    if (pustrName->Buffer != NULL) {
        pDeviceInfo->ustrName.Buffer = UserAllocPool(pustrName->Length, TAG_PNP);

        if (pDeviceInfo->ustrName.Buffer == NULL) {
            RIPMSG2(RIP_WARNING, "CreateDeviceInfo: Can't duplicate string %.*ws",
                    pustrName->Length / sizeof(WCHAR),
                    pustrName->Buffer);
            goto CreateFailed;
        }

        pDeviceInfo->ustrName.MaximumLength = pustrName->Length;
        RtlCopyUnicodeString(&pDeviceInfo->ustrName, pustrName);
    }

    pDeviceInfo->type = (BYTE)DeviceType;
    pDeviceInfo->bFlags |= bFlags;

    /*
     * Create this device's HidChangeCompletion event. When the RIT completes
     * a synchronous ProcessDeviceChanges() it signals the HidChangeCompletion
     * event to wake the requesting RequestDeviceChange() which is blocking on
     * the event.
     * Each device has it's own HidChangeCompletion event,
     * since multiple PnP notification may arrive  for several different
     * devices simultaneously.  (see #331320 IanJa)
     */
    pDeviceInfo->pkeHidChangeCompleted = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (pDeviceInfo->pkeHidChangeCompleted == NULL) {
        RIPMSG0(RIP_WARNING,
                "CreateDeviceInfo: failed to create pkeHidChangeCompleted");
        goto CreateFailed;
    }

    EnterDeviceInfoListCrit();

#ifdef TRACK_PNP_NOTIFICATION
    /*
     * Placing tracking code here may miss the failure cases above,
     * but they're pretty exceptional cases that can be safely ignored.
     */
    if (gfRecordPnpNotification) {
        RecordPnpNotification(PNP_NTF_CREATEDEVICEINFO, pDeviceInfo, DeviceType);
    }
#endif

#ifdef GENERIC_INPUT

    if (aDeviceTemplate[DeviceType].dwFlags & DT_HID) {
        /*
         * Create HID specific information.
         */
        pDeviceInfo->hid.pHidDesc = xxxHidCreateDeviceInfo(pDeviceInfo);

        if (pDeviceInfo->hid.pHidDesc == NULL) {
            /*
             * Something wrong happened and we failed to
             * create the device information.
             * Or the device is not our target.
             * Should bail out anyway.
             */
            TAGMSG0(DBGTAG_PNP, "CreateDeviceInfo: xxxHidCreateDeviceInfo bailed out.");
            LeaveDeviceInfoListCrit();
            goto CreateFailed;
        }
    }
#endif

    /*
     * Link it in
     */
    pDeviceInfo->pNext = gpDeviceInfoList;
    gpDeviceInfoList = pDeviceInfo;

    /*
     * Tell the RIT there is a new device so that it can open it and start
     * reading from it.  This is non-blocking (no GDIAF_PNPWAITING bit set)
     */
    RequestDeviceChange(pDeviceInfo, GDIAF_ARRIVED, TRUE);
    LeaveDeviceInfoListCrit();

    EXITATOMICCHECK();
    return pDeviceInfo;

CreateFailed:

    if (pDeviceInfo) {
        if (pDeviceInfo->ustrName.Buffer) {
            UserFreePool(pDeviceInfo->ustrName.Buffer);
        }
#ifdef GENERIC_INPUT
        if (pDeviceInfo->hid.pHidDesc) {
            FreeHidDesc(pDeviceInfo->hid.pHidDesc);
#if DBG
            pDeviceInfo->hid.pHidDesc = NULL;
#endif
        }
        if (pDeviceInfo->pkeHidChangeCompleted) {
            FreeKernelEvent(&pDeviceInfo->pkeHidChangeCompleted);
        }
        HMFreeObject(pDeviceInfo);
#else
        UserFreePool(pDeviceInfo);
#endif
    }

    ENDATOMICCHECK();
    return NULL;
}


/***************************************************************************\
* DeviceClassNotify
*
* This gets called when an input device is attached or detached.
* If this happens during initialization (for mice already connected) we
* come here by in the context of the RIT.  If hot-(un)plugging a mouse,
* then we are called on a thread from the Kernel process.
*
* History:
* 10-20-97  IanJa   Taken from some old code of KenRay's
\***************************************************************************/
NTSTATUS
DeviceClassNotify (
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION classChange,
    IN PVOID DeviceType // (context)
    )
{
    DWORD dwDeviceType;

    CheckCritOut();
    dwDeviceType = PtrToUlong( DeviceType );
    TAGMSG2(DBGTAG_PNP, "enter DeviceClassNotify(%lx, %lx)", classChange, dwDeviceType);

    /*
     * Sanity check the DeviceType, and that it matches the InterfaceClassGuid
     */
    UserAssert(dwDeviceType <= DEVICE_TYPE_MAX);
    UserAssert(IsEqualGUID(&classChange->InterfaceClassGuid, aDeviceTemplate[dwDeviceType].pClassGUID));

    if (IsRemoteConnection()) {
        return STATUS_SUCCESS;
    }

    TAGMSG3(DBGTAG_PNP | RIP_THERESMORE, " Event GUID %lx, %x, %x",
            classChange->Event.Data1,
            classChange->Event.Data2,
            classChange->Event.Data3);
    TAGMSG8(DBGTAG_PNP | RIP_THERESMORE, " %2x%2x%2x%2x%2x%2x%2x%2x",
            classChange->Event.Data4[0], classChange->Event.Data4[1],
            classChange->Event.Data4[2], classChange->Event.Data4[3],
            classChange->Event.Data4[4], classChange->Event.Data4[5],
            classChange->Event.Data4[6], classChange->Event.Data4[7]);
    TAGMSG4(DBGTAG_PNP | RIP_THERESMORE, " InterfaceClassGuid %lx, %lx, %lx, %lx",
            ((DWORD *)&(classChange->InterfaceClassGuid))[0],
            ((DWORD *)&(classChange->InterfaceClassGuid))[1],
            ((DWORD *)&(classChange->InterfaceClassGuid))[2],
            ((DWORD *)&(classChange->InterfaceClassGuid))[3]);
    TAGMSG1(DBGTAG_PNP | RIP_THERESMORE, " SymbolicLinkName %ws", classChange->SymbolicLinkName->Buffer);

    if (IsEqualGUID(&classChange->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {

        // A new hid device class association has arrived
        EnterCrit();
        TRACE_INIT(("DeviceClassNotify - SymbolicLinkName : %ws \n", classChange->SymbolicLinkName->Buffer));
#ifdef TRACK_PNP_NOTIFICATION
        if (gfRecordPnpNotification) {
            CheckDeviceInfoListCritOut();
            EnterDeviceInfoListCrit();
            RecordPnpNotification(PNP_NTF_CLASSNOTIFY, (PVOID)classChange->SymbolicLinkName, (ULONG_PTR)DeviceType);
            LeaveDeviceInfoListCrit();
        }
#endif
        CreateDeviceInfo(dwDeviceType, classChange->SymbolicLinkName, 0);
        LeaveCrit();
        TAGMSG0(DBGTAG_PNP, "=== CREATED ===");
    }

    return STATUS_SUCCESS;
}

/****************************************************************************\
* If a device class "all-for-one" setting (ConnectMultiplePorts) is on,
* then we just open the device the old (non-PnP) way and return TRUE.  (As a
* safety feature we also do this if gpWin32kDriverObject is NULL, because this
* driver object is needed to register for PnP device class notifications)
* Otherwise, return FALSE so we can continue and register for Arrival/Departure
* notifications.
*
* This code was originally intended to be temporary until ConnectMultiplePorts
* was finally turned off.
* But now I think we have to keep it for backward compatibility with
* drivers that filter Pointer/KeyboardClass0 and/or those that replace
* Pointer/KeyboardClass0 by putting a different name in the registry under
* System\CurrentControlSet\Services\RIT\mouclass (or kbbclass)
\****************************************************************************/
BOOL
OpenMultiplePortDevice(DWORD DeviceType)
{
    WCHAR awchDeviceName[MAX_PATH];
    UNICODE_STRING DeviceName;
    PDEVICE_TEMPLATE pDevTpl;
    PDEVICEINFO pDeviceInfo;
    PWCHAR pwchNameIndex;

    UINT uiConnectMultiplePorts = 0;

    CheckCritIn();

    if (DeviceType <= DEVICE_TYPE_MAX) {
        pDevTpl = &aDeviceTemplate[DeviceType];
    } else {
        RIPMSG1(RIP_ERROR, "OpenMultiplePortDevice(%d) - unknown type", DeviceType);
        return FALSE;
    }

    if (IsRemoteConnection()) {
        return FALSE;
    }

#ifdef GENERIC_INPUT
    if (pDevTpl->dwFlags & DT_HID) {
        /*
         * HID devices don't need multiple port
         */
        return FALSE;
    }
#endif // GENERIC_INPUT

    /*
     * Note that we don't need to FastOpenUserProfileMapping() here since
     * uiRegistrySection (PMAP_MOUCLASS_PARAMS/PMAP_KBDCLASS_PARAMS) is a
     * machine setiing, not a user setting.
     */
    FastGetProfileDwordW(NULL,
            pDevTpl->uiRegistrySection, L"ConnectMultiplePorts", 0, &uiConnectMultiplePorts, 0);

    /*
     * Open the device for read access.
     */
    if (uiConnectMultiplePorts || (gpWin32kDriverObject == NULL)) {
        /*
         * Find out if there is a name substitution in the registry.
         * Note that we don't need to FastOpenUserProfileMapping() here since
         * PMAP_INPUT is a machine setting, not a user setting.
         */
        FastGetProfileStringW(NULL,
                PMAP_INPUT,
                pDevTpl->pwszClassName,
                pDevTpl->pwszDefDevName, // if no substitution, use this default
                awchDeviceName,
                sizeof(awchDeviceName)/sizeof(WCHAR),
                0);

        RtlInitUnicodeString(&DeviceName, awchDeviceName);

        pDeviceInfo = CreateDeviceInfo(DeviceType, &DeviceName, GDIF_NOTPNP);
        if (pDeviceInfo) {
            return TRUE;
        }
    } else {
        DeviceName.Length = 0;
        DeviceName.MaximumLength = sizeof(awchDeviceName);
        DeviceName.Buffer = awchDeviceName;

        RtlAppendUnicodeToString(&DeviceName, pDevTpl->pwszLegacyDevName);
        pwchNameIndex = &DeviceName.Buffer[(DeviceName.Length / sizeof(WCHAR)) - 1];
        for (*pwchNameIndex = L'0'; *pwchNameIndex <= L'9'; (*pwchNameIndex)++) {
            CreateDeviceInfo(DeviceType, &DeviceName, GDIF_NOTPNP);
        }
    }

    return FALSE;
}

/***************************************************************************\
* RegisterCDROMNotify
*
* History:
* 08-21-00  VTan    Created
\***************************************************************************/
VOID RegisterCDROMNotify(
    VOID)
{
    UserAssert(!IsRemoteConnection());
    UserAssert(gpWin32kDriverObject != NULL);

    if (gpWin32kDriverObject != NULL) {
        IoRegisterPlugPlayNotification (
            EventCategoryDeviceInterfaceChange,
            PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
            (PVOID) &CdRomClassGuid,
            gpWin32kDriverObject,
            (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)DeviceClassCDROMNotify,
            NULL,
            &gCDROMClassRegistrationEntry);
    }
}

/***************************************************************************\
* RegisterForDeviceClassNotifications
*
* Get ready to receive notifications that a mouse or keyboard is plugged in
* or removed, then request notifications by registering for them.
*
* History:
* 10-20-97  IanJa   Taken from ntos\io\pnpinit.c
\***************************************************************************/
NTSTATUS
xxxRegisterForDeviceClassNotifications(
    VOID)
{
    IO_NOTIFICATION_EVENT_CATEGORY eventCategory;
    ULONG                          eventFlags;
    NTSTATUS                       Status;
    UNICODE_STRING                 ustrDriverName;
    DWORD                          DeviceType;


    CheckCritIn();

    TAGMSG0(DBGTAG_PNP, "enter xxxRegisterForDeviceClassNotifications()");

    /*
     * Remote hydra session indicates CreateDeviceInfo in xxxRemoteReconnect
     */
    UserAssert(!IsRemoteConnection());

    if (!gFirstConnectionDone) {

       if (!gbRemoteSession) {
           // Session 0
           /*
            * This must be done before devices are registered for device notifications
            * which will occur as a result of CreateDeviceInfo()...
            */
           RtlInitUnicodeString(&ustrDriverName, L"\\Driver\\Win32k");
           Status = IoCreateDriver(&ustrDriverName, Win32kPnPDriverEntry);

           TAGMSG1(DBGTAG_PNP | RIP_THERESMORE, "IoCreateDriver returned status = %lx", Status);
           TAGMSG1(DBGTAG_PNP, "gpWin32kDriverObject = %lx", gpWin32kDriverObject);

           if (!NT_SUCCESS(Status)) {
               RIPMSG1(RIP_ERROR, "IoCreateDriver failed, status %lx", Status);
               Status = STATUS_SUCCESS;
           }

           UserAssert(gpWin32kDriverObject);
       } else {
           UserAssert(gpWin32kDriverObject == NULL);
           /*
            * Non-Zero session attached to the console
            */

           RtlInitUnicodeString(&ustrDriverName, L"\\Driver\\Win32k");

           //
           // Attempt to open the driver object
           //
           Status = ObReferenceObjectByName(&ustrDriverName,
                                            OBJ_CASE_INSENSITIVE,
                                            NULL,
                                            0,
                                            *IoDriverObjectType,
                                            KernelMode,
                                            NULL,
                                            &gpWin32kDriverObject);
           if (!NT_SUCCESS(Status)) {
               RIPMSG1(RIP_ERROR, "ObReferenceObjectByName failed, status %lx", Status);
               Status = STATUS_SUCCESS;
           }
           UserAssert(gpWin32kDriverObject);
       }
    }

    //
    // We are only interested in DeviceClasses changing.
    //
    eventCategory = EventCategoryDeviceInterfaceChange;

    //
    // We want to be notified for all devices that are in the system.
    // those that are know now, and those that will arive later.
    // This allows us to have one code path for adding devices, and eliminates
    // the nasty race condition.  If we were only interested in the devices
    // that exist at this one moment in time, and not future devices, we
    // would call IoGetDeviceClassAssociations.
    //
    eventFlags = PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES;


    /*
     * For all input device types:
     *  If they are Multiple Port Devices (ie: not PnP) just open them
     *  Else Register them for PnP notifications (they will be opened when the
     *       arrival notification arrives.
     * If devices are already attached, we will received immediate notification
     * during the call to IoRegisterPlugPlayNotification, so we must LeaveCrit
     * because the callback routine DeviceClassNotify expects it.
     */
    for (DeviceType = 0; DeviceType <= DEVICE_TYPE_MAX; DeviceType++) {
        if (!OpenMultiplePortDevice(DeviceType) && (gpWin32kDriverObject != NULL)) {
            /*
             * Make the registration.
             */

            TAGMSG1(DBGTAG_PNP, "Registering device type %d", DeviceType);

            LeaveCrit(); // for DeviceClassNotify
            Status = IoRegisterPlugPlayNotification (
                         eventCategory,
                         eventFlags,
                         (PVOID)aDeviceTemplate[DeviceType].pClassGUID,
                         gpWin32kDriverObject,
                         (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)DeviceClassNotify,
                         LongToPtr( DeviceType ),
                         &aDeviceClassNotificationEntry[DeviceType]);

            EnterCrit();


            TAGMSG1(DBGTAG_PNP, "Registration returned status %lx", Status);
            if (!NT_SUCCESS(Status)) {
                RIPMSG2(RIP_ERROR, "IoRegisterPlugPlayNotification(%d) failed, status %lx",
                        DeviceType, Status);
            }
        }
    }

    // Now Register for CD_ROM notifications
    LeaveCrit(); // for DeviceClassNotify

    if ( !gFirstConnectionDone && (gpWin32kDriverObject != NULL)) {
        if (!IsRemoteConnection()) {
            RegisterCDROMNotify();
        }
        gFirstConnectionDone = TRUE;
    }
    EnterCrit();

    return Status;
}

/***************************************************************************\
* UnregisterDeviceClassNotifications
*
* Remove device class notification registrations.
*
* History:
* 02-28-00  Earhart  Created
\***************************************************************************/
VOID
xxxUnregisterDeviceClassNotifications(
    VOID)
{
    // Our input devices will automatically unregister themselves; we
    // need to clean up cdrom, though.
    PLIST_ENTRY   pNext;
    PCDROM_NOTIFY pContext;
    PVOID         RegistrationEntry;

    EnterMediaCrit();

    if (gCDROMClassRegistrationEntry) {
        RegistrationEntry = gCDROMClassRegistrationEntry;
        gCDROMClassRegistrationEntry = NULL;
        LeaveMediaCrit();
        IoUnregisterPlugPlayNotification(RegistrationEntry);
        EnterMediaCrit();
    }

    while (TRUE) {
        pNext = RemoveHeadList(&gCDROMNotifyList);
        if (!pNext || pNext == &gCDROMNotifyList) {
            break;
        }
        pContext = CONTAINING_RECORD(pNext, CDROM_NOTIFY, Entry);
        LeaveMediaCrit();       /* in case there's a notification pending */
        IoUnregisterPlugPlayNotification(pContext->RegistrationHandle);
        UserFreePool(pContext);
        EnterMediaCrit();
    }

    LeaveMediaCrit();
}

/***************************************************************************\
* GetKbdExId
*
* Get extended keyboard id with WMI
*
* History:
* 01-02-01  Hiroyama    Created
\***************************************************************************/
NTSTATUS GetKbdExId(
    HANDLE hDevice,
    PKEYBOARD_ID_EX pIdEx)
{
    PWNODE_SINGLE_INSTANCE pNode;
    ULONG size;
    PVOID p = NULL;
    NTSTATUS status;
    UNICODE_STRING str;

    status = IoWMIOpenBlock((LPGUID)&MSKeyboard_ExtendedID_GUID, WMIGUID_QUERY, &p);

    if (NT_SUCCESS(status)) {
        status = IoWMIHandleToInstanceName(p, hDevice, &str);
        TAGMSG2(DBGTAG_PNP, "GetKbdExId: DevName='%.*ws'",
                str.Length / sizeof(WCHAR),
                str.Buffer);

        if (NT_SUCCESS(status)) {
            // Get the size
            size = 0;
            IoWMIQuerySingleInstance(p, &str, &size, NULL);

            size += sizeof *pIdEx;
            pNode = UserAllocPoolNonPaged(size, TAG_KBDEXID);

            if(pNode) {
                status = IoWMIQuerySingleInstance(p, &str, &size, pNode);
                if (NT_SUCCESS(status)) {
                    *pIdEx = *(PKEYBOARD_ID_EX)(((PUCHAR)pNode) + pNode->DataBlockOffset);
                }

                UserFreePool(pNode);
            }

            RtlFreeUnicodeString(&str);
        }

        ObDereferenceObject(p);
    }


    return status;
}


/***************************************************************************\
* QueryDeviceInfo
*
* Query the device information.  This function is an async function,
* so be sure any buffers it uses aren't allocated on the stack!
*
* If this is an asynchronous IOCTL, perhaps we should be waiting on
* the file handle or on an event for it to succeed?
*
* This function must called by the RIT, not directly by PnP notification
* (else the handle we issue the IOCTL on will be invalid)
*
* History:
* 01-20-99 IanJa        Created.
\***************************************************************************/
NTSTATUS
QueryDeviceInfo(
    PDEVICEINFO pDeviceInfo)
{
    NTSTATUS Status;
    PDEVICE_TEMPLATE pDevTpl = &aDeviceTemplate[pDeviceInfo->type];
    KEYBOARD_ID_EX IdEx;

#ifdef GENERIC_INPUT
    UserAssert(pDeviceInfo->type != DEVICE_TYPE_HID);
#endif

#ifdef DIAGNOSE_IO
    pDeviceInfo->AttrStatus =
#endif
    Status = ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                 &pDeviceInfo->iosb,
                 pDevTpl->IOCTL_Attr,
                 NULL, 0,
                 (PVOID)((PBYTE)pDeviceInfo + pDevTpl->offAttr),
                 pDevTpl->cbAttr);

    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_WARNING, "QueryDeviceInfo(%p): IOCTL failed - Status %lx",
                pDeviceInfo, Status);
    }
    TAGMSG1(DBGTAG_PNP, "IOCTL_*_QUERY_ATTRIBUTES returns Status %lx", Status);

    if (pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) {
        if (NT_SUCCESS(GetKbdExId(pDeviceInfo->handle, &IdEx))) {
            TAGMSG4(DBGTAG_PNP, "QueryDeviceInfo: kbd (%x,%x) ExId:(%x,%x)",
                    pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Type, pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Subtype,
                    IdEx.Type, IdEx.Subtype);
            pDeviceInfo->keyboard.IdEx = IdEx;
        } else {
            // What can we do?
            pDeviceInfo->keyboard.IdEx.Type = pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Type;
            pDeviceInfo->keyboard.IdEx.Subtype = pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Subtype;
            TAGMSG3(DBGTAG_PNP, "QueryDeviceInfo: failed to get ExId for pDevice=%p, fallback to (%x,%x)",
                    pDeviceInfo, pDeviceInfo->keyboard.IdEx.Type, pDeviceInfo->keyboard.IdEx.Subtype);
        }
    }

    return Status;
}


/***************************************************************************\
* OpenDevice
*
* This function opens an input device for USER, mouse or keyboard.
*
*
* Return value
*   BOOL did the operation succeed?
*
* When trying to open a HYDRA client's mouse (or kbd?), pDeviceInfo->ustrName
* is NULL.
*
* This function must called by the RIT, not directly by PnP
* notification (that way the handle we are about to create will be in the right
* our process)
*
* History:
* 11-26-90 DavidPe      Created.
* 01-07-98 IanJa        Plug & Play
* 04-17-98 IanJa        Only open mice in RIT context.
\***************************************************************************/
BOOL OpenDevice(
    PDEVICEINFO pDeviceInfo)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    ULONG ulAccessMode = FILE_READ_DATA | SYNCHRONIZE;
    ULONG ulShareMode = FILE_SHARE_WRITE;
    UINT i;

    CheckCritIn();
    UserAssert((PtiCurrentShared() == gptiRit) || (PtiCurrentShared() == gTermIO.ptiDesktop));

    TAGMSG4(DBGTAG_PNP, "OpenDevice(): Opening type %d (%lx %.*ws)",
            pDeviceInfo->type, pDeviceInfo->handle, pDeviceInfo->ustrName.Length / sizeof(WCHAR), pDeviceInfo->ustrName.Buffer);

#ifdef DIAGNOSE_IO
    pDeviceInfo->OpenerProcess = PsGetCurrentProcessId();
#endif

    if (IsRemoteConnection()) {

        TRACE_INIT(("OpenDevice - Remote mode\n"));

        /*
         * For other than the console, the mouse handle is
         * set before createwinstation.
         */

        pDeviceInfo->bFlags |= GDIF_NOTPNP;

        switch (pDeviceInfo->type) {
        case DEVICE_TYPE_MOUSE:
            pDeviceInfo->handle = ghRemoteMouseChannel;
            if (ghRemoteMouseChannel == NULL) {
               return FALSE;
            }
            break;
        case DEVICE_TYPE_KEYBOARD:
            pDeviceInfo->handle = ghRemoteKeyboardChannel;
            if (ghRemoteKeyboardChannel == NULL) {
               return FALSE;
            }
            break;
        default:
            RIPMSG2(RIP_ERROR, "Unknown device type %d DeviceInfo %#p",
                    pDeviceInfo->type, pDeviceInfo);
            return FALSE;
        }
    } else {
        InitializeObjectAttributes(&ObjectAttributes, &(pDeviceInfo->ustrName), 0, NULL, NULL);

#ifdef GENERIC_INPUT
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            ulAccessMode |= FILE_WRITE_DATA;
            ulShareMode |= FILE_SHARE_READ;
        }
#endif

        // USB devices are slow, so they may not have been closed before we
        // open again here so let us delay execution for some time and try
        // to open them again. We delay 1/10th of a second for a max of 30
        // times, making a total wait time of 3 seconds.
        //
        // If we fast user switch too fast, the serial port may be in the
        // process of closing where it stalls execution. This is a rare
        // case where we may open the serial port while it is stalling
        // and get back STATUS_ACCESS_DENIED and lose the user's device.
        // In this case, we should retry the open and it should succeed
        // once the serial port has closed.

        for (i = 0; i < MAX_RETRIES_TO_OPEN; i++) {
#ifdef DIAGNOSE_IO
        pDeviceInfo->OpenStatus =
#endif
            Status = ZwCreateFile(&pDeviceInfo->handle, ulAccessMode,
                    &ObjectAttributes, &pDeviceInfo->iosb, NULL, 0, ulShareMode, FILE_OPEN_IF, 0, NULL, 0);

            if (STATUS_SHARING_VIOLATION == Status ||
                    (Status == STATUS_ACCESS_DENIED)) {
                // Sleep for 1/10th of a second
                UserSleep(100);
            } else {
                // Device opened successfully or some other error occured
                break;
            }
        }

        TAGMSG2(DBGTAG_PNP, "ZwCreateFile returns handle %lx, Status %lx",
                pDeviceInfo->handle, Status);

        if (!NT_SUCCESS(Status)) {
            if ((pDeviceInfo->bFlags & GDIF_NOTPNP) == 0) {
                /*
                 * Don't warn about PS/2 mice: the PointerClassLegacy0 -9 and
                 * KeyboardClassLegacy0 - 9 will usually fail to be created
                 */
                RIPMSG1(RIP_WARNING, "OpenDevice: ZwCreateFile failed with Status %lx", Status);
            }
            TRACE_INIT(("OpenDevice: ZwCreateFile failed with Status %lx", Status));
            /*
             * Don't FreeDeviceInfo here because that alters gpDeviceInfoList
             * which our caller, ProcessDeviceChanges, is traversing.
             * Instead, let ProcessDeviceChanges do it.
             */
            return FALSE;
        }
    }

#ifdef GENERIC_INPUT
    /*
     * HID Information has been already acquired through xxxHidCreateDeviceInfo
     */
    if (pDeviceInfo->type != DEVICE_TYPE_HID) {
#endif
        Status = QueryDeviceInfo(pDeviceInfo);
#ifdef GENERIC_INPUT
    }
#endif

    return NT_SUCCESS(Status);
}

VOID CloseDevice(
    PDEVICEINFO pDeviceInfo)
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    CheckCritIn();

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        CheckDeviceInfoListCritIn();
        RecordPnpNotification(PNP_NTF_CLOSEDEVICE, pDeviceInfo, pDeviceInfo->usActions);
    }
#endif // TRACK_PNP_NOTIFICATION

    TAGMSG5(DBGTAG_PNP, "CloseDevice(%p): closing type %d (%lx %.*ws)",
            pDeviceInfo,
            pDeviceInfo->type, pDeviceInfo->handle,
            pDeviceInfo->ustrName.Length / sizeof(WCHAR), pDeviceInfo->ustrName.Buffer);

    if (pDeviceInfo->handle) {
        UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

        ZwCancelIoFile(pDeviceInfo->handle, &IoStatusBlock);
        UserAssertMsg2(NT_SUCCESS(IoStatusBlock.Status), "NtCancelIoFile handle %x failed status %#x",
                 pDeviceInfo->handle, IoStatusBlock.Status);

        if (pDeviceInfo->handle == ghRemoteMouseChannel) {
           UserAssert(pDeviceInfo->type == DEVICE_TYPE_MOUSE);
           pDeviceInfo->handle = 0;
           return;
        }

        if (pDeviceInfo->handle == ghRemoteKeyboardChannel) {
           UserAssert(pDeviceInfo->type == DEVICE_TYPE_KEYBOARD);
           pDeviceInfo->handle = 0;
           return;
        }

        Status = ZwClose(pDeviceInfo->handle);
        UserAssertMsg2(NT_SUCCESS(Status), "ZwClose handle %x failed status %#x",
                pDeviceInfo->handle, Status);
        pDeviceInfo->handle = 0;
    } else {
#ifdef GENERIC_INPUT
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            /*
             * HID devices may be closed regardless the error conditions.
             */
            TAGMSG2(DBGTAG_PNP, "CloseDevice: hid: pDeviceInfo->iosb.Status=%x, ReadStatus=%x",
                    pDeviceInfo->iosb.Status, pDeviceInfo->ReadStatus);
        } else {
#endif
            /*
             * Assert the IO was cancelled or we tried to read the device
             * after the first close (which set the handle to 0 - an invalid handle)
             */
            UserAssert((pDeviceInfo->iosb.Status == STATUS_CANCELLED) ||
                       (pDeviceInfo->ReadStatus == STATUS_INVALID_HANDLE));

#ifdef GENERIC_INPUT
        }
#endif
    }
}

/*****************************************************************************\
* RegisterForDeviceChangeNotifications()
*
* Device Notifications such as QueryRemove, RemoveCancelled, RemoveComplete
* tell us what is going on with the mouse.
* To register for device notifications:
* (1) Obtain a pointer to the device object (pFileObject)
* (2) Register for target device change notifications, saving the
*     notification handle (which we will need in order to deregister)
*
* It doesn't matter too much if this fails: we just won't be able to eject the
* hardware via the UI very successfully. (We can still just yank it though).
* This will also fail if the ConnectMultiplePorts was set for this device.
*
* 1998-10-05 IanJa    Created
\*****************************************************************************/
BOOL RegisterForDeviceChangeNotifications(
    PDEVICEINFO pDeviceInfo)
{
    PFILE_OBJECT pFileObject;
    NTSTATUS Status;

    /*
     * In or Out of User critical section:
     * In when called from RIT ProcessDeviceChanges();
     * Out when called from the DeviceNotify callback
     */

    if (IsRemoteConnection()) {
        TRACE_INIT(("RegisterForDeviceChangeNotifications called for remote session\n"));
        return TRUE;
    }


    CheckCritIn();
    UserAssert((PtiCurrentShared() == gptiRit) || (PtiCurrentShared() == gTermIO.ptiDesktop));
    UserAssert(pDeviceInfo->handle);
    UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

    if (pDeviceInfo->bFlags & GDIF_NOTPNP) {
        return TRUE;
    }
    Status = ObReferenceObjectByHandle(pDeviceInfo->handle,
                                       0,
                                       NULL,
                                       KernelMode,
                                       (PVOID)&pFileObject,
                                       NULL);
    if (NT_SUCCESS(Status)) {
        Status = IoRegisterPlugPlayNotification (
                EventCategoryTargetDeviceChange,  // EventCategory
                0,                                // EventCategoryFlags
                (PVOID)pFileObject,               // EventCategoryData
                gpWin32kDriverObject,             // DriverObject
                // (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)
                DeviceNotify,
                (PVOID)pDeviceInfo,                       // Context
                &pDeviceInfo->NotificationEntry);
        ObDereferenceObject(pFileObject);
        if (!NT_SUCCESS(Status)) {
            // This is only OK if ConnectMultiplePorts is on (ie: not a PnP device)
            RIPMSG3(RIP_ERROR,
                    "IoRegisterPlugPlayNotification failed on device %.*ws, status %lx, email DoronH : #333453",
                    pDeviceInfo->ustrName.Length / sizeof(WCHAR),
                    pDeviceInfo->ustrName.Buffer, Status);
        }
    } else {
        // non-catastrophic error (won't be able to remove device)
        RIPMSG2(RIP_ERROR, "Can't get pFileObject from handle %lx, status %lx",
                pDeviceInfo->handle, Status);
    }

    return NT_SUCCESS(Status);
}


BOOL UnregisterForDeviceChangeNotifications(PDEVICEINFO pDeviceInfo)
{
    NTSTATUS Status;

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        CheckDeviceInfoListCritIn();
        RecordPnpNotification(PNP_NTF_UNREGISTER_NOTIFICATION, pDeviceInfo, pDeviceInfo->usActions);
    }
#endif

    CheckCritIn();
    UserAssert((PtiCurrentShared() == gptiRit) || (PtiCurrentShared() == gTermIO.ptiDesktop));
    UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

    if (pDeviceInfo->NotificationEntry == NULL) {
        /*
         * This happens for non-PnP devices or if the earlier
         * IoRegisterPlugPlayNotification() failed.  Return now since
         * IoUnregisterPlugPlayNotification(NULL) will bluescreen.
         * And other case is also when we detach remote devices (which are
         * not PnP) when reconnecting locally.
         */
        return TRUE;
    }

    // non-PnP devices should not have any NotificationEntry:
    UserAssert((pDeviceInfo->bFlags & GDIF_NOTPNP) == 0);

    TAGMSG4(DBGTAG_PNP, "UnregisterForDeviceChangeNotifications(): type %d (%lx %.*ws)",
            pDeviceInfo->type, pDeviceInfo, pDeviceInfo->ustrName.Length / sizeof(WCHAR), pDeviceInfo->ustrName.Buffer);
    Status = IoUnregisterPlugPlayNotification(pDeviceInfo->NotificationEntry);
    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_ERROR,
                "IoUnregisterPlugPlayNotification failed Status = %lx, DEVICEINFO %lx",
                Status, pDeviceInfo);
        return FALSE;
    }
    pDeviceInfo->NotificationEntry = 0;
    return TRUE;
}


/***************************************************************************\
* Handle device notifications such as QueryRemove, CancelRemove etc.
*
* Execution Context:
*    when yanked:  a non-WIN32 thread.
*    via UI:       ??? (won't see this except from laptop being undocked?)
*
* History:
\***************************************************************************/
__inline USHORT GetPnpActionFromGuid(
    GUID *pEvent)
{
    USHORT usAction = 0;

    if (IsEqualGUID(pEvent, &GUID_TARGET_DEVICE_QUERY_REMOVE)) {
        TAGMSG0(DBGTAG_PNP | RIP_NONAME, "QueryRemove");
        usAction = GDIAF_QUERYREMOVE;

    } else if (IsEqualGUID(pEvent, &GUID_TARGET_DEVICE_REMOVE_CANCELLED)) {
        TAGMSG0(DBGTAG_PNP | RIP_NONAME, "RemoveCancelled");
        usAction = GDIAF_REMOVECANCELLED;

    } else if (IsEqualGUID(pEvent, &GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {
        TAGMSG1(DBGTAG_PNP | RIP_NONAME, "RemoveComplete (process %#x)", PsGetCurrentProcessId());
        usAction = GDIAF_DEPARTED;

    } else {
        TAGMSG4(DBGTAG_PNP | RIP_NONAME, "GUID Unknown: %lx:%lx:%lx:%x...",
                pEvent->Data1, pEvent->Data2,
                pEvent->Data3, pEvent->Data4[0]);
    }
    return usAction;
}


NTSTATUS DeviceNotify(
    IN PPLUGPLAY_NOTIFY_HDR pNotification,
    IN PDEVICEINFO pDeviceInfo)  // should the context be a kernel address?
{
    USHORT usAction;
    PDEVICEINFO pDeviceInfoTmp;

    CheckCritOut();
    CheckDeviceInfoListCritOut();

    /*
     * Check the validity of pDeviceInfo.
     */
    EnterDeviceInfoListCrit();
    for (pDeviceInfoTmp = gpDeviceInfoList; pDeviceInfoTmp; pDeviceInfoTmp = pDeviceInfoTmp->pNext) {
        if (pDeviceInfoTmp == pDeviceInfo) {
            break;
        }
    }
    if (pDeviceInfoTmp == NULL) {
        /*
         * This is an unknown device, most likely the one already freed.
         */
#ifdef TRACK_PNP_NOTIFICATION
        if (gfRecordPnpNotification) {
            RecordPnpNotification(PNP_NTF_DEVICENOTIFY_UNLISTED, pDeviceInfo, GetPnpActionFromGuid(&pNotification->Event));
        }
#endif

        RIPMSG1(RIP_ERROR, "win32k!DeviceNotify: Notification for unlisted DEVICEINFO %p, contact ntuserdt!", pDeviceInfo);

        LeaveDeviceInfoListCrit();
        /*
         * Not to prevent device removal etc.,
         * return success here.
         */
        return STATUS_SUCCESS;
    }

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        RecordPnpNotification(PNP_NTF_DEVICENOTIFY, pDeviceInfo, GetPnpActionFromGuid(&pNotification->Event));
    }
#endif
    LeaveDeviceInfoListCrit();

    if (IsRemoteConnection()) {
        return STATUS_SUCCESS;
    }

    TAGMSG1(DBGTAG_PNP | RIP_THERESMORE, "DeviceNotify >>> %lx", pDeviceInfo);

    UserAssert(pDeviceInfo->OpenerProcess != PsGetCurrentProcessId());
    UserAssert(pDeviceInfo->usActions == 0);

    usAction = GetPnpActionFromGuid(&pNotification->Event);
    if (usAction == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Signal the RIT to ProcessDeviceChanges()
     * Wait for completion according to the GDIAF_PNPWAITING bit
     */
    CheckCritOut();
    CheckDeviceInfoListCritOut();

    /*
     * There is small window where we can get a PnP notification for a device that
     * we just have unregister unregistered a notification for and that we are deleting
     * so for PnP notification we need to check the device is valid (still in the list
     * and not being deleted.
     */
    EnterDeviceInfoListCrit();
    pDeviceInfoTmp = gpDeviceInfoList;
    while (pDeviceInfoTmp) {
        if (pDeviceInfoTmp == pDeviceInfo ) {
            if (!(pDeviceInfo->usActions & (GDIAF_FREEME | GDIAF_DEPARTED)))  {
                KeResetEvent(gpEventPnPWainting);
                gbPnPWaiting = TRUE;
                RequestDeviceChange(pDeviceInfo, (USHORT)(usAction | GDIAF_PNPWAITING), TRUE);
                gbPnPWaiting = FALSE;
                KeSetEvent(gpEventPnPWainting, EVENT_INCREMENT, FALSE);
            }
            break;
        }
        pDeviceInfoTmp = pDeviceInfoTmp->pNext;
    }
    LeaveDeviceInfoListCrit();

    return STATUS_SUCCESS;
}


/***************************************************************************\
* StartDeviceRead
*
* This function makes an asynchronous read request to the input device driver,
* unless the device has been marked for destruction (GDIAF_FREEME)
*
* Returns:
*   The next DeviceInfo on the list if this device was freed: If the caller
*   was not already in the DeviceInfoList critical section, the this must be
*   ignored as it is not safe.
*   NULL if the read succeeded.
*
* History:
* 11-26-90 DavidPe      Created.
* 10-20-98 IanJa        Generalized for PnP input devices
\***************************************************************************/
PDEVICEINFO StartDeviceRead(
    PDEVICEINFO pDeviceInfo)
{
    PDEVICE_TEMPLATE pDevTpl;
#ifdef GENERIC_INPUT
    PVOID pBuffer;
    ULONG ulLengthToRead;
#endif

#if !defined(GENERIC_INPUT)
    pDeviceInfo->bFlags |= GDIF_READING;
#endif

    /*
     * If this device need to be freed, abandon
     * reading now and request the free.
     */
    if (pDeviceInfo->usActions & GDIAF_FREEME) {
#ifdef GENERIC_INPUT
        BEGIN_REENTERCRIT() {
#if DBG
            if (fAlreadyHadCrit) {
                CheckDeviceInfoListCritIn();
            }
#endif
#endif
            BEGIN_REENTER_DEVICEINFOLISTCRIT() {
                pDeviceInfo->bFlags &= ~GDIF_READING;
                pDeviceInfo = FreeDeviceInfo(pDeviceInfo);
            } END_REENTER_DEVICEINFOLISTCRIT();
#ifdef GENERIC_INPUT
        } END_REENTERCRIT();
#endif
        return pDeviceInfo;
    }

    if (gbExitInProgress || gbStopReadInput) {
        // Let's not post any more reads when we're trying to exit, eh?
        pDeviceInfo->bFlags &= ~GDIF_READING;
        pDeviceInfo->iosb.Status = STATUS_UNSUCCESSFUL;
        return NULL;
    }

    /*
     * Initialize in case read fails
     */
    pDeviceInfo->iosb.Status = STATUS_UNSUCCESSFUL; // catch concurrent writes?
    pDeviceInfo->iosb.Information = 0;

    pDevTpl = &aDeviceTemplate[pDeviceInfo->type];

    UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

#ifdef GENERIC_INPUT
    if (pDeviceInfo->type == DEVICE_TYPE_HID) {
        UserAssert(pDeviceInfo->hid.pTLCInfo);
        if (pDeviceInfo->handle == NULL) {
            /*
             * Currently this device is not requested by anyone.
             */
            TAGMSG1(DBGTAG_PNP, "StartDeviceRead: pDevInfo=%p has been closed on demand.", pDeviceInfo);
            BEGIN_REENTER_DEVICEINFOLISTCRIT()
            if (pDeviceInfo->handle == NULL) {
                if (pDeviceInfo->bFlags & GDIF_READING) {
                    pDeviceInfo->bFlags &= ~GDIF_READING;
                    TAGMSG1(DBGTAG_PNP, "StartDeviceRead: pDevInfo=%p, bFlags has been reset.", pDeviceInfo);
                }
            }
            END_REENTER_DEVICEINFOLISTCRIT();
            return NULL;
        }

        pBuffer = pDeviceInfo->hid.pHidDesc->pInputBuffer;
        ulLengthToRead = pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength * MAXIMUM_ITEMS_READ;
    }
    else {
        pBuffer = (PBYTE)pDeviceInfo + pDevTpl->offData;
        ulLengthToRead = pDevTpl->cbData;
    }
#endif

    if (pDeviceInfo->handle == NULL) {
        BEGIN_REENTER_DEVICEINFOLISTCRIT() {
            /*
             * Make sure the handle is truely NULL.
             * If this is the case, perhaps this is called from APC
             * that happened at bad timing, like in the middle of
             * device removal query, when ProcessDeviceChanges completed
             * but RequestDeviceChange is not awaken for the complete event.
             * The code can olnly simply bail out once in the situation.
             */
            if (pDeviceInfo->handle == NULL) {
                pDeviceInfo->bFlags &= ~GDIF_READING;
                pDeviceInfo->ReadStatus = STATUS_INVALID_HANDLE;
            }
        } END_REENTER_DEVICEINFOLISTCRIT();
        return NULL;
    }

#ifdef GENERIC_INPUT
    pDeviceInfo->bFlags |= GDIF_READING;
#endif

    LOGTIME(pDeviceInfo->timeStartRead);

#ifdef DIAGNOSE_IO
    pDeviceInfo->nReadsOutstanding++;
#endif

    UserAssert(pDeviceInfo->handle);

    /*
     * Avoid to start reading NULL device handle.
     * This happen when the DeviceNotify receives QUERY_REMOVE
     * and the RIT finishes processing it, but RequestDeviceChange
     * has not finished its wait.
     */
#ifdef GENERIC_INPUT
    pDeviceInfo->ReadStatus = ZwReadFile(
            pDeviceInfo->handle,
            NULL,                // hReadEvent
            InputApc,            // InputApc()
            pDeviceInfo,         // ApcContext
            &pDeviceInfo->iosb,
            pBuffer,
            ulLengthToRead,
            PZERO(LARGE_INTEGER), NULL);
#else

        pDeviceInfo->ReadStatus = ZwReadFile(
                pDeviceInfo->handle,
                NULL,                // hReadEvent
                InputApc,            // InputApc()
                pDeviceInfo,         // ApcContext
                &pDeviceInfo->iosb,
                (PVOID)((PBYTE)pDeviceInfo + pDevTpl->offData),
                pDevTpl->cbData,
                PZERO(LARGE_INTEGER), NULL);
#endif

    LOGTIME(pDeviceInfo->timeEndRead);

#if DBG
    if (pDeviceInfo->bFlags & GDIF_DBGREAD) {
        TAGMSG2(DBGTAG_PNP, "ZwReadFile of Device handle %lx returned status %lx",
                pDeviceInfo->handle, pDeviceInfo->ReadStatus);
    }
#endif

    if (!NT_SUCCESS(pDeviceInfo->ReadStatus)) {
        BEGIN_REENTER_DEVICEINFOLISTCRIT() {
            /*
             * If insufficient resources, retry the read the next time the RIT
             * wakes up for the ID_TIMER event by incrementing gnRetryReadInput
             * (Cheaper than setting our own timer),
             * Else just abandon reading.
             */
            if (pDeviceInfo->ReadStatus == STATUS_INSUFFICIENT_RESOURCES) {
                if (pDeviceInfo->nRetryRead++ < MAXIMUM_READ_RETRIES) {
                    pDeviceInfo->usActions |= GDIAF_RETRYREAD;
                    gnRetryReadInput++;
                }
            } else {
                pDeviceInfo->bFlags &= ~GDIF_READING;
            }

#ifdef DIAGNOSE_IO
            pDeviceInfo->nReadsOutstanding--;
#endif
        } END_REENTER_DEVICEINFOLISTCRIT();
    } else {
        pDeviceInfo->nRetryRead = 0;
    }

    if (!gbRemoteSession && !NT_SUCCESS(pDeviceInfo->ReadStatus))
        RIPMSG2(RIP_WARNING, "StartDeviceRead %#p failed Status %#x",
                pDeviceInfo, pDeviceInfo->ReadStatus);

    return NULL;
}

#ifdef GENERIC_INPUT
/***************************************************************************\
* StopDeviceRead
*
* History:
* XX-XX-00 Hiroyama     created
\***************************************************************************/
PDEVICEINFO StopDeviceRead(
    PDEVICEINFO pDeviceInfo)
{
    IO_STATUS_BLOCK IoStatusBlock;

    TAGMSG1(DBGTAG_PNP, "StopDeviceRead(%p)", pDeviceInfo);

    CheckCritIn();
    CheckDeviceInfoListCritIn();

    UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);
    UserAssert(pDeviceInfo->handle);
    UserAssert(pDeviceInfo->OpenerProcess == PsGetCurrentProcessId());

    /*
     * Stop reading this HID device.
     */
    pDeviceInfo->bFlags &= ~GDIF_READING;

    ZwCancelIoFile(pDeviceInfo->handle, &IoStatusBlock);
    UserAssertMsg2(NT_SUCCESS(IoStatusBlock.Status), "NtCancelIoFile handle %x failed status %#x",
             pDeviceInfo->handle, IoStatusBlock.Status);

    CloseDevice(pDeviceInfo);

    return NULL;
}
#endif

/***************************************************************************\
* IsKnownKeyboardType
*
* Checks if the given type/subtype is the known IDs
* History:
* XX-XX-00 Hiroyama     created
\***************************************************************************/
__inline BOOL IsKnownKeyboardType(
    DWORD dwType,
    DWORD dwSubType)
{
    switch (dwType) {
    case 4: // Generic
        if ((BYTE)dwSubType == 0xff) {
            /*
             * Bogus subtype, most likely invalid Hydra device.
             */
            return FALSE;
        }
        return TRUE;
    case 7: // Japanese
    case 8: // Korean
        return TRUE;
    default:
        break;
    }
    return FALSE;
}

/***************************************************************************\
* IsPS2Keyboard
*
* return TRUE for the PS/2 device name
* XX-XX-00 Hiroyama     created
\***************************************************************************/
__inline BOOL IsPS2Keyboard(
    LPWSTR pwszDevice)
{
    static const WCHAR wszPS2Header[] = L"\\??\\Root#*";
    static const WCHAR wszPS2HeaderACPI[] = L"\\??\\ACPI#*";

    return wcsncmp(pwszDevice, wszPS2Header, ARRAY_SIZE(wszPS2Header) - 1) == 0 ||
        wcsncmp(pwszDevice, wszPS2HeaderACPI, ARRAY_SIZE(wszPS2HeaderACPI) - 1) == 0;
}

__inline BOOL IsRDPKeyboard(
    LPWSTR pwszDevice)
{
    static const WCHAR wszRDPHeader[] = L"\\??\\Root#RDP";

    return wcsncmp(pwszDevice, wszRDPHeader, ARRAY_SIZE(wszRDPHeader) - 1) == 0;
}

VOID ProcessDeviceChanges(
    DWORD DeviceType)
{
    PDEVICEINFO pDeviceInfo;
    USHORT usOriginalActions;
#if DBG
    int nChanges = 0;
    ULONG timeStartReadPrev;
#endif

    /*
     * Reset summary information for all Mice and Keyboards
     */
    DWORD nMice = 0;
    DWORD nWheels = 0;
    DWORD nMaxButtons = 0;
    int   nKeyboards = 0;
    BOOLEAN fKeyboardIdSet = FALSE;
#ifdef GENERIC_INPUT
    int   nHid = 0;
#endif

    CheckCritIn();
    BEGINATOMICCHECK();
    UserAssert((PtiCurrentShared() == gptiRit) || (PtiCurrentShared() == gTermIO.ptiDesktop));

    EnterDeviceInfoListCrit();
    BEGINATOMICDEVICEINFOLISTCHECK();

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        RecordPnpNotification(PNP_NTF_PROCESSDEVICECHANGES, NULL, DeviceType);
    }
#endif

    if (DeviceType == DEVICE_TYPE_KEYBOARD) {
        /*
         * Set the fallback value.
         */
        gKeyboardInfo = gKeyboardDefaultInfo;
    }

    /*
     * Look for devices to Create (those which have newly arrived)
     * and for devices to Terminate (these which have just departed)
     * and for device change notifications.
     * Make sure the actions are processed in the right order in case we
     * are being asked for more than one action per device: for example,
     * we sometimes get QueryRemove followed quickly by RemoveCancelled
     * and both actions arrive here together: we should do them in the
     * correct order.
     */
    pDeviceInfo = gpDeviceInfoList;
    while (pDeviceInfo) {
        if (pDeviceInfo->type != DeviceType) {
            pDeviceInfo = pDeviceInfo->pNext;
            continue;
        }

        usOriginalActions = pDeviceInfo->usActions;
        UserAssert((usOriginalActions == 0) || (usOriginalActions & ~GDIAF_PNPWAITING));

        /*
         * Refresh Mouse:
         * We read a MOUSE_ATTRIBUTES_CHANGED flag when a PS/2 mouse
         * is plugged back in. Find out the attributes of the device.
         */
        if (pDeviceInfo->usActions & GDIAF_REFRESH_MOUSE) {
            pDeviceInfo->usActions &= ~GDIAF_REFRESH_MOUSE;

            UserAssert(pDeviceInfo->type == DEVICE_TYPE_MOUSE);
#if DBG
            nChanges++;
#endif
            TAGMSG1(DBGTAG_PNP, "QueryDeviceInfo: %lx", pDeviceInfo);
            QueryDeviceInfo(pDeviceInfo);
        }

        /*
         * QueryRemove:
         * Close the file object, but retain the DEVICEINFO struct and the
         * registration in case we later get a RemoveCancelled.
         */
        if (pDeviceInfo->usActions & GDIAF_QUERYREMOVE) {
            pDeviceInfo->usActions &= ~GDIAF_QUERYREMOVE;
#if DBG
            nChanges++;
#endif
            TAGMSG1(DBGTAG_PNP, "QueryRemove: %lx", pDeviceInfo);
            CloseDevice(pDeviceInfo);
        }

        /*
         * New device arrived or RemoveCancelled:
         * If new device, Open it, register for notifications and start reading
         * If RemoveCancelled, unregister the old notfications first
         */
        if (pDeviceInfo->usActions & (GDIAF_ARRIVED | GDIAF_REMOVECANCELLED)) {
            // Reopen the file object, (this is a new file object, of course),
            // Unregister for the old file, register with this new one.
            if (pDeviceInfo->usActions & GDIAF_REMOVECANCELLED) {
                pDeviceInfo->usActions &= ~GDIAF_REMOVECANCELLED;
#if DBG
                nChanges++;
#endif
                TAGMSG1(DBGTAG_PNP, "RemoveCancelled: %lx", pDeviceInfo);
                UnregisterForDeviceChangeNotifications(pDeviceInfo);
            }

#if DBG
            if (pDeviceInfo->usActions & GDIAF_ARRIVED) {
                nChanges++;
            }
#endif


            pDeviceInfo->usActions &= ~GDIAF_ARRIVED;
            if (OpenDevice(pDeviceInfo)) {
                PDEVICEINFO pDeviceInfoNext;

                if (!IsRemoteConnection()) {
                    RegisterForDeviceChangeNotifications(pDeviceInfo);
                }

#ifdef GENERIC_INPUT
                if (pDeviceInfo->type == DEVICE_TYPE_HID) {
                    /*
                     * If this device is not requested, close the device now.
                     */
                    UserAssert(pDeviceInfo->handle);
                    UserAssert(pDeviceInfo->hid.pTLCInfo);

                    if (pDeviceInfo->handle && !HidTLCActive(pDeviceInfo->hid.pTLCInfo)) {
                        StopDeviceRead(pDeviceInfo);    // also closes the handle
                    }
                }
                if (!((IsRemoteConnection()) && (pDeviceInfo->usActions & GDIAF_RECONNECT)) && pDeviceInfo->handle) {
                    pDeviceInfoNext = StartDeviceRead(pDeviceInfo);
                    if (pDeviceInfoNext) {
                        /*
                         * pDeviceInfo was freed, move onto the next
                         */
                        pDeviceInfo = pDeviceInfoNext;
                        continue;
                    }
                }

#else

                if (!((IsRemoteConnection()) && (pDeviceInfo->usActions & GDIAF_RECONNECT))) {

                    pDeviceInfoNext = StartDeviceRead(pDeviceInfo);
                    if (pDeviceInfoNext) {
                        /*
                          * pDeviceInfo wasa freed, move onto the next
                         */
                        pDeviceInfo = pDeviceInfoNext;
                        continue;
                    }
                }
#endif
                pDeviceInfo->usActions &= ~GDIAF_RECONNECT;

            } else {
                /*
                 * If the Open failed, we free the device here, and move on to
                 * the next device.
                 * Assert to catch re-open failure upon RemoveCancelled.
                 */
#if DBG
                if ((usOriginalActions & GDIAF_ARRIVED) == 0) {
                    RIPMSG2(RIP_WARNING, "Re-Open %#p failed status %x during RemoveCancelled",
                            pDeviceInfo, pDeviceInfo->OpenStatus);
                }
#endif

#ifdef GENERIC_INPUT
                if (pDeviceInfo->type == DEVICE_TYPE_HID) {
                    /*
                     * Some other applications may open this device
                     * exclusively. We may succeed to open it later on, so
                     * keep this deviceinfo around until it's physically
                     * detached.
                     */
                    RIPMSG1(RIP_WARNING, "ProcessDeviceChanges: failed to open the device %p",
                            pDeviceInfo);
                } else {
#endif
                    pDeviceInfo = FreeDeviceInfo(pDeviceInfo);
                    continue;
#ifdef GENERIC_INPUT
                }
#endif
            }
        }

        /*
         * RemoveComplete:
         * Close the file object, if you have not already done so, Unregister.
         * FreeDeviceInfo here (which will actually request a free from the
         * reader or the PnP requestor thread), and move on to the next device.
         */
        if (pDeviceInfo->usActions & GDIAF_DEPARTED) {
            pDeviceInfo->usActions &= ~GDIAF_DEPARTED;
#if DBG
            nChanges++;
#endif
            TAGMSG1(DBGTAG_PNP, "RemoveComplete: %lx (process %#x)", pDeviceInfo);
            CloseDevice(pDeviceInfo);
            UnregisterForDeviceChangeNotifications(pDeviceInfo);
            pDeviceInfo = FreeDeviceInfo(pDeviceInfo);
            continue;
        }

        if (pDeviceInfo->usActions & GDIAF_IME_STATUS) {
            pDeviceInfo->usActions &= ~GDIAF_IME_STATUS;
#if DBG
            nChanges++;
#endif
            if ((pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) && (pDeviceInfo->handle)) {
                if (FUJITSU_KBD_CONSOLE(pDeviceInfo->keyboard.Attr.KeyboardIdentifier) ||
                    (gbRemoteSession &&
                     FUJITSU_KBD_REMOTE(gRemoteClientKeyboardType))
                   ) {
                    /*
                     * Fill up the KEYBOARD_IME_STATUS structure.
                     */
                    ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                            &giosbKbdControl, IOCTL_KEYBOARD_SET_IME_STATUS,
                            (PVOID)&gKbdImeStatus, sizeof(gKbdImeStatus), NULL, 0);
                }
            }
        }

        if (pDeviceInfo->usActions & GDIAF_RETRYREAD) {
            PDEVICEINFO pDeviceInfoNext;
            pDeviceInfo->usActions &= ~GDIAF_RETRYREAD;
            UserAssert(pDeviceInfo->ReadStatus == STATUS_INSUFFICIENT_RESOURCES);
#if DBG
            timeStartReadPrev = pDeviceInfo->timeStartRead;
#endif
            TAGMSG2(DBGTAG_PNP, "Retry Read %#p after %lx ticks",
                    pDeviceInfo, pDeviceInfo->timeStartRead - timeStartReadPrev);
            pDeviceInfoNext = StartDeviceRead(pDeviceInfo);
            if (pDeviceInfoNext) {
                /*
                 * pDeviceInfo wasa freed, move onto the next
                 */
                pDeviceInfo = pDeviceInfoNext;
                continue;
            }
        }

#ifdef GENERIC_INPUT
        if (pDeviceInfo->usActions & GDIAF_STARTREAD) {

            pDeviceInfo->usActions &= ~GDIAF_STARTREAD;
#if DBG
            timeStartReadPrev = pDeviceInfo->timeStartRead;
#endif
            TAGMSG1(DBGTAG_PNP, "Start Read %#p", pDeviceInfo);
            UserAssert(pDeviceInfo->handle == NULL);
            UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);
            UserAssert(HidTLCActive(pDeviceInfo->hid.pTLCInfo)); // a bit over active assert?

            if (!OpenDevice(pDeviceInfo)) {
                /*
                 * Failed to open, perhaps some other applications
                 * has opened this device exclusively.
                 * We can't do nothing more than ignoring the failure.
                 * Let's get going.
                 */
                RIPMSG1(RIP_WARNING, "ProcessDeviceChanges: STARTREAD failed to reopen the device %p",
                       pDeviceInfo);
            } else {
                PDEVICEINFO pDeviceInfoNext;

                pDeviceInfoNext = StartDeviceRead(pDeviceInfo);
                if (pDeviceInfoNext) {
                    /*
                     * pDeviceInfo was freed, move onto the next
                     */
                    pDeviceInfo = pDeviceInfoNext;
                    continue;
                }
            }
        }

        if (pDeviceInfo->usActions & GDIAF_STOPREAD) {

            pDeviceInfo->usActions &= ~GDIAF_STOPREAD;
            UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);
            if (pDeviceInfo->handle) {
                PDEVICEINFO pDeviceInfoNext;

                /*
                 * StopDeviceRead cancels pending I/O,
                 * and closes the device handle,
                 * but basically the deviceinfo itself keeps
                 * alive.
                 */
                pDeviceInfoNext = StopDeviceRead(pDeviceInfo);
                if (pDeviceInfoNext) {
                    /*
                     * pDeviceInfo was freed, move onto the next
                     */
                    pDeviceInfo = pDeviceInfoNext;
                }
            } else {
                RIPMSG1(RIP_WARNING, "ProcessDeviceChanges: STOPREAD, but handle is already NULL for %p",
                        pDeviceInfo);
            }
        }
#endif

        /*
         * Gather summary information on open devices
         */
        if (pDeviceInfo->handle) {
            switch (pDeviceInfo->type) {
            case DEVICE_TYPE_MOUSE:
                UserAssert(PtiCurrentShared() == gTermIO.ptiDesktop);
                if (pDeviceInfo->usActions & GDIAF_REFRESH_MOUSE) {
                    pDeviceInfo->usActions &= ~GDIAF_REFRESH_MOUSE;
#if DBG
                    nChanges++;
#endif
                }
                nMice++;
                nMaxButtons = max(nMaxButtons, pDeviceInfo->mouse.Attr.NumberOfButtons);
                switch(pDeviceInfo->mouse.Attr.MouseIdentifier) {
                case WHEELMOUSE_I8042_HARDWARE:
                case WHEELMOUSE_SERIAL_HARDWARE:
                case WHEELMOUSE_HID_HARDWARE:
                    nWheels++;
                }
                break;

            case DEVICE_TYPE_KEYBOARD:
                UserAssert(PtiCurrentShared() == gptiRit);
                // LEDStatus held in win32k.sys and later force the new keyboard
                // to be set accordingly.
                if (pDeviceInfo->ustrName.Buffer == NULL) {
                    /*
                     * This most likely is a bogus Hydra device.
                     */
                    RIPMSG1(RIP_WARNING, "ProcessDeviceChanges: KBD pDevInfo=%p has no name!", pDeviceInfo);
                    if (!fKeyboardIdSet) {
                        /*
                         * If keyboard id/attr is not set, try to get it from this device
                         * anyway.  If there are legit PS/2 devices after this, we'll get
                         * a chance to re-aquire more meaningful id/attr.
                         */
                        goto get_attr_anyway;
                    }
                } else {
                    NTSTATUS Status;

                    if ((!fKeyboardIdSet || IsPS2Keyboard(pDeviceInfo->ustrName.Buffer)) &&
                            !IsRDPKeyboard(pDeviceInfo->ustrName.Buffer)) {
get_attr_anyway:

#if 0
                        /*
                         * LATER: when other GI stuff in ntinput.c goes in,
                         * move this boot-time LED and type/subtype initialization to
                         * ntinput.c where the RIT is initialized.
                         */
#ifdef DIAGNOSE_IO
                        gKbdIoctlLEDSStatus =
#endif
                        Status = ZwDeviceIoControlFile(pDeviceInfo->handle, NULL, NULL, NULL,
                                &giosbKbdControl, IOCTL_KEYBOARD_QUERY_INDICATORS,
                                NULL, 0,
                                (PVOID)&gklpBootTime, sizeof(gklpBootTime));
                        UserAssertMsg2(NT_SUCCESS(Status),
                                "IOCTL_KEYBOARD_QUERY_INDICATORS failed: DeviceInfo %#x, Status %#x",
                                 pDeviceInfo, Status);

                        TAGMSG1(DBGTAG_PNP, "ProcessDeviceChanges: led flag is %x", gklpBootTime.LedFlags);
#else
                        UNREFERENCED_PARAMETER(Status);
#endif  // 0

                        if (IsKnownKeyboardType(pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Type,
                                                pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Subtype)) {
                            USHORT NumberOfFunctionKeysSave = gKeyboardInfo.NumberOfFunctionKeys;

                            gKeyboardInfo = pDeviceInfo->keyboard.Attr;
                            /*
                             * Store the maximum number of function keys into gKeyboardInfo.
                             */
                            if (NumberOfFunctionKeysSave > gKeyboardInfo.NumberOfFunctionKeys) {
                                gKeyboardInfo.NumberOfFunctionKeys = NumberOfFunctionKeysSave;
                            }
                        } else {
                            RIPMSG3(RIP_WARNING, "ProcessDeviceChanges: kbd pDevInfo %p has bogus type/subtype=%x/%x",
                                    pDeviceInfo,
                                    pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Type,
                                    pDeviceInfo->keyboard.Attr.KeyboardIdentifier.Subtype);
                        }

                        if (pDeviceInfo->ustrName.Buffer) {
                            /*
                             * If this is a legit device, remember it so that we won't
                             * try to get other non PS/2 keyboard id/attr.
                             */
                            fKeyboardIdSet = TRUE;
                        }
                    }
                }
                nKeyboards++;
                break;

#ifdef GENERIC_INPUT
            case DEVICE_TYPE_HID:
                ++nHid;
                break;
#endif

            default:
                // Add code for a new type of input device here
                RIPMSG2(RIP_ERROR, "pDeviceInfo %#p has strange type %d",
                        pDeviceInfo, pDeviceInfo->type);
                break;
            }
        }
#ifdef GENERIC_INPUT
        else if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            ++nHid;
            TAGMSG1(DBGTAG_PNP, "ProcessDeviceChanges: HID DeviceInfo %p", pDeviceInfo);
        }
#endif

        /*
         * Notify the PnP thread that a change has been completed
         */
        if (usOriginalActions & GDIAF_PNPWAITING) {
            KeSetEvent(pDeviceInfo->pkeHidChangeCompleted, EVENT_INCREMENT, FALSE);
        }

        pDeviceInfo = pDeviceInfo->pNext;
    }

    ENDATOMICDEVICEINFOLISTCHECK();
    LeaveDeviceInfoListCrit();


    switch (DeviceType) {
    case DEVICE_TYPE_MOUSE:
        /*
         * Apply summary information for Mice
         */
        if (nMice) {
            if (gnMice == 0) {
                /*
                 * We had no mouse before but we have one now: add a cursor
                 */
                SET_GTERMF(GTERMF_MOUSE);
                SYSMET(MOUSEPRESENT) = TRUE;
                SetGlobalCursorLevel(0);
                UserAssert(PpiFromProcess(gpepCSRSS)->ptiList->iCursorLevel == 0);
                UserAssert(PpiFromProcess(gpepCSRSS)->ptiList->pq->iCursorLevel == 0);
                GreMovePointer(gpDispInfo->hDev, gpsi->ptCursor.x, gpsi->ptCursor.y,
                               MP_PROCEDURAL);
            }
        } else {
            if (gnMice != 0) {
                /*
                 * We had a mouse before but we don't now: remove the cursor
                 */
                CLEAR_GTERMF(GTERMF_MOUSE);
                SYSMET(MOUSEPRESENT) = FALSE;
                SetGlobalCursorLevel(-1);
                /*
                 * Don't leave mouse buttons stuck down, clear the global button
                 * state here, otherwise weird stuff might happen.
                 * Also do this in Alt-Tab processing and zzzCancelJournalling.
                 */
#if DBG
                if (gwMouseOwnerButton)
                    RIPMSG1(RIP_WARNING,
                            "gwMouseOwnerButton=%x, being cleared forcibly\n",
                            gwMouseOwnerButton);
#endif
                gwMouseOwnerButton = 0;
            }
        }
        /*
         * Mouse button count represents the number of buttons on the mouse with
         * the most buttons.
         */
        SYSMET(CMOUSEBUTTONS) = nMaxButtons;
        SYSMET(MOUSEWHEELPRESENT) = (nWheels > 0);
        gnMice = nMice;
        break;

    case DEVICE_TYPE_KEYBOARD:
        /*
         * Apply summary information for Keyboards
         */

        if (nKeyboards > gnKeyboards) {
            /*
             * We have more keyboards, let set their LEDs properly
             */
            UpdateKeyLights(FALSE);
            /*
             * The new keyboard arrived. Tell the RIT to set
             * the repeat rate.
             */
            RequestKeyboardRateUpdate();
        }
        if ((nKeyboards != 0) && (gnKeyboards == 0)) {
            /*
             * We had no keyboard but we have one now: set the system hotkeys.
             */
            SetDebugHotKeys();
        }
        gnKeyboards = nKeyboards;
        break;

#ifdef GENERIC_INPUT
    case DEVICE_TYPE_HID:
        gnHid = nHid;
        break;
#endif

    default:
        break;
    }

    ENDATOMICCHECK();
}

/***************************************************************************\
* RequestDeviceChange()
*
* Flag the Device for the specified actions, then set its pkeHidChange to
* trigger the RIT to perform the actions.
* The current thread may not be able to do this if it is a PnP notification
* from another process.
*
* History:
* 01-20-99 IanJa        Created.
\***************************************************************************/
VOID RequestDeviceChange(
    PDEVICEINFO pDeviceInfo,
    USHORT usAction,
    BOOL fInDeviceInfoListCrit)
{
    PDEVICE_TEMPLATE pDevTpl = &aDeviceTemplate[pDeviceInfo->type];
    UserAssert(pDevTpl->pkeHidChange != NULL);
    UserAssert((usAction & GDIAF_FREEME) == 0);
    UserAssert((pDeviceInfo->usActions & GDIAF_PNPWAITING) == 0);

#if DBG
    if (pDeviceInfo->usActions != 0) {
        TAGMSG3(DBGTAG_PNP, "RequestDeviceChange(%#p, %x), but action %x pending",
                pDeviceInfo, usAction, pDeviceInfo->usActions);
    }

    /*
     * We can't ask for synchronized actions to be performed on the Device List
     * if we are holding the Device List lock or the User Critical Section:
     * ProcessDeviceChanges() requires both of these itself.
     */
    //if (usAction & GDIAF_PNPWAITING) {
    //    CheckDeviceInfoListCritOut();
    //    CheckCritOut();
    //}
#endif

    TAGMSG2(DBGTAG_PNP, "RequestDeviceChange(%p, %x)", pDeviceInfo, usAction);

    /*
     * Grab the DeviceInfoList critical section if we don't already have it
     */
    UserAssert(!fInDeviceInfoListCrit == !ExIsResourceAcquiredExclusiveLite(gpresDeviceInfoList));

#ifdef TRACK_PNP_NOTIFICATION
    if (gfRecordPnpNotification) {
        if (!fInDeviceInfoListCrit) {
            EnterDeviceInfoListCrit();
        }
        RecordPnpNotification(PNP_NTF_REQUESTDEVICECHANGE, pDeviceInfo, usAction);
        if (!fInDeviceInfoListCrit) {
            LeaveDeviceInfoListCrit();
        }
    }
#endif

#ifdef GENERIC_INPUT
    if (!fInDeviceInfoListCrit) {
        EnterDeviceInfoListCrit();
    }
    CheckDeviceInfoListCritIn();
    pDeviceInfo->usActions |= usAction;
    if ((pDeviceInfo->usActions & (GDIAF_STARTREAD | GDIAF_STOPREAD)) == (GDIAF_STARTREAD | GDIAF_STOPREAD)) {
        pDeviceInfo->usActions &= ~(GDIAF_STARTREAD | GDIAF_STOPREAD);
    }
    if (!fInDeviceInfoListCrit) {
        LeaveDeviceInfoListCrit();
    }

#else

    if (fInDeviceInfoListCrit) {
        CheckDeviceInfoListCritIn();
        pDeviceInfo->usActions |= usAction;
    } else {
        EnterDeviceInfoListCrit();
        pDeviceInfo->usActions |= usAction;
        LeaveDeviceInfoListCrit();
    }

#endif

    if (usAction & GDIAF_PNPWAITING) {

        CheckDeviceInfoListCritIn();
        KeSetEvent(pDevTpl->pkeHidChange, EVENT_INCREMENT, FALSE);
        LeaveDeviceInfoListCrit();
        KeWaitForSingleObject(pDeviceInfo->pkeHidChangeCompleted, WrUserRequest, KernelMode, FALSE, NULL);


#ifdef GENERIC_INPUT
        BESURE_IN_USERCRIT(pDeviceInfo->usActions & GDIAF_FREEME);
#endif
        EnterDeviceInfoListCrit();
        /*
         * Assert that nothing else cleared GDIAF_PNPWAITING - only do it here.
         * Check that the action we were waiting for actually occurred.
         */
        UserAssert(pDeviceInfo->usActions & GDIAF_PNPWAITING);
        pDeviceInfo->usActions &= ~GDIAF_PNPWAITING;
        UserAssert((pDeviceInfo->usActions & usAction) == 0);
        if (pDeviceInfo->usActions & GDIAF_FREEME) {
            FreeDeviceInfo(pDeviceInfo);
        }
#ifdef GENERIC_INPUT
        LeaveDeviceInfoListCrit();
        END_IN_USERCRIT();
        EnterDeviceInfoListCrit();
#endif
    } else {
        KeSetEvent(pDevTpl->pkeHidChange, EVENT_INCREMENT, FALSE);
    }
}



/***************************************************************************\
* RemoveInputDevices()
*
* Used to detach input devices from a session. When disconnecting from a
* session that owns the local input devices we need to release them so that
* the new session that will take ownership of local console can use them
*
\***************************************************************************/
VOID RemoveInputDevices(
    VOID)
{
    PDEVICEINFO pDeviceInfo;
    ULONG DeviceType;
    NTSTATUS Status;


    /*
     * First Thing is to remove device class notification.
     */
    for (DeviceType = 0; DeviceType <= DEVICE_TYPE_MAX; DeviceType++) {
        if (aDeviceClassNotificationEntry[DeviceType] != NULL) {
            IoUnregisterPlugPlayNotification(aDeviceClassNotificationEntry[DeviceType]);
            aDeviceClassNotificationEntry[DeviceType] = NULL;
        }
    }

    /*
     * Then walk the device liste detaching mice and keyboads.
     */

    EnterDeviceInfoListCrit();
    PNP_SAFE_DEVICECRIT_IN();
    pDeviceInfo = gpDeviceInfoList;
    while (pDeviceInfo) {
#ifdef GENERIC_INPUT
        if (pDeviceInfo->usActions & (GDIAF_DEPARTED | GDIAF_FREEME)) {
            pDeviceInfo = pDeviceInfo->pNext;
            continue;
        }
#else
        if ((pDeviceInfo->type != DEVICE_TYPE_KEYBOARD && pDeviceInfo->type != DEVICE_TYPE_MOUSE) ||
            (pDeviceInfo->usActions & GDIAF_DEPARTED) ||
            (pDeviceInfo->usActions & GDIAF_FREEME) ) {
            pDeviceInfo = pDeviceInfo->pNext;
            continue;
        }
#endif
        RequestDeviceChange(pDeviceInfo, GDIAF_DEPARTED, TRUE);
        pDeviceInfo = gpDeviceInfoList;
    }
    LeaveDeviceInfoListCrit();
}


/***************************************************************************\
* AttachInputDevices
*
* Used to Attach  input devices to  a session.
*
\***************************************************************************/
BOOL AttachInputDevices(
    BOOL bLocalDevices)
{
    UNICODE_STRING    ustrName;
    BOOL              fSuccess = TRUE;

    if (!bLocalDevices) {
        RtlInitUnicodeString(&ustrName, NULL);
        fSuccess &= !!CreateDeviceInfo(DEVICE_TYPE_MOUSE, &ustrName, 0);
        fSuccess &= !!CreateDeviceInfo(DEVICE_TYPE_KEYBOARD, &ustrName, 0);


        if (!fSuccess) {
            RIPMSG0(RIP_WARNING, "AttachInputDevices Failed  the creation of input devices");
        }
    } else {
        /*
         * For local devices just register Device class notification and let
         * PnP call us back.
         */
        xxxRegisterForDeviceClassNotifications();
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\ntstubs.c ===
/****************************** Module Header ******************************\
* Module Name: ntstubs.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Kernel-mode stubs
*
* History:
* 03-16-95 JimA             Created.
* 08-12-96 jparsons         Added lparam validate for WM_NCCREATE [51986]
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "cscall.h"

#include <dbt.h>
#define PROTOS_ONLY 1
#include "msgdef.h"

#if DBG

UINT gcMaxNestedCalls = 0;
ULONG_PTR gcMaxUsedStack = 0;
#if defined(_IA64_)
ULONG_PTR gcMaxUsedBStore = 0;
#endif // _IA64_

int ThreadLockCount(
    BOOL fInc)
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    PTL ptl = ptiCurrent->ptl;
    int nLocks = 0;
    ULONG_PTR CurrentUsedSize;

    if (fInc) {
        (ptiCurrent->cNestedCalls)++;

        if (GetNestedCallsCounter() > 50) {
            RIPMSG1(RIP_WARNING, "ThreadLockCount: This thread did %d nested calls.", GetNestedCallsCounter());
        }

        if (ptiCurrent->cNestedCalls > gcMaxNestedCalls) {
            gcMaxNestedCalls = ptiCurrent->cNestedCalls;
        }
    } else {
        (ptiCurrent->cNestedCalls)--;
    }

    if (!ISCSRSS()) {
        CurrentUsedSize = GET_USED_STACK_SIZE();
        if (CurrentUsedSize > gcMaxUsedStack) {
            gcMaxUsedStack = CurrentUsedSize;
        }

#if defined(_IA64_)
        CurrentUsedSize = GET_USED_BSTORE_SIZE();
        if (CurrentUsedSize > gcMaxUsedBStore) {
            gcMaxUsedBStore = CurrentUsedSize;
        }
#endif // _IA64_
    }


    while (ptl != NULL) {
        nLocks++;
        ptl = ptl->next;
    }
    ptl = ptiCurrent->ptlW32;
    while (ptl != NULL) {
        nLocks++;
        ptl = ptl->next;
    }

    return nLocks;
}

VOID ThreadLockCheck(
    int nLocks)
{
    int nNewCount = ThreadLockCount(FALSE);
    if (nLocks != nNewCount) {
        RIPMSG2(RIP_ERROR, "ThreadLocks mismatch %d %d", nLocks, nNewCount);
    }
}

// The parameter is used to ensure BEGINRECV* matches ENDRECV* in each stub.
#define DBG_THREADLOCK_START(s)   { int nLocks ## s = ThreadLockCount(TRUE);
#define DBG_THREADLOCK_END(s)     ThreadLockCheck(nLocks ## s); }
#else // DBG
#define DBG_THREADLOCK_START(s)
#define DBG_THREADLOCK_END(s)
#endif // DBG

/*
 * Setup and control macros
 */
#define BEGINRECV(type, err)    \
    type retval;                \
    type errret = err;          \
    EnterCrit();                \
    DBG_THREADLOCK_START(_)
#define ENDRECV() ENDRECV_(_)

#define BEGINATOMICRECV(type, err)    \
    type retval;                \
    type errret = err;          \
    EnterCrit();                \
    DBG_THREADLOCK_START(_)     \
    BEGINATOMICCHECK()
#define ENDATOMICRECV() ENDATOMICRECV_(_)

#define BEGINRECVCSRSS(type, err)      \
    type retval;                       \
    type errret = err;                 \
    EnterCrit();                       \
    DBG_THREADLOCK_START(CSRSS)          \
    if (!ISCSRSS()) {                  \
        retval = STATUS_ACCESS_DENIED; \
        goto errorexit;                \
    }
#define ENDRECVCSRSS() ENDRECV_(CSRSS)

#define BEGINRECV_SHARED(type, err) \
    type retval;                    \
    type errret = err;              \
    EnterSharedCrit();              \
    DBG_THREADLOCK_START(SHARED)
#define ENDRECV_SHARED() ENDRECV_(SHARED)

#define BEGINRECV_NOCRIT(type, err) \
    type retval;                    \
    type errret = err;

#define BEGINRECV_VOID() \
    EnterCrit();         \
    DBG_THREADLOCK_START(_VOID)
#define ENDRECV_VOID() ENDRECV_VOID_(_VOID)

#define BEGINRECV_HWND(type, err, hwnd)           \
    type retval;                                  \
    type errret = err;                            \
    PWND pwnd;                                    \
    EnterCrit();                                  \
    DBG_THREADLOCK_START(HWND)                    \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {  \
        retval = errret;                          \
        goto errorexit;                           \
    }
#define ENDRECV_HWND() ENDRECV_HWND_(HWND)

#define BEGINATOMICRECV_HWND(type, err, hwnd)     \
    type retval;                                  \
    type errret = err;                            \
    PWND pwnd;                                    \
    EnterCrit();                                  \
    DBG_THREADLOCK_START(HWND)                    \
    BEGINATOMICCHECK()                            \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {  \
        retval = errret;                          \
        goto errorexit;                           \
    }
#define ENDATOMICRECV_HWND() ENDATOMICRECV_HWND_(HWND)

#define BEGINRECV_HWND_VOID(hwnd)                 \
    PWND pwnd;                                    \
    EnterCrit();                                  \
    DBG_THREADLOCK_START(HWND_VOID)               \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {  \
        goto errorexit;                           \
    }
#define ENDRECV_HWND_VOID() ENDRECV_VOID_(HWND_VOID)

#define BEGINRECV_HWND_SHARED(type, err, hwnd)    \
    type retval;                                  \
    type errret = err;                            \
    PWND pwnd;                                    \
    EnterSharedCrit();                            \
    DBG_THREADLOCK_START(HWND_SHARED)             \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {  \
        retval = errret;                          \
        goto errorexit;                           \
    }
#define ENDRECV_HWND_SHARED() ENDRECV_HWND_(HWND_SHARED)

#define BEGINRECV_HWNDOPT_SHARED(type, err, hwnd)    \
    type retval;                                     \
    type errret = err;                               \
    PWND pwnd;                                       \
    EnterSharedCrit();                               \
    DBG_THREADLOCK_START(HWND_OPT_SHARED)              \
    if (hwnd) {                                      \
        if ((pwnd = ValidateHwnd((hwnd))) == NULL) { \
            retval = errret;                         \
            goto errorexit;                          \
        }                                            \
    } else {                                         \
        pwnd = NULL;                                 \
    }
#define ENDRECV_HWNDOPT_SHARED() ENDRECV_HWND_(HWND_OPT_SHARED)

#define BEGINRECV_HWNDLOCK(type, err, hwnd)      \
    type retval;                                 \
    type errret = err;                           \
    PWND pwnd;                                   \
    TL tlpwnd;                                   \
    PTHREADINFO ptiCurrent;                      \
    EnterCrit();                                 \
    DBG_THREADLOCK_START(HWNDLOCK)               \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) { \
        retval = errret;                         \
        goto errorexit2;                         \
    }                                            \
    ptiCurrent = PtiCurrent();                   \
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

#define BEGINRECV_HWNDLOCKFF(type, err, hwnd, xpfnProc)         \
    type retval;                                                \
    type errret = err;                                          \
    PWND pwnd;                                                  \
    TL tlpwnd;                                                  \
    PTHREADINFO ptiCurrent;                                     \
    EnterCrit();                                                \
    DBG_THREADLOCK_START(HWNDLOCK)                              \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {                \
        if (((hwnd == HWND_BROADCAST) || (hwnd == (HWND)-1)) && \
            ((xpfnProc == FNID_SENDNOTIFYMESSAGE) ||            \
            (xpfnProc == FNID_SENDMESSAGECALLBACK))) {          \
                                                                \
            pwnd = PWND_BROADCAST;                              \
            goto ItIsHWND_BROADCAST;                            \
        }                                                       \
        retval = errret;                                        \
        goto errorexit2;                                        \
    }                                                           \
    ptiCurrent = PtiCurrent();                                  \
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);         \
ItIsHWND_BROADCAST:

#define ENDRECV_HWNDLOCK() ENDRECV_HWNDLOCK_(HWNDLOCK)
#define ENDRECV_HWNDLOCKFF() ENDRECV_HWNDLOCK_FF(HWNDLOCK)

#define BEGINRECV_HWNDLOCK_ND(type, err, hwnd)       \
    type retval;                                     \
    type errret = err;                               \
    PWND pwndND;                                     \
    TL tlpwnd;                                       \
    PTHREADINFO ptiCurrent;                          \
    EnterCrit();                                     \
    DBG_THREADLOCK_START(HWNDLOCK_ND)                \
    if (((pwndND = ValidateHwnd((hwnd))) == NULL) || \
            (GETFNID(pwndND) == FNID_DESKTOP) ||     \
            (GETFNID(pwndND) == FNID_MESSAGEWND)) {  \
        retval = errret;                             \
        goto errorexit2;                             \
    }                                                \
    ptiCurrent = PtiCurrent();                       \
    ThreadLockAlwaysWithPti(ptiCurrent, pwndND, &tlpwnd);
#define ENDRECV_HWNDLOCK_ND() ENDRECV_HWNDLOCK_(HWNDLOCK_ND)

#define BEGINRECV_HWNDLOCK_OPT(type, err, hwnd) \
    type retval;                                    \
    type errret = err;                              \
    PWND pwnd;                                      \
    TL tlpwnd;                                      \
    PTHREADINFO ptiCurrent;                         \
    EnterCrit();                                    \
    DBG_THREADLOCK_START(HWNDLOCK_OPT)                \
    if (hwnd) {                                     \
        if ((pwnd = ValidateHwnd(hwnd)) == NULL) {  \
            retval = errret;                        \
            goto errorexit2;                        \
        }                                           \
    } else {                                        \
        pwnd = NULL;                                \
    }                                               \
    ptiCurrent = PtiCurrent();                      \
    ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);
#define ENDRECV_HWNDLOCK_OPT() ENDRECV_HWNDLOCK_(HWNDLOCK_OPT)

#define BEGINRECV_HWNDLOCK_VOID(hwnd) \
    PWND pwnd;                                          \
    TL tlpwnd;                                          \
    PTHREADINFO ptiCurrent;                             \
    EnterCrit();                                        \
    DBG_THREADLOCK_START(HWNDLOCK_VOID)                   \
    if ((pwnd = ValidateHwnd((hwnd))) == NULL) {        \
        goto errorexit2;                                \
    }                                                   \
    ptiCurrent = PtiCurrent();                          \
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);


#define ISXPFNPROCINRANGE(range)                        \
   ((xpfnProc >= SFI_BEGINTRANSLATE ## range) &&        \
    (xpfnProc < SFI_ENDTRANSLATE ## range))

#define VALIDATEXPFNPROC(range)                                 \
    UserAssert(SFI_ENDTRANSLATETABLE == ulMaxSimpleCall);       \
    UserAssert(SFI_ENDTRANSLATE ## range <= ulMaxSimpleCall);   \
    if (!ISXPFNPROCINRANGE(range)) {                            \
        MSGERROR(0);                                             \
    }


#define CLEANUPRECV() \
cleanupexit:

#define ENDRECV_(s)       \
    goto errorexit;       \
errorexit:                \
    DBG_THREADLOCK_END(s) \
    LeaveCrit();          \
    return retval;

#define ENDATOMICRECV_(s) \
    goto errorexit;       \
errorexit:                \
    ENDATOMICCHECK()      \
    DBG_THREADLOCK_END(s) \
    LeaveCrit();          \
    return retval;

#define ENDRECV_NOCRIT() \
    goto errorexit;      \
errorexit:               \
    return retval;

#define ENDRECV_VOID_(s) \
    goto errorexit;      \
errorexit:               \
    DBG_THREADLOCK_END(s)  \
    LeaveCrit();         \
    return;

#define ENDRECV_HWND_(s) \
    goto errorexit;         \
errorexit:                  \
    DBG_THREADLOCK_END(s)     \
    LeaveCrit();            \
    return retval;

#define ENDATOMICRECV_HWND_(s) \
    goto errorexit;         \
errorexit:                  \
    ENDATOMICCHECK()        \
    DBG_THREADLOCK_END(s)   \
    LeaveCrit();            \
    return retval;

#define ENDRECV_HWNDLOCK_(s) \
    goto errorexit;          \
errorexit:                   \
    ThreadUnlock(&tlpwnd);   \
errorexit2:                  \
    DBG_THREADLOCK_END(s)      \
    LeaveCrit();             \
    return retval;

#define ENDRECV_HWNDLOCK_FF(s)      \
    goto errorexit;                 \
errorexit:                          \
    if (pwnd != PWND_BROADCAST) {   \
        ThreadUnlock(&tlpwnd);      \
    }                               \
errorexit2:                         \
    DBG_THREADLOCK_END(s)           \
    LeaveCrit();                    \
    return retval;

#define ENDRECV_HWNDLOCK_VOID() \
    goto errorexit;                 \
errorexit:                          \
    ThreadUnlock(&tlpwnd);          \
errorexit2:                         \
    DBG_THREADLOCK_END(HWNDLOCK_VOID) \
    LeaveCrit();                    \
    return;

/*
 * MSGERROR - exit the stub with an error condition.
 * Parameters:
 * LastError (OPTIONAL):
 * == 0 If LastError is 0, the compiler will optimize away the call to
 *      UserSetLastError(). The last error will not be set to zero!
 * != 0 If you want to SetLastError, provide a non-zero value.
 */
#define MSGERROR(LastError) {        \
    retval = errret;                 \
    if (LastError) {                 \
        UserSetLastError(LastError); \
    }                                \
    goto errorexit; }


#define MSGERROR_VOID() { \
    goto errorexit; }

/*
 * Same as MSGERROR but jumps to cleanup code instead of straight to the return
 */
#define MSGERRORCLEANUP(LastError) { \
    retval = errret;                 \
    if (LastError) {                 \
        UserSetLastError(LastError); \
    }                                \
    goto cleanupexit; }

#define StubExceptionHandler(fSetLastError)  W32ExceptionHandler((fSetLastError), RIP_WARNING)

#define TESTFLAGS(flags, mask) \
    if (((flags) & ~(mask)) != 0) { \
        RIPERR2(ERROR_INVALID_FLAGS, RIP_WARNING, "Invalid flags, %x & ~%x != 0 " #mask, \
            flags, mask); \
        MSGERROR(0);   \
    }

#define LIMITVALUE(value, limit, szText) \
    if ((UINT)(value) > (UINT)(limit)) {     \
        RIPERR3(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid parameter, %d > %d in %s", \
             value, limit, szText); \
        MSGERROR(0);     \
    }

#define MESSAGECALL(api) \
LRESULT NtUserfn ## api( \
    PWND pwnd,           \
    UINT msg,            \
    WPARAM wParam,       \
    LPARAM lParam,       \
    ULONG_PTR xParam,     \
    DWORD xpfnProc,      \
    BOOL bAnsi)

#define BEGINRECV_MESSAGECALL(err)      \
    LRESULT retval;                     \
    LRESULT errret = err;               \
    PTHREADINFO ptiCurrent = PtiCurrent(); \
    CheckCritIn();

#define ENDRECV_MESSAGECALL()           \
    goto errorexit;                     \
errorexit:                              \
    return retval;

#define BEGINRECV_HOOKCALL()            \
    LRESULT retval;                     \
    LRESULT errret = 0;                 \
    CheckCritIn();

#define ENDRECV_HOOKCALL()              \
    goto errorexit;                     \
errorexit:                              \
    return retval;

#define CALLPROC(p) FNID(p)

/*
 * Validation macros
 */
#define ValidateHWNDNoRIP(p,h)              \
    if ((p = ValidateHwnd(h)) == NULL)      \
        MSGERROR(0);

#define ValidateHWND(p,h)                   \
    if ((p = ValidateHwnd(h)) == NULL)      \
        MSGERROR(0);

#define ValidateHWNDND(p,h)                 \
    if ( ((p = ValidateHwnd(h)) == NULL) || \
         (GETFNID(p) == FNID_DESKTOP) ||    \
         (GETFNID(p) == FNID_MESSAGEWND)    \
        )       \
        MSGERROR(0);

#define ValidateHWNDOPT(p,h) \
    if (h) {                                \
        if ((p = ValidateHwnd(h)) == NULL)  \
            MSGERROR(0);                     \
    } else {                                \
        p = NULL;                           \
    }

#define ValidateHWNDIA(p,h)                      \
    if (h != HWND_TOP &&                         \
        h != HWND_BOTTOM &&                      \
        h != HWND_TOPMOST &&                     \
        h != HWND_NOTOPMOST) {                   \
        if ( ((p = ValidateHwnd(h)) == NULL) ||  \
             (GETFNID(p) == FNID_DESKTOP) ||     \
             (GETFNID(p) == FNID_MESSAGEWND)     \
            )        \
            MSGERROR(0);                          \
    } else {                                     \
        p = (PWND)h;                             \
    }

#define ValidateHMENUOPT(p,h) \
    if (h) {                                \
        if ((p = ValidateHmenu(h)) == NULL) \
            MSGERROR(0);                    \
    } else {                                \
        p = NULL;                           \
    }

#define ValidateHMENU(p,h) \
    if ((p = ValidateHmenu(h)) == NULL) \
        MSGERROR(0);

#define ValidateHMENUMODIFY(p,h) \
    if ((p = ValidateHmenu(h)) == NULL)  {          \
        MSGERROR(0);                                \
    } else if (TestMF(p, MFDESKTOP)) { \
        RIPMSG1(RIP_WARNING, "ValidateHMENUMODIFY: Attempt to modify desktop menu:%#p", p); \
        MSGERROR(0);                                \
    }

#define ValidateHMENUMODIFYCHECKLOCK(p,h) \
    if ((p = ValidateHmenu(h)) == NULL)  {          \
        MSGERROR(0);                                \
    } else if (TestMF(p, MFDESKTOP)) { \
        RIPMSG1(RIP_WARNING, "ValidateHMENUMODIFYCHECKLOCK: Attempt to modify desktop menu:%#p", p); \
        MSGERROR(0);                                \
    } else if (TestMF(p, MFREADONLY)) { \
        RIPMSG1(RIP_WARNING, "ValidateHMENUMODIFYCHECKLOCK: Attempt to modify RO menu: %#p", p); \
        MSGERROR(0);                                \
    }

#define ValidateHACCEL(p,h) \
    if ((p = HMValidateHandle(h, TYPE_ACCELTABLE)) == NULL) \
        MSGERROR(0);

#define ValidateHCURSOR(p,h) \
    if ((p = HMValidateHandle(h, TYPE_CURSOR)) == NULL) \
        MSGERROR(0);

#define ValidateHCURSOROPT(p,h) \
    if (h) {                                 \
        if ((p = HMValidateHandle(h, TYPE_CURSOR)) == NULL) \
        MSGERROR(0);                          \
    } else {                                \
        p = NULL;                           \
    }

#define ValidateHICON(p,h) \
    if ((p = HMValidateHandle(h, TYPE_CURSOR)) == NULL) \
        MSGERROR(0);

#define ValidateHHOOK(p,h) \
    if ((p = HMValidateHandle(h, TYPE_HOOK)) == NULL) \
        MSGERROR(0);

#define ValidateHWINEVENTHOOK(p,h) \
    if ((p = HMValidateHandle(h, TYPE_WINEVENTHOOK)) == NULL) \
        MSGERROR(0);

#define ValidateHDWP(p,h) \
    if ((p = HMValidateHandle(h, TYPE_SETWINDOWPOS)) == NULL) \
        MSGERROR(0);

#define ValidateHMONITOR(p,h) \
    if ((p = ValidateHmonitor(h)) == NULL) \
        MSGERROR(0);

#define ValidateHIMC(p,h) \
    if ((p = HMValidateHandle((HANDLE)h, TYPE_INPUTCONTEXT)) == NULL) \
        MSGERROR(0);

#define ValidateHIMCOPT(p,h) \
    if (h) {                                                              \
        if ((p = HMValidateHandle((HANDLE)h, TYPE_INPUTCONTEXT)) == NULL) \
            MSGERROR(0);                                                   \
    } else {                                                              \
        p = NULL;                                                         \
    }

#define ValidateIMMEnabled()                                                                    \
    if (!IS_IME_ENABLED()) {                                                                    \
        RIPERR0(ERROR_CALL_NOT_IMPLEMENTED, RIP_VERBOSE, "IME is disabled in this system.");    \
        MSGERROR(0); \
    }

#define ValidateIMMEnabledVOID()                                                                \
    if (!IS_IME_ENABLED()) {                                                                    \
        RIPERR0(ERROR_CALL_NOT_IMPLEMENTED, RIP_VERBOSE, "IME is disabled in this system.");    \
        MSGERROR_VOID();                                                                        \
    }


#define DOWNCAST(type, value)  ((type)(ULONG_PTR)(value))

NTSTATUS
NtUserRemoteConnect(
    IN PDOCONNECTDATA pDoConnectData,
    IN ULONG DisplayDriverNameLength,
    IN PWCHAR DisplayDriverName )
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }

    /*
     * Probe all read arguments -- no try block.
     */
#if DBG
    ProbeForRead(DisplayDriverName, DisplayDriverNameLength, sizeof(BYTE));
    ProbeForRead(pDoConnectData, sizeof(DOCONNECTDATA), sizeof(BYTE));
#endif

    retval = RemoteConnect(
                 pDoConnectData,
                 DisplayDriverNameLength,
                 DisplayDriverName);


    TRACE("NtUserRemoteConnect");
    ENDRECVCSRSS();

}

NTSTATUS
NtUserRemoteRedrawRectangle(
    IN WORD Left,
    IN WORD Top,
    IN WORD Right,
    IN WORD Bottom )
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);
    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }

    retval = RemoteRedrawRectangle(
                 Left,
                 Top,
                 Right,
                 Bottom);

    TRACE("NtUserRemoteRedrawRectangle");
    ENDRECVCSRSS();
}


NTSTATUS
NtUserRemoteRedrawScreen(
    VOID)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);
    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }

    /*
     * If there are any shadow connections, or it's not disconnected
     */
    if (gnShadowers > 0 || gbConnected)
        retval = RemoteRedrawScreen();
    else
        retval = STATUS_UNSUCCESSFUL;

    TRACE("NtUserRemoteRedrawScreen");
    ENDRECVCSRSS();
}


NTSTATUS
NtUserRemoteStopScreenUpdates(
    VOID)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);
    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }
    if (!gfSwitchInProgress) {
        retval = xxxRemoteStopScreenUpdates(TRUE);
    } else {
        retval = STATUS_UNSUCCESSFUL;
    }

    TRACE("NtUserRemoteStopScreenUpdates");
    ENDRECVCSRSS();
}

NTSTATUS
NtUserCtxDisplayIOCtl(
    IN ULONG  DisplayIOCtlFlags,
    IN PUCHAR pDisplayIOCtlData,
    IN ULONG  cbDisplayIOCtlData)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);
    if (!ISTS()) {
        errret = STATUS_ACCESS_DENIED;
        MSGERROR(0);
    }

    /*
     * Probe all read arguments
     */
#if DBG
    ProbeForRead(pDisplayIOCtlData, cbDisplayIOCtlData, sizeof(BYTE));
#endif

    retval = CtxDisplayIOCtl(
                 DisplayIOCtlFlags,
                 pDisplayIOCtlData,
                 cbDisplayIOCtlData);

    TRACE("NtUserCtxDisplayIOCtl");
    ENDRECVCSRSS();

}

UINT NtUserHardErrorControl(
    IN HARDERRORCONTROL dwCmd,
    IN HANDLE handle,
    OUT PDESKRESTOREDATA pdrdRestore OPTIONAL)
{
    BEGINRECVCSRSS(BOOL, HEC_ERROR);

#if DBG
    if (ARGUMENT_PRESENT(pdrdRestore)) {
        ProbeForWrite(pdrdRestore, sizeof(DESKRESTOREDATA), sizeof(DWORD));
    }
#endif

    retval = xxxHardErrorControl(dwCmd, handle, pdrdRestore);

    TRACE("NtUserHardErrorControl");
    ENDRECVCSRSS();
}

BOOL NtUserGetObjectInformation(  // API GetUserObjectInformationA/W
    IN HANDLE hObject,
    IN int nIndex,
    OUT PVOID pvInfo,
    IN DWORD nLength,
    OUT OPTIONAL LPDWORD pnLengthNeeded)
{
    DWORD dwAlign;
    DWORD dwLocalLength;
    BEGINATOMICRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        dwAlign = sizeof(BYTE);
#else
        if (nIndex == UOI_FLAGS)
            dwAlign = sizeof(DWORD);
        else
            dwAlign = sizeof(WCHAR);
#endif
        ProbeForWrite(pvInfo, nLength, dwAlign);
        if (ARGUMENT_PRESENT(pnLengthNeeded))
            ProbeForWriteUlong(pnLengthNeeded);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Make sure the handle doesn't get closed while we're playing with it.
     */
    SetHandleInUse(hObject);

    /*
     * pvInfo is client-side. GetUserObjectInformation
     * protects use of this pointer with try blocks.
     */

    retval = _GetUserObjectInformation(hObject,
            nIndex, pvInfo,
            nLength, &dwLocalLength);

    /*
     * OK, we're done with the handle.
     */
    SetHandleInUse(NULL);

    if (ARGUMENT_PRESENT(pnLengthNeeded)) {
        try {
            *pnLengthNeeded = dwLocalLength;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetObjectInformation");
    ENDATOMICRECV();
}

BOOL NtUserWin32PoolAllocationStats(
    IN  LPDWORD parrTags,
    IN  SIZE_T  tagsCount,
    OUT SIZE_T* lpdwMaxMem,
    OUT SIZE_T* lpdwCrtMem,
    OUT LPDWORD lpdwMaxAlloc,
    OUT LPDWORD lpdwCrtAlloc)
{
#ifdef POOL_INSTR_API
    SIZE_T  dwMaxMem, dwCrtMem;
    DWORD   dwMaxAlloc, dwCrtAlloc;

    BEGINRECV(BOOL, FALSE);

    retval = _Win32PoolAllocationStats(parrTags,
                                       tagsCount,
                                       &dwMaxMem,
                                       &dwCrtMem,
                                       &dwMaxAlloc,
                                       &dwCrtAlloc);
    /*
     * Probe and copy
     */
    try {
        if (lpdwMaxMem != NULL) {
            ProbeForWrite(lpdwMaxMem, sizeof(SIZE_T), sizeof(DWORD));
            *lpdwMaxMem = dwMaxMem;
        }
        if (lpdwCrtMem != NULL) {
            ProbeForWrite(lpdwCrtMem, sizeof(SIZE_T), sizeof(DWORD));
            *lpdwCrtMem = dwCrtMem;
        }
        if (lpdwMaxAlloc != NULL) {
            ProbeForWrite(lpdwMaxAlloc, sizeof(DWORD), sizeof(DWORD));
            *lpdwMaxAlloc = dwMaxAlloc;
        }
        if (lpdwCrtAlloc != NULL) {
            ProbeForWrite(lpdwCrtAlloc, sizeof(DWORD), sizeof(DWORD));
            *lpdwCrtAlloc = dwCrtAlloc;
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserWin32PoolAllocationStats");
    ENDRECV();
#else
    UNREFERENCED_PARAMETER(parrTags);
    UNREFERENCED_PARAMETER(tagsCount);
    UNREFERENCED_PARAMETER(lpdwMaxMem);
    UNREFERENCED_PARAMETER(lpdwCrtMem);
    UNREFERENCED_PARAMETER(lpdwMaxAlloc);
    UNREFERENCED_PARAMETER(lpdwCrtAlloc);
    return FALSE;
#endif // POOL_INSTR_API
}

#if DBG

VOID NtUserDbgWin32HeapFail( // private DbgWin32HeapFail
    IN DWORD dwFlags,
    IN BOOL  bFail)
{
    BEGINRECV_VOID();

    if ((dwFlags | WHF_VALID) != WHF_VALID) {
        RIPMSG1(RIP_WARNING, "Invalid flags for DbgWin32HeapFail %x", dwFlags);
        MSGERROR_VOID();
    }

    Win32HeapFailAllocations(bFail);

    TRACEVOID("NtUserDbgWin32HeapFail");
    ENDRECV_VOID();
}

DWORD  NtUserDbgWin32HeapStat( // private DbgWin32HeapStat
    PDBGHEAPSTAT phs,
    DWORD dwLen)
{
    extern DWORD Win32HeapStat(PDBGHEAPSTAT phs, DWORD dwLen, BOOL bTagsAreShift);

    DBGHEAPSTAT localHS[30];
    BEGINRECV(DWORD, 0);

    LIMITVALUE(dwLen, sizeof(localHS), "DbgWin32HeapStat");

    try{
        ProbeForRead(phs, dwLen, CHARALIGN);
        RtlCopyMemory(localHS, phs, dwLen);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = Win32HeapStat(localHS, dwLen, FALSE);

    try {
        ProbeForWrite(phs, dwLen, CHARALIGN);
        RtlCopyMemory(phs, localHS, dwLen);
    } except (StubExceptionHandler(FALSE)) {
    }
    TRACE("NtUserDbgWin32HeapStat");
    ENDRECV();
}
#endif // DBG

BOOL NtUserSetObjectInformation(  // API SetUserObjectInformationA/W
    IN HANDLE hObject,
    IN int nIndex,
    IN PVOID pvInfo,
    IN DWORD nLength)
{
    BEGINATOMICRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(pvInfo, nLength, DATAALIGN);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Make sure the handle doesn't get closed while we're playing with it.
     */
    SetHandleInUse(hObject);

    /*
     * pvInfo is client-side. SetUserObjectInformation
     * protects use of this pointer with try blocks.
     */
    retval = _SetUserObjectInformation(hObject,
                nIndex, pvInfo, nLength);

    /*
     * OK, we're done with the handle.
     */
    SetHandleInUse(NULL);

    TRACE("NtUserSetObjectInformation");
    ENDATOMICRECV();
}

NTSTATUS NtUserConsoleControl(  // private NtUserConsoleControl
    IN CONSOLECONTROL ConsoleCommand,
    IN PVOID ConsoleInformation,
    IN DWORD ConsoleInformationLength)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

#if DBG
    ProbeForWrite(ConsoleInformation,
                  ConsoleInformationLength,
                  sizeof(WORD));
#endif

    retval = xxxConsoleControl(ConsoleCommand,
                                ConsoleInformation,
                                ConsoleInformationLength);

    TRACE("NtUserConsoleControl");
    ENDRECVCSRSS();
}

HWINSTA NtUserCreateWindowStation(  // API CreateWindowStationA/W
    IN POBJECT_ATTRIBUTES pObja,
    IN ACCESS_MASK        amRequest,
    IN HANDLE             hKbdLayoutFile,
    IN DWORD              offTable,
    IN PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    IN PUNICODE_STRING    pstrKLID,
    UINT                  uKbdInputLocale)

{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           CapturedAttributes;
    SECURITY_QUALITY_OF_SERVICE qosCaptured;
    PSECURITY_DESCRIPTOR        psdCaptured = NULL;
    LUID                        luidService;
    UNICODE_STRING              strWinSta;
    UNICODE_STRING              strKLID;
    KBDTABLE_MULTI_INTERNAL     kbdTableMulti;
    WCHAR                       awchName[MAX_SESSION_PATH];
    WCHAR                       awchKF[KL_NAMELENGTH];
    UINT                        chMax;
    KPROCESSOR_MODE             OwnershipMode;

    BEGINRECV(HWINSTA, NULL);

    /*
     * Set status so we can clean up in case of failure
     */
    Status = STATUS_SUCCESS;

    try {
        /*
         * Probe and capture the ??? string
         */
        strKLID = ProbeAndReadUnicodeString(pstrKLID);
        ProbeForReadUnicodeStringBuffer(strKLID);
        chMax = min(sizeof(awchKF) - sizeof(WCHAR), strKLID.Length) / sizeof(WCHAR);
        wcsncpycch(awchKF, strKLID.Buffer, chMax);
        awchKF[chMax] = 0;

        kbdTableMulti = ProbeAndReadStructure(pKbdTableMulti, KBDTABLE_MULTI_INTERNAL);
        if (kbdTableMulti.multi.nTables >= KBDTABLE_MULTI_MAX) {
            RIPMSG1(RIP_WARNING, "NtUserCreateWindowStation: kbdTableMulti.multi.nTables too big: %x", kbdTableMulti.multi.nTables);
            MSGERROR(ERROR_INVALID_PARAMETER);
        }

        /*
         * Probe and capture the object attributes
         */
        CapturedAttributes = ProbeAndReadStructure(pObja, OBJECT_ATTRIBUTES);

        /*
         * Probe and capture all other components of the object attributes.
         */
        if (CapturedAttributes.ObjectName == NULL && CapturedAttributes.RootDirectory == NULL) {

            /*
             * Use the logon authentication id to form the windowstation
             * name.
             */
            Status = GetProcessLuid(NULL, &luidService);
            if (NT_SUCCESS(Status)) {
                swprintf(awchName, L"%ws\\Service-0x%x-%x$",
                        szWindowStationDirectory,
                        luidService.HighPart, luidService.LowPart);
                RtlInitUnicodeString(&strWinSta, awchName);
                CapturedAttributes.ObjectName = &strWinSta;
            }
            OwnershipMode = KernelMode;
        } else {
            strWinSta = ProbeAndReadUnicodeString(CapturedAttributes.ObjectName);
            ProbeForReadUnicodeStringBuffer(strWinSta);
            /*
             * Use the StaticUnicodeBuffer on the TEB as the buffer for the object name.
             * Even if this is client side and we pass KernelMode to the Ob call in
             * _OpenWindowStation this is safe because the TEB is not going to go away
             * during this call. The worst it can happen is to have the buffer in the TEB
             * trashed.
             */
            strWinSta.Length = min(strWinSta.Length, STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR));

            RtlCopyMemory(NtCurrentTeb()->StaticUnicodeBuffer,
                          strWinSta.Buffer,
                          strWinSta.Length);

            strWinSta.Buffer = NtCurrentTeb()->StaticUnicodeBuffer;
            CapturedAttributes.ObjectName = &strWinSta;
            OwnershipMode = UserMode;
        }

        if (CapturedAttributes.SecurityQualityOfService) {
            PSECURITY_QUALITY_OF_SERVICE pqos;

            pqos = CapturedAttributes.SecurityQualityOfService;
            qosCaptured = ProbeAndReadStructure(pqos, SECURITY_QUALITY_OF_SERVICE);
            CapturedAttributes.SecurityQualityOfService = &qosCaptured;
        }

        if (NT_SUCCESS(Status) && CapturedAttributes.SecurityDescriptor != NULL) {
            Status = SeCaptureSecurityDescriptor(
                    CapturedAttributes.SecurityDescriptor,
                    UserMode,
                    PagedPool,
                    FALSE,
                    &psdCaptured);
            if (!NT_SUCCESS(Status)) {
                psdCaptured = NULL;
            }
            CapturedAttributes.SecurityDescriptor = psdCaptured;
        }

    } except (StubExceptionHandler(FALSE)) {
        Status = GetExceptionCode();
    }
    if (!NT_SUCCESS(Status))
        MSGERRORCLEANUP(ERROR_INVALID_PARAMETER);

    /*
     * Create the windowstation and return a kernel handle.
     */
    retval = xxxCreateWindowStation(&CapturedAttributes,
                                    OwnershipMode,
                                    amRequest,
                                    hKbdLayoutFile,
                                    offTable,
                                    &kbdTableMulti,
                                    awchKF,
                                    uKbdInputLocale);

    CLEANUPRECV();

    /*
     * Release captured security descriptor.
     */
    if (psdCaptured != NULL) {
        SeReleaseSecurityDescriptor(
                psdCaptured,
                UserMode,
                FALSE);
    }

    TRACE("NtUserCreateWindowStation");
    ENDRECV();
}


HWINSTA NtUserOpenWindowStation(
    IN OUT POBJECT_ATTRIBUTES pObja,
    IN ACCESS_MASK amRequest)
{
    NTSTATUS                    Status;
    LUID                        luidService;
    WCHAR                       awchName[sizeof(L"Service-0x0000-0000$") / sizeof(WCHAR)];
    OBJECT_ATTRIBUTES           Obja;
    UNICODE_STRING              ObjectName;

    BEGINRECV(HWINSTA, NULL);

    retval = NULL;

    /*
     * NT Bug 387849: We want to allow the caller to pass in a "template" to be
     * filled in for the Service windowstation. So, we need to walk through the
     * pObja structure and check the string out, replacing it with the real
     * object name if necessary.
     *
     * It is VERY important that we pass the pObja object to the executive
     * (through _OpenWindowStation) and not the Obja object. This is because we
     * will request UserMode for this object, and the executive will check that
     * it is actually getting a user-mode address.
     *
     * We will still make a copy of the structures to manipulate while we are
     * walking everything so that we don't need to worry about the rug being
     * removed from beneath us. The executive will do its own checking.
     */

    try {
        /*
         * Probe the object attributes. We need to be able to read the
         * OBJECT_ATTRIBUTES and to write the ObjectName (UNICODE_STRING).
         */
        Obja = ProbeAndReadStructure(pObja, OBJECT_ATTRIBUTES);

        ProbeForWrite(Obja.ObjectName, sizeof(*(Obja.ObjectName)), DATAALIGN);

        ObjectName = ProbeAndReadUnicodeString(Obja.ObjectName);

        /*
         * If we are trying to open the NULL or "" WindowStation, remap this
         * benign name to Service-0x????-????$.
         */
        if (Obja.RootDirectory != NULL &&
                ObjectName.Buffer != NULL &&
                ObjectName.MaximumLength == sizeof(awchName) &&
                ObjectName.Length == (sizeof(awchName) - sizeof(UNICODE_NULL))) {

            /*
             * Use the logon authentication id to form the windowstation
             * name. Put this in the user's buffer since we were the one
             * who allocated it in OpenWindowStation.
             */

            ProbeForWrite(ObjectName.Buffer, ObjectName.MaximumLength, CHARALIGN);

            if (!_wcsicmp(ObjectName.Buffer, L"Service-0x0000-0000$")) {
                Status = GetProcessLuid(NULL, &luidService);
                if (NT_SUCCESS(Status)) {
                    swprintf(ObjectName.Buffer,
                              L"Service-0x%x-%x$",
                              luidService.HighPart,
                              luidService.LowPart);
                    /*
                     * We need to re-initialize the string to get the counted
                     * length correct. Otherwise the hashing function used
                     * by ObpLookupDirectoryEntry will fail.
                     */
                    RtlInitUnicodeString(Obja.ObjectName, ObjectName.Buffer);
                }
            }
        }

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Open the WindowStation
     */
    retval = _OpenWindowStation(pObja, amRequest, UserMode);

    TRACE("NtUserOpenWindowStation");
    ENDRECV();

    UNREFERENCED_PARAMETER(awchName);
}

BOOL NtUserCloseWindowStation(
    IN HWINSTA hwinsta)
{
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    retval = FALSE;

    Status = ValidateHwinsta(hwinsta, UserMode, 0, &pwinsta);
    if (NT_SUCCESS(Status)) {
        retval = _CloseWindowStation(hwinsta);
        ObDereferenceObject(pwinsta);
    }

    TRACE("NtUserCloseWindowStation");
    ENDRECV();
}


BOOL NtUserSetProcessWindowStation(
    IN HWINSTA hwinsta)
{
    BEGINRECV(BOOL, FALSE);

    retval = NT_SUCCESS(xxxSetProcessWindowStation(hwinsta, UserMode));

    TRACE("NtUserSetProcessWindowStation");
    ENDRECV();
}

HWINSTA NtUserGetProcessWindowStation(
    VOID)
{
    BEGINRECV_SHARED(HWINSTA, NULL);

    _GetProcessWindowStation(&retval);

    TRACE("NtUserGetProcessWindowStation");
    ENDRECV_SHARED();
}

BOOL NtUserLockWorkStation(
    VOID)
{
    BEGINRECV(BOOL, FALSE);

    retval = _LockWorkStation();

    TRACE("NtUserLockWorkStation");
    ENDRECV();
}


HDESK NtUserCreateDesktop(  // API CreateDesktopA/W
    IN POBJECT_ATTRIBUTES pObja,
    IN PUNICODE_STRING pstrDevice,
    IN LPDEVMODEW pDevmode,
    IN DWORD dwFlags,
    IN ACCESS_MASK amRequest)
{
    BEGINRECV(HDESK, NULL);

    /*
     * Fail this call for restricted threads
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_DESKTOP)) {
        RIPMSG0(RIP_WARNING, "NtUserCreateDesktop failed for restricted thread");
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(pObja, sizeof(*pObja), sizeof(DWORD));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * pObja, pDevmode, and pstrDevice are all client side addresses.
     *
     * pstrDevice and pDevmode are put into the Context info,
     * and they are used in ntgdi\dre\drvsup.cxx,
     * where thay are captured before use.

     */

    retval = xxxCreateDesktop(pObja,
                              UserMode,
                              pstrDevice,
                              pDevmode,
                              dwFlags,
                              amRequest);

    TRACE("NtUserCreateDesktop");
    ENDRECV();
}

HDESK NtUserOpenDesktop(
    IN POBJECT_ATTRIBUTES pObja,
    IN DWORD dwFlags,
    IN ACCESS_MASK amRequest)
{
    BOOL bShutDown;

    BEGINRECV(HDESK, NULL);

    retval = _OpenDesktop(pObja, UserMode, dwFlags, amRequest, &bShutDown);

    TRACE("NtUserOpenDesktop");
    ENDRECV();
}


HDESK NtUserOpenInputDesktop(
    IN DWORD dwFlags,
    IN BOOL fInherit,
    IN DWORD amRequest)
{
    HWINSTA        hwinsta;
    PWINDOWSTATION pwinsta;
    PDESKTOP       pdesk;
    NTSTATUS       Status;

    BEGINRECV(HDESK, NULL);

    if (grpdeskRitInput == NULL) {
        MSGERROR(ERROR_OPEN_FAILED);
    } else {
        pwinsta = _GetProcessWindowStation(&hwinsta);
        if (pwinsta == NULL) {
            MSGERROR(ERROR_ACCESS_DENIED);
        }
        if (pwinsta->dwWSF_Flags & WSF_NOIO) {
            MSGERROR(ERROR_INVALID_FUNCTION);
        } else {

            /*
             * We should never return the 'Disconnect' desktop to
             * an app. We should return instead the desktop that we will
             * restore to from the Disconnect desktop.
             */

            pdesk = (gbDesktopLocked ? gspdeskShouldBeForeground : grpdeskRitInput);
            if (pdesk == NULL) {
                MSGERROR(ERROR_OPEN_FAILED);
            }

            /*
             * Require read/write access
             */
            amRequest |= DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS;

            Status = ObOpenObjectByPointer(
                    pdesk,
                    fInherit ? OBJ_INHERIT : 0,
                    NULL,
                    amRequest,
                    *ExDesktopObjectType,
                    UserMode,
                    &retval);
            if (NT_SUCCESS(Status)) {

                BOOL bShutDown;
                /*
                 * Complete the desktop open
                 */
                if (!OpenDesktopCompletion(pdesk, retval,
                    dwFlags, &bShutDown)) {

                    CloseProtectedHandle(retval);
                    retval = NULL;
                } else {
                    SetHandleFlag(retval, HF_PROTECTED, TRUE);
                }
            } else
                retval = NULL;
        }
    }
    TRACE("NtUserOpenInputDesktop");
    ENDRECV();
}


NTSTATUS NtUserResolveDesktopForWOW (  // WOW ResolveDesktopForWOW
    IN OUT PUNICODE_STRING pstrDesktop)
{
    UNICODE_STRING strDesktop, strDesktop2;
    PTHREADINFO ptiCurrent;
    TL tlBuffer;
    LPWSTR lpBuffer = NULL;
    BOOL fFreeBuffer = FALSE;
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    retval = STATUS_SUCCESS;

    ptiCurrent = PtiCurrent();
    /*
     * Probe arguments
     */
    try {
        strDesktop = ProbeAndReadUnicodeString(pstrDesktop);
        ProbeForReadUnicodeStringFullBuffer(strDesktop);
        RtlCopyMemory(&strDesktop2, &strDesktop, sizeof strDesktop);
        if (strDesktop.MaximumLength > 0) {
            PWSTR pszCapture = strDesktop.Buffer;
            strDesktop.Buffer = UserAllocPoolWithQuota(strDesktop.MaximumLength, TAG_TEXT2);
            if (strDesktop.Buffer) {
                fFreeBuffer = TRUE;
                ThreadLockPool(ptiCurrent, strDesktop.Buffer, &tlBuffer);
                RtlCopyMemory(strDesktop.Buffer, pszCapture, strDesktop.Length);
            } else
                ExRaiseStatus(STATUS_NO_MEMORY);

        } else {
            strDesktop.Buffer = NULL;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    retval = xxxResolveDesktopForWOW(&strDesktop);

    if (NT_SUCCESS(retval)) {
        try {
            /*
             * The string structure at pstrDesktop could have changed
             * so we will ignore it and drop the one we have already
             * probed down on top of it. We have already performed the
             * ResolveDesktopForWOW action, so we should not return an
             * error if this copy fails.
             */

            RtlCopyUnicodeString(&strDesktop2, &strDesktop);
            RtlCopyMemory(pstrDesktop, &strDesktop2, sizeof strDesktop2);
        } except (StubExceptionHandler(FALSE)) {
        }
    }

CLEANUPRECV();
    if (fFreeBuffer)
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);
    TRACE("NtUserResolveDesktopForWOW");
    ENDRECV();
}

HDESK NtUserResolveDesktop(
    IN HANDLE hProcess,
    IN PUNICODE_STRING pstrDesktop,
    IN BOOL fInherit,
    OUT HWINSTA *phwinsta)
{
    UNICODE_STRING strDesktop;
    HWINSTA hwinsta = NULL;
    PTHREADINFO pti;
    TL tlBuffer;
    BOOL fFreeBuffer = FALSE;
    BOOL bShutDown = FALSE;

    BEGINRECV(HDESK, NULL);

    pti = PtiCurrent();
    /*
     * Probe and capture desktop path
     */
    try {
        strDesktop = ProbeAndReadUnicodeString(pstrDesktop);
        if (strDesktop.Length > 0) {
            PWSTR pszCapture = strDesktop.Buffer;
            ProbeForReadUnicodeStringBuffer(strDesktop);
            strDesktop.Buffer = UserAllocPoolWithQuota(strDesktop.Length, TAG_TEXT2);
            if (strDesktop.Buffer) {
                fFreeBuffer = TRUE;
                ThreadLockPool(pti, strDesktop.Buffer, &tlBuffer);
                RtlCopyMemory(strDesktop.Buffer, pszCapture, strDesktop.Length);
            } else
                ExRaiseStatus(STATUS_NO_MEMORY);
        } else {
            strDesktop.Buffer = NULL;
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    retval = xxxResolveDesktop(hProcess, &strDesktop, &hwinsta,
            fInherit, &bShutDown);

    CLEANUPRECV();
    if (fFreeBuffer)
        ThreadUnlockAndFreePool(pti, &tlBuffer);

    if (retval != NULL) {
        try {
            ProbeAndWriteHandle((PHANDLE)phwinsta, hwinsta);
        } except (StubExceptionHandler(TRUE)) {
            xxxCloseDesktop(retval, KernelMode);
            if (hwinsta)
                _CloseWindowStation(hwinsta);
            MSGERROR(0);
        }
    } else {
        UserAssert(hwinsta == NULL);
    }

    TRACE("NtUserResolveDesktop");
    ENDRECV();
}

BOOL NtUserCloseDesktop(
    IN HDESK hdesk)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxCloseDesktop(hdesk, UserMode);

    TRACE("NtUserCloseDesktop");
    ENDRECV();
}

BOOL NtUserSetThreadDesktop(
    IN HDESK hdesk)
{
    PDESKTOP pdesk = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    BEGINRECV(BOOL, FALSE);
    Status = ValidateHdesk(hdesk, UserMode, 0, &pdesk);
    if (NT_SUCCESS(Status)) {
        retval = xxxSetThreadDesktop(hdesk, pdesk);
        LogDesktop(pdesk, LD_DEREF_VALIDATE_HDESK1, FALSE, (ULONG_PTR)PtiCurrent());
        ObDereferenceObject(pdesk);
    } else if (hdesk == NULL && PsGetCurrentProcess() == gpepCSRSS) {
        retval = xxxSetThreadDesktop(NULL, NULL);
    } else
        retval = FALSE;

    TRACE("NtUserSetThreadDesktop");
    ENDRECV();
}

HDESK NtUserGetThreadDesktop(
    IN DWORD dwThreadId,
    IN HDESK hdeskConsole)
{
    BEGINRECV_SHARED(HDESK, NULL);

    retval = xxxGetThreadDesktop(dwThreadId, hdeskConsole, UserMode);

    TRACE("NtUserGetThreadDesktop");
    ENDRECV_SHARED();
}

BOOL NtUserSwitchDesktop(
    IN HDESK hdesk)
{
    PDESKTOP pdesk;
    TL tlpdesk;
    PTHREADINFO ptiCurrent;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    ptiCurrent = PtiCurrent();

    /*
     * Fail this call for restricted threads
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_DESKTOP)) {
        RIPMSG0(RIP_WARNING, "NtUserSwitchDesktop failed for restricted thread");
        MSGERROR(0);
    }

    Status = ValidateHdesk(hdesk, UserMode, DESKTOP_SWITCHDESKTOP, &pdesk);
    if (NT_SUCCESS(Status)) {
        if (pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO) {
            LogDesktop(pdesk, LD_DEREF_VALIDATE_HDESK2, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdesk);
            RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "");
            retval = FALSE;
        } else {
            ThreadLockDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_NTUSERSWITCHDESKTOP);
            LogDesktop(pdesk, LD_DEREF_VALIDATE_HDESK3, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdesk);
            retval = xxxSwitchDesktop(NULL, pdesk, 0);
            ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_NTUSERSWITCHDESKTOP);
        }
    } else
        retval = FALSE;

    TRACE("NtUserSwitchDesktop");
    ENDRECV();
}

NTSTATUS NtUserInitializeClientPfnArrays(  // private
    IN CONST PFNCLIENT *ppfnClientA OPTIONAL,
    IN CONST PFNCLIENT *ppfnClientW OPTIONAL,
    IN CONST PFNCLIENTWORKER *ppfnClientWorker OPTIONAL,
    IN HANDLE hModUser)
{
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * Probe all read arguments
     */
    try {
        if (ARGUMENT_PRESENT(ppfnClientA)) {
            ProbeForRead(ppfnClientA, sizeof(*ppfnClientA), sizeof(DWORD));
        }
        if (ARGUMENT_PRESENT(ppfnClientW)) {
            ProbeForRead(ppfnClientW, sizeof(*ppfnClientW), sizeof(DWORD));
        }

        if (ARGUMENT_PRESENT(ppfnClientWorker)) {
            ProbeForRead(ppfnClientWorker, sizeof(*ppfnClientWorker), sizeof(DWORD));
        }

        retval = InitializeClientPfnArrays(
                ppfnClientA, ppfnClientW, ppfnClientWorker, hModUser);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserInitializeThreadInfo");
    ENDRECV();
}

BOOL NtUserWaitForMsgAndEvent(
    IN HANDLE hevent)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxSleepTask(FALSE, hevent);

    TRACE("NtUserWaitForMsgAndEvent");
    ENDRECV();
}

DWORD NtUserDragObject(
    IN HWND hwndParent,
    IN HWND hwndFrom,
    IN UINT wFmt,
    IN ULONG_PTR dwData,
    IN HCURSOR hcur)
{
    PWND pwndFrom;
    PCURSOR pcur;
    TL tlpwndFrom;
    TL tlpcur;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwndParent);

    ValidateHWNDOPT(pwndFrom, hwndFrom);
    ValidateHCURSOROPT(pcur, hcur);

    ThreadLockWithPti(ptiCurrent, pwndFrom, &tlpwndFrom);
    ThreadLockWithPti(ptiCurrent, pcur, &tlpcur);

    retval = xxxDragObject(
            pwnd,
            pwndFrom,
            wFmt,
            dwData,
            pcur);

    ThreadUnlock(&tlpcur);
    ThreadUnlock(&tlpwndFrom);

    TRACE("NtUserDragObject");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserGetIconInfo(  // API GetIconInfo
    IN  HICON hIcon,
    OUT PICONINFO piconinfo,
    IN OUT OPTIONAL PUNICODE_STRING pstrInstanceName,
    IN OUT OPTIONAL PUNICODE_STRING pstrResName,
    OUT LPDWORD pbpp,
    IN  BOOL fInternal)
{
    PICON pIcon;
    UNICODE_STRING strInstanceName, *pstrInstanceLocal;
    UNICODE_STRING strResName, *pstrResLocal;

    BEGINATOMICRECV(BOOL, FALSE);

    /*
     * NOTE -- this can't be _SHARED since it calls Gre code with system HDC's.
     */

    ValidateHCURSOR(pIcon, hIcon);

    /*
     * Probe arguments
     */
    try {
        if (pstrInstanceName != NULL) {
            strInstanceName = ProbeAndReadUnicodeString(pstrInstanceName);
            ProbeForWrite(strInstanceName.Buffer, strInstanceName.MaximumLength, CHARALIGN);
            pstrInstanceLocal = &strInstanceName;
        } else {
            pstrInstanceLocal = NULL;
        }

        if (pstrResName != NULL) {
            strResName = ProbeAndReadUnicodeString(pstrResName);
            ProbeForWrite(strResName.Buffer, strResName.MaximumLength, CHARALIGN);
            pstrResLocal = &strResName;
        } else {
            pstrResLocal = NULL;
        }

        if (pbpp != NULL) {
            ProbeForWrite(pbpp, sizeof(DWORD), sizeof(DWORD));
        }
        ProbeForWrite(piconinfo, sizeof(*piconinfo), DATAALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * All use of client-side pointers in InternalGetIconInfo
     * is protected by try/except.
     */

    retval = _InternalGetIconInfo(
            pIcon,
            piconinfo,
            pstrInstanceLocal,
            pstrResLocal,
            pbpp,
            fInternal);

    try {
        if (pstrInstanceName != NULL) {
            RtlCopyMemory(pstrInstanceName, pstrInstanceLocal, sizeof(UNICODE_STRING));
        }
        if (pstrResName != NULL) {
            RtlCopyMemory(pstrResName, pstrResLocal, sizeof(UNICODE_STRING));
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetIconInfo");
    ENDATOMICRECV();
}

BOOL NtUserGetIconSize(  // private
    IN HICON hIcon,
    IN UINT istepIfAniCur,
    OUT int *pcx,
    OUT int *pcy)
{
    PCURSOR picon;

    BEGINRECV_SHARED(BOOL, FALSE);

    ValidateHICON(picon, hIcon);

    if (picon->CURSORF_flags & CURSORF_ACON) {
        PACON pacon = (PACON)picon;
        if (istepIfAniCur < (UINT)pacon->cpcur) {
            picon = pacon->aspcur[pacon->aicur[istepIfAniCur]];
        } else {
            RIPMSG2(RIP_WARNING, "NtUserGetIconSize: Invalid istepIfAniCur:%#lx. picon:%#p",
                    istepIfAniCur, picon);
            MSGERROR(0);
        }
    }

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteLong(pcx, picon->cx);
        ProbeAndWriteLong(pcy, picon->cy);

        retval = 1;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetIconSize");
    ENDRECV_SHARED();
}



BOOL NtUserDrawIconEx(  // API DrawIconEx
    IN HDC hdc,
    IN int x,
    IN int y,
    IN HICON hicon,
    IN int cx,
    IN int cy,
    IN UINT istepIfAniCur,
    IN HBRUSH hbrush,
    IN UINT diFlags,
    IN BOOL fMeta,
    OUT DRAWICONEXDATA *pdid)
{
    PCURSOR picon;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHICON(picon, hicon);

    if (fMeta) {
        if (picon->CURSORF_flags & CURSORF_ACON)
            picon = ((PACON)picon)->aspcur[((PACON)picon)->aicur[0]];

        /*
         * Probe arguments
         */
        try {
            ProbeForWrite(pdid, sizeof(*pdid), DATAALIGN);

            pdid->hbmMask  = picon->hbmMask;
            pdid->hbmColor = picon->hbmColor;
            pdid->hbmUserAlpha = picon->hbmUserAlpha;

            pdid->cx = picon->cx;
            pdid->cy = picon->cy;

            retval = 1;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }

    } else {
        retval = _DrawIconEx(hdc, x, y, picon,
                            cx, cy,
                            istepIfAniCur, hbrush,
                            diFlags );
    }

    TRACE("NtUserDrawIconEx");
    ENDATOMICRECV();
}

HANDLE NtUserDeferWindowPos(
    IN HDWP hWinPosInfo,
    IN HWND hwnd,
    IN HWND hwndInsertAfter,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN UINT wFlags)
{
    PWND pwnd;
    PWND pwndInsertAfter;
    PSMWP psmwp;

    BEGINATOMICRECV(HANDLE, NULL);

    TESTFLAGS(wFlags, SWP_VALID);

    ValidateHWNDND(pwnd, hwnd);
    ValidateHWNDIA(pwndInsertAfter, hwndInsertAfter);
    ValidateHDWP(psmwp, hWinPosInfo);

    if (wFlags & ~(SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER |
            SWP_NOREDRAW | SWP_NOACTIVATE | SWP_FRAMECHANGED |
            SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCOPYBITS |
            SWP_NOOWNERZORDER)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid flags (0x%lx) passed to DeferWindowPos",
                wFlags);
        MSGERROR(0);
    }

    /*
     * Make sure the window coordinates can fit in WORDs.
     */
    if (!(wFlags & SWP_NOMOVE)) {
        if (x > SHRT_MAX) {
            x = SHRT_MAX;
        } else if (x < SHRT_MIN) {
            x = SHRT_MIN;
        }
        if (y > SHRT_MAX) {
            y = SHRT_MAX;
        } else if (y < SHRT_MIN) {
            y = SHRT_MIN;
        }
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (!(wFlags & SWP_NOSIZE)) {
        if (cx < 0) {
            cx = 0;
        } else if (cx > SHRT_MAX) {
            cx = SHRT_MAX;
        }
        if (cy < 0) {
            cy = 0;
        } else if (cy > SHRT_MAX) {
            cy = SHRT_MAX;
        }
    }

#ifdef NEVER
//
// do not fail these conditions because real apps use them.
//
    if (!(wFlags & SWP_NOMOVE) &&
            (x > SHRT_MAX || x < SHRT_MIN ||
             y > SHRT_MAX || y < SHRT_MIN)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid coordinate passed to SetWindowPos");
        MSGERROR(0);
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (!(wFlags & SWP_NOSIZE) &&
            (cx < 0 || cx > SHRT_MAX ||
             cy < 0 || cy > SHRT_MAX)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid width/height passed to SetWindowPos");
        MSGERROR(0);
    }
#endif

    retval = _DeferWindowPos(
            psmwp,
            pwnd,
            pwndInsertAfter,
            x,
            y,
            cx,
            cy,
            wFlags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserDeferWindowPos");
    ENDATOMICRECV();
}

BOOL NtUserEndDeferWindowPosEx(
    IN HDWP hWinPosInfo,
    IN BOOL fAsync)
{
    PSMWP psmwp;
    TL tlpsmp;

    BEGINRECV(BOOL, FALSE);

    ValidateHDWP(psmwp, hWinPosInfo);

    ThreadLockAlways(psmwp, &tlpsmp);

    retval = xxxEndDeferWindowPosEx(
            psmwp,
            fAsync);

    ThreadUnlock(&tlpsmp);

    TRACE("NtUserEndDeferWindowPosEx");
    ENDRECV();
}

BOOL NtUserGetMessage(  // API GetMessageA/W
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);

    retval = xxxGetMessage(
            &msg,
            hwnd,
            wMsgFilterMin,
            wMsgFilterMax);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(pmsg, msg, MSG);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetMessage");
    ENDRECV();
}


#ifdef MESSAGE_PUMP_HOOK

BOOL NtUserRealInternalGetMessage(  // API RealInternalGetMessage
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT flags,
    BOOL fGetMessage)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);
    TESTFLAGS(flags, PM_VALID);

    if (!IsInsideMPH()) {
        RIPMSG0(RIP_WARNING, "NtUserRealInternalGetMessage: Calling MPH function on non-initialized thread");
    }

    retval = xxxRealInternalGetMessage(
            &msg,
            hwnd,
            wMsgFilterMin,
            wMsgFilterMax,
            flags,
            fGetMessage);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(pmsg, msg, MSG);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserRealInternalGetMessage");
    ENDRECV();
}

#endif // MESSAGE_PUMP_HOOK


BOOL NtUserMoveWindow(
    IN HWND hwnd,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN BOOL fRepaint)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    /*
     * Make sure the window coordinates can fit in WORDs.
     */
    if (x > SHRT_MAX) {
        x = SHRT_MAX;
    } else if (x < SHRT_MIN) {
        x = SHRT_MIN;
    }
    if (y > SHRT_MAX) {
        y = SHRT_MAX;
    } else if (y < SHRT_MIN) {
        y = SHRT_MIN;
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (cx < 0) {
        cx = 0;
    } else if (cx > SHRT_MAX) {
        cx = SHRT_MAX;
    }
    if (cy < 0) {
        cy = 0;
    } else if (cy > SHRT_MAX) {
        cy = SHRT_MAX;
    }

#ifdef NEVER
//
// do not fail these conditions because real apps use them.
//
    if (x > SHRT_MAX || x < SHRT_MIN ||
            y > SHRT_MAX || y < SHRT_MIN) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid coordinate passed to MoveWindow");
        MSGERROR(0);
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (cx < 0 || cx > SHRT_MAX ||
            cy < 0 || cy > SHRT_MAX) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid width/height passed to MoveWindow");
        MSGERROR(0);
    }
#endif

    retval = xxxMoveWindow(
            pwndND,
            x,
            y,
            cx,
            cy,
            fRepaint);

    TRACE("NtUserMoveWindow");
    ENDRECV_HWNDLOCK_ND();
}

int NtUserTranslateAccelerator(  // API TranslateAcceleratorA/W
    IN HWND hwnd,
    IN HACCEL haccel,
    IN LPMSG lpmsg)
{
    PWND pwnd;
    LPACCELTABLE pat;
    TL tlpwnd;
    TL tlpat;
    PTHREADINFO ptiCurrent;
    MSG msg;

    BEGINRECV(int, 0);

    /*
     * Probe arguments
     */
    try {
        msg = ProbeAndReadMessage(lpmsg);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * This is called within a message loop. If the window gets destroyed,
     * there still may be other messages in the queue that get returned
     * after the window is destroyed. The app will call TranslateAccelerator()
     * on every one of these, causing RIPs.... Make it nice so it just
     * returns FALSE.
     */
    ValidateHWNDNoRIP(pwnd, hwnd);
    ValidateHACCEL(pat, haccel);

    ptiCurrent = PtiCurrent();
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
    ThreadLockAlwaysWithPti(ptiCurrent, pat, &tlpat);

    retval = xxxTranslateAccelerator(
            pwnd,
            pat,
            &msg);

    ThreadUnlock(&tlpat);
    ThreadUnlock(&tlpwnd);

    TRACE("NtUserTranslateAccelerator");
    ENDRECV();
}

LONG_PTR NtUserSetClassLongPtr(  // API SetClassLongPtrA/W
    IN  HWND hwnd,
    IN  int nIndex,
    OUT LONG_PTR dwNewLong,
    IN  BOOL bAnsi)
{
    UNICODE_STRING strMenuName;
    CLSMENUNAME cmn, *pcmnSave;

    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    switch (nIndex) {
    case GCLP_MENUNAME:
        try {
            /*
             * There is no callback from the routine for
             * this value, so we can protect it with a try/except.
             * This is cheaper than capturing the name
             * and copying it back. FritzS
             */

            pcmnSave = (PCLSMENUNAME) dwNewLong;
            cmn = ProbeAndReadStructure(pcmnSave, CLSMENUNAME);
            strMenuName = ProbeAndReadUnicodeString(cmn.pusMenuName);
            ProbeForReadUnicodeStringBufferOrId(strMenuName);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
        cmn.pusMenuName = &strMenuName;
        dwNewLong = (ULONG_PTR) &cmn;
        retval = xxxSetClassLongPtr(
            pwnd,
            nIndex,
            dwNewLong,
            bAnsi);
        try {
            ProbeAndWriteStructure(pcmnSave, cmn, CLSMENUNAME);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
        break;

    case GCL_STYLE:
        /*
         * I'm not sure how CS_VALID mask will affect existing apps,
         * so leave it for now --- except CS_IME flag, on which the system
         * deeply depends.
         */
#if DBG
        if (dwNewLong & ~CS_VALID) {
            RIPMSG1(RIP_WARNING, "NtUserSetClassLongPtr: Invalid style (%x) specified.", dwNewLong);
        }
#endif
        if (dwNewLong & CS_IME) {
           RIPERR1(ERROR_INVALID_DATA, RIP_VERBOSE, "NtUserSetClassLongPtr: CS_IME is specified in new style (%x).", dwNewLong);
           MSGERROR(0);
        }
    default:
        retval = xxxSetClassLongPtr(
                pwnd,
                nIndex,
                dwNewLong,
                bAnsi);

    }

    TRACE("NtUserSetClassLongPtr");
    ENDRECV_HWNDLOCK();
}

#ifdef _WIN64
LONG NtUserSetClassLong(
    IN  HWND hwnd,
    IN  int nIndex,
    OUT LONG dwNewLong,
    IN  BOOL bAnsi)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    switch (nIndex) {
    case GCL_STYLE:
        /*
         * I'm not sure how CS_VALID mask will affect existing apps,
         * so leave it for now --- except CS_IME flag, on which the system
         * deeply depends.
         */
#if DBG
        if (dwNewLong & ~CS_VALID) {
            RIPMSG1(RIP_WARNING, "NtUserSetClassLong: Invalid style (%x) specified.", dwNewLong);
        }
#endif
        if (dwNewLong & CS_IME) {
           RIPERR1(ERROR_INVALID_DATA, RIP_VERBOSE, "NtUserSetClassLong: CS_IME is specified in new style (%x).", dwNewLong);
           MSGERROR(0);
        }
    }

    retval = xxxSetClassLong(
            pwnd,
            nIndex,
            dwNewLong,
            bAnsi);

    TRACE("NtUserSetClassLong");
    ENDRECV_HWNDLOCK();
}
#endif

BOOL NtUserSetKeyboardState(  // API SetKeyboardState
    IN CONST BYTE *lpKeyState)
{
    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(lpKeyState, 256, sizeof(BYTE));

        retval = _SetKeyboardState(lpKeyState);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserSetKeyboardState");
    ENDRECV();
}

BOOL NtUserSetWindowPos(
    IN HWND hwnd,
    IN HWND hwndInsertAfter,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN UINT dwFlags)
{
    PWND        pwndT;
    PWND        pwndInsertAfter;
    TL          tlpwndT;

    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    TESTFLAGS(dwFlags, SWP_VALID);

    ValidateHWNDIA(pwndInsertAfter, hwndInsertAfter);

    /*
     * Let's not allow the window to be shown/hidden once we
     * started the destruction of the window.
     */
    if (TestWF(pwndND, WFINDESTROY)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "SetWindowPos: Window is being destroyed (pwnd == %#p)",
                pwndND);
        MSGERROR(0);
    }

    if (dwFlags & ~SWP_VALID) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "SetWindowPos: Invalid flags passed in (flags == 0x%lx)",
                dwFlags);
        MSGERROR(0);
    }

    /*
     * Make sure the window coordinates can fit in WORDs.
     */
    if (!(dwFlags & SWP_NOMOVE)) {
        if (x > SHRT_MAX) {
            x = SHRT_MAX;
        } else if (x < SHRT_MIN) {
            x = SHRT_MIN;
        }
        if (y > SHRT_MAX) {
            y = SHRT_MAX;
        } else if (y < SHRT_MIN) {
            y = SHRT_MIN;
        }
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (!(dwFlags & SWP_NOSIZE)) {
        if (cx < 0) {
            cx = 0;
        } else if (cx > SHRT_MAX) {
            cx = SHRT_MAX;
        }
        if (cy < 0) {
            cy = 0;
        } else if (cy > SHRT_MAX) {
            cy = SHRT_MAX;
        }
    }

#ifdef NEVER
//
// do not fail these conditions because real apps use them.
//
    if (!(dwFlags & SWP_NOMOVE) &&
            (x > SHRT_MAX || x < SHRT_MIN ||
             y > SHRT_MAX || y < SHRT_MIN)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid coordinate passed to SetWindowPos");
        MSGERROR(0);
    }

    /*
     * Actually, if we were going to be really strict about this we'd
     * make sure that x + cx < SHRT_MAX, etc but since we do maintain
     * signed 32-bit coords internally this case doesn't cause a problem.
     */
    if (!(dwFlags & SWP_NOSIZE) &&
            (cx < 0 || cx > SHRT_MAX ||
             cy < 0 || cy > SHRT_MAX)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid width/height passed to SetWindowPos");
        MSGERROR(0);
    }
#endif

    switch((ULONG_PTR)pwndInsertAfter) {
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
        pwndT = NULL;
        break;

    default:
        pwndT = pwndInsertAfter;
        break;
    }

    ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

    retval = xxxSetWindowPos(
            pwndND,
            pwndInsertAfter,
            x,
            y,
            cx,
            cy,
            dwFlags);

    ThreadUnlock(&tlpwndT);

    TRACE("NtUserSetWindowPos");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserSetShellWindowEx(
    IN HWND hwnd,
    IN HWND hwndBkGnd)
{
    PWND        pwndBkGnd;
    TL          tlpwndBkGnd;

    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    ValidateHWNDND(pwndBkGnd, hwndBkGnd);

    ThreadLockAlwaysWithPti(ptiCurrent, pwndBkGnd, &tlpwndBkGnd);

    retval = xxxSetShellWindow(pwndND, pwndBkGnd);

    ThreadUnlock(&tlpwndBkGnd);

    TRACE("NtUserSetShellWindowEx");
    ENDRECV_HWNDLOCK_ND();
}

DWORD
NtUserGetGuiResources(
    HANDLE hProcess,
    DWORD dwFlags)

{
    PEPROCESS Process;
    PW32PROCESS pW32Process;
    BEGINRECV_SHARED(DWORD, 0);

    /*
     * Probe arguments
     */
    if (dwFlags > GR_MAXOBJECT) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "GetGuiResources: invalid flag bits %x\n",
                        dwFlags);
        MSGERROR(0);
    }


    if (hProcess == NtCurrentProcess()) {
        pW32Process = W32GetCurrentProcess();
    } else {
        NTSTATUS Status;
        Status = ObReferenceObjectByHandle(hProcess,
                                           PROCESS_QUERY_INFORMATION,
                                           *PsProcessType,
                                           UserMode,
                                           &Process,
                                           NULL);

        if (!NT_SUCCESS(Status)) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "GetGuiResources: Failed with Process handle == %X, Status = %x\n",
                    hProcess, Status);
            MSGERROR(0);
        }

        /*
         * Make sure they are from the same session
         */
        if (PsGetProcessSessionId(Process) != gSessionId) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "GetGuiResources: Different session. Failed with Process handle == %X, Status = %x\n",
                    hProcess, Status);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        pW32Process = PsGetProcessWin32Process(Process);
    }

    if (pW32Process) {
        switch(dwFlags) {
        case GR_GDIOBJECTS:
            retval = pW32Process->GDIHandleCount;
            break;
        case GR_USEROBJECTS:
            retval = pW32Process->UserHandleCount;
            break;
        }
    } else
        retval = 0;

    if (hProcess != NtCurrentProcess()) {
        ObDereferenceObject(Process);
    }

    TRACE("NtUserGetGuiResources");
    ENDRECV_SHARED();
}


BOOL NtUserSystemParametersInfo(  // API SystemParametersInfoA/W
    IN UINT   wFlag,
    IN DWORD  wParam,
    IN OUT LPVOID lpData,
    IN UINT   flags)
{
    UNICODE_STRING strData;
    ULONG          ulLength, ulLength2;
    LPVOID         lpDataSave;
    union {
        INT              MouseData[3];
        LOGFONTW         LogFont;
        MOUSEKEYS        MouseKeys;
        FILTERKEYS       FilterKeys;
        STICKYKEYS       StickyKeys;
        TOGGLEKEYS       ToggleKeys;
        SOUNDSENTRY      SoundSentry;
        ACCESSTIMEOUT    AccessTimeout;
        RECT             Rect;
        ANIMATIONINFO    AnimationInfo;
        NONCLIENTMETRICS NonClientMetrics;
        MINIMIZEDMETRICS MinimizedMetrics;
        ICONMETRICS      IconMetrics;
        HKL              hkl;
        INTERNALSETHIGHCONTRAST     ihc;
        HIGHCONTRAST     hc;
        WCHAR            szTemp[MAX_PATH];
    } CaptureBuffer;
    PTHREADINFO pti;
    TL tlBuffer;
    BOOL fFreeBuffer = FALSE;
    BOOL fWrite = FALSE;




    BEGINRECV(BOOL, FALSE);

    /*
     * Prevent restricted processes from setting system
     * parameters.
     *
     * clupu: this is ineficient and temporary. I'll change this
     * soon !!!
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS)) {

        switch (wFlag) {
        case SPI_SETBEEP:
        case SPI_SETMOUSE:
        case SPI_SETBORDER:
        case SPI_SETKEYBOARDSPEED:
        case SPI_ICONHORIZONTALSPACING:
        case SPI_SETSCREENSAVETIMEOUT:
        case SPI_SETBLOCKSENDINPUTRESETS:
        case SPI_SETSCREENSAVEACTIVE:
        case SPI_SETGRIDGRANULARITY:
        case SPI_SETDESKWALLPAPER:
        case SPI_SETDESKPATTERN:
        case SPI_SETKEYBOARDDELAY:
        case SPI_ICONVERTICALSPACING:
        case SPI_SETICONTITLEWRAP:
        case SPI_SETMENUDROPALIGNMENT:
        case SPI_SETDOUBLECLKWIDTH:
        case SPI_SETDOUBLECLKHEIGHT:
        case SPI_SETDOUBLECLICKTIME:
        case SPI_SETMOUSEBUTTONSWAP:
        case SPI_SETICONTITLELOGFONT:
        case SPI_SETFASTTASKSWITCH:
        case SPI_SETDRAGFULLWINDOWS:
        case SPI_SETNONCLIENTMETRICS:
        case SPI_SETMINIMIZEDMETRICS:
        case SPI_SETICONMETRICS:
        case SPI_SETWORKAREA:
        case SPI_SETPENWINDOWS:
        case SPI_SETHIGHCONTRAST:
        case SPI_SETKEYBOARDPREF:
        case SPI_SETSCREENREADER:
        case SPI_SETANIMATION:
        case SPI_SETFONTSMOOTHING:
        case SPI_SETDRAGWIDTH:
        case SPI_SETDRAGHEIGHT:
        case SPI_SETHANDHELD:
        case SPI_SETLOWPOWERTIMEOUT:
        case SPI_SETPOWEROFFTIMEOUT:
        case SPI_SETLOWPOWERACTIVE:
        case SPI_SETPOWEROFFACTIVE:
        case SPI_SETCURSORS:
        case SPI_SETICONS:
        case SPI_SETDEFAULTINPUTLANG:
        case SPI_SETLANGTOGGLE:
        case SPI_SETMOUSETRAILS:
        case SPI_SETSCREENSAVERRUNNING:
        case SPI_SETFILTERKEYS:
        case SPI_SETTOGGLEKEYS:
        case SPI_SETMOUSEKEYS:
        case SPI_SETSHOWSOUNDS:
        case SPI_SETSTICKYKEYS:
        case SPI_SETACCESSTIMEOUT:
        case SPI_SETSOUNDSENTRY:
        case SPI_SETSNAPTODEFBUTTON:
        case SPI_SETMOUSEHOVERWIDTH:
        case SPI_SETMOUSEHOVERHEIGHT:
        case SPI_SETMOUSEHOVERTIME:
        case SPI_SETWHEELSCROLLLINES:
        case SPI_SETMENUSHOWDELAY:
        case SPI_SETSHOWIMEUI:
        case SPI_SETMOUSESPEED:
        case SPI_SETACTIVEWINDOWTRACKING:
        case SPI_SETMENUANIMATION:
        case SPI_SETCOMBOBOXANIMATION:
        case SPI_SETLISTBOXSMOOTHSCROLLING:
        case SPI_SETGRADIENTCAPTIONS:
        case SPI_SETKEYBOARDCUES:
        case SPI_SETACTIVEWNDTRKZORDER:
        case SPI_SETHOTTRACKING:
        case SPI_SETMENUFADE:
        case SPI_SETSELECTIONFADE:
        case SPI_SETTOOLTIPANIMATION:
        case SPI_SETTOOLTIPFADE:
#ifdef MOUSE_IP
        case SPI_SETMOUSESONAR:
        case SPI_SETMOUSECLICKLOCK:
#endif
        case SPI_SETFOREGROUNDLOCKTIMEOUT:
        case SPI_SETACTIVEWNDTRKTIMEOUT:
        case SPI_SETFOREGROUNDFLASHCOUNT:
        case SPI_SETMOUSECLICKLOCKTIME:
        case SPI_SETFOCUSBORDERWIDTH:
        case SPI_SETFOCUSBORDERHEIGHT:
            MSGERROR(0);
            break;
        }
    }

    try {
        switch(wFlag) {

        case SPI_SETDESKPATTERN:
            /*
             * If wParam is -1, that means read the new wallpaper from
             * win.ini. If wParam is not -1, lParam points to the wallpaper
             * string.
             */
            if (wParam == (WPARAM)-1) {
                break;
            }

            /*
             * SetDeskPattern may take a string in lpData; if lpData
             * is one of the magic values it obviously is not a string
             */
            if (lpData == IntToPtr(0xFFFFFFFF) || lpData == NULL) {
                /*
                 * These are not really magic values, but in order not to break
                 * apps we have to keep them valid. wParam == -1 will make
                 * lParam be ignored.
                 * MCostea 208416
                 */
                wParam = -1;
                break;
            }
            goto ProbeString;

        case SPI_SETDESKWALLPAPER:

            /*
             * If the caller passed in (-1) in the wParam, then the
             * wallpaper name is to be loaded later. Otherwise,
             * they passed in a unicode string in the lParam.
             */
            if (wParam == (WPARAM)-1) {
                break;
            }

            if (((LPWSTR)lpData == NULL)                 ||
                ((LPWSTR)lpData == SETWALLPAPER_METRICS) ||
                ((LPWSTR)lpData == SETWALLPAPER_DEFAULT)) {
                break;
            }

ProbeString:

            /*
             * Probe and capture the string. Capture is necessary to
             * the pointer to be passed directly to the registry routines
             * which cannot cleanly handle exceptions.
             */
            strData = ProbeAndReadUnicodeString((PUNICODE_STRING)lpData);
#if defined(_X86_)
            ProbeForRead(strData.Buffer, strData.Length, sizeof(BYTE));
#else
            ProbeForRead(strData.Buffer, strData.Length, sizeof(WCHAR));
#endif
            lpData = UserAllocPoolWithQuota(strData.Length + sizeof(WCHAR), TAG_TEXT2);
            if (lpData == NULL) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            pti = PtiCurrent();
            ThreadLockPool(pti, lpData, &tlBuffer);
            fFreeBuffer = TRUE;
            RtlCopyMemory(lpData,
                          strData.Buffer,
                          strData.Length);
            ((PWSTR)lpData)[strData.Length / sizeof(WCHAR)] = 0;
            break;

        case SPI_SETBLOCKSENDINPUTRESETS:
            /*
             * This must be done a we must allow our value to be passed in wparam
             * to be consistent with xxxUpdatePerUserSystemParameters().  If we allow
             * This to fall through the default it will assert on us and the value will
             * not get set properly.
             */
            break;
        case SPI_SETMOUSE:
            ulLength = sizeof(INT) * 3;
            goto ProbeRead;
        case SPI_SETICONTITLELOGFONT:
            if (!ARGUMENT_PRESENT(lpData))
                break;
            ulLength = sizeof(LOGFONTW);
            goto ProbeRead;
        case SPI_SETMOUSEKEYS:
            ulLength = sizeof(MOUSEKEYS);
            goto ProbeRead;
        case SPI_SETFILTERKEYS:
            ulLength = sizeof(FILTERKEYS);
            goto ProbeRead;
        case SPI_SETSTICKYKEYS:
            ulLength = sizeof(STICKYKEYS);
            goto ProbeRead;
        case SPI_SETTOGGLEKEYS:
            ulLength = sizeof(TOGGLEKEYS);
            goto ProbeRead;
        case SPI_SETSOUNDSENTRY:
            ulLength = sizeof(SOUNDSENTRY);
            goto ProbeRead;
        case SPI_SETACCESSTIMEOUT:
            ulLength = sizeof(ACCESSTIMEOUT);
            goto ProbeRead;
        case SPI_SETWORKAREA:
            ulLength = sizeof(RECT);
            goto ProbeRead;
        case SPI_SETANIMATION:
            ulLength = sizeof(ANIMATIONINFO);
            goto ProbeRead;
        case SPI_SETNONCLIENTMETRICS:
            ulLength = sizeof(NONCLIENTMETRICS);
            goto ProbeRead;
        case SPI_SETMINIMIZEDMETRICS:
            ulLength = sizeof(MINIMIZEDMETRICS);
            goto ProbeRead;
        case SPI_SETICONMETRICS:
            ulLength = sizeof(ICONMETRICS);
            goto ProbeRead;
        case SPI_SETDEFAULTINPUTLANG:
            ulLength = sizeof(HKL);
            goto ProbeRead;
        case SPI_SETHIGHCONTRAST:
            CaptureBuffer.ihc = ProbeAndReadStructure((INTERNALSETHIGHCONTRAST *)lpData, INTERNALSETHIGHCONTRAST);
            lpData = &CaptureBuffer.ihc;

            /*
             * Now probe High Contrast string -- note that we send a client-side
             * buffer pointer to the routine.
             */

            ProbeForReadUnicodeStringBuffer(CaptureBuffer.ihc.usDefaultScheme);
            if (CaptureBuffer.ihc.usDefaultScheme.Length == 0) {
                CaptureBuffer.ihc.usDefaultScheme.Buffer = NULL;
            }
            break;

            /*
             * Probe and capture the data. Capture is necessary to
             * allow the pointer to be passed to the worker routines
             * where exceptions cannot be cleanly handled.
             */
ProbeRead:
#if defined(_X86_)
            ProbeForRead(lpData, ulLength, sizeof(BYTE));
#else
            ProbeForRead(lpData, ulLength, sizeof(DWORD));
#endif
            RtlCopyMemory(&CaptureBuffer, lpData, ulLength);
            lpData = &CaptureBuffer;
            break;

        case SPI_ICONHORIZONTALSPACING: // returns INT
        case SPI_ICONVERTICALSPACING:   // returns INT
            if (!IS_PTR(lpData))
                break;

            /*
             * Fall through and probe the data
             */
        case SPI_GETBEEP:                   // returns BOOL
        case SPI_GETBORDER:                 // returns INT
        case SPI_GETKEYBOARDSPEED:          // returns DWORD
        case SPI_GETKEYBOARDDELAY:          // returns INT
        case SPI_GETSCREENSAVETIMEOUT:      // returns INT
        case SPI_GETLOWPOWERTIMEOUT:        // returns INT
        case SPI_GETPOWEROFFTIMEOUT:        // returns INT
        case SPI_GETSCREENSAVEACTIVE:       // returns BOOL
        case SPI_GETBLOCKSENDINPUTRESETS:   // returns BOOL
        case SPI_GETLOWPOWERACTIVE:         // returns BOOL
        case SPI_GETPOWEROFFACTIVE:         // returns BOOL
        case SPI_GETGRIDGRANULARITY:        // returns INT
        case SPI_GETICONTITLEWRAP:          // returns BOOL
        case SPI_GETMENUDROPALIGNMENT:      // returns BOOL
        case SPI_GETFASTTASKSWITCH:         // returns BOOL
        case SPI_GETDRAGFULLWINDOWS:        // returns INT
        case SPI_GETSHOWSOUNDS:             // returns BOOL
        case SPI_GETFONTSMOOTHING:          // returns INT
        case SPI_GETSNAPTODEFBUTTON:        // returns BOOL
        case SPI_GETKEYBOARDPREF:           // returns BOOL
        case SPI_GETSCREENREADER:           // returns BOOL
        case SPI_GETDEFAULTINPUTLANG:
        case SPI_GETMOUSEHOVERWIDTH:
        case SPI_GETMOUSEHOVERHEIGHT:
        case SPI_GETMOUSEHOVERTIME:
        case SPI_GETWHEELSCROLLLINES:
        case SPI_GETMENUSHOWDELAY:
        case SPI_GETMOUSESPEED:
        case SPI_GETMOUSETRAILS:        // returns int
        case SPI_GETSCREENSAVERRUNNING:
        case SPI_GETSHOWIMEUI:
            goto ProbeWriteUlong;

        case SPI_GETICONTITLELOGFONT:   // returns LOGFONT
            ulLength = sizeof(LOGFONT);
            goto ProbeWrite;
        case SPI_GETMOUSE:              // returns 3 INTs
            ulLength = sizeof(INT) * 3;
            goto ProbeWrite;
        case SPI_GETFILTERKEYS:         // returns FILTERKEYS
            ulLength = sizeof(FILTERKEYS);
            goto ProbeWrite;
        case SPI_GETSTICKYKEYS:         // returns STICKYKEYS
            ulLength = sizeof(STICKYKEYS);
            goto ProbeWrite;
        case SPI_GETMOUSEKEYS:          // returns MOUSEKEYS
            ulLength = sizeof(MOUSEKEYS);
            goto ProbeWrite;
        case SPI_GETTOGGLEKEYS:         // returns TOGGLEKEYS
            ulLength = sizeof(TOGGLEKEYS);
            goto ProbeWrite;
        case SPI_GETSOUNDSENTRY:        // returns SOUNDSENTRY
            ulLength = sizeof(SOUNDSENTRY);
            goto ProbeWrite;
        case SPI_GETACCESSTIMEOUT:      // returns ACCESSTIMEOUT
            ulLength = sizeof(ACCESSTIMEOUT);
            goto ProbeWrite;
        case SPI_GETANIMATION:          // returns ANIMATIONINFO
            ulLength = sizeof(ANIMATIONINFO);
            goto ProbeWrite;
        case SPI_GETNONCLIENTMETRICS:   // returns NONCLIENTMETRICS
            ulLength = sizeof(NONCLIENTMETRICS);
            goto ProbeWrite;
        case SPI_GETMINIMIZEDMETRICS:   // returns MINIMIZEDMETRICS
            ulLength = sizeof(MINIMIZEDMETRICS);
            goto ProbeWrite;
        case SPI_GETICONMETRICS:        // returns ICONMETRICS
            ulLength = sizeof(ICONMETRICS);
            goto ProbeWrite;

        case SPI_GETHIGHCONTRAST:       // returns HIGHCONTRAST
            ulLength = sizeof(HIGHCONTRASTW);
            ProbeForWrite(lpData, ulLength, DATAALIGN);
            lpDataSave = lpData;
            CaptureBuffer.hc = *((LPHIGHCONTRAST)lpData);
            lpData = &CaptureBuffer.hc;

            /*
             * now probe string address
             */

            ulLength2 = MAX_SCHEME_NAME_SIZE * sizeof(WCHAR);

            ProbeForWrite(((LPHIGHCONTRAST)lpData)->lpszDefaultScheme, ulLength2, CHARALIGN);
            fWrite = TRUE;
            break;
        case SPI_GETWORKAREA:           // returns RECT
            ulLength = sizeof(RECT);
            goto ProbeWrite;

        case SPI_GETDESKWALLPAPER:
            lpDataSave = lpData;
            lpData = CaptureBuffer.szTemp;
            ProbeForWriteBuffer((PWSTR)lpDataSave, wParam, CHARALIGN);
            wParam = (wParam < MAX_PATH) ? wParam : MAX_PATH;
            ulLength = wParam * sizeof(WCHAR);
            fWrite = TRUE;
            break;

        default:
            if (wFlag < SPI_MAX) {
                break;
            } else if (!UPIsBOOLRange(wFlag)
                    && !UPIsDWORDRange(wFlag)) {

                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserSystemParametersInfo: Invalid SPI_:%#lx", wFlag);
                retval = FALSE;
                MSGERRORCLEANUP(0);
            }

            /*
             * Let's enforce this or this parameter is gone for good.
             */
            if (wParam != 0) {
                /*
                 * Too late, Winstone98 is alreay using it (incorrectly).
                 * Bummer, this has never been shipped and it's hacked already
                 * Allow a special case to go through
                 */
                if (LOWORD((PtiCurrent()->dwExpWinVer) > VER40)
                        || (wFlag != SPI_SETUIEFFECTS)
                        || (wParam != 1)) {
                    RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserSystemParametersInfo: uiParam must be zero for SPI %#lx", wFlag);
                    retval = FALSE;
                    MSGERRORCLEANUP(0);
                }
            }

            UserAssert(wFlag & SPIF_RANGETYPEMASK);

            if (wFlag & SPIF_SET) {
                /*
                 * If your dword data needs to be validated (i.e, range, value),
                 *  switch here on wFlag and do it here
                 */
                switch (wFlag) {
                    case SPI_SETFOREGROUNDLOCKTIMEOUT:
                        if (!CanForceForeground(PpiCurrent() FG_HOOKLOCK_PARAM(PtiCurrent()))) {
                            RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "");
                            retval = FALSE;
                            MSGERRORCLEANUP(0);
                        }
                        break;
                    case SPI_SETFONTSMOOTHINGTYPE:
                        if(PtrToInt(lpData) & ~FE_FONTSMOOTHINGTYPE_VALID) {
                            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "");
                            MSGERRORCLEANUP(0);
                        }
                        break;
                    case SPI_SETFONTSMOOTHINGORIENTATION:
                        if(PtrToInt(lpData) & ~FE_FONTSMOOTHINGORIENTATION_VALID) {
                            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "");
                            MSGERRORCLEANUP(0);
                        }
                        break;
                }

            } else {
ProbeWriteUlong:
                ulLength = sizeof(ULONG);
                lpDataSave = lpData;
                lpData = &CaptureBuffer;
                ProbeForWriteUlong((PULONG)lpDataSave);
                fWrite = TRUE;
            }
            break;

            /*
             * Probe the data. wParam contains the length.
             */
ProbeWrite:
            lpDataSave = lpData;
            lpData = &CaptureBuffer;
            ProbeForWrite(lpDataSave, ulLength, DATAALIGN);
            fWrite = TRUE;
            /*
             * Copy the first DWORD of the buffer. This will make sure that
             * the cbSize parameter of some structures gets copied.
             */

            UserAssert(ulLength >= sizeof(DWORD));
            *(LPDWORD)lpData=*(LPDWORD)lpDataSave;
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    retval = xxxSystemParametersInfo(wFlag, wParam, lpData, flags);

    /*
     * Copy out any data we need to.
     */
    if (fWrite) {
        try {
            RtlCopyMemory(lpDataSave, lpData, ulLength);
        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
    }

    CLEANUPRECV();
    if (fFreeBuffer)
        ThreadUnlockAndFreePool(pti, &tlBuffer);

    TRACE("NtUserSystemParametersInfo");
    ENDRECV();
}

BOOL NtUserUpdatePerUserSystemParameters(
    IN HANDLE hToken,
    IN DWORD dwFlags)
{
    BEGINRECV(BOOL, FALSE);

    UNREFERENCED_PARAMETER(hToken);

    retval = xxxUpdatePerUserSystemParameters(dwFlags);

    TRACE("NtUserUpdatePerUserSystemParameters");
    ENDRECV();
}

DWORD NtUserDdeInitialize(  // API DdeInitializeA/W
    OUT PHANDLE phInst,
    OUT HWND *phwnd,
    OUT LPDWORD pMonFlags,
    IN DWORD afCmd,
    IN PVOID pcii)
{
    HANDLE hInst;
    HWND hwnd;
    DWORD MonFlags;

    BEGINRECV(DWORD, DMLERR_INVALIDPARAMETER);

    /*
     * NOTE -- pcii is a value that is passed back to the client side
     * for event callbacks. It is not probed because it is not used
     * on the kernel side.
     */

    retval = xxxCsDdeInitialize(&hInst, &hwnd,
            &MonFlags, afCmd, pcii);

    /*
     * Probe arguments. pcii is not dereferenced in the kernel so probing
     * is not needed.
     */
    if (retval == DMLERR_NO_ERROR) {
        try {
            ProbeAndWriteHandle(phInst, hInst);
            ProbeAndWriteHandle((PHANDLE)phwnd, hwnd);
            ProbeAndWriteUlong(pMonFlags, MonFlags);
        } except (StubExceptionHandler(TRUE)) {
            xxxDestroyThreadDDEObject(PtiCurrent(), HtoP(hInst));
            MSGERROR(0);
        }
    }

    TRACE("NtUserDdeInitialize");
    ENDRECV();
}

DWORD NtUserUpdateInstance( // private, but pMonFlags from API DdeInitializeA/W
    IN HANDLE hInst,
    OUT LPDWORD pMonFlags,
    IN DWORD afCmd)
{
    DWORD MonFlags;
    BEGINRECV(DWORD, DMLERR_INVALIDPARAMETER);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteUlong(pMonFlags);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = _CsUpdateInstance(hInst, &MonFlags, afCmd);
    try {
        *pMonFlags = MonFlags;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserUpdateInstance");
    ENDRECV();
}

DWORD NtUserEvent(  // private
    IN PEVENT_PACKET pep)
{
    WORD cbEventData;
    BEGINRECV(DWORD, 0);

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(pep, sizeof(*pep), DATAALIGN);
        /*
         * capture so that another thread can't change it after the probe.
         */
        cbEventData = pep->cbEventData;
        ProbeForRead(&pep->Data, cbEventData, DATAALIGN);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * The buffer is captured within a try/except in xxxCsEvent.
     */

    retval = xxxCsEvent((PEVENT_PACKET)pep, cbEventData);

    TRACE("NtUserEvent");
    ENDRECV();
}

BOOL NtUserFillWindow(
    IN HWND hwndBrush,
    IN HWND hwndPaint,
    IN HDC hdc,
    IN HBRUSH hbr)
{
    PWND pwndBrush;
    TL tlpwndBrush;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwndPaint);

    if (hdc == NULL)
        MSGERROR(0);

    ValidateHWNDOPT(pwndBrush, hwndBrush);

    ThreadLockWithPti(ptiCurrent, pwndBrush, &tlpwndBrush);

    retval = xxxFillWindow(
            pwndBrush,
            pwnd,
            hdc,
            hbr);

    ThreadUnlock(&tlpwndBrush);

    TRACE("NtUserFillWindow");
    ENDRECV_HWNDLOCK();
}

PCLS NtUserGetWOWClass(  // wow
    IN HINSTANCE hInstance,
    IN PUNICODE_STRING pString)
{
    UNICODE_STRING strClassName;

    BEGINRECV_SHARED(PCLS, NULL);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pString);
        ProbeForReadUnicodeStringBuffer(strClassName);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = _GetWOWClass(
            hInstance,
            strClassName.Buffer);

    TRACE("NtUserGetWOWClass");
    ENDRECV_SHARED();
}

UINT NtUserGetInternalWindowPos(  // private
    IN HWND hwnd,
    OUT LPRECT lpRect OPTIONAL,
    OUT LPPOINT lpPoint OPTIONAL)
{
    WINDOWPLACEMENT wp;

    BEGINRECV_HWND_SHARED(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(lpRect)) {
            ProbeForWriteRect(lpRect);
        }
        if (ARGUMENT_PRESENT(lpPoint)) {
            ProbeForWritePoint(lpPoint);
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    wp.length = sizeof(WINDOWPLACEMENT);

    _GetWindowPlacement(pwnd, &wp);

    retval = wp.showCmd;
    try {
        if (ARGUMENT_PRESENT(lpRect)) {
            RtlCopyMemory(lpRect, &wp.rcNormalPosition, sizeof (RECT));
        }
        if (ARGUMENT_PRESENT(lpPoint)) {
            RtlCopyMemory(lpPoint, &wp.ptMinPosition, sizeof (POINT));
        }

    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("NtUserGetInternalWindowPos");
    ENDRECV_HWND_SHARED();
}

NTSTATUS NtUserInitTask(  // wow
    IN UINT dwExpWinVer,
    IN DWORD dwAppCompatFlags,
    IN DWORD dwUserWOWCompatFlags,
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrBaseFileName,
    IN DWORD hTaskWow,
    IN DWORD dwHotkey,
    IN DWORD idTask,
    IN DWORD dwX,
    IN DWORD dwY,
    IN DWORD dwXSize,
    IN DWORD dwYSize)
{
    UNICODE_STRING strModName;
    UNICODE_STRING strBaseFileName;

    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * Make sure this is really a WOW process.
     */
    if (PpiCurrent()->pwpi == NULL) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        strModName = ProbeAndReadUnicodeString(pstrModName);
        /*
         * pstrModName->Buffer has a UNICODE_NULL that's not counted in
         * the length, but we want to include it for convenience. The
         * probe routine does this.
         */
        ProbeForReadUnicodeStringBuffer(strModName);

        if (pstrBaseFileName) {
            strBaseFileName = ProbeAndReadUnicodeString(pstrBaseFileName);
            ProbeForReadUnicodeStringBuffer(strBaseFileName);
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = zzzInitTask(
            dwExpWinVer,
            dwAppCompatFlags,
            dwUserWOWCompatFlags,
            &strModName,
            pstrBaseFileName ? &strBaseFileName : NULL,
            hTaskWow,
            dwHotkey,
            idTask,
            dwX,
            dwY,
            dwXSize,
            dwYSize);

    TRACE("NtUserInitTask");
    ENDRECV();
}

BOOL NtUserPostThreadMessage(
    IN DWORD id,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    PTHREADINFO ptiCurrent, pti;

    BEGINRECV(BOOL, FALSE);

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (msg & MSGFLAG_MASK) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid message");
        MSGERROR(0);
    }

    pti = PtiFromThreadId(id);
    if (pti == NULL) {
        struct tagWOWPROCESSINFO *pwpi;
        PTDB ptdb;

        for (pwpi=gpwpiFirstWow; pwpi; pwpi=pwpi->pwpiNext) {
            for (ptdb=pwpi->ptdbHead; ptdb; ptdb=ptdb->ptdbNext) {
                if (ptdb->hTaskWow == id) {
                    pti=ptdb->pti;
                    goto PTM_DoIt;
                }
            }
        }

        RIPERR0(ERROR_INVALID_THREAD_ID, RIP_VERBOSE, "");
        MSGERROR(0);
    }

PTM_DoIt:

    /*
     * Should be OK if any of the following are true
     *   threads are running on the same desktop
     *   request is on behalf of a system process
     *   this process owns the desktop the thread is running in
     *   the LUIDs match
     */
    ptiCurrent = PtiCurrent();
    if ( !(ptiCurrent->rpdesk == pti->rpdesk) &&
         !(ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) &&
         !(GetDesktopView(ptiCurrent->ppi, pti->rpdesk))) {

        LUID     luidCurrent, luidTo;

        if (!NT_SUCCESS(GetProcessLuid(ptiCurrent->pEThread, &luidCurrent)) ||
            !NT_SUCCESS(GetProcessLuid(pti->pEThread, &luidTo)) ||
            !RtlEqualLuid(&luidCurrent, &luidTo)) {
            RIPERR3(ERROR_INVALID_THREAD_ID,
                    RIP_WARNING,
                    "NtUserPostThreadMessage failed LUID check: msg(%lx), t1(%#p) -> t2(%#p)",
                    msg, ptiCurrent, pti);
            MSGERROR(0);
        }
    }

    retval = _PostThreadMessage(
            pti,
            msg,
            wParam,
            lParam);

    TRACE("NtUserPostThreadMessage");
    ENDRECV();
}

BOOL NtUserRegisterTasklist(
    IN HWND hwnd)
{
    BEGINRECV_HWND(DWORD, 0, hwnd);

    retval = _RegisterTasklist(
            pwnd);

    TRACE("NtUserRegisterTasklist");
    ENDRECV_HWND();
}

BOOL NtUserCloseClipboard(
    VOID)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxCloseClipboard(NULL);

    TRACE("NtUserCloseClipboard");
    ENDRECV();
}

BOOL NtUserEmptyClipboard(
    VOID)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxEmptyClipboard(NULL);

    TRACE("NtUserEmptyClipboard");
    ENDRECV();
}

BOOL NtUserSetClipboardData(  // API SetClipboardData
    IN UINT          fmt,
    IN HANDLE        hData,
    IN PSETCLIPBDATA pscd)
{
    SETCLIPBDATA scd;

    BEGINRECV(BOOL, FALSE);

    /*
     * Check for jobs with JOB_OBJECT_UILIMIT_WRITECLIPBOARD
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_WRITECLIPBOARD)) {
        RIPMSG0(RIP_WARNING, "NtUserSetClipboardData failed for restricted thread");
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        scd = ProbeAndReadSetClipBData(pscd);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _SetClipboardData(
            fmt,
            hData,
            scd.fGlobalHandle,
            scd.fIncSerialNumber);

    TRACE("NtUserSetClipboardData");
    ENDRECV();
}

HANDLE NtUserConvertMemHandle(  // worker routine, lpData not from API
    IN LPBYTE lpData,
    IN UINT   cbData)
{
    BEGINRECV(HANDLE, NULL);

    /*
     * Probe arguments
     */
    try {

        ProbeForRead(lpData, cbData, sizeof(BYTE));

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * lpData is client-side.
     */
    retval = _ConvertMemHandle(lpData, cbData);

    TRACE("NtUserConvertMemHandle");
    ENDRECV();
}

NTSTATUS NtUserCreateLocalMemHandle(  // helper routine
    IN HANDLE hMem,
    OUT LPBYTE lpData OPTIONAL,
    IN UINT cbData,
    OUT PUINT lpcbNeeded OPTIONAL)
{
    PCLIPDATA pClipData;

    BEGINRECV(NTSTATUS, STATUS_INVALID_HANDLE);

    pClipData = HMValidateHandle(hMem, TYPE_CLIPDATA);
    if (pClipData == NULL)
        MSGERROR(0);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(lpData)) {
            ProbeForWrite(lpData, cbData, sizeof(BYTE));
        }

        if (ARGUMENT_PRESENT(lpcbNeeded)) {
            ProbeAndWriteUlong(lpcbNeeded, pClipData->cbData);
        }

        if (!ARGUMENT_PRESENT(lpData) || cbData < pClipData->cbData) {
            retval = STATUS_BUFFER_TOO_SMALL;
        } else {
            RtlCopyMemory(lpData, &pClipData->abData, pClipData->cbData);
            retval = STATUS_SUCCESS;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserCreateLocalMemHandle");
    ENDRECV();
}

HHOOK NtUserSetWindowsHookEx(
    IN HANDLE hmod,
    IN PUNICODE_STRING pstrLib OPTIONAL,
    IN DWORD idThread,
    IN int nFilterType,
    IN PROC pfnFilterProc,
    IN DWORD dwFlags)
{
    PTHREADINFO ptiThread;

    BEGINRECV(HHOOK, NULL);

    if (idThread != 0) {
        ptiThread = PtiFromThreadId(idThread);
        if (ptiThread == NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            MSGERROR(0);
        }
    } else {
        ptiThread = NULL;
    }

    /*
     * Probe pstrLib in GetHmodTableIndex().
     */
    retval = (HHOOK)zzzSetWindowsHookEx(
            hmod,
            pstrLib,
            ptiThread,
            nFilterType,
            pfnFilterProc,
            dwFlags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserSetWindowsHookEx");
    ENDRECV();
}

HWINEVENTHOOK NtUserSetWinEventHook(
    IN DWORD           eventMin,
    IN DWORD           eventMax,
    IN HMODULE         hmodWinEventProc,
    IN PUNICODE_STRING pstrLib OPTIONAL,
    IN WINEVENTPROC    pfnWinEventProc,
    IN DWORD           idEventProcess,
    IN DWORD           idEventThread,
    IN DWORD           dwFlags)
{
    BEGINRECV(HWINEVENTHOOK, NULL);

    TESTFLAGS(dwFlags, WINEVENT_VALID);

    /*
     * Probe pstrLib in GetHmodTableIndex().
     */
    retval = (HWINEVENTHOOK)_SetWinEventHook(
            eventMin,
            eventMax,
            hmodWinEventProc,
            pstrLib,
            pfnWinEventProc,
            (HANDLE)LongToHandle( idEventProcess ),
            idEventThread,
            dwFlags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserSetWinEventHook");
    ENDRECV();
}

BOOL NtUserUnhookWinEvent(
    IN HWINEVENTHOOK hWinEventUnhook)
{
    PEVENTHOOK peh;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWINEVENTHOOK(peh, hWinEventUnhook);

    retval = _UnhookWinEvent(peh);

    TRACE("NtUserUnhookWinEvent");
    ENDATOMICRECV();
}

VOID NtUserNotifyWinEvent(
    IN DWORD event,
    IN HWND  hwnd,
    IN LONG  idObject,
    IN LONG  idChild)
{
    BEGINRECV_HWNDLOCK_VOID(hwnd);

    xxxWindowEvent(event, pwnd, idObject, idChild, WEF_USEPWNDTHREAD);

    TRACEVOID("NtUserNotifyWinEvent");
    ENDRECV_HWNDLOCK_VOID();
}

BOOL NtUserRegisterUserApiHook(
    IN PUNICODE_STRING pstrLib,
    IN ULONG_PTR offPfnInitUserApiHook)
{
    BEGINATOMICRECV(BOOL, FALSE);

    /*
     * Probe pstrLib in GetHmodTableIndex().
     */
    retval = _RegisterUserApiHook(
            pstrLib,
            offPfnInitUserApiHook);

    TRACE("NtUserRegisterUserApiHook");
    ENDATOMICRECV();
}

BOOL NtUserUnregisterUserApiHook(VOID)
{
    BEGINATOMICRECV(BOOL, FALSE);

    retval = _UnregisterUserApiHook();

    TRACE("NtUserUnregisterUserApiHook");
    ENDATOMICRECV();
}

BOOL NtUserGetGUIThreadInfo(  // API GetGUIThreadInfo
    IN DWORD idThread,
    IN OUT PGUITHREADINFO pgui)
{
    PTHREADINFO ptiThread;
    GUITHREADINFO gui;

    BEGINRECV_SHARED(BOOL, FALSE);

    if (idThread) {
        ptiThread = PtiFromThreadId(idThread);
        if (ptiThread == NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "Bad thread id");
            MSGERROR(0);
        }
    } else {
        ptiThread = NULL;
    }

    /*
     * Probe arguments and copy results
     * C2: test pti & current thread on same desktop within _GetGUIThreadInfo
     */
    try {
        ProbeForWrite(pgui, sizeof(*pgui), DATAALIGN);
        gui.cbSize = pgui->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _GetGUIThreadInfo(ptiThread, &gui);
    if (retval) {
        try {
            *pgui = gui;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetGUIThreadInfo");
    ENDRECV_SHARED();
}

/*****************************************************************************\
* GetTitleBarInfo
*
* Gets information about the title bar
\*****************************************************************************/
BOOL NtUserGetTitleBarInfo(IN HWND hwnd, IN OUT PTITLEBARINFO ptbi)
{
    TITLEBARINFO tbi;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments and copy out results
     */
    try {
        ProbeForWrite(ptbi, sizeof(*ptbi), DATAALIGN);
        tbi.cbSize = ptbi->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }
    /*
     * Get the titlebar info
     */
    retval = xxxGetTitleBarInfo(pwnd, &tbi);
    if (retval) {
        try {
            *ptbi = tbi;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetTitleBarInfo");
    ENDRECV_HWNDLOCK();
}


/*****************************************************************************\
* NtUserGetComboBoxInfo
*
* Gets information about the combo box
\*****************************************************************************/
BOOL NtUserGetComboBoxInfo(IN HWND hwnd, IN OUT PCOMBOBOXINFO pcbi)
{
    COMBOBOXINFO cbi;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments and copy out results
     */
    try {
        ProbeForWrite(pcbi, sizeof(*pcbi), DATAALIGN);
        cbi.cbSize = pcbi->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

        /*
         * Get the combobox info
         */
    retval = xxxGetComboBoxInfo(pwnd, &cbi);

    if (retval) {
        try {
            *pcbi = cbi;
        } except (StubExceptionHandler(TRUE)) {
             MSGERROR(0);
        }
    }

    TRACE("NtUserGetComboBoxInfo");
    ENDRECV_HWNDLOCK();
}


/*****************************************************************************\
* NtUserGetListBoxInfo
*
* Gets information about the list box
\*****************************************************************************/
DWORD NtUserGetListBoxInfo(IN HWND hwnd)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    /*
     * Get the listbox info
     */
    retval = xxxGetListBoxInfo(pwnd);

    TRACE("NtUserGetListBoxInfo");
    ENDRECV_HWNDLOCK();
}


/*****************************************************************************\
* GetCursorInfo
*
* Gets information about the global cursor
\*****************************************************************************/
BOOL NtUserGetCursorInfo(IN OUT PCURSORINFO pci)
{
    CURSORINFO ci = {0};

    BEGINRECV_SHARED(BOOL, FALSE);

    ci.ptScreenPos = gpsi->ptCursor;
    ci.flags = 0;

    if (gpcurPhysCurrent)
        ci.flags |= CURSOR_SHOWING;

    /*
     * Get the current LOGICAL cursor (the one apps actually see from LoadCursor())
     */
    ci.hCursor = (HCURSOR)PtoH(gpcurLogCurrent);

    retval = TRUE;

    /*
     * Probe arguments and copy out result
     */
    try {
        ProbeForWrite(pci, sizeof(*pci), DATAALIGN);
        if (pci->cbSize != sizeof(CURSORINFO)) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "CURSORINFO.cbSize %d is wrong", pci->cbSize);
            retval = FALSE;
        } else {
            *pci = ci;
        }

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetCursorInfo");
    ENDRECV_SHARED();
}

/*****************************************************************************\
* GetScrollBarInfo
*
* Gets information about the scroll bar
\*****************************************************************************/
BOOL NtUserGetScrollBarInfo(IN HWND hwnd, IN LONG idObject, IN OUT PSCROLLBARINFO psbi)
{
    SCROLLBARINFO sbi;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments and copy out results
     */
    try {
        ProbeForWrite(psbi, sizeof(*psbi), DATAALIGN);
        sbi.cbSize = psbi->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }
    /*
     * Get the scrollbar info
     */
    retval = xxxGetScrollBarInfo(pwnd, idObject, &sbi);

    if (retval) {
        try {
            *psbi = sbi;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetScrollBarInfo");
    ENDRECV_HWNDLOCK();
}

HWND NtUserGetAncestor(IN HWND hwndChild, IN UINT gaFlags)
{
    BEGINRECV_HWND_SHARED(HWND, NULL, hwndChild);

    if ((gaFlags < GA_MIN) || (gaFlags > GA_MAX)) {
        RIPERR3(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "NtUserGetAncestor: Invalid gaFlags parameter %d, not %d - %d",
                 gaFlags, GA_MIN, GA_MAX);
        MSGERROR(0);
    }
    retval = (HWND)_GetAncestor(pwnd, gaFlags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserGetAncestor");
    ENDRECV_HWND_SHARED();
}

HWND NtUserRealChildWindowFromPoint(IN HWND hwndParent, IN POINT pt)
{
    BEGINRECV_HWND_SHARED(HWND, NULL, hwndParent);

    retval = (HWND)_RealChildWindowFromPoint(pwnd, pt);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserRealChildWindowFromPoint");
    ENDRECV_HWND_SHARED();
}

BOOL NtUserGetAltTabInfo(
    IN HWND hwnd,
    IN int iItem,
    IN OUT PALTTABINFO pati,
    OUT LPWSTR lpszItemText,
    IN UINT cchItemText OPTIONAL,
    BOOL bAnsi)
{
    ALTTABINFO ati;

    BEGINRECV_HWNDOPT_SHARED(BOOL, FALSE, hwnd);

    /*
     * If the specified window is not a switch window, then fail the call.
     * It's a dumb API we got from Windows 95, I am hereby allowing NULL hwnd.
     */
    if (pwnd && (pwnd != gspwndAltTab)) {
        MSGERROR(ERROR_INVALID_WINDOW_HANDLE);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForWrite(pati, sizeof(*pati), DATAALIGN);
        if (bAnsi) {
            ProbeForWriteBuffer((LPSTR)lpszItemText, cchItemText, CHARALIGN);
        } else {
            ProbeForWriteBuffer(lpszItemText, cchItemText, CHARALIGN);
        }

        /*
         * Validate AltTabInfo structure
         */
        if (pati->cbSize != sizeof(ALTTABINFO)) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "ALTTABINFO.cbSize %d is wrong", pati->cbSize);
            MSGERROR(0);
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Get the alt tab info
     */
    ati.cbSize = sizeof(ALTTABINFO);
    retval = _GetAltTabInfo(iItem, &ati, lpszItemText, cchItemText, bAnsi);
    if (retval) {
        try {
            *pati = ati;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetAltTabInfo");
    ENDRECV_HWNDOPT_SHARED();
}

BOOL NtUserGetMenuBarInfo(
    IN HWND hwnd,
    IN long idObject,
    IN long idItem,
    IN OUT PMENUBARINFO pmbi)
{
    MENUBARINFO mbi;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        ProbeForWrite(pmbi, sizeof(*pmbi), sizeof(BYTE));
#else
        ProbeForWrite(pmbi, sizeof(*pmbi), sizeof(DWORD));
#endif
        mbi.cbSize = pmbi->cbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Get the menubar info
     */
    retval = xxxGetMenuBarInfo(pwnd, idObject, idItem, &mbi);

    if (retval) {
        try {
            *pmbi = mbi;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetMenuBarInfo");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserSetInternalWindowPos(  // private SetInternalWindowPos
    IN HWND hwnd,
    IN UINT cmdShow,
    IN CONST RECT *lpRect,
    IN CONST POINT *lpPoint)
{
    RECT rc;
    POINT pt;

    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        rc = ProbeAndReadRect(lpRect);
        pt = ProbeAndReadPoint(lpPoint);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxSetInternalWindowPos(
            pwndND,
            cmdShow,
            &rc,
            &pt);

    TRACE("NtUserSetInternalWindowPos");
    ENDRECV_HWNDLOCK_ND();
}


BOOL NtUserChangeClipboardChain(
    IN HWND hwndRemove,
    IN HWND hwndNewNext)
{
    PWND pwndNewNext;
    TL tlpwndNewNext;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwndRemove);

    ValidateHWNDOPT(pwndNewNext, hwndNewNext);

    ThreadLockWithPti(ptiCurrent, pwndNewNext, &tlpwndNewNext);
    retval = xxxChangeClipboardChain(
            pwnd,
            pwndNewNext);

    ThreadUnlock(&tlpwndNewNext);

    TRACE("NtUserChangeClipboardChain");
    ENDRECV_HWNDLOCK();
}

DWORD NtUserCheckMenuItem(
    IN HMENU hmenu,
    IN UINT wIDCheckItem,
    IN UINT wCheck)
{
    PMENU pmenu;

    BEGINATOMICRECV(DWORD, (DWORD)-1);

    TESTFLAGS(wCheck, MF_VALID);

    ValidateHMENUMODIFY(pmenu, hmenu);

    retval = _CheckMenuItem(
            pmenu,
            wIDCheckItem,
            wCheck);

    TRACE("NtUserCheckMenuItem");
    ENDATOMICRECV();
}

HWND NtUserChildWindowFromPointEx(
    IN HWND hwndParent,
    IN POINT point,
    IN UINT flags)
{
    BEGINRECV_HWND(HWND, NULL, hwndParent);

    retval = (HWND)_ChildWindowFromPointEx(pwnd, point, flags);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserChildWindowFromPointEx");
    ENDRECV_HWND();
}

BOOL NtUserClipCursor(  // API ClipCursor
    IN CONST RECT *lpRect OPTIONAL)
{
    RECT rc;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lpRect)) {
        try {
            rc = ProbeAndReadRect(lpRect);
            lpRect = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    retval = zzzClipCursor(lpRect);

    TRACE("NtUserClipCursor");
    ENDRECV();
}

HACCEL NtUserCreateAcceleratorTable(  // API CreateAcceleratorTableA/W
    IN LPACCEL paccel,
    IN INT cAccel)
{
    BEGINRECV(HACCEL, NULL);

    if (cAccel <= 0) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForReadBuffer(paccel, cAccel, DATAALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = (HACCEL)_CreateAcceleratorTable(
            paccel,
            cAccel * sizeof(ACCEL));
    retval = PtoH((PVOID)retval);

    TRACE("NtUserCreateAcceleratorTable");
    ENDRECV();
}

BOOL NtUserDeleteMenu(
    IN HMENU hmenu,
    IN UINT nPosition,
    IN UINT dwFlags)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV(BOOL, FALSE);

    TESTFLAGS(dwFlags, MF_VALID);

    ValidateHMENUMODIFYCHECKLOCK(pmenu, hmenu);
    ThreadLock(pmenu, &tlpMenu);
    retval = xxxDeleteMenu(
            pmenu,
            nPosition,
            dwFlags);
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserDeleteMenu");
    ENDRECV();
}

BOOL NtUserDestroyAcceleratorTable(
    IN HACCEL hAccel)
{
    LPACCELTABLE pat;

    BEGINRECV(BOOL, FALSE);

    ValidateHACCEL(pat, hAccel);

    /*
     * Mark the object for destruction - if it says it's ok to free,
     * then free it.
     */
    if (HMMarkObjectDestroy(pat)) {
        HMFreeObject(pat);
    }
    retval = TRUE;

    TRACE("NtUserDestroyAcceleratorTable");
    ENDRECV();
}

BOOL NtUserDestroyCursor(
    IN HCURSOR hcurs,
    IN DWORD cmd)
{
    PCURSOR pcurs;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHCURSOR(pcurs, hcurs);

    retval = _DestroyCursor(pcurs, cmd);

    TRACE("NtUserDestroyCursor");
    ENDATOMICRECV();
}

HANDLE NtUserGetClipboardData(  // API GetClipboardData
    IN  UINT          fmt,
    OUT PGETCLIPBDATA pgcd)
{
    PTHREADINFO    ptiCurrent;
    TL             tlpwinsta;
    PWINDOWSTATION pwinsta;
    GETCLIPBDATA   gcd;

    BEGINRECV(HANDLE, NULL);

    ptiCurrent = PtiCurrent();
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    /*
     * Check for jobs with JOB_OBJECT_UILIMIT_READCLIPBOARD
     */
    if (IS_THREAD_RESTRICTED(ptiCurrent, JOB_OBJECT_UILIMIT_READCLIPBOARD)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "NtUserGetClipboardData failed for restricted thread");
        MSGERROR(0);
    }

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    /*
     * Start out assuming the format requested
     * will be the format returned.
     */
    gcd.uFmtRet = fmt;

    retval = xxxGetClipboardData(pwinsta, fmt, &gcd);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(pgcd, gcd, GETCLIPBDATA);
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    CLEANUPRECV();
    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    TRACE("NtUserGetClipboardData");
    ENDRECV();

}

BOOL NtUserDestroyMenu(
    IN HMENU hmenu)
{
    PMENU pmenu;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHMENUMODIFY(pmenu, hmenu);

    retval = _DestroyMenu(pmenu);

    TRACE("NtUserDestroyMenu");
    ENDATOMICRECV();
}

BOOL NtUserDestroyWindow(
    IN HWND hwnd)
{
    BEGINRECV_HWND(DWORD, 0, hwnd);

    retval  = xxxDestroyWindow(pwnd);

    TRACE("NtUserDestroyWindow");
    ENDRECV_HWND();
}

LRESULT NtUserDispatchMessage(  // API DispatchMessageA/W
    IN CONST MSG *pmsg)
{
    MSG msg;

    BEGINRECV(LRESULT, 0);

    /*
     * Probe arguments
     */
    try {
        msg = ProbeAndReadMessage(pmsg);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxDispatchMessage(&msg);

    TRACE("NtUserDispatchMessage");
    ENDRECV();
}

BOOL NtUserEnableMenuItem(
    IN HMENU hMenu,
    IN UINT wIDEnableItem,
    IN UINT wEnable)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV(BOOL, -1);

    TESTFLAGS(wEnable, MF_VALID);

    ValidateHMENUMODIFY(pmenu, hMenu);

    ThreadLockAlways(pmenu, &tlpMenu);
    retval = xxxEnableMenuItem(
            pmenu,
            wIDEnableItem,
            wEnable);
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserEnableMenuItem");
    ENDRECV();
}

BOOL NtUserAttachThreadInput(
    IN DWORD idAttach,
    IN DWORD idAttachTo,
    IN BOOL fAttach)
{
    PTHREADINFO ptiAttach;
    PTHREADINFO ptiAttachTo;

    BEGINRECV(BOOL, FALSE);

    /*
     * Always must attach or detach from a real thread id.
     */
    if ((ptiAttach = PtiFromThreadId(idAttach)) == NULL) {
        MSGERROR(0);
    }
    if ((ptiAttachTo = PtiFromThreadId(idAttachTo)) == NULL) {
        MSGERROR(0);
    }

    retval = zzzAttachThreadInput(
            ptiAttach,
            ptiAttachTo,
            fAttach);

    TRACE("NtUserAttachThreadInput");
    ENDRECV();
}

BOOL NtUserGetWindowPlacement(  // API GetWindowPlacement
    IN HWND hwnd,
    OUT PWINDOWPLACEMENT pwp)
{
    /*
     * Note -- this routine updates the checkpoint, so it needs exclusive
     * use of the crit sect.
     */

    WINDOWPLACEMENT wp;
    BEGINRECV_HWND(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteWindowPlacement(pwp);
        wp.length = pwp->length;
#ifdef LATER
        if (pwp->length != sizeof(WINDOWPLACEMENT)) {
            if (TestWF(pwnd, WFWIN40COMPAT)) {
                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "GetWindowPlacement: invalid length %lX", pwp->length);
                MSGERROR(0);
            } else {
                RIPMSG1(RIP_WARNING, "GetWindowPlacement: invalid length %lX", pwp->length);
                pwp->length = sizeof(WINDOWPLACEMENT);
            }
        }
#endif

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _GetWindowPlacement(pwnd, &wp);

    try {
        RtlCopyMemory(pwp, &wp, sizeof (WINDOWPLACEMENT));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetWindowPlacement");
    ENDRECV_HWND();
}

BOOL NtUserSetWindowPlacement(  // API SetWindowPlacement
    IN HWND hwnd,
    IN CONST WINDOWPLACEMENT *pwp)
{
    WINDOWPLACEMENT wp;

    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        wp = ProbeAndReadWindowPlacement(pwp);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (wp.length != sizeof(WINDOWPLACEMENT)) {
        if (Is400Compat(ptiCurrent->dwExpWinVer)) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "SetWindowPlacement: invalid length %lX", pwp->length);
            MSGERROR(0);
        } else {
            RIPMSG1(RIP_WARNING, "SetWindowPlacement: invalid length %lX", pwp->length);
        }
    }

    retval = xxxSetWindowPlacement(pwndND, &wp);

    TRACE("NtUserSetWindowPlacement");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserLockWindowUpdate(  // API LockWindowUpdate
    IN HWND hwnd)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = LockWindowUpdate2(pwnd, FALSE);

    TRACE("NtUserLockWindowUpdate");
    ENDATOMICRECV();
}

BOOL NtUserGetClipCursor(  // API GetClipCursor
    OUT LPRECT lpRect)
{
    /*
     * Check if the caller has the proper access rights: if not, this will
     * SetLastError to ERROR_ACCESS_DENIED and return FALSE. Do this *before*
     * BEGINRECV_SHARED, else we must use MSGERROR to release the critsect!
     */
    RETURN_IF_ACCESS_DENIED(PpiCurrent()->amwinsta,
                            WINSTA_READATTRIBUTES,
                            FALSE);
    {
        BEGINRECV_SHARED(BOOL, FALSE);

        /*
         * Probe arguments
         */
        try {
            ProbeForWriteRect(lpRect);

            *lpRect = grcCursorClip;
            retval = TRUE;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }

        TRACE("NtUserGetClipCursor");
        ENDRECV_SHARED();
    }
}

BOOL NtUserEnableScrollBar(
    IN HWND hwnd,
    IN UINT wSBflags,
    IN UINT wArrows)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    LIMITVALUE(wSBflags, SB_MAX, "EnableScrollBar");

    retval = xxxEnableScrollBar(
            pwndND,
            wSBflags,
            wArrows);

    TRACE("NtUserEnableScrollBar");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserDdeSetQualityOfService(  // API DdeSetQualityOfService
    IN HWND hwndClient,
    IN CONST SECURITY_QUALITY_OF_SERVICE *pqosNew,
    OUT PSECURITY_QUALITY_OF_SERVICE pqosPrev OPTIONAL)
{
    SECURITY_QUALITY_OF_SERVICE qosNew, qosPrev;

    BEGINRECV_HWND(BOOL, FALSE, hwndClient);

    if (GETPTI(pwnd) != PtiCurrent()) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        qosNew = ProbeAndReadStructure(pqosNew, SECURITY_QUALITY_OF_SERVICE);
        if (ARGUMENT_PRESENT(pqosPrev))
            ProbeForWrite(pqosPrev, sizeof(*pqosPrev), sizeof(DWORD));

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _DdeSetQualityOfService(
                pwnd,
                &qosNew,
                &qosPrev);

    try {
        if (ARGUMENT_PRESENT(pqosPrev))
            *pqosPrev = qosPrev;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserDdeSetQualityOfService");
    ENDRECV_HWND();
}

BOOL NtUserDdeGetQualityOfService(  // private DdeGetQualityOfService
    IN HWND hwndClient,
    IN HWND hwndServer,
    OUT PSECURITY_QUALITY_OF_SERVICE pqos)
{
    PWND pwndServer;
    PTHREADINFO ptiCurrent;
    SECURITY_QUALITY_OF_SERVICE qos;

    BEGINATOMICRECV_HWND(BOOL, FALSE, hwndClient);

    ValidateHWNDOPT(pwndServer, hwndServer);
    ptiCurrent = PtiCurrent();
    if (GETPTI(pwnd) != ptiCurrent && pwndServer != NULL &&
            GETPTI(pwndServer) != ptiCurrent) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForWrite(pqos, sizeof(*pqos), DATAALIGN);

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = _DdeGetQualityOfService(
                pwnd,
                pwndServer,
                &qos);
    try {
        RtlCopyMemory(pqos, &qos, sizeof (SECURITY_QUALITY_OF_SERVICE));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserDdeGetQualityOfService");
    ENDATOMICRECV_HWND();
}

DWORD NtUserGetMenuIndex(
    IN HMENU hMenu,
    IN HMENU hSubMenu)
{

    PMENU pmenu;
    PMENU psubmenu;
    DWORD idx;

    BEGINRECV_SHARED(DWORD, 0);

    ValidateHMENU(pmenu, hMenu);
    ValidateHMENU(psubmenu, hSubMenu);

    retval = (DWORD)-1;

    if (pmenu && psubmenu) {
        for (idx=0; idx<pmenu->cItems; idx++)
            if ((pmenu->rgItems[idx].spSubMenu == psubmenu)) {
                retval = idx;
                break;
            }
    }

    TRACE("NtUserGetMenuIndex");
    ENDRECV_SHARED();
}

VOID NtUserSetRipFlags(DWORD dwRipFlags, DWORD dwPID)
{
    BEGINRECV_VOID();

    _SetRipFlags(dwRipFlags, dwPID);

    TRACEVOID("NtUserSetRipFlags");
    ENDRECV_VOID();
}

VOID NtUserSetDbgTag(int tag, DWORD dwBitFlags)
{
    BEGINRECV_VOID();

    _SetDbgTag(tag, dwBitFlags);

    TRACEVOID("NtUserSetRipFlags");
    ENDRECV_VOID();
}

ULONG_PTR NtUserCallNoParam(
    IN DWORD xpfnProc)
{
    BEGINRECV(ULONG_PTR, 0);

    /*
     * C4296: (...) : expression is always true/false
     * The first comparison in ISXPFNPROCINRANGE is always true for
     * SFI_BEGINTRANSLATENOPARAMXXX, so we explicitly disable the warning.
     */
#pragma warning(disable:4296)
    VALIDATEXPFNPROC(NOPARAM);

    retval = (apfnSimpleCall[xpfnProc]());
    if (ISXPFNPROCINRANGE(NOPARAMANDRETURNHANDLE)) {
        retval = (ULONG_PTR)PtoH((PVOID)retval);
    }
#pragma warning(default:4296)

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV();
}

ULONG_PTR NtUserCallOneParam(
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc)
{
    BEGINRECV(ULONG_PTR, 0);

    VALIDATEXPFNPROC(ONEPARAM);

    retval = (apfnSimpleCall[xpfnProc](dwParam));
    if (ISXPFNPROCINRANGE(ONEPARAMANDRETURNHANDLE)) {
        retval = (ULONG_PTR)PtoH((PVOID)retval);
    }

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV();
}

ULONG_PTR NtUserCallHwnd(
    IN HWND hwnd,
    IN DWORD xpfnProc)
{
    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    VALIDATEXPFNPROC(HWND);

    retval = (apfnSimpleCall[xpfnProc](pwnd));

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV_HWNDLOCK();
}

ULONG_PTR NtUserCallHwndLock(
    IN HWND hwnd,
    IN DWORD xpfnProc)
{
    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    VALIDATEXPFNPROC(HWNDLOCK);

    retval = (apfnSimpleCall[xpfnProc](pwnd));

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV_HWNDLOCK();
}

ULONG_PTR NtUserCallHwndOpt(
    IN HWND hwnd,
    IN DWORD xpfnProc)
{
    PWND pwnd;

    BEGINATOMICRECV(ULONG_PTR, 0);

    ValidateHWNDOPT(pwnd, hwnd);

    VALIDATEXPFNPROC(HWNDOPT);

    retval = (apfnSimpleCall[xpfnProc](pwnd));

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDATOMICRECV();
}

ULONG_PTR NtUserCallHwndParam(
    IN HWND hwnd,
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc)
{
    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    VALIDATEXPFNPROC(HWNDPARAM);

    retval = (apfnSimpleCall[xpfnProc](pwnd, dwParam));
    if (ISXPFNPROCINRANGE(HWNDPARAMANDRETURNHANDLE)) {
        retval = (ULONG_PTR)PtoH((PVOID)retval);
    }

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV_HWNDLOCK();
}

ULONG_PTR NtUserCallHwndParamLock(
    IN HWND hwnd,
    IN ULONG_PTR dwParam,
    IN DWORD xpfnProc)
{
    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    VALIDATEXPFNPROC(HWNDPARAMLOCK);

    retval = (apfnSimpleCall[xpfnProc](pwnd, dwParam));

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV_HWNDLOCK();
}

ULONG_PTR NtUserCallTwoParam(
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2,
    IN DWORD xpfnProc)
{
    BEGINRECV(ULONG_PTR, 0);

    VALIDATEXPFNPROC(TWOPARAM);

    retval = (apfnSimpleCall[xpfnProc](dwParam1, dwParam2));

    TRACE(apszSimpleCallNames[xpfnProc]);
    ENDRECV();
}

BOOL NtUserThunkedMenuItemInfo(  // worker for various menu APIs
    IN HMENU hMenu,
    IN UINT nPosition,
    IN BOOL fByPosition,
    IN BOOL fInsert,
    IN LPMENUITEMINFOW lpmii,
    IN PUNICODE_STRING pstrItem OPTIONAL)
{
    PMENU pmenu;
    MENUITEMINFO mii;
    UNICODE_STRING strItem;
    TL tlpMenu;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     * No need to SetLastError because lpmii is always the address of
     * a local stack structure in USER code, not an application address.
     */
    try {
        mii = ProbeAndReadMenuItem(lpmii);

        if (ARGUMENT_PRESENT(pstrItem)) {
            strItem = ProbeAndReadUnicodeString(pstrItem);
            ProbeForReadUnicodeStringBuffer(strItem);
        } else {
            RtlInitUnicodeString(&strItem, NULL);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    if (fInsert) {
        ValidateHMENUMODIFYCHECKLOCK(pmenu, hMenu);
    } else {
        ValidateHMENUMODIFY(pmenu, hMenu);
    }

    ThreadLock(pmenu, &tlpMenu);
    /*
     * These routines only use the buffer in a try/except (actually in
     * xxxSetLPITEMInfo).
     */
    if (fInsert) {
        retval = xxxInsertMenuItem(
                pmenu,
                nPosition,
                fByPosition,
                &mii,
                &strItem);
    } else {
        retval = xxxSetMenuItemInfo(
                pmenu,
                nPosition,
                fByPosition,
                &mii,
                &strItem);
    }
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserThunkedMenuItemInfo");
    ENDRECV();
}

/***************************************************************************\
* NtUserThunkedMenuInfo
*
* History:
*  07-23-96 GerardoB - Added header & fixed up for 5.0
\***************************************************************************/
BOOL NtUserThunkedMenuInfo(  // API SetMenuInfo
    IN HMENU hMenu,
    IN LPCMENUINFO lpmi)
{
    PMENU pmenu;
    MENUINFO mi;
    TL tlpMenu;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        mi = ProbeAndReadMenuInfo(lpmi);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ValidateHMENUMODIFY(pmenu, hMenu);

    ThreadLock(pmenu, &tlpMenu);
    retval = xxxSetMenuInfo(pmenu, &mi);
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserThunkedMenuInfo");
    ENDRECV();
}

BOOL NtUserSetMenuDefaultItem(
    IN HMENU hMenu,
    IN UINT wID,
    IN UINT fByPosition)
{
    PMENU pmenu;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHMENUMODIFY(pmenu, hMenu);

    retval = _SetMenuDefaultItem(
            pmenu,
            wID,
            fByPosition);

    TRACE("NtUserSetMenuDefaultItem");
    ENDATOMICRECV();
}

BOOL NtUserSetMenuContextHelpId(
    IN HMENU hMenu,
    IN DWORD dwContextHelpId)
{
    PMENU pmenu;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHMENUMODIFY(pmenu, hMenu);

    retval = _SetMenuContextHelpId(
            pmenu,
            dwContextHelpId);

    TRACE("NtUserSetMenuContextHelpId");
    ENDATOMICRECV();
}

BOOL NtUserSetMenuFlagRtoL(
    IN HMENU hMenu)
{
    PMENU pmenu;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHMENU(pmenu, hMenu);

    retval = _SetMenuFlagRtoL(pmenu);

    TRACE("NtUserSetMenuFlagRtoL");
    ENDATOMICRECV();
}

BOOL NtUserDrawAnimatedRects(  // API DrawAnimatedRects
    IN HWND hwnd,
    IN int idAni,
    IN CONST RECT *lprcFrom,
    IN CONST RECT *lprcTo)
{
    PWND pwnd;
    TL tlpwnd;
    RECT rcFrom;
    RECT rcTo;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    /*
     * Probe arguments
     */
    try {
        rcFrom = ProbeAndReadRect(lprcFrom);
        rcTo = ProbeAndReadRect(lprcTo);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ThreadLock(pwnd, &tlpwnd);

    retval = xxxDrawAnimatedRects(
        pwnd,
        idAni,
        &rcFrom,
        &rcTo);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserDrawAnimatedRects");
    ENDRECV();
}

BOOL NtUserDrawCaption(  // API DrawCaption
    IN HWND hwnd,
    IN HDC hdc,
    IN CONST RECT *lprc,
    IN UINT flags)
{
    RECT rc;

    BEGINRECV_HWNDLOCK(DWORD, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        rc = ProbeAndReadRect(lprc);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxDrawCaptionTemp(pwnd, hdc, &rc, NULL, NULL, NULL, flags);

    TRACE("NtUserDrawCaption");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserPaintDesktop(
    IN HDC hdc)
{
    PTHREADINFO ptiCurrent;
    PWND        pwndDesk;
    TL          tlpwndDesk;

    BEGINRECV(BOOL, FALSE);

    ptiCurrent = PtiCurrent();

    if (ptiCurrent->rpdesk != NULL) {
        pwndDesk = ptiCurrent->rpdesk->pDeskInfo->spwnd;
        ThreadLockWithPti(ptiCurrent, pwndDesk, &tlpwndDesk);
        retval = xxxInternalPaintDesktop(pwndDesk, hdc, TRUE);
        ThreadUnlock(&tlpwndDesk);
    } else {
        MSGERROR(0);
    }

    TRACE("NtUserPaintDesktop");
    ENDRECV();
}

SHORT NtUserGetAsyncKeyState(
    IN int vKey)
{

    PTHREADINFO ptiCurrent;
    BEGINRECV_SHARED(SHORT, 0);


    ptiCurrent = PtiCurrentShared();
    UserAssert(ptiCurrent);

    /*
     * Don't allow other processes to spy on other deskops or a process
     * to spy on the foreground if the desktop does not allow input spying
     */
    if ((ptiCurrent->rpdesk != grpdeskRitInput) ||
            ( ((gptiForeground == NULL) || (PpiCurrent() != gptiForeground->ppi)) &&
              !RtlAreAnyAccessesGranted(ptiCurrent->amdesk, (DESKTOP_HOOKCONTROL | DESKTOP_JOURNALRECORD)))) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "GetAysncKeyState: not"
                " foreground desktop or no desktop hooking (input spying)");
        MSGERROR(0);
    }
    UserAssert(!(ptiCurrent->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

    retval = _GetAsyncKeyState(vKey);

    /*
     * Update the client side key state cache.
     */
    ptiCurrent->pClientInfo->dwAsyncKeyCache = gpsi->dwAsyncKeyCache;
    RtlCopyMemory(ptiCurrent->pClientInfo->afAsyncKeyState,
                  gafAsyncKeyState,
                  CBASYNCKEYCACHE);
    RtlCopyMemory(ptiCurrent->pClientInfo->afAsyncKeyStateRecentDown,
                  gafAsyncKeyStateRecentDown,
                  CBASYNCKEYCACHE);

    TRACE("NtUserGetAsyncKeyState");
    ENDRECV_SHARED();
}

HBRUSH NtUserGetControlBrush(
    IN HWND hwnd,
    IN HDC hdc,
    IN UINT msg)
{
    BEGINRECV_HWNDLOCK(HBRUSH, NULL, hwnd);

    if (hdc == NULL || !InMsgRange(msg, WM_CTLCOLORFIRST, WM_CTLCOLORLAST)) {
        MSGERROR(0);
    }

    retval = xxxGetControlBrush(
            pwnd,
            hdc,
            msg);

    TRACE("NtUserGetControlBrush");
    ENDRECV_HWNDLOCK();
}

HBRUSH NtUserGetControlColor(
    IN HWND hwndParent,
    IN HWND hwndCtl,
    IN HDC hdc,
    IN UINT msg)
{
    PWND pwndCtl;
    TL tlpwndCtl;

    BEGINRECV_HWNDLOCK(HBRUSH, NULL, hwndParent);

    ValidateHWND(pwndCtl, hwndCtl);

    if (hdc == NULL || !InMsgRange(msg, WM_CTLCOLORFIRST, WM_CTLCOLORLAST)) {
        MSGERROR(0);
    }

    ThreadLockAlwaysWithPti(ptiCurrent, pwndCtl, &tlpwndCtl);

    retval = xxxGetControlColor(
            pwnd,
            pwndCtl,
            hdc,
            msg);

    ThreadUnlock(&tlpwndCtl);

    TRACE("NtUserGetControlColor");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserEndMenu(VOID)
{
    PTHREADINFO ptiCurrent;
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);

    ptiCurrent = PtiCurrent();

    /*
     * The menu might be in the middle of some callback, so calling xxxEndMenu
     *  directly might mess things up. So we post it a message to signal it to
     *  go away at a good moment
     */
    if (ptiCurrent->pMenuState != NULL) {
        pwnd = GetMenuStateWindow(ptiCurrent->pMenuState);

        if (pwnd != NULL) {
            _PostMessage(pwnd, MN_ENDMENU, 0, 0);
        } else {
            /*
             * Is this menu messed up?
             */
            UserAssert(pwnd != NULL);
            ptiCurrent->pMenuState->fInsideMenuLoop = FALSE;
        }
    }

    retval = TRUE;

    TRACEVOID("NtUserEndMenu");
    ENDRECV();
}

int NtUserCountClipboardFormats(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(int, 0);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = pwinsta->cNumClipFormats;

    TRACE("NtUserCountClipboardFormats");
    ENDRECV_SHARED();
}

DWORD NtUserGetClipboardSequenceNumber(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(DWORD, 0);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = pwinsta->iClipSequenceNumber;

    TRACE("NtUserGetClipboardSequenceNumber");
    ENDRECV_SHARED();
}

UINT NtUserGetCaretBlinkTime(VOID)
{
    BEGINRECV_SHARED(UINT, 0);

    /*
     * Blow it off if the caller doesn't have the proper access rights. However,
     * allow CSRSS to use this value internally to the server. Note that if the
     * client tries to retrieve this value itself, the access check will
     * function normally.
     */
    if ((PpiCurrent()->Process != gpepCSRSS) &&
        (!CheckGrantedAccess(PpiCurrent()->amwinsta, WINSTA_READATTRIBUTES))) {
        MSGERROR(0);
    }

    retval = gpsi->dtCaretBlink;

    TRACE("NtUserGetCaretBlinkTime");
    ENDRECV_SHARED();
}

HWND NtUserGetClipboardOwner(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(HWND, NULL);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = PtoH(pwinsta->spwndClipOwner);

    TRACE("NtUserGetClipboardOwner");
    ENDRECV_SHARED();
}

HWND NtUserGetClipboardViewer(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(HWND, NULL);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = PtoH(pwinsta->spwndClipViewer);

    TRACE("NtUserGetClipboardViewer");
    ENDRECV_SHARED();
}

UINT NtUserGetDoubleClickTime(
    VOID)
{
    BEGINRECV_SHARED(UINT, 0);

    /*
     * Blow it off if the caller doesn't have the proper access rights. However,
     * allow CSRSS to use this value internally to the server. Note that if the
     * client tries to retrieve this value itself, the access check will
     * function normally.
     */
    if ((PpiCurrent()->Process != gpepCSRSS) &&
        (!CheckGrantedAccess(PpiCurrent()->amwinsta, WINSTA_READATTRIBUTES))) {
        MSGERROR(0);
    }

    retval = gdtDblClk;

    TRACE("NtUserGetDoubleClickTime");
    ENDRECV_SHARED();
}

HWND NtUserGetForegroundWindow(
    VOID)
{
    BEGINRECV_SHARED(HWND, NULL);

    /*
     * Only return a window if there is a foreground queue and the
     * caller has access to the current desktop.
     */
    if (gpqForeground == NULL || gpqForeground->spwndActive == NULL ||
            PtiCurrentShared()->rpdesk != gpqForeground->spwndActive->head.rpdesk) {
        MSGERROR(0);
    }

    retval = PtoHq(gpqForeground->spwndActive);

    TRACE("NtUserGetForegroundWindow");
    ENDRECV_SHARED();
}

HWND NtUserGetOpenClipboardWindow(
    VOID)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(HWND, NULL);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = PtoH(pwinsta->spwndClipOpen);

    TRACE("NtUserGetOpenClipboardWindow");
    ENDRECV_SHARED();
}

int NtUserGetPriorityClipboardFormat(  // API GetPriorityClipboardFormat
    IN UINT *paFormatPriorityList,
    IN int cFormats)
{
    BEGINRECV_SHARED(int, 0);

    /*
     * Probe arguments
     */
    try {
        ProbeForReadBuffer(paFormatPriorityList, cFormats, DATAALIGN);

        retval = _GetPriorityClipboardFormat(
                paFormatPriorityList,
                cFormats);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetPriorityClipboardFormat");
    ENDRECV_SHARED();
}

HMENU NtUserGetSystemMenu(
    IN HWND hwnd,
    IN BOOL bRevert)
{
    BEGINRECV_HWNDLOCK(HMENU, NULL, hwnd);

    retval = (HMENU)xxxGetSystemMenu(pwnd, bRevert);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserGetSystemMenu");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserGetUpdateRect(  // API GetUpdateRect
    IN HWND hwnd,
    IN LPRECT prect OPTIONAL,
    IN BOOL bErase)
{
    RECT rect2;
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    retval = xxxGetUpdateRect(
            pwnd,
            prect? &rect2:NULL,
            bErase);
    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(prect)) {
        try {
            ProbeAndWriteStructure(prect, rect2, RECT);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetUpdateRect");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserHideCaret(
    IN HWND hwnd)
{
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = zzzHideCaret(pwnd);

    TRACE("NtUserHideCaret");
    ENDRECV();
}

BOOL NtUserHiliteMenuItem(
    IN HWND hwnd,
    IN HMENU hMenu,
    IN UINT uIDHiliteItem,
    IN UINT uHilite)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    TESTFLAGS(uHilite, MF_VALID);

    ValidateHMENUMODIFY(pmenu, hMenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval = xxxHiliteMenuItem(
            pwnd,
            pmenu,
            uIDHiliteItem,
            uHilite);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserHiliteMenuItem");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserInvalidateRect(  // API InvalidateRect
    IN HWND hwnd,
    IN CONST RECT *prect OPTIONAL,
    IN BOOL bErase)
{
    PWND pwnd;
    TL tlpwnd;
    RECT rc;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(prect)) {
        try {
            rc = ProbeAndReadRect(prect);
            prect = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    ThreadLock(pwnd, &tlpwnd);

    retval = xxxInvalidateRect(
            pwnd,
            (PRECT)prect,
            bErase);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserInvalidateRect");
    ENDRECV();
}

BOOL NtUserIsClipboardFormatAvailable(
    IN UINT nFormat)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(BOOL, FALSE);

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL) {
        MSGERROR(0);
    }

    retval = (FindClipFormat(pwinsta, nFormat) != NULL);

    TRACE("NtUserIsClipboardFormatAvailable");
    ENDRECV_SHARED();
}

BOOL NtUserKillTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = _KillTimer(
            pwnd,
            nIDEvent);

    TRACE("NtUserKillTimer");
    ENDATOMICRECV();
}

HWND NtUserMinMaximize(
    IN HWND hwnd,
    IN UINT nCmdShow,
    IN BOOL fKeepHidden)
{
    BEGINRECV_HWNDLOCK_ND(HWND, NULL, hwnd);

    retval = (HWND)xxxMinMaximize(
            pwndND,
            nCmdShow,
            ((fKeepHidden) ? MINMAX_KEEPHIDDEN : 0) | TEST_PUDF(PUDF_ANIMATE));
    retval = PtoH((PVOID)retval);

    TRACE("NtUserMinMaximize");
    ENDRECV_HWNDLOCK_ND();
}

/**************************************************************************\
* NtUserMNDragOver
*
* Called from the IDropTarget interface to let menus update the selection
*  given the mouse position. It also returns the handle of the menu the
*  the index of the item  the point is on.
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
BOOL NtUserMNDragOver(  // worker for menu drag & drop
    IN POINT * ppt,
    OUT PMNDRAGOVERINFO pmndoi)
{
    POINT pt;
    MNDRAGOVERINFO mndoi;

    BEGINRECV(BOOL, FALSE);

    /*
     * No need to SetLastError since ppt and pmndoi are always addresses of
     * local stack variables in USER, not addresses from an application
     */
    try {
        pt = ProbeAndReadPoint(ppt);
    } except (StubExceptionHandler(FALSE)) {
        RIPMSG1(RIP_WARNING, "NtUserMNDragOver: Exception:%#lx", GetExceptionCode());
        MSGERROR(0);
    }

    retval = xxxMNDragOver(&pt, &mndoi);

    if (retval) {
        try {
            ProbeAndWriteStructure(pmndoi, mndoi, MNDRAGOVERINFO);
        } except (StubExceptionHandler(FALSE)) {
            RIPMSG1(RIP_WARNING, "NtUserMNDragOver: Exception:%#lx", GetExceptionCode());
            MSGERROR(0);
        }
    }

    TRACE("NtUserMNDragOver");
    ENDRECV();
}
/**************************************************************************\
* NtUserMNDragLeave
*
* Called from the IDropTarget interface to let the menu clean up
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
BOOL NtUserMNDragLeave(VOID)
{
    BEGINRECV(BOOL, FALSE);
    retval = xxxMNDragLeave();
    TRACE("NtUserMNDragLeave");
    ENDRECV();
}

BOOL NtUserOpenClipboard(  // API OpenClipboard
    IN HWND hwnd,
    OUT PBOOL pfEmptyClient)
{
    PWND pwnd;
    TL tlpwnd;
    BOOL fEmptyClient;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = xxxOpenClipboard(pwnd, &fEmptyClient);

    ThreadUnlock(&tlpwnd);

    /*
     * Probe arguments
     * No need to SetLastError since pfEmptyClient is the address of a local
     * variable in USER client code, not an application address.
     */
    try {
        ProbeAndWriteUlong(pfEmptyClient, fEmptyClient);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserOpenClipboard");
    ENDRECV();
}

BOOL NtUserPeekMessage(
    OUT LPMSG pmsg,
    IN HWND hwnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT wRemoveMsg)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);

    TESTFLAGS(wRemoveMsg, PM_VALID);

    retval = xxxPeekMessage(
            &msg,
            hwnd,
            wMsgFilterMin,
            wMsgFilterMax,
            wRemoveMsg);

    /*
     * Probe and write arguments only if PeekMessage suceeds otherwise
     * we want to leave MSG undisturbed (bug 16224) to be compatible.
     */
    if (retval) {
        try {
            ProbeAndWriteStructure(pmsg, msg, MSG);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserPeekMessage");
    ENDRECV();
}

BOOL NtUserPostMessage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (msg & MSGFLAG_MASK) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid message");
        MSGERROR(0);
    }

    switch ((ULONG_PTR)hwnd) {
    case -1:
    case 0x0000FFFF:
        pwnd = PWND_BROADCAST;
        break;

    case 0:
        pwnd = NULL;
        break;

    default:
        if ((pwnd = ValidateHwnd(hwnd)) == NULL) {
            /*
             * We fake terminates to dead windows! (SAS)
             */
            errret = (msg == WM_DDE_TERMINATE);
            MSGERROR(0);
        }
        break;
    }

    retval = _PostMessage(
            pwnd,
            msg,
            wParam,
            lParam);

    TRACE("NtUserPostMessage");
    ENDRECV();
}

BOOL NtUserRegisterHotKey(
    IN HWND hwnd,
    IN int id,
    IN UINT fsModifiers,
    IN UINT vk)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    TESTFLAGS(fsModifiers, MOD_VALID);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = _RegisterHotKey(
            pwnd,
            id,
            fsModifiers,
            vk
            );

    TRACE("NtUserRegisterHotKey");
    ENDATOMICRECV();
}

BOOL NtUserRemoveMenu(
    IN HMENU hmenu,
    IN UINT nPosition,
    IN UINT dwFlags)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV(BOOL, FALSE);

    TESTFLAGS(dwFlags, MF_VALID);

    ValidateHMENUMODIFYCHECKLOCK(pmenu, hmenu);

    ThreadLock(pmenu, &tlpMenu);
    retval = xxxRemoveMenu(
            pmenu,
            nPosition,
            dwFlags);
    ThreadUnlock(&tlpMenu);

    TRACE("NtUserRemoveMenu");
    ENDRECV();
}

BOOL NtUserScrollWindowEx(  // API ScrollWindowEx
    IN HWND hwnd,
    IN int dx,
    IN int dy,
    IN CONST RECT *prcScroll OPTIONAL,
    IN CONST RECT *prcClip OPTIONAL,
    IN HRGN hrgnUpdate,
    OUT LPRECT prcUpdate OPTIONAL,
    IN UINT flags)
{
    RECT rcScroll;
    RECT rcClip;
    RECT rcUpdate;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(prcScroll)) {
            rcScroll = ProbeAndReadRect(prcScroll);
            prcScroll = &rcScroll;
        }
        if (ARGUMENT_PRESENT(prcClip)) {
            rcClip = ProbeAndReadRect(prcClip);
            prcClip = &rcClip;
        }

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxScrollWindowEx(
                pwnd,
                dx,
                dy,
                (PRECT)prcScroll,
                (PRECT)prcClip,
                hrgnUpdate,
                prcUpdate ? &rcUpdate : NULL,
                flags);

    if (ARGUMENT_PRESENT(prcUpdate)) {
        try {
            ProbeAndWriteStructure(prcUpdate, rcUpdate, RECT);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserScrollWindow");
    ENDRECV_HWNDLOCK();
}

HWND NtUserSetActiveWindow(
    IN HWND hwnd)
{
    PWND pwnd;
    TL tlpwnd;

    BEGINRECV(HWND, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = (HWND)xxxSetActiveWindow(pwnd);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserSetActiveWindow");
    ENDRECV();
}

HWND NtUserSetCapture(
    IN HWND hwnd)
{
    PWND pwnd;
    TL tlpwnd;

    BEGINRECV(HWND, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = (HWND)xxxSetCapture(pwnd);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserSetCapture");
    ENDRECV();
}

WORD NtUserSetClassWord(
    IN HWND hwnd,
    IN int nIndex,
    IN WORD wNewWord)
{
    BEGINRECV_HWND(WORD, 0, hwnd);

    retval = _SetClassWord(
            pwnd,
            nIndex,
            wNewWord);

    TRACE("NtUserSetClassWord");
    ENDRECV_HWND();
}

HWND NtUserSetClipboardViewer(
    IN HWND hwnd)
{
    PWND pwnd;
    TL tlpwnd;

    BEGINRECV(HWND, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = (HWND)xxxSetClipboardViewer(pwnd);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserSetClipboardViewer");
    ENDRECV();
}

HCURSOR NtUserSetCursor(
    IN HCURSOR hCursor)
{
    PCURSOR pCursor;

    BEGINRECV(HCURSOR, NULL);

    ValidateHCURSOROPT(pCursor, hCursor);

    retval = (HCURSOR)zzzSetCursor(pCursor);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserSetCursor");
    ENDRECV();
}

HWND NtUserSetFocus(
    IN HWND hwnd)
{
    PWND pwnd;
    TL tlpwnd;

    BEGINRECV(HWND, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = (HWND)xxxSetFocus(pwnd);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserSetFocus");
    ENDRECV();
}

BOOL NtUserSetMenu(
    IN HWND  hwnd,
    IN HMENU hmenu,
    IN BOOL  fRedraw)
{
    PMENU pmenu;
    TL    tlpMenu;

    BEGINRECV_HWNDLOCK_ND(DWORD, 0, hwnd);

    ValidateHMENUOPT(pmenu, hmenu);

    ThreadLockWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval = xxxSetMenu(
            pwndND,
            pmenu,
            fRedraw);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserSetMenu");
    ENDRECV_HWNDLOCK_ND();
}

HWND NtUserSetParent(
    IN HWND hwndChild,
    IN HWND hwndNewParent)
{

    PWND pwndNewParent;
    TL tlpwndNewParent;

    BEGINRECV_HWNDLOCK_ND(HWND, NULL, hwndChild);

    if (hwndNewParent == NULL) {
        pwndNewParent = _GetDesktopWindow();
    } else if (hwndNewParent == HWND_MESSAGE) {
        pwndNewParent = _GetMessageWindow();
    } else {
        ValidateHWND(pwndNewParent, hwndNewParent);
    }

    ThreadLockWithPti(ptiCurrent, pwndNewParent, &tlpwndNewParent);

    retval = (HWND)xxxSetParent(
            pwndND,
            pwndNewParent);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwndNewParent);

    TRACE("NtUserSetParent");
    ENDRECV_HWNDLOCK_ND();
}

int NtUserSetScrollInfo(  // API SetScrollInfo
    IN HWND hwnd,
    IN int nBar,
    IN LPCSCROLLINFO pInfo,
    IN BOOL fRedraw)
{
    SCROLLINFO si;

    BEGINRECV_HWNDLOCK_ND(DWORD, 0, hwnd);

    LIMITVALUE(nBar, SB_MAX, "SetScrollInfo");

    /*
     * Probe arguments
     */
    try {
        si = ProbeAndReadScrollInfo(pInfo);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxSetScrollBar(
            pwndND,
            nBar,
            &si,
            fRedraw);

    TRACE("NtUserSetScrollInfo");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserSetSysColors(  // API SetSysColors
    IN int nCount,
    IN CONST INT *pSysColor,
    IN CONST COLORREF *pColorValues,
    IN UINT  uOptions)
{
    LPINT lpSysColors = NULL;
    LPDWORD lpSysColorValues = NULL;
    TL tlName, tlSysColors, tlSysColorValues;
    PUNICODE_STRING pProfileUserName = NULL;
    PTHREADINFO ptiCurrent;

    BEGINRECV(BOOL, FALSE);

    ptiCurrent = PtiCurrent();

    /*
     * Prevent restricted threads from changing global stuff
     */
    if (IS_THREAD_RESTRICTED(ptiCurrent, JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS)) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    if (nCount) {
        try {
            ProbeForReadBuffer(pSysColor, nCount, DATAALIGN);
            ProbeForReadBuffer(pColorValues, nCount, DATAALIGN);
            lpSysColors = UserAllocPoolWithQuota(nCount * sizeof(*pSysColor), TAG_COLORS);
            if (lpSysColors == NULL) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            RtlCopyMemory(lpSysColors, pSysColor, nCount * sizeof(*pSysColor));
            lpSysColorValues = UserAllocPoolWithQuota(nCount * sizeof(*pColorValues), TAG_COLORVALUES);
            if (lpSysColorValues == NULL) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            RtlCopyMemory(lpSysColorValues, pColorValues, nCount * sizeof(*pColorValues));

        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
    }

    ThreadLockPool(ptiCurrent, lpSysColors, &tlSysColors);
    ThreadLockPool(ptiCurrent, lpSysColorValues, &tlSysColorValues);
    pProfileUserName = CreateProfileUserName(&tlName);
    retval = xxxSetSysColors(pProfileUserName,
                nCount,
                lpSysColors,
                lpSysColorValues,
                uOptions
                );
    FreeProfileUserName(pProfileUserName, &tlName);
    ThreadUnlockPool(ptiCurrent, &tlSysColorValues);
    ThreadUnlockPool(ptiCurrent, &tlSysColors);

    CLEANUPRECV();
    if (lpSysColors)
        UserFreePool(lpSysColors);
    if (lpSysColorValues)
        UserFreePool(lpSysColorValues);

    TRACE("NtUserSetSysColors");
    ENDRECV();
}

UINT_PTR NtUserSetTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent,
    IN UINT wElapse,
    IN TIMERPROC pTimerFunc)
{
    PWND pwnd;

    BEGINATOMICRECV(UINT_PTR, 0);

    ValidateHWNDOPT(pwnd, hwnd);

    /*
     * We have code on the client side that assumes no CSRSS code creates
     * a timer with a timer proc, so assert that that's the case.
     */
    UserAssert(PsGetCurrentProcess() != gpepCSRSS || pTimerFunc == NULL);

    /*
     * If we let apps set a timer granularity less then 10 the app
     * spends too long processing timer messages. Some WOW apps like
     * Paradox in WinStone use zero to effectively get the minimal
     * timer value which was ~55ms in Win 3.1. We also step this
     * value up for 32 bit apps because the NT timer resolution
     * can very depending if the multimedia timers have turned up
     * the resolution. If they have NT apps that specify a low value
     * will not work properly because they will eat the CPU processing
     * WM_TIMER messages.
     */
    if (wElapse < 10) {
        wElapse = 10;
    }

    retval = _SetTimer(
            pwnd,
            nIDEvent,
            wElapse,
            (TIMERPROC_PWND)pTimerFunc);

    TRACE("NtUserSetTimer");
    ENDATOMICRECV();
}

LONG_PTR NtUserSetWindowLongPtr(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG_PTR dwNewLong,
    IN BOOL bAnsi)
{
    BEGINRECV_HWNDLOCK(ULONG_PTR, 0, hwnd);

    retval = xxxSetWindowLongPtr(
            pwnd,
            nIndex,
            dwNewLong,
            bAnsi);

    TRACE("NtUserSetWindowLongPtr");
    ENDRECV_HWNDLOCK();
}

#ifdef _WIN64
LONG NtUserSetWindowLong(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG dwNewLong,
    IN BOOL bAnsi)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    retval = xxxSetWindowLong(
            pwnd,
            nIndex,
            dwNewLong,
            bAnsi);

    TRACE("NtUserSetWindowLong");
    ENDRECV_HWNDLOCK();
}
#endif

WORD NtUserSetWindowWord(
    IN HWND hwnd,
    IN int nIndex,
    IN WORD wNewWord)
{
    BEGINRECV_HWND(WORD, 0, hwnd);

    retval = _SetWindowWord(
            pwnd,
            nIndex,
            wNewWord);

    TRACE("NtUserSetWindowWord");
    ENDRECV_HWND();
}

HHOOK NtUserSetWindowsHookAW(
    IN int nFilterType,
    IN HOOKPROC pfnFilterProc,
    IN DWORD dwFlags)
{
    BEGINRECV(HHOOK, NULL);

    retval = (HHOOK)zzzSetWindowsHookAW(
            nFilterType,
            (PROC)pfnFilterProc,
            dwFlags);

    TRACE("NtUserSetWindowsHookAW");
    ENDRECV();
}

BOOL NtUserShowCaret(
    IN HWND hwnd)
{
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = zzzShowCaret(
            pwnd);

    TRACE("NtUserShowCaret");
    ENDRECV();
}

BOOL NtUserShowScrollBar(
    IN HWND hwnd,
    IN int iBar,
    IN BOOL fShow)
{
    BEGINRECV_HWNDLOCK_ND(DWORD, 0, hwnd);

    LIMITVALUE(iBar, SB_MAX, "ShowScrollBar");

    retval = xxxShowScrollBar(
            pwndND,
            iBar,
            fShow);

    TRACE("NtUserShowScrollBar");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserShowWindowAsync(
    IN HWND hwnd,
    IN int nCmdShow)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    LIMITVALUE(nCmdShow, SW_MAX, "ShowWindowAsync");

    retval = _ShowWindowAsync(pwndND, nCmdShow, 0);

    TRACE("NtUserShowWindowAsync");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserShowWindow(
    IN HWND hwnd,
    IN int nCmdShow)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);

    LIMITVALUE(nCmdShow, SW_MAX, "ShowWindow");

    /*
     * Let's not allow the window to be shown/hidden once we
     * started the destruction of the window.
     */
    if (TestWF(pwndND, WFINDESTROY)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "ShowWindow: Window is being destroyed (%#p)",
                pwndND);
        MSGERROR(0);
    }

    retval = xxxShowWindow(pwndND, nCmdShow | TEST_PUDF(PUDF_ANIMATE));

    TRACE("NtUserShowWindow");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserTrackMouseEvent(  // API TrackMouseEvent
    IN OUT LPTRACKMOUSEEVENT lpTME)
{
    TRACKMOUSEEVENT tme;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        tme = ProbeAndReadTrackMouseEvent(lpTME);

        if (tme.cbSize != sizeof(tme)) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "TrackMouseEvent: invalid size %lX", tme.cbSize);
            MSGERROR(0);
        }

        TESTFLAGS(tme.dwFlags, TME_VALID);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (tme.dwFlags & TME_QUERY) {
        retval = QueryTrackMouseEvent(&tme);
        try {
            RtlCopyMemory(lpTME, &tme, sizeof(tme));
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    } else {
        retval = TrackMouseEvent(&tme);
    }

    TRACE("NtUserTrackMouseEvent");
    ENDRECV();
}

BOOL NtUserTrackPopupMenuEx(  // API TrackPopupMenuEx
    IN HMENU hMenu,
    IN UINT uFlags,
    IN int x,
    IN int y,
    IN HWND hwnd,
    IN CONST TPMPARAMS *pparamst OPTIONAL)
{
    PWND pwnd;
    PMENU pmenu;
    TL tlpwnd;
    TL tlpMenu;
    PTHREADINFO ptiCurrent;
    TPMPARAMS paramst;

    BEGINRECV(BOOL, FALSE);

    TESTFLAGS(uFlags, TPM_VALID);

    ValidateHMENU(pmenu, hMenu);
    ValidateHWND(pwnd, hwnd);

    ptiCurrent = PtiCurrent();
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(pparamst)) {
            paramst = ProbeAndReadPopupParams(pparamst);
            pparamst = &paramst;
        }

    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }
    retval = xxxTrackPopupMenuEx(
                pmenu,
                uFlags,
                x,
                y,
                pwnd,
                pparamst);

    CLEANUPRECV();

    ThreadUnlock(&tlpMenu);
    ThreadUnlock(&tlpwnd);

    TRACE("NtUserTrackPopupMenuEx");
    ENDRECV();
}

UINT NtUserPaintMenuBar(
    IN HWND hwnd,
    IN HDC hdc,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN DWORD dwFlags)
{
    BEGINRECV_HWNDLOCK(UINT, 0, hwnd);

    TESTFLAGS(dwFlags, PMB_VALID);

    if (iLeftOffset < 0 || iRightOffset < 0 || iTopOffset < 0) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    retval = xxxPaintMenuBar(pwnd, hdc, iLeftOffset, iRightOffset, iTopOffset, dwFlags);

    TRACE("NtUserPaintMenuBar");
    ENDRECV_HWNDLOCK();
}

UINT NtUserCalcMenuBar(
    IN HWND hwnd,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN LPCRECT prcWnd)
{
    RECT rcWnd;

    BEGINRECV_HWNDLOCK(UINT, 0, hwnd);

    if (iLeftOffset < 0 || iRightOffset < 0 || iTopOffset < 0) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    try {
        if (ARGUMENT_PRESENT(prcWnd)) {
            rcWnd = ProbeAndReadRect(prcWnd);
        } else {
            CopyRect(&rcWnd, &pwnd->rcWindow);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCalcMenuBar(pwnd, iLeftOffset, iRightOffset, iTopOffset, &rcWnd);

    TRACE("NtUserCalcMenuBar");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserTranslateMessage(  // API TranslateMessage
    IN CONST MSG *lpMsg,
    IN UINT flags)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        msg = ProbeAndReadMessage(lpMsg);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (ValidateHwnd(msg.hwnd) == NULL) {
        MSGERROR(0);
    }

    retval = xxxTranslateMessage(
            &msg,
            flags);

    TRACE("NtUserTranslateMessage");
    ENDRECV();
}

BOOL NtUserUnhookWindowsHookEx(
    IN HHOOK hhk)
{
    PHOOK phk;

    BEGINRECV(BOOL, FALSE);

    ValidateHHOOK(phk, hhk);

    retval = zzzUnhookWindowsHookEx(
            phk);

    TRACE("NtUserUnhookWindowsHookEx");
    ENDRECV();
}

BOOL NtUserUnregisterHotKey(
    IN HWND hwnd,
    IN int id)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = _UnregisterHotKey(
            pwnd,
            id);

    TRACE("NtUserUnregisterHotKey");
    ENDATOMICRECV();
}

BOOL NtUserValidateRect(  // API ValidateRect
    IN HWND hwnd,
    IN CONST RECT *lpRect OPTIONAL)
{
    PWND pwnd;
    TL tlpwnd;
    RECT rc;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lpRect)) {
        try {
            rc = ProbeAndReadRect(lpRect);
            lpRect = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    ValidateHWNDOPT(pwnd, hwnd);

    ThreadLock(pwnd, &tlpwnd);

    retval = xxxValidateRect(pwnd, (PRECT)lpRect);

    ThreadUnlock(&tlpwnd);

    TRACE("NtUserValidateRect");
    ENDRECV();
}

DWORD NtUserWaitForInputIdle(
    IN ULONG_PTR idProcess,
    IN DWORD dwMilliseconds,
    IN BOOL fSharedWow)
{
    BEGINRECV(DWORD, (DWORD)-1);

    retval = xxxWaitForInputIdle(
            idProcess,
            dwMilliseconds,
            fSharedWow);

    TRACE("NtUserWaitForInputIdle");
    ENDRECV();
}

HWND NtUserWindowFromPoint(
    IN POINT Point)
{
    BEGINRECV(HWND, NULL);

    retval = (HWND)xxxWindowFromPoint(
            Point);
    retval = PtoH((PVOID)retval);

    TRACE("NtUserWindowFromPoint");
    ENDRECV();
}

HDC NtUserBeginPaint(  // API BeginPaint
    IN HWND hwnd,
    OUT LPPAINTSTRUCT lpPaint)
{
    PAINTSTRUCT ps;

    BEGINRECV_HWNDLOCK(HDC, NULL, hwnd);

    retval = xxxBeginPaint(pwnd, &ps);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(lpPaint, ps, PAINTSTRUCT);
    } except (StubExceptionHandler(TRUE)) {
        xxxEndPaint(pwnd, &ps);
        MSGERROR(0);
    }

    TRACE("NtUserBeginPaint");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserCreateCaret(
    IN HWND hwnd,
    IN HBITMAP hBitmap,
    IN int nWidth,
    IN int nHeight)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    retval = xxxCreateCaret(
            pwnd,
            hBitmap,
            nWidth,
            nHeight
    );

    TRACE("NtUserCreateCaret");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserEndPaint(  // API EndPaint
    IN HWND hwnd,
    IN CONST PAINTSTRUCT *lpPaint)
{
    PAINTSTRUCT ps;

    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        ps = ProbeAndReadPaintStruct(lpPaint);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxEndPaint(pwnd, &ps);

    TRACE("NtUserEndPaint");
    ENDRECV_HWNDLOCK();
}

int NtUserExcludeUpdateRgn(
    IN HDC hdc,
    IN HWND hwnd)
{
    BEGINRECV_HWND(int, ERROR, hwnd);

    if (hdc == NULL)
        MSGERROR(0);

    retval = _ExcludeUpdateRgn(hdc, pwnd);

    TRACE("NtUserExcludeUpdateRgn");
    ENDRECV_HWND();
}

HDC NtUserGetDC(
    IN HWND hwnd)
{
    PWND pwnd;
    BOOL bValid = TRUE;

    BEGINATOMICRECV(HDC, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_HANDLES) && pwnd == NULL) {

        PDESKTOP pdesk = PtiCurrent()->rpdesk;

        /*
         * make sure it has access to the desktop window
         */
        if (!ValidateHwnd(PtoH(pdesk->pDeskInfo->spwnd))) {
            bValid = FALSE;
        }
    }

    retval = _GetDC(pwnd);

    if (!bValid) {

        HRGN hrgn;

        /*
         * Select a NULL visible region on this DC so that restricted
         * processes don't mess with GetDC(NULL)
         */
        hrgn = CreateEmptyRgn();

        GreSelectVisRgn(retval, hrgn, SVR_DELETEOLD);
    }

    TRACE("NtUserGetDC");
    ENDATOMICRECV();
}

HDC NtUserGetDCEx(
    IN HWND hwnd,
    IN HRGN hrgnClip,
    IN DWORD flags)
{
    PWND pwnd;

    BEGINATOMICRECV(HDC, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    if (pwnd == NULL) {
        pwnd = PtiCurrent()->rpdesk->pDeskInfo->spwnd;

        if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_HANDLES)) {
            /*
             * make sure it has access to the desktop window
             */
            if (!ValidateHwnd(PtoH(pwnd))) {
                RIPMSG0(RIP_WARNING,
                        "NtUserGetDCEx fails desktop window validation");
                MSGERROR(0);
            }
        }
    }

    retval = _GetDCEx(
            pwnd,
            hrgnClip,
            flags);

    TRACE("NtUserGetDCEx");
    ENDATOMICRECV();
}

HDC NtUserGetWindowDC(
    IN HWND hwnd)
{
    PWND pwnd;

    BEGINATOMICRECV(HDC, NULL);

    ValidateHWNDOPT(pwnd, hwnd);

    retval = _GetWindowDC(pwnd);

    TRACE("NtUserGetWindowDC");
    ENDATOMICRECV();
}

int NtUserGetUpdateRgn(
    IN HWND hwnd,
    IN HRGN hrgn,
    IN BOOL bErase)
{
    BEGINRECV_HWNDLOCK(int, ERROR, hwnd);

    retval = xxxGetUpdateRgn(
            pwnd,
            hrgn,
            bErase);

    TRACE("NtUserGetUpdateRgn");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserRedrawWindow(  // API RedrawWindow
    IN HWND hwnd,
    IN CONST RECT *lprcUpdate OPTIONAL,
    IN HRGN hrgnUpdate,
    IN UINT flags)
{
    RECT rc;

    BEGINRECV_HWNDLOCK_OPT(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lprcUpdate)) {
        try {
            rc = ProbeAndReadRect(lprcUpdate);
            lprcUpdate = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TESTFLAGS(flags, RDW_VALIDMASK);

    retval = xxxRedrawWindow(
            pwnd,
            (PRECT)lprcUpdate,
            hrgnUpdate,
            flags);

    TRACE("NtUserRedrawWindow");
    ENDRECV_HWNDLOCK_OPT();
}

BOOL NtUserInvalidateRgn(
    IN HWND hwnd,
    IN HRGN hrgn,
    IN BOOL bErase)
{
    BEGINRECV_HWNDLOCK(BOOL, FALSE, hwnd);

    retval = xxxInvalidateRgn(
            pwnd,
            hrgn,
            bErase);

    TRACE("NtUserInvalidateRgn");
    ENDRECV_HWNDLOCK();
}

int NtUserSetWindowRgn(
    IN HWND hwnd,
    IN HRGN hrgn,
    IN BOOL bRedraw)
{
    BEGINRECV_HWNDLOCK_ND(int, 0, hwnd);

    retval = xxxSetWindowRgn(
            pwndND,
            hrgn,
            bRedraw);

    TRACE("NtUserSetWindowRgn");
    ENDRECV_HWNDLOCK_ND();
}

BOOL NtUserScrollDC(  // API ScrollDC
    IN HDC hdc,
    IN int dx,
    IN int dy,
    IN CONST RECT *prcScroll OPTIONAL,
    IN CONST RECT *prcClip OPTIONAL,
    IN HRGN hrgnUpdate,
    OUT LPRECT prcUpdate OPTIONAL)
{
    RECT rcScroll;
    RECT rcClip;
    RECT rcUpdate;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(prcScroll)) {
            rcScroll = ProbeAndReadRect(prcScroll);
            prcScroll = &rcScroll;
        }
        if (ARGUMENT_PRESENT(prcClip)) {
            rcClip = ProbeAndReadRect(prcClip);
            prcClip = &rcClip;
        }

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }
    retval = _ScrollDC(
                hdc,
                dx,
                dy,
                (PRECT)prcScroll,
                (PRECT)prcClip,
                hrgnUpdate,
                prcUpdate ? &rcUpdate : NULL);

    if (ARGUMENT_PRESENT(prcUpdate)) {
        try {
            ProbeAndWriteStructure(prcUpdate, rcUpdate, RECT);
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }
    ENDRECV();
}

int NtUserInternalGetWindowText(  // private InternalGetWindowText
    IN HWND hwnd,
    OUT LPWSTR lpString,
    IN int nMaxCount)
{
    BEGINRECV_HWND_SHARED(DWORD, 0, hwnd);

    if (nMaxCount) {
        /*
         * Probe arguments
         */
        try {
            ProbeForWriteBuffer(lpString, nMaxCount, CHARALIGN);
           /*
            * Initialize string empty.
            */
            *lpString = TEXT('\0');
            if (pwnd->strName.Length) {
                retval = TextCopy(&pwnd->strName, lpString, nMaxCount);
            } else {
                retval = 0;
            }

        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0); // private API, don't SetLastError
        }
    } else {
        MSGERROR(0);
    }

    TRACE("NtUserInternalGetWindowText");
    ENDRECV_HWND_SHARED();
}

int NtUserGetMouseMovePointsEx(  // API GetMouseMovePointsEx
    IN UINT             cbSize,
    IN CONST MOUSEMOVEPOINT *lppt,
    OUT MOUSEMOVEPOINT *lpptBuf,
    IN UINT             nBufPoints,
    IN DWORD            resolution)
{
    MOUSEMOVEPOINT mmp;
    BEGINRECV(int, -1);

    if (cbSize != sizeof(MOUSEMOVEPOINT) || nBufPoints > MAX_MOUSEPOINTS) {

        RIPERR2(ERROR_INVALID_PARAMETER, RIP_VERBOSE,
                "GetMouseMovePointsEx: invalid cbSize %d or nBufPoints %d",
                cbSize, nBufPoints);
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        mmp = ProbeAndReadStructure(lppt, MOUSEMOVEPOINT);
        ProbeForWriteBuffer(lpptBuf, nBufPoints, DATAALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * GetMouseMovePointsEx protects itself with a try block.
     * No it doesn't!
     */

    retval = _GetMouseMovePointsEx(&mmp, lpptBuf, nBufPoints, resolution);

    TRACE("NtUserGetMouseMovePointsEx");
    ENDRECV();
}

int NtUserToUnicodeEx(  // API ToUnicode/ToUnicodeEx/ToAscii/ToAsciiEx
    IN UINT wVirtKey,
    IN UINT wScanCode,
    IN CONST BYTE *lpKeyState,
    OUT LPWSTR pwszBuff,
    IN int cchBuff,
    IN UINT wFlags,
    IN HKL hKeyboardLayout)
{
    BYTE KeyState[256];
    WCHAR wcBuff[4];
    LPWSTR pwszBuffK;
    BOOL bAlloc = FALSE;
    PTHREADINFO ptiCurrent;
    TL tlInput;

    BEGINRECV(int, 0);

    if (cchBuff <= 0) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(lpKeyState, 256, sizeof(BYTE));
        RtlCopyMemory(&KeyState, lpKeyState, 256);
        ProbeForWriteBuffer(pwszBuff, cchBuff, CHARALIGN);
        if (cchBuff < 4) {
            pwszBuffK = wcBuff;
        }else {
            pwszBuffK = UserAllocPoolWithQuota(cchBuff * sizeof(WCHAR), TAG_UNICODEBUFFER);
            if (pwszBuffK == NULL) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            bAlloc = TRUE;
            ptiCurrent = PtiCurrent();
            ThreadLockPool(ptiCurrent, pwszBuffK, &tlInput);
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = xxxToUnicodeEx(
                wVirtKey,
                wScanCode,
                KeyState,
                pwszBuffK,
                cchBuff,
                wFlags,
                hKeyboardLayout);

    try {
        RtlCopyMemory(pwszBuff, pwszBuffK, cchBuff*sizeof(WCHAR));
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    CLEANUPRECV();

    if (bAlloc) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlInput);
    }

    TRACE("NtUserToUnicodeEx");
    ENDRECV();
}

BOOL NtUserYieldTask(
    VOID)
{
    PTHREADINFO ptiCurrent;

    BEGINRECV(BOOL, FALSE);

    /*
     * Make sure this process is running in the background if it is just
     * spinning.
     */
    ptiCurrent = PtiCurrent();

    ptiCurrent->pClientInfo->cSpins++;

    /*
     * CheckProcessBackground see input.c for comments
     */
    if (ptiCurrent->pClientInfo->cSpins >= CSPINBACKGROUND) {
        ptiCurrent->pClientInfo->cSpins = 0;
        ptiCurrent->TIF_flags |= TIF_SPINNING;
        ptiCurrent->pClientInfo->dwTIFlags |= TIF_SPINNING;

        if (!(ptiCurrent->ppi->W32PF_Flags & W32PF_FORCEBACKGROUNDPRIORITY)) {
            ptiCurrent->ppi->W32PF_Flags |= W32PF_FORCEBACKGROUNDPRIORITY;
            if (ptiCurrent->ppi == gppiWantForegroundPriority) {
                SetForegroundPriority(ptiCurrent, FALSE);
            }
        }
    }

    retval = xxxUserYield(ptiCurrent);

    TRACE("NtUserYieldTask");
    ENDRECV();
}

BOOL NtUserWaitMessage(
    VOID)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxWaitMessage();

    TRACE("NtUserWaitMessage");
    ENDRECV();
}


#ifdef MESSAGE_PUMP_HOOK

BOOL NtUserRealWaitMessageEx(
    IN UINT fsWakeMask,
    IN DWORD Timeout)
{
    BEGINRECV(BOOL, FALSE);
    TESTFLAGS(fsWakeMask, QS_VALID);

    if (!IsInsideMPH()) {
        RIPMSG0(RIP_WARNING, "NtUserRealWaitMessageEx: Calling MPH function on non-initialized thread");
    }

    retval = xxxRealWaitMessageEx(fsWakeMask, Timeout);

    TRACE("NtUserRealWaitMessage");
    ENDRECV();
}

#endif // MESSAGE_PUMP_HOOK


UINT NtUserLockWindowStation(
    IN HWINSTA hwinsta)
{
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;

    BEGINRECV(UINT, 0);

    Status = ValidateHwinsta(hwinsta, UserMode, 0, &pwinsta);
    if (!NT_SUCCESS(Status))
        MSGERROR(0);

    retval = _LockWindowStation(pwinsta);

    ObDereferenceObject(pwinsta);

    TRACE("NtUserLockWindowStation");
    ENDRECV();
}

BOOL NtUserUnlockWindowStation(
    IN HWINSTA hwinsta)
{
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    Status = ValidateHwinsta(hwinsta, UserMode, 0, &pwinsta);
    if (!NT_SUCCESS(Status))
        MSGERROR(0);

    retval = _UnlockWindowStation(pwinsta);

    ObDereferenceObject(pwinsta);

    TRACE("NtUserUnlockWindowStation");
    ENDRECV();
}

UINT NtUserSetWindowStationUser(  // private SetWindowStationUser
    IN HWINSTA hwinsta,
    IN PLUID pLuidUser,
    IN PSID pSidUser OPTIONAL,
    IN DWORD cbSidUser)
{
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;
    LUID luid;
    BEGINATOMICRECV(UINT, FALSE);

    Status = ValidateHwinsta(hwinsta, UserMode, 0, &pwinsta);
    if (!NT_SUCCESS(Status))
        MSGERROR(0);

    try {
        ProbeForRead(pLuidUser, sizeof(*pLuidUser), sizeof(DWORD));
        luid = *pLuidUser;
        if (ARGUMENT_PRESENT(pSidUser)) {
            ProbeForRead(pSidUser, cbSidUser, sizeof(DWORD));
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);  // don't SetLastError for private API
    }

    /*
     * SetWindowStationUser uses pSidUser in a try block.
     */

    retval = _SetWindowStationUser(pwinsta, &luid, pSidUser, cbSidUser);

    CLEANUPRECV();

    ObDereferenceObject(pwinsta);

    TRACE("NtUserSetWindowStationUser");
    ENDATOMICRECV();
}

BOOL NtUserSetLogonNotifyWindow(
    IN HWND hwnd)
{
    BEGINRECV_HWND(BOOL, FALSE, hwnd);

    retval = _SetLogonNotifyWindow(pwnd);

    TRACE("NtUserSetLogonNotifyWindow");
    ENDRECV_HWND();
}

BOOL NtUserSetSystemCursor(
    IN HCURSOR hcur,
    IN DWORD id)
{
    PCURSOR pcur;

    BEGINRECV(BOOL, FALSE);

    ValidateHCURSOR(pcur, hcur);

    retval = zzzSetSystemCursor(
            pcur,
            id);

    TRACE("NtUserSetSystemCursor");
    ENDRECV();
}

HCURSOR NtUserGetCursorFrameInfo(  // private GetCursorFrameInfo (Obsolete? - IanJa)
    IN HCURSOR hcur,
    IN int iFrame,
    OUT LPDWORD pjifRate,
    OUT LPINT pccur)
{
    PCURSOR pcur, pcurRet;
    DWORD jifRate;
    INT ccur;

    BEGINRECV_SHARED(HCURSOR, NULL);

    ValidateHCURSOR(pcur, hcur);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteUlong(pjifRate);
        ProbeForWriteLong(pccur);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);  // don't SetLastError for private API
    }

    pcurRet = _GetCursorFrameInfo(
                pcur,
                iFrame,
                &jifRate,
                &ccur);
    if (pcurRet != NULL) {
        retval = PtoH(pcurRet);
        try {
            *pjifRate = jifRate;
            *pccur = ccur;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);  // don't SetLastError for private API
        }
    } else {
        retval = NULL;
    }

    TRACE("NtUserGetCursorFrameInfo");
    ENDRECV_SHARED();
}

BOOL NtUserSetCursorContents(
    IN HCURSOR hCursor,
    IN HCURSOR hCursorNew)
{
    PCURSOR pCursor;
    PCURSOR pCursorNew;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHCURSOR(pCursor, hCursor);
    ValidateHCURSOR(pCursorNew, hCursorNew);

    retval = _SetCursorContents(pCursor, pCursorNew);

    TRACE("NtUserSetCursorContents");
    ENDATOMICRECV();
}

HCURSOR NtUserFindExistingCursorIcon(  // Various Icon/Cursor APIs
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrResName,
    IN PCURSORFIND     pcfSearch)
{
    ATOM           atomModName;
    UNICODE_STRING strModName;
    UNICODE_STRING strResName;
    PCURSOR        pcurSrc;
    CURSORFIND     cfSearch;

    BEGINRECV_SHARED(HCURSOR, NULL);

    /*
     * Probe arguments
     */
    try {

        cfSearch = ProbeAndReadCursorFind(pcfSearch);

        ValidateHCURSOROPT(pcurSrc, cfSearch.hcur);

        strModName = ProbeAndReadUnicodeString(pstrModName);
        ProbeForReadUnicodeStringBuffer(strModName);

        strResName = ProbeAndReadUnicodeString(pstrResName);
        ProbeForReadUnicodeStringBufferOrId(strResName);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * The ModName buffer is client-side, but UserFindAtom protects
     * access.
     */

    atomModName = UserFindAtom(strModName.Buffer);

    if (atomModName) {

        /*
         * The ResName buffer is client-side. FindExistincCursorIcon
         * protects access.
         */
        retval = (HCURSOR)_FindExistingCursorIcon(atomModName,
                                                  &strResName,
                                                  pcurSrc,
                                                  &cfSearch);

        retval = (HCURSOR)PtoH((PCURSOR)retval);

    } else {

        retval = 0;
    }


    TRACE("NtUserFindExistingCursorIcon");
    ENDRECV_SHARED();
}

BOOL NtUserSetCursorIconData(  // worker called by CreateIcon, CreateCursor etc.
    IN HCURSOR         hCursor,
    IN PUNICODE_STRING pstrModName,
    IN PUNICODE_STRING pstrResName,
    IN PCURSORDATA     pData)
{
    UNICODE_STRING strModName;
    UNICODE_STRING strResName;
    PCURSOR        pCursor;
    CURSORDATA     curData;
    DWORD          cbData;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHCURSOR(pCursor, hCursor);

    /*
     * Probe arguments
     */
    try {

        strModName = ProbeAndReadUnicodeString(pstrModName);
        strResName = ProbeAndReadUnicodeString(pstrResName);

        ProbeForReadUnicodeStringBuffer(strModName);
        ProbeForReadUnicodeStringBufferOrId(strResName);

        curData = ProbeAndReadCursorData(pData);

        if (curData.CURSORF_flags & CURSORF_ACON) {
            /*
             * Avoid overflow here, or we might end up probing less.
             * MCostea #199188
             */
            if (HIWORD(curData.cpcur) | HIWORD(curData.cicur)) {
                MSGERROR(0);
            }

            /*
             * The code assumes that the memory was allocated in one chunk
             * as in CreateAniIcon(). To prevent evil apps, do this check.
             */
            if ((INT_PTR)curData.ajifRate != curData.cpcur * (INT_PTR) sizeof(HCURSOR) ||
                (INT_PTR)curData.aicur != (INT_PTR)curData.ajifRate + curData.cicur * (INT_PTR) sizeof(JIF)) {
                MSGERROR(0);
            }
            cbData = (curData.cpcur * sizeof(HCURSOR)) +
                     (curData.cicur * sizeof(JIF)) +
                     (curData.cicur * sizeof(DWORD));

        } else {
            cbData = 0;
        }
        ProbeForRead(curData.aspcur, cbData, sizeof(DWORD));

    } except (StubExceptionHandler(FALSE)) {
        /*
         * Probed parameters are USER stack variables, not supplied by the
         * application itself, so don't bother to SetLastError.
         */
        MSGERROR(0);
    }

    /*
     * SetCursorIconData guards use of the buffer addresses with try clauses.
     */
    retval = _SetCursorIconData(pCursor,
                                    &strModName,
                                    &strResName,
                                    &curData,
                                    cbData);

    TRACE("NtUserSetCursorIconData");
    ENDATOMICRECV();
}

BOOL NtUserGetMenuItemRect(  // API GetMenuItemRect
    IN HWND hwnd,
    IN HMENU hMenu,
    IN UINT uItem,
    OUT LPRECT lprcItem)
{
    PMENU pmenu;
    TL tlpMenu;
    RECT rcItem;

    BEGINRECV_HWNDLOCK_OPT(DWORD, 0, hwnd);

    ValidateHMENU(pmenu, hMenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval = xxxGetMenuItemRect(
                pwnd,
                pmenu,
                uItem,
                &rcItem);
    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure(lprcItem, rcItem, RECT);
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    CLEANUPRECV();

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserGetMenuItemRect");
    ENDRECV_HWNDLOCK_OPT();
}

int NtUserMenuItemFromPoint(  // API MenuItemFromPoint
    IN HWND hwnd,
    IN HMENU hMenu,
    IN POINT ptScreen)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV_HWNDLOCK_OPT(DWORD, -1, hwnd);

    ValidateHMENU(pmenu, hMenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval = xxxMenuItemFromPoint(
            pwnd,
            pmenu,
            ptScreen);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserMenuItemFromPoint");
    ENDRECV_HWNDLOCK_OPT();
}

BOOL NtUserGetCaretPos(  // API GetCaretPos
    OUT LPPOINT lpPoint)
{
    PTHREADINFO pti;
    PQ pq;
    BEGINRECV_SHARED(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        ProbeForWritePoint(lpPoint);

        pti = PtiCurrentShared();
        pq = pti->pq;
        lpPoint->x = pq->caret.x;
        lpPoint->y = pq->caret.y;
        retval = TRUE;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetCaretPos");
    ENDRECV_SHARED();
}

BOOL NtUserDefSetText(
    IN HWND hwnd,
    IN PLARGE_STRING pstrText OPTIONAL)
{
    LARGE_STRING strText;

    BEGINRECV_HWND(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(pstrText)) {
        try {
            strText = ProbeAndReadLargeString(pstrText);
#if defined(_X86_)
            ProbeForRead(strText.Buffer, strText.Length, sizeof(BYTE));
#else
            ProbeForRead(strText.Buffer, strText.Length,
                    strText.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
            pstrText = &strText;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);  // WM_SETTEXT lParam
        }
    }

    /*
     * pstrText buffer is client side. DefSetText protects uses of the buffer.
     */
    retval = DefSetText(
            pwnd,
            pstrText);

    TRACE("NtUserDefSetText");
    ENDRECV_HWND();
}

NTSTATUS NtUserQueryInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);
    /*
     * note -- QueryInformationThread can call xxxSwitchDesktop, so it is not sharable
     */

    /*
     * Probe arguments -- no try/except
     */

#if DBG
    if (ARGUMENT_PRESENT(ThreadInformation)) {
        switch (ThreadInfoClass) {
        case UserThreadShutdownInformation:
        case UserThreadFlags:
        case UserThreadWOWInformation:
        case UserThreadHungStatus:
            ProbeForWriteBoolean((PBOOLEAN)ThreadInformation);
            break;
        case UserThreadTaskName:
            ProbeForWrite(ThreadInformation, ThreadInformationLength,
                    sizeof(WCHAR));
            break;
        }
    }
    if (ARGUMENT_PRESENT(ReturnLength))
        ProbeForWriteUlong(ReturnLength);
#endif

    retval = xxxQueryInformationThread(hThread,
            ThreadInfoClass, ThreadInformation,
            ThreadInformationLength, ReturnLength);

    TRACE("NtUserQueryInformationThread");
    ENDRECVCSRSS();
}

NTSTATUS NtUserSetInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * Probe arguments outside a try clause -- CSRSS
     */
#if DBG
    if (ThreadInfoClass == UserThreadUseDesktop) {
        ProbeForWrite(ThreadInformation, ThreadInformationLength,
                sizeof(DWORD));
    } else {
        ProbeForRead(ThreadInformation, ThreadInformationLength,
                sizeof(DWORD));
    }

#endif

    retval = xxxSetInformationThread(hThread,
                ThreadInfoClass, ThreadInformation,
                ThreadInformationLength);


    TRACE("NtUserSetInformationThread");
    ENDRECVCSRSS();
}

NTSTATUS NtUserSetInformationProcess(
    IN HANDLE hProcess,
    IN USERPROCESSINFOCLASS ProcessInfoClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength)
{
    BEGINRECVCSRSS(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * Probe arguments without try/except
     */
#if DBG
    ProbeForRead(ProcessInformation, ProcessInformationLength,
                sizeof(DWORD));
#endif

    retval = SetInformationProcess(hProcess,
                    ProcessInfoClass, ProcessInformation,
                    ProcessInformationLength);


    TRACE("NtUserSetInformationProcess");
    ENDRECVCSRSS();
}

BOOL NtUserNotifyProcessCreate(
    IN DWORD dwProcessId,
    IN DWORD dwParentThreadId,
    IN ULONG_PTR dwData,
    IN DWORD dwFlags)
{
    extern BOOL xxxUserNotifyProcessCreate(DWORD idProcess, DWORD idParentThread,
            ULONG_PTR dwData, DWORD dwFlags);

    BEGINRECVCSRSS(BOOL, FALSE);

    retval = xxxUserNotifyProcessCreate(dwProcessId,
            dwParentThreadId,
            dwData,
            dwFlags);

    TRACE("NtUserNotifyProcessCreate");
    ENDRECVCSRSS();
}

NTSTATUS NtUserSoundSentry(VOID)
{
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    retval = (_UserSoundSentryWorker() ?
            STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

    TRACE("NtUserSoundSentry");
    ENDRECV();
}

NTSTATUS NtUserTestForInteractiveUser(  // private _UserTestTokenForInteractive
    IN PLUID pluidCaller)
{
    LUID luidCaller;

    BEGINRECV_SHARED(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * Probe arguments
     */
    try {
        luidCaller = ProbeAndReadStructure(pluidCaller, LUID);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = TestForInteractiveUser(&luidCaller);

    TRACE("NtUserTestForInteractiveUser");
    ENDRECV_SHARED();
}

BOOL NtUserSetConsoleReserveKeys(
    IN HWND hwnd,
    IN DWORD fsReserveKeys)
{
    BOOL _SetConsoleReserveKeys(PWND, DWORD);

    BEGINRECV_HWND(BOOL, FALSE, hwnd);

    retval = _SetConsoleReserveKeys(pwnd, fsReserveKeys);

    TRACE("NtUserSetConsoleReserveKeys");
    ENDRECV_HWND();
}

VOID NtUserModifyUserStartupInfoFlags(
    IN DWORD dwMask,
    IN DWORD dwFlags)
{
    BEGINRECV_VOID();

    PpiCurrent()->usi.dwFlags = (PpiCurrent()->usi.dwFlags & ~dwMask) | (dwFlags & dwMask);

    TRACEVOID("NtUserModifyUserStartupInfoFlags");
    ENDRECV_VOID();
}

BOOL NtUserSetWindowFNID(
    IN HWND hwnd,
    IN WORD fnid)
{
    BEGINRECV_HWND(BOOL, FALSE, hwnd);

    /*
     * Don't let apps mess with windows on other processes.
     */
    if (GETPTI(pwnd)->ppi != PpiCurrent()) {
        MSGERROR(0);
    }

    /*
     * Make sure the fnid is in the correct range.
     */
    if (fnid != FNID_CLEANEDUP_BIT) {
        if ((fnid < FNID_CONTROLSTART) || (fnid > FNID_CONTROLEND) || (GETFNID(pwnd) != 0)) {
            MSGERROR(0);
        }
    }

    /*
     * Remember what window class this window belongs to. Can't use
     * the real class because any app can call CallWindowProc()
     * directly no matter what the class is!
     */
    pwnd->fnid |= fnid;
    retval = TRUE;

    TRACE("NtUserSetWindowFNID");
    ENDRECV_HWND();
}

#define AWS_MASK (BS_TYPEMASK | BS_RIGHT | BS_RIGHTBUTTON | \
        WS_HSCROLL | WS_VSCROLL | SS_TYPEMASK)

VOID NtUserAlterWindowStyle(
    IN HWND hwnd,
    IN DWORD mask,
    IN DWORD flags)
{
    BEGINRECV_HWND_VOID(hwnd);

    if (GETPTI(pwnd)->ppi == PpiCurrent()) {

#if DBG
        if (mask & ~AWS_MASK) {
            RIPMSG1(RIP_WARNING, "NtUserAlterWindowStyle: bad mask %x", mask);
        }
#endif

        mask &= AWS_MASK;
        pwnd->style = (pwnd->style & (~mask)) | (flags & mask);
    } else {
        RIPMSG1(RIP_WARNING, "NtUserAlterWIndowStyle: current ppi doesn't own pwnd %#p", pwnd);
    }

    TRACEVOID("NtUserAlterWindowStyle");
    ENDRECV_HWND_VOID();
}

VOID NtUserSetThreadState(
    IN DWORD dwFlags,
    IN DWORD dwMask)
{
    PTHREADINFO ptiCurrent;
    DWORD dwOldFlags;

    if (dwFlags & ~(QF_DIALOGACTIVE)) {
        return;
    }

    BEGINRECV_VOID();

    ptiCurrent = PtiCurrent();
    dwOldFlags = ptiCurrent->pq->QF_flags;
    ptiCurrent->pq->QF_flags ^= ((dwOldFlags ^ dwFlags) & dwMask);

    TRACEVOID("NtUserSetThreadState");
    ENDRECV_VOID();
}


ULONG_PTR NtUserGetThreadState(
    IN USERTHREADSTATECLASS ThreadState)
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    BEGINRECV_SHARED(ULONG_PTR, 0);

    switch (ThreadState) {
    case UserThreadStateFocusWindow:
        retval = (ULONG_PTR)HW(ptiCurrent->pq->spwndFocus);
        break;
    case UserThreadStateActiveWindow:
        retval = (ULONG_PTR)HW(ptiCurrent->pq->spwndActive);
        break;
    case UserThreadStateCaptureWindow:
        retval = (ULONG_PTR)HW(ptiCurrent->pq->spwndCapture);
        break;
    case UserThreadStateDefaultImeWindow:
        retval = (ULONG_PTR)HW(ptiCurrent->spwndDefaultIme);
        break;
    case UserThreadStateDefaultInputContext:
        retval = (ULONG_PTR)PtoH(ptiCurrent->spDefaultImc);
        break;
    case UserThreadStateImeCompatFlags:
        UserAssert(ptiCurrent->ppi != NULL);
        retval = (DWORD)(ptiCurrent->ppi->dwImeCompatFlags);
        break;
    case UserThreadStatePreviousKeyboardLayout:
        retval = (ULONG_PTR)(ptiCurrent->hklPrev);
        break;
#ifdef OBSOLETE
    case UserThreadStateIsWinlogonThread:
        /*
         * This is no longer supported, for the securty breach bug.
         * The enum value is kept for the Wow16 compatibility.
         */
#endif

    case UserThreadStateNeedsSecurity:
        // Client IMM checks if the process is Login;
        // to prevent switching dictionaries, etc.
        // Also, needs to check the secure desktop, for
        // some accessibility applications run on the secure desktop.
        retval = (GetCurrentProcessId() == gpidLogon) || (ptiCurrent->rpdesk == grpdeskLogon);
#if DBG
        if (ptiCurrent->rpdesk == grpdeskLogon) {
            RIPMSG2(RIP_WARNING, "An app pti=%p is running on the secure desktop %p!", ptiCurrent, grpdeskLogon);
        }
#endif
        break;
    case UserThreadStateIsConImeThread:
        UserAssert(ptiCurrent->rpdesk != NULL);
        retval = (DWORD)(PtiFromThreadId(ptiCurrent->rpdesk->dwConsoleIMEThreadId) == ptiCurrent);
        break;
    case UserThreadStateInputState:
        retval = (DWORD)_GetInputState();
        break;
    case UserThreadStateCursor:
        retval = (ULONG_PTR)PtoH(ptiCurrent->pq->spcurCurrent);
        break;
    case UserThreadStateChangeBits:
        retval = ptiCurrent->pcti->fsChangeBits;
        break;
    case UserThreadStatePeekMessage:
        /*
         * Update the last read time so that hung app painting won't occur.
         */
        SET_TIME_LAST_READ(ptiCurrent);
        retval = (DWORD)FALSE;
        break;
    case UserThreadStateExtraInfo:
        retval = ptiCurrent->pq->ExtraInfo;
        break;

    case UserThreadStateInSendMessage:
        if (ptiCurrent->psmsCurrent != NULL) {
            if (ptiCurrent->psmsCurrent->ptiSender != NULL) {
                retval = ISMEX_SEND;
            } else if (ptiCurrent->psmsCurrent->flags & (SMF_CB_REQUEST | SMF_CB_REPLY)) {
                retval = ISMEX_CALLBACK;
            } else {
                retval = ISMEX_NOTIFY;
            }

            if (ptiCurrent->psmsCurrent->flags & SMF_REPLY) {
                retval |= ISMEX_REPLIED;
            }
        } else {
            retval = ISMEX_NOSEND;
        }
        break;

    case UserThreadStateMessageTime:
        retval = ptiCurrent->timeLast;
        break;
    case UserThreadStateIsForeground:
        retval = (ptiCurrent->pq == gpqForeground);
        break;
    case UserThreadConnect:
        retval = TRUE;
        break;
    default:
        RIPMSG1(RIP_WARNING, "NtUserGetThreadState invalid ThreadState:%#x", ThreadState);
        MSGERROR(0);
    }

    ENDRECV_SHARED();
}

BOOL NtUserValidateHandleSecure(
    IN HANDLE h)
{
    BEGINRECV(BOOL, FALSE);

    retval = ValidateHandleSecure(h);

    TRACE("NtUserValidateHandleSecure");
    ENDRECV();
}

BOOL NtUserUserHandleGrantAccess( // API UserHandleGrantAccess
    IN HANDLE hUserHandle,
    IN HANDLE hJob,
    IN BOOL   bGrant)
{
    NTSTATUS  Status;
    PEJOB     Job;
    PW32JOB   pW32Job;
    DWORD     dw;
    PHE       phe;
    PULONG_PTR pgh;
    BOOL      retval;
    BOOL      errret = FALSE;

    Status = ObReferenceObjectByHandle(
                    hJob,
                    JOB_OBJECT_SET_ATTRIBUTES,
                    *PsJobType,
                    UserMode,
                    (PVOID*)&Job,
                    NULL);

    if (!NT_SUCCESS(Status)) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "UserHandleGrantAccess: invalid job handle %#p\n",
                hJob);
        return FALSE;
    }

    /*
     * aquire the job's lock and after that enter the user
     * critical section.
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(PsGetJobLock(Job), TRUE);

    EnterCrit();

    /*
     * bail out if it doesn't have UI restrictions
     */
    if (PsGetJobUIRestrictionsClass(Job) == 0) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "UserHandleGrantAccess: job %#p doesn't have UI restrictions\n",
                hJob);
        MSGERRORCLEANUP(0);
    }

    /*
     * see if we have a W32JOB structure created for this job
     */
    pW32Job = gpJobsList;

    while (pW32Job) {
        if (pW32Job->Job == Job) {
            break;
        }
        pW32Job = pW32Job->pNext;
    }

    UserAssert(pW32Job != NULL);

    try {
        /*
         * Now, validate the 'unsecure' handle
         */
        if (HMValidateHandle(hUserHandle, TYPE_GENERIC) == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "UserHandleGrantAccess: invalid handle %#p\n",
                    hUserHandle);

            MSGERRORCLEANUP(0);
        }

        dw = HMIndexFromHandle(hUserHandle);

        phe = &gSharedInfo.aheList[dw];

        phe->bFlags |= HANDLEF_GRANTED;

        pgh = pW32Job->pgh;

        if (bGrant) {
            /*
             * Add the handle to the process' list
             */
            if (pW32Job->ughCrt == pW32Job->ughMax) {

                if (pW32Job->ughCrt == 0) {
                    pgh = UserAllocPool(GH_SIZE * sizeof(*pgh), TAG_GRANTEDHANDLES);
                } else {
                    /*
                     * we need to grow the array
                     */
                    DWORD uBytes = (pW32Job->ughMax) * sizeof(*pgh);

                    pgh = UserReAllocPool(pgh,
                                          uBytes,
                                          uBytes + GH_SIZE * sizeof(*pgh),
                                          TAG_GRANTEDHANDLES);
                }

                if (pgh == NULL) {
                    RIPMSG0(RIP_WARNING, "UserHandleGrantAccess: out of memory\n");
                    MSGERRORCLEANUP(ERROR_NOT_ENOUGH_MEMORY);
                }

                pW32Job->pgh     = pgh;
                pW32Job->ughMax += GH_SIZE;
            }

            UserAssert(pW32Job->ughCrt < pW32Job->ughMax);

            /*
             * see if the handle is not already granted to this process
             */
            for (dw = 0; dw < pW32Job->ughCrt; dw++) {
                if (*(pgh + dw) == (ULONG_PTR)hUserHandle) {
                    break;
                }
            }

            if (dw >= pW32Job->ughCrt) {

                /*
                 * add the handle to the granted handles table
                 */
                *(pgh + pW32Job->ughCrt) = (ULONG_PTR)hUserHandle;

                (pW32Job->ughCrt)++;
            }
        } else {
            /*
             * Remove the handle from the granted list
             */
            /*
             * search for the handle in the array.
             */
            for (dw = 0; dw < pW32Job->ughCrt; dw++) {
                if (*(pgh + dw) == (ULONG_PTR)hUserHandle) {

                    /*
                     * found the handle granted to this process
                     */
                    RtlMoveMemory(pgh + dw,
                                  pgh + dw + 1,
                                  (pW32Job->ughCrt - dw - 1) * sizeof(*pgh));

                    (pW32Job->ughCrt)--;
                    break;
                }
            }
#if DBG
            if (dw >= pW32Job->ughCrt) {
                RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING,
                        "UserHandleGrantAccess(FALSE): handle not found %#p",
                        hUserHandle);
            }
#endif // DBG
        }

        retval = TRUE;

    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    CLEANUPRECV();

    LeaveCrit();
    ExReleaseResourceLite(PsGetJobLock(Job));
    KeLeaveCriticalRegion();
    ObDereferenceObject(Job);

    TRACE("NtUserUserHandleGrantAccess");

    return retval;
}

HWND NtUserCreateWindowEx(
    IN DWORD dwExStyle,
    IN PLARGE_STRING pstrNVClassName,
    IN PLARGE_STRING pstrClassName,
    IN PLARGE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwStyle,
    IN int x,
    IN int y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hwndParent,
    IN HMENU hmenu,
    IN HANDLE hModule,
    IN LPVOID pParam,
    IN DWORD dwFlags,
    IN PACTIVATION_CONTEXT pActCtx)
{
    LARGE_STRING strNVClassName;
    LARGE_STRING strClassName;
    LARGE_STRING strWindowName;
    PWND pwndParent;
    PMENU pmenu;
    TL tlpwndParent;
    TL tlpMenu;
    BOOL fLockMenu = FALSE;
    PTHREADINFO ptiCurrent;

    BEGINRECV(HWND, NULL);

    if (hwndParent != HWND_MESSAGE) {
        ValidateHWNDOPT(pwndParent, hwndParent);
    } else
        pwndParent = _GetMessageWindow();


    /*
     * Win3.1 only checks for WS_CHILD before treating pmenu as an id. This
     * is a bug, because throughout the code, the real check is TestwndChild(),
     * which checks (style & (WS_CHILD | WS_POPUP)) == WS_CHILD. This is
     * because old style "iconic popup" is WS_CHILD | WS_POPUP. So... if on
     * win3.1 an app used ws_iconicpopup, menu validation would not occur
     * (could crash if hmenu != NULL). On Win32, check for the real thing -
     * but allow NULL!
     */
    ptiCurrent = PtiCurrent();
    if (((dwStyle & (WS_CHILD | WS_POPUP)) != WS_CHILD) &&
            (hmenu != NULL)) {
        ValidateHMENU(pmenu, hmenu);

        ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);
        fLockMenu = TRUE;

    } else {
        pmenu = (PMENU)hmenu;
    }

    /*
     * Mask out the new 5.0 extended style bits for apps
     * that would try to use them and we'll fail in xxxCreateWindowEx
     */
    if (GetAppCompatFlags2(VER40) & GACF2_NO50EXSTYLEBITSCW) {

#if DBG
        if (dwExStyle & ~(WS_EX_VALID40 | WS_EX_INTERNAL)) {
            RIPMSG0(RIP_WARNING, "CreateWindowEx: appcompat removed 5.0 EX bits");
        }
#endif

        dwExStyle &= (WS_EX_VALID40 | WS_EX_INTERNAL);
    }


    if ((dwExStyle & (WS_EX_ALLVALID | WS_EX_INTERNAL)) != dwExStyle) {
        RIPMSG0(RIP_WARNING, "CreateWindowEx: enforced not using private bits");

        /*
         * NOTE: Because WS_EX_ANSICREATOR is a reused bit, we actually need to
         * check for valid | internal instead of turning off the private bits.
         *
         * It is very important for us to do this because we need to ensure that
         * certain bits are not set, such as WS_EXP_COMPOSITING or
         * WS_EXP_REDIRECTED because we can fault if this bits were set without
         * properly setting up their accompanying data.
         */
        dwExStyle &= WS_EX_ALLVALID | WS_EX_INTERNAL;
    }


    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        if (IS_PTR(pstrNVClassName)) {
            strNVClassName = ProbeAndReadLargeString(pstrNVClassName);
            ProbeForRead(strNVClassName.Buffer, strNVClassName.Length,
                    sizeof(BYTE));
            pstrNVClassName = &strNVClassName;
        }
        if (IS_PTR(pstrClassName)) {
            strClassName = ProbeAndReadLargeString(pstrClassName);
            ProbeForRead(strClassName.Buffer, strClassName.Length,
                    sizeof(BYTE));
            pstrClassName = &strClassName;
        }
        if (ARGUMENT_PRESENT(pstrWindowName)) {
            strWindowName = ProbeAndReadLargeString(pstrWindowName);
            ProbeForRead(strWindowName.Buffer, strWindowName.Length,
                    sizeof(BYTE));
            pstrWindowName = &strWindowName;
        }
#else
        if (IS_PTR(pstrNVClassName)) {
            strNVClassName = ProbeAndReadLargeString(pstrNVClassName);
            ProbeForRead(strNVClassName.Buffer, strNVClassName.Length,
                    sizeof(WORD));
            pstrNVClassName = &strNVClassName;
        }
        if (IS_PTR(pstrClassName)) {
            strClassName = ProbeAndReadLargeString(pstrClassName);
            ProbeForRead(strClassName.Buffer, strClassName.Length,
                    sizeof(WORD));
            pstrClassName = &strClassName;
        }
        if (ARGUMENT_PRESENT(pstrWindowName)) {
            strWindowName = ProbeAndReadLargeString(pstrWindowName);
            ProbeForRead(strWindowName.Buffer, strWindowName.Length,
                    (strWindowName.bAnsi ? sizeof(BYTE) : sizeof(WORD)));
            pstrWindowName = &strWindowName;
        }
#endif
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    ThreadLockWithPti(ptiCurrent, pwndParent, &tlpwndParent);

    /*
     * The buffers for ClassName and WindowName are still in client space.
     */

    retval = (HWND)xxxCreateWindowEx(
            dwExStyle,
            pstrNVClassName,
            pstrClassName,
            pstrWindowName,
            dwStyle,
            x,
            y,
            nWidth,
            nHeight,
            pwndParent,
            pmenu,
            hModule,
            pParam,
            dwFlags,
            pActCtx);
    retval = PtoH((PVOID)retval);

    ThreadUnlock(&tlpwndParent);

    CLEANUPRECV();
    if (fLockMenu)
        ThreadUnlock(&tlpMenu);

    TRACE("NtUserCreateWindowEx");
    ENDRECV();
}

NTSTATUS NtUserBuildHwndList(  // worker for EnumWindows, EnumThreadWindows etc.
    IN HDESK hdesk,
    IN HWND hwndNext,
    IN BOOL fEnumChildren,
    IN DWORD idThread,
    IN UINT cHwndMax,
    OUT HWND *phwndFirst,
    OUT PUINT pcHwndNeeded)
{
    PWND pwndNext;
    PDESKTOP pdesk;
    PBWL pbwl;
    PTHREADINFO pti;
    UINT cHwndNeeded;
    UINT wFlags = BWL_ENUMLIST;
    BEGINATOMICRECV(NTSTATUS, STATUS_INVALID_HANDLE);

    if (IS_IME_ENABLED()) {
        // special treatment of IME Window
        wFlags |= BWL_ENUMIMELAST;
    }

    /*
     * Validate prior to referencing the desktop
     */
    ValidateHWNDOPT(pwndNext, hwndNext);

    if (idThread) {
        pti = PtiFromThreadId(idThread);
        if (pti == NULL || pti->rpdesk == NULL){
            MSGERROR(ERROR_INVALID_PARAMETER);
        }
        pwndNext = pti->rpdesk->pDeskInfo->spwnd->spwndChild;
    } else {
        pti = NULL;
    }

    if (hdesk) {
        retval = ValidateHdesk(hdesk, UserMode, DESKTOP_READOBJECTS, &pdesk);
        if (!NT_SUCCESS(retval)){
            MSGERROR(ERROR_INVALID_HANDLE);
        }
        pwndNext = pdesk->pDeskInfo->spwnd->spwndChild;
    } else {
        pdesk = NULL;
    }


    if (pwndNext == NULL) {
        /*
         * Bug: 262004 joejo
         * If we have a valid desk (just no windows on it), then we need
         * to fall through. Otherwise, we'll just grab the current desktop and enum it's
         * windows!
         */
        if (pdesk == NULL) {
            if (pti != NULL) {
                pwndNext = pti->rpdesk->pDeskInfo->spwnd->spwndChild;
            } else {
                pwndNext = _GetDesktopWindow()->spwndChild;
            }
        }
    } else {
        if (fEnumChildren) {
            wFlags |= BWL_ENUMCHILDREN;
            pwndNext = pwndNext->spwndChild;
        }
    }

    if ((pbwl = BuildHwndList(pwndNext, wFlags, pti)) == NULL) {
        MSGERRORCLEANUP(ERROR_NOT_ENOUGH_MEMORY);
    }

    cHwndNeeded = (UINT)(pbwl->phwndNext - pbwl->rghwnd) + 1;

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(phwndFirst, cHwndMax, sizeof(DWORD));
        ProbeForWriteUlong(pcHwndNeeded);

       /*
        * If we have enough space, copy out list of hwnds to user mode buffer.
        */
        if (cHwndNeeded <= cHwndMax) {
            RtlCopyMemory(phwndFirst, pbwl->rghwnd, cHwndNeeded * sizeof(HWND));
            retval = STATUS_SUCCESS;
        } else {
            retval = STATUS_BUFFER_TOO_SMALL;
        }
        *pcHwndNeeded = cHwndNeeded;
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);  // phwndFirst/pcHwndNeeded are USER's, not app's
    }

    CLEANUPRECV();

    if (pbwl != NULL) {
        FreeHwndList(pbwl);
    }

    if (pdesk != NULL) {
        LogDesktop(pdesk, LD_DEREF_VALIDATE_HDESK4, FALSE, (ULONG_PTR)PtiCurrent());
        ObDereferenceObject(pdesk);
    }

    TRACE("NtUserBuildHwndList");
    ENDATOMICRECV();
}

NTSTATUS NtUserBuildPropList(  // worker for EnumProps etc.
    IN HWND hwnd,
    IN UINT cPropMax,
    OUT PPROPSET pPropSet,
    OUT PUINT pcPropNeeded)
{
    BEGINRECV_HWNDLOCK(NTSTATUS, STATUS_INVALID_HANDLE, hwnd);

    if (cPropMax == 0) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(pPropSet, cPropMax, sizeof(DWORD));
        ProbeForWriteUlong(pcPropNeeded);

        retval = _BuildPropList(
                pwnd,
                pPropSet,
                cPropMax,
                pcPropNeeded);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);  // pPropSet/pcPropNeed are USER's, not app's
    }

    TRACE("NtUserBuildPropList");
    ENDRECV_HWNDLOCK();
}

NTSTATUS NtUserBuildNameList(  // worker for EnumWindowStations/EnumDesktops
    IN HWINSTA hwinsta,
    IN UINT cbNameList,
    OUT PNAMELIST pNameList,
    OUT PUINT pcbNeeded)
{
    UINT cbNeeded;
    PWINDOWSTATION pwinsta = NULL;

    BEGINRECV_SHARED(NTSTATUS, STATUS_INVALID_HANDLE);

    if (cbNameList < sizeof(NAMELIST)) {
        MSGERROR(0);
    }

    try {
        ProbeForWriteUlong(pcbNeeded);
        ProbeForWrite(pNameList, cbNameList, sizeof(DWORD));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    if (hwinsta != NULL) {
        retval = ValidateHwinsta(hwinsta, UserMode, WINSTA_ENUMDESKTOPS, &pwinsta);
    } else {
        retval = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(retval)) {
        try {
            *pNameList->awchNames = 0;
            pNameList->cb = 1;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }

     }  else {
        /*
         * Note -- pNameList is a client-side pointers.
         *         BuildNameList protects access with try blocks.
         */

        retval = _BuildNameList(
                    pwinsta,
                    pNameList,
                    cbNameList,
                    &cbNeeded);
        try {
            *pcbNeeded = cbNeeded;
        } except (StubExceptionHandler(FALSE)) {
            retval = STATUS_ACCESS_VIOLATION;
        }
    }

    if (pwinsta != NULL)
        ObDereferenceObject(pwinsta);

    TRACE("NtUserBuildNameList");
    ENDRECV_SHARED();
}

HKL NtUserActivateKeyboardLayout(
    IN HKL hkl,
    IN UINT Flags)
{
    BEGINRECV(HKL, NULL);

    /*
     * Prevent restricted threads from setting the keyboard layout
     * for the entire system.
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_HANDLES)) {
        MSGERROR(0);
    }

    retval = (HKL)xxxActivateKeyboardLayout(
                     _GetProcessWindowStation(NULL),
                     hkl,
                     Flags, NULL);

    TRACE("NtUserActivateKeyboardLayout");
    ENDRECV();
}

HKL NtUserLoadKeyboardLayoutEx(
    IN HANDLE hFile,
    IN DWORD offTable,
    IN PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    IN HKL hkl,
    IN PUNICODE_STRING pstrKLID,
    IN UINT KbdInputLocale,
    IN UINT Flags)
{
    UNICODE_STRING strKLID;
    PWINDOWSTATION pwinsta;
    WCHAR awchKF[KL_NAMELENGTH];
    UINT chMax;
    KBDTABLE_MULTI_INTERNAL kbdTableMulti;

    BEGINRECV(HKL, NULL);

    TESTFLAGS(Flags, KLF_VALID);

    pwinsta = _GetProcessWindowStation(NULL);

    /*
     * Probe arguments
     */
    try {
        strKLID = ProbeAndReadUnicodeString(pstrKLID);
        ProbeForRead(strKLID.Buffer, strKLID.Length, CHARALIGN);
        chMax = min(sizeof(awchKF) - sizeof(WCHAR), strKLID.Length) / sizeof(WCHAR);
        wcsncpy(awchKF, strKLID.Buffer, chMax);
        awchKF[chMax] = 0;
        if (pKbdTableMulti) {
            kbdTableMulti = ProbeAndReadStructure(pKbdTableMulti, KBDTABLE_MULTI_INTERNAL);
            if (kbdTableMulti.multi.nTables >= KBDTABLE_MULTI_MAX) {
                RIPMSG1(RIP_WARNING, "NtUserLoadKeyboardLayoutEx: pKbdTableMulti.multi.nTables too large: %x", kbdTableMulti.multi.nTables);
                MSGERROR(ERROR_INVALID_PARAMETER);
            }
            pKbdTableMulti = &kbdTableMulti;
        } else {
            RIPMSG0(RIP_WARNING, "NtUserLoadKeyboardLayoutEx: pKbdTableMulti is NULL.");
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (pKbdTableMulti && pKbdTableMulti->multi.nTables >= KBDTABLE_MULTI_MAX) {
        MSGERROR(0);
    }

    retval = xxxLoadKeyboardLayoutEx(
            pwinsta,
            hFile,
            hkl,
            offTable,
            pKbdTableMulti,
            awchKF,
            KbdInputLocale,
            Flags);

    TRACE("NtUserLoadKeyboardLayoutEx");
    ENDRECV();
}

BOOL NtUserUnloadKeyboardLayout(
    IN HKL hkl)
{
    BEGINRECV(BOOL, FALSE);

    retval = xxxUnloadKeyboardLayout(
                     _GetProcessWindowStation(NULL),
                     hkl);

    TRACE("NtUserUnloadKeyboardLayout");
    ENDRECV();
}

BOOL NtUserSetSystemMenu(
    IN HWND hwnd,
    IN HMENU hmenu)
{
    PMENU pmenu;
    TL tlpMenu;

    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    ValidateHMENU(pmenu, hmenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pmenu, &tlpMenu);

    retval =  xxxSetSystemMenu(pwnd, pmenu);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserSetSystemMenu");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserDragDetect(
    IN HWND hwnd,
    IN POINT pt)
{
    BEGINRECV_HWNDLOCK(DWORD, 0, hwnd);

    retval = xxxDragDetect(pwnd, pt);

    TRACE("NtUserDragDetect");
    ENDRECV_HWNDLOCK();
}

UINT_PTR NtUserSetSystemTimer(
    IN HWND hwnd,
    IN UINT_PTR nIDEvent,
    IN DWORD dwElapse,
    IN WNDPROC pTimerFunc)
{
    BEGINRECV_HWND(UINT_PTR, 0, hwnd);

    UNREFERENCED_PARAMETER(pTimerFunc);

    retval = _SetSystemTimer(pwnd,
            nIDEvent,
            dwElapse,
            NULL);

    TRACE("NtUserSetSystemTimer");
    ENDRECV_HWND();
}

BOOL NtUserQuerySendMessage(  // private QuerySendMessage
    OUT PMSG pmsg OPTIONAL)
{
    PSMS psms;
    BEGINRECV_SHARED(BOOL, FALSE);

    if ((psms = PtiCurrentShared()->psmsCurrent) == NULL) {
        MSGERROR(0);
    }

    retval = TRUE;
    if (ARGUMENT_PRESENT(pmsg)) {
        try {
            ProbeForWriteMessage(pmsg);
            pmsg->hwnd = HW(psms->spwnd);
            pmsg->message = psms->message;
            pmsg->wParam = psms->wParam;
            pmsg->lParam = psms->lParam;
            pmsg->time = psms->tSent;
            pmsg->pt.x = 0;
            pmsg->pt.y = 0;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserQuerySendMessage");
    ENDRECV_SHARED();
}

UINT NtUserSendInput(
    IN UINT    cInputs,
    IN CONST INPUT *pInputs,
    IN int     cbSize)
{
    LPINPUT pInput2 = NULL;
    PTHREADINFO ptiCurrent;
    TL tlInput;
    DWORD dwArgumentError = ERROR_INVALID_PARAMETER;

    BEGINRECV(UINT, 0);

    if (sizeof(INPUT) != cbSize || cInputs == 0) {
        MSGERROR(dwArgumentError);
    }

    ptiCurrent = PtiCurrent();

    /*
     * Probe arguments
     */
    try {
        ProbeForReadBuffer(pInputs, cInputs, DATAALIGN);

        pInput2 = UserAllocPoolWithQuota(cInputs * sizeof(*pInputs), TAG_SENDINPUT);
        if (pInput2 == NULL) {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }
        RtlCopyMemory(pInput2, pInputs, cInputs * sizeof(*pInputs));
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    ThreadLockPool(ptiCurrent, pInput2, &tlInput);
    retval = xxxSendInput(cInputs, pInput2);
    ThreadUnlockPool(ptiCurrent, &tlInput);
CLEANUPRECV();
    if (pInput2) {
        UserFreePool(pInput2);
    }
    TRACE("NtUserSendInput");
    ENDRECV();
}

UINT NtUserBlockInput(
    IN BOOL fBlockIt)
{
    BEGINATOMICRECV(BOOL, FALSE);
    retval = _BlockInput(fBlockIt);
    TRACE("NtUserBlockInput");
    ENDATOMICRECV();
}

BOOL NtUserImpersonateDdeClientWindow(
    IN HWND hwndClient,
    IN HWND hwndServer)
{
    PWND pwndServer;

    BEGINATOMICRECV_HWND(BOOL, FALSE, hwndClient);

    ValidateHWND(pwndServer, hwndServer);
    if (GETPTI(pwndServer) != PtiCurrent()) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        MSGERROR(0);
    }

    if (GETPWNDPPI(pwnd) == GETPWNDPPI(pwndServer)) {
        retval = TRUE;  // impersonating self is a NOOP
    } else {
        retval = _ImpersonateDdeClientWindow(pwnd, pwndServer);
    }

    TRACE("NtUserImpersonateDdeClientWindow");
    ENDATOMICRECV_HWND();
}

ULONG_PTR NtUserGetCPD(
    IN HWND hwnd,
    IN DWORD options,
    IN ULONG_PTR dwData)
{
    BEGINRECV_HWND(ULONG_PTR, 0, hwnd);

    switch (options & ~CPD_TRANSITION_TYPES) {
    case CPD_WND:
    case CPD_DIALOG:
    case CPD_WNDTOCLS:
        break;
    default:
        RIPMSG1(RIP_WARNING, "GetCPD: Invalid options %x", options);
        MSGERROR(0);
    }

    retval = GetCPD(pwnd, options, dwData);

    TRACE("NtUserGetCPD");
    ENDRECV_HWND();
}

int NtUserCopyAcceleratorTable(  // API CopyAcceleratorTableA/W
    IN HACCEL hAccelSrc,
    IN OUT LPACCEL lpAccelDst OPTIONAL,
    IN int cAccel)
{
    LPACCELTABLE pat;
    int i;
    BEGINATOMICRECV(int, 0);

    ValidateHACCEL(pat, hAccelSrc);

    if (lpAccelDst == NULL) {
        retval = pat->cAccel;
    } else {

        /*
         * Probe arguments
         */
        try {
            ProbeForWriteBuffer(lpAccelDst, cAccel, DATAALIGN);

            if (cAccel > (int)pat->cAccel)
                cAccel = pat->cAccel;

            retval = cAccel;
            for (i = 0; i < cAccel; i++) {
                RtlCopyMemory(&lpAccelDst[i], &pat->accel[i], sizeof(ACCEL));
                lpAccelDst[i].fVirt &= ~FLASTKEY;
            }
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserCopyAcceleratorTable");
    ENDATOMICRECV();
}

HWND NtUserFindWindowEx(  // API FindWindowA/W, FindWindowExA/W
    IN HWND hwndParent,
    IN HWND hwndChild,
    IN PUNICODE_STRING pstrClassName,
    IN PUNICODE_STRING pstrWindowName,
    DWORD dwType)
{
    UNICODE_STRING  strClassName;
    UNICODE_STRING  strWindowName;
    PWND            pwndParent, pwndChild;

    BEGINATOMICRECV(HWND, NULL);

    if (hwndParent != HWND_MESSAGE) {
        ValidateHWNDOPT(pwndParent, hwndParent);
    } else
        pwndParent = _GetMessageWindow();

    ValidateHWNDOPT(pwndChild,  hwndChild);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);
        strWindowName = ProbeAndReadUnicodeString(pstrWindowName);
        ProbeForReadUnicodeStringBufferOrId(strClassName);
        ProbeForReadUnicodeStringBuffer(strWindowName);
    } except (StubExceptionHandler(TRUE)) {
        MSGERRORCLEANUP(0);
    }

    /*
     * Use of both buffers is protected by try/except clauses in the code.
     */

    retval = (HWND)_FindWindowEx(
            pwndParent,
            pwndChild,
            strClassName.Buffer,
            strWindowName.Buffer,
            dwType);
    retval = PtoH((PVOID)retval);

    CLEANUPRECV();

    TRACE("NtUserFindWindowEx");
    ENDATOMICRECV();
}

BOOL NtUserGetClassInfo(  // API GetClassInfoA/W
    IN HINSTANCE hInstance OPTIONAL,
    IN PUNICODE_STRING pstrClassName,
    IN OUT LPWNDCLASSEXW lpWndClass,
    OUT LPWSTR *ppszMenuName,
    IN BOOL bAnsi)
{
    UNICODE_STRING strClassName;

    LPWSTR pszMenuName;
    WNDCLASSEXW  wc;
    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);

        /*
         * The class name may either be a string or an atom. Only
         * probe strings.
         */
        ProbeForReadUnicodeStringBufferOrId(strClassName);
        ProbeForWrite(lpWndClass, sizeof(*lpWndClass), DATAALIGN);
        ProbeForWriteUlong((PULONG)ppszMenuName);
        RtlCopyMemory(&wc, lpWndClass, sizeof(WNDCLASSEXW));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * The class name buffer is client-side.
     */
    retval = _GetClassInfoEx(
                hInstance,
                (LPTSTR)strClassName.Buffer,
                &wc,
                &pszMenuName,
                bAnsi);

    try {
        RtlCopyMemory(lpWndClass, &wc, sizeof(WNDCLASSEXW));
        *ppszMenuName = pszMenuName;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }
    TRACE("NtUserGetClassInfo");
    ENDRECV();
}

/*
 * gaFNIDtoICLS is used only in NtUserGetClassName and should be in sync with
 * the values from user.h
 * ICLS_MAX is an unused value
 */
CONST BYTE gaFNIDtoICLS[] = {
                        //  FNID-START
    ICLS_SCROLLBAR,     //  FNID_SCROLLBAR
    ICLS_ICONTITLE,     //  FNID_ICONTITLE
    ICLS_MENU,          //  FNID_MENU
    ICLS_DESKTOP,       //  FNID_DESKTOP
    ICLS_MAX,           //  FNID_DEFWINDOWPROC
    ICLS_MAX,           //  FNID_MESSAGE
    ICLS_SWITCH,        //  FNID_SWITCH
    ICLS_BUTTON,        //  FNID_BUTTON
    ICLS_COMBOBOX,      //  FNID_COMBOBOX
    ICLS_COMBOLISTBOX,  //  FNID_COMBOLISTBOX
    ICLS_DIALOG,        //  FNID_DIALOG
    ICLS_EDIT,          //  FNID_EDIT
    ICLS_LISTBOX,       //  FNID_LISTBOX
    ICLS_MDICLIENT,     //  FNID_MDICLIENT
    ICLS_STATIC,        //  FNID_STATIC
    ICLS_IME,           //  FNID_IME
    ICLS_MAX,           //  FNID_HKINLPCWPEXSTRUCT
    ICLS_MAX,           //  FNID_HKINLPCWPRETEXSTRUCT
    ICLS_MAX,           //  FNID_DEFFRAMEPROC
    ICLS_MAX,           //  FNID_DEFMDICHILDPROC
    ICLS_MAX,           //  FNID_MB_DLGPROC
    ICLS_MAX,           //  FNID_MDIACTIVATEDLGPROC
    ICLS_MAX,           //  FNID_SENDMESSAGE
    ICLS_MAX,           //  FNID_SENDMESSAGEFF
    ICLS_MAX,           //  FNID_SENDMESSAGEEX
    ICLS_MAX,           //  FNID_CALLWINDOWPROC
    ICLS_MAX,           //  FNID_SENDMESSAGEBSM
    ICLS_TOOLTIP,       //  FNID_TOOLTIP
    ICLS_GHOST,         //  FNID_GHOST
    ICLS_MAX,           //  FNID_SENDNOTIFYMESSAGE
    ICLS_MAX            //  FNID_SENDMESSAGECALLBACK
};                      //  FNID_END

int NtUserGetClassName(  // API GetClassNameA/W
    IN HWND hwnd,
    IN BOOL bReal,
    IN OUT PUNICODE_STRING pstrClassName)
{
    UNICODE_STRING strClassName;
    ATOM atom;

    BEGINRECV_HWND_SHARED(DWORD, 0, hwnd);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);
#if defined(_X86_)
        ProbeForWrite(strClassName.Buffer, strClassName.MaximumLength,
            sizeof(BYTE));
#else
        ProbeForWrite(strClassName.Buffer, strClassName.MaximumLength,
            sizeof(WCHAR));
#endif
        atom = pwnd->pcls->atomNVClassName;

        UserAssert(ARRAY_SIZE(gaFNIDtoICLS) == FNID_END - FNID_START + 1);

        if (bReal) {
            DWORD dwFnid;
            DWORD dwClass;
            dwFnid = GETFNID(pwnd);
            if (dwFnid) {
                dwFnid -= FNID_START;
                if (dwFnid < ARRAY_SIZE(gaFNIDtoICLS)) {
                    dwClass = gaFNIDtoICLS[dwFnid];
                    if (dwClass != ICLS_MAX) {
                        atom = gpsi->atomSysClass[dwClass];
                    }
                }
            }
        }
        retval = UserGetAtomName(
            atom,
            strClassName.Buffer,
            strClassName.MaximumLength / sizeof(WCHAR));

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetClassName");
    ENDRECV_HWND_SHARED();
}

UINT NtUserGetAtomName(
    IN ATOM atom,
    IN OUT PUNICODE_STRING pstrAtomName)
{
    UNICODE_STRING strAtomName;

    BEGINRECV_SHARED(UINT, 0);

    /*
     * Probe arguments
     */
    try {
        strAtomName = ProbeAndReadUnicodeString(pstrAtomName);
#if defined(_X86_)
        ProbeForWrite(strAtomName.Buffer, strAtomName.MaximumLength,
            sizeof(BYTE));
#else
        ProbeForWrite(strAtomName.Buffer, strAtomName.MaximumLength,
            sizeof(WCHAR));
#endif
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = UserGetAtomName(
        atom,
        strAtomName.Buffer,
        strAtomName.MaximumLength / sizeof(WCHAR));

    TRACE("NtUserGetAtomName");
    ENDRECV_SHARED();
}

int NtUserGetClipboardFormatName(  // API GetclipboardFormatNameA/W
    IN UINT format,
    OUT LPWSTR lpszFormatName,
    IN UINT chMax)
{
    BEGINRECV_NOCRIT(int, 0);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(lpszFormatName, chMax, CHARALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if ((ATOM)format < MAXINTATOM) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    } else {
        /*
         * UserGetAtomName (actually RtlQueryAtomInAtomTable) protects access
         * within a try block, and sets last error appropriately.
         */
        retval = UserGetAtomName((ATOM)format, lpszFormatName, chMax);
    }

    TRACE("NtUserGetClipboardFormatName");
    ENDRECV_NOCRIT();
}

int NtUserGetKeyNameText(
    IN LONG lParam,
    OUT LPWSTR lpszKeyName,
    IN UINT chMax)
{
    BEGINRECV_SHARED(int, 0);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(lpszKeyName, chMax, CHARALIGN);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Note -- lpszKeyName is a client-side address. GetKeyNameText
     * protects uses with try blocks, and sets last error accordingly.
     */

    retval = _GetKeyNameText(
                lParam,
                lpszKeyName,
                chMax);

    TRACE("NtUserGetKeyNameText");
    ENDRECV_SHARED();
}


BOOL NtUserGetKeyboardLayoutName(
    IN OUT PUNICODE_STRING pstrKLID)
{
    PTHREADINFO ptiCurrent;
    PKL pklActive;
    UNICODE_STRING strKLID;

    BEGINRECV_SHARED(BOOL, FALSE);

    ptiCurrent = PtiCurrentShared();
    pklActive = ptiCurrent->spklActive;

    if (pklActive == NULL) {
        MSGERROR(0);
    }
    /*
     * Probe arguments
     */
    try {
        strKLID = ProbeAndReadUnicodeString(pstrKLID);
        ProbeForWrite(strKLID.Buffer, strKLID.MaximumLength, CHARALIGN);

        if (IS_IME_KBDLAYOUT(pklActive->hkl)) {
            /*
             * IME KL may have different KL name for the same layout file.
             * Their KL name are really equivalent to HKL.
             */
            RtlIntegerToUnicodeString(DOWNCAST(ULONG, pklActive->hkl), 0x10, &strKLID);
        } else {
    #if (KL_NAMELENGTH != 8 + 1)
        #error unexpected KL_NAMELENGTH
    #endif
            if (strKLID.MaximumLength < KL_NAMELENGTH * sizeof(WCHAR) ||
                    !NT_SUCCESS(RtlIntegerToUnicode(pklActive->dwKLID, 0x10, -(KL_NAMELENGTH - 1), strKLID.Buffer))) {
                MSGERROR(ERROR_INVALID_PARAMETER);
            }
            strKLID.Length = (KL_NAMELENGTH - 1) * sizeof(WCHAR);
            /*
             * Make it NULL terminated.
             */
            strKLID.Buffer[KL_NAMELENGTH - 1] = L'\0';
        }

        retval = TRUE;

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserGetKeyboardLayoutName");
    ENDRECV_SHARED();
}

UINT NtUserGetKeyboardLayoutList(
    IN UINT nItems,
    OUT HKL *lpBuff)
{
    PWINDOWSTATION pwinsta;

    BEGINRECV_SHARED(UINT, 0);

    /*
     * Probe arguments
     */
    try {
        if (!lpBuff) {
            nItems = 0;
        }
        ProbeForWriteBuffer(lpBuff, nItems, DATAALIGN);
        pwinsta = _GetProcessWindowStation(NULL);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * Access to the client-side buffer lpBuff is protected by try/except
     * inside _GetKeyboardLayoutList()
     */
    retval = (DWORD)_GetKeyboardLayoutList(pwinsta, nItems, lpBuff);
    TRACE("NtUserGetKeyboardLayoutList");
    ENDRECV_SHARED();
}

UINT NtUserMapVirtualKeyEx(
    IN UINT uCode,
    IN UINT uMapType,
    IN ULONG_PTR dwHKLorPKL,
    IN BOOL bHKL)
{
    PKL pkl;

    BEGINRECV_SHARED(UINT, 0);

    /*
     * See if we need to convert an HKL to a PKL. MapVirtualKey passes a PKL and
     * MapVirtualKeyEx passes an HKL. The conversion must be done in the kernel.
     */
    if (bHKL) {
        pkl = HKLtoPKL(PtiCurrentShared(), (HKL)dwHKLorPKL);
    } else {
        pkl = PtiCurrentShared()->spklActive;
    }

    if (pkl == NULL) {
        retval = 0;
    } else {
        retval = InternalMapVirtualKeyEx(uCode, uMapType, pkl->spkf->pKbdTbl);
    }

    TRACE("NtUserMapVirtualKeyEx");
    ENDRECV_SHARED();
}

ATOM NtUserRegisterClassExWOW(
    IN WNDCLASSEX *lpWndClass,
    IN PUNICODE_STRING pstrClassName,
    IN PUNICODE_STRING pstrClassNameVer,
    IN PCLSMENUNAME pcmn,
    IN WORD fnid,
    IN DWORD dwFlags,
    IN LPDWORD pdwWOWstuff OPTIONAL)
{
    UNICODE_STRING strClassName;
    UNICODE_STRING strClassNameVer;
    UNICODE_STRING strMenuName;
    WNDCLASSVEREX WndClass;
    WC WowCls;
    CLSMENUNAME cmn;

    BEGINRECV(ATOM, 0);

    TESTFLAGS(dwFlags, CSF_VALID);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);
        strClassNameVer = ProbeAndReadUnicodeString(pstrClassNameVer);
        cmn = ProbeAndReadStructure(pcmn, CLSMENUNAME);
        strMenuName = ProbeAndReadUnicodeString(cmn.pusMenuName);
        *((LPWNDCLASSEX)(&WndClass)) = ProbeAndReadStructure(lpWndClass, WNDCLASSEX);
        ProbeForReadUnicodeStringBufferOrId(strClassName);
        ProbeForReadUnicodeStringBufferOrId(strClassNameVer);
        ProbeForReadUnicodeStringBufferOrId(strMenuName);
        if (ARGUMENT_PRESENT(pdwWOWstuff)) {
            ProbeForRead(pdwWOWstuff, sizeof(WC), sizeof(BYTE));
            RtlCopyMemory(&WowCls, pdwWOWstuff, sizeof(WC));
            pdwWOWstuff = (PDWORD)&WowCls;
        }
        WndClass.lpszClassName = strClassName.Buffer;
        WndClass.lpszClassNameVer = strClassNameVer.Buffer;
        WndClass.lpszMenuName = strMenuName.Buffer;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * ClassName and MenuName in WndClass are client-side pointers.
     */

    retval = xxxRegisterClassEx(
            &WndClass,
            &cmn,
            fnid,
            dwFlags,
            pdwWOWstuff);

    TRACE("NtUserRegisterClassExWOW");
    ENDRECV();
}

UINT NtUserRegisterWindowMessage(
    IN PUNICODE_STRING pstrMessage)
{
    UNICODE_STRING strMessage;

    BEGINRECV_NOCRIT(UINT, 0);

    /*
     * Probe arguments
     */
    try {
        strMessage = ProbeAndReadUnicodeString(pstrMessage);
        ProbeForReadUnicodeStringBuffer(strMessage);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * The buffer is in client-side memory.
     * Rtl atom routines protect accesses to strings with their
     * own try/except blocks, UserAddAtom sets last error accordingly.
     */
    retval = UserAddAtom(
            strMessage.Buffer, FALSE);

    TRACE("NtUserRegisterWindowMessage");
    ENDRECV_NOCRIT();
}

HANDLE NtUserRemoveProp(
    IN HWND hwnd,
    IN DWORD dwProp)
{
    BEGINRECV_HWND(HANDLE, NULL, hwnd);

    retval = InternalRemoveProp(pwnd, (LPWSTR)LOWORD(dwProp), FALSE);

    TRACE("NtUserRemoveProp");
    ENDRECV_HWND();
}

BOOL NtUserSetProp(
    IN HWND hwnd,
    IN DWORD dwProp,
    IN HANDLE hData)
{
    BEGINRECV_HWND(DWORD, 0, hwnd);

    /*
     * Check if someone is setting the window property from outside CSRSS.
     */
    UserAssert(pwnd);
    if ((GETPTI(pwnd)->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD)) && (PtiCurrent()->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD)) == 0) {
        RIPMSG1(RIP_WARNING, "Attempting to set property of CSRSS or System thread from outside; target pti = %p", GETPTI(pwnd));
        MSGERROR(ERROR_ACCESS_DENIED);
    }

    retval = InternalSetProp(
            pwnd,
            (LPTSTR)LOWORD(dwProp),
            hData,
            HIWORD(dwProp) ? PROPF_STRING : 0);

    TRACE("NtUserSetProp");
    ENDRECV_HWND();
}

BOOL NtUserUnregisterClass(  // API UnregisterClass
    IN PUNICODE_STRING pstrClassName,
    IN HINSTANCE hInstance,
    OUT PCLSMENUNAME pcmn)
{
    UNICODE_STRING strClassName;
    CLSMENUNAME cmn;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        strClassName = ProbeAndReadUnicodeString(pstrClassName);
        ProbeForReadUnicodeStringBufferOrId(strClassName);
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    /*
     * The buffer is in client-side memory.
     */

    retval = _UnregisterClass(
                strClassName.Buffer,
                hInstance,
                &cmn);

    try {
        ProbeAndWriteStructure(pcmn, cmn, CLSMENUNAME);
    } except (StubExceptionHandler(FALSE)) {
        // no SetLastError, since pcmn is a USER address, not the application's
    }

    TRACE("NtUserUnregisterClass");
    ENDRECV();
}

SHORT NtUserVkKeyScanEx(
    IN WCHAR cChar,
    IN ULONG_PTR dwHKLorPKL,
    IN BOOL bHKL)
{
    PKL pkl;

    BEGINRECV_SHARED(SHORT, -1);

    /*
     * See if we need to convert an HKL to a PKL. VkKeyScan passes a PKL and
     * VkKeyScanEx passes an HKL. The conversion must be done on the server side.
     */
    if (bHKL) {
        pkl = HKLtoPKL(PtiCurrentShared(), (HKL)dwHKLorPKL);
    } else {
        pkl = PtiCurrentShared()->spklActive;
    }

    if (pkl == NULL) {
        retval = (SHORT)-1;
    } else {
        retval = InternalVkKeyScanEx(cChar, pkl->spkf->pKbdTbl);
    }

    TRACE("NtUserVkKeyScanEx");
    ENDRECV_SHARED();
}

NTSTATUS
NtUserEnumDisplayDevices(
    IN PUNICODE_STRING pstrDeviceName,
    IN DWORD iDevNum,
    IN OUT LPDISPLAY_DEVICEW lpDisplayDevice,
    IN DWORD dwFlags)
{
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * We need to syncrhonize with session switching from local to remote or
     * remote to local while enumerating display settings. Use
     * UserSessionSwitchEnterCrit() to ensure mutual exclusion with session
     * switch code, but first leave the User critical section as
     * UserSessionSwitchEnterCrit() does not expect to be held by the caller.
     * On return from UserSessionSwitchEnterCrit() the critical section will be
     * held.
     */

    LeaveCrit();
    retval = UserSessionSwitchEnterCrit();
    if (retval != STATUS_SUCCESS) {
        goto exit_api;
    }

    /*
     * Update the list of devices. Do this only if connected to local console.
     * If the function returns FALSE (retry update), then we must
     * disable the current hdev, call back, and reanable the hdev.
     */
    if (!IsRemoteConnection()) {
        if (DrvUpdateGraphicsDeviceList(FALSE, FALSE, TRUE) == FALSE) {

            if (SafeDisableMDEV()) {

                DrvUpdateGraphicsDeviceList(TRUE, FALSE, TRUE);

                SafeEnableMDEV();

                /*
                 * Repaint the screen
                 */

                xxxUserResetDisplayDevice();

                /*
                 * xxxUserResetDisplayDevice may have released and reaquiered the user critical section.
                 * We need to make sure again that no session switch has started during that window.
                 */

                LeaveCrit();
                retval = UserSessionSwitchEnterCrit();
                if (retval != STATUS_SUCCESS) {
                    goto exit_api;
                }
            }
        }
    }


    /*
     * Address checking, etc., occurs in GRE.
     */

    retval = DrvEnumDisplayDevices(pstrDeviceName,
                                   gpDispInfo->pMonitorPrimary->hDev,
                                   iDevNum,
                                   lpDisplayDevice,
                                   dwFlags,
                                   UserMode);

    UserSessionSwitchLeaveCrit();
exit_api:
    EnterCrit();

    TRACE("NtUserEnumDisplayDevices");
    ENDRECV();
}

NTSTATUS
NtUserEnumDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN DWORD           iModeNum,
    OUT LPDEVMODEW     lpDevMode,
    IN  DWORD          dwFlags)
{
    BEGINRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    /*
     * We need to synchronize with session switching from local to remote or
     * remote to local while enumerating display settings. Use
     * UserSessionSwitchEnterCrit() to ensure mutual exclusion with session
     * switch code, but first leave the User critical section as
     * UserSessionSwitchEnterCrit() does not expect to be held by the caller.
     * On return from UserSessionSwitchEnterCrit() the critical section will be
     * held.
     *
     * Address checking, etc., occurs in GRE.
     */

    LeaveCrit();
    retval = UserSessionSwitchEnterCrit();
    if (retval != STATUS_SUCCESS) {
        goto exit_api;
    }
    retval = DrvEnumDisplaySettings(pstrDeviceName,
                                    gpDispInfo->pMonitorPrimary->hDev,
                                    iModeNum,
                                    lpDevMode,
                                    dwFlags);
    UserSessionSwitchLeaveCrit();
exit_api:
    EnterCrit();

    TRACE("NtUserEnumDisplaySettings");
    ENDRECV();
}

LONG
NtUserChangeDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN LPDEVMODEW pDevMode,
    IN HWND hwnd,
    IN DWORD dwFlags,
    IN PVOID lParam)
{
    BEGINRECV(LONG, DISP_CHANGE_FAILED);

    /*
     * Prevent restricted threads from changing
     * display settings
     */
    if (IS_CURRENT_THREAD_RESTRICTED(JOB_OBJECT_UILIMIT_DISPLAYSETTINGS)) {
        MSGERROR(0);
    }

    /*
     * Address checking, etc., occurs in GRE.
     */

    retval = xxxUserChangeDisplaySettings(pstrDeviceName,
                                          pDevMode,
                                          hwnd,
                                          NULL,     // pdesk
                                          dwFlags,
                                          lParam,
                                          UserMode);

    TRACE("NtUserChangeDisplaySettings");
    ENDRECV();
}

BOOL NtUserCallMsgFilter(  // API CallMsgFilterA/W
    IN OUT LPMSG lpMsg,
    IN int nCode)
{
    MSG msg;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteMessage(lpMsg);
        msg = *lpMsg;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _CallMsgFilter(
                &msg,
                nCode);
    try {
        *lpMsg = msg;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    TRACE("NtUserCallMsgFilter");
    ENDRECV();
}

int NtUserDrawMenuBarTemp(  // private DrawMenuBarTemp
    IN HWND hwnd,
    IN HDC hdc,
    IN LPCRECT lprc,
    IN HMENU hMenu,
    IN HFONT hFont)
{
    PMENU   pMenu;
    TL      tlpMenu;
    RECT    rc;


    BEGINRECV_HWNDLOCK(int, 0, hwnd);

    /*
     * Probe and capture arguments.
     */
    try {
        rc = ProbeAndReadRect(lprc);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    ValidateHMENU(pMenu, hMenu);

    ThreadLockAlwaysWithPti(ptiCurrent, pMenu, &tlpMenu);

    retval = xxxDrawMenuBarTemp(
            pwnd,
            hdc,
            &rc,
            pMenu,
            hFont);

    ThreadUnlock(&tlpMenu);

    TRACE("NtUserDrawMenuBarTemp");
    ENDRECV_HWNDLOCK();
}

BOOL NtUserDrawCaptionTemp(  // private DrawCaptionTempA/W
    IN HWND hwnd,
    IN HDC hdc,
    IN LPCRECT lprc,
    IN HFONT hFont,
    IN HICON hIcon,
    IN PUNICODE_STRING pstrText,
    IN UINT flags)
{
    PCURSOR         pcur;
    TL              tlpcur;
    RECT            rc;
    UNICODE_STRING  strCapture;
    PWND            pwnd;
    TL              tlpwnd;
    PTHREADINFO     ptiCurrent;
    TL tlBuffer;
    BOOL fFreeBuffer = FALSE;

    BEGINRECV(DWORD, FALSE);

    ptiCurrent = PtiCurrent();

    ValidateHWNDOPT(pwnd, hwnd);
    ValidateHCURSOROPT(pcur, hIcon);

    /*
     * Probe and capture arguments. Capturing the text is ugly,
     * but must be done because it is passed to GDI.
     */
    try {
        rc = ProbeAndReadRect(lprc);
        strCapture = ProbeAndReadUnicodeString(pstrText);
        if (strCapture.Buffer != NULL) {
            PWSTR pszCapture = strCapture.Buffer;
            ProbeForRead(strCapture.Buffer, strCapture.Length, CHARALIGN);
            strCapture.Buffer = UserAllocPoolWithQuota(strCapture.Length+sizeof(UNICODE_NULL), TAG_TEXT);
            if (strCapture.Buffer != NULL) {
                fFreeBuffer = TRUE;
                ThreadLockPool(ptiCurrent, strCapture.Buffer, &tlBuffer);
                RtlCopyMemory(strCapture.Buffer, pszCapture, strCapture.Length);
                strCapture.Buffer[strCapture.Length/sizeof(WCHAR)]=0;  // null-terminate string
                strCapture.MaximumLength = strCapture.Length+sizeof(UNICODE_NULL);
                pstrText = &strCapture;
            } else {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);
    ThreadLockWithPti(ptiCurrent, pcur, &tlpcur);

    retval = xxxDrawCaptionTemp(
            pwnd,
            hdc,
            &rc,
            hFont,
            pcur,
            strCapture.Buffer ? &strCapture : NULL,
            flags);

    ThreadUnlock(&tlpcur);
    ThreadUnlock(&tlpwnd);

    CLEANUPRECV();
    if (fFreeBuffer)
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);

    TRACE("NtUserDrawCaptionTemp");
    ENDRECV();
}

BOOL NtUserGetKeyboardState(  // API GetKeyboardState
    OUT PBYTE pb)
{
    int i;
    PQ pq;
    BEGINRECV_SHARED(SHORT, 0)

    /*
     * Probe arguments
     */
    try {
        ProbeForWrite(pb, 256, sizeof(BYTE));

        pq = PtiCurrentShared()->pq;

        for (i = 0; i < 256; i++, pb++) {
            *pb = 0;
            if (TestKeyStateDown(pq, i))
                *pb |= 0x80;

            if (TestKeyStateToggle(pq, i))
                *pb |= 0x01;
        }
        retval = TRUE;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ENDRECV_SHARED();
}

SHORT NtUserGetKeyState(
    IN int vk)
{
    PTHREADINFO ptiCurrent;
    BEGINRECV_SHARED(SHORT, 0)

    ptiCurrent = PtiCurrentShared();
    if (ptiCurrent->pq->QF_flags & QF_UPDATEKEYSTATE) {

        /*
         * We are going to change the system state, so we
         * must have an exclusive lock
         */
        ChangeAcquireResourceType();

        /*
         * If this thread needs a key state event, give one to it. There are
         * cases where any app may be looping looking at GetKeyState(), plus
         * calling PeekMessage(). Key state events don't get created unless
         * new hardware input comes along. If the app isn't receiving hardware
         * input, it won't get the new key state. So ResyncKeyState() will
         * ensure that if the app is looping on GetKeyState(), it'll get the
         * right key state.
         */
        if (ptiCurrent->pq->QF_flags & QF_UPDATEKEYSTATE) {
            PostUpdateKeyStateEvent(ptiCurrent->pq);
        }
    }
    retval = _GetKeyState(vk);

    /*
     * Update the client side key state cache.
     */
    ptiCurrent->pClientInfo->dwKeyCache = gpsi->dwKeyCache;
    RtlCopyMemory(ptiCurrent->pClientInfo->afKeyState,
                  ptiCurrent->pq->afKeyState,
                  CBKEYCACHE);

    ENDRECV_SHARED();
}

/**************************************************************************\
* NtUserQueryWindow
*
* 03-18-95 JimA         Created.
\**************************************************************************/

HANDLE NtUserQueryWindow(
    IN HWND hwnd,
    IN WINDOWINFOCLASS WindowInfo)
{
    PTHREADINFO ptiWnd;

    BEGINRECV_HWND_SHARED(HANDLE, NULL, hwnd);

    ptiWnd = GETPTI(pwnd);

    switch (WindowInfo) {
    case WindowProcess:

        /*
         * Special case console windows
         */
        if (ptiWnd->TIF_flags & TIF_CSRSSTHREAD &&
                pwnd->pcls->atomClassName == gatomConsoleClass) {
            retval = (HANDLE)LongToHandle( _GetWindowLong(pwnd, 0) );
        } else {
            retval = PsGetThreadProcessId(ptiWnd->pEThread);
        }
        break;
    case WindowThread:

        /*
         * Special case console windows
         */
        if (ptiWnd->TIF_flags & TIF_CSRSSTHREAD &&
                pwnd->pcls->atomClassName == gatomConsoleClass) {
            retval = (HANDLE)LongToHandle( _GetWindowLong(pwnd, 4) );
        } else {
            retval = (HANDLE)GETPTIID(ptiWnd);
        }
        break;
    case WindowActiveWindow:
        retval = (HANDLE)HW(ptiWnd->pq->spwndActive);
        break;
    case WindowFocusWindow:
        retval = (HANDLE)HW(ptiWnd->pq->spwndFocus);
        break;
    case WindowIsHung:
        /*
         * If the window is a ghost window, report that the window is hung.
         */
        if ((GETFNID(pwnd) == FNID_GHOST)) {
            retval = (HANDLE)IntToPtr(TRUE);
        } else {
            retval = (HANDLE)IntToPtr( FHungApp(ptiWnd, CMSHUNGAPPTIMEOUT) );
        }
        break;
    case WindowIsForegroundThread:
        retval = (HANDLE)IntToPtr( (ptiWnd->pq == gpqForeground) );
        break;
    case WindowDefaultImeWindow:
        retval = (HANDLE)HW(ptiWnd->spwndDefaultIme);
        break;
    case WindowDefaultInputContext:
        retval = (HANDLE)PtoH(ptiWnd->spDefaultImc);
        break;
    case WindowActiveDefaultImeWindow:
        /*
         * Only return a window if there is a foreground queue and the
         * caller has access to the current desktop.
         */
        retval = NULL;
        if (gpqForeground && gpqForeground->spwndActive &&
                PtiCurrentShared()->rpdesk == gpqForeground->spwndActive->head.rpdesk) {
            PWND pwndFG = gpqForeground->spwndActive;

            if (pwndFG && pwndFG->head.pti) {
                retval = (HANDLE)PtoHq(pwndFG->head.pti->spwndDefaultIme);
            }
        }
        break;
    default:
        retval = (HANDLE)NULL;
        break;
    }

    ENDRECV_HWND_SHARED();
}

BOOL NtUserSBGetParms(  // API GetScrollInfo, SBM_GETSCROLLINFO
    IN HWND hwnd,
    IN int code,
    IN PSBDATA pw,
    IN OUT LPSCROLLINFO lpsi)
{
    SBDATA sbd;
    SCROLLINFO si;
    BEGINRECV_HWND_SHARED(BOOL, FALSE, hwnd);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteScrollInfo(lpsi);

        /*
         * Probe the 4 DWORDS (MIN, MAX, PAGE, POS)
         */
        ProbeForRead(pw, sizeof(SBDATA), sizeof(DWORD));
        RtlCopyMemory(&sbd, pw, sizeof(sbd));
        RtlCopyMemory(&si, lpsi, sizeof(SCROLLINFO));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _SBGetParms(pwnd, code, &sbd, &si);
    try {
        RtlCopyMemory(lpsi, &si, sizeof(SCROLLINFO));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ENDRECV_HWND_SHARED();
}

BOOL NtUserBitBltSysBmp(
    IN HDC hdc,
    IN int xDest,
    IN int yDest,
    IN int cxDest,
    IN int cyDest,
    IN int xSrc,
    IN int ySrc,
    IN DWORD dwRop)
{
    BEGINRECV(BOOL, FALSE);

    /*
     * Note: This interface requires exclusive ownership of the User crit
     * sect in order to serialize use of HDCBITS. Only one thread at a time
     * may use a DC.
     */

    retval = GreBitBlt(hdc,
                       xDest,
                       yDest,
                       cxDest,
                       cyDest,
                       HDCBITS(),
                       xSrc,
                       ySrc,
                       dwRop,
                       0);

    ENDRECV();
}

HPALETTE NtUserSelectPalette(
    IN HDC hdc,
    IN HPALETTE hpalette,
    IN BOOL fForceBackground)
{
    BEGINRECV(HPALETTE, NULL)

    retval = _SelectPalette(hdc, hpalette, fForceBackground);

    ENDRECV();
}

/*
 * Message thunks
 */

LRESULT NtUserMessageCall(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam,
    IN ULONG_PTR xParam,
    IN DWORD xpfnProc,
    IN BOOL bAnsi)
{
    BEGINRECV_HWNDLOCKFF(LRESULT, 0, hwnd, xpfnProc);

    if ((msg & ~MSGFLAG_MASK) >= WM_USER) {
        retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam);
    } else {
        retval = gapfnMessageCall[MessageTable[(msg & ~MSGFLAG_MASK)].iFunction](
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    }

    TRACE("NtUserMessageCall");
    ENDRECV_HWNDLOCKFF();
}

MESSAGECALL(DWORD)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnDWORD");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnDWORD");
    ENDRECV_MESSAGECALL();

}

MESSAGECALL(NCDESTROY)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnNCDESTROY");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnNCDESTROY");
    ENDRECV_MESSAGECALL();

}

MESSAGECALL(OPTOUTLPDWORDOPTOUTLPDWORD)
{
    DWORD dwwParam, dwlParam;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOPTOUTLPDWORDOPTOUTLPDWORD");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            (WPARAM)&dwwParam,
            (LPARAM)&dwlParam,
            xParam);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(wParam)) {
            ProbeAndWriteUlong((PULONG)wParam, dwwParam);
        }
        if (ARGUMENT_PRESENT(lParam)) {
            ProbeAndWriteUlong((PULONG)lParam, dwlParam);
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);  // should messages with bad wParam/lParam SetLastError?
    }

    TRACE("fnOPTOUTLPDWORDOPTOUTLPDWORD");
    ENDRECV_MESSAGECALL();

}

MESSAGECALL(INOUTNEXTMENU)
{
    MDINEXTMENU mnm;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTNEXTMENU");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteMDINextMenu((PMDINEXTMENU)lParam);
        mnm = *(PMDINEXTMENU)lParam;

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&mnm,
                xParam);

    try {
        *(PMDINEXTMENU)lParam = mnm;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTNEXTMENU");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(DWORDOPTINLPMSG)
{
    MSG msgstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnDWORDOPTINLPMSG");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(lParam)) {
            msgstruct = ProbeAndReadMessage((LPMSG)lParam);
            lParam = (LPARAM)&msgstruct;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnDWORDOPTINLPMSG");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(COPYGLOBALDATA)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnCOPYGLOBALDATA");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForRead((PVOID)lParam, wParam, sizeof(BYTE));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Data pointed to by lParam must be captured
     * in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnCOPYGLOBALDATA");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(COPYDATA)
{
    COPYDATASTRUCT cds;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnCOPYDATA");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        if (ARGUMENT_PRESENT(lParam)) {
            cds = ProbeAndReadCopyDataStruct((PCOPYDATASTRUCT)lParam);
            if (cds.lpData)
                ProbeForRead(cds.lpData, cds.cbData, sizeof(BYTE));
            lParam = (LPARAM)&cds;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Data pointed to by cds.lpData must be captured
     * in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnCOPYDATA");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(SENTDDEMSG)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnSENTDDEMSG");

    UNREFERENCED_PARAMETER(bAnsi);

    if (xpfnProc == FNID_CALLWINDOWPROC) {
        retval = CALLPROC(xpfnProc)(pwnd,
                msg | MSGFLAG_DDE_SPECIAL_SEND,
                wParam, lParam, xParam);
    } else if ((ptiCurrent->TIF_flags & TIF_16BIT) &&
               (ptiCurrent->ptdb) &&
               (ptiCurrent->ptdb->hTaskWow)) {
        /*
         * Note that this function may modify msg by ORing in a bit in the
         * high word. This bit is ignored when thunking messages.
         * This allows the DdeTrackSendMessage() hook to be skipped - which
         * would cause an error - and instead allows this thunk to carry
         * the message all the way across.
         */
        retval = xxxDDETrackPostHook(&msg, pwnd, wParam, &lParam, TRUE);
        switch (retval) {
        case DO_POST:
            /*
             * Or in the MSGFLAG_DDE_SPECIAL_SEND so that
             * xxxSendMessageTimeout() will not pass this on to
             * xxxDdeTrackSendMsg() which would think it was evil.
             *
             * Since the SendMessage() thunks ignore the reserved bits
             * it will still get maped to the fnSENTDDEMSG callback thunk.
             */
            retval = CALLPROC(xpfnProc)(pwnd,
                    msg | MSGFLAG_DDE_SPECIAL_SEND,
                    wParam, lParam, xParam);
            break;

        case FAKE_POST:
        case FAIL_POST:
            retval = 0;
        }
    } else {
        MSGERROR(0);
    }

    TRACE("fnSENTDDEMSG");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(DDEINIT)
{
    PWND pwndFrom;
    TL tlpwndFrom;
    PDDEIMP pddei;
    PSECURITY_QUALITY_OF_SERVICE pqos;
    NTSTATUS Status;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnDDEINIT");

    UNREFERENCED_PARAMETER(bAnsi);

    ValidateHWND(pwndFrom, (HWND)wParam);
    ThreadLockAlwaysWithPti(ptiCurrent, pwndFrom, &tlpwndFrom);

    /*
     * Create temporary DDEIMP property for client window - this stays around
     * only during the initiate phase.
     */
    if ((pddei = (PDDEIMP)_GetProp(pwndFrom, PROP_DDEIMP, TRUE))
            == NULL) {
        pddei = (PDDEIMP)UserAllocPoolWithQuota(sizeof(DDEIMP), TAG_DDEd);
        if (pddei == NULL) {
            RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "fnDDEINIT: LocalAlloc failed.");
            MSGERRORCLEANUP(0);
        }
        pqos = (PSECURITY_QUALITY_OF_SERVICE)_GetProp(pwndFrom, PROP_QOS, TRUE);
        if (pqos == NULL) {
            pqos = &gqosDefault;
        }
        pddei->qos = *pqos;
        Status = SeCreateClientSecurity(PsGetCurrentThread(),
                pqos, FALSE, &pddei->ClientContext);
        if (!NT_SUCCESS(Status)) {
            RIPMSG0(RIP_WARNING, "SeCreateClientContext failed.");
            UserFreePool(pddei);
            MSGERRORCLEANUP(0);
        }
        pddei->cRefInit = 1;
        pddei->cRefConv = 0;
        InternalSetProp(pwndFrom, PROP_DDEIMP, pddei, PROPF_INTERNAL);
    } else {
        pddei->cRefInit++;      // cover broadcast case!
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    /*
     * Reaquire pddei incase pwndFrom was destroyed.
     */
    pddei = (PDDEIMP)_GetProp(pwndFrom, PROP_DDEIMP, TRUE);
    if (pddei != NULL) {
        /*
         * Decrement reference count from DDEImpersonate property and remove property.
         */
        pddei->cRefInit--;
        if (pddei->cRefInit == 0) {
            InternalRemoveProp(pwndFrom, PROP_DDEIMP, TRUE);
            if (pddei->cRefConv == 0) {
                SeDeleteClientSecurity(&pddei->ClientContext);
                UserFreePool(pddei);
            }
        }
    }

    CLEANUPRECV();
    ThreadUnlock(&tlpwndFrom);

    TRACE("fnDDEINIT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INPAINTCLIPBRD)
{
    PAINTSTRUCT ps;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINPAINTCLIPBRD");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ps = ProbeAndReadPaintStruct((PPAINTSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&ps,
            xParam);

    TRACE("fnINPAINTCLIPBRD");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INSIZECLIPBRD)
{
    RECT rc;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINSIZECLIPBRD");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        rc = ProbeAndReadRect((PRECT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&rc,
            xParam);

    TRACE("fnINSIZECLIPBRD");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTDRAG)
{
    DROPSTRUCT ds;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTDRAG");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteDropStruct((PDROPSTRUCT)lParam);
        ds = *(PDROPSTRUCT)lParam;

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&ds,
                xParam);

    try {
        *(PDROPSTRUCT)lParam = ds;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTDRAG");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(GETDBCSTEXTLENGTHS)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnGETDBCSTEXTLENGTHS");

    UNREFERENCED_PARAMETER(lParam);

    /*
     * This is used by L/CB_GETTEXTLEN which should return -1 (L/CB_ERR)
     *  on error. If any error code path is introduced here, make sure we return the
     *  proper value.This is also used by WM_GETTEXTLEN.
     */

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            bAnsi,
            xParam);

    TRACE("fnGETDBCSTEXTLENGTHS");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPCREATESTRUCT)
{
    CREATESTRUCTEX csex;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPCREATESTRUCT");

    if (ARGUMENT_PRESENT(lParam)) {
        try {
            csex.cs = ProbeAndReadCreateStruct((LPCREATESTRUCTW)lParam);
            if (bAnsi) {
                ProbeForRead(csex.cs.lpszName, sizeof(CHAR), sizeof(CHAR));
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&csex.strName,
                        (LPSTR)csex.cs.lpszName, (UINT)-1);
                if (IS_PTR(csex.cs.lpszClass)) {
                    ProbeForRead(csex.cs.lpszClass, sizeof(CHAR), sizeof(CHAR));
                    RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&csex.strClass,
                            (LPSTR)csex.cs.lpszClass, (UINT)-1);
                }
            } else {
                ProbeForRead(csex.cs.lpszName, sizeof(WCHAR), CHARALIGN);
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&csex.strName,
                        csex.cs.lpszName, (UINT)-1);
                if (IS_PTR(csex.cs.lpszClass)) {
                    ProbeForRead(csex.cs.lpszClass, sizeof(WCHAR), CHARALIGN);
                    RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&csex.strClass,
                            csex.cs.lpszClass, (UINT)-1);
                }
            }
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    /*
     * Per Win95, do not allow NULL lpcreatestructs for WM_NCCREATE [51986]
     * Allowed for WM_CREATE in Win95 for ObjectVision
     */
    else if (msg == WM_NCCREATE) {
        MSGERROR(0) ;
    }

    /*
     * !!! Strings pointed to by cs.cs must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam ? (LPARAM)&csex : 0,
            xParam);

    TRACE("fnINLPCREATESTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPMDICREATESTRUCT)
{
    MDICREATESTRUCTEX mdics;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPMDICREATESTRUCT");

    /*
     * Probe arguments
     */
    try {
        mdics.mdics = ProbeAndReadMDICreateStruct((LPMDICREATESTRUCTW)lParam);

        if (bAnsi) {
            ProbeForRead(mdics.mdics.szTitle, sizeof(CHAR), sizeof(CHAR));
            RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&mdics.strTitle,
                    (LPSTR)mdics.mdics.szTitle, (UINT)-1);
            if (IS_PTR(mdics.mdics.szClass)) {
                ProbeForRead(mdics.mdics.szClass, sizeof(CHAR), sizeof(CHAR));
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&mdics.strClass,
                        (LPSTR)mdics.mdics.szClass, (UINT)-1);
            } else {
                /*
                 * mdics.mdics.szClass may be Atom.
                 */
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&mdics.strClass,
                                       NULL, 0);
            }
        } else {
            ProbeForRead(mdics.mdics.szTitle, sizeof(WCHAR), CHARALIGN);
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&mdics.strTitle,
                    mdics.mdics.szTitle, (UINT)-1);
            if (IS_PTR(mdics.mdics.szClass)) {
                ProbeForRead(mdics.mdics.szClass, sizeof(WCHAR), CHARALIGN);
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&mdics.strClass,
                        mdics.mdics.szClass, (UINT)-1);
            } else {
                /*
                 * mdics.mdics.szClass may be Atom.
                 */
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&mdics.strClass,
                                       NULL, 0);
            }
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Strings pointed to by mdics must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&mdics,
            xParam);

    TRACE("fnINLPMDICREATESTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPSCROLLINFO)
{
    SCROLLINFO scrollinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTLPSCROLLINFO");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteScrollInfo((LPSCROLLINFO)lParam);
        scrollinfo = *(LPSCROLLINFO)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&scrollinfo,
                xParam);

    try {
        *(LPSCROLLINFO)lParam = scrollinfo;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPSCROLLINFO");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPPOINT5)
{
    POINT5 pt5;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTLPPOINT5");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWritePoint5((LPPOINT5)lParam);
        pt5 = *(LPPOINT5)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&pt5,
                xParam);

    try {
        *(LPPOINT5)lParam = pt5;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPPOINT5");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINSTRING");

    /*
     * Don't allow any app to send a LB_DIR or CB_DIR with the postmsgs bit
     * set (ObjectVision does this). This is because there is actually a legal
     * case that we need to thunk of user posting a LB_DIR or CB_DIR
     * (DlgDirListHelper()). In the post case, we thunk the lParam (pointer
     * to a string) differently, and we track that post case with the
     * DDL_POSTMSGS bit. If an app sends a message with this bit, then our
     * thunking gets confused, so clear it here. Let's hope that no app
     * depends on this bit set when either of these messages are sent.
     *
     * These messages should return -1 on failure
     */
    switch (msg) {
    case LB_DIR:
    case CB_DIR:
        wParam &= ~DDL_POSTMSGS;
        /* Fall through */

    case LB_ADDFILE:
#if (LB_ERR != CB_ERR)
#error LB_ERR/CB_ERR conflict
#endif
        errret = LB_ERR;
        break;
    }

    /*
     * Probe arguments
     */
    try {
        if (bAnsi) {
            ProbeForRead((LPSTR)lParam, sizeof(CHAR), sizeof(CHAR));
            RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&str,
                    (LPSTR)lParam, (UINT)-1);
        } else {
            ProbeForRead((LPWSTR)lParam, sizeof(WCHAR), CHARALIGN);
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&str,
                    (LPWSTR)lParam, (UINT)-1);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! str.Buffer must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    TRACE("fnINSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INSTRINGNULL)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINSTRINGNULL");

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lParam)) {
        try {
            if (bAnsi) {
                ProbeForRead((LPSTR)lParam, sizeof(CHAR), sizeof(CHAR));
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&str,
                        (LPSTR)lParam, (UINT)-1);
            } else {
                ProbeForRead((LPWSTR)lParam, sizeof(WCHAR), CHARALIGN);
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&str,
                        (LPWSTR)lParam, (UINT)-1);
            }
            lParam = (LPARAM)&str;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    /*
     * !!! str.Buffer must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnINSTRINGNULL");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INDEVICECHANGE)
{
    BOOL fPtr    = (BOOL)((wParam & 0x8000) == 0x8000);
    DWORD cbSize;
    PBYTE bfr = NULL;
    TL tlBuffer;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINDEVICECHANGE");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    if (fPtr && lParam) {
        struct _DEV_BROADCAST_HEADER *pHdr;
        PDEV_BROADCAST_DEVICEINTERFACE_W pInterfaceW;
        PDEV_BROADCAST_PORT_W pPortW;
        PDEV_BROADCAST_HANDLE pHandleW;
        try {
            pHdr = (struct _DEV_BROADCAST_HEADER *)lParam;
            cbSize = ProbeAndReadUlong(&(pHdr->dbcd_size));
            if (cbSize < sizeof(*pHdr)) {
                MSGERROR(ERROR_INVALID_PARAMETER);
            }
            ProbeForRead(pHdr, cbSize, sizeof(BYTE));

            bfr = UserAllocPoolWithQuota(cbSize+2, TAG_DEVICECHANGE); // add space for trailing NULL for test
            if (bfr == NULL) {
                RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "fnINDEVICECHANGE: LocalAlloc failed.");
                MSGERRORCLEANUP(0);
            }

            ThreadLockPool(ptiCurrent, bfr, &tlBuffer);

            RtlCopyMemory(bfr,  (PBYTE)lParam,
                        cbSize);
            ((PWSTR)bfr)[cbSize/sizeof(WCHAR)] = 0;  // trailing null to halt wcslen scan
            lParam = (LPARAM)bfr;
            pHdr = (struct _DEV_BROADCAST_HEADER *)lParam;
            if (pHdr->dbcd_size != cbSize) {
                MSGERRORCLEANUP(0);
            }
            switch(pHdr->dbcd_devicetype) {
            case DBT_DEVTYP_PORT:
                pPortW = (PDEV_BROADCAST_PORT_W)lParam;
                if ((1+wcslen(pPortW->dbcp_name))*sizeof(WCHAR) + FIELD_OFFSET(DEV_BROADCAST_PORT_W, dbcp_name) > cbSize) {
                    MSGERRORCLEANUP(0);
                }
                break;
            case DBT_DEVTYP_DEVICEINTERFACE:
                pInterfaceW = (PDEV_BROADCAST_DEVICEINTERFACE_W)lParam;
                if ((1+wcslen(pInterfaceW->dbcc_name))*sizeof(WCHAR) + FIELD_OFFSET(DEV_BROADCAST_DEVICEINTERFACE_W, dbcc_name) > cbSize) {
                    MSGERRORCLEANUP(0);
                }
                break;
            case DBT_DEVTYP_HANDLE:
                pHandleW = (PDEV_BROADCAST_HANDLE)lParam;
            /*
             * Check if there is any text.
             */

                if (wParam != DBT_CUSTOMEVENT) {
                    if (FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid) > cbSize) {
                        MSGERRORCLEANUP(0);
                    }
                    break;
                }
                if (pHandleW->dbch_nameoffset < 0) {
                    if (FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data) > cbSize) {
                        MSGERRORCLEANUP(0);
                    }
                    break;
                }
                if (pHandleW->dbch_nameoffset & (CHARALIGN - 1)) {
                    ExRaiseDatatypeMisalignment();                                                            \
                }
                if ((DWORD)(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data) + pHandleW->dbch_nameoffset) > cbSize) {
                    MSGERRORCLEANUP(0);
                }
                if (FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data) + pHandleW->dbch_nameoffset +
                    (1+wcslen((LPWSTR)(pHandleW->dbch_data+pHandleW->dbch_nameoffset)))*sizeof(WCHAR) >
                    cbSize) {
                    MSGERRORCLEANUP(0);
                }
                break;

            }

        } except (StubExceptionHandler(FALSE)) {
            MSGERRORCLEANUP(0);
        }

    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    CLEANUPRECV();
    if (bfr)
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);

    TRACE("fnINDEVICECHANGE");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTNCCALCSIZE)
{
    NCCALCSIZE_PARAMS params;
    WINDOWPOS pos;
    PWINDOWPOS pposClient;
    RECT rc;
    LPARAM lParamLocal;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTNCCALCSIZE");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        if (wParam != 0) {
            ProbeForWriteNCCalcSize((LPNCCALCSIZE_PARAMS)lParam);
            params = *(LPNCCALCSIZE_PARAMS)lParam;
            ProbeForWriteWindowPos(params.lppos);
            pposClient = params.lppos;
            pos = *params.lppos;
            params.lppos = &pos;
            lParamLocal = (LPARAM)&params;
        } else {
            ProbeForWriteRect((LPRECT)lParam);
            rc = *(LPRECT)lParam;
            lParamLocal = (LPARAM)&rc;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lParamLocal,
                xParam);

    try {
        if (wParam != 0) {
            *(LPNCCALCSIZE_PARAMS)lParam = params;
            ((LPNCCALCSIZE_PARAMS)lParam)->lppos = pposClient;
            *pposClient = pos;
        } else {
            *(LPRECT)lParam = rc;
        }
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTNCCALCSIZE");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTSTYLECHANGE)
{
    STYLESTRUCT ss;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTSTYLECHANGE");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteStyleStruct((LPSTYLESTRUCT)lParam);
        ss = *(LPSTYLESTRUCT)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&ss,
                xParam);

    try {
        *(LPSTYLESTRUCT)lParam = ss;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTSTYLECHANGE");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPRECT)
{
    RECT rc;

    BEGINRECV_MESSAGECALL((msg == LB_GETITEMRECT ? LB_ERR : 0));
    TRACETHUNK("fnINOUTLPRECT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteRect((PRECT)lParam);
        rc = *(PRECT)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&rc,
                xParam);

    try {
        *(PRECT)lParam = rc;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPRECT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLPSCROLLINFO)
{
    SCROLLINFO scrollinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTLPSCROLLINFO");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&scrollinfo,
            xParam);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure((LPSCROLLINFO)lParam, scrollinfo, SCROLLINFO);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("fnOUTLPSCROLLINFO");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLPRECT)
{
    RECT rc;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTLPRECT");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&rc,
            xParam);

    /*
     * Probe arguments
     */
    try {
        ProbeAndWriteStructure((PRECT)lParam, rc, RECT);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("fnOUTLPRECT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPCOMPAREITEMSTRUCT)
{
    COMPAREITEMSTRUCT compareitemstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPCOMPAREITEMSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        compareitemstruct = ProbeAndReadCompareItemStruct((PCOMPAREITEMSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&compareitemstruct,
            xParam);

    TRACE("fnINLPCOMPAREITEMSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPDELETEITEMSTRUCT)
{
    DELETEITEMSTRUCT deleteitemstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPDELETEITEMSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        deleteitemstruct = ProbeAndReadDeleteItemStruct((PDELETEITEMSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&deleteitemstruct,
            xParam);

    TRACE("fnINLPDELETEITEMSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPHLPSTRUCT)
{
    HLP hlp;
    LPHLP phlp = NULL;
    TL tlBuffer;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPHLPSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        hlp = ProbeAndReadHelp((LPHLP)lParam);
        if (hlp.cbData < sizeof(HLP)) {
            MSGERROR(0);
        }
        phlp = UserAllocPoolWithQuota(hlp.cbData, TAG_SYSTEM);
        if (phlp == NULL) {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }
        ThreadLockPool(ptiCurrent, phlp, &tlBuffer);
        RtlCopyMemory(phlp, (PVOID)lParam, hlp.cbData);
    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)phlp,
            xParam);

    CLEANUPRECV();
    if (phlp) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlBuffer);
    }

    TRACE("fnINLPHLPSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPHELPINFOSTRUCT)
{
    HELPINFO helpinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPHELPINFOSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        helpinfo = ProbeAndReadHelpInfo((LPHELPINFO)lParam);
        if (helpinfo.cbSize != sizeof(HELPINFO)) {
            RIPMSG1(RIP_WARNING, "HELPINFO.cbSize %d is wrong", helpinfo.cbSize);
            MSGERROR(ERROR_INVALID_PARAMETER);
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&helpinfo,
            xParam);

    TRACE("fnINLPHELPINFOSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPDRAWITEMSTRUCT)
{
    DRAWITEMSTRUCT drawitemstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPDRAWITEMSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        drawitemstruct = ProbeAndReadDrawItemStruct((PDRAWITEMSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&drawitemstruct,
            xParam);

    TRACE("fnINLPDRAWITEMSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPMEASUREITEMSTRUCT)
{
    MEASUREITEMSTRUCT measureitemstruct;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTLPMEASUREITEMSTRUCT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteMeasureItemStruct((PMEASUREITEMSTRUCT)lParam);
        measureitemstruct = *(PMEASUREITEMSTRUCT)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&measureitemstruct,
                xParam);

    try {
        *(PMEASUREITEMSTRUCT)lParam = measureitemstruct;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPMEASUREITEMSTRUCT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTSTRING");

    /*
     * Probe all arguments
     */
    try {
        str.bAnsi = bAnsi;
        str.MaximumLength = (ULONG)wParam;
        if (!bAnsi) {
            str.MaximumLength *= sizeof(WCHAR);
        }
        str.Length = 0;
        str.Buffer = (PVOID)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! String buffer must be created in xxxInterSendMsgEx and
     *     lParam probed for write again upon return.
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    /*
     * A dialog function returning FALSE means no text to copy out,
     * but an empty string also has retval == 0: put a null char in
     * pstr for the latter case.
     */
    if (!retval && wParam != 0) {
        try {
            NullTerminateString((PVOID)lParam, bAnsi);
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("fnOUTSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTDWORDINDWORD)
{
    DWORD dw;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTDWORDINDWORD");

    UNREFERENCED_PARAMETER(bAnsi);

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            (WPARAM)&dw,
            lParam,
            xParam);

    /*
     * Probe wParam
     */
    try {
        ProbeAndWriteUlong((PULONG)wParam, dw);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("fnOUTDWORDINDWORD");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INCNTOUTSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINCNTOUTSTRING");

    /*
     * Probe arguments
     */
    try {
        str.bAnsi = bAnsi;
        str.MaximumLength = ProbeAndReadUshort((LPWORD)lParam);
        if (!bAnsi) {
            str.MaximumLength *= sizeof(WCHAR);
        }
        if (str.MaximumLength < sizeof(WORD)) {
            RIPMSG0(RIP_WARNING, "fnINCNTOUTSTRING buffer is too small");
            MSGERROR(0);
        }
        str.Length = 0;
        str.Buffer = (LPBYTE)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! String buffer must be created in xxxInterSendMsgEx and
     *     lParam probed for write again upon return.
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    /*
     * A dialog function returning FALSE means no text to copy out,
     * but an empty string also has retval == 0: put a null char in
     * pstr for the latter case.
     */
    if (!retval) {
        try {
            NullTerminateString((PVOID)lParam, bAnsi);
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("fnINCNTOUTSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INCNTOUTSTRINGNULL)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINCNTOUTSTRINGNULL");

    /*
     * Probe arguments
     */
    try {
        if (wParam < 2) {       // This prevents a possible GP
            MSGERROR(0);
        }

        str.bAnsi = bAnsi;
        str.MaximumLength = (ULONG)wParam;
        if (!bAnsi) {
            str.MaximumLength *= sizeof(WCHAR);
        }
        str.Length = 0;
        str.Buffer = (LPBYTE)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
        *((LPWSTR)str.Buffer) = 0;    // mark incase message is not handled
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! String buffer must be created in xxxInterSendMsgEx and
     *     lParam probed for write again upon return.
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    TRACE("fnINCNTOUTSTRINGNULL");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(POUTLPINT)
{
    BEGINRECV_MESSAGECALL(LB_ERR);
    /*
     * If we use this for other messages, then that return value might not be appropriate.
     */
    UserAssert(msg == LB_GETSELITEMS);
    TRACETHUNK("fnPOUTLPINT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        ProbeForWriteBuffer((LPINT)lParam, wParam, sizeof(BYTE));
#else
        ProbeForWriteBuffer((LPINT)lParam, wParam, sizeof(INT));
#endif
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Buffer must be created in xxxInterSendMsgEx and
     *     lParam probed for write again upon return.
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnPOUTLPINT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(POPTINLPUINT)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnPOPTINLPUINT");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
#if defined(_X86_)
        if (lParam)
            ProbeForReadBuffer((LPUINT)lParam, wParam, sizeof(BYTE));
#else
        if (lParam)
            ProbeForReadBuffer((LPUINT)lParam, wParam, sizeof(DWORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * !!! Data pointed to by lParam must be captured in xxxInterSendMsgEx
     */
    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnPOPTINLPUINT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INOUTLPWINDOWPOS)
{
    WINDOWPOS pos;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTLPWINDOWPOS");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteWindowPos((PWINDOWPOS)lParam);
        pos = *(PWINDOWPOS)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&pos,
                xParam);

    try {
        *(PWINDOWPOS)lParam = pos;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTLPWINDOWPOS");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLPWINDOWPOS)
{
    WINDOWPOS pos;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINLPWINDOWPOS");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        pos = ProbeAndReadWindowPos((PWINDOWPOS)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&pos,
                xParam);

    TRACE("fnINLPWINDOWPOS");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INLBOXSTRING)
{
    BEGINRECV_MESSAGECALL(LB_ERR);
    TRACETHUNK("fnINLBOXSTRING");

    if (!(pwnd->style & LBS_HASSTRINGS) &&
            (pwnd->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE))) {
        retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam);
    } else if (msg == LB_FINDSTRING) {
        retval = NtUserfnINSTRINGNULL(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    } else {
        retval = NtUserfnINSTRING(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    }

    TRACE("fnINLBOXSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLBOXSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(LB_ERR);
    TRACETHUNK("fnOUTLBOXSTRING");

    /*
     * Need to get the string length ahead of time. This isn't passed in
     * with this message. Code assumes app already knows the size of
     * the string and has passed a pointer to a buffer of adequate size.
     * To do client/server copying of this string, we need to ahead of
     * time the Unicode size of this string. We add one character because
     * GETTEXTLEN excludes the null terminator.
     */
    retval = NtUserfnGETDBCSTEXTLENGTHS(
            pwnd,
            LB_GETTEXTLEN,
            wParam,
            lParam,
            xParam,
            xpfnProc,
            /*IS_DBCS_ENABLED() &&*/ bAnsi);   // HiroYama: LATER
    if (retval == LB_ERR)
        MSGERROR(0);
    retval++;

    /*
     * Probe all arguments
     */
    try {
        str.bAnsi = bAnsi;
        if (bAnsi)
            str.MaximumLength = (ULONG)retval;
        else
            str.MaximumLength = (ULONG)retval * sizeof(WCHAR);
        str.Length = 0;
        str.Buffer = (PVOID)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
          MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    /*
     * If the control is ownerdraw and does not have the LBS_HASSTRINGS
     * style, then a 32-bits of application data has been obtained,
     * not a string.
     */
    if (!(pwnd->style & LBS_HASSTRINGS) &&
            (pwnd->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE))) {
        if (bAnsi) {
            retval = sizeof(ULONG_PTR)/sizeof(CHAR);     // 4 CHARs just like win3.1
        } else {
            retval = sizeof(ULONG_PTR)/sizeof(WCHAR);    // 2 WCHARs
        }
    }

    TRACE("fnOUTLBOXSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INCBOXSTRING)
{
    BEGINRECV_MESSAGECALL(CB_ERR);
    TRACETHUNK("fnINCBOXSTRING");

    if (!(pwnd->style & CBS_HASSTRINGS) &&
            (pwnd->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))) {
        retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam);
    } else if (msg == CB_FINDSTRING) {
        retval =  NtUserfnINSTRINGNULL(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    } else {
        retval = NtUserfnINSTRING(
                pwnd,
                msg,
                wParam,
                lParam,
                xParam,
                xpfnProc,
                bAnsi);
    }

    TRACE("fnINCBOXSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTCBOXSTRING)
{
    LARGE_STRING str;

    BEGINRECV_MESSAGECALL(CB_ERR);
    TRACETHUNK("fnOUTCBOXSTRING");

    /*
     * Need to get the string length ahead of time. This isn't passed in
     * with this message. Code assumes app already knows the size of
     * the string and has passed a pointer to a buffer of adequate size.
     * To do client/server copying of this string, we need to ahead of
     * time the size of this string. We add one character because
     * GETTEXTLEN excludes the null terminator.
     */
    retval = NtUserfnGETDBCSTEXTLENGTHS(
            pwnd,
            CB_GETLBTEXTLEN,
            wParam,
            lParam,
            xParam,
            xpfnProc,
            /*IS_DBCS_ENABLED() &&*/ bAnsi);   // HiroYama: LATER
    if (retval == CB_ERR)
        MSGERROR(0);
    retval++;

    /*
     * Probe all arguments
     */
    try {
        str.bAnsi = bAnsi;
        if (bAnsi)
            str.MaximumLength = (ULONG)retval;
        else
            str.MaximumLength = (ULONG)retval * sizeof(WCHAR);
        str.Length = 0;
        str.Buffer = (PVOID)lParam;
#if defined(_X86_)
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength, sizeof(BYTE));
#else
        ProbeForWrite((PVOID)str.Buffer, str.MaximumLength,
                str.bAnsi ? sizeof(BYTE) : sizeof(WORD));
#endif
    } except (StubExceptionHandler(FALSE)) {
          MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            (LPARAM)&str,
            xParam);

    /*
     * If the control is ownerdraw and does not have the CBS_HASSTRINGS
     * style, then a 32-bits of application data has been obtained,
     * not a string.
     */
    if (!(pwnd->style & CBS_HASSTRINGS) &&
            (pwnd->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))) {
        if (bAnsi) {
            retval = sizeof(ULONG_PTR)/sizeof(CHAR);     // 4 CHARs just like win3.1
        } else {
            retval = sizeof(ULONG_PTR)/sizeof(WCHAR);    // 2 WCHARs
        }
    }

    TRACE("fnOUTCBOXSTRING");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(INWPARAMCHAR)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINWPARAMCHAR");

    /*
     * The server always expects the characters to be unicode so
     * if this was generated from an ANSI routine convert it to Unicode
     */
    if (bAnsi) {
        if (msg == WM_CHARTOITEM || msg == WM_MENUCHAR) {
            WPARAM dwT = wParam & 0xFFFF;                // mask of caret pos
            RtlMBMessageWParamCharToWCS(msg, &dwT);     // convert key portion
            wParam = MAKELONG(LOWORD(dwT),HIWORD(wParam));  // rebuild pos & key wParam
        } else {
            RtlMBMessageWParamCharToWCS(msg, &wParam);
        }
    }

    retval = CALLPROC(xpfnProc)(
            pwnd,
            msg,
            wParam,
            lParam,
            xParam);

    TRACE("fnINWPARAMCHAR");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(KERNELONLY)
{
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnKERNELONLY");

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(xParam);
    UNREFERENCED_PARAMETER(xpfnProc);
    UNREFERENCED_PARAMETER(bAnsi);

    RIPMSG0(RIP_WARNING,
            "Message sent from client to kernel for a process which has only kernel side\n" );

    retval = 0;

    TRACE("fnKERNELONLY");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(IMECONTROL)
{
    CANDIDATEFORM   CandForm;
    COMPOSITIONFORM CompForm;
    LOGFONTW        LogFontW;
    LPARAM          lData = lParam;
    PSOFTKBDDATA    pSoftKbdData = NULL;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnIMECONTROL");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * wParam range validation:
     * No need to check lower limit, 'cause we assume IMC_FIRST == 0
     * and wParam is unsigned.
     */
    #if (IMC_FIRST != 0)
    #error IMC_FIRST: unexpected value
    #endif
    if (msg != WM_IME_CONTROL || wParam > IMC_LAST) {
        MSGERROR(0);
    }

    /*
     * Probe arguments
     */
    try {
        switch (wParam) {
        case IMC_GETCANDIDATEPOS:
            ProbeForWriteCandidateForm((PCANDIDATEFORM)lParam);
            break;

        case IMC_GETCOMPOSITIONWINDOW:
            ProbeForWriteCompositionForm((PCOMPOSITIONFORM)lParam);
            break;

        case IMC_GETCOMPOSITIONFONT:
        case IMC_GETSOFTKBDFONT:
            ProbeForWriteLogFontW((PLOGFONTW)lParam);
            break;

        case IMC_SETCANDIDATEPOS:
            CandForm = ProbeAndReadCandidateForm((PCANDIDATEFORM)lParam);
            lData = (LPARAM)&CandForm;
            break;

        case IMC_SETCOMPOSITIONWINDOW:
            CompForm = ProbeAndReadCompositionForm((PCOMPOSITIONFORM)lParam);
            lData = (LPARAM)&CompForm;
            break;

        case IMC_SETCOMPOSITIONFONT:
            LogFontW = ProbeAndReadLogFontW((PLOGFONTW)lParam);
            lData = (LPARAM)&LogFontW;
            break;

        case IMC_SETSOFTKBDDATA:
            pSoftKbdData = ProbeAndCaptureSoftKbdData((PSOFTKBDDATA)lParam);
            if (pSoftKbdData == NULL)
                MSGERROR(0);
            lData = (LPARAM)pSoftKbdData;
            break;

        default:
            break;
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lData,
                xParam);

    CLEANUPRECV();
    if (pSoftKbdData != NULL) {
        UserFreePool(pSoftKbdData);
    }

    TRACE("fnIMECONTROL");
    ENDRECV_MESSAGECALL();
}

#ifdef LATER
MESSAGECALL(IMEREQUEST)
{
    LPARAM          lData = lParam;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnIMEREQUEST");

    UNREFERENCED_PARAMETER(bAnsi);

//    RIPMSG0(RIP_ERROR, "MESSAGECALL(IMEREQUEST) called.\n");

    if (GETPTI(pwnd) != PtiCurrent()) {
        /*
         * Does not allow to send WM_IME_REQUEST to
         * the different thread.
         */
        MSGERROR(ERROR_WINDOW_OF_OTHER_THREAD);
    }

    /*
     * Probe arguments
     */
    try {
        switch (wParam) {
        case IMR_COMPOSITIONWINDOW:
            ProbeForWriteCompositionForm((PCOMPOSITIONFORM)lParam);
            break;

        case IMR_CANDIDATEWINDOW:
            ProbeForWriteCandidateForm((PCANDIDATEFORM)lParam);
            break;

        case IMR_COMPOSITIONFONT:
            ProbeForWriteLogFontW((PLOGFONTW)lParam);
            break;

        case IMR_RECONVERTSTRING:
        case IMR_DOCUMENTFEED:
            if (lParam) {
                ProbeForWriteReconvertString((LPRECONVERTSTRING)lParam);
            }
            break;

        case IMR_CONFIRMRECONVERTSTRING:
            //ProbeAndCaptureReconvertString((LPRECONVERTSTRING)lParam);
            //ProbeForWriteReconvertString((LPRECONVERTSTRING)lParam);
            ProbeForReadReconvertString((LPRECONVERTSTRING)lParam);
            break;

        case IMR_QUERYCHARPOSITION:
            ProbeForWriteImeCharPosition((LPPrivateIMECHARPOSITION)lParam);
            break;

        default:
            MSGERROR(0);
        }

    } except (StubExceptionHandler(FALSE)) {
        MSGERRORCLEANUP(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                lData,
                xParam);

    CLEANUPRECV();

    TRACE("fnIMEREQUEST");
    ENDRECV_MESSAGECALL();
}
#endif

/*
 * Hook stubs
 */

LRESULT NtUserfnHkINLPCBTCREATESTRUCT(
    IN UINT msg,
    IN WPARAM wParam,
    IN LPCBT_CREATEWND pcbt,
    IN BOOL bAnsi)
{
    CBT_CREATEWND cbt;
    CREATESTRUCTEX csex;
    LPCREATESTRUCT lpcsSave;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        cbt = ProbeAndReadCBTCreateStruct(pcbt);
        ProbeForWriteCreateStruct(cbt.lpcs);
        lpcsSave = cbt.lpcs;
        csex.cs = *cbt.lpcs;
        cbt.lpcs = (LPCREATESTRUCT)&csex;
        if (bAnsi) {
            ProbeForRead(csex.cs.lpszName, sizeof(CHAR), sizeof(CHAR));
            RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&csex.strName,
                    (LPSTR)csex.cs.lpszName, (UINT)-1);
            if (IS_PTR(csex.cs.lpszClass)) {
                ProbeForRead(csex.cs.lpszClass, sizeof(CHAR), sizeof(CHAR));
                RtlInitLargeAnsiString((PLARGE_ANSI_STRING)&csex.strClass,
                        (LPSTR)csex.cs.lpszClass, (UINT)-1);
            }
        } else {
            ProbeForRead(csex.cs.lpszName, sizeof(WCHAR), CHARALIGN);
            RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&csex.strName,
                    csex.cs.lpszName, (UINT)-1);
            if (IS_PTR(csex.cs.lpszClass)) {
                ProbeForRead(csex.cs.lpszClass, sizeof(WCHAR), CHARALIGN);
                RtlInitLargeUnicodeString((PLARGE_UNICODE_STRING)&csex.strClass,
                        csex.cs.lpszClass, (UINT)-1);
            }
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
                msg,
                wParam,
                (LPARAM)&cbt);

    try {
        pcbt->hwndInsertAfter = cbt.hwndInsertAfter;
        lpcsSave->x = cbt.lpcs->x;
        lpcsSave->y = cbt.lpcs->y;
        lpcsSave->cx = cbt.lpcs->cx;
        lpcsSave->cy = cbt.lpcs->cy;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    TRACE("NtUserfnHkINLPCBTCREATESTRUCT");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPRECT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPRECT lParam)
{
    RECT rc;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        rc = ProbeAndReadRect((PRECT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&rc);

    TRACE("NtUserfnHkINLPRECT");
    ENDRECV_HOOKCALL();
}

#ifdef REDIRECTION

LRESULT NtUserfnHkINLPPOINT(
    IN DWORD   nCode,
    IN WPARAM  wParam,
    IN LPPOINT lParam)
{
    POINT pt;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        pt = ProbeAndReadPoint((LPPOINT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&pt);

    TRACE("NtUserfnHkINLPPOINT");
    ENDRECV_HOOKCALL();
}

/**************************************************************************\
* NtUserGetProcessRedirectionMode
*
* 04-06-01 MSadek         Created.
\**************************************************************************/

BOOL
NtUserGetProcessRedirectionMode(
    HANDLE hProcess,
    PBOOL pbRedirectionMode)
{
    PEPROCESS Process;
    PPROCESSINFO ppi;

    BEGINRECV(BOOL, FALSE);

   if (hProcess == NtCurrentProcess()) {
        ppi = PpiCurrent();
    } else {
        NTSTATUS Status;
        Status = ObReferenceObjectByHandle(hProcess,
                                           PROCESS_QUERY_INFORMATION,
                                           *PsProcessType,
                                           UserMode,
                                           &Process,
                                           NULL);

        if (!NT_SUCCESS(Status)) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserGetProcessRedirectionMode: Failed with Process handle == %X, Status = %x\n",
                    hProcess, Status);
            MSGERROR(0);
        }

        /*
         * Make sure they are from the same session.
         */
        if (PsGetProcessSessionId(Process) != gSessionId) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserGetProcessRedirectionMode: Different session. Failed with Process handle == %X", hProcess);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        ppi = PpiFromProcess(Process);

        if (ppi == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserGetProcessRedirectionMode: Non GUI process. Process handle == %X", hProcess);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        try {
            ProbeAndWriteLong(pbRedirectionMode, ppi->dwRedirection & PF_REDIRECTED);
            ObDereferenceObject(Process);
        } except (StubExceptionHandler(TRUE)) {
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        retval = TRUE;
    }
    TRACE("NTUserGetProcessRedirectionMode");
    ENDRECV();

}

/**************************************************************************\
* NtUserSetProcessRedirectionMode
*
* 04-06-01 MSadek         Created.
\**************************************************************************/

BOOL
NtUserSetProcessRedirectionMode(
    HANDLE hProcess,
    BOOL bRedirectionMode)
{
    PEPROCESS Process;
    PPROCESSINFO ppi;

    BEGINRECV(BOOL, FALSE);

   /*
    * A host process can not redirect itself.
    */
   if (hProcess == NtCurrentProcess()) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserSetProcessRedirectionMode: A process tried to change redirection mode for itself." );
        MSGERROR(0);
    } else {
        NTSTATUS Status;
        Status = ObReferenceObjectByHandle(hProcess,
                                           PROCESS_SET_INFORMATION,
                                           *PsProcessType,
                                           UserMode,
                                           &Process,
                                           NULL);

        if (!NT_SUCCESS(Status)) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserSetProcessRedirectionMode: Failed with Process handle == %X, Status = %x\n",
                    hProcess, Status);
            MSGERROR(0);
        }

        /*
         * Cannot allow CSRSS to be redirected.
         */
        if (Process == gpepCSRSS) {
            ObDereferenceObject(Process);
            MSGERROR(ERROR_ACCESS_DENIED);
        }

        /*
         * Make sure they are from the same session.
         */
        if (PsGetProcessSessionId(Process) != gSessionId) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserSetProcessRedirectionMode: Different session. Failed with Process handle == %X", hProcess);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        ppi = PpiFromProcess(Process);

        if (ppi == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserSetProcessRedirectionMode: Non GUI process. Process handle == %X", hProcess);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        /*
         * Fail if the target process is a redirection host.
         */
        if (ppi-> dwRedirection & PF_REDIRECTIONHOST) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserSetProcessRedirectionMode: trying to redirect a host process == %X, Status = %x\n",
                    hProcess, Status);
            ObDereferenceObject(Process);
            MSGERROR(0);
        }

        PpiCurrent()->dwRedirection = PF_REDIRECTIONHOST;
        if (bRedirectionMode) {
            ppi->dwRedirection |= PF_REDIRECTED;
        } else {
            ppi->dwRedirection &= ~PF_REDIRECTED;
        }

        xxxSetProcessRedirectionMode(bRedirectionMode, ppi);

        ObDereferenceObject(Process);

        retval = TRUE;
    }
    TRACE("NTUserSetProcessRedirectionMode");
    ENDRECV();

}

/**************************************************************************\
* NtUserGetDesktopRedirectionMode
*
* 04-06-01 MSadek         Created.
\**************************************************************************/

BOOL
NtUserGetDesktopRedirectionMode(
    HDESK hDesk,
    PBOOL pbRedirectionMode)
{
    PDESKTOP pDesk;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    Status = ValidateHdesk(hDesk, UserMode, DESKTOP_QUERY_INFORMATION, &pDesk);

    if (!NT_SUCCESS(Status)) {
        RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserGetDesktopRedirectionMode: Failed with Desktop handle == %X, Status = %x\n",
                hDesk, Status);
        MSGERROR(0);
    }
    try {
        ProbeAndWriteLong(pbRedirectionMode, pDesk->dwDTFlags & DF_REDIRECTED);
        ObDereferenceObject(pDesk);
    } except (StubExceptionHandler(TRUE)) {
        ObDereferenceObject(pDesk);
        MSGERROR(0);
    }

    retval = TRUE;

    TRACE("NTUserGetDesktopRedirectionMode");
    ENDRECV();
}

/**************************************************************************\
* NtUserSetDesktopRedirectionMode
*
* 04-06-01 MSadek         Created.
\**************************************************************************/

BOOL
NtUserSetDesktopRedirectionMode(
    HDESK hDesk,
    BOOL bRedirectionMode)
{
    PDESKTOP pDesk;
    NTSTATUS Status;

    BEGINRECV(BOOL, FALSE);

    Status = ValidateHdesk(hDesk, UserMode, DESKTOP_REDIRECT, &pDesk);

    if (!NT_SUCCESS(Status)) {
        RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "NTUserGetDesktopRedirectionMode: Failed with Desktop handle == %X, Status = %x\n",
                hDesk, Status);
        MSGERROR(0);
    }

    PpiCurrent()->dwRedirection = PF_REDIRECTIONHOST;
    if (bRedirectionMode) {
        pDesk->dwDTFlags |= DF_REDIRECTED;
    } else {
        pDesk->dwDTFlags &= ~DF_REDIRECTED;
    }

    xxxSetDesktopRedirectionMode(bRedirectionMode, pDesk, PpiCurrent());

    ObDereferenceObject(pDesk);

    retval = TRUE;

    TRACE("NtUserSetDesktopRedirectionMode");
    ENDRECV();
}
#endif // REDIRECTION

LRESULT NtUserfnHkINLPMSG(
    IN int iHook,
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMSG lParam)
{
    MSG msg;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        msg = ProbeAndReadMessage((PMSG)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&msg);

    /*
     * If this is GetMessageHook, the hook should be
     * able to change the message, as stated in SDK document.
     */
    if (iHook == WH_GETMESSAGE) {
        try {
            *(PMSG)lParam = msg;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserfnHkINLPMSG");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPDEBUGHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPDEBUGHOOKINFO lParam)
{
    DEBUGHOOKINFO hookinfo;
    DWORD cbDbgLParam;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        hookinfo = ProbeAndReadHookInfo((PDEBUGHOOKINFO)lParam);

        cbDbgLParam = GetDebugHookLParamSize(wParam, &hookinfo);
        ProbeForRead(hookinfo.lParam, cbDbgLParam, DATAALIGN);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&hookinfo);

    TRACE("NtUserfnHkINLPDEBUGHOOKSTRUCT");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkOPTINLPEVENTMSG(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN OUT LPEVENTMSGMSG lParam OPTIONAL)
{
    EVENTMSG event;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lParam)) {
        try {
            ProbeForWriteEvent((LPEVENTMSGMSG)lParam);
            event = *(LPEVENTMSGMSG)lParam;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)(lParam ? &event : NULL));

    if (ARGUMENT_PRESENT(lParam)) {
        try {
            *(LPEVENTMSGMSG)lParam = event;
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserfnHkINLPEVENTMSG");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPMOUSEHOOKSTRUCTEX(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMOUSEHOOKSTRUCTEX lParam)
{
    MOUSEHOOKSTRUCTEX mousehook;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        mousehook = ProbeAndReadMouseHook((PMOUSEHOOKSTRUCTEX)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&mousehook);

    TRACE("NtUserfnHkINLPMOUSEHOOKSTRUCTEX");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPKBDLLHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPKBDLLHOOKSTRUCT lParam)
{
    KBDLLHOOKSTRUCT kbdhook;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        kbdhook = ProbeAndReadKbdHook((PKBDLLHOOKSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&kbdhook);

    TRACE("NtUserfnHkINLPKBDLLHOOKSTRUCT");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserfnHkINLPMSLLHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPMSLLHOOKSTRUCT lParam)
{
    MSLLHOOKSTRUCT msllhook;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        msllhook = ProbeAndReadMsllHook((PMSLLHOOKSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&msllhook);

    TRACE("NtUserfnHkINLPMSLLHOOKSTRUCT");
    ENDRECV_HOOKCALL();
}

#ifdef REDIRECTION
LRESULT NtUserfnHkINLPHTHOOKSTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPHTHOOKSTRUCT lParam)
{
    HTHOOKSTRUCT hthook;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        hthook = ProbeAndReadHTHook((PHTHOOKSTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&hthook);

    TRACE("NtUserfnHkINLPHTHOOKSTRUCT");
    ENDRECV_HOOKCALL();
}
#endif // REDIRECTION

LRESULT NtUserfnHkINLPCBTACTIVATESTRUCT(
    IN DWORD nCode,
    IN WPARAM wParam,
    IN LPCBTACTIVATESTRUCT lParam)
{
    CBTACTIVATESTRUCT cbtactivate;

    BEGINRECV_HOOKCALL();

    /*
     * Probe arguments
     */
    try {
        cbtactivate = ProbeAndReadCBTActivateStruct((LPCBTACTIVATESTRUCT)lParam);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = xxxCallNextHookEx(
            nCode,
            wParam,
            (LPARAM)&cbtactivate);

    TRACE("NtUserfnHkINLPCBTACTIVATESTRUCT");
    ENDRECV_HOOKCALL();
}

LRESULT NtUserCallNextHookEx(
    int nCode,
    WPARAM wParam,
    LPARAM lParam,
    BOOL bAnsi)
{
    BEGINRECV(LRESULT, 0);

    if (PtiCurrent()->sphkCurrent == NULL) {
        MSGERROR(0);
    }

    switch (PtiCurrent()->sphkCurrent->iHook) {
    case WH_CBT:
        /*
         * There are many different types of CBT hooks!
         */
        switch (nCode) {
        case HCBT_CLICKSKIPPED:
            goto MouseHook;
            break;

        case HCBT_CREATEWND:
            /*
             * This hook type points to a CREATESTRUCT, so we need to
             * be fancy it's thunking, because a CREATESTRUCT contains
             * a pointer to CREATEPARAMS which can be anything... so
             * funnel this through our message thunks.
             */
            retval =  NtUserfnHkINLPCBTCREATESTRUCT(
                    nCode,
                    wParam,
                    (LPCBT_CREATEWND)lParam,
                    bAnsi);
            break;

#ifdef REDIRECTION
        case HCBT_GETCURSORPOS:

            /*
             * This hook type points to a POINT structure.
             */
            retval = NtUserfnHkINLPPOINT(nCode, wParam, (LPPOINT)lParam);
            break;
#endif // REDIRECTION

        case HCBT_MOVESIZE:

            /*
             * This hook type points to a RECT structure.
             */
            retval = NtUserfnHkINLPRECT(nCode, wParam, (LPRECT)lParam);
            break;

        case HCBT_ACTIVATE:
            /*
             * This hook type points to a CBTACTIVATESTRUCT
             */
            retval = NtUserfnHkINLPCBTACTIVATESTRUCT(nCode, wParam,
                    (LPCBTACTIVATESTRUCT)lParam);
            break;

        default:
            /*
             * The rest of the cbt hooks are all dword parameters.
             */
            retval = xxxCallNextHookEx(
                    nCode,
                    wParam,
                    lParam);
            break;
        }
        break;

    case WH_FOREGROUNDIDLE:
    case WH_KEYBOARD:
    case WH_SHELL:
        /*
         * These are dword parameters and are therefore real easy.
         */
        retval = xxxCallNextHookEx(
                nCode,
                wParam,
                lParam);
        break;

    case WH_MSGFILTER:
    case WH_SYSMSGFILTER:
    case WH_GETMESSAGE:
        /*
         * These take an lpMsg as their last parameter. Since these are
         * exclusively posted parameters, and since nowhere on the server
         * do we post a message with a pointer to some other structure in
         * it, the lpMsg structure contents can all be treated verbatim.
         */
        retval = NtUserfnHkINLPMSG(PtiCurrent()->sphkCurrent->iHook, nCode, wParam, (LPMSG)lParam);
        break;

    case WH_JOURNALPLAYBACK:
    case WH_JOURNALRECORD:
        /*
         * These take an OPTIONAL lpEventMsg.
         */
        retval = NtUserfnHkOPTINLPEVENTMSG(nCode, wParam, (LPEVENTMSGMSG)lParam);
        break;

    case WH_DEBUG:
        /*
         * This takes an lpDebugHookStruct.
         */
        retval = NtUserfnHkINLPDEBUGHOOKSTRUCT(nCode, wParam, (LPDEBUGHOOKINFO)lParam);
        break;

    case WH_KEYBOARD_LL:
        /*
         * This takes an lpKbdllHookStruct.
         */
        retval = NtUserfnHkINLPKBDLLHOOKSTRUCT(nCode, wParam, (LPKBDLLHOOKSTRUCT)lParam);
        break;

    case WH_MOUSE_LL:
        /*
         * This takes an lpMsllHookStruct.
         */
        retval = NtUserfnHkINLPMSLLHOOKSTRUCT(nCode, wParam, (LPMSLLHOOKSTRUCT)lParam);
        break;

    case WH_MOUSE:
        /*
         * This takes an lpMouseHookStructEx.
         */
MouseHook:
        retval = NtUserfnHkINLPMOUSEHOOKSTRUCTEX(nCode, wParam, (LPMOUSEHOOKSTRUCTEX)lParam);
        break;

#ifdef REDIRECTION
    case WH_HITTEST:
        /*
         * This takes an lpHTHookStruct.
         */
        retval = NtUserfnHkINLPHTHOOKSTRUCT(nCode, wParam, (LPHTHOOKSTRUCT)lParam);
        break;
#endif // REDIRECTION

    default:
        RIPMSG1(RIP_WARNING, "NtUserCallNextHookEx: Invalid hook type %x",
                PtiCurrent()->sphkCurrent->iHook);
        MSGERROR(0);
    }

    TRACE("NtUserCallNextHookEx");
    ENDRECV();
}


HIMC NtUserCreateInputContext(
    IN ULONG_PTR dwClientImcData)
{
    BEGINRECV(HIMC, (HIMC)NULL);

    ValidateIMMEnabled();

    if (dwClientImcData == 0) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid hMemClientIC parameter");
        MSGERROR(0);
    }

    retval = (HIMC)CreateInputContext(dwClientImcData);

    retval = (HIMC)PtoH((PVOID)retval);

    TRACE("NtUserCreateInputContext");
    ENDRECV();
}


BOOL NtUserDestroyInputContext(
    IN HIMC hImc)
{
    PIMC pImc;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateIMMEnabled();

    ValidateHIMC(pImc, hImc);

    retval = DestroyInputContext(pImc);

    TRACE("NtUserDestroyInputContext");
    ENDATOMICRECV();
}


AIC_STATUS NtUserAssociateInputContext(
    IN HWND hwnd,
    IN HIMC hImc,
    IN DWORD dwFlag)
{
    PIMC pImc;

    BEGINATOMICRECV_HWND(AIC_STATUS, AIC_ERROR, hwnd);

    ValidateIMMEnabled();

    ValidateHIMCOPT(pImc, hImc);

    retval = AssociateInputContextEx(pwnd, pImc, dwFlag);

    TRACE("NtUserAssociateInputContext");
    ENDATOMICRECV_HWND();
}

BOOL NtUserUpdateInputContext(
    IN HIMC hImc,
    IN UPDATEINPUTCONTEXTCLASS UpdateType,
    IN ULONG_PTR UpdateValue)
{
    PIMC pImc;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateIMMEnabled();

    ValidateHIMC(pImc, hImc);

    retval = UpdateInputContext(pImc, UpdateType, UpdateValue);

    TRACE("NtUserUpdateInputContext");
    ENDATOMICRECV();
}


ULONG_PTR NtUserQueryInputContext(
    IN HIMC hImc,
    IN INPUTCONTEXTINFOCLASS InputContextInfo)
{
    PTHREADINFO ptiImc;
    PIMC pImc;

    BEGINRECV_SHARED(ULONG_PTR, 0);

    ValidateIMMEnabled();

    ValidateHIMC(pImc, hImc);

    ptiImc = GETPTI(pImc);

    switch (InputContextInfo) {
    case InputContextProcess:
        retval = (ULONG_PTR)PsGetThreadProcessId(ptiImc->pEThread);
        break;

    case InputContextThread:
        retval = (ULONG_PTR)GETPTIID(ptiImc);
        break;

    case InputContextDefaultImeWindow:
        retval = (ULONG_PTR)HW(ptiImc->spwndDefaultIme);
        break;

    case InputContextDefaultInputContext:
        retval = (ULONG_PTR)PtoH(ptiImc->spDefaultImc);
        break;
    }

    ENDRECV_SHARED();
}

NTSTATUS NtUserBuildHimcList(  // private IMM BuildHimcList
    IN DWORD  idThread,
    IN UINT   cHimcMax,
    OUT HIMC *phimcFirst,
    OUT PUINT pcHimcNeeded)
{
    PTHREADINFO pti;
    UINT cHimcNeeded;

    BEGINATOMICRECV(NTSTATUS, STATUS_UNSUCCESSFUL);

    ValidateIMMEnabled();

    switch (idThread) {
    case 0:
        pti = PtiCurrent();
        break;
    case (DWORD)-1:
        pti = NULL;
        break;
    default:
        pti = PtiFromThreadId(idThread);
        if (pti == NULL || pti->rpdesk == NULL) {
            MSGERROR(0);
        }
        break;
    }

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteBuffer(phimcFirst, cHimcMax, sizeof(DWORD));
        ProbeForWriteUlong(pcHimcNeeded);
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    /*
     * phimcFirst is client-side.
     */

    cHimcNeeded = BuildHimcList(pti, cHimcMax, phimcFirst);

    if (cHimcNeeded <= cHimcMax) {
        retval = STATUS_SUCCESS;
    } else {
        retval = STATUS_BUFFER_TOO_SMALL;
    }
    try {
        *pcHimcNeeded = cHimcNeeded;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("NtUserBuildHimcList");
    ENDATOMICRECV();
}


BOOL NtUserGetImeInfoEx(  // private ImmGetImeInfoEx
    IN OUT PIMEINFOEX piiex,
    IN IMEINFOEXCLASS SearchType)
{
    IMEINFOEX iiex;
    BEGINRECV_SHARED(BOOL, FALSE);

    ValidateIMMEnabled();

    try {
        ProbeForWrite(piiex, sizeof(*piiex), sizeof(BYTE));
        RtlCopyMemory(&iiex, piiex, sizeof(IMEINFOEX));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = GetImeInfoEx(
                    _GetProcessWindowStation(NULL),
                    &iiex,
                    SearchType);

    try {
        RtlCopyMemory(piiex, &iiex, sizeof(IMEINFOEX));
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("NtUserGetImeInfoEx");
    ENDRECV_SHARED();
}


BOOL NtUserSetImeInfoEx(
    IN PIMEINFOEX piiex)
{
    IMEINFOEX iiex;
    BEGINRECV(BOOL, FALSE);

    ValidateIMMEnabled();

    /*
     * Probe arguments
     */
    try {
        ProbeForRead(piiex, sizeof(*piiex), sizeof(BYTE));
        RtlCopyMemory(&iiex, piiex, sizeof(IMEINFOEX));
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = SetImeInfoEx(
                    _GetProcessWindowStation(NULL),
                    &iiex);

    TRACE("NtUserSetImeInfoEx");
    ENDRECV();
}

BOOL NtUserGetImeHotKey(
    IN DWORD dwID,
    OUT PUINT puModifiers,
    OUT PUINT puVKey,
    OUT LPHKL phkl)
{
    UINT uModifiers;
    UINT uVKey;
    HKL hkl;
    LPHKL phklIn = NULL;
    BEGINRECV(BOOL, FALSE);

    try {
        ProbeForWriteUlong(((PULONG)puModifiers));
        ProbeForWriteUlong(((PULONG)puVKey));
        if (ARGUMENT_PRESENT(phkl)) {
            ProbeForWriteHandle((PHANDLE)phkl);
            phklIn = &hkl;
        }
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = GetImeHotKey( dwID, &uModifiers, &uVKey, phklIn);

    if (retval) {
        try {
            *puModifiers = uModifiers;
            *puVKey = uVKey;
            if (ARGUMENT_PRESENT(phkl)) {
                *phkl = *phklIn;
            }
        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
    }
    TRACE("NtUserGetImeHotKey");
    ENDRECV();
}

BOOL NtUserSetImeHotKey(
    IN DWORD dwID,
    IN UINT  uModifiers,
    IN UINT  uVKey,
    IN HKL   hkl,
    IN DWORD dwFlags)
{
    BEGINRECV(BOOL, FALSE);

    retval = SetImeHotKey( dwID, uModifiers, uVKey, hkl, dwFlags );
    TRACE("NtUserSetImeHotKey");
    ENDRECV();
}

/*
 * Set per-window application level for IME control.
 * Used only for Korean 3.x ( both 16 bit and 32 bit)
 * applications.
 *
 * return value
 *
 *      TRUE : success
 *      FALSE: error
 */
BOOL NtUserSetAppImeLevel(
    IN HWND  hwnd,
    IN DWORD dwLevel)
{
    BEGINRECV_HWND(BOOL, FALSE, hwnd);

    ValidateIMMEnabled();

    if ( GETPTI(pwnd)->ppi == PpiCurrent() ) {
        InternalSetProp(pwnd, PROP_IMELEVEL, (HANDLE)LongToHandle( dwLevel ), PROPF_INTERNAL | PROPF_NOPOOL);
        retval = TRUE;
    } else {
        MSGERROR(0);
    }
    TRACE("NtUserSetAppImeLevel");
    ENDRECV_HWND();
}

/*
 * Get per-window application level for IME control.
 * Used only for Korean 3.x ( both 16 bit and 32 bit)
 * applications.
 *
 * return value
 *
 *      0               : error
 *      non zero value  : level
 */
DWORD NtUserGetAppImeLevel(
    IN HWND  hwnd)
{
    BEGINRECV_HWND_SHARED(DWORD, 0, hwnd);

    ValidateIMMEnabled();

    if ( GETPTI(pwnd)->ppi == PtiCurrentShared()->ppi ) {
        retval = (DWORD)(ULONG_PTR)_GetProp(pwnd, PROP_IMELEVEL, TRUE);
    } else {
        MSGERROR(0);
    }
    TRACE("NtUserGetAppImeLevel");
    ENDRECV_HWND_SHARED();
}


DWORD NtUserCheckImeHotKey(
    UINT uVKey,
    LPARAM lParam)
{
    PIMEHOTKEYOBJ pImeHotKeyObj;
    BEGINRECV(DWORD, IME_INVALID_HOTKEY);

    if (gpqForeground == NULL)
        MSGERROR(0);

    ValidateIMMEnabled();

    pImeHotKeyObj = CheckImeHotKey(gpqForeground, uVKey, lParam);
    if (pImeHotKeyObj) {
        retval = pImeHotKeyObj->hk.dwHotKeyID;
    }
    else {
        retval = IME_INVALID_HOTKEY;
    }

    TRACE("NtUserCheckImeHotKey");
    ENDRECV();
}

BOOL NtUserSetImeOwnerWindow(
    IN HWND hwndIme,
    IN HWND hwndFocus)
{
    PWND pwndFocus;

    BEGINATOMICRECV_HWND(BOOL, FALSE, hwndIme);

    ValidateIMMEnabled();

    /*
     * Make sure this really is an IME window.
     */
    if (GETFNID(pwnd) != FNID_IME)
        MSGERROR(0);

    ValidateHWNDOPT(pwndFocus, hwndFocus);

    if (pwndFocus != NULL) {
        PWND pwndTopLevel;
        PWND pwndT;

        if (TestCF(pwndFocus, CFIME) ||
                pwndFocus->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
            RIPMSG0(RIP_WARNING, "Focus window should not be an IME/UI window!!");
            MSGERROR(0);
        }

        /*
         * Child window cannot be an owner window.
         */
        pwndTopLevel = pwndT = GetTopLevelWindow(pwndFocus);

        /*
         * To prevent the IME window becomes the onwer (HY?)
         */
        while (pwndT != NULL) {
            if (pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
                RIPMSG0(RIP_WARNING,
                        "The owner of focus window should not be an IME window!!");
                pwndTopLevel = NULL;
                break;
            }
            pwndT = pwndT->spwndOwner;
        }

        UserAssert(pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]);
        UserAssert(pwndTopLevel == NULL || !TestCF(pwndTopLevel, CFIME));
        Lock(&pwnd->spwndOwner, pwndTopLevel);
        ImeCheckTopmost(pwnd);
    }
    else {
        PTHREADINFO ptiImeWnd = GETPTI(pwnd);
        PWND pwndActive = ptiImeWnd->pq->spwndActive;

        /*
         * If pwndFocus == NULL, active window in the queue should become the
         * owner window of the IME window, except: if IME related windows
         * somehow got a focus, or the active window belongs to the other thread.
         */
        if (pwndActive == NULL || pwndActive != pwnd->spwndOwner) {
            if (pwndActive == NULL || IsWndImeRelated(pwndActive) || ptiImeWnd != GETPTI(pwndActive)) {
                /*
                 * We should avoid improper window to be an owner of IME window.
                 */
                ImeSetFutureOwner(pwnd, pwnd->spwndOwner);
            }
            else {
                Lock(&pwnd->spwndOwner, pwndActive);
            }
            ImeCheckTopmost(pwnd);
        }
    }

    retval = TRUE;

    TRACE("NtUserSetImeNewOwner");
    ENDATOMICRECV_HWND();
}


VOID NtUserSetThreadLayoutHandles(
    IN HKL hklNew,
    IN HKL hklOld)
{
    PTHREADINFO ptiCurrent;
    PKL         pklNew;

    BEGINRECV_VOID();

    ptiCurrent = PtiCurrent();

    if (ptiCurrent->spklActive != NULL && ptiCurrent->spklActive->hkl != hklOld)
        MSGERROR_VOID();

    if ((pklNew = HKLtoPKL(ptiCurrent, hklNew)) == NULL)
        MSGERROR_VOID();

    /*
     * hklPrev is only used for IME, non-IME toggle hotkey.
     * The purpose we remember hklPrev is to jump from
     * non-IME keyboard layout to the most recently used
     * IME layout, or to jump from an IME layout to
     * the most recently used non-IME layout. Therefore
     * piti->hklPrev is updated only when [ IME -> non-IME ]
     * or [ non-IME -> IME ] transition is happened.
     */
    if (IS_IME_KBDLAYOUT(hklNew) ^ IS_IME_KBDLAYOUT(hklOld))
        ptiCurrent->hklPrev = hklOld;

    Lock(&ptiCurrent->spklActive, pklNew);

    TRACEVOID("NtUserSetThreadLayoutHandles");
    ENDRECV_VOID();
}

VOID NtUserNotifyIMEStatus(
    IN HWND hwnd,
    IN DWORD dwOpen,
    IN DWORD dwConversion)
{
    BEGINRECV_HWNDLOCK_VOID(hwnd);

    ValidateIMMEnabledVOID();

    xxxNotifyIMEStatus( pwnd, dwOpen, dwConversion );

    TRACEVOID("NtUserNotifyIMEStatus");
    ENDRECV_HWNDLOCK_VOID()
}

BOOL NtUserDisableThreadIme(
    IN DWORD dwThreadId)
{
    PTHREADINFO ptiCurrent, pti;

    BEGINRECV(BOOL, FALSE);

    ValidateIMMEnabled();

    ptiCurrent = PtiCurrent();

    if (dwThreadId == -1) {
        // IME processing is disabled for all the thread in the current process
        ptiCurrent->ppi->W32PF_Flags |= W32PF_DISABLEIME;
        // destory IME stuff
        pti = ptiCurrent->ppi->ptiList;
        while (pti) {
            pti->TIF_flags |= TIF_DISABLEIME;
            if (pti->spwndDefaultIme != NULL) {
                xxxDestroyWindow(pti->spwndDefaultIme);
                // Start the search over from beginning
                // Since the ptilist may be updated
                pti = ptiCurrent->ppi->ptiList;
                continue;
            }
            pti = pti->ptiSibling;
        }
    } else {
        if (dwThreadId == 0) {
            pti = ptiCurrent;
        }
        else {
            pti = PtiFromThreadId(dwThreadId);
            if (pti == NULL || pti->ppi != ptiCurrent->ppi)
                MSGERROR(0);
        }
        pti->TIF_flags |= TIF_DISABLEIME;
        if (pti->spwndDefaultIme != NULL) {
            xxxDestroyWindow(pti->spwndDefaultIme);
        }

    }

    retval = TRUE;

    TRACE("NtUserDisableThreadIme");
    ENDRECV();
}


BOOL
NtUserEnumDisplayMonitors(  // API EnumDisplayMonitors
    IN HDC             hdc,
    IN LPCRECT         lprcClip,
    IN MONITORENUMPROC lpfnEnum,
    IN LPARAM          dwData)
{
    RECT    rc;
    LPRECT  lprc = (LPRECT) lprcClip;

    BEGINRECV(BOOL, FALSE);

    /*
     * Probe arguments
     */
    if (ARGUMENT_PRESENT(lprc)) {
        try {
            rc = ProbeAndReadRect(lprc);
            lprc = &rc;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    retval = xxxEnumDisplayMonitors(
            hdc,
            lprc,
            lpfnEnum,
            dwData,
            FALSE);

    TRACE("NtUserEnumDisplayMonitors");
    ENDRECV();
}

/*
 * NtUserQueryUserCounters() retrieves statistics on win32k
 * QUERYUSER_TYPE_USER retrieves the handle counters
 * QUERYUSER_TYPE_CS will fill the result buffer with USER critical section usage data
 */

BOOL
NtUserQueryUserCounters(  // private QueryUserCounters
    IN  DWORD       dwQueryType,
    IN  LPVOID      pvIn,
    IN  DWORD       dwInSize,
    OUT LPVOID      pvResult,
    IN  DWORD       dwOutSize)
{
    PDWORD  pdwInternalIn = NULL;
    PDWORD  pdwInternalResult = NULL;

    BEGINRECV(BOOL, FALSE);

#if defined (USER_PERFORMANCE)
    if (dwQueryType == QUERYUSER_CS) {
        CSSTATISTICS* pcsData;

        if (dwOutSize != sizeof(CSSTATISTICS)) {
            MSGERROR(0);
        }
        try {
            ProbeForWrite((PDWORD)pvResult, dwOutSize, sizeof(DWORD));

            /*
             * Checking for overflow on these counters is caller responsability
             */
            pcsData = (CSSTATISTICS*)pvResult;
            pcsData->cExclusive       = gCSStatistics.cExclusive;
            pcsData->cShared          = gCSStatistics.cShared;
            pcsData->i64TimeExclusive = gCSStatistics.i64TimeExclusive;

        } except (StubExceptionHandler(FALSE)) {
            MSGERROR(0);
        }
        retval = TRUE;
        MSGERROR_VOID();
    }
    else
#endif // USER_PERFORMANCE

    if (dwQueryType == QUERYUSER_HANDLES) {

        /*
         * Probe arguments, dwInSize should be multiple of 4
         */
        if (dwInSize & (sizeof(DWORD)-1) ||
            dwOutSize != TYPE_CTYPES*dwInSize) {

            MSGERROR(0)
        }

        try {
            ProbeForRead((PDWORD)pvIn, dwInSize, sizeof(DWORD));
            pdwInternalIn = UserAllocPoolWithQuota(dwInSize, TAG_SYSTEM);
            if (!pdwInternalIn) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }
            RtlCopyMemory(pdwInternalIn, pvIn, dwInSize);

            ProbeForWrite(pvResult, dwOutSize, sizeof(DWORD));
            pdwInternalResult = UserAllocPoolWithQuota(dwOutSize, TAG_SYSTEM);
            if (!pdwInternalResult) {
                ExRaiseStatus(STATUS_NO_MEMORY);
            }

        } except (StubExceptionHandler(FALSE)) {
                MSGERRORCLEANUP(0);
        }

        _QueryUserHandles(pdwInternalIn,
                dwInSize/sizeof(DWORD),
                (DWORD (*)[TYPE_CTYPES])pdwInternalResult);
        retval = TRUE;

        try {
            RtlCopyMemory(pvResult, pdwInternalResult, dwOutSize);

        } except (StubExceptionHandler(FALSE)) {
                MSGERRORCLEANUP(0);
        }
    }

    else {

       MSGERROR(0);
    }

    CLEANUPRECV();
    if (pdwInternalIn) {
        UserFreePool(pdwInternalIn);
    }
    if (pdwInternalResult) {
        UserFreePool(pdwInternalResult);
    }

    TRACE("NtUserQueryCounters");
    ENDRECV();
}


/***************************************************************************\
* NtUserINOUTGETMENUINFO
*
* History:
*  11-12-96 GerardoB - Created
\***************************************************************************/
MESSAGECALL(INOUTMENUGETOBJECT)
{
    MENUGETOBJECTINFO mgoi;
    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnINOUTMENUGETOBJECT");

    UNREFERENCED_PARAMETER(bAnsi);

    try {
        /*
         * Capture now so xxxInterSendMsgEx won't have to.
         */
        mgoi = ProbeAndReadMenuGetObjectInfo((PMENUGETOBJECTINFO)lParam);

    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }
    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&mgoi,
                xParam);

    try {
        *((PMENUGETOBJECTINFO)lParam) = mgoi;

    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnINOUTMENUGETOBJECT");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLPCOMBOBOXINFO)
{
    COMBOBOXINFO cbinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTLPCOMBOBOXINFO");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteComboBoxInfo((PCOMBOBOXINFO)lParam);
        cbinfo = *(PCOMBOBOXINFO)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&cbinfo,
                xParam);

    try {
        *(PCOMBOBOXINFO)lParam = cbinfo;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnOUTLPCOMBOBOXINFO");
    ENDRECV_MESSAGECALL();
}

MESSAGECALL(OUTLPSCROLLBARINFO)
{
    SCROLLBARINFO sbinfo;

    BEGINRECV_MESSAGECALL(0);
    TRACETHUNK("fnOUTLPSCROLLBARINFO");

    UNREFERENCED_PARAMETER(bAnsi);

    /*
     * Probe arguments
     */
    try {
        ProbeForWriteScrollBarInfo((PSCROLLBARINFO)lParam);
        sbinfo = *(PSCROLLBARINFO)lParam;
    } except (StubExceptionHandler(FALSE)) {
        MSGERROR(0);
    }

    retval = CALLPROC(xpfnProc)(
                pwnd,
                msg,
                wParam,
                (LPARAM)&sbinfo,
                xParam);

    try {
        *(PSCROLLBARINFO)lParam = sbinfo;
    } except (StubExceptionHandler(FALSE)) {
    }

    TRACE("fnOUTLPSCROLLBARINFO");
    ENDRECV_MESSAGECALL();
}

/***************************************************************************\
* NtUserFlashWindowEx
*
* History:
*  11-16-96 MCostea - Created
\***************************************************************************/
BOOL
NtUserFlashWindowEx(  // API FlashWindowEx
    IN PFLASHWINFO pfwi)
{
    FLASHWINFO fwiInternal;
    TL tlpwnd;
    PWND pwnd;

    BEGINRECV(BOOL, FALSE);
    DBG_THREADLOCK_START(FlashWindowEx);

    /*
     * Probe arguments
     */
    try {
        fwiInternal = ProbeAndReadStructure(pfwi, FLASHWINFO);

    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if ((pwnd = ValidateHwnd(fwiInternal.hwnd)) == NULL ||
        fwiInternal.cbSize != sizeof(FLASHWINFO) ||
        fwiInternal.dwFlags & ~FLASHW_VALID) {

        RIPMSG0(RIP_WARNING, "NtUserFlashWindowEx: Invalid Parameter");
        MSGERROR(ERROR_INVALID_PARAMETER);
    }
    else {
        ThreadLockAlwaysWithPti(PtiCurrent(), pwnd, &tlpwnd);
        retval = xxxFlashWindow(pwnd,
                            MAKELONG(fwiInternal.dwFlags, fwiInternal.uCount),
                            fwiInternal.dwTimeout);
        ThreadUnlock(&tlpwnd);
    }

    DBG_THREADLOCK_END(FlashWindowEx);

    TRACE("NtUserFlashWindowEx");
    ENDRECV();
}

BOOL NtUserUpdateLayeredWindow(  // API UpdateLayeredWindow
    IN HWND hwnd,
    IN HDC hdcDst,
    IN POINT *pptDst,
    IN SIZE *psize,
    IN HDC hdcSrc,
    IN POINT *pptSrc,
    IN COLORREF crKey,
    IN BLENDFUNCTION *pblend,
    IN DWORD dwFlags)
{
    PWND pwnd;
    POINT ptSrc;
    SIZE size;
    POINT ptDst;
    BLENDFUNCTION blend;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWND(pwnd, hwnd);

    /*
     * Probe and validate arguments.
     */
    try {
        if (ARGUMENT_PRESENT(pptSrc)) {
            ptSrc = ProbeAndReadPoint(pptSrc);
            pptSrc = &ptSrc;
        }
        if (ARGUMENT_PRESENT(psize)) {
            size = ProbeAndReadSize(psize);
            psize = &size;
            if (psize->cx < 0 || psize->cy < 0) {
                MSGERROR(ERROR_INVALID_PARAMETER);  // this is a jump out of try!
            }
        }
        if (ARGUMENT_PRESENT(pptDst)) {
            ptDst = ProbeAndReadPoint(pptDst);
            pptDst = &ptDst;
        }

        if (ARGUMENT_PRESENT(pblend)) {
            blend = ProbeAndReadBlendfunction(pblend);
            pblend = &blend;
        }
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    if (dwFlags & ~ULW_VALID) {
        RIPMSG0(RIP_WARNING, "UpdateLayeredWindow: Invalid Parameter");
        MSGERROR(ERROR_INVALID_PARAMETER);
    } else {
        retval = _UpdateLayeredWindow(
                pwnd,
                hdcDst,
                pptDst,
                psize,
                hdcSrc,
                pptSrc,
                crKey,
                pblend,
                dwFlags);
    }

    TRACE("NtUserUpdateLayeredWindow");
    ENDATOMICRECV();
}

BOOL NtUserGetLayeredWindowAttributes(
    IN HWND hwnd,
    OUT OPTIONAL COLORREF *pcrKey,
    OUT OPTIONAL BYTE *pbAlpha,
    OUT OPTIONAL DWORD *pdwFlags)
{
    PWND pwnd;
    COLORREF crKey;
    BYTE bAlpha;
    DWORD dwFlags;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWND(pwnd, hwnd);

    retval = _GetLayeredWindowAttributes(pwnd, &crKey, &bAlpha, &dwFlags);
    if (retval) {
        try {
            if (ARGUMENT_PRESENT(pcrKey)) {
                ProbeForWrite(pcrKey, sizeof(COLORREF), sizeof(COLORREF));
                *pcrKey = crKey;
            }

            if (ARGUMENT_PRESENT(pbAlpha)) {
                ProbeForWrite(pbAlpha, sizeof(BYTE), sizeof(BYTE));
                *pbAlpha = bAlpha;
            }

            if (ARGUMENT_PRESENT(pdwFlags)) {
                ProbeForWrite(pdwFlags, sizeof(DWORD), sizeof(DWORD));
                *pdwFlags = dwFlags & ULW_VALID;
            }
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    }

    TRACE("NtUserGetLayeredWindowAttributes");
    ENDATOMICRECV();
}


BOOL NtUserSetLayeredWindowAttributes(
    IN HWND hwnd,
    IN COLORREF crKey,
    IN BYTE bAlpha,
    IN DWORD dwFlags)
{
    PWND pwnd;

    BEGINATOMICRECV(BOOL, FALSE);

    ValidateHWND(pwnd, hwnd);

    if (dwFlags & ~LWA_VALID) {
        RIPMSG0(RIP_WARNING, "SetLayeredWindowAttributes: Invalid Parameter");
        MSGERROR(ERROR_INVALID_PARAMETER);
    } else {
        retval = _SetLayeredWindowAttributes(pwnd, crKey, bAlpha, dwFlags);
    }

    TRACE("NtUserSetLayeredWindowAttributes");
    ENDATOMICRECV();
}


BOOL NtUserPrintWindow(
    IN HWND hwnd,
    IN HDC hdcBlt,
    IN UINT nFlags)
{
    BEGINRECV_HWNDLOCK_ND(BOOL, FALSE, hwnd);
    if ((nFlags & PW_VALID) != nFlags) {
        RIPMSG2(RIP_WARNING, "PrintWindow: Invalid Parameter nFlags=%d on HWND=0x%p", nFlags, hwnd);
        MSGERROR(ERROR_INVALID_PARAMETER);
    } else {
        retval = xxxPrintWindow(pwndND, hdcBlt, nFlags);
    }

    TRACE("NtUserPrintWindow");
    ENDRECV_HWNDLOCK_ND();
}


/***************************************************************************\
* GetHDevName
* Called by NtUserCallTwoParam in GetMonitorInfo to query
* gre about the HDev name
*
* 1-July-1998    MCostea      created
\***************************************************************************/
BOOL GetHDevName(HMONITOR hMon, PWCHAR pName)
{
    PMONITOR pMonitor;
    WCHAR wszName[CCHDEVICENAME];
    BOOL fResult = FALSE;

    CheckCritIn();

    pMonitor = ValidateHmonitor(hMon);
    if (!pMonitor) {
        return FALSE;
    }

    if (DrvGetHdevName(pMonitor->hDev, wszName)) {
        /*
         * Make sure it's NULL terminated.
         */
        wszName[CCHDEVICENAME - 1] = 0;
        try {
            ProbeForWrite(pName, CCHDEVICENAME * sizeof(WCHAR), sizeof(DWORD));
            RtlCopyMemory(pName, wszName, CCHDEVICENAME * sizeof(WCHAR));
        } except (StubExceptionHandler(TRUE)) {
            goto _exit;
        }
        fResult = TRUE;
    }

_exit:
    return fResult;
}


#ifdef GENERIC_INPUT
/***************************************************************************\
* NtUserGetRawInputData
* Gets the HIDDATA structure from its HRAWINPUT handle.
*
* Returns the number of bytes written to pRawInput. On error, it returns -1 and zero
* in *pcbSize. If pRawInput is NULL, it returns zero and the number of bytes need to
* receive the data in pcbSize.
*
* If pRawInput is not big enough, it return -1 and the number of bytes needed to
* receive the data in pcbSize.
*
* 25-February-2000    JasonSch       created
\***************************************************************************/

UINT NtUserGetRawInputData(
    HRAWINPUT hRawInput,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize,
    UINT cbSizeHeader)
{
    PHIDDATA pHidData;
    UINT cbOutSize, cbBufferSize;

    BEGINATOMICRECV(UINT, (UINT)-1);

    if (cbSizeHeader != sizeof(RAWINPUTHEADER)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    /*
     * Get the report data contents.
     */
    pHidData = HMValidateHandle(hRawInput, TYPE_HIDDATA);
    if (pHidData == NULL) {
        RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING, "NtUserGetRawInputData: invalid handle %p", hRawInput);
        MSGERROR(0);
    }

    /*
     * Check the type of the raw input data.
     */
    switch (pHidData->rid.header.dwType) {
    case RIM_TYPEMOUSE:
    case RIM_TYPEKEYBOARD:
    case RIM_TYPEHID:
        break;
    default:
        // The handle is valid, but the internal state of the object is weird. Assert.
        UserAssertMsg1(0, "Bad dwType for pHidData = %#p", pHidData);
        RIPERR2(ERROR_INVALID_HANDLE, RIP_ERROR, "NtUserGetRawInputData: invalid type %x in pHidData %p",
                pHidData->rid.header.dwType, pHidData);
        MSGERROR(0);
    }

    /*
     * Calculate the size of the data
     */
    switch (uiCommand) {
    case RID_INPUT:
        cbOutSize = pHidData->rid.header.dwSize;
        break;
    case RID_HEADER:
        cbOutSize = sizeof pHidData->rid.header;
        break;
    default:
        MSGERROR(ERROR_INVALID_PARAMETER);
        break;
    }

#if DBG
    if (pHidData->rid.header.dwType == RIM_TYPEHID && uiCommand == RID_INPUT) {
        /*
         * TYPEHID has variable length array of report data.
         */
        TAGMSG3(DBGTAG_PNP, "NtUserGetRawInputData: pHidData=%p, dwOutSize=%x, calc'ed=%x",
                pHidData,
                cbOutSize, FIELD_OFFSET(RAWINPUT, data.hid.bRawData) + pHidData->rid.data.hid.dwSizeHid * pHidData->rid.data.hid.dwCount);
        UserAssert(cbOutSize == FIELD_OFFSET(RAWINPUT, data.hid.bRawData) + pHidData->rid.data.hid.dwSizeHid * pHidData->rid.data.hid.dwCount);
    }
#endif

    if (pData == NULL) {
        /*
         * The caller wants to get the required size of the buffer.
         */
        try {
            ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
            *pcbSize = cbOutSize;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
        retval = 0;
    } else {
        try {
            ProbeForRead(pcbSize, sizeof(UINT), sizeof(DWORD));
            cbBufferSize = *pcbSize;
        } except (StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }

        if (cbBufferSize >= cbOutSize) {
            try {
                switch (uiCommand) {
                case RID_INPUT:
                    ProbeForWrite(pData, cbOutSize, sizeof(DWORD));
                    RtlCopyMemory(pData, &pHidData->rid, cbOutSize);
                    break;

                case RID_HEADER:
                    {
                        PRAWINPUTHEADER pHeader = (PRAWINPUTHEADER)pData;
                        UserAssert(cbOutSize == sizeof(RAWINPUTHEADER));
                        ProbeAndWriteStructure(pHeader, pHidData->rid.header, RAWINPUTHEADER);
                    }
                    break;

                default:
                    UserAssert(FALSE);
                    break;
                }
            } except (StubExceptionHandler(TRUE)) {
                MSGERROR(0);
            }
            retval = cbOutSize;
        } else {
            retval = errret;
            try {
                ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
                *pcbSize = cbBufferSize;
                UserSetLastError(ERROR_INSUFFICIENT_BUFFER);
            } except(StubExceptionHandler(TRUE)) {
                MSGERROR(0);
            }
        }
    }

    TRACE("NtUserGetRawInputData");
    ENDATOMICRECV();
}


UINT NtUserGetRawInputDeviceInfo(
    HANDLE hDevice,
    UINT uiCommand,
    LPVOID pData,
    PUINT pcbSize)
{
    PDEVICEINFO pDeviceInfo;
    UINT cbOutSize = 0;
    UINT cbBufferSize;

    BEGINATOMICRECV(DWORD, (UINT)-1);

    try {
        ProbeForRead(pcbSize, sizeof(UINT), sizeof(DWORD));
        cbBufferSize = *pcbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    EnterDeviceInfoListCrit();

    pDeviceInfo = HMValidateHandle(hDevice, TYPE_DEVICEINFO);
    if (pDeviceInfo == NULL) {
        RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING, "NtUserGetRawInputDeviceInfo: invalid handle=%p", hDevice);
        MSGERRORCLEANUP(0);
    }

    /*
     * Compute the size of the output and evaluate the uiCommand.
     */
    switch (uiCommand) {
    case RIDI_PREPARSEDDATA:
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            cbOutSize = pDeviceInfo->hid.pHidDesc->hidCollectionInfo.DescriptorSize;
        } else {
            cbOutSize = 0;
        }
        break;
    case RIDI_DEVICENAME:
        /*
         * N.b. UNICODE_STRING counts the length by the BYTE count, not by the character count.
         * Our APIs always treat the strings by the character count. Thus, for RIDI_DEVICNAME
         * only, cbOutSize holds the character count, not the byte count, in spite of its
         * name. Confusing, but cch is the way to be consistent.
         */
        cbOutSize = pDeviceInfo->ustrName.Length / sizeof(WCHAR) + 1;   // for Null terminator
        break;

    case RIDI_DEVICEINFO:
        cbOutSize = sizeof(RID_DEVICE_INFO);
        break;

    default:
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "NtUserGetRawInputDeviceInfo: invalid uiCommand=%x", uiCommand);
        MSGERRORCLEANUP(0);
        break;
    }

    if (pData == NULL) {
        /*
         * The app wants to get the required size.
         */
        try {
            ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
            *pcbSize = cbOutSize;
        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
        retval = 0;
    } else {
        if (cbBufferSize >= cbOutSize) {
            try {
                ProbeForWrite(pData, cbBufferSize, sizeof(DWORD));
                switch (uiCommand) {
                case RIDI_PREPARSEDDATA:
                    if (pDeviceInfo->type == DEVICE_TYPE_HID) {
                        RtlCopyMemory(pData, pDeviceInfo->hid.pHidDesc->pPreparsedData, cbOutSize);
                    } else {
                        UserAssert(cbOutSize == 0);
                    }
                    break;

                case RIDI_DEVICENAME:
                    UserAssert((cbOutSize -1) * sizeof(WCHAR) == pDeviceInfo->ustrName.Length);
                    RtlCopyMemory(pData, pDeviceInfo->ustrName.Buffer, pDeviceInfo->ustrName.Length);
                    ((WCHAR*)pData)[cbOutSize - 1] = 0; // make it null terminated
                    break;

                case RIDI_DEVICEINFO:
                    {
                        PRID_DEVICE_INFO prdi = (PRID_DEVICE_INFO)pData;

                        ProbeForRead(prdi, sizeof(UINT), sizeof(DWORD));
                        if (prdi->cbSize != cbOutSize) {
                            MSGERRORCLEANUP(ERROR_INVALID_PARAMETER);
                        }
                        ProbeForWrite(prdi, sizeof(RID_DEVICE_INFO), sizeof(DWORD));
                        RtlZeroMemory(prdi, sizeof(RID_DEVICE_INFO));
                        prdi->cbSize = cbOutSize;

                        switch (pDeviceInfo->type) {
                        case DEVICE_TYPE_HID:
                            prdi->dwType = RIM_TYPEHID;
                            prdi->hid.dwVendorId = pDeviceInfo->hid.pHidDesc->hidCollectionInfo.VendorID;
                            prdi->hid.dwProductId = pDeviceInfo->hid.pHidDesc->hidCollectionInfo.ProductID;
                            prdi->hid.dwVersionNumber = pDeviceInfo->hid.pHidDesc->hidCollectionInfo.VersionNumber;
                            prdi->hid.usUsagePage = pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage;
                            prdi->hid.usUsage = pDeviceInfo->hid.pHidDesc->hidpCaps.Usage;
                            break;

                        case DEVICE_TYPE_MOUSE:
                            prdi->dwType = RIM_TYPEMOUSE;
                            prdi->mouse.dwId = pDeviceInfo->mouse.Attr.MouseIdentifier;
                            prdi->mouse.dwNumberOfButtons = pDeviceInfo->mouse.Attr.NumberOfButtons;
                            prdi->mouse.dwSampleRate = pDeviceInfo->mouse.Attr.SampleRate;
                            break;

                        case DEVICE_TYPE_KEYBOARD:
                            prdi->dwType = RIM_TYPEKEYBOARD;
                            prdi->keyboard.dwType = GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo);
                            prdi->keyboard.dwSubType = GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo);
                            prdi->keyboard.dwKeyboardMode = pDeviceInfo->keyboard.Attr.KeyboardMode;
                            prdi->keyboard.dwNumberOfFunctionKeys = pDeviceInfo->keyboard.Attr.NumberOfFunctionKeys;
                            prdi->keyboard.dwNumberOfIndicators = pDeviceInfo->keyboard.Attr.NumberOfIndicators;
                            prdi->keyboard.dwNumberOfKeysTotal = pDeviceInfo->keyboard.Attr.NumberOfKeysTotal;
                            break;
                        }
                    }
                    break;

                default:
                    UserAssert(FALSE);
                    break;
                }
            } except (StubExceptionHandler(TRUE)) {
                MSGERRORCLEANUP(0);
            }
            retval = cbOutSize;
        } else {
            /*
             * The buffer size is too small.
             * Returns error, storing the required size in *pcbSize.
             */
            retval = errret;
            try {
                ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
                *pcbSize = cbOutSize;
                UserSetLastError(ERROR_INSUFFICIENT_BUFFER);
            } except (StubExceptionHandler(TRUE)) {
                MSGERRORCLEANUP(0);
            }
        }
    }


    CLEANUPRECV();
    LeaveDeviceInfoListCrit();

    TRACE("NtUserGetRawInputDeviceInfo");
    ENDATOMICRECV();
}


UINT NtUserGetRawInputDeviceList(
    PRAWINPUTDEVICELIST pRawInputDeviceList,
    PUINT puiNumDevices,
    UINT cbSize)
{
    UINT nDevices = 0;
    PDEVICEINFO pDeviceInfo;

    BEGINATOMICRECV(DWORD, (UINT)-1);

    if (cbSize != sizeof(RAWINPUTDEVICELIST)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    EnterDeviceInfoListCrit();

    /*
     * Firstly, count up the number of devices
     * attached to the system.
     */
    for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
        ++nDevices;
    }

    if (pRawInputDeviceList == NULL) {
        /*
         * Application simply wants the number of devices.
         */
        try {
            /*
             * Store number of devices.
             */
            ProbeForWrite(puiNumDevices, sizeof(UINT), sizeof(DWORD));
            *puiNumDevices = nDevices;
            /*
             * Set retval as 0, to indicate the API succeeded.
             */
            retval = 0;
        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
    } else {
        /*
         * Write out the device info list.
         */
        try {
            UINT i;

            ProbeForRead(puiNumDevices, sizeof(UINT), sizeof(DWORD));
            if (*puiNumDevices < nDevices) {
                /*
                 * If the buffer size is not sufficient, set the required
                 * number of buffers, then return error.
                 */
                ProbeForWrite(puiNumDevices, sizeof(UINT), sizeof(DWORD));
                *puiNumDevices = nDevices;
                MSGERRORCLEANUP(ERROR_INSUFFICIENT_BUFFER);
            }
            ProbeForWrite(pRawInputDeviceList, sizeof(RAWINPUTDEVICELIST) * nDevices, sizeof(HANDLE));
            for (i = 0, pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext, ++i) {
                UserAssert(i < nDevices);
                pRawInputDeviceList[i].hDevice = PtoHq(pDeviceInfo);
                pRawInputDeviceList[i].dwType = pDeviceInfo->type;
            }
            UserAssert(i == nDevices);
            retval = i;
        } except (StubExceptionHandler(TRUE)) {
            MSGERRORCLEANUP(0);
        }
    }

    CLEANUPRECV();
    LeaveDeviceInfoListCrit();

    TRACE("NtUserGetRawInputDeviceList");
    ENDATOMICRECV();
}


BOOL NtUserRegisterRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    UINT uiNumDevices,
    UINT cbSize)
{
    BEGINATOMICRECV(BOOL, FALSE);

    if (pRawInputDevices == NULL || uiNumDevices == 0 || cbSize != sizeof(RAWINPUTDEVICE)) {
        /*
         * TBD:
         * What should we do if pRawInputDevices is NULL?
         * Perhaps should start receiving all HID input?
         */
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    try {
        ProbeForReadBuffer(pRawInputDevices, uiNumDevices, sizeof(DWORD));
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    retval = _RegisterRawInputDevices(pRawInputDevices, uiNumDevices);

    TRACE("NtUserSetRawInputDevices");
    ENDATOMICRECV();
}

UINT NtUserGetRegisteredRawInputDevices(
    PRAWINPUTDEVICE pRawInputDevices,
    PUINT puiNumDevices,
    UINT cbSize)
{
    BEGINATOMICRECV(DWORD, (UINT)-1);

    if (cbSize != sizeof(RAWINPUTDEVICE)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    retval = _GetRegisteredRawInputDevices(pRawInputDevices, puiNumDevices);

    ENDATOMICRECV();
}

#ifdef _WIN64
# ifndef QWORD_ALIGN
# define QWORD_ALIGN(x) (((x) + 7) & ~7)
# endif
#define RI_ALIGN(x) QWORD_ALIGN(x)
#else
#define RI_ALIGN(x) DWORD_ALIGN(x)
#endif  // _Win64

UINT NtUserGetRawInputBuffer(
    PRAWINPUT pData,
    PUINT pcbSize,
#ifdef LATER
    DWORD dwFlags,
#endif
    UINT cbSizeHeader)
{
    UINT cbBytes = 0;               /* # of bytes written to the buffer   */
    UINT cbWriteSize = 0;           /* the # of bytes to write into pData */
    PQMSG pqmsg;
    PTHREADINFO ptiCurrent;
    PQ pq;
    PHIDDATA pHidData;
    UINT cbBufferSize; /* the size of the passed in buffer */
    UINT cRICount = 0; /* # of RAWINPUT structures written to the buffer */

    BEGINATOMICRECV(UINT, -1);

#ifdef LATER
    if (dwFlags != 0) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }
#endif

    if (cbSizeHeader != sizeof(RAWINPUTHEADER)) {
        MSGERROR(ERROR_INVALID_PARAMETER);
    }

    try {
        ProbeForRead(pcbSize, sizeof(UINT), sizeof(DWORD));
        cbBufferSize = *pcbSize;
    } except (StubExceptionHandler(TRUE)) {
        MSGERROR(0);
    }

    ptiCurrent = PtiCurrent();
    pq = ptiCurrent->pq;
    pqmsg = pq->mlInput.pqmsgRead;
    while (pqmsg) {
        // Remember the next pqmsg, for the current pqmsg may be freed in this loop
        PQMSG pqmsgNext = pqmsg->pqmsgNext;

        if (pqmsg->msg.message == WM_INPUT) {
            pHidData = HMValidateHandle((HRAWINPUT)pqmsg->msg.lParam, TYPE_HIDDATA);
            UserAssert(pHidData != NULL);

            cbWriteSize = RI_ALIGN(pHidData->rid.header.dwSize);
            if (pData == NULL || (cbBytes + cbWriteSize) > cbBufferSize) {
                break;
            }

            try {
                ProbeForWrite(pData, cbWriteSize, sizeof(DWORD));
                RtlCopyMemory(pData, &pHidData->rid, pHidData->rid.header.dwSize);
                ++cRICount;
                (PBYTE)pData += cbWriteSize;
                cbBytes += cbWriteSize;
            } except (StubExceptionHandler(TRUE)) {
                RIPMSG3(RIP_WARNING, "NtUserGetRawInputBuffer: exception: src=%p target=%p  %x bytes",
                        &pHidData->rid, pData, pHidData->rid.header.dwSize);
                MSGERROR(0);
            }

            // Update the time of the messages
            ptiCurrent->timeLast = pqmsg->msg.time;

            // Remove this msg from the queue
            DelQEntry(&pq->mlInput, pqmsg);
            FreeHidData(pHidData);
        }
        pqmsg = pqmsgNext;
    }

    // If pqmsg is NULL then we went through the entire MLIST. This will
    // only happen if we have copied all of the WM_INPUTs into the buffer or
    // there were none to begin with. Either way, there are none left. So turn
    // off QS_RAWINPUT.
    if(pqmsg == NULL && pData != NULL) {
        ClearWakeBit(ptiCurrent, QS_RAWINPUT, FALSE);
    }

    if (cbBufferSize <= cbWriteSize || pData == NULL) {
        if(pData == NULL) {
            retval = 0;
        } else {
            retval = errret;
            UserSetLastError(ERROR_INSUFFICIENT_BUFFER);
        }

        try {
            ProbeForWrite(pcbSize, sizeof(UINT), sizeof(DWORD));
            *pcbSize = cbWriteSize;
        } except(StubExceptionHandler(TRUE)) {
            MSGERROR(0);
        }
    } else {
        // Update the last time read
        SET_TIME_LAST_READ(ptiCurrent);
        retval = cRICount;
    }

    TRACE("NtUserGetRawInputBuffer");
    ENDATOMICRECV();
}
#undef RI_ALIGN

#endif // GENERIC_INPUT

#ifdef LAME_BUTTON
VOID SetStackTrace(
    HWND hwnd,
    PVOID pStackTrace)
{
    PWND pwnd;

    if ((pwnd = ValidateHwnd((hwnd))) != NULL) {
        pwnd->pStackTrace = pStackTrace;
    }
}
#endif // LAME_BUTTON

BOOL NtUserValidateTimerCallback(
    HWND hwnd,
    ULONG_PTR wParam,
    ULONG_PTR lParam)
{
    BEGINRECV_HWNDOPT_SHARED(BOOL, FALSE, hwnd);

    retval = ValidateTimerCallback(PtiCurrentShared(), pwnd, wParam, lParam);

    ENDRECV_HWNDOPT_SHARED();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\power.c ===
/****************************** Module Header ******************************\
* Module Name: power.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the code to implement power management.
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntcsrmsg.h>
#include "csrmsg.h"
#include "ntddvdeo.h"

#pragma alloc_text(INIT, InitializePowerRequestList)

BOOL IsSessionSwitchBlocked();
NTSTATUS UserSessionSwitchBlock_Start();
void UserSessionSwitchBlock_End();


extern BOOL gbUserInitialized;

#define SWITCHACTION_RESETMODE      0x1
#define SWITCHACTION_REENUMERATE    0x2

LIST_ENTRY gPowerRequestList;
PFAST_MUTEX gpPowerRequestMutex;
PKEVENT gpEventPowerRequest;
ULONG   gulDelayedSwitchAction = 0;

typedef struct tagPOWERREQUEST {
    LIST_ENTRY        PowerRequestLink;
    union {
        KEVENT            Event;
        WIN32_POWEREVENT_PARAMETERS CapturedParms;
    };
    NTSTATUS          Status;
    PKWIN32_POWEREVENT_PARAMETERS Parms;
} POWERREQUEST, *PPOWERREQUEST;

PPOWERREQUEST gpPowerRequestCurrent;

__inline VOID EnterPowerCrit() {
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpPowerRequestMutex);
}

__inline VOID LeavePowerCrit() {
    ExReleaseFastMutexUnsafe(gpPowerRequestMutex);
    KeLeaveCriticalRegion();
}

/***************************************************************************\
* CancelPowerRequest
*
* The power request can't be satisfied because the worker thread is gone.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/

VOID
CancelPowerRequest(
    PPOWERREQUEST pPowerRequest)
{
    UserAssert(pPowerRequest != gpPowerRequestCurrent);
    pPowerRequest->Status = STATUS_UNSUCCESSFUL;

    /*
     * If it was a callout, tell the waiting thread to proceed.
     * If it was an event, there is no waiting thread but we need to
     * free the pool
     */
    if (pPowerRequest->Parms) {
        UserFreePool(pPowerRequest);
    } else {
        KeSetEvent(&pPowerRequest->Event, EVENT_INCREMENT, FALSE);
    }
}

/***************************************************************************\
* QueuePowerRequest
*
* Insert a power request into the list and wakeup CSRSS to process it.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/

NTSTATUS
QueuePowerRequest(
    PKWIN32_POWEREVENT_PARAMETERS Parms)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPOWERREQUEST pPowerRequest;
    TL tlPool;

    UserAssert(gpEventPowerRequest != NULL);
    UserAssert(gpPowerRequestMutex != NULL);

    /*
     * Allocate and initialize the power request.
     */
    pPowerRequest = UserAllocPoolNonPagedNS(sizeof(POWERREQUEST), TAG_POWER);
    if (pPowerRequest == NULL) {
        return STATUS_NO_MEMORY;
    }

    /*
     * If this is a callout, there are no paramaters. Initialize the event to wait on.
     * If this is an event, capture the parameters to be freed after the event
     * is dispatched.
     */
    if (Parms) {
        pPowerRequest->CapturedParms = *Parms;
        pPowerRequest->Parms = &pPowerRequest->CapturedParms;
    } else {
        KeInitializeEvent(&pPowerRequest->Event, SynchronizationEvent, FALSE);
        pPowerRequest->Parms = NULL;
    }

    /*
     * Insert the power request into the list.
     */
    EnterPowerCrit();
    if (gbNoMorePowerCallouts) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        InsertHeadList(&gPowerRequestList, &pPowerRequest->PowerRequestLink);
    }
    LeavePowerCrit();

    /*
     * if this thread is gone through attach process, or
     * If this is a system thread or a non-GUI thread, tell CSRSS to do the
     * work and wait for it to finish. Otherwise, we'll do the work ourselves.
     */
    if (NT_SUCCESS(Status)) {
        if (PsIsSystemThread(PsGetCurrentThread()) ||
            KeIsAttachedProcess() ||
            W32GetCurrentThread() == NULL) {
            KeSetEvent(gpEventPowerRequest, EVENT_INCREMENT, FALSE);
        } else {
            EnterCrit();
            ThreadLockPool(PtiCurrent(), pPowerRequest, &tlPool);
            xxxUserPowerCalloutWorker();
            ThreadUnlockPool(PtiCurrent(), &tlPool);
            LeaveCrit();
        }

        /*
         * If this is a callout, wait for it and then free the request.
         * Otherwise, it is an event, and we do not need to wait for it
         * to complete. The request will be freed after it is dequeued.
         */
        if (Parms) {
            return(STATUS_SUCCESS);
        } else {
            Status = KeWaitForSingleObject(&pPowerRequest->Event,
                                           WrUserRequest,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            if (NT_SUCCESS(Status)) {
                Status = pPowerRequest->Status;
            }
        }
    }

    /*
     * Free the power request.
     */
    UserAssert(pPowerRequest != gpPowerRequestCurrent);
    UserFreePool(pPowerRequest);

    return Status;
}

/***************************************************************************\
* UnqueuePowerRequest
*
* Remove a power request from the list.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/

PPOWERREQUEST
UnqueuePowerRequest(VOID)
{
    PLIST_ENTRY pEntry;
    PPOWERREQUEST pPowerRequest = NULL;

    /*
     * Remove a power request from the list.
     */
    EnterPowerCrit();
    if (!IsListEmpty(&gPowerRequestList)) {
        pEntry = RemoveTailList(&gPowerRequestList);
        pPowerRequest = CONTAINING_RECORD(pEntry, POWERREQUEST, PowerRequestLink);
    }
    LeavePowerCrit();

    return pPowerRequest;
}

/***************************************************************************\
* InitializePowerRequestList
*
* Initialize global power request list state.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/

NTSTATUS
InitializePowerRequestList(
    HANDLE hPowerRequestEvent)
{
    NTSTATUS Status;

    InitializeListHead(&gPowerRequestList);

    Status = ObReferenceObjectByHandle(hPowerRequestEvent,
                                       EVENT_ALL_ACCESS,
                                       *ExEventObjectType,
                                       KernelMode,
                                       &gpEventPowerRequest,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    gpPowerRequestMutex = UserAllocPoolNonPaged(sizeof(FAST_MUTEX), TAG_POWER);
    if (gpPowerRequestMutex == NULL) {
        return STATUS_NO_MEMORY;
    }
    ExInitializeFastMutex(gpPowerRequestMutex);

    return STATUS_SUCCESS;
}

/***************************************************************************\
* CleanupPowerRequestList
*
* Cancel any pending power requests.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/

VOID
CleanupPowerRequestList(VOID)
{
    PPOWERREQUEST pPowerRequest;

    /*
     * Make sure no new power requests come in.
     */
    gbNoMorePowerCallouts = TRUE;

    /*
     * If we never allocated anything, there's nothing to clean up.
     */
    if (gpPowerRequestMutex == NULL) {
        return;
    }

    /*
     * Mark any pending power requests as cacelled.
     */
    while ((pPowerRequest = UnqueuePowerRequest()) != NULL) {
        CancelPowerRequest(pPowerRequest);
    }
}

/***************************************************************************\
* DeletePowerRequestList
*
* Clean up any global power request state.
*
* History:
* 20-Oct-1998 JerrySh   Created.
\***************************************************************************/

VOID
DeletePowerRequestList(VOID)
{
    if (gpPowerRequestMutex) {

        /*
         * Make sure there are no pending power requests.
         */
        UserAssert(IsListEmpty(&gPowerRequestList));

        /*
         * Free the power request structures.
         */
        UserFreePool(gpPowerRequestMutex);
        gpPowerRequestMutex = NULL;
    }
}

/***************************************************************************\
* UserPowerEventCalloutWorker
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/

NTSTATUS xxxUserPowerEventCalloutWorker(
    PKWIN32_POWEREVENT_PARAMETERS Parms)
{
    BROADCASTSYSTEMMSGPARAMS bsmParams;
    NTSTATUS Status = STATUS_SUCCESS;
    PSPOWEREVENTTYPE EventNumber = Parms->EventNumber;
    ULONG_PTR Code = Parms->Code;
    BOOL bCurrentPowerOn;
    ULONGLONG ullLastSleepTime;
    BOOL bGotLastSleepTime;


    /*
     * Make sure CSRSS is still running.
     */
    if (gbNoMorePowerCallouts) {
        return STATUS_UNSUCCESSFUL;
    }

    switch (EventNumber) {
    case PsW32FullWake:

        if (!gbRemoteSession) {
            /*
             * Let all the services know that they can resume operation.
             * There is no corresponding POWER_ACTION for this, but since this
             * is a non-query event, PowerActionNone is as good as any.
             */
            LeaveCrit();
            IoPnPDeliverServicePowerNotification(PowerActionNone,
                                                 PBT_APMRESUMESUSPEND,
                                                 0,
                                                 FALSE);
            EnterCrit();
        }

        /*
         * Let all the applications know that they can resume operation.
         * We must not send this message to a session, if it was created after machine went into sleep
         */

        /*
         *   One of the side effects of NtPowerInformation is that it will
         *   dispatch pending power events. So we can not call it with the user critsec held
         *   Note: same thing is done for IoPnPDeliverServicePowerNotification.
         */
        LeaveCrit();
        bGotLastSleepTime = ZwPowerInformation(LastSleepTime, NULL, 0, &ullLastSleepTime, sizeof(ULONGLONG)) == STATUS_SUCCESS;
        EnterCrit();

        if ( !bGotLastSleepTime || gSessionCreationTime < ullLastSleepTime)
        {

            bsmParams.dwRecipients = BSM_ALLDESKTOPS;
            bsmParams.dwFlags = BSF_QUEUENOTIFYMESSAGE;
            xxxSendMessageBSM(NULL,
                              WM_POWERBROADCAST,
                              PBT_APMRESUMESUSPEND,
                              0,
                              &bsmParams);

        }
        break;

    case PsW32EventCode:
        /*
         * Post a message to winlogon, and let them put up a message box
         * or play a sound.
         */

        if (gspwndLogonNotify) {
            glinp.ptiLastWoken = GETPTI(gspwndLogonNotify);
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, LOGON_POWEREVENT, (ULONG)Code);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        break;

    case PsW32PowerPolicyChanged:
        /*
         * Set video timeout value.
         */
        xxxSystemParametersInfo(SPI_SETLOWPOWERTIMEOUT, (ULONG)Code, 0, 0);
        xxxSystemParametersInfo(SPI_SETPOWEROFFTIMEOUT, (ULONG)Code, 0, 0);
        break;

    case PsW32SystemPowerState:

        if (!gbRemoteSession) {
            /*
             * Let all the services know that the power status has changed.
             * There is no corresponding POWER_ACTION for this, but since this
             * is a non-query event, PowerActionNone is as good as any.
             */
            LeaveCrit();
            IoPnPDeliverServicePowerNotification(PowerActionNone,
                                                 PBT_APMPOWERSTATUSCHANGE,
                                                 0,
                                                 FALSE);
            EnterCrit();
        }

        /*
         * Let all the applications know that the power status has changed.
         */
        bsmParams.dwRecipients = BSM_ALLDESKTOPS;
        bsmParams.dwFlags = BSF_POSTMESSAGE;
        xxxSendMessageBSM(NULL,
                          WM_POWERBROADCAST,
                          PBT_APMPOWERSTATUSCHANGE,
                          0,
                          &bsmParams);
        break;

    case PsW32SystemTime:
        /*
         * Let all the applications know that the system time has changed.
         */
        bsmParams.dwRecipients = BSM_ALLDESKTOPS;
        bsmParams.dwFlags = BSF_POSTMESSAGE;
        xxxSendMessageBSM(NULL,
                          WM_TIMECHANGE,
                          0,
                          0,
                          &bsmParams);
        break;

    case PsW32DisplayState:
        /*
         * Set video timeout active status.
         */
        xxxSystemParametersInfo(SPI_SETLOWPOWERACTIVE, !Code, 0, 0);
        xxxSystemParametersInfo(SPI_SETPOWEROFFACTIVE, !Code, 0, 0);
        break;

    case PsW32GdiOff:
        /*
         * At this point we will disable the display device, if no protocol switch is in progress.
         */
        if (!gfSwitchInProgress) {
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3);

            bCurrentPowerOn = DrvQueryMDEVPowerState(gpDispInfo->pmdev);
            if (bCurrentPowerOn) {
                SafeDisableMDEV();
            }
            DrvSetMDEVPowerState(gpDispInfo->pmdev, FALSE);
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        break;

    case PsW32GdiOn:
        /*
         * Call video driver to turn the display back on, if no protocol switch is in progress.
         */

        if (!gfSwitchInProgress) {
            bCurrentPowerOn = DrvQueryMDEVPowerState(gpDispInfo->pmdev);
            if (!bCurrentPowerOn) {
                SafeEnableMDEV();
            }
            DrvSetMDEVPowerState(gpDispInfo->pmdev, TRUE);
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);

        } else {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
        /*
         * Repaint the whole screen
         */
        xxxUserResetDisplayDevice();

        if (gulDelayedSwitchAction)
        {
            HANDLE pdo;

            //
            // The first ACPI device is the one respond to hotkey.
            //
            PVOID PhysDisp = DrvWakeupHandler(&pdo);

            if (PhysDisp &&
                (gulDelayedSwitchAction & SWITCHACTION_RESETMODE))
            {
                UNICODE_STRING   strDeviceName;
                DEVMODEW         NewMode;
                ULONG            bPrune;

                if (DrvDisplaySwitchHandler(PhysDisp, &strDeviceName, &NewMode, &bPrune))
                {
                    /*
                     * CSRSS is not the only process to diliver power callout
                     */
                    if (!ISCSRSS()) {
                        xxxUserChangeDisplaySettings(NULL, NULL, NULL, grpdeskRitInput,
                                 ((bPrune) ? 0 : CDS_RAWMODE) | CDS_TRYCLOSEST | CDS_RESET, 0, KernelMode);
                    }
                    else
                    {
                        DESKRESTOREDATA drdRestore;

                        drdRestore.pdeskRestore = NULL;
                        if (NT_SUCCESS (xxxSetCsrssThreadDesktop(grpdeskRitInput, &drdRestore)) )
                        {
                            xxxUserChangeDisplaySettings(NULL, NULL, NULL, NULL,
                                     ((bPrune) ? 0 : CDS_RAWMODE) | CDS_TRYCLOSEST | CDS_RESET, 0, KernelMode);
                            xxxRestoreCsrssThreadDesktop(&drdRestore);
                        }
                    }
                }

                //
                // If there is a requirement to reenumerate sub-devices
                //
                if (pdo &&
                    (gulDelayedSwitchAction & SWITCHACTION_REENUMERATE))
                {
                    IoInvalidateDeviceRelations((PDEVICE_OBJECT)pdo, BusRelations);
                }
            }
        }
        gulDelayedSwitchAction = 0;

        break;

    default:
        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    return Status;
}

/***************************************************************************\
* UserPowerEventCallout
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/

NTSTATUS UserPowerEventCallout(
    PKWIN32_POWEREVENT_PARAMETERS Parms)
{

    /*
     * Make sure CSRSS is running.
     */
    if (!gbVideoInitialized || gbNoMorePowerCallouts) {
        return STATUS_UNSUCCESSFUL;
    }

    UserAssert(gpepCSRSS != NULL);

    /*
     * Process the power request.
     */
    return QueuePowerRequest(Parms);
}

/***************************************************************************\
* UserPowerStateCalloutWorker
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/

NTSTATUS xxxUserPowerStateCalloutWorker(VOID)
{
    BOOL fContinue;
    BROADCASTSYSTEMMSGPARAMS bsmParams;
    POWER_ACTION powerOperation;
    NTSTATUS Status = STATUS_SUCCESS;
    TL tlpwnd;
    POWERSTATETASK Task = gPowerState.PowerStateTask;
    ULONGLONG ullLastSleepTime;
    BOOL bGotLastSleepTime;

    /*
     * by now we must have alrady blocked session switch, 
     *  its blocked only for win32k belonging to active console session.
     */
    UserAssert(SharedUserData->ActiveConsoleId != gSessionId || IsSessionSwitchBlocked());


    /*
     * Make sure CSRSS is still running.
     */
    if (gbNoMorePowerCallouts) {
        return STATUS_UNSUCCESSFUL;
    }


    switch (Task) {

    case PowerState_Init:

        /*
         * Store the event so this thread can be promoted later.
         */

        EnterPowerCrit();
        gPowerState.pEvent = PtiCurrent()->pEventQueueServer;
        LeavePowerCrit();

        break;


    case PowerState_QueryApps:

        if (!gPowerState.fCritical) {
            /*
             * Ask the applications if we can suspend operation.
             */
            if (gPowerState.fQueryAllowed) {

                gPowerState.bsmParams.dwRecipients = BSM_ALLDESKTOPS;
                gPowerState.bsmParams.dwFlags = BSF_NOHANG | BSF_FORCEIFHUNG;
                if (gPowerState.fUIAllowed) {

                    gPowerState.bsmParams.dwFlags |= BSF_ALLOWSFW;
                }

                if (gPowerState.fOverrideApps == FALSE) {

                    gPowerState.bsmParams.dwFlags |= (BSF_QUERY | BSF_NOTIMEOUTIFNOTHUNG);
                }

                fContinue = xxxSendMessageBSM(NULL,
                                              WM_POWERBROADCAST,
                                              PBT_APMQUERYSUSPEND,
                                              gPowerState.fUIAllowed,
                                              &gPowerState.bsmParams);


                if (fContinue && !gbRemoteSession) {
                    /*
                     * Ask the services if we can suspend operation.
                     * Map the power action event as needed.
                     */
                    if (gPowerState.psParams.MinSystemState == PowerSystemHibernate) {
                        powerOperation = PowerActionHibernate;
                    } else {
                        powerOperation = gPowerState.psParams.SystemAction;
                    }

                    LeaveCrit();
                    fContinue = IoPnPDeliverServicePowerNotification(
                        powerOperation,
                        PBT_APMQUERYSUSPEND,
                        gPowerState.fUIAllowed,
                        TRUE); // synchronous query
                    EnterCrit();
                }

                /*
                 * If an app or service says to abort and we're not in override apps or
                 * critical mode, return query failed.
                 */

                if (!(fContinue || gPowerState.fOverrideApps || gPowerState.fCritical)) {
                    Status = STATUS_CANCELLED;
                }
            }

        }

        break;

    case PowerState_QueryFailed:

        /*
         * Only send a suspend failed message to the applications, since pnp
         * will already have delivered the suspend failed message to services if
         * one of those aborted the query.
         */
        gPowerState.bsmParams.dwRecipients = BSM_ALLDESKTOPS;
        gPowerState.bsmParams.dwFlags = BSF_QUEUENOTIFYMESSAGE;
        xxxSendMessageBSM(NULL,
                          WM_POWERBROADCAST,
                          PBT_APMQUERYSUSPENDFAILED,
                          0,
                          &gPowerState.bsmParams);
        EnterPowerCrit();
        gPowerState.pEvent = NULL;
        gPowerState.fInProgress = FALSE;
        LeavePowerCrit();


        break;

    case PowerState_SuspendApps:

        if (!gPowerState.fCritical) {

            if (!gbRemoteSession) {
                /*
                 * Map the power action event as needed.
                 */
                if (gPowerState.psParams.MinSystemState == PowerSystemHibernate) {
                    powerOperation = PowerActionHibernate;
                } else {
                    powerOperation = gPowerState.psParams.SystemAction;
                }

                LeaveCrit();
                IoPnPDeliverServicePowerNotification(powerOperation,
                                                     PBT_APMSUSPEND,
                                                     0,
                                                     FALSE);
                EnterCrit();
            }

            gPowerState.bsmParams.dwRecipients = BSM_ALLDESKTOPS;
            gPowerState.bsmParams.dwFlags = BSF_NOHANG | BSF_FORCEIFHUNG;
            xxxSendMessageBSM(NULL,
                              WM_POWERBROADCAST,
                              PBT_APMSUSPEND,
                              0,
                              &gPowerState.bsmParams);
        }

        /*
         * Clear the event so the thread won't wake up prematurely.
         */
        EnterPowerCrit();
        gPowerState.pEvent = NULL;
        LeavePowerCrit();

        break;

    case PowerState_ShowUI:

        /*
        * if this is not session 0 show ui for sessions.
        * we shall take this ui off when we resume apps
        * For session 0 we call PowerState_NotifyWL which takes care of it.
        */

        if ((gSessionId != 0 ) && (gspwndLogonNotify != NULL)) {

            ThreadLockAlways(gspwndLogonNotify, &tlpwnd);

            Status = (NTSTATUS)xxxSendMessage(gspwndLogonNotify,
                                              WM_LOGONNOTIFY,
                                              LOGON_SHOW_POWER_MESSAGE,
                                              (LPARAM)&gPowerState.psParams);
            ThreadUnlock(&tlpwnd);


        }

        break;


    case PowerState_NotifyWL:

        if (gspwndLogonNotify != NULL) {

            PWND pwndActive;

            if (gpqForeground && (pwndActive = gpqForeground->spwndActive) &&
                    (GetFullScreen(pwndActive) == FULLSCREEN ||
                     GetFullScreen(pwndActive) == FULLSCREENMIN)) {
                gPowerState.psParams.FullScreenMode = TRUE;
            } else {
                gPowerState.psParams.FullScreenMode = FALSE;
            }
            ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
            Status = (NTSTATUS)xxxSendMessage(gspwndLogonNotify,
                                              WM_LOGONNOTIFY,
                                              LOGON_POWERSTATE,
                                              (LPARAM)&gPowerState.psParams);

            ThreadUnlock(&tlpwnd);

            if (!NT_SUCCESS(Status)) {
                /*
                 * if we failed to to this power operation, dont lock the console.
                 */
                gPowerState.psParams.Flags &= ~POWER_ACTION_LOCK_CONSOLE;
            }



        }

        break;

    case PowerState_ResumeApps:



        /*
         * if this is active console we need to lock it.
         */


        if ((gPowerState.psParams.Flags & POWER_ACTION_LOCK_CONSOLE) &&
            (gSessionId == SharedUserData->ActiveConsoleId) &&
            (gspwndLogonNotify != NULL)) {

            ThreadLockAlways(gspwndLogonNotify, &tlpwnd);

            _PostMessage(gspwndLogonNotify,
                        WM_LOGONNOTIFY,
                        LOGON_LOCKWORKSTATION,
                        LOCK_RESUMEHIBERNATE);

            ThreadUnlock(&tlpwnd);

        }



        //
        // we dont need to remove power message, if we did not post one.
        //

        /*
         *   One of the side effects of NtPowerInformation is that it will
         *   dispatch pending power events. So we can not call it with the user critsec held
         *   Note: same thing is done for IoPnPDeliverServicePowerNotification.
         */

        LeaveCrit();
        bGotLastSleepTime = ZwPowerInformation(LastSleepTime, NULL, 0, &ullLastSleepTime, sizeof(ULONGLONG)) == STATUS_SUCCESS;
        EnterCrit();

        if ( !bGotLastSleepTime || gSessionCreationTime < ullLastSleepTime)
        {
            if ((gSessionId != 0 ) && (gspwndLogonNotify != NULL)) {

                ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
                Status = (NTSTATUS)xxxSendMessage(gspwndLogonNotify,
                                                  WM_LOGONNOTIFY,
                                                  LOGON_REMOVE_POWER_MESSAGE,
                                                  (LPARAM)&gPowerState.psParams);

                ThreadUnlock(&tlpwnd);

            }

        }



        /*
         * The power state broadcast is over.
         */
        EnterPowerCrit();
        gPowerState.fInProgress = FALSE;
        LeavePowerCrit();


        /*
         * Tickle the input time so we don't fire up a screen saver right away.
         */
        glinp.timeLastInputMessage = NtGetTickCount();

        if (!gbRemoteSession) {
            /*
             * Re-init the keyboard state.
             */
            InitKeyboardState();

            /*
             * Let all the services know that we're waking up.
             * There is no corresponding POWER_ACTION for this, but since this
             * is a non-query event, PowerActionNone is as good as any.
             */
            LeaveCrit();
            IoPnPDeliverServicePowerNotification(PowerActionNone,
                                                 PBT_APMRESUMEAUTOMATIC,
                                                 0,
                                                 FALSE);
            EnterCrit();
        }

        /*
         * Let all the applications know that we're waking up.
         */
        bsmParams.dwRecipients = BSM_ALLDESKTOPS;
        bsmParams.dwFlags = BSF_QUEUENOTIFYMESSAGE;
        xxxSendMessageBSM(NULL,
                          WM_POWERBROADCAST,
                          PBT_APMRESUMEAUTOMATIC,
                          0,
                          &bsmParams);


        break;

    default:
        ASSERT(FALSE);


    }

    return Status;


}

/***************************************************************************\
* UserPowerStateCallout
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/

NTSTATUS UserPowerStateCallout(
    PKWIN32_POWERSTATE_PARAMETERS Parms)
{
    POWERSTATETASK Task = Parms->PowerStateTask;
    BOOLEAN Promotion = Parms->Promotion;
    POWER_ACTION SystemAction = Parms->SystemAction;
    SYSTEM_POWER_STATE MinSystemState = Parms->MinSystemState;
    ULONG Flags = Parms->Flags;
    NTSTATUS status;

    if (Task == PowerState_BlockSessionSwitch)
    {
        /*
         * dont allow active console session switch while we are in power callouts.
         * first try block the session switch
         */
        return UserSessionSwitchBlock_Start();
    }

    if (Task == PowerState_UnBlockSessionSwitch)
    {
        UserAssert(IsSessionSwitchBlocked());
        UserSessionSwitchBlock_End();
        return STATUS_SUCCESS;
    }

    /*
     * Make sure CSRSS is running.
     */
    if (!gbVideoInitialized || gbNoMorePowerCallouts || !gspwndLogonNotify) {
        return STATUS_UNSUCCESSFUL;
    }

    UserAssert(gpepCSRSS != NULL);



/*
    we can optimize here, by checking if the previous session has already
    denied the query request, but need to make sure if its ok to send QUERYFAILED message
    without sending query message.

    // some other session has already denied the query, dont ask this session apps.
    if (Parms->ulStep == POWERSTATE_QUERY_APPS && Parms->fQueryDenied) {
        return STATUS_CANCELLED;
    }
*/


    EnterPowerCrit();

    if (Task == PowerState_Init) {

        /*
         * Make sure we're not trying to promote a non-existent request
         * or start a new one when we're already doing it.
         */
        if ((Promotion && !gPowerState.fInProgress) ||
            (!Promotion && gPowerState.fInProgress)) {
            LeavePowerCrit();

            return STATUS_INVALID_PARAMETER;
        }

        /*
         * Save our state.
         */
        gPowerState.fInProgress = TRUE;
        gPowerState.fOverrideApps = (Flags & POWER_ACTION_OVERRIDE_APPS) != 0;
        gPowerState.fCritical = (Flags & POWER_ACTION_CRITICAL) != 0;
        gPowerState.fQueryAllowed = (Flags & POWER_ACTION_QUERY_ALLOWED) != 0;
        gPowerState.fUIAllowed = (Flags & POWER_ACTION_UI_ALLOWED) != 0;
        gPowerState.psParams.SystemAction = SystemAction;
        gPowerState.psParams.MinSystemState = MinSystemState;
        gPowerState.psParams.Flags = Flags;
        if (gPowerState.fOverrideApps) {
            gPowerState.bsmParams.dwFlags = BSF_NOHANG | BSF_FORCEIFHUNG;
        }
        if (gPowerState.fCritical) {
            gPowerState.bsmParams.dwFlags = BSF_NOHANG | BSF_QUERY;
        }
        if (gPowerState.pEvent) {
            KeSetEvent(gPowerState.pEvent, EVENT_INCREMENT, FALSE);
        }

    }

    gPowerState.PowerStateTask = Task;

    LeavePowerCrit();

    /*
     * If this is a promotion, we're done.
     */
    if (Promotion) {
        return STATUS_SUCCESS;
    }


    /*
     * Process the power request.
     */
    status = QueuePowerRequest(NULL);

    if (Task == PowerState_QueryApps && !NT_SUCCESS(status)) {
        /*
        * Query was refused.
        */
        Parms->fQueryDenied = TRUE;
    }

    return status;
}

/***************************************************************************\
* UserPowerCalloutWorker
*
* Pull any pending power requests off the list and call the appropriate
* power callout function.
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/

VOID
xxxUserPowerCalloutWorker(VOID)
{
    PPOWERREQUEST pPowerRequest;
    TL tlPool;

    while ((pPowerRequest = UnqueuePowerRequest()) != NULL) {
        /*
         * Make sure the event gets signalled even if the thread dies in a
         * callback or the waiting thread might get stuck.
         */
        ThreadLockPoolCleanup(PtiCurrent(), pPowerRequest, &tlPool, CancelPowerRequest);

        /*
         * Call the appropriate power worker function.
         */
        gpPowerRequestCurrent = pPowerRequest;
        if (pPowerRequest->Parms) {
            pPowerRequest->Status = xxxUserPowerEventCalloutWorker(pPowerRequest->Parms);
        } else {
            pPowerRequest->Status = xxxUserPowerStateCalloutWorker();
        }
        gpPowerRequestCurrent = NULL;

        /*
         * If it was a callout, tell the waiting thread to proceed.
         * If it was an event, there is no waiting thread but we need to
         * free the pool
         */
        ThreadUnlockPoolCleanup(PtiCurrent(), &tlPool);
        if (pPowerRequest->Parms) {
            UserFreePool(pPowerRequest);
        } else {
            KeSetEvent(&pPowerRequest->Event, EVENT_INCREMENT, FALSE);
        }
    }
}


/***************************************************************************\
* VideoPortCalloutThread
*
* Call the appropriate power callout function and return.
*
* History:
* 02-Dec-1996 JerrySh   Created.
\***************************************************************************/

VOID
VideoPortCalloutThread(
    PPOWER_INIT pInitData
    )
{
    NTSTATUS Status;
    PVIDEO_WIN32K_CALLBACKS_PARAMS Params = pInitData->Params;

    Params->Status = InitSystemThread(NULL);

    if (!NT_SUCCESS(Params->Status)) {
        goto RetThreadCallOut;
    }

    // DbgPrint("video --- Before CritSect\n");

    while (1) {
        EnterCrit();
        if (!gfSwitchInProgress) {
            break;
        }else {
            LeaveCrit();
            Status = KeWaitForSingleObject(gpevtVideoportCallout, WrUserRequest, KernelMode, FALSE, NULL);
        }
    }
    if (IsRemoteConnection()) {
        LeaveCrit();
        return;
    }

    // DbgPrint("video --- After CritSect\n");


    switch (Params->CalloutType) {

    case VideoWakeupCallout:
        gulDelayedSwitchAction |= SWITCHACTION_RESETMODE;

        break;

    case VideoDisplaySwitchCallout:
        {
            UNICODE_STRING   strDeviceName;
            DEVMODEW         NewMode;
            ULONG            bPrune;


            Params->Status = STATUS_SUCCESS;

            if (!DrvQueryMDEVPowerState(gpDispInfo->pmdev))
            {
                gulDelayedSwitchAction |= ((Params->PhysDisp != NULL) ? SWITCHACTION_RESETMODE : 0) |
                                          ((Params->Param) ? SWITCHACTION_REENUMERATE : 0);
                break;
            }

            gulDelayedSwitchAction = 0;
            if (Params->PhysDisp != NULL)
            {
                if (DrvDisplaySwitchHandler(Params->PhysDisp, &strDeviceName, &NewMode, &bPrune))
                {
                    DESKRESTOREDATA drdRestore;

                    drdRestore.pdeskRestore = NULL;

                    /*
                     * CSRSS is not the only process to diliver power callout
                     */

                    if (!ISCSRSS() ||
                        NT_SUCCESS (xxxSetCsrssThreadDesktop(grpdeskRitInput, &drdRestore)) )
                    {
                        xxxUserChangeDisplaySettings(NULL, NULL, NULL, grpdeskRitInput,
                                 ((bPrune) ? 0 : CDS_RAWMODE) | CDS_TRYCLOSEST | CDS_RESET, 0, KernelMode);

                        if (ISCSRSS())
                        {
                            xxxRestoreCsrssThreadDesktop(&drdRestore);
                        }
                    }
                }
            }
        }

        //
        // If there is a requirement to reenumerate sub-devices
        //
        if (Params->Param)
        {
            IoInvalidateDeviceRelations((PDEVICE_OBJECT)Params->Param, BusRelations);
        }

        break;

    case VideoChangeDisplaySettingsCallout:
        {
            DEVMODEW Devmode;
            DESKRESTOREDATA drdRestore;

            memset(&Devmode, 0, sizeof(DEVMODEW));
            Devmode.dmSize = sizeof(DEVMODEW);
            Devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
            Devmode.dmBitsPerPel = 4;
            Devmode.dmPelsWidth = 640;
            Devmode.dmPelsHeight = 480;

            drdRestore.pdeskRestore = NULL;

            /*
             * CSRSS is not the only process to deliver power callouts.
             */
            if (!ISCSRSS() ||
                NT_SUCCESS(xxxSetCsrssThreadDesktop(grpdeskRitInput, &drdRestore))) {
		xxxUserChangeDisplaySettings(NULL, &Devmode, NULL, grpdeskRitInput, CDS_RESET, NULL, KernelMode);

                if (ISCSRSS()) {
                    xxxRestoreCsrssThreadDesktop(&drdRestore);
                }
            }
        }
        break;

    case VideoFindAdapterCallout:

        if (Params->Param) {

            SafeEnableMDEV();
            xxxUserResetDisplayDevice();

        } else {

            SafeDisableMDEV();
        }

        Params->Status = STATUS_SUCCESS;
        break;

    default:

        UserAssert(FALSE);

        Params->Status = STATUS_UNSUCCESSFUL;

    }


    // DbgPrint("video --- Before Leave CritSect\n");
    LeaveCrit();
    // DbgPrint("video --- After Leave CritSect\n");

RetThreadCallOut:
    /*
     * Signal that the Callout has been ended.
     */
    KeSetEvent(pInitData->pPowerReadyEvent, EVENT_INCREMENT, FALSE);
    return;
}


/***************************************************************************\
* VideoPortCallout
*
* History:
* 26-Jul-1998 AndreVa   Created.
\***************************************************************************/

VOID
VideoPortCallout(
    IN PVOID Params
    )
{

    /*
     * To make sure this is a system thread, we create a new thread.
     */

    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    BOOL     fRet;
    USER_API_MSG m;
    POWER_INIT initData;


    //
    // Make sure Video had been initialized
    //
    if (!gbVideoInitialized)
    {
        ((PVIDEO_WIN32K_CALLBACKS_PARAMS)(Params))->Status = STATUS_UNSUCCESSFUL;
        return;
    }

    //
    // Make sure the CsrApiPort has been initialized
    //

    if (!CsrApiPort) {
	((PVIDEO_WIN32K_CALLBACKS_PARAMS)(Params))->Status = STATUS_INVALID_HANDLE;
        return;
    }

    // DbgPrint("Callout --- Enter !!!\n");

    initData.Params = Params;
    initData.pPowerReadyEvent = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (initData.pPowerReadyEvent == NULL) {
        goto RetCallOut;
    }

    UserAssert (ISCSRSS());

    EnterCrit();
    fRet = InitCreateSystemThreadsMsg(&m, CST_POWER, &initData, 0, FALSE);
    LeaveCrit();

    if (fRet) {
        Status = LpcRequestPort(CsrApiPort, (PPORT_MESSAGE)&m);

        if (NT_SUCCESS(Status)) {
            KeWaitForSingleObject(initData.pPowerReadyEvent, WrUserRequest,
                    KernelMode, FALSE, NULL);
            Status = ((PVIDEO_WIN32K_CALLBACKS_PARAMS)(Params))->Status;
        }
    }

RetCallOut:

    if (initData.pPowerReadyEvent) {
        FreeKernelEvent(&initData.pPowerReadyEvent);
    }

    // DbgPrint("Callout --- Leave !!!\n");

    ((PVIDEO_WIN32K_CALLBACKS_PARAMS)(Params))->Status = Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\precomp.h ===
/*
 * Core NT headers
 */
#define NOWINBASEINTERLOCK
#include <ntosp.h>



#include <zwapi.h>
//#include <ntdbg.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddstor.h>
#include <wdmguid.h>
#include <ntcsrmsg.h>
#include <wmistr.h>
#include <wmidata.h>


/*
 * Standard C runtime headers
 */
#include <limits.h>
#include <stddef.h>
#include <stdio.h>


/*
 * Win32 headers
 */
#include <windef.h>
#include <wingdi.h>
#include <w32gdip.h>
#include <winerror.h>
#include <ntgdistr.h>
#include <winddi.h>
#include <w32p.h>
#include <w32err.h>
#include <gre.h>
#include <usergdi.h>
#include <ddeml.h>
#include <ddemlp.h>
#include <winuserk.h>
#include <dde.h>
#include <ddetrack.h>


/*
 * Far East specific headers
 */
#ifdef FE_IME
#include <immstruc.h>
#endif

/*
 * NtUser global headers
 */

#include <mountmgr.h>
#include <ioevent.h>

/*
 * NtUser Kernel specific headers
 */
#include <kbd.h>
#include "userk.h"
#include "access.h"
#include <conapi.h>

#include "winstaw.h"
#include <icadd.h>
#include <regapi.h>
#include <winddits.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\profile.c ===
/****************************** Module Header ******************************\
* Module Name: profile.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code to emulate ini file mapping.
*
* History:
* 30-Nov-1993 SanfordS  Created.
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* aFastRegMap[]
*
* This array maps section ids (PMAP_) to cached registry keys and section
* addresses within the registry.  IF INI FILE MAPPING CHANGES ARE MADE,
* THIS TABLE MUST BE UPDATED.
*
* The first character of the szSection field indicates what root the
* section is in. (or locked open status)
*      M = LocalMachine
*      U = CurrentUser
*      L = Locked open - used only on M mappings.
*
* History:
\***************************************************************************/
#define PROOT_CPANEL     0
#define PROOT_ACCESS     1
#define PROOT_CURRENTM   2
#define PROOT_CURRENTU   3
#define PROOT_CONTROL    4
#define PROOT_SERVICES   5
#define PROOT_KEYBOARD   6
#define PROOT_SYSTEM     7

typedef struct tagFASTREGMAP {
    UINT idRoot;
    PCWSTR szSection;
} FASTREGMAP, *PFASTREGMAP;

CONST PCWSTR aFastRegRoot[] = {
    L"UControl Panel\\",                                    // PROOT_CPANEL
    L"UControl Panel\\Accessibility\\",                     // PROOT_ACCESS
    L"MSoftware\\Microsoft\\Windows NT\\CurrentVersion\\",  // PROOT_CURRENTM
    L"USoftware\\Microsoft\\Windows NT\\CurrentVersion\\",  // PROOT_CURRENTU
    L"MSystem\\CurrentControlSet\\Control\\",               // PROOT_CONTROL
    L"MSystem\\CurrentControlSet\\Services\\",              // PROOT_SERVICES
    L"UKeyboard Layout\\",                                  // PROOT_KEYBOARD
    L"MSystem\\",                                           // PROOT_SYSTEM   
};

CONST FASTREGMAP aFastRegMap[PMAP_LAST + 1] = {
    { PROOT_CPANEL,   L"Colors" },                            // PMAP_COLORS
    { PROOT_CPANEL,   L"Cursors" },                           // PMAP_CURSORS
    { PROOT_CURRENTM, L"Windows" },                           // PMAP_WINDOWSM
    { PROOT_CURRENTU, L"Windows" },                           // PMAP_WINDOWSU
    { PROOT_CPANEL,   L"Desktop" },                           // PMAP_DESKTOP
    { PROOT_CPANEL,   L"Icons" },                             // PMAP_ICONS
    { PROOT_CURRENTM, L"Fonts" },                             // PMAP_FONTS
    { PROOT_CURRENTU, L"TrueType" },                          // PMAP_TRUETYPE
    { PROOT_CONTROL,  L"Keyboard Layout" },                   // PMAP_KBDLAYOUT
    { PROOT_SERVICES, L"RIT" },                               // PMAP_INPUT
    { PROOT_CURRENTM, L"Compatibility" },                     // PMAP_COMPAT
    { PROOT_CONTROL,  L"Session Manager\\SubSystems" },       // PMAP_SUBSYSTEMS
    { PROOT_CPANEL,   L"Sound" },                             // PMAP_BEEP
    { PROOT_CPANEL,   L"Mouse" },                             // PMAP_MOUSE
    { PROOT_CPANEL,   L"Keyboard" },                          // PMAP_KEYBOARD
    { PROOT_ACCESS,   L"StickyKeys" },                        // PMAP_STICKYKEYS
    { PROOT_ACCESS,   L"Keyboard Response" },                 // PMAP_KEYBOARDRESPONSE
    { PROOT_ACCESS,   L"MouseKeys" },                         // PMAP_MOUSEKEYS
    { PROOT_ACCESS,   L"ToggleKeys" },                        // PMAP_TOGGLEKEYS
    { PROOT_ACCESS,   L"TimeOut" },                           // PMAP_TIMEOUT
    { PROOT_ACCESS,   L"SoundSentry" },                       // PMAP_SOUNDSENTRY
    { PROOT_ACCESS,   L"ShowSounds" },                        // PMAP_SHOWSOUNDS
    { PROOT_CURRENTM, L"AeDebug" },                           // PMAP_AEDEBUG
    { PROOT_CONTROL,  L"NetworkProvider" },                   // PMAP_NETWORK
    { PROOT_CPANEL,   L"Desktop\\WindowMetrics" },            // PMAP_METRICS
    { PROOT_KEYBOARD, L"" },                                  // PMAP_UKBDLAYOUT
    { PROOT_KEYBOARD, L"Toggle" },                            // PMAP_UKBDLAYOUTTOGGLE
    { PROOT_CURRENTM, L"Winlogon" },                          // PMAP_WINLOGON
    { PROOT_ACCESS,   L"Keyboard Preference" },               // PMAP_KEYBOARDPREF
    { PROOT_ACCESS,   L"Blind Access" },                      // PMAP_SCREENREADER
    { PROOT_ACCESS,   L"HighContrast" },                      // PMAP_HIGHCONTRAST
    { PROOT_CURRENTM, L"IME Compatibility" },                 // PMAP_IMECOMPAT
    { PROOT_CURRENTM, L"IMM" },                               // PMAP_IMM
    { PROOT_CONTROL,  L"Session Manager\\SubSystems\\Pool" }, // PMAP_POOLLIMITS
    { PROOT_CURRENTM, L"Compatibility32" },                   // PMAP_COMPAT32
    { PROOT_CURRENTM, L"WOW\\SetupPrograms" },                // PMAP_SETUPPROGRAMNAMES
    { PROOT_CPANEL,   L"Input Method" },                      // PMAP_INPUTMETHOD
    { PROOT_CURRENTM, L"Compatibility2" },                    // PMAP_COMPAT2
    { PROOT_SERVICES, L"Mouclass\\Parameters" },              // PMAP_MOUCLASS_PARAMS
    { PROOT_SERVICES, L"Kbdclass\\Parameters" },              // PMAP_KBDCLASS_PARAMS
    { PROOT_CONTROL,  L"ComputerName\\ComputerName" },        // PMAP_COMPUTERNAME
    { PROOT_CONTROL,  L"Terminal Server" },                   // PMAP_TS
    { PROOT_SYSTEM,   L"WPA\\TabletPC" },                     // PMAP_TABLETPC
    { PROOT_SYSTEM,   L"WPA\\MediaCenter" },                  // PMAP_MEDIACENTER
};

WCHAR PreviousUserStringBuf[256];
UNICODE_STRING PreviousUserString = {0, sizeof PreviousUserStringBuf, PreviousUserStringBuf};
LUID luidPrevious;

CONST WCHAR wszDefaultUser[] = L"\\Registry\\User\\.Default";
UNICODE_STRING DefaultUserString = {sizeof wszDefaultUser - sizeof(WCHAR), sizeof wszDefaultUser, (WCHAR *)wszDefaultUser};

void InitPreviousUserString(void) {
    UNICODE_STRING UserString;
    LUID           luidCaller;

    CheckCritIn();

    /*
     * Speed hack, check if luid of this process == system or previous to
     * save work.
     */
    if (NT_SUCCESS(GetProcessLuid(NULL, &luidCaller))) {

        if (RtlEqualLuid(&luidCaller, &luidPrevious)) {
            return;   // same as last time - no work.
        }
        luidPrevious = luidCaller;

        if (RtlEqualLuid(&luidCaller, &luidSystem))
            goto DefaultUser;

    } else {
        luidPrevious = RtlConvertLongToLuid(0);
    }

    /*
     * Set up current user registry base string.
     */
    if (!NT_SUCCESS(RtlFormatCurrentUserKeyPath(&UserString))) {

DefaultUser:

        RtlCopyUnicodeString(&PreviousUserString, &DefaultUserString);

    } else {
        UserAssert(sizeof(PreviousUserStringBuf) >= UserString.Length + 4);
        RtlCopyUnicodeString(&PreviousUserString, &UserString);
        RtlFreeUnicodeString(&UserString);
    }

    RtlAppendUnicodeToString(&PreviousUserString, L"\\");

}

typedef struct tagPROFILEUSERNAME {
    WCHAR awcName[MAXPROFILEBUF];
    UNICODE_STRING NameString;
} PROFILEUSERNAME, *PPROFILEUSERNAME;

PUNICODE_STRING CreateProfileUserName(TL *ptl)
{
    PPROFILEUSERNAME pMapName;

    CheckCritIn();

    pMapName = UserAllocPoolWithQuota(sizeof (PROFILEUSERNAME), TAG_PROFILEUSERNAME);
    if (!pMapName) {
        RIPMSG0(RIP_WARNING, "CreateProfileUserName: Allocation failed");
        return NULL;
    }

    ThreadLockPool(PtiCurrent(), pMapName, ptl);
    pMapName->NameString.Length = 0;
    pMapName->NameString.MaximumLength = sizeof (pMapName->awcName);
    pMapName->NameString.Buffer = pMapName->awcName;

    InitPreviousUserString();

    RtlCopyUnicodeString(&pMapName->NameString, &PreviousUserString);
    return &(pMapName->NameString);
}

void FreeProfileUserName(PUNICODE_STRING pProfileUserName,TL *ptl) {
    UNREFERENCED_PARAMETER(ptl);
    CheckCritIn();
    if (pProfileUserName) {
        ThreadUnlockAndFreePool(PtiCurrent(), ptl);
    }
}


/*****************************************************************************\
* OpenCacheKeyEx
*
* Attempts to open a cached key for a given section.  If we are calling
* for a client thread, we must check the access rights for the key after
* opening it.
*
* Returns fSuccess.
*
* Note -- param 1 can be NULL.  If the section name is a per-user registry
*         section, we ill use the first parameter if available or set up
*         and use the cached one if the first parameter is NULL.
*
* History:
* 03-Dec-1993 SanfordS  Created.
\*****************************************************************************/
HANDLE OpenCacheKeyEx(
    PUNICODE_STRING pMapName OPTIONAL,
    UINT        idSection,
    ACCESS_MASK amRequest,
    PDWORD pdwPolicyFlags
    )
{
    OBJECT_ATTRIBUTES OA;
    WCHAR             UnicodeStringBuf[256];
    WCHAR             pszSessionId[13];
    UNICODE_STRING    UnicodeString;
    LONG              Status;
    HANDLE            hKey = NULL;
    PEPROCESS         peCurrent = PsGetCurrentProcess();
    DWORD             dwPolicyFlags;

    CheckCritIn();

    UserAssert(idSection <= PMAP_LAST);

    /*
     * If we're opening the desktop or CPL\keyboard key for read access, we should be checking
     * for relevant policy.
     */
    if ((amRequest == KEY_READ) && (idSection == PMAP_DESKTOP)) {
        UserAssert(pdwPolicyFlags);
        UserAssert(!(*pdwPolicyFlags & ~POLICY_VALID));
        dwPolicyFlags = *pdwPolicyFlags;
    } else {
        /*
         * if we are here because Policy was changed and there is not POLICY_ flags set then return.
         */
        if (pdwPolicyFlags && (*pdwPolicyFlags & POLICY_ONLY)) {
            *pdwPolicyFlags = 0;
            UserAssert(FALSE);
            return NULL;
        }
        dwPolicyFlags = POLICY_NONE;
    }

TryAgain:

    UnicodeString.Length        = 0;
    UnicodeString.MaximumLength = sizeof(UnicodeStringBuf);
    UnicodeString.Buffer        = UnicodeStringBuf;


    if (dwPolicyFlags & POLICY_MACHINE) {
        dwPolicyFlags &= ~POLICY_MACHINE;
        RtlAppendUnicodeToString(&UnicodeString,
                                 L"\\Registry\\Machine\\");
        RtlAppendUnicodeToString(&UnicodeString,
                                 L"Software\\Policies\\Microsoft\\Windows\\");
    } else {
        if (aFastRegRoot[aFastRegMap[idSection].idRoot][0] == L'M') {
            RtlAppendUnicodeToString(&UnicodeString, L"\\Registry\\Machine\\");
        } else {
            if (!pMapName) {
                InitPreviousUserString();
                RtlAppendUnicodeStringToString(
                    &UnicodeString,
                    &PreviousUserString);
            } else {
                RtlAppendUnicodeStringToString(
                    &UnicodeString,
                    pMapName);
            }
        }
        if (dwPolicyFlags & POLICY_USER) {
            dwPolicyFlags &= ~POLICY_USER;
            RtlAppendUnicodeToString(&UnicodeString,
                                     L"Software\\Policies\\Microsoft\\Windows\\");
        } 
        else if (dwPolicyFlags & POLICY_REMOTE) {
            dwPolicyFlags &= ~POLICY_REMOTE;
            RtlAppendUnicodeToString(&UnicodeString,
                                     L"Remote\\");
            swprintf(pszSessionId, L"%ld\\", gSessionId);
            RtlAppendUnicodeToString(&UnicodeString, pszSessionId);
        } else {
            /*
             * if we are here because Policy was changed then do not try preferences.  
             */
            if (pdwPolicyFlags && (*pdwPolicyFlags & POLICY_ONLY)) {
                *pdwPolicyFlags = 0;
                return NULL;
            }
            dwPolicyFlags &= ~POLICY_NONE;
        }
    }

    RtlAppendUnicodeToString(&UnicodeString,
                             (PWSTR)&aFastRegRoot[aFastRegMap[idSection].idRoot][1]);

    RtlAppendUnicodeToString(&UnicodeString,
                             (PWSTR)aFastRegMap[idSection].szSection);


    /*
     * Open the key for kernel mode access
     */
    InitializeObjectAttributes(&OA,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&hKey, amRequest, &OA);

    if (
        (amRequest == KEY_READ)   ||     /*
                                          * We must be able to read
                                          * our registry settings.
                                          */
        (peCurrent == gpepCSRSS)  ||
        (peCurrent == gpepInit)
             ) {

    } else {
        /*
         * Now check if the user has access to the key
         */

        if (NT_SUCCESS(Status)) {
            PVOID pKey;
            NTSTATUS Status2;
            Status2 = ObReferenceObjectByHandle(hKey,
                                        amRequest,
                                        NULL,
                                        KernelMode,
                                        &pKey,
                                        NULL);

            if (NT_SUCCESS(Status2)) {
                if (!AccessCheckObject(pKey, amRequest, UserMode, &KeyMapping)) {
                    ZwClose(hKey);
                    Status = STATUS_ACCESS_DENIED;
                }
                ObDereferenceObject(pKey);
            } else {
                ZwClose(hKey);
                Status = STATUS_ACCESS_DENIED;
            }
        }

    }

#if DBG
    if (!NT_SUCCESS(Status)) {
        UnicodeStringBuf[UnicodeString.Length / 2] = 0;

        if (PsGetCurrentProcessId() != gpidLogon) {
            RIPMSG1(RIP_WARNING | RIP_THERESMORE, "OpenCacheKeyEx failed with Status = %lx key:", Status);
            RIPMSG1(RIP_WARNING | RIP_THERESMORE | RIP_NONAME | RIP_NONEWLINE, " %ws\\", UnicodeStringBuf);
        }
    }
#endif DBG

    /*
     * If we didn't succeed and we're not down to bottom of policy chain, try again.
     */
    if (!NT_SUCCESS(Status) && dwPolicyFlags) {
        goto TryAgain;
    }

    /*
     * Update policy level
     */
    if (pdwPolicyFlags) {
        *pdwPolicyFlags = dwPolicyFlags;
    }

    return (NT_SUCCESS(Status) ? hKey : NULL);
}


/*****************************************************************************\
* CheckDesktopPolicy
*
* Check if a desktop value has an associated policy.
*
* Returns TRUE if there is a policy, FALSE otherwise.
*
* History:
* 07-Feb-2000 JerrySh   Created.
\*****************************************************************************/
BOOL CheckDesktopPolicy(
    PUNICODE_STRING pProfileUserName OPTIONAL,
    PCWSTR      lpKeyName
    )
{
    WCHAR          szKey[80];
    HANDLE         hKey;
    DWORD          cbSize;
    NTSTATUS       Status;
    UNICODE_STRING UnicodeString;
    KEY_VALUE_BASIC_INFORMATION  KeyInfo;
    DWORD          dwPolicyFlags = gdwPolicyFlags & (POLICY_MACHINE | POLICY_USER);

    /*
     * If there is no policy or the caller is winlogon, let it go.
     */
    if (!dwPolicyFlags || GetCurrentProcessId() == gpidLogon) {
        return FALSE;
    }

    /*
     * Convert the ID to a string if we need to.
     */
    if (!IS_PTR(lpKeyName)) {
        ServerLoadString(hModuleWin, PTR_TO_ID(lpKeyName), szKey, ARRAY_SIZE(szKey));
        lpKeyName = szKey;
    }

TryAgain:

    /*
     * Try to open a key.
     */
    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               PMAP_DESKTOP,
                               KEY_READ,
                               &dwPolicyFlags)) == NULL) {
        return FALSE;
    }

    /*
     * See if the value exists.
     */
    RtlInitUnicodeString(&UnicodeString, lpKeyName);
    Status = ZwQueryValueKey(hKey,
                             &UnicodeString,
                             KeyValueBasicInformation,
                             &KeyInfo,
                             sizeof(KeyInfo),
                             &cbSize);

    ZwClose(hKey);

    if (!NT_ERROR(Status)) {
        return TRUE;
    } else if (dwPolicyFlags) {
        goto TryAgain;
    } else {
        return FALSE;
    }
}


/*****************************************************************************\
* CheckDesktopPolicyChange
*
* Check if policy has changed since last time we checked.
*
* Returns TRUE if policy changed, FASLE otherwise.
*
* History:
* 07-Feb-2000 JerrySh   Created.
\*****************************************************************************/
BOOL CheckDesktopPolicyChange(
    PUNICODE_STRING pProfileUserName OPTIONAL
    )
{
    static LARGE_INTEGER  LastMachineWriteTime;
    static LARGE_INTEGER  LastUserWriteTime;
    KEY_BASIC_INFORMATION KeyInfo;
    BOOL                  bPolicyChanged = FALSE;
    HANDLE                hKey;
    DWORD                 cbSize;
    DWORD                 dwPolicyFlags;

    /*
     * Check if machine policy has changed since last time we checked.
     */
    dwPolicyFlags = POLICY_MACHINE;
    KeyInfo.LastWriteTime.QuadPart = 0;
    hKey = OpenCacheKeyEx(pProfileUserName,
                          PMAP_DESKTOP,
                          KEY_READ,
                          &dwPolicyFlags);
    if (hKey) {
        if (hKey) {
            ZwQueryKey(hKey,
                       KeyValueBasicInformation,
                       &KeyInfo,
                       sizeof(KeyInfo),
                       &cbSize);
            ZwClose(hKey);
        }
        gdwPolicyFlags |= POLICY_MACHINE;
    } else {
        gdwPolicyFlags &= ~POLICY_MACHINE;
    }
    if (LastMachineWriteTime.QuadPart != KeyInfo.LastWriteTime.QuadPart) {
        LastMachineWriteTime.QuadPart = KeyInfo.LastWriteTime.QuadPart;
        bPolicyChanged = TRUE;
    }

    /*
     * Check if user policy has changed since last time we checked.
     */
    dwPolicyFlags = POLICY_USER;
    KeyInfo.LastWriteTime.QuadPart = 0;
    hKey = OpenCacheKeyEx(pProfileUserName,
                          PMAP_DESKTOP,
                          KEY_READ,
                          &dwPolicyFlags);
    if (hKey) {
        ZwQueryKey(hKey,
                   KeyValueBasicInformation,
                   &KeyInfo,
                   sizeof(KeyInfo),
                   &cbSize);
        ZwClose(hKey);
        gdwPolicyFlags |= POLICY_USER;
    } else {
        gdwPolicyFlags &= ~POLICY_USER;
    }
    if (LastUserWriteTime.QuadPart != KeyInfo.LastWriteTime.QuadPart) {
        LastUserWriteTime.QuadPart = KeyInfo.LastWriteTime.QuadPart;
        bPolicyChanged = TRUE;
    }

    return bPolicyChanged;
}


/*****************************************************************************\
* FastGetProfileDwordW
*
* Reads a REG_DWORD type key from the registry.
*
* returns value read or default value on failure.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
BOOL FastGetProfileDwordW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    DWORD   dwDefault,
    PDWORD  pdwReturn,
    DWORD   dwPolicyOnly
    )
{
    HANDLE         hKey;
    DWORD          cbSize;
    DWORD          dwRet;
    LONG           Status;
    UNICODE_STRING UnicodeString;
    BYTE           Buf[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    DWORD          dwPolicyFlags = gdwPolicyFlags | dwPolicyOnly;

    UserAssert(idSection <= PMAP_LAST);

TryAgain:

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_READ,
                               &dwPolicyFlags)) == NULL) {
        RIPMSG1(RIP_WARNING | RIP_NONAME, "%ws", lpKeyName);

        if (dwPolicyOnly & POLICY_ONLY) {
            return FALSE;
        }

        if (pdwReturn) {
            *pdwReturn = dwDefault;
        }
        return TRUE;
    }

    RtlInitUnicodeString(&UnicodeString, lpKeyName);
    Status = ZwQueryValueKey(hKey,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             (PKEY_VALUE_PARTIAL_INFORMATION)Buf,
                             sizeof(Buf),
                             &cbSize);

    dwRet = dwDefault;

    if (NT_SUCCESS(Status)) {

        dwRet = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)Buf)->Data);

    } else if (dwPolicyFlags) {

        ZwClose(hKey);
        goto TryAgain;

    } else if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

        RIPMSG1(RIP_WARNING,
                "FastGetProfileDwordW: ObjectName not found: %ws",
                lpKeyName);
    }

    ZwClose(hKey);

    if (pdwReturn) {
        *pdwReturn = dwRet;
    }
    return TRUE;
}

/*****************************************************************************\
* FastGetProfileKeysW()
*
* Reads all key names in the given section.
*
* History:
* 15-Dec-1994 JimA      Created.
\*****************************************************************************/
DWORD FastGetProfileKeysW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpDefault,
    LPWSTR  *lpReturnedString
    )
{
    HANDLE                       hKey;
    DWORD                        cchSize;
    DWORD                        cchKey;
    LONG                         Status;
    WCHAR                        Buffer[256 + 6];
    PKEY_VALUE_BASIC_INFORMATION pKeyInfo;
    ULONG                        iValue;
    LPWSTR                       lpTmp;
    LPWSTR                       lpKeys = NULL;
    DWORD                        dwPoolSize;

    UserAssert(idSection <= PMAP_LAST);

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_READ,
                               NULL)) == NULL) {
        RIPMSG0(RIP_WARNING | RIP_NONAME, "");
        goto DefExit;
    }

    pKeyInfo          = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
    cchSize           = 0;
    *lpReturnedString = NULL;
    iValue            = 0;

    while (TRUE) {

#if DBG
        wcscpy(Buffer + 256, L"DON'T");
#endif
        Status = ZwEnumerateValueKey(hKey,
                                     iValue,
                                     KeyValueBasicInformation,
                                     pKeyInfo,
                                     sizeof(Buffer),
                                     &cchKey);

        UserAssert(_wcsicmp(Buffer + 256, L"DON'T") == 0);

        if (Status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(Status)) {

            if (lpKeys) {
                UserFreePool(lpKeys);
                lpKeys = NULL;
            }
            goto DefExit;
        }

        UserAssert(pKeyInfo->NameLength * sizeof(WCHAR) <=
                   sizeof(Buffer) - sizeof(KEY_VALUE_BASIC_INFORMATION));

        UserAssert(cchKey <= sizeof(Buffer));

        /*
         * A key was found.  Allocate space for it.  Note that
         * NameLength is in bytes.
         */
        cchKey   = cchSize;
        cchSize += pKeyInfo->NameLength + sizeof(WCHAR);

        if (lpKeys == NULL) {

            dwPoolSize = cchSize + sizeof(WCHAR);
            lpKeys = UserAllocPoolWithQuota(dwPoolSize, TAG_PROFILE);

        } else {

            lpTmp = lpKeys;
            lpKeys = UserReAllocPoolWithQuota(lpTmp,
                                              dwPoolSize,
                                              cchSize + sizeof(WCHAR),
                                              TAG_PROFILE);

            /*
             * Free the original buffer if the allocation fails
             */
            if (lpKeys == NULL) {
                UserFreePool(lpTmp);
            }
            dwPoolSize = cchSize + sizeof(WCHAR);
        }

        /*
         * Check for out of memory.
         */
        if (lpKeys == NULL)
            goto DefExit;

        /*
         * NULL terminate the string and append it to
         * the key list.
         */
        UserAssert(pKeyInfo->NameLength < sizeof(Buffer) - sizeof(KEY_VALUE_BASIC_INFORMATION));

        RtlCopyMemory(&lpKeys[cchKey / sizeof(WCHAR)], pKeyInfo->Name, pKeyInfo->NameLength);
        lpKeys[(cchKey + pKeyInfo->NameLength) / sizeof(WCHAR)] = 0;

        iValue++;
    }

    /*
     * If no keys were found, return the default.
     */
    if (iValue == 0) {

DefExit:

        cchSize = wcslen(lpDefault)+1;
        lpKeys  = UserAllocPoolWithQuota((cchSize+1) * sizeof(WCHAR), TAG_PROFILE);

        if (lpKeys)
            wcscpy(lpKeys, lpDefault);
        else
            cchSize = 0;

    } else {

        /*
         * Turn the byte count into a char count.
         */
        cchSize /= sizeof(WCHAR);
    }

    /*
     * Make sure hKey is closed.
     */
    if (hKey)
        ZwClose(hKey);

    /*
     * Append the ending NULL.
     */
    if (lpKeys)
        lpKeys[cchSize] = 0;

    *lpReturnedString = lpKeys;

    return cchSize;
}

/*****************************************************************************\
* FastGetProfileStringW()
*
* Implements a fast version of the standard API using predefined registry
* section indecies (PMAP_) that reference lazy-opened, cached registry
* handles.  FastCloseProfileUserMapping() should be called to clean up
* cached entries when fast profile calls are completed.
*
* This api does NOT implement the NULL lpKeyName feature of the real API.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
DWORD FastGetProfileStringW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   cchBuf,
    DWORD   dwPolicyOnly
    )
{
    HANDLE                         hKey = NULL;
    DWORD                          cbSize;
    LONG                           Status;
    UNICODE_STRING                 UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    DWORD                          dwPolicyFlags = gdwPolicyFlags | dwPolicyOnly;


    UserAssert(idSection <= PMAP_LAST);
    UserAssert(lpKeyName != NULL);

TryAgain:

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_READ,
                               &dwPolicyFlags)) == NULL) {
#if DBG
        if (PsGetCurrentProcessId() != gpidLogon) {
            RIPMSG1(RIP_WARNING | RIP_NONAME, "%ws", lpKeyName);
        }
#endif
        if (dwPolicyOnly & POLICY_ONLY) {
            return 0;
        }
        goto DefExit;
    }

    cbSize = (cchBuf * sizeof(WCHAR)) +
            FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);

    if ((pKeyInfo = UserAllocPoolWithQuota(cbSize, TAG_PROFILE)) == NULL)
        goto DefExit;

    RtlInitUnicodeString(&UnicodeString, lpKeyName);
    Status = ZwQueryValueKey(hKey,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             pKeyInfo,
                             cbSize,
                             &cbSize);

    if (Status == STATUS_BUFFER_OVERFLOW) {
        RIPMSG0(RIP_WARNING, "FastGetProfileStringW: Buffer overflow");
        Status = STATUS_SUCCESS;
    }

    UserAssert(NT_SUCCESS(Status) || (Status == STATUS_OBJECT_NAME_NOT_FOUND));

    if (NT_SUCCESS(Status)) {

        if (pKeyInfo->DataLength >= sizeof(WCHAR)) {

            ((LPWSTR)(pKeyInfo->Data))[cchBuf - 1] = L'\0';
            wcscpy(lpReturnedString, (LPWSTR)pKeyInfo->Data);

        } else {
            /*
             * Appears to be a bug with empty strings - only first
             * byte is set to NULL. (SAS)
             */
            lpReturnedString[0] = TEXT('\0');
        }

        cchBuf = pKeyInfo->DataLength;

        UserFreePool(pKeyInfo);

        ZwClose(hKey);

        /*
         * data length includes terminating zero [bodind]
         */
        return (cchBuf / sizeof(WCHAR));

    } else if (dwPolicyFlags) {
        UserFreePool(pKeyInfo);
        ZwClose(hKey);
        goto TryAgain;
    }

    UserFreePool(pKeyInfo);

DefExit:

    /*
     * Make sure the key is closed.
     */
    if (hKey)
        ZwClose(hKey);

    /*
     * wcscopy copies terminating zero, but the length returned by
     * wcslen does not, so add 1 to be consistent with success
     * return [bodind]
     */
    if (lpDefault != NULL) {
        cchBuf = wcslen(lpDefault) + 1;
        RtlCopyMemory(lpReturnedString, lpDefault, cchBuf * sizeof(WCHAR));
        return cchBuf;
    }

    return 0;
}

/*****************************************************************************\
* FastGetProfileIntW()
*
* Implements a fast version of the standard API using predefined registry
* section indecies (PMAP_) that reference lazy-opened, cached registry
* handles.  FastCloseProfileUserMapping() should be called to clean up
* cached entries when fast profile calls are completed.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
BOOL FastGetProfileIntW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    UINT    nDefault,
    PUINT   puiReturn,
    DWORD   dwPolicyOnly
    )
{
    WCHAR          ValueBuf[40];
    UNICODE_STRING Value;
    UINT           ReturnValue;

    UserAssert(idSection <= PMAP_LAST);
    UserAssert(puiReturn);

    if (!FastGetProfileStringW(pProfileUserName,
                               idSection,
                               lpKeyName,
                               NULL,
                               ValueBuf,
                               sizeof(ValueBuf) / sizeof(WCHAR),
                               dwPolicyOnly
                               )) {
        if (dwPolicyOnly & POLICY_ONLY) {
            return FALSE;
        }

        *puiReturn = nDefault; 
        return TRUE;
    }

    /*
     * Convert string to int.
     */
    RtlInitUnicodeString(&Value, ValueBuf);
    RtlUnicodeStringToInteger(&Value, 10, &ReturnValue);

    *puiReturn = ReturnValue; 
    return TRUE;
}

/*****************************************************************************\
* FastWriteProfileStringW
*
* Implements a fast version of the standard API using predefined registry
* section indecies (PMAP_) that reference lazy-opened, cached registry
* handles.  FastCloseProfileUserMapping() should be called to clean up
* cached entries when fast profile calls are completed.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
BOOL FastWriteProfileStringW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    LPCWSTR lpString
    )
{
    HANDLE         hKey;
    LONG           Status;
    UNICODE_STRING UnicodeString;

    UserAssert(idSection <= PMAP_LAST);

    /*
     * We shouldn't be writing values that are controlled by policy.
     */
    if (idSection == PMAP_DESKTOP) {
        UserAssert(!CheckDesktopPolicy(pProfileUserName, lpKeyName));
    }

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_WRITE,
                               NULL)) == NULL) {
        RIPMSG1(RIP_WARNING | RIP_NONAME, "%ws", lpKeyName);
        return FALSE;
    }

    RtlInitUnicodeString(&UnicodeString, lpKeyName);
    Status = ZwSetValueKey(hKey,
                           &UnicodeString,
                           0,
                           REG_SZ,
                           (PVOID)lpString,
                           (wcslen(lpString) + 1) * sizeof(WCHAR));

    ZwClose(hKey);

    return (NT_SUCCESS(Status));
}

/*****************************************************************************\
* FastGetProfileIntFromID
*
* Just like FastGetProfileIntW except it reads the USER string table for the
* key name.
*
* History:
* 02-Dec-1993 SanfordS  Created.
* 25-Feb-1995 BradG     Added TWIPS -> Pixel conversion.
\*****************************************************************************/
BOOL FastGetProfileIntFromID(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT  idSection,
    UINT  idKey,
    int   def,
    PINT  pResult,
    DWORD dwPolicyOnly
    )
{
    int   result;
    WCHAR szKey[80];


    UserAssert(idSection <= PMAP_LAST);

    ServerLoadString(hModuleWin, idKey, szKey, ARRAY_SIZE(szKey));

    if (FastGetProfileIntW(pProfileUserName,idSection, szKey, def, &result, dwPolicyOnly)) 
    {
        /*
         * If you change the below list of STR_* make sure you make a
         * corresponding change in SetWindowMetricInt (rare.c)
         */
        switch (idKey) {
        case STR_BORDERWIDTH:
        case STR_SCROLLWIDTH:
        case STR_SCROLLHEIGHT:
        case STR_CAPTIONWIDTH:
        case STR_CAPTIONHEIGHT:
        case STR_SMCAPTIONWIDTH:
        case STR_SMCAPTIONHEIGHT:
        case STR_MENUWIDTH:
        case STR_MENUHEIGHT:
        case STR_ICONHORZSPACING:
        case STR_ICONVERTSPACING:
        case STR_MINWIDTH:
        case STR_MINHORZGAP:
        case STR_MINVERTGAP:
            /*
             * Convert any registry values stored in TWIPS back to pixels
             */
            if (result < 0)
                result = MultDiv(-result, gpsi->dmLogPixels, 72 * 20);
            break;
        }

        if (pResult) {
            *pResult = result;
        }
        return TRUE;
    }
    return FALSE;
}

/*****************************************************************************\
* FastGetProfileIntFromID
*
* Just like FastGetProfileStringW except it reads the USER string table for
* the key name.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
DWORD FastGetProfileStringFromIDW(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    UINT    idKey,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   cch,
    DWORD   dwPolicyOnly
    )
{
    WCHAR szKey[80];

    UserAssert(idSection <= PMAP_LAST);

    ServerLoadString(hModuleWin, idKey, szKey, ARRAY_SIZE(szKey));

    return FastGetProfileStringW(pProfileUserName,
                                 idSection,
                                 szKey,
                                 lpDefault,
                                 lpReturnedString,
                                 cch,
                                 dwPolicyOnly);
}

/*****************************************************************************\
* FastWriteProfileValue
*
* History:
* 06/10/96 GerardoB Renamed and added uType parameter
\*****************************************************************************/
BOOL FastWriteProfileValue(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    UINT    uType,
    LPBYTE  lpStruct,
    UINT    cbSizeStruct
    )
{
    HANDLE         hKey;
    LONG           Status;
    UNICODE_STRING UnicodeString;
    WCHAR          szKey[SERVERSTRINGMAXSIZE];

    UserAssert(idSection <= PMAP_LAST);

    if (!IS_PTR(lpKeyName)) {
        *szKey = (WCHAR)0;
        ServerLoadString(hModuleWin, PTR_TO_ID(lpKeyName), szKey, ARRAY_SIZE(szKey));
        UserAssert(*szKey != (WCHAR)0);
        lpKeyName = szKey;
    }

    /*
     * We shouldn't be writing values that are controlled by policy.
     */
    if (idSection == PMAP_DESKTOP) {
        UserAssert(!CheckDesktopPolicy(pProfileUserName, lpKeyName));
    }

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_WRITE,
                               NULL)) == NULL) {
        RIPMSG1(RIP_WARNING, "FastWriteProfileValue: Failed to open cache-key (%ws)", lpKeyName);
        return FALSE;
    }

    RtlInitUnicodeString(&UnicodeString, lpKeyName);

    Status = ZwSetValueKey(hKey,
                           &UnicodeString,
                           0,
                           uType,
                           lpStruct,
                           cbSizeStruct);
    ZwClose(hKey);

#if DBG
    if (!NT_SUCCESS(Status)) {
        RIPMSG3 (RIP_WARNING, "FastWriteProfileValue: ZwSetValueKey Failed. Status:%#lx idSection:%#lx KeyName:%s",
                 Status, idSection, UnicodeString.Buffer);
    }
#endif

    return (NT_SUCCESS(Status));
}

/*****************************************************************************\
* FastGetProfileValue
*
* If cbSizeReturn is 0, just return the size of the data
*
* History:
* 06/10/96 GerardoB Renamed
\*****************************************************************************/
DWORD FastGetProfileValue(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT    idSection,
    LPCWSTR lpKeyName,
    LPBYTE  lpDefault,
    LPBYTE  lpReturn,
    UINT    cbSizeReturn,
    DWORD   dwPolicyOnly
    )
{
    HANDLE                         hKey;
    UINT                           cbSize;
    LONG                           Status;
    UNICODE_STRING                 UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
    WCHAR                          szKey[SERVERSTRINGMAXSIZE];
    KEY_VALUE_PARTIAL_INFORMATION  KeyInfo;
    DWORD                          dwPolicyFlags = gdwPolicyFlags | dwPolicyOnly;

    UserAssert(idSection <= PMAP_LAST);

    if (!IS_PTR(lpKeyName)) {
        *szKey = (WCHAR)0;
        ServerLoadString(hModuleWin, PTR_TO_ID(lpKeyName), szKey, ARRAY_SIZE(szKey));
        UserAssert(*szKey != (WCHAR)0);
        lpKeyName = szKey;
    }

TryAgain:

    if ((hKey = OpenCacheKeyEx(pProfileUserName,
                               idSection,
                               KEY_READ,
                               &dwPolicyFlags)) == NULL) {
        // if hi-word of lpKeName is 0, it is a resource number not a string
        if (!IS_PTR(lpKeyName))
            RIPMSG1(RIP_WARNING, "FastGetProfileValue: Failed to open cache-key (%08x)", lpKeyName);
        else
            RIPMSG1(RIP_WARNING | RIP_NONAME, "%ws", lpKeyName);

        if (dwPolicyOnly & POLICY_ONLY) {
            return 0;
        }
        goto DefExit;
    }

    if (cbSizeReturn == 0) {
        cbSize = sizeof(KeyInfo);
        pKeyInfo = &KeyInfo;
    } else {
        cbSize = cbSizeReturn + FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
        if ((pKeyInfo = UserAllocPoolWithQuota(cbSize, TAG_PROFILE)) == NULL) {
            goto DefExit;
        }
    }

    RtlInitUnicodeString(&UnicodeString, lpKeyName);

    Status = ZwQueryValueKey(hKey,
                             &UnicodeString,
                             KeyValuePartialInformation,
                             pKeyInfo,
                             cbSize,
                             &cbSize);

    if (NT_SUCCESS(Status)) {

        UserAssert(cbSizeReturn >= pKeyInfo->DataLength);

        cbSize = pKeyInfo->DataLength;
        RtlCopyMemory(lpReturn, pKeyInfo->Data, cbSize);

        if (cbSizeReturn != 0) {
            UserFreePool(pKeyInfo);
        }
        ZwClose(hKey);

        return cbSize;
    } else if ((Status == STATUS_BUFFER_OVERFLOW) && (cbSizeReturn == 0)) {
        ZwClose(hKey);
        return pKeyInfo->DataLength;
    } else if (dwPolicyFlags) {
        if (cbSizeReturn != 0) {
            UserFreePool(pKeyInfo);
        }
        ZwClose(hKey);
        goto TryAgain;
    }

#if DBG
    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
        RIPMSG3 (RIP_WARNING, "FastGetProfileValue: ZwQueryValueKey Failed. Status:%#lx idSection:%#lx KeyName:%s",
                Status, idSection, UnicodeString.Buffer);
    }
#endif

    if (cbSizeReturn != 0) {
        UserFreePool(pKeyInfo);
    }

DefExit:

    if (hKey)
        ZwClose(hKey);

    if (lpDefault) {
        RtlMoveMemory(lpReturn, lpDefault, cbSizeReturn);
        return cbSizeReturn;
    }

    return 0;
}

/*****************************************************************************\
* UT_FastGetProfileIntsW
*
* Repeatedly calls FastGetProfileIntW on the given table.
*
* History:
* 02-Dec-1993 SanfordS  Created.
\*****************************************************************************/
BOOL FastGetProfileIntsW(PUNICODE_STRING pProfileUserName OPTIONAL,
    PPROFINTINFO ppii,
    DWORD        dwPolicyOnly
    )
{
    WCHAR szKey[40];

    while (ppii->idSection != 0) {

        ServerLoadString(hModuleWin,
                             PTR_TO_ID(ppii->lpKeyName),
                             szKey,
                             ARRAY_SIZE(szKey));

        FastGetProfileIntW(pProfileUserName,
                           ppii->idSection,
                           szKey,
                           ppii->nDefault,
                           ppii->puResult,
                           dwPolicyOnly);
        ppii++;
    }

    return TRUE;
}

/***************************************************************************\
* UpdateWinIni
*
* Handles impersonation stuff and writes the given value to the registry.
*
* History:
* 28-Jun-1991 MikeHar       Ported.
* 03-Dec-1993 SanfordS      Used FastProfile calls, moved to profile.c
\***************************************************************************/
BOOL FastUpdateWinIni(PUNICODE_STRING pProfileUserName OPTIONAL,
    UINT         idSection,
    UINT         wKeyNameId,
    LPWSTR       lpszValue
    )
{
    WCHAR            szKeyName[40];
    BOOL             bResult = FALSE;

    UserAssert(idSection <= PMAP_LAST);

    ServerLoadString(hModuleWin,
                         wKeyNameId,
                         szKeyName,
                         ARRAY_SIZE(szKeyName));

    bResult = FastWriteProfileStringW(pProfileUserName,
                                          idSection, szKeyName, lpszValue);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\queue.c ===
/****************************** Module Header ******************************\
* Module Name: queue.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the low-level code for working with the Q structure.
*
* History:
* 12-02-90 DavidPe      Created.
* 02-06-91 IanJa        HWND revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

VOID DestroyProcessesObjects(PPROCESSINFO ppi);
VOID DestroyThreadsMessages(PQ pq, PTHREADINFO pti);
VOID CheckProcessForeground(PTHREADINFO pti);
DWORD xxxPollAndWaitForSingleObject(PKEVENT pEvent, PVOID pExecObject,
                                    DWORD dwMilliseconds);

NTSTATUS InitiateShutdown(PETHREAD Thread, PULONG lpdwFlags);
NTSTATUS EndShutdown(PETHREAD Thread, NTSTATUS StatusShutdown);
VOID SetVDMCursorBounds(LPRECT lprc);
NTSTATUS InitQEntryLookaside(VOID);
VOID SetAppStarting(PPROCESSINFO ppi);

#if defined(_WIN64) 
/* 
 * For Win64 ask winlogon to play sounds for accessibility events
 * (IA64 machines do not have internal speakers so we have to go
 * thru the sound card).  Post a message to winlogon with an lParam
 * whose high word is ACCESS_SOUND_RANGE and low word is the index 
 * of the sound to make.  If a new RITSOUND_xx macro is added then
 * winlogon has to be updated too.
 */
#define ACCESS_SOUND_RANGE 1
#endif

#pragma alloc_text(INIT, InitQEntryLookaside)

PW32PROCESS gpwpCalcFirst;

PPAGED_LOOKASIDE_LIST QLookaside;
PPAGED_LOOKASIDE_LIST QEntryLookaside;

#if DBG
VOID DebugValidateMLIST(
    PMLIST pml)
{
    int     c;
    PQMSG   pqmsg;

    /*
     * Check that the message list is properly terminated.
     */
    UserAssert(!pml->pqmsgRead || !pml->pqmsgRead->pqmsgPrev);
    UserAssert(!pml->pqmsgWriteLast || !pml->pqmsgWriteLast->pqmsgNext);

    /*
     * Check that there aren't loops in the Next list.
     */
    c = pml->cMsgs;
    UserAssert(c >= 0);
    pqmsg = pml->pqmsgRead;
    while (--c >= 0) {
        UserAssert(pqmsg);
        if (c == 0) {
            UserAssert(pqmsg == pml->pqmsgWriteLast);
        }

        pqmsg = pqmsg->pqmsgNext;
    }

    UserAssert(!pqmsg);

    /*
     * Check that there aren't loops in the Prev list.
     */
    c = pml->cMsgs;
    pqmsg = pml->pqmsgWriteLast;
    while (--c >= 0) {
        UserAssert(pqmsg);
        if (c == 0) {
            UserAssert(pqmsg == pml->pqmsgRead);
        }

        pqmsg = pqmsg->pqmsgPrev;
    }

    UserAssert(!pqmsg);
}

VOID DebugValidateMLISTandQMSG(
    PMLIST pml,
    PQMSG pqmsg)
{
    PQMSG pqmsgT;

    DebugValidateMLIST(pml);
    for (pqmsgT = pml->pqmsgRead; pqmsgT; pqmsgT = pqmsgT->pqmsgNext) {
        if (pqmsgT == pqmsg) {
            return;
        }
    }

    UserAssert(pqmsgT == pqmsg);
}

#else
#define DebugValidateMLIST(pml)
#define DebugValidateMLISTandQMSG(pml, pqmsg)
#endif

VOID
_AllowForegroundActivation(
    VOID)
{
    SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
    TAGMSG0(DBGTAG_FOREGROUND, "AllowSetForegroundWindows set PUDF.");
}

/***************************************************************************\
* xxxSetProcessInitState
*
* Set process initialization state. What state is set depends
* on whether another process is waiting on this process.
*
* 04-02-95 JimA         Created.
\***************************************************************************/
BOOL xxxSetProcessInitState(
    PEPROCESS Process,
    DWORD dwFlags)
{
    PW32PROCESS W32Process;
    NTSTATUS Status;

    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * If the W32Process structure has not been allocated, do it now.
     */
    W32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);
    if (W32Process == NULL) {
        Status = AllocateW32Process(Process);
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
        W32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);
#if DBG
        /*
         * The above AllocateW32Process(Process, FALSE) won't set the
         * W32PF_PROCESSCONNECTED flag (and if it wasn't previously set),
         * make sure we're not on the gppiStarting list, because if we are,
         * we will not be removed without the W32PF_PROCESSCONNECTED bit.
         */
        if ((W32Process->W32PF_Flags & W32PF_PROCESSCONNECTED) == 0) {
            UserAssert((W32Process->W32PF_Flags & W32PF_APPSTARTING) == 0);
        }
#endif
    }

    /*
     * Defer WinEvent notifications, because the thread isn't initialized yet.
     */
    DeferWinEventNotify();
    if (dwFlags == 0) {
        if (!(W32Process->W32PF_Flags & W32PF_WOW)) {

            /*
             * Check to see if the startglass is on, and if so turn it off and update.
             */
            if (W32Process->W32PF_Flags & W32PF_STARTGLASS) {
                W32Process->W32PF_Flags &= ~W32PF_STARTGLASS;
                zzzCalcStartCursorHide(NULL, 0);
            }

            /*
             * Found it. Set the console bit and reset the wait event so any sleepers
             * wake up.
             */
            W32Process->W32PF_Flags |= W32PF_CONSOLEAPPLICATION;
            SET_PSEUDO_EVENT(&W32Process->InputIdleEvent);
        }
    } else if (!(W32Process->W32PF_Flags & W32PF_INITIALIZED)) {
        W32Process->W32PF_Flags |= W32PF_INITIALIZED;

        /*
         * Set global state to allow the new process to become
         * foreground. xxxInitProcessInfo() will set
         * W32PF_ALLOWFOREGROUNDACTIVATE when the process initializes.
         */
        SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
        TAGMSG1(DBGTAG_FOREGROUND, "xxxSetProcessInitState set PUDF. %#p", W32Process);


        /*
         * If this is the win32 server process, force off start glass feedback
         */
        if (Process == gpepCSRSS) {
            dwFlags |= STARTF_FORCEOFFFEEDBACK;
        }

        /*
         * Show the app start cursor for 2 seconds if it was requested from
         * the application.
         */
        if (dwFlags & STARTF_FORCEOFFFEEDBACK) {
            W32Process->W32PF_Flags |= W32PF_FORCEOFFFEEDBACK;
            zzzCalcStartCursorHide(NULL, 0);
        } else if (dwFlags & STARTF_FORCEONFEEDBACK) {
            zzzCalcStartCursorHide(W32Process, 2000);
        }
    }
    /*
     * Have to defer without processing, because we don't have a ptiCurrent yet
     */
    EndDeferWinEventNotifyWithoutProcessing();
    return TRUE;
}

/***************************************************************************\
* CheckAllowForeground
*
* Bug 273518 - joejo
*
* Removed this loop from xxxInitProcessInfo to allow code shareing between
* that function and xxxUserNotifyConsoleApplication. This will allow console
* windows to set foreground correctly on new process' it launches, as opposed
* it just forcing foreground.
\***************************************************************************/
BOOL CheckAllowForeground(
    PEPROCESS pep)
{
    BOOL fCreator = TRUE;
    HANDLE hpid = PsGetProcessInheritedFromUniqueProcessId(pep);
    LUID luid;
    PACCESS_TOKEN pat;
    PEPROCESS pepParent;
    PPROCESSINFO ppiParent;
    UINT uAncestors = 0;
    BOOL fAllowForeground = FALSE;
    NTSTATUS Status;

    do {
        /*
         * Get the ppi for the parent process.
         */
        LeaveCrit();
        Status = LockProcessByClientId(hpid, &pepParent);
        EnterCrit();
        if (!NT_SUCCESS(Status)) {
            /*
             * Bug 294193 - joejo
             *
             * If this is a process that was created after it'a creator was
             * destroyed, then lets attempt to give it foreground. This is a
             * typical scenario when a stub exe trys to create another process
             * in it's place.
             */
CheckForegroundActivateRight:
            if (HasForegroundActivateRight(PsGetProcessInheritedFromUniqueProcessId(pep))) {
                fAllowForeground = TRUE;
            }
            break;
        }

        ppiParent = PpiFromProcess(pepParent);
        if (ppiParent == NULL) {
            UnlockProcess(pepParent);
            goto CheckForegroundActivateRight;
        }
        /*
         * If we're walking the parent chain,
         * stop when we get to the shell or to a process that
         * is not running on the IO winsta
         */
        if (!fCreator
                && (IsShellProcess(ppiParent)
                    || ((ppiParent->rpwinsta != NULL)
                        && (ppiParent->rpwinsta->dwWSF_Flags & WSF_NOIO)))) {

            UnlockProcess(pepParent);
            break;
        }
        fAllowForeground = CanForceForeground(ppiParent FG_HOOKLOCK_PARAM(NULL));
        if (!fAllowForeground) {
            /*
             * Bug 285639 - joejo
             *
             * If the first thread of the parent process has allow set foreground
             * than we allow the setting of the foreground.
             */
            if (ppiParent->ptiList != NULL
                && (ppiParent->ptiList->TIF_flags & TIF_ALLOWFOREGROUNDACTIVATE)) {
                    fAllowForeground = TRUE;
            }

            if (!fAllowForeground){
                /*
                 * Let's try an ancestor (this might be a worker process).
                 */
                hpid = PsGetProcessInheritedFromUniqueProcessId(pepParent);
                /*
                 * If this is launched by a system process, let it come to
                 *  the foreground (i.e. CSRSS launching an OLE server).
                 */
                if (fCreator) {
                    fCreator = FALSE;
                    pat = PsReferencePrimaryToken(pepParent);
                    if (pat != NULL) {
                        Status = SeQueryAuthenticationIdToken(pat, &luid);
                        if (NT_SUCCESS(Status)) {
                            fAllowForeground = RtlEqualLuid(&luid, &luidSystem);
                            /*
                             * If it is a system process, give it the
                             *  permanent right so we won't have to check
                             *  its luid again
                             */
                             if (fAllowForeground) {
                                 ppiParent->W32PF_Flags |= W32PF_ALLOWSETFOREGROUND;
                             }
                        }
                        ObDereferenceObject(pat);
                    }
                }
            }
        }
        UnlockProcess(pepParent);
      /*
       * InheritedFromUniqueProcessId cannot be quite trusted because
       *  process ids get reused very often. So we just check few levels up
       */
    } while (!fAllowForeground && (uAncestors++ < 5));

    return  fAllowForeground || GiveUpForeground();
}

/***************************************************************************\
* xxxUserNotifyConsoleApplication
*
* This is called by the console init code - it tells us that the starting
* application is a console application. We want to know this for various
* reasons, one being that WinExec() doesn't wait on a starting console
* application.
*
* 09-18-91 ScottLu      Created.
* 01-12-99 JoeJo        Bug 273518
\***************************************************************************/
VOID xxxUserNotifyConsoleApplication(
    PCONSOLE_PROCESS_INFO pcpi)
{
    NTSTATUS  Status;
    PEPROCESS Process;
    BOOL retval;

    /*
     * First search for this process in our process information list.
     */
    LeaveCrit();
    Status = LockProcessByClientId((HANDLE)LongToHandle( pcpi->dwProcessID ), &Process);
    EnterCrit();

    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_WARNING, "xxxUserNotifyConsoleApplication: Failed with Process ID == %X, Status = %x\n",
                pcpi->dwProcessID, Status);
        return;
    }

    retval = xxxSetProcessInitState(Process, 0);
    /*
     * Bug 273518 - joejo
     *
     * This will allow console windows to set foreground correctly on new
     * process' it launches, as opposed it just forcing foreground.
     */
    if (retval) {
        if (pcpi->dwFlags & CPI_NEWPROCESSWINDOW) {
            PPROCESSINFO ppiCurrent = PpiCurrent();
            if (CheckAllowForeground(Process)) {
                if (!(ppiCurrent->W32PF_Flags & W32PF_APPSTARTING)) {
                    SetAppStarting(ppiCurrent);
                }
                SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
                TAGMSG0(DBGTAG_FOREGROUND, "xxxUserNotifyConsoleApplication set PUDF");
                ppiCurrent->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
            }

            TAGMSG3(DBGTAG_FOREGROUND, "xxxUserNotifyConsoleApplication %s W32PF %#p-%#p",
                    ((ppiCurrent->W32PF_Flags & W32PF_ALLOWFOREGROUNDACTIVATE) ? "set" : "NOT"),
                    ppiCurrent, PpiFromProcess(Process));
        }
    } else {
        RIPMSG1(RIP_WARNING, "xxxUserNotifyConsoleApplication - SetProcessInitState failed on %#p", Process);
    }

    UnlockProcess(Process);
}


/***************************************************************************\
* UserSetConsoleProcessWindowStation
*
* This is called by the console init code - it tells us that the starting
* application is a console application and which window station they are
* associated with. The window station pointer is stored in the EPROCESS for
* the Global atom calls to find the correct global atom table when called from
* a console application
*
\***************************************************************************/
VOID UserSetConsoleProcessWindowStation(
    DWORD idProcess,
    HWINSTA hwinsta)
{
    NTSTATUS  Status;
    PEPROCESS Process;

    /*
     * First search for this process in our process information list.
     */
    LeaveCrit();
    Status = LockProcessByClientId((HANDLE)LongToHandle( idProcess ), &Process);
    EnterCrit();

    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_WARNING, "UserSetConsoleProcessWindowStation: Failed with Process ID == %X, Status = %x\n",
                idProcess, Status);
        return;
    }

    PsSetProcessWindowStation(Process, hwinsta);

    UnlockProcess(Process);
}


/***************************************************************************\
* xxxUserNotifyProcessCreate
*
* This is a special notification that we get from the base while process data
* structures are being created, but before the process has started. We use
* this notification for startup synchronization matters (winexec, startup
* activation, type ahead, etc).
*
* This notification is called on the server thread for the client thread
* starting the process.
*
* 09-09-91 ScottLu      Created.
\***************************************************************************/

BOOL xxxUserNotifyProcessCreate(
    DWORD idProcess,
    DWORD idParentThread,
    ULONG_PTR dwData,
    DWORD dwFlags)
{
    PEPROCESS Process;
    PETHREAD Thread;
    PTHREADINFO pti;
    NTSTATUS Status;
    BOOL retval;

    CheckCritIn();


    GiveForegroundActivateRight(LongToHandle(idProcess));

    /*
     * 0x1 bit means give feedback (app start cursor).
     * 0x2 bit means this is a gui app (meaning, call CreateProcessInfo()
     *     so we get app start synchronization (WaitForInputIdle()).
     * 0x8 bit means this process is a WOW process, set W32PF_WOW. 0x1
     *     and 0x2 bits will also be set.
     * 0x4 value means this is really a shared WOW task starting
     */

    /*
     * If we want feedback, we need to create a process info structure,
     * so do it: it will be properly cleaned up.
     */
    if ((dwFlags & 0xb) != 0) {
        LeaveCrit();
        Status = LockProcessByClientId((HANDLE)LongToHandle( idProcess ), &Process);
        EnterCrit();

        if (!NT_SUCCESS(Status)) {
            RIPMSG2(RIP_WARNING, "xxxUserNotifyProcessCreate: Failed with Process ID == %X, Status = %x\n",
                    idProcess, Status);
            return FALSE;
        }

        retval = xxxSetProcessInitState(Process, ((dwFlags & 1) ? STARTF_FORCEONFEEDBACK : STARTF_FORCEOFFFEEDBACK));
        if (!retval) {
            RIPMSG1(RIP_WARNING, "xxxUserNotifyProcessCreate - SetProcessInitState failed on %#p", Process);
        }
        if (dwFlags & 0x8) {
            PPROCESSINFO ppi;
            ppi = PsGetProcessWin32Process(Process);
            if (ppi != NULL)
                ppi->W32PF_Flags |= W32PF_WOW;
        }

        UnlockProcess(Process);

        /*
         * Find out who is starting this app. If it is a 16 bit app, allow
         * it to bring itself back to the foreground if it calls
         * SetActiveWindow() or SetFocus(). This is because this could be
         * related to OLE to DDE activation. Notes has a case where after it
         * lauches pbrush to edit an embedded bitmap, it brings up a message
         * box on top if the bitmap is read only. This message box won't appear
         * foreground unless we allow it to. This usually isn't a problem
         * because most apps don't bring up windows on top of editors
         * like this. 32 bit apps will call SetForegroundWindow().
         */

        LeaveCrit();
        Status = LockThreadByClientId((HANDLE)LongToHandle( idParentThread ), &Thread);
        EnterCrit();

        if (!NT_SUCCESS(Status)) {
            RIPMSG2(RIP_WARNING, "xxxUserNotifyProcessCreate: Failed with Thread ID == %X, Status = %x\n",
                    idParentThread, Status);
            return FALSE;
        }

        pti = PtiFromThread(Thread);
        if (pti && (pti->TIF_flags & TIF_16BIT)) {
            pti->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxUserNotifyProcessCreate set TIF %#p", pti);
        }

        UnlockThread(Thread);

    } else if (dwFlags == 4) {
        /*
         * A WOW task is starting up. Create the WOW per thread info
         * structure here in case someone calls WaitForInputIdle
         * before the thread is created.
         */
        PWOWTHREADINFO pwti;

        /*
         * Look for a matching thread in the WOW thread info list.
         */
        for (pwti = gpwtiFirst; pwti != NULL; pwti = pwti->pwtiNext) {
            if (pwti->idTask == idProcess) {
                break;
            }
        }

        /*
         * If we didn't find one, allocate a new one and add it to
         * the head of the list.
         */
        if (pwti == NULL) {
            pwti = (PWOWTHREADINFO)UserAllocPoolWithQuota(
                    sizeof(WOWTHREADINFO), TAG_WOWTHREADINFO);
            if (pwti == NULL) {
                return FALSE;
            }
            INIT_PSEUDO_EVENT(&pwti->pIdleEvent);
            pwti->idTask = idProcess;
            pwti->pwtiNext = gpwtiFirst;
            gpwtiFirst = pwti;
        } else {
            RESET_PSEUDO_EVENT(&pwti->pIdleEvent);
        }

        pwti->idWaitObject = dwData;
        LeaveCrit();
        Status = LockThreadByClientId((HANDLE)LongToHandle( idParentThread ), &Thread);
        EnterCrit();
        if (!NT_SUCCESS(Status))
            return FALSE;

        if (!NT_SUCCESS(Status)) {
            RIPMSG2(RIP_WARNING, "xxxUserNotifyProcessCreate: Failed with Thread ID == %X, Status = %x\n",
                    idParentThread, Status);
            return FALSE;
        }

        pwti->idParentProcess = HandleToUlong(PsGetThreadProcessId(Thread));
        UnlockThread(Thread);
    }

    return TRUE;
}


/***************************************************************************\
* zzzCalcStartCursorHide
*
* Calculates when to hide the startup cursor.
*
* 05-14-92 ScottLu      Created.
\***************************************************************************/
VOID zzzCalcStartCursorHide(
    PW32PROCESS pwp,
    DWORD timeAdd)
{
    DWORD timeNow;
    PW32PROCESS pwpT;
    PW32PROCESS *ppwpT;


    timeNow = NtGetTickCount();

    if (pwp != NULL) {

        /*
         * We were passed in a timeout. Recalculate when we timeout
         * and add the pwp to the starting list.
         */
        if (!(pwp->W32PF_Flags & W32PF_STARTGLASS)) {

            /*
             * Add it to the list only if it is not already in the list
             */
            for (pwpT = gpwpCalcFirst; pwpT != NULL; pwpT = pwpT->NextStart) {
                if (pwpT == pwp)
                    break;
            }

            if (pwpT != pwp) {
                pwp->NextStart = gpwpCalcFirst;
                gpwpCalcFirst = pwp;
            }
        }
        pwp->StartCursorHideTime = timeAdd + timeNow;
        pwp->W32PF_Flags |= W32PF_STARTGLASS;
    }

    gtimeStartCursorHide = 0;
    for (ppwpT = &gpwpCalcFirst; (pwpT = *ppwpT) != NULL; ) {

        /*
         * If the app isn't starting or feedback is forced off, remove
         * it from the list so we don't look at it again.
         */
        if (!(pwpT->W32PF_Flags & W32PF_STARTGLASS) ||
                (pwpT->W32PF_Flags & W32PF_FORCEOFFFEEDBACK)) {
            *ppwpT = pwpT->NextStart;
            continue;
        }

        /*
         * Find the greatest hide cursor timeout value.
         */
        if (gtimeStartCursorHide < pwpT->StartCursorHideTime)
            gtimeStartCursorHide = pwpT->StartCursorHideTime;

        /*
         * If this app has timed out, it isn't starting anymore!
         * Remove it from the list.
         */
        if (ComputeTickDelta(timeNow, pwpT->StartCursorHideTime) > 0) {
            pwpT->W32PF_Flags &= ~W32PF_STARTGLASS;
            *ppwpT = pwpT->NextStart;
            continue;
        }

        /*
         * Step to the next pwp in the list.
         */
        ppwpT = &pwpT->NextStart;
    }

    /*
     * If the hide time is still less than the current time, then turn off
     * the app starting cursor.
     */
    if (gtimeStartCursorHide <= timeNow)
        gtimeStartCursorHide = 0;

    /*
     * Update the cursor image with the new info (doesn't do anything unless
     * the cursor is really changing).
     */
    zzzUpdateCursorImage();
}


#define QUERY_VALUE_BUFFER 80

/*
 * Install hack.
 *
 * We have a hack inherited from Chicago that allows the shell to
 * clean up registry information after a setup program runs. A
 * setup program is defined as an app with one of a list of names. -- FritzS
 */

PUNICODE_STRING gpastrSetupExe;    // These are initialized in the routine
int giSetupExe;                    // CreateSetupNameArray in setup.c


/***************************************************************************\
* SetAppImeCompatFlags - NOTE pstrModName->Buffer must be zero terminated.
*
*
* History:
* 07-17-97 DaveHart Split from SetAppCompatFlags -- misleadingly it also
*                   returns a BOOL indicating whether the filename is
*                   recognized as a setup program. Used by SetAppCompatFlags
*                   for 32-bit apps and zzzInitTask for 16-bit ones.
\***************************************************************************/
BOOL SetAppImeCompatFlags(
    PTHREADINFO pti,
    PUNICODE_STRING pstrModName,
    PUNICODE_STRING pstrBaseFileName)
{
    DWORD dwImeFlags = 0;
    WCHAR szHex[QUERY_VALUE_BUFFER];
    WORD wPrimaryLangID;
    LCID lcid;
    int iSetup;
    BOOL fSetup = FALSE;
    int iAppName;
    int cAppNames;
    PUNICODE_STRING rgpstrAppNames[2];
    UNICODE_STRING strHex;

    /*
     * Because can't access pClientInfo of another process
     */
    UserAssert(pti->ppi == PpiCurrent());

    /*
     * Because it is used as a zero-terminated profile key name.
     */
    UserAssert(pstrModName->Buffer[pstrModName->Length / sizeof(WCHAR)] == 0);

    if (FastGetProfileStringW(
                NULL,
                PMAP_IMECOMPAT,
                pstrModName->Buffer,
                NULL,
                szHex,
                ARRAY_SIZE(szHex),
                0)) {

        /*
         * Found some flags. Attempt to convert the hex string
         * into numeric value. Specify base 0, so
         * RtlUnicodeStringToInteger will handle the 0x format.
         */
        RtlInitUnicodeString(&strHex, szHex);
        RtlUnicodeStringToInteger(&strHex, 0, (PULONG)&dwImeFlags);
    }

    /*
     * If current layout is not IME layout, we don't need to get
     * compatible flags for IME. But now, we don't have any scheme
     * to get this flags when the keyboard layout is switched. Then
     * we get it here, even this flags are not nessesary for non-IME
     * keyboard layouts.
     */
    ZwQueryDefaultLocale(FALSE, &lcid);
    wPrimaryLangID = PRIMARYLANGID(lcid);

    if ((wPrimaryLangID == LANG_KOREAN || wPrimaryLangID == LANG_JAPANESE) &&
            (LOWORD(pti->dwExpWinVer) <= VER31)) {
        /*
         * IME compatibility flags are needed even if it's a 32 bit app.
         */
        pti->ppi->dwImeCompatFlags = dwImeFlags;
    } else {
        pti->ppi->dwImeCompatFlags = dwImeFlags & (IMECOMPAT_NOFINALIZECOMPSTR | IMECOMPAT_HYDRACLIENT);
        if (dwImeFlags & IMECOMPAT_NOFINALIZECOMPSTR) {
            RIPMSG1(RIP_WARNING, "IMECOMPAT_NOFINALIZECOMPSTR is set to ppi=%#p", pti->ppi);
        }
        if (dwImeFlags & IMECOMPAT_HYDRACLIENT) {
            RIPMSG1(RIP_WARNING, "IMECOMPAT_HYDRACLIENT is set to ppi=%#p", pti->ppi);
        }
    }


    if (gpastrSetupExe == NULL) {
        return fSetup;
    }

    rgpstrAppNames[0] = pstrModName;
    cAppNames = 1;
    if (pstrBaseFileName) {
        rgpstrAppNames[1] = pstrBaseFileName;
        cAppNames = 2;
    }

    for (iAppName = 0;
         iAppName < cAppNames && !fSetup;
         iAppName++) {

        iSetup = 0;
        while (iSetup < giSetupExe) {
            if (RtlCompareUnicodeString(rgpstrAppNames[iAppName], &(gpastrSetupExe[iSetup]), TRUE) == 0) {
                fSetup = TRUE;
                break;
            }
            iSetup++;
        }
    }

    return fSetup;
}

/***************************************************************************\
* SetAppCompatFlags
*
*
* History:
* 03-23-92 JimA     Created.
* 07-17-97 FritzS   add return for fSetup -- returns TRUE if app is a setup app.
* 09-03-97 DaveHart Split out IME, WOW doesn't use this function anymore.
* 07-14-98 MCostea  Add Compatibility2 flags
* 01-21-99 MCostea  Add DesiredOSVersion
\***************************************************************************/
BOOL SetAppCompatFlags(
    PTHREADINFO pti)
{
    DWORD dwFlags = 0;
    DWORD dwFlags2 = 0;
    WCHAR szHex[QUERY_VALUE_BUFFER];
    WCHAR szKey[90];
    WCHAR *pchStart, *pchEnd;
    DWORD cb;
    PUNICODE_STRING pstrAppName;
    UNICODE_STRING strKey;
    UNICODE_STRING strImageName;

    /*
     * Because can't access pClientInfo of another process.
     */
    UserAssert(pti->ppi == PpiCurrent());

    UserAssert(pti->ppi->ptiList);

    UserAssert(!(pti->TIF_flags & TIF_16BIT));

    /*
     * We assume here that pti was just inserted in at the head of ptiList
     */
    UserAssert(pti == pti->ppi->ptiList);

    if (pti->ptiSibling) {
        pti->pClientInfo->dwCompatFlags = pti->dwCompatFlags = pti->ptiSibling->dwCompatFlags;
        pti->pClientInfo->dwCompatFlags2 = pti->dwCompatFlags2 = pti->ptiSibling->dwCompatFlags2;
        return FALSE;
    }

    try {
        PPEB ppeb = PsGetProcessPeb(PsGetThreadProcess(pti->pEThread));
        struct _RTL_USER_PROCESS_PARAMETERS *ProcessParameters;

        /*
         * PEB can be trashed from the client side, so we need to probe pointers in it
         * MCostea 317180
         */
        /*
         * Find end of app name
         */
        if (pti->pstrAppName != NULL) {
            pstrAppName = pti->pstrAppName;
        } else {

            ProbeForRead(ppeb, sizeof(PEB), sizeof(BYTE));
            ProcessParameters = ppeb->ProcessParameters;

            ProbeForRead(ProcessParameters, sizeof(*ProcessParameters), sizeof(BYTE));
            strImageName = ProbeAndReadUnicodeString(&ProcessParameters->ImagePathName);
            ProbeForReadUnicodeStringBuffer(strImageName);
            pstrAppName = &strImageName;
        }
        pchStart = pchEnd = pstrAppName->Buffer +
                (pstrAppName->Length / sizeof(WCHAR));

        /*
         * Locate start of extension
         */
        while (TRUE) {
            if (pchEnd == pstrAppName->Buffer) {
                pchEnd = pchStart;
                break;
            }

            if (*pchEnd == TEXT('.')) {
                break;
            }

            pchEnd--;
        }

        /*
         * Locate start of filename
         */
        pchStart = pchEnd;

        while (pchStart != pstrAppName->Buffer) {
            if (*pchStart == TEXT('\\') || *pchStart == TEXT(':')) {
                pchStart++;
                break;
            }

            pchStart--;
        }

    #define MODULESUFFIXSIZE    (8 * sizeof(WCHAR))
    #define MAXMODULENAMELEN    (sizeof(szKey) - MODULESUFFIXSIZE)
        /*
         * Get a copy of the filename
         * Allow extra spaces for the 'ImageSubsystemMajorVersionMinorVersion'
         * i.e. 3.5 that will get appended at the end of the module name
         */
        cb = (DWORD)(pchEnd - pchStart) * sizeof(WCHAR);
        if (cb >= MAXMODULENAMELEN)
            cb = MAXMODULENAMELEN - sizeof(WCHAR);
        RtlCopyMemory(szKey, pchStart, cb);

        /*
         * Get the compat2 flags from the PEB. The appcompat infrastructure
         * gets the flags from the shim database.
         */
        pti->dwCompatFlags2 = ppeb->AppCompatFlagsUser.LowPart;
        pti->pClientInfo->dwCompatFlags2 = pti->dwCompatFlags2;
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) {
        return FALSE;
    }

    szKey[(cb / sizeof(WCHAR))] = 0;
#undef MAXMODULENAMELEN

    if (FastGetProfileStringW(
                NULL,
                PMAP_COMPAT32,
                szKey,
                NULL,
                szHex,
                ARRAY_SIZE(szHex),
                0)) {

        UNICODE_STRING strHex;

        /*
         * Found some flags. Attempt to convert the hex string
         * into numeric value. Specify base 0, so
         * RtlUnicodeStringToInteger will handle the 0x format
         */
        RtlInitUnicodeString(&strHex, szHex);
        RtlUnicodeStringToInteger(&strHex, 0, (PULONG)&dwFlags);
    }

    pti->dwCompatFlags = dwFlags;
    pti->pClientInfo->dwCompatFlags = dwFlags;

    /*
     * Restore the string
     */
    szKey[(cb / sizeof(WCHAR))] = 0;
    RtlInitUnicodeString(&strKey, szKey);

    return SetAppImeCompatFlags(pti, &strKey, NULL);
}

/***************************************************************************\
* GetAppCompatFlags
*
* Compatibility flags for < Win 3.1 apps running on 3.1
*
* History:
* 04-??-92 ScottLu      Created.
* 05-04-92 DarrinM      Moved to USERRTL.DLL.
\***************************************************************************/
DWORD GetAppCompatFlags(
    PTHREADINFO pti)
{
    // From GRE with pti = NULL
    // We got to use PtiCurrentShared()
    if (pti == NULL)
        pti = PtiCurrentShared();

    return pti->dwCompatFlags;
}
/***************************************************************************\
* GetAppCompatFlags2
*
* Compatibility flags for < wVer apps
*
* History:
* 07-01-98 MCostea      Created.
\***************************************************************************/
DWORD GetAppCompatFlags2(
    WORD wVer)
{
    return GetAppCompatFlags2ForPti(PtiCurrentShared(), wVer);
}

DWORD GetAppImeCompatFlags(
    PTHREADINFO pti)
{
    if (pti == NULL) {
        pti = PtiCurrentShared();
    }

    return pti->ppi->dwImeCompatFlags;
}

/***************************************************************************\
* CheckAppStarting
*
* This is a timer proc (see SetAppStarting) which removes ppi's from the
* starting list once their initialization time has expired.
*
* History:
* 08/26/97 GerardoB     Created
\***************************************************************************/
VOID CheckAppStarting(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    LARGE_INTEGER liStartingTimeout;
    PPROCESSINFO *pppi = &gppiStarting;

    KeQuerySystemTime(&liStartingTimeout); /* 1 unit == 100ns */
    liStartingTimeout.QuadPart -= (LONGLONG)(CMSAPPSTARTINGTIMEOUT * 10000);
    while (*pppi != NULL) {
        if (liStartingTimeout.QuadPart  > PsGetProcessCreateTimeQuadPart((*pppi)->Process)) {
            (*pppi)->W32PF_Flags &= ~(W32PF_APPSTARTING | W32PF_ALLOWFOREGROUNDACTIVATE);
            TAGMSG1(DBGTAG_FOREGROUND, "CheckAppStarting clear W32PF %#p", *pppi);
            *pppi = (*pppi)->ppiNext;
        } else {
            pppi = &(*pppi)->ppiNext;
        }
    }

    TAGMSG0(DBGTAG_FOREGROUND, "Removing all entries from ghCanActivateForegroundPIDs array");
    RtlZeroMemory(ghCanActivateForegroundPIDs, sizeof(ghCanActivateForegroundPIDs));

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);
}

/***************************************************************************\
* SetAppStarting
*
* Add a process to the starting list and mark it as such. The process will
* remain in the list until it activates a window, our timer goes off or the
* process goes away, whichever happens first.
*
* History:
* 08/26/97 GerardoB     Created
\***************************************************************************/
VOID SetAppStarting(
    PPROCESSINFO ppi)
{
    static UINT_PTR guAppStartingId = 0;

    /*
     * This ppi had better not be in the list already, or we will be creating
     * a loop (as seen in stress).
     */
    UserAssert((ppi->W32PF_Flags & W32PF_APPSTARTING) == 0);

    /*
     * If we add this to the gppiStartingList without this bit set, we will
     * skip removing it from the list in DestroyProcessInfo(), but continue
     * to free it in FreeW32Process called by W32pProcessCallout.
     */
    UserAssert((ppi->W32PF_Flags & W32PF_PROCESSCONNECTED));

    ppi->W32PF_Flags |= W32PF_APPSTARTING;
    ppi->ppiNext = gppiStarting;
    gppiStarting = ppi;
    /*
     * Some system processes are initialized before the RIT has setup the master
     * timer, so check for it.
     */
    if (gptmrMaster != NULL) {
        guAppStartingId = InternalSetTimer(NULL, guAppStartingId,
                                           CMSAPPSTARTINGTIMEOUT + CMSHUNGAPPTIMEOUT,
                                           CheckAppStarting, TMRF_RIT | TMRF_ONESHOT);
    }
}

/***************************************************************************\
* ClearAppStarting
*
* Remove a process from the app starting list and clear the W32PF_APPSTARTING
* flag. No major action here, just a centralized place to take care of this.
*
* History:
* 08/26/97 GerardoB     Created
\***************************************************************************/
VOID ClearAppStarting(
    PPROCESSINFO ppi)
{
    REMOVE_FROM_LIST(PROCESSINFO, gppiStarting, ppi, ppiNext);
    ppi->W32PF_Flags &= ~W32PF_APPSTARTING;
}

/***************************************************************************\
* zzzInitTask -- called by WOW startup for each app
*
*
* History:
* 02-21-91 MikeHar  Created.
* 02-23-92 MattFe   Altered for WOW
* 09-03-97 DaveHart WOW supplies compat flags, we tell it about setup apps.
\***************************************************************************/
NTSTATUS zzzInitTask(
    UINT dwExpWinVer,
    DWORD dwAppCompatFlags,
    DWORD dwUserWOWCompatFlags,
    PUNICODE_STRING pstrModName,
    PUNICODE_STRING pstrBaseFileName,
    DWORD hTaskWow,
    DWORD dwHotkey,
    DWORD idTask,
    DWORD dwX,
    DWORD dwY,
    DWORD dwXSize,
    DWORD dwYSize)
{
    PTHREADINFO ptiCurrent;
    PTDB ptdb;
    PPROCESSINFO ppi;
    PWOWTHREADINFO pwti;

    ptiCurrent = PtiCurrent();
    ppi = ptiCurrent->ppi;

    /*
     * Set the real name of the module. (Instead of 'NTVDM')
     * We've already probed pstrModName->Buffer for Length+sizeof(WCHAR) so
     * we can copy the UNICODE_NULL terminator as well.
     */
    if (ptiCurrent->pstrAppName != NULL) {
        UserFreePool(ptiCurrent->pstrAppName);
    }
    ptiCurrent->pstrAppName = UserAllocPoolWithQuota(sizeof(UNICODE_STRING) +
            pstrModName->Length + sizeof(WCHAR), TAG_TEXT);
    if (ptiCurrent->pstrAppName != NULL) {
        ptiCurrent->pstrAppName->Buffer = (PWCHAR)(ptiCurrent->pstrAppName + 1);
        try {
            RtlCopyMemory(ptiCurrent->pstrAppName->Buffer, pstrModName->Buffer,
                    pstrModName->Length);
            ptiCurrent->pstrAppName->Buffer[pstrModName->Length / sizeof(WCHAR)] = 0;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            UserFreePool(ptiCurrent->pstrAppName);
            ptiCurrent->pstrAppName = NULL;
            return STATUS_OBJECT_NAME_INVALID;
        }
        ptiCurrent->pstrAppName->MaximumLength = pstrModName->Length + sizeof(WCHAR);
        ptiCurrent->pstrAppName->Length = pstrModName->Length;
    } else
        return STATUS_OBJECT_NAME_INVALID;

    /*
     * An app is starting!
     */
    if (!(ppi->W32PF_Flags & W32PF_APPSTARTING)) {
        SetAppStarting(ppi);
    }

    /*
     * We never want to use the ShowWindow defaulting mechanism for WOW
     * apps. If STARTF_USESHOWWINDOW was set in the client-side
     * STARTUPINFO structure, WOW has already picked it up and used
     * it for the first (command-line) app.
     */
    ppi->usi.dwFlags &= ~STARTF_USESHOWWINDOW;

    /*
     * If WOW passed us a hotkey for this app, save it for CreateWindow's use.
     */
    if (dwHotkey != 0) {
        ppi->dwHotkey = dwHotkey;
    }

    /*
     * If WOW passed us a non-default window position use it, otherwise clear it.
     */
    ppi->usi.cb = sizeof(ppi->usi);

    if (dwX == CW_USEDEFAULT || dwX == CW2_USEDEFAULT) {
        ppi->usi.dwFlags &= ~STARTF_USEPOSITION;
    } else {
        ppi->usi.dwFlags |= STARTF_USEPOSITION;
        ppi->usi.dwX = dwX;
        ppi->usi.dwY = dwY;
    }

    /*
     * If WOW passed us a non-default window size use it, otherwise clear it.
     */
    if (dwXSize == CW_USEDEFAULT || dwXSize == CW2_USEDEFAULT) {
        ppi->usi.dwFlags &= ~STARTF_USESIZE;
    } else {
        ppi->usi.dwFlags |= STARTF_USESIZE;
        ppi->usi.dwXSize = dwXSize;
        ppi->usi.dwYSize = dwYSize;
    }

    /*
     * Alloc and Link in new task into the task list
     */

    if ((ptdb = (PTDB)UserAllocPoolWithQuota(sizeof(TDB), TAG_WOWTDB)) == NULL)
        return STATUS_NO_MEMORY;

    ptiCurrent->ptdb = ptdb;

    /*
     * Save away the 16 bit task handle: we use this later when calling
     * wow back to close a WOW task.
     */
    ptdb->hTaskWow = LOWORD(hTaskWow);

    ptiCurrent->dwCompatFlags = dwAppCompatFlags;
    ptiCurrent->pClientInfo->dwCompatFlags = dwAppCompatFlags;

    UserAssert(ptiCurrent->ppi->ptiList);

    dwUserWOWCompatFlags &= COMPATFLAGS2_FORWOW;
    ptiCurrent->dwCompatFlags2 = dwUserWOWCompatFlags;
    ptiCurrent->pClientInfo->dwCompatFlags2 = dwUserWOWCompatFlags;

    /*
     * HIWORD: != 0 if wants proportional font
     * LOWORD: Expected windows version (3.00 [300], 3.10 [30A], etc)
     */
    ptiCurrent->dwExpWinVer = dwExpWinVer;
    ptiCurrent->pClientInfo->dwExpWinVer = dwExpWinVer;

    /*
     * We haven't captured pstrBaseFileName's buffer, we
     * may fault touching it in SetAppImeCompatFlags. If
     * so the IME flags have been set already and we
     * can safely assume it's not a setup app.
     */

    try {
        if (SetAppImeCompatFlags(ptiCurrent, ptiCurrent->pstrAppName,
                             pstrBaseFileName)) {
            /*
             * Flag task as a setup app.
             */
            ptdb->TDB_Flags = TDBF_SETUP;
            ppi->W32PF_Flags |= W32PF_SETUPAPP;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }


    /*
     * Set the flags to say this is a TIF_MEOW
     * queues!
     */

    if(hTaskWow & HTW_ISMEOW) {
       ptiCurrent->TIF_flags |= TIF_MEOW;
    }

    if(hTaskWow & HTW_IS16BIT) {
       ptiCurrent->TIF_flags |= TIF_16BIT | TIF_FIRSTIDLE;
    }
    else {
       ptiCurrent->pClientInfo->dwTIFlags |= ptiCurrent->TIF_flags;
    }

    if(hTaskWow & HTW_IS16BIT) {

       /* jarbats
        * Set the flags to say this is a 16-bit thread - before attaching
        * queues!
        */

       /*
        * If this task is running in the shared WOW VDM, we handle
        * WaitForInputIdle a little differently than separate WOW
        * VDMs. This is because CreateProcess returns a real process
        * handle when you start a separate WOW VDM, so the "normal"
        * WaitForInputIdle works. For the shared WOW VDM, CreateProcess
        * returns an event handle.
        */
        ptdb->pwti = NULL;
        if (idTask) {
            ptiCurrent->TIF_flags |= TIF_SHAREDWOW;

            /*
             * Look for a matching thread in the WOW thread info list.
             */
            if (idTask != (DWORD)-1) {
                for (pwti = gpwtiFirst; pwti != NULL; pwti = pwti->pwtiNext) {
                     if (pwti->idTask == idTask) {
                         ptdb->pwti = pwti;
                         break;
                     }
                }
#if DBG
                if (pwti == NULL) {
                    RIPMSG0(RIP_WARNING, "InitTask couldn't find WOW struct\n");
                }
#endif
            }
        }
        ptiCurrent->pClientInfo->dwTIFlags |= ptiCurrent->TIF_flags;

        /*
         * We need this thread to share the queue of other win16 apps.
         * If we're journalling, all apps are sharing a queue, so we wouldn't
         * want to interrupt that - so only cause queue recalculation
         * if we aren't journalling.
         * ptdb may be freed by DestroyTask during a callback, so defer WinEvent
         * notifications until we don't need ptdb any more.
         */
        DeferWinEventNotify();
        if (!FJOURNALRECORD() && !FJOURNALPLAYBACK())
            zzzReattachThreads(FALSE);

        /*
         * Setup the app start cursor for 5 second timeout.
         */
        zzzCalcStartCursorHide((PW32PROCESS)ppi, 5000);

        /*
         * Mark this guy and add him to the global task list so he can run.
         */
        #define NORMAL_PRIORITY_TASK 10

        /*
         * To be Compatible it super important that the new task run immediately
         * Set its priority accordingly. No other task should ever be set to
         * CREATION priority
         */
        ptdb->nPriority = NORMAL_PRIORITY_TASK;
        ptdb->nEvents = 0;
        ptdb->pti = ptiCurrent;
        ptdb->ptdbNext = NULL;
        ptdb->TDB_Flags = 0;

        InsertTask(ppi, ptdb);
        zzzEndDeferWinEventNotify();


        /*
         * Force this new task to be the active task (WOW will ensure the
         * currently running task does a Yield which will put it into the
         * non preemptive scheduler.
         */
        ppi->pwpi->ptiScheduled = ptiCurrent;
        ppi->pwpi->CSLockCount = -1;

        EnterWowCritSect(ptiCurrent, ppi->pwpi);

        /*
         * ensure app gets focus
         */
        zzzShowStartGlass(10000);
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* zzzShowStartGlass
*
* This routine is called by WOW when first starting or when starting an
* additional WOW app.
*
* 12-07-92 ScottLu      Created.
\***************************************************************************/
VOID zzzShowStartGlass(
    DWORD dwTimeout)
{
    PPROCESSINFO ppi;

    /*
     * If this is the first call to zzzShowStartGlass(), then the
     * W32PF_ALLOWFOREGROUNDACTIVATE bit has already been set in the process
     * info - we don't want to set it again because it may have been
     * purposefully cleared when the user hit a key or mouse clicked.
     */
    ppi = PpiCurrent();
    if (ppi->W32PF_Flags & W32PF_SHOWSTARTGLASSCALLED) {
        /*
         * Allow this wow app to come to the foreground. This'll be cancelled
         * if the user mouse clicks or hits any keys.
         */
        SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
        TAGMSG0(DBGTAG_FOREGROUND, "zzzShowStartGlass set PUDF");
        ppi->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
        TAGMSG1(DBGTAG_FOREGROUND, "zzzShowStartGlass set W32PF %#p", ppi);
}
    ppi->W32PF_Flags |= W32PF_SHOWSTARTGLASSCALLED;

    /*
     * Show the start glass cursor for this much longer.
     */
    zzzCalcStartCursorHide((PW32PROCESS)ppi, dwTimeout);
}
/***************************************************************************\
* GetJournallingQueue
*
* 03/21/97  GerardoB     Created
\***************************************************************************/
PQ GetJournallingQueue(PTHREADINFO pti)
{
    PHOOK phook;
    /*
     * fail if we cannot journal this thread
     */
    if ((pti->TIF_flags & TIF_DONTJOURNALATTACH)
            || (pti->rpdesk == NULL)) {

        return NULL;
    }
    /*
     * Get the journalling hook if any.
     */
    phook = PhkFirstGlobalValid(pti, WH_JOURNALPLAYBACK);
    if (phook == NULL) {
        phook = PhkFirstGlobalValid(pti, WH_JOURNALRECORD);
    }
    /*
     * Validate fsHooks bits.
     */
    UserAssert((phook == NULL)
                ^ IsHooked(pti, (WHF_FROM_WH(WH_JOURNALPLAYBACK) | WHF_FROM_WH(WH_JOURNALRECORD))));

    /*
     * return the queue if we found a journalling hook
     */
    return ((phook == NULL) ? NULL : GETPTI(phook)->pq);
}

/***************************************************************************\
* ClearQueueServerEvent
*
* This function should be called when a thread needs to wait for some kind of
* input. This clears pEventQueueServer which means we won't return from the
* wait until new input of the required type arrives. Setting the wake mask
* controls what input will wake us up. WOW apps skip this since their
* scheduler controls when they wake up.
*
* History:
* 09/12/97 GerardoB     Created
\***************************************************************************/
VOID ClearQueueServerEvent(
    WORD wWakeMask)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    UserAssert(wWakeMask != 0);
    ptiCurrent->pcti->fsWakeMask = wWakeMask;
    KeClearEvent(ptiCurrent->pEventQueueServer);
}

ULONG ParseReserved(
    WCHAR *cczpReserved,
    WCHAR *pchFind)
{
    ULONG dw;
    WCHAR *cczpch, *cczpchT, ch;
    UNICODE_STRING cczuString;

    dw = 0;
    try {
        if (cczpReserved != NULL && (cczpch = wcsstr(cczpReserved, pchFind)) != NULL) {
            cczpch += wcslen(pchFind);

            cczpchT = cczpch;
            while (*cczpchT >= '0' && *cczpchT <= '9')
                cczpchT++;

            ch = *cczpchT;
            *cczpchT = 0;
            RtlInitUnicodeString(&cczuString, cczpch);
            *cczpchT = ch;

            RtlUnicodeStringToInteger(&cczuString, 0, &dw);
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return 0;
    }

    return dw;
}
/*
 * Structure USER_PROCESS_PARAMETERS is used to capture all the fields that
 * we touch in RTL_USER_PROCESS_PARAMETERS (ppeb->ProcessParameters) since the
 * PEB can be trashed from the client side.
 */
typedef struct tagUSER_PROCESS_PARAMETERS {
    HANDLE StandardInput;
    HANDLE StandardOutput;
    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING DesktopInfo;     // ProcessParameters
    UNICODE_STRING ShellInfo;       // ProcessParameters
} USER_PROCESS_PARAMETERS, *PUSER_PROCESS_PARAMETERS;

/***************************************************************************\
* xxxCreateThreadInfo
*
* Allocate the main thread information structure
*
* History:
* 03-18-95 JimA         Created.
* 04-18-01 Mohamed      Modified error recovery wrt hEventQueueClient.
\***************************************************************************/
NTSTATUS xxxCreateThreadInfo(
    PETHREAD pEThread,
    BOOL     IsSystemThread)
{
    DWORD                        dwTIFlags = 0;
    PPROCESSINFO                 ppi;
    PTHREADINFO                  ptiCurrent;
    PEPROCESS                    pEProcess = PsGetThreadProcess(pEThread);
    PUSERSTARTUPINFO             pusi;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PUSER_PROCESS_PARAMETERS     ProcessParams = NULL;
    USER_PROCESS_PARAMETERS      ProcessParamsData;
    PDESKTOP                     pdesk = NULL;
    HDESK                        hdesk = NULL;
    HWINSTA                      hwinsta;
    PQ                           pq;
    NTSTATUS                     Status;
    BOOL                         fFirstThread;
    PTEB                         pteb = NtCurrentTeb();
    TL                           tlpdesk, tlPool;
    PPEB                         ppeb;
    PVOID                        pTmpPool = NULL;

    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    ValidateProcessSessionId(pEProcess);

    /*
     * If CleanupResources was called for the last GUI thread then
     * we should not allow any more GUI threads
     */
    if (gbCleanedUpResources) {
        RIPMSG0(RIP_ERROR, "No more GUI threads should be created");
        return STATUS_PROCESS_IS_TERMINATING;
    }

    /*
     * Increment the number of GUI threads in the session
     */
    gdwGuiThreads++;

    /*
     * Although all threads now have a ETHREAD structure, server-side
     * threads (RIT, Console, etc) don't have a client-server eventpair
     * handle. We use this to distinguish the two cases.
     */

    if (IsSystemThread) {
        dwTIFlags = TIF_SYSTEMTHREAD | TIF_DONTATTACHQUEUE | TIF_DISABLEIME;
    }

    if (!(dwTIFlags & TIF_SYSTEMTHREAD) && pEProcess == gpepCSRSS) {
        dwTIFlags = TIF_CSRSSTHREAD | TIF_DONTATTACHQUEUE | TIF_DISABLEIME;
    }

    /*
     * Allocate the thread-info structure. If it's a SYSTEMTHREAD, then
     * make sure we have enough space for the (pwinsta) pointer. This
     * is referenced in (paint.c: DoPaint) to assure desktop/input can
     * have a winsta to view.
     */
    ptiCurrent = (PTHREADINFO)PsGetThreadWin32Thread(pEThread);

    ProcessParamsData.DesktopInfo.Buffer = NULL;
    try {
        /*
         * PEB can be trashed from the client side, so we need to probe it
         * and then capture it in ProcessParamsData.
         *
         * NOTE: We allocate memory for the DesktopInfo.Buffer and free it
         * later. For ShellInfo we do not since ParseReserved handles user-mode
         * pointers.
         */
        ppeb = PsGetProcessPeb(pEProcess);

        if (ppeb != NULL) {
            ProbeForRead(ppeb, sizeof(PEB), sizeof(BYTE));
            ProcessParameters = ppeb->ProcessParameters;
            ProcessParams = &ProcessParamsData;
            ProbeForRead(ProcessParameters, sizeof(RTL_USER_PROCESS_PARAMETERS), sizeof(BYTE));
            ProcessParamsData.StandardInput = ProcessParameters->StandardInput;
            ProcessParamsData.StandardOutput = ProcessParameters->StandardOutput;
            ProcessParamsData.StartingX = ProcessParameters->StartingX;
            ProcessParamsData.StartingY = ProcessParameters->StartingY;
            ProcessParamsData.CountX = ProcessParameters->CountX;
            ProcessParamsData.CountY = ProcessParameters->CountY;
            ProcessParamsData.WindowFlags = ProcessParameters->WindowFlags;
            ProcessParamsData.ShowWindowFlags = ProcessParameters->ShowWindowFlags;

            ProcessParamsData.DesktopInfo = ProbeAndReadUnicodeString(&ProcessParameters->DesktopInfo);
            if (ProcessParamsData.DesktopInfo.Length > 0) {
                PWSTR pszCapture = ProcessParamsData.DesktopInfo.Buffer;
                ProbeForReadUnicodeStringBuffer(ProcessParamsData.DesktopInfo);

                /*
                 * The pool pointer is stored in pTmpPool as well as in DesktopInfo.Buffer. The reason 
                 * is that in case of corrupt user mode DesktopInfo an exception is raised which bails
                 * out of this try-except block without properly allocating the new pool. Therefore,
                 * pTmpPool is used in the check before freeing this pool.
                 */
                pTmpPool = UserAllocPoolWithQuota(ProcessParamsData.DesktopInfo.Length, TAG_TEXT2);
                ProcessParamsData.DesktopInfo.Buffer = pTmpPool;
                if (ProcessParamsData.DesktopInfo.Buffer) {
                    ThreadLockPool(ptiCurrent, ProcessParamsData.DesktopInfo.Buffer, &tlPool);
                    RtlCopyMemory(ProcessParamsData.DesktopInfo.Buffer, pszCapture, ProcessParamsData.DesktopInfo.Length);
                } else {
                    ExRaiseStatus(STATUS_NO_MEMORY);
                }
            } else {
                ProcessParamsData.DesktopInfo.Buffer = NULL;
            }

            ProcessParamsData.ShellInfo = ProbeAndReadUnicodeString(&ProcessParameters->ShellInfo);
            ProbeForReadUnicodeStringBuffer(ProcessParamsData.ShellInfo);
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
          Status = GetExceptionCode();
          goto CreateThreadInfoFailed;
    }

    /*
     * Locate the processinfo structure for the new thread.
     */
    ppi = PpiCurrent();

#if defined(_WIN64)
    /*
     * If the process is marked as an emulated 32bit app thus,
     * mark the thread as an emulated 32bit thread.
     * This is to be consistent with the way WOW16 marks threads.
     */
    if (ppi->W32PF_Flags & W32PF_WOW64) {
        dwTIFlags |= TIF_WOW64;
    }
#endif //defined(_WIN64)

    /*
     * For Winlogon, only the first thread can have IME processing.
     */
    if (gpidLogon == PsGetThreadProcessId(pEThread)) {
        if (ppi->ptiList != NULL) {
            dwTIFlags |= TIF_DISABLEIME;
            RIPMSG1(RIP_VERBOSE, "WinLogon, second or other thread. pti=%#p", PsGetThreadWin32Thread(pEThread));
        }
    }

    ptiCurrent->TIF_flags = dwTIFlags;
    Lock(&ptiCurrent->spklActive, gspklBaseLayout);
    ptiCurrent->pcti      = &(ptiCurrent->cti);

    /*
     * Check if no IME processing for all threads
     * in the same process.
     */
    if (ppi->W32PF_Flags & W32PF_DISABLEIME) {
        ptiCurrent->TIF_flags |= TIF_DISABLEIME;
    }

    /*
     * Hook up this queue to this process info structure, increment
     * the count of threads using this process info structure. Set up
     * the ppi before calling SetForegroundPriority().
     */
    UserAssert(ppi != NULL);

    ptiCurrent->ppi        = ppi;
    ptiCurrent->ptiSibling = ppi->ptiList;
    ppi->ptiList    = ptiCurrent;
    ppi->cThreads++;


    if (pteb != NULL) {
        try {
            pteb->Win32ThreadInfo = ptiCurrent;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
              Status = GetExceptionCode();
              goto CreateThreadInfoFailed;
        }
    }

    /*
     * Point to the client info.
     */
    if (dwTIFlags & TIF_SYSTEMTHREAD) {
        ptiCurrent->pClientInfo = UserAllocPoolWithQuota(sizeof(CLIENTINFO),
                                                  TAG_CLIENTTHREADINFO);
        if (ptiCurrent->pClientInfo == NULL) {
            Status = STATUS_NO_MEMORY;
            goto CreateThreadInfoFailed;
        }
    } else {
        /*
         * If this is not a system thread then grab the user mode client info
         * elsewhere we use the GetClientInfo macro which looks here
         */
        UserAssert(pteb != NULL);

        try {
            ptiCurrent->pClientInfo = ((PCLIENTINFO)((pteb)->Win32ClientInfo));
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
              Status = GetExceptionCode();
              goto CreateThreadInfoFailed;
        }

        /*
         * set the SECURE flag in the thread flags if this is a secure process
         */
        if (((PW32PROCESS)ppi)->W32PF_Flags & W32PF_RESTRICTED) {
            ptiCurrent->TIF_flags |= TIF_RESTRICTED;
        }
    }


    /*
     * Create the input event.
     */
    Status = ZwCreateEvent(&ptiCurrent->hEventQueueClient,
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE);

    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle(ptiCurrent->hEventQueueClient,
                                           EVENT_ALL_ACCESS,
                                           *ExEventObjectType,
                                           UserMode,
                                           &ptiCurrent->pEventQueueServer,
                                           NULL);
        if (NT_SUCCESS(Status)) {
            Status = ProtectHandle(ptiCurrent->hEventQueueClient, *ExEventObjectType, TRUE);
        } 
        if (!NT_SUCCESS(Status) && Status != STATUS_INVALID_HANDLE) {
            ObCloseHandle(ptiCurrent->hEventQueueClient, UserMode);
        }
    }
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxCreateThreadInfo: failed a handle routine for hEventQueueClient handle, status=%08x", Status);
        ptiCurrent->hEventQueueClient = NULL;
        goto CreateThreadInfoFailed;
    }

    /*
     * Mark the process as having threads that need cleanup. See
     * DestroyProcessesObjects().
     */
    fFirstThread = !(ppi->W32PF_Flags & W32PF_THREADCONNECTED);
    ppi->W32PF_Flags |= W32PF_THREADCONNECTED;

    /*
     * If we haven't copied over our startup info yet, do it now.
     * Don't bother copying the info if we aren't going to use it.
     */
    if (ProcessParams) {

        pusi = &ppi->usi;

        if ((pusi->cb == 0) && (ProcessParams->WindowFlags != 0)) {
            pusi->cb          = sizeof(USERSTARTUPINFO);
            pusi->dwX         = ProcessParams->StartingX;
            pusi->dwY         = ProcessParams->StartingY;
            pusi->dwXSize     = ProcessParams->CountX;
            pusi->dwYSize     = ProcessParams->CountY;
            pusi->dwFlags     = ProcessParams->WindowFlags;
            pusi->wShowWindow = (WORD)ProcessParams->ShowWindowFlags;
        }

        if (fFirstThread) {

            /*
             * Set up the hot key, if there is one.
             *
             * If the STARTF_USEHOTKEY flag is given in the startup info, then
             * the hStdInput is the hotkey (new from Chicago). Otherwise, parse
             * it out in string format from the lpReserved string.
             */
            if (ProcessParams->WindowFlags & STARTF_USEHOTKEY) {
                ppi->dwHotkey = HandleToUlong(ProcessParams->StandardInput);
            } else {
                if (ProcessParams->ShellInfo.Length > 0) {
                    ppi->dwHotkey = ParseReserved(ProcessParams->ShellInfo.Buffer,
                                                  L"hotkey.");
                } else {
                    ppi->dwHotkey = 0;
                }
            }

            /*
             * Copy the monitor handle, if there is one.
             */
            UserAssert(!ppi->hMonitor);
            if (ProcessParams->WindowFlags & STARTF_HASSHELLDATA) {
                HMONITOR    hMonitor;

                hMonitor = (HMONITOR)(ProcessParams->StandardOutput);
                if (ValidateHmonitor(hMonitor)) {
                    ppi->hMonitor = hMonitor;
                }
            }
        }
    }

    if ((pq = AllocQueue(NULL, NULL)) == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CreateThreadInfoFailed;
    }

    /*
     * Attach the Q to the THREADINFO.
     */
    ptiCurrent->pq = pq;
    pq->ptiMouse = pq->ptiKeyboard = ptiCurrent;
    pq->cThreads++;

    /*
     * Open the windowstation and desktop. If this is a system
     * thread only use the desktop that might be stored in the teb.
     */
    UserAssert(ptiCurrent->rpdesk == NULL);
    if (!(ptiCurrent->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD)) &&
        grpWinStaList) {

        BOOL bShutDown = FALSE;

        hdesk = xxxResolveDesktop(
                NtCurrentProcess(),
                &ProcessParams->DesktopInfo,
                &hwinsta, (ProcessParams->WindowFlags & STARTF_DESKTOPINHERIT),
                &bShutDown);

        if (hdesk == NULL) {

            if (bShutDown) {
                /*
                 * Trying to create a new process during logoff
                 */
                ULONG_PTR adwParameters[5] = {0, 0, 0, 0, MB_DEFAULT_DESKTOP_ONLY};
                ULONG ErrorResponse;

                LeaveCrit();

                ExRaiseHardError((NTSTATUS)STATUS_DLL_INIT_FAILED_LOGOFF,
                                 ARRAY_SIZE(adwParameters),
                                 0,
                                 adwParameters,
                                 OptionOkNoWait,
                                 &ErrorResponse);

                ZwTerminateProcess(NtCurrentProcess(), STATUS_DLL_INIT_FAILED);

                EnterCrit();
            }

            Status = STATUS_DLL_INIT_FAILED;
            goto CreateThreadInfoFailed;

        } else {
            Status = xxxSetProcessWindowStation(hwinsta, UserMode);
            if (!NT_SUCCESS(Status)) {
                goto CreateThreadInfoFailed;
            }

            /*
             * Reference the desktop handle
             */
            Status = ObReferenceObjectByHandle(
                    hdesk,
                    0,
                    *ExDesktopObjectType,
                    KernelMode,
                    &pdesk,
                    NULL);

            if (!NT_SUCCESS(Status)) {
                UserAssert(pdesk == NULL);
                goto CreateThreadInfoFailed;
            }

            ThreadLockDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_CREATETHREADINFO);

            ObDereferenceObject(pdesk);

            /*
             * The first desktop is the default for all succeeding threads.
             */
            if ((ppi->hdeskStartup == NULL) &&
                (PsGetProcessId(pEProcess) != gpidLogon)) {

                LockDesktop(&ppi->rpdeskStartup, pdesk, LDL_PPI_DESKSTARTUP2, (ULONG_PTR)ppi);
                ppi->hdeskStartup = hdesk;
            }
        }
    }

    /*
     * Remember dwExpWinVer. This is used to return GetAppVer() (and
     * GetExpWinVer(NULL).
     */
    if (PsGetProcessPeb(pEProcess) != NULL)
        ptiCurrent->dwExpWinVer = RtlGetExpWinVer(PsGetProcessSectionBaseAddress(pEProcess));
    else
        ptiCurrent->dwExpWinVer = VER40;

    INITCLIENTINFO(ptiCurrent);

    /*
     * Set the desktop even if it is NULL to ensure that ptiCurrent->pDeskInfo
     * is set.
     * NOTE: This adds the pti to the desktop's PtiList, but we don't yet have
     * a pti->pq. zzzRecalcThreadAttachment loops through this PtiList expects
     * a pq, so we must not leave the critsect until we have a queue.
     * zzzSetDesktop only zzz leaves the critsect if there is a pti->pq, so we
     * can BEGINATOMICCHECK to ensure this, and make sure we allocate the queue
     * before we leave the critical section.
     */
    BEGINATOMICCHECK();
    zzzSetDesktop(ptiCurrent, pdesk, hdesk);
    ENDATOMICCHECK();

    /*
     * If we have a desktop and are journalling on that desktop, use
     * the journal queue, otherwise create a new queue.
     */
    if (pdesk == grpdeskRitInput) {
        PQ pq;
        UserAssert((pdesk == NULL) || (ptiCurrent->pDeskInfo == pdesk->pDeskInfo));
        UserAssert(ptiCurrent->rpdesk == pdesk);
        pq = GetJournallingQueue(ptiCurrent);
        if (pq != NULL && pq != ptiCurrent->pq) {

            DestroyThreadsMessages(ptiCurrent->pq, ptiCurrent);
            zzzDestroyQueue(ptiCurrent->pq, ptiCurrent);

            ptiCurrent->pq = pq;
            pq->cThreads++;
        }
    }

    /*
     * Remember that this is a screen saver. That way we can set its
     * priority appropriately when it is idle or when it needs to go
     * away. At first we set it to normal priority, then we set the
     * TIF_IDLESCREENSAVER bit so that when it activates it will get
     * lowered in priority.
     */
    if (ProcessParams && ProcessParams->WindowFlags & STARTF_SCREENSAVER) {

        if (fFirstThread) {
            UserAssert(gppiScreenSaver == NULL);

            /*
             * Make sure the parent's process is WinLogon, since only WinLogon is allowed to
             * use the STARTF_SCREENSAVER flag.
             */
            if (gpidLogon == 0 || PsGetProcessInheritedFromUniqueProcessId(pEProcess) != gpidLogon) {
                RIPMSG0(RIP_WARNING,"Only the Logon process can launch a screen saver.");
                ProcessParams->WindowFlags &= ~STARTF_SCREENSAVER;
                goto NotAScreenSaver;
            }

            gppiScreenSaver = ppi;
            gptSSCursor = gpsi->ptCursor;
            ppi->W32PF_Flags |= W32PF_SCREENSAVER;
        }
#if DBG
        else {
            UserAssert(ppi->W32PF_Flags & W32PF_SCREENSAVER);
        }
#endif

        SetForegroundPriority(ptiCurrent, TRUE);

        if (fFirstThread) {
            ppi->W32PF_Flags |= W32PF_IDLESCREENSAVER;
        }

        /*
         * Screen saver doesn't need any IME processing.
         */
        ptiCurrent->TIF_flags |= TIF_DISABLEIME;
    }

NotAScreenSaver:

    /*
     * Do special processing for the first thread of a process.
     */
    if (!(ptiCurrent->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD))) {

        /*
         * I changed the code a while ago to unregister classes when the last
         * GUI thread is destroyed. Simply, there was too much stuff getting
         * unlocked and destroyed to guarantee that it would work on a non-GUI
         * thread. So if a process destroys its last GUI thread and then makes
         * a thread GUI later, we need to re-register the classes.
         */

        if (!(ppi->W32PF_Flags & W32PF_CLASSESREGISTERED)) {
            if (!LW_RegisterWindows(FALSE)) {
                RIPMSG0(RIP_WARNING, "xxxCreateThreadInfo: LW_RegisterWindows failed");
                Status = STATUS_UNSUCCESSFUL;
                goto CreateThreadInfoFailed;
            }
            ppi->W32PF_Flags |= W32PF_CLASSESREGISTERED;
            if (ptiCurrent->pClientInfo) {
                ptiCurrent->pClientInfo->CI_flags |= CI_REGISTERCLASSES;
            }
        }

        if (fFirstThread) {

            /*
             * If this is an application starting (ie. not some thread of
             * the server context), enable the app-starting cursor.
             */
            DeferWinEventNotify();
            zzzCalcStartCursorHide((PW32PROCESS)PsGetProcessWin32Process(pEProcess), 5000);
            EndDeferWinEventNotifyWithoutProcessing();

            /*
             * Open the windowstation
             */
            if (grpWinStaList && ppi->rpwinsta == NULL) {
                RIPERR0(ERROR_CAN_NOT_COMPLETE, RIP_WARNING, "System is not initialized\n");
                Status = STATUS_UNSUCCESSFUL;
                goto CreateThreadInfoFailed;
            }
        }
    } else {

        /*
         * Don't register system windows until cursors and icons
         * have been loaded.
         */
        if ((SYSCUR(ARROW) != NULL) &&
                !(ppi->W32PF_Flags & W32PF_CLASSESREGISTERED)) {

            ppi->W32PF_Flags |= W32PF_CLASSESREGISTERED;
            if (!LW_RegisterWindows(ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD)) {
                RIPMSG0(RIP_WARNING, "xxxCreateThreadInfo: LW_RegisterWindows failed");
                Status = STATUS_UNSUCCESSFUL;
                goto CreateThreadInfoFailed;
            }
        }
    }


    /*
     * Initialize hung timer value
     */

    SET_TIME_LAST_READ(ptiCurrent);

    /*
     * If someone is waiting on this process propagate that info into
     * the thread info
     */
    if (ppi->W32PF_Flags & W32PF_WAITFORINPUTIDLE)
        ptiCurrent->TIF_flags |= TIF_WAITFORINPUTIDLE;

    /*
     * Mark the thread as initialized.
     */
    ptiCurrent->TIF_flags |= TIF_GUITHREADINITIALIZED;

    /*
     * Allow the thread to come to foreground when it is created
     * if the current process is the foreground process or the last input owner
     * This Flag is a hack to fix Bug 28502. When we click on
     * "Map Network Drive" button on the toolbar, the explorer (Bobday)
     * creates another thread to create the dialog box. This will create
     * the dialog in the background. We are adding this fix at the request
     * of the Shell team so that this dialog comes up as foreground.
     *
     * If the process already has the foreground right, we don't give it
     *  to this thread (it doesn't need it). We do this to narrow the number
     *  of ways this process can force the foreground.
     * Also, if the process is starting, it already has the right unless
     *  the user has canceled it -- in which case we don't want to give it back.
     *
     */
     if (!(ppi->W32PF_Flags & (W32PF_ALLOWFOREGROUNDACTIVATE | W32PF_APPSTARTING))) {
         if (((gptiForeground != NULL) && (ppi == gptiForeground->ppi))
                || ((glinp.ptiLastWoken != NULL) && (ppi == glinp.ptiLastWoken->ppi))) {

            ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxCreateThreadInfo set TIF %#p", ptiCurrent);
         }
     }

    if (IS_IME_ENABLED()) {
        /*
         * Create per-thread default input context
         */
        CreateInputContext(0);
    }

    /*
     * Call back to the client to finish initialization.
     */
    if (!(dwTIFlags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD))) {

        if (SetAppCompatFlags(ptiCurrent)) {
            /*
             * Flag this process as a setup app.
             */
            ppi->W32PF_Flags |= W32PF_SETUPAPP;
        }

        Status = xxxClientThreadSetup();
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "ClientThreadSetup failed with NTSTATUS %lx", Status);
            goto CreateThreadInfoFailed;
        }
    }

    if ((NT_SUCCESS(Status) && fFirstThread) &&
        !(ppi->W32PF_Flags & W32PF_CONSOLEAPPLICATION)) {

        /*
         * Don't play the sound for console processes
         * since we will play it when the console window
         * will be created
         */
        PlayEventSound(USER_SOUND_OPEN);
    }

    /*
     * Release desktop.
     * Some other thread might have been waiting to destroy this desktop
     * when xxxResolveDestktop got a handle to it. So let's double
     * check this now that we have called back several times after getting
     * the handle back.
     */
    if (pdesk != NULL) {
        if (pdesk->dwDTFlags & DF_DESTROYED) {
            RIPMSG1(RIP_WARNING, "xxxCreateThreadInfo: pdesk destroyed:%#p", pdesk);
            Status = STATUS_UNSUCCESSFUL;
            goto CreateThreadInfoFailed;
        }
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_CREATETHREADINFO1);
    }


    if (pTmpPool != NULL) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlPool);
    }


    // We must return a success here. If the failure status is returned
    // W32Thread will be freed without us going thru xxxDestroyProcessInfo.

    UserAssert(NT_SUCCESS(Status));
    return Status;

CreateThreadInfoFailed:

    RIPMSG3(RIP_WARNING, "xxxCreateThreadInfo failed: pti %#p pdesk %#p status 0x%x", ptiCurrent, pdesk, Status);

    if (pdesk != NULL) {
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_CREATETHREADINFO2);
    }

    if (pTmpPool != NULL) {
        ThreadUnlockAndFreePool(ptiCurrent, &tlPool);
    }

    xxxDestroyThreadInfo();
    return Status;
}

/***************************************************************************\
* AllocQueue
*
* Allocates the memory for a TI structure and initializes its fields.
* Each Win32 queue has it's own TI while all Win16 threads share the same
* TI.
*
* History:
* 02-21-91 MikeHar      Created.
\***************************************************************************/
PQ AllocQueue(
    PTHREADINFO ptiKeyState,    // If non-Null then use this key state.
                                // Otherwise use global AsyncKeyState.
    PQ pq)                      // Non-NULL == preallocated object.
{
    USHORT cLockCount;

    if (pq == NULL) {
        pq = ExAllocateFromPagedLookasideList(QLookaside);
        if (pq == NULL) {
            return NULL;
        }
        cLockCount = 0;
    } else {
        DebugValidateMLIST(&pq->mlInput);
        /*
         * Preserve lock count.
         */
        cLockCount = pq->cLockCount;
    }
    RtlZeroMemory(pq, sizeof(Q));
    pq->cLockCount = cLockCount;

    /*
     * This is a new queue; we need to update its key state table before
     * the first input event is put in the queue.
     * We do this by copying the current keystate table and NULLing the recent
     * down state table. If a key is really down it will be updated when
     * we get it repeats.
     *
     * He is the old way that did not work because if the first key was say an
     * alt key the Async table would be updated, then the UpdateKeyState
     * message and it would look like the alt key was PREVIOUSLY down.
     *
     * The queue will get updated when it first reads input: to allow the
     * app to query the key state before it calls GetMessage, set its initial
     * key state to the asynchronous key state.
     */
    if (ptiKeyState) {
        RtlCopyMemory(pq->afKeyState, ptiKeyState->pq->afKeyState, CBKEYSTATE);
    } else {
        RtlCopyMemory(pq->afKeyState, gafAsyncKeyState, CBKEYSTATE);
    }

    /*
     * If there isn't a mouse set iCursorLevel to -1 so the
     * mouse cursor won't be visible on the screen.
     */
    if (
        !TEST_GTERMF(GTERMF_MOUSE)) {
            pq->iCursorLevel--;
    }

    /*
     * While the thread is starting up ... it has the wait cursor.
     */
    LockQCursor(pq, SYSCUR(WAIT));

    DebugValidateMLIST(&pq->mlInput);
    return pq;
}

/***************************************************************************\
* FreeQueue
*
* 04-04-96 GerardoB    Created.
\***************************************************************************/
VOID FreeQueue(
    PQ pq)
{
#if DBG
    /*
     * Turn off the flag indicating that this queue is in destruction.
     * We do this in either case that we are putting this into the free
     * list, or truly destroying the handle. We use this to try and
     * track cases where someone tries to lock elements into the queue
     * structure while it's going through destuction.
     */
    pq->QF_flags &= ~QF_INDESTROY;
#endif

    UserAssertMsg0(pq != gpqForeground, "FreeQueue(gpqForeground) !");
    UserAssertMsg0(pq != gpqForegroundPrev, "FreeQueue(gpqForegroundPrev) !");
    UserAssertMsg0(pq != gpqCursor, "FreeQueue(gpqCursor) !");
    ExFreeToPagedLookasideList(QLookaside, pq);
}

/***************************************************************************\
* FreeCachedQueues
*
* 14-Jan-98 CLupu    Created.
\***************************************************************************/
VOID FreeCachedQueues(
    VOID)
{
    if (QLookaside != NULL) {
        ExDeletePagedLookasideList(QLookaside);
        UserFreePool(QLookaside);
        QLookaside = NULL;
    }
}

/***************************************************************************\
* zzzDestroyQueue
*
*
* History:
* 05-20-91 MikeHar      Created.
\***************************************************************************/
VOID zzzDestroyQueue(
    PQ          pq,
    PTHREADINFO pti)
{
    PTHREADINFO ptiT;
    PTHREADINFO ptiAny, ptiBestMouse, ptiBestKey;
    PLIST_ENTRY pHead, pEntry;

#if DBG
    USHORT cDying = 0;
#endif

    BOOL fSetFMouseMoved = FALSE;

    DebugValidateMLIST(&pq->mlInput);

    UserAssert(pq->cThreads);
    pq->cThreads--;

    if (pq->cThreads != 0) {

        /*
         * Since we aren't going to destroy this queue, make sure
         * it isn't pointing to the THREADINFO that's going away.
         */
        if (pq->ptiSysLock == pti) {
            CheckSysLock(6, pq, NULL);
            pq->ptiSysLock = NULL;
        }

        if ((pq->ptiKeyboard == pti) || (pq->ptiMouse == pti)) {

            /*
             * Run through THREADINFOs looking for one pointing to pq.
             */
            ptiAny = NULL;
            ptiBestMouse = NULL;
            ptiBestKey = NULL;

            pHead = &pti->rpdesk->PtiList;
            for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
                ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

                /*
                 * Skip threads that are going away or belong to a
                 * different queue.
                 */
                if ((ptiT->TIF_flags & TIF_INCLEANUP) || (ptiT->pq != pq)) {
#if DBG
                    if (ptiT->pq == pq && (ptiT->TIF_flags & TIF_INCLEANUP))
                        cDying++;
#endif
                    continue;
                }

                ptiAny = ptiT;

                if (pti->pcti->fsWakeBits & QS_MOUSE) {
                    if (ptiT->pcti->fsWakeMask & QS_MOUSE)
                        ptiBestMouse = ptiT;
                }

                if (pti->pcti->fsWakeBits & QS_KEY) {
                    if (ptiT->pcti->fsWakeMask & QS_KEY)
                        ptiBestKey = ptiT;
                }
#ifdef GENERIC_INPUT
                if (pti->pcti->fsWakeMask & QS_RAWINPUT) {
                    if (ptiT->pcti->fsWakeMask & QS_RAWINPUT) {
                        /* For now, let's use keyboard focus to route the raw input */
                        ptiBestKey = ptiT;
                    }
                }
#endif
            }

            if (ptiBestMouse == NULL)
                ptiBestMouse = ptiAny;
            if (ptiBestKey == NULL)
                ptiBestKey = ptiAny;

            /*
             * Transfer any wake-bits to this new queue. This
             * is a common problem for QS_MOUSEMOVE which doesn't
             * get set on coalesced WM_MOUSEMOVE events, so we
             * need to make sure the new thread tries to process
             * any input waiting in the queue.
             */
            if (ptiBestMouse != NULL)
                SetWakeBit(ptiBestMouse, pti->pcti->fsWakeBits & QS_MOUSE);
            if (ptiBestKey != NULL) {
                SetWakeBit(ptiBestKey, pti->pcti->fsWakeBits & QS_KEY);
#ifdef GENERIC_INPUT
                SetWakeBit(ptiBestKey, pti->pcti->fsWakeBits & QS_RAWINPUT);
#endif
            }

            if (pq->ptiKeyboard == pti)
                pq->ptiKeyboard = ptiBestKey;

            if (pq->ptiMouse == pti)
                pq->ptiMouse = ptiBestMouse;

#if DBG
            /*
             * Bad things happen if ptiKeyboard or ptiMouse are NULL
             */
            if (pq->cThreads != cDying && (pq->ptiKeyboard == NULL || pq->ptiMouse == NULL)) {
                RIPMSG6(RIP_ERROR,
                        "pq %#p pq->cThreads %x cDying %x pti %#p ptiK %#p ptiM %#p",
                        pq, pq->cThreads, cDying, pti, pq->ptiKeyboard, pq->ptiMouse);
            }
#endif
        }

        return;
    }

    /*
     * Unlock any potentially locked globals now that we know absolutely
     * that this queue is going away.
     */
    UnlockCaptureWindow(pq);
    Unlock(&pq->spwndFocus);
    Unlock(&pq->spwndActive);
    Unlock(&pq->spwndActivePrev);
    Unlock(&pq->caret.spwnd);
    LockQCursor(pq, NULL);

#if DBG
    /*
     * Mark this queue as being in the destruction process. This is
     * cleared in FreeQueue() once we have determined it's safe to
     * place in the free-list, or destroy the handle. We use this
     * to track cases where someone will lock a cursor into the queue
     * while it's in the middle of being destroyed.
     */
    pq->QF_flags |= QF_INDESTROY;
#endif

    /*
     * Free everything else that was allocated/created by AllocQueue.
     */
    FreeMessageList(&pq->mlInput);

    /*
     * If this queue is in the foreground, set gpqForeground
     * to NULL so no input is routed. At some point we'll want
     * to do slightly more clever assignment of gpqForeground here.
     */
    if (gpqForeground == pq) {
        gpqForeground = NULL;
    }

    if (gpqForegroundPrev == pq) {
        gpqForegroundPrev = NULL;
    }

    if (gpqCursor == pq) {
        gpqCursor = NULL;
        fSetFMouseMoved = TRUE;
    }

    if (pq->cLockCount == 0) {
        FreeQueue(pq);
    }

    if (fSetFMouseMoved) {
        zzzSetFMouseMoved();
    }

}

/**************************************************************************\
* UserDeleteW32Thread
*
* This function is called when the W32THREAD reference count goes
* down to zero. So everything left around by xxxDestroyThreadInfo
* must be cleaned up here.
*
* SO VERY IMPORTANT:
* Note that this call is not in the context of the pti being cleaned up,
* in other words, pti != PtiCurrent(). So only kernel calls are allowed here.
*
* 04-01-96 GerardoB   Created
\**************************************************************************/
VOID UserDeleteW32Thread(
    PW32THREAD pW32Thread)
{
    PTHREADINFO pti = (PTHREADINFO)pW32Thread;

    BEGIN_REENTERCRIT();

    /*
     * Make sure the ref count didn't get bumped up while we were waiting.
     */
    if (pW32Thread->RefCount == 0) {

        /*
         * Events
         */
        if (pti->pEventQueueServer != NULL) {
            ObDereferenceObject(pti->pEventQueueServer);
        }
        if (pti->apEvent != NULL) {
            UserFreePool(pti->apEvent);
        }

        /*
         * App name.
         */
        if (pti->pstrAppName != NULL) {
            UserFreePool(pti->pstrAppName);
        }

        /*
         * Unlock the queues and free them if no one is using them
         * (the queues were already destroyed in DestroyThreadInfo)
         */
        if (pti->pq != NULL) {

            UserAssert(pti->pq->cLockCount);
            --(pti->pq->cLockCount);

            if ((pti->pq->cLockCount == 0)
                    && (pti->pq->cThreads == 0)) {
                FreeQueue(pti->pq);
            }

        }
        /*
         * zzzReattachThreads shouldn't call back while using pqAttach
         */
        UserAssert(pti->pqAttach == NULL);
        #if 0
        if (pti->pqAttach != NULL) {

            UserAssert(pti->pqAttach->cLockCount);
            --(pti->pqAttach->cLockCount);

            if ((pti->pqAttach->cLockCount == 0)
                    && (pti->pqAttach->cThreads == 0)) {
                FreeQueue(pti->pqAttach);
            }

        }
        #endif
        /*
         * Unlock the desktop (pti already unlinked from ptiList)
         */
        if (pti->rpdesk != NULL) {
            UnlockDesktop(&pti->rpdesk, LDU_PTI_DESK, (ULONG_PTR)pti);
        }

        /*
         * Remove the pointer to this W32Thread and free the associated memory.
         */
        PsSetThreadWin32Thread(pW32Thread->pEThread, NULL, pW32Thread);
        Win32FreePool(pW32Thread);
    }

    END_REENTERCRIT();
}

/**************************************************************************\
* UserDeleteW32Process
*
* This function is called when the W32PROCESS reference count goes
* down to zero. So everything left around by DestroyProcessInfo
* must be cleaned up here.
*
* SO VERY IMPORTANT:
* Note that this call may not be in the context of the ppi being cleaned up,
* in other words, ppi != PpiCurrent(). So only kernel calls are allowed here.
*
* 04-01-96 GerardoB   Created
\**************************************************************************/
VOID UserDeleteW32Process(
    PW32PROCESS pW32Process)
{
    PPROCESSINFO ppi = (PPROCESSINFO)pW32Process;

    BEGIN_REENTERCRIT();

    /*
     * Make sure the ref count didn't get bumped up while we were waiting.
     */
    if (pW32Process->RefCount == 0) {

        /*
         * Grab the handle flags lock. We can't call into the object manager when
         * we have this or we might deadlock.
         */
        EnterHandleFlagsCrit();

        /*
         * Delete handle flags attribute bitmap
         */
        if (ppi->bmHandleFlags.Buffer) {
            UserFreePool(ppi->bmHandleFlags.Buffer);
            RtlInitializeBitMap(&ppi->bmHandleFlags, NULL, 0);
        }

        /*
         * Remove the pointer to this W32Process and free the associated memory.
         */
        PsSetProcessWin32Process(pW32Process->Process, NULL, pW32Process);
        Win32FreePool(pW32Process);

        /*
         * Release the handle flags lock.
         */
        LeaveHandleFlagsCrit();
    }

    END_REENTERCRIT();
}

/***************************************************************************\
* FLastGuiThread
*
* Check if this is the last GUI thread in the process.
\***************************************************************************/

__inline BOOL FLastGuiThread(PTHREADINFO pti)
{
    return (pti->ppi &&
            pti->ppi->ptiList == pti &&
            pti->ptiSibling == NULL);
}

/***************************************************************************\
* xxxDestroyThreadInfo
*
* Destroys a THREADINFO created by xxxCreateThreadInfo().
*
* Note that the current pti can be locked so it might be used after this
* function returns, eventhough the thread execution has ended.
*
* We want to stop any activity on this thread so we clean up any USER stuff
* like messages, clipboard, queue, etc and specially anything that assumes
* to be running on a Win32 thread and client side stuff. The final cleanup
* will take place in UserDeleteW32Thread.
*
* This function must not go into the user mode because the ntos data
* structures may no longer support it and it may bluescreen the system.
*
* Make all callbacks before the thread objects are destroyed. If you callback
* afterwards, new objects might be created and won't be cleaned up.
*
* History:
* 02-15-91 DarrinM      Created.
* 02-27-91 mikeke       Made it work
* 02-27-91 Mikehar      Removed queue from the global list
\***************************************************************************/
VOID xxxDestroyThreadInfo(
    VOID)
{
    PTHREADINFO ptiCurrent;
    PTHREADINFO *ppti;

    ptiCurrent = PtiCurrent();
    UserAssert(ptiCurrent != NULL);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * If this thread is blocking input, stop it.
     */
    if (gptiBlockInput == ptiCurrent) {
        gptiBlockInput = NULL;
    }

    /*
     * Don't mess with this ptiCurrent anymore.
     */
    ptiCurrent->TIF_flags |= (TIF_DONTATTACHQUEUE | TIF_INCLEANUP);

    /*
     * First do any preparation work: Windows need to be "patched" so that
     * their window procs point to server only windowprocs, for example.
     */
    PatchThreadWindows(ptiCurrent);

    /*
     * If this thread terminated abnormally and was tracking tell
     * GDI to hide the trackrect.
     */
    if (ptiCurrent->pmsd != NULL) {
        xxxCancelTrackingForThread(ptiCurrent);
    }

    /*
     * Unlock the pmsd window.
     */
    if (ptiCurrent->pmsd != NULL) {
        Unlock(&ptiCurrent->pmsd->spwnd);
        UserFreePool(ptiCurrent->pmsd);
        ptiCurrent->pmsd = NULL;
    }

    /*
     * Free the clipboard if owned by this thread.
     */
    {
        PWINDOWSTATION pwinsta;
        pwinsta = _GetProcessWindowStation(NULL);
        if (pwinsta != NULL) {
            if (pwinsta->ptiClipLock == ptiCurrent) {
                xxxCloseClipboard(pwinsta);
            }
            if (pwinsta->ptiDrawingClipboard == ptiCurrent) {
                pwinsta->ptiDrawingClipboard = NULL;
            }
        }
    }

    /*
     * Unlock all the objects stored in the menustate structure
     */
    while (ptiCurrent->pMenuState != NULL) {
        PMENUSTATE pMenuState;
        PPOPUPMENU ppopupmenuRoot;

        pMenuState = ptiCurrent->pMenuState;
        ppopupmenuRoot = pMenuState->pGlobalPopupMenu;

        /*
         * If menu mode was running on this thread
         */
        if (ptiCurrent == pMenuState->ptiMenuStateOwner) {
            /*
             * The menu's going away, so anyone who's locked it
             * is SOL anyway. Windows NT Bug #375467.
             */
            pMenuState->dwLockCount = 0;

            /*
             * Close this menu.
             */
            if (pMenuState->fModelessMenu) {
                xxxEndMenuLoop(pMenuState, ppopupmenuRoot);
                xxxMNEndMenuState(TRUE);
            } else {
                pMenuState->fInsideMenuLoop = FALSE;
                ptiCurrent->pq->QF_flags &= ~QF_CAPTURELOCKED;
                xxxMNCloseHierarchy(ppopupmenuRoot, pMenuState);
                xxxMNEndMenuState(ppopupmenuRoot->fIsMenuBar || ppopupmenuRoot->fDestroyed);
            }
        } else {
            /*
             * Menu mode is running on another thread. This thread
             * must own spwndNotify which is going away soon.
             *
             * When spwndNotify is destroyed, we will clean up pMenuState
             * from this pti. So do nothing now as we'll need this
             * pMenuState at that time.
             */
            UserAssert((ppopupmenuRoot->spwndNotify != NULL)
                    && (GETPTI(ppopupmenuRoot->spwndNotify) == ptiCurrent));

            /*
             * Nested menus are not supposed to involve multiple threads.
             */
            UserAssert(pMenuState->pmnsPrev == NULL);
            break;
        }
    }

    /*
     * This thread must not be using the desktop menu
     * Debugging bug #162562
     */
    if ((ptiCurrent->rpdesk != NULL) && (ptiCurrent->rpdesk->spwndMenu != NULL) &&
        (ptiCurrent == GETPTI(ptiCurrent->rpdesk->spwndMenu))) {
        FRE_RIPMSG3(RIP_ERROR, "Destroying pti ( %p ) used by menu ( %p ) on desktop ( %p )",
                    ptiCurrent, ptiCurrent->rpdesk->spwndMenu, ptiCurrent->rpdesk);
    }

    /*
     * Unlock all the objects stored in the sbstate structure.
     */
    if (ptiCurrent->pSBTrack) {
        Unlock(&ptiCurrent->pSBTrack->spwndSB);
        Unlock(&ptiCurrent->pSBTrack->spwndSBNotify);
        Unlock(&ptiCurrent->pSBTrack->spwndTrack);
        UserFreePool(ptiCurrent->pSBTrack);
        ptiCurrent->pSBTrack = NULL;
    }

    /*
     * If this is the main input thread of this application, zero out
     * that field.
     */
    if (ptiCurrent->ppi != NULL && ptiCurrent->ppi->ptiMainThread == ptiCurrent) {
        ptiCurrent->ppi->ptiMainThread = NULL;
    }

    while (ptiCurrent->psiiList != NULL) {
        xxxDestroyThreadDDEObject(ptiCurrent, ptiCurrent->psiiList);
    }

    if (ptiCurrent->TIF_flags & TIF_PALETTEAWARE) {
        PWND pwnd;
        TL tlpwnd;

        UserAssert(ptiCurrent->rpdesk != NULL);

        pwnd = ptiCurrent->rpdesk->pDeskInfo->spwnd;
        if(pwnd) {
            ThreadLock(pwnd, &tlpwnd);
            xxxFlushPalette(pwnd);
            ThreadUnlock(&tlpwnd);
        }
    }

    /*
     * If this is the last GUI thread for the process that made a temporary
     * (fullscreen) mode change, restore the mode to what's in the registry.
     */
    if (FLastGuiThread(ptiCurrent)) {
        if ((gppiFullscreen == ptiCurrent->ppi) && !gbMDEVDisabled) {
            LONG Status = xxxUserChangeDisplaySettings(NULL, NULL, NULL, NULL, 0, 0, KernelMode);
            UserAssertMsg1(gppiFullscreen != ptiCurrent->ppi, "xxxUserChangeDisplaySettings failed with status 0x%x", Status);
        }
    }

#ifdef GENERIC_INPUT
    /*
     * If the raw input is specified in this process,
     * destroy thread-related objects and requests.
     * This has to be done before the window reparenting.
     */
    if (ptiCurrent->ppi && ptiCurrent->ppi->pHidTable) {
        DestroyThreadHidObjects(ptiCurrent);
    }
#endif


    /**************************************************************************\
     *
     * CLEANING THREAD OBJECTS. AVOID CALLING BACK AFTER THIS POINT.
     *
     * New objects might be created while calling back and won't be cleaned up.
     *
    \**************************************************************************/

    /*
     * This thread might have some outstanding timers. Destroy them.
     */
    DestroyThreadsTimers(ptiCurrent);

    /*
     * Free any windows hooks this thread has created.
     */
    FreeThreadsWindowHooks();

    /*
     * Free any hwnd lists the thread was using
     */
    {
       PBWL pbwl, pbwlNext;
       for (pbwl = gpbwlList; pbwl != NULL; ) {
           pbwlNext = pbwl->pbwlNext;
           if (pbwl->ptiOwner == ptiCurrent) {
               FreeHwndList(pbwl);
           }
           pbwl = pbwlNext;
       }
    }

    /*
     * Destroy all the public objects created by this thread.
     */
    DestroyThreadsHotKeys();

    DestroyThreadsObjects();

    /*
     * Free any synchronous Notifies pending for this thread and
     * free any Win Event Hooks this thread created.
     */
    FreeThreadsWinEvents(ptiCurrent);

    /*
     * Unlock the keyboard layouts here.
     */
    Unlock(&ptiCurrent->spklActive);

    /*
     * Cleanup the global resources if this is the last GUI
     * thread for this session.
     */
    if (gdwGuiThreads == 1) {
        CleanupResources();
    }


    if (FLastGuiThread(ptiCurrent)) {

        /*
         * Check if this was a setup app.
         */
        if (ptiCurrent->ppi->W32PF_Flags & W32PF_SETUPAPP) {
            PDESKTOPINFO pdeskinfo = GETDESKINFO(ptiCurrent);
            if (pdeskinfo->spwndShell) {
                _PostMessage(pdeskinfo->spwndShell, DTM_SETUPAPPRAN, 0, 0);
            }
        }

        DestroyProcessesClasses(ptiCurrent->ppi);
        ptiCurrent->ppi->W32PF_Flags &= ~(W32PF_CLASSESREGISTERED);

        DestroyProcessesObjects(ptiCurrent->ppi);
    }

    /*
     * Unlock default input context.
     */
    Unlock(&ptiCurrent->spDefaultImc);

    if (ptiCurrent->pq != NULL) {
        /*
         * Remove this thread's cursor count from the queue.
         */
        ptiCurrent->pq->iCursorLevel -= ptiCurrent->iCursorLevel;

        /*
         * Have to recalc queue ownership after this thread
         * leaves if it is a member of a shared input queue.
         */
        if (ptiCurrent->pq->cThreads != 1) {
            gpdeskRecalcQueueAttach = ptiCurrent->rpdesk;
            /*
             * Because we are in thread cleanup, we won't callback due
             * to WinEvents (zzzSetFMouseMoved calls zzzUpdateCursorImage).
             */
            UserAssert(ptiCurrent->TIF_flags & TIF_INCLEANUP);
            UserAssert(gbExitInProgress == FALSE);
            zzzSetFMouseMoved();
        }
    }

    /*
     * Remove from the process' list, also.
     */
    ppti = &PpiCurrent()->ptiList;
    if (*ppti != NULL) {
        while (*ppti != ptiCurrent && (*ppti)->ptiSibling != NULL) {
            ppti = &((*ppti)->ptiSibling);
        }
        if (*ppti == ptiCurrent) {
            *ppti = ptiCurrent->ptiSibling;
            ptiCurrent->ptiSibling = NULL;
        }
    }

    {
        PDESKTOP rpdesk;
        PATTACHINFO *ppai;

        /*
         * Temporarily lock the desktop until the THREADINFO structure is
         * freed. Note that locking a NULL ptiCurrent->rpdesk is OK. Use a
         * normal lock instead of a thread lock because the lock must
         * exist past the freeing of the ptiCurrent.
         */
        rpdesk = NULL;
        LockDesktop(&rpdesk, ptiCurrent->rpdesk, LDL_FN_DESTROYTHREADINFO, (ULONG_PTR)PtiCurrent());

        /*
         * Cleanup SMS structures attached to this thread. Handles both
         * pending send and receive messages. MUST make sure we do
         * SendMsgCleanup AFTER window cleanup.
         */
        SendMsgCleanup(ptiCurrent);


        /*
         * Allow this thread to be swapped
         */
        if (ptiCurrent->cEnterCount) {
            BOOLEAN bool;

            RIPMSG1(RIP_WARNING, "Thread exiting with stack locked. pti:%#p\n", ptiCurrent);
            bool = KeSetKernelStackSwapEnable(TRUE);
            ptiCurrent->cEnterCount = 0;
            UserAssert(!bool);
        }

        if (ptiCurrent->ppi != NULL) {
            ptiCurrent->ppi->cThreads--;
            UserAssert(ptiCurrent->ppi->cThreads >= 0);
        }

        /*
         * If this thread is a win16 task, remove it from the scheduler.
         */
        if (ptiCurrent->TIF_flags & TIF_16BIT) {
            if ((ptiCurrent->ptdb) && (ptiCurrent->ptdb->hTaskWow != 0)) {
                _WOWCleanup(NULL, ptiCurrent->ptdb->hTaskWow);
            }
            DestroyTask(ptiCurrent->ppi, ptiCurrent);
        }

        if (ptiCurrent->hEventQueueClient != NULL) {
            NTSTATUS Status;
            Status = ProtectHandle(ptiCurrent->hEventQueueClient, *ExEventObjectType, FALSE);
            if (NT_SUCCESS(Status)) {
                ObCloseHandle(ptiCurrent->hEventQueueClient, UserMode);
            } else {
                RIPMSG1(RIP_WARNING, "xxxDestroyThreadInfo: failed to unprotect the hEventQueueClient handle, status=%08x", Status);
            }
            ptiCurrent->hEventQueueClient = NULL;
        }


        if (gspwndInternalCapture != NULL) {
            if (GETPTI(gspwndInternalCapture) == ptiCurrent) {
                Unlock(&gspwndInternalCapture);
            }
        }

        /*
         * Set gptiForeground to NULL if equal to this pti before exiting
         * this routine.
         */
        if (gptiForeground == ptiCurrent) {
            /*
             * Post these (WEF_ASYNC), since we can't make callbacks from here.
             */
            xxxWindowEvent(EVENT_OBJECT_FOCUS, NULL, OBJID_CLIENT, INDEXID_CONTAINER, WEF_ASYNC);
            xxxWindowEvent(EVENT_SYSTEM_FOREGROUND, NULL, OBJID_WINDOW, INDEXID_CONTAINER, WEF_ASYNC);

            /*
             * Call the Shell to ask it to activate its main window.
             * This will be accomplished with a PostMessage() to itself,
             * so the actual activation will take place later.
             */
            UserAssert(rpdesk != NULL);

            if (rpdesk->pDeskInfo->spwndProgman)
                _PostMessage(rpdesk->pDeskInfo->spwndProgman, guiActivateShellWindow, 0, 0);

            /*
             * Set gptiForeground to NULL because we're destroying it.
             */
            SetForegroundThread(NULL);

            /*
             * If this thread is attached to gpqForeground AND it's the
             * last thread in the queue, then zzzDestroyQueue will NULL out
             * qpqForeground. Due to journalling attaching, gptiForegrouund
             * is not always attached to gpqForeground. This is one reason
             * why we no longer NULL out gpqForeground as stated in the old
             * comment. The other reason is that there might be other threads
             * in the foreground queue so there is no need to zap it. This was
             * messing up MsTest (now called VisualTest)
             * This is the old comment:
             * "Since gpqForeground is derived from the foreground thread
             * structure, set it to NULL as well, since there now is no
             * foreground thread structure"
             *
             * qpqForeground = NULL;
             */
        }


        /*
         * If this thread got the last input event, pass ownership to another
         *  thread in this process or to the foreground thread.
         */
        if (ptiCurrent == glinp.ptiLastWoken) {
            UserAssert(PpiCurrent() == ptiCurrent->ppi);
            if (ptiCurrent->ppi->ptiList != NULL) {
                UserAssert (ptiCurrent != ptiCurrent->ppi->ptiList);
                glinp.ptiLastWoken = ptiCurrent->ppi->ptiList;
            } else {
                glinp.ptiLastWoken = gptiForeground;
            }
        }

        /*
         * Make sure none of the other global thread pointers are pointing to us.
         */
        if (gptiShutdownNotify == ptiCurrent) {
            gptiShutdownNotify = NULL;
        }
        if (gptiTasklist == ptiCurrent) {
            gptiTasklist = NULL;
        }
        if (gHardErrorHandler.pti == ptiCurrent) {
            gHardErrorHandler.pti = NULL;
        }

        /*
         * Might be called from xxxCreateThreadInfo before the queue is created
         * so check for NULL queue. Lock the queues since this pti might be
         * locked. They will be unlocked in UserDeleteW32Thread
         */
        if (ptiCurrent->pq != NULL) {
            UserAssert(ptiCurrent->pq != ptiCurrent->pqAttach);
            DestroyThreadsMessages(ptiCurrent->pq, ptiCurrent);
            (ptiCurrent->pq->cLockCount)++;
            zzzDestroyQueue(ptiCurrent->pq, ptiCurrent);
        }

        /*
         * zzzReattachThreads shouldn't call back while using pqAttach
         */
        UserAssert(ptiCurrent->pqAttach == NULL);
        #if 0
        if (ptiCurrent->pqAttach != NULL) {
            DestroyThreadsMessages(ptiCurrent->pqAttach, ptiCurrent);
            (ptiCurrent->pqAttach->cLockCount)++;
            zzzDestroyQueue(ptiCurrent->pqAttach, ptiCurrent);
        }
        #endif

        /*
         * Remove the pti from its pti list and reset the pointers.
         */
        if (ptiCurrent->rpdesk != NULL) {
            RemoveEntryList(&ptiCurrent->PtiLink);
            InitializeListHead(&ptiCurrent->PtiLink);
        }

        FreeMessageList(&ptiCurrent->mlPost);

        /*
         * Free any attachinfo structures pointing to this thread
         */
        ppai = &gpai;
        while ((*ppai) != NULL) {
            if ((*ppai)->pti1 == ptiCurrent || (*ppai)->pti2 == ptiCurrent) {
                PATTACHINFO paiKill = *ppai;
                *ppai = (*ppai)->paiNext;
                UserFreePool((HLOCAL)paiKill);
            } else {
                ppai = &(*ppai)->paiNext;
            }
        }

        /*
         * Change ownership of any objects that didn't get freed (because they
         * are locked or we have a bug and the object didn't get destroyed).
         */
        MarkThreadsObjects(ptiCurrent);

        /*
         * Free thread information visible from client
         */
        if (rpdesk && ptiCurrent->pcti != NULL && ptiCurrent->pcti != &(ptiCurrent->cti)) {
            DesktopFree(rpdesk, ptiCurrent->pcti);
            ptiCurrent->pcti = &(ptiCurrent->cti);
        }

        /*
         * Free the client info for system threads
         */
        if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD && ptiCurrent->pClientInfo != NULL) {
            UserFreePool(ptiCurrent->pClientInfo);
            ptiCurrent->pClientInfo = NULL;
        }

        /*
         * Unlock the temporary desktop lock. ptiCurrent->rpdesk is still locked
         *  and will be unlocked in UserDeleteW32Thread.
         */
        UnlockDesktop(&rpdesk, LDU_FN_DESTROYTHREADINFO, (ULONG_PTR)PtiCurrent());
    }

    /*
     * One more thread died.
     */
    gdwGuiThreads--;
}


/***************************************************************************\
* CleanEventMessage
*
* This routine takes a message and destroys and event message related pieces,
* which may be allocated.
*
* 12-10-92 ScottLu      Created.
\***************************************************************************/
VOID CleanEventMessage(
    PQMSG pqmsg)
{
    PASYNCSENDMSG pmsg;

    /*
     * Certain special messages on the INPUT queue have associated
     * bits of memory that need to be freed.
     */
    switch (pqmsg->dwQEvent) {
    case QEVENT_SETWINDOWPOS:
        UserFreePool((PSMWP)pqmsg->msg.wParam);
        break;

    case QEVENT_UPDATEKEYSTATE:
        UserFreePool((PBYTE)pqmsg->msg.wParam);
        break;

    case QEVENT_NOTIFYWINEVENT:
        DestroyNotify((PNOTIFY)pqmsg->msg.lParam);
        break;

    case QEVENT_ASYNCSENDMSG:
        pmsg = (PASYNCSENDMSG)pqmsg->msg.wParam;
        UserDeleteAtom((ATOM)pmsg->lParam);
        UserFreePool(pmsg);
        break;
    }
}

/***************************************************************************\
* FreeMessageList
*
* History:
* 02-27-91  mikeke      Created.
* 11-03-92  scottlu     Changed to work with MLIST structure.
\***************************************************************************/
VOID FreeMessageList(
    PMLIST pml)
{
    PQMSG pqmsg;

    DebugValidateMLIST(pml);

    while ((pqmsg = pml->pqmsgRead) != NULL) {
        CleanEventMessage(pqmsg);
        DelQEntry(pml, pqmsg);
    }

    DebugValidateMLIST(pml);
}

/***************************************************************************\
* DestroyThreadsMessages
*
* History:
* 02-21-96  jerrysh     Created.
\***************************************************************************/
VOID DestroyThreadsMessages(
    PQ pq,
    PTHREADINFO pti)
{
    PQMSG pqmsg;
    PQMSG pqmsgNext;

    DebugValidateMLIST(&pq->mlInput);

    pqmsg = pq->mlInput.pqmsgRead;
    while (pqmsg != NULL) {
        pqmsgNext = pqmsg->pqmsgNext;
        if (pqmsg->pti == pti) {
            /*
             * Make sure we don't leave any bogus references to this message
             * lying around.
             */
            if (pq->idSysPeek == (ULONG_PTR)pqmsg) {
                CheckPtiSysPeek(8, pq, 0);
                pq->idSysPeek = 0;
            }
            CleanEventMessage(pqmsg);
            DelQEntry(&pq->mlInput, pqmsg);
        }
        pqmsg = pqmsgNext;
    }

    DebugValidateMLIST(&pq->mlInput);
}

/***************************************************************************\
* InitQEntryLookaside
*
* Initializes the Q entry lookaside list. This improves Q entry locality
* by keeping Q entries in a single page
*
* 09-09-93  Markl   Created.
\***************************************************************************/
NTSTATUS
InitQEntryLookaside(
    VOID)
{
    QEntryLookaside = Win32AllocPoolNonPagedNS(sizeof(PAGED_LOOKASIDE_LIST),
                                               TAG_LOOKASIDE);
    if (QEntryLookaside == NULL) {
        return STATUS_NO_MEMORY;
    }

    ExInitializePagedLookasideList(QEntryLookaside,
                                   NULL,
                                   NULL,
                                   gSessionPoolMask,
                                   sizeof(QMSG),
                                   TAG_QMSG,
                                   16);

    QLookaside = Win32AllocPoolNonPagedNS(sizeof(PAGED_LOOKASIDE_LIST),
                                          TAG_LOOKASIDE);
    if (QLookaside == NULL) {
        return STATUS_NO_MEMORY;
    }

    ExInitializePagedLookasideList(QLookaside,
                                   NULL,
                                   NULL,
                                   gSessionPoolMask,
                                   sizeof(Q),
                                   TAG_Q,
                                   16);
    return STATUS_SUCCESS;
}

/***************************************************************************\
* AllocQEntry
*
* Allocates a message on a message list. DelQEntry deletes a message
* on a message list.
*
* 10-22-92 ScottLu      Created.
\***************************************************************************/

PQMSG AllocQEntry(
    PMLIST pml)
{
    PQMSG pqmsg;

    DebugValidateMLIST(pml);

    if (pml->cMsgs >= gUserPostMessageLimit) {
        RIPERR3(ERROR_NOT_ENOUGH_QUOTA, RIP_VERBOSE, "AllocQEntry: # of post messages exceeds the limit(%d) in pti=%#p, pml=%#p",
               gUserPostMessageLimit, W32GetCurrentThread(), pml);
        return NULL;
    }

    /*
     * Allocate a Q message structure.
     */
    if ((pqmsg = ExAllocateFromPagedLookasideList(QEntryLookaside)) == NULL) {
        RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "AllocQEntry: allocation failed, not enough memory");
        return NULL;
    }

    RtlZeroMemory(pqmsg, sizeof(*pqmsg));

    if (pml->pqmsgWriteLast != NULL) {
        pml->pqmsgWriteLast->pqmsgNext = pqmsg;
        pqmsg->pqmsgPrev = pml->pqmsgWriteLast;
        pml->pqmsgWriteLast = pqmsg;
    } else {
        pml->pqmsgWriteLast = pml->pqmsgRead = pqmsg;
    }

    pml->cMsgs++;

    DebugValidateMLISTandQMSG(pml, pqmsg);

    return pqmsg;
}

/***************************************************************************\
* DelQEntry
*
* Simply removes a message from a message queue list.
*
* 10-20-92 ScottLu      Created.
\***************************************************************************/
VOID DelQEntry(
    PMLIST pml,
    PQMSG pqmsg)
{
    DebugValidateMLISTandQMSG(pml, pqmsg);
    UserAssert((int)pml->cMsgs > 0);
    UserAssert(pml->pqmsgRead);
    UserAssert(pml->pqmsgWriteLast);

    /*
     * Unlink this pqmsg from the message list.
     */
    if (pqmsg->pqmsgPrev != NULL)
        pqmsg->pqmsgPrev->pqmsgNext = pqmsg->pqmsgNext;

    if (pqmsg->pqmsgNext != NULL)
        pqmsg->pqmsgNext->pqmsgPrev = pqmsg->pqmsgPrev;

    /*
     * Update the read/write pointers if necessary.
     */
    if (pml->pqmsgRead == pqmsg)
        pml->pqmsgRead = pqmsg->pqmsgNext;

    if (pml->pqmsgWriteLast == pqmsg)
        pml->pqmsgWriteLast = pqmsg->pqmsgPrev;

    /*
     * Adjust the message count and free the message structure.
     */
    pml->cMsgs--;

    ExFreeToPagedLookasideList(QEntryLookaside, pqmsg);

    DebugValidateMLIST(pml);
}

/***************************************************************************\
* CheckRemoveHotkeyBit
*
* We have a special bit for the WM_HOTKEY message - QS_HOTKEY. When there
* is a WM_HOTKEY message in the queue, that bit is on. When there isn't,
* that bit is off. This checks for more than one hot key, because the one
* is about to be deleted. If there is only one, the hot key bits are cleared.
*
* 11-12-92 ScottLu      Created.
\***************************************************************************/
VOID CheckRemoveHotkeyBit(
    PTHREADINFO pti,
    PMLIST pml)
{
    PQMSG pqmsg;
    DWORD cHotkeys;

    /*
     * Remove the QS_HOTKEY bit if there is only one WM_HOTKEY message
     * in this message list.
     */
    cHotkeys = 0;
    for (pqmsg = pml->pqmsgRead; pqmsg != NULL; pqmsg = pqmsg->pqmsgNext) {
        if (pqmsg->msg.message == WM_HOTKEY)
            cHotkeys++;
    }

    /*
     * If there is 1 or fewer hot keys, remove the hotkey bits.
     */
    if (cHotkeys <= 1) {
        pti->pcti->fsWakeBits &= ~QS_HOTKEY;
        pti->pcti->fsChangeBits &= ~QS_HOTKEY;
    }
}

/***************************************************************************\
* FindQMsg
*
* Finds a qmsg that fits the filters by looping through the message list.
*
* 10-20-92 ScottLu      Created.
* 06-06-97 CLupu        added processing for WM_DDE_ACK messages
\***************************************************************************/

PQMSG FindQMsg(
    PTHREADINFO pti,
    PMLIST pml,
    PWND pwndFilter,
    UINT msgMin,
    UINT msgMax,
    BOOL bProcessAck)
{
    PWND pwnd;
    PQMSG pqmsgRead;
    PQMSG pqmsgRet = NULL;
    UINT message;

    DebugValidateMLIST(pml);

    pqmsgRead = pml->pqmsgRead;

    while (pqmsgRead != NULL) {

        /*
         * Make sure this window is valid and doesn't have the destroy
         * bit set (don't want to send it to any client side window procs
         * if destroy window has been called on it).
         */
        pwnd = RevalidateHwnd(pqmsgRead->msg.hwnd);

        if (pwnd == NULL && pqmsgRead->msg.hwnd != NULL) {
            /*
             * If we're removing a WM_HOTKEY message, we may need to
             * clear the QS_HOTKEY bit, since we have a special bit
             * for that message.
             */
            if (pqmsgRead->msg.message == WM_HOTKEY) {
                CheckRemoveHotkeyBit(pti, pml);
            }
            /*
             * If the current thread's queue is locked waiting for this message,
             *  we have to unlock it because we're eating the message. If there's
             *  no more input/messages for this thread, the thread is going to
             *  sleep; hence there might not be a next Get/PeekMessage call to
             *  unlock the queue (ie, updating pti->idLast is not enough);
             *  so we must unlock it now.
             * Win95 doesn't have this problem because their FindQMsg doesn't
             *  eat messages; they call ReadPostMessage from FreeWindow
             *  to take care of this scenario (== message for a destroyed window).
             *  We could also do this if we have some problems with this fix.
             */
            if ((pti->pq->idSysLock == (ULONG_PTR)pqmsgRead)
                    && (pti->pq->ptiSysLock == pti)) {
                /* CheckSysLock(What number?, pti->pq, NULL); */
                RIPMSG2(RIP_VERBOSE, "FindQMsg: Unlocking queue:%#p. Msg:%#lx",
                                        pti->pq, pqmsgRead->msg.message);
                pti->pq->ptiSysLock = NULL;
            }

            DelQEntry(pml, pqmsgRead);
            goto nextMsgFromPml;
        }

        /*
         * Process the WM_DDE_ACK messages if bProcessAck is set.
         */
        if (bProcessAck && (PtoH(pwndFilter) == pqmsgRead->msg.hwnd) &&
            (pqmsgRead->msg.message == (WM_DDE_ACK | MSGFLAG_DDE_MID_THUNK))) {

            PXSTATE pxs;

            pxs = (PXSTATE)HMValidateHandleNoRip((HANDLE)pqmsgRead->msg.lParam, TYPE_DDEXACT);

            if (pxs != NULL && (pxs->flags & XS_FREEPXS)) {
                FreeDdeXact(pxs);
                DelQEntry(pml, pqmsgRead);
                goto nextMsgFromPml;
            }
        }

        /*
         * Make sure this message fits both window handle and message
         * filters.
         */
        if (!CheckPwndFilter(pwnd, pwndFilter))
            goto nextMsg;

        /*
         * If this is a fixed up dde message, then turn it into a normal
         * dde message for the sake of message filtering.
         */
        message = pqmsgRead->msg.message;
        if (CheckMsgFilter(message,
                (WM_DDE_FIRST + 1) | MSGFLAG_DDE_MID_THUNK,
                WM_DDE_LAST | MSGFLAG_DDE_MID_THUNK)) {
            message = message & ~MSGFLAG_DDE_MID_THUNK;
        }

        if (!CheckMsgFilter(message, msgMin, msgMax))
            goto nextMsg;

        /*
         * Found it. If bProcessAck is set, remember this pointer and go on
         * till we finish walking the list to process all WM_DDE_ACK messages.
         */
        if (!bProcessAck) {
            DebugValidateMLIST(pml);
            return pqmsgRead;
        }

        if (pqmsgRet == NULL) {
            pqmsgRet = pqmsgRead;
        }
nextMsg:
        pqmsgRead = pqmsgRead->pqmsgNext;
        continue;

nextMsgFromPml:
        pqmsgRead = pml->pqmsgRead;
        continue;
    }

    DebugValidateMLIST(pml);
    return pqmsgRet;
}

/***************************************************************************\
* CheckQuitMessage
*
* Checks to see if a WM_QUIT message should be generated.
*
* 11-06-92 ScottLu      Created.
\***************************************************************************/
BOOL CheckQuitMessage(
    PTHREADINFO pti,
    LPMSG lpMsg,
    BOOL fRemoveMsg)
{
    /*
     * If there are no more posted messages in the queue and the app
     * has already called PostQuitMessage, then generate a quit.
     */
    if ((pti->TIF_flags & TIF_QUITPOSTED) && pti->mlPost.cMsgs == 0) {
        /*
         * If we're "removing" the quit, clear TIF_QUITPOSTED so another one
         * isn't generated.
         */
        if (fRemoveMsg) {
            pti->TIF_flags &= ~TIF_QUITPOSTED;
        }
        StoreMessage(lpMsg, NULL, WM_QUIT, (DWORD)pti->exitCode, 0, 0);
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* ReadPostMessage
*
* If queue is not empty, read message satisfying filter conditions from
* this queue to *lpMsg.
*
* 10-19-92 ScottLu      Created.
\***************************************************************************/
BOOL xxxReadPostMessage(
    PTHREADINFO pti,
    LPMSG lpMsg,
    PWND pwndFilter,
    UINT msgMin,
    UINT msgMax,
    BOOL fRemoveMsg)
{
    PQMSG pqmsg;
    PMLIST pmlPost;

    /*
     * Check to see if it is time to generate a quit message.
     */
    if (CheckQuitMessage(pti, lpMsg, fRemoveMsg)) {
        return TRUE;
    }

    /*
     * Loop through the messages in this list looking for the one that
     * fits the passed in filters.
     */
    pmlPost = &pti->mlPost;
    pqmsg = FindQMsg(pti, pmlPost, pwndFilter, msgMin, msgMax, FALSE);
    if (pqmsg == NULL) {
        /*
         * Check again for quit... FindQMsg deletes some messages
         * in some instances, so we may match the conditions
         * for quit generation here.
         */
        if (CheckQuitMessage(pti, lpMsg, fRemoveMsg)) {
            return TRUE;
        }
    } else {
        /*
         * Update the thread info fields with the info from this qmsg.
         */
        pti->timeLast = pqmsg->msg.time;
        if (!RtlEqualMemory(&pti->ptLast, &pqmsg->msg.pt, sizeof(POINT))) {
            pti->TIF_flags |= TIF_MSGPOSCHANGED;
        }
        pti->ptLast = pqmsg->msg.pt;

        pti->idLast = (ULONG_PTR)pqmsg;
        pti->pq->ExtraInfo = pqmsg->ExtraInfo;

        /*
         * Are we supposed to yank out the message? If not, stick some
         * random id into idLast so we don't unlock the input queue until we
         * pull this message from the queue.
         */
        *lpMsg = pqmsg->msg;
        if (!fRemoveMsg) {
            pti->idLast = 1;
        } else {
            /*
             * If we're removing a WM_HOTKEY message, we may need to
             * clear the QS_HOTKEY bit, since we have a special bit
             * for that message.
             */
            if (pmlPost->pqmsgRead->msg.message == WM_HOTKEY) {
                CheckRemoveHotkeyBit(pti, pmlPost);
            }


            /*
             * Since we're removing an event from the queue, we
             * need to check priority. This resets the TIF_SPINNING
             * since we're no longer spinning.
             */
            if (pti->TIF_flags & TIF_SPINNING) {
                CheckProcessForeground(pti);
            }

            DelQEntry(pmlPost, pqmsg);
        }

        /*
         * See if this is a dde message that needs to be fixed up.
         */
        if (CheckMsgFilter(lpMsg->message,
                (WM_DDE_FIRST + 1) | MSGFLAG_DDE_MID_THUNK,
                WM_DDE_LAST | MSGFLAG_DDE_MID_THUNK)) {
            /*
             * Fixup the message value.
             */
            lpMsg->message &= (UINT)~MSGFLAG_DDE_MID_THUNK;

            /*
             * Call back the client to allocate the dde data for this message.
             */
            xxxDDETrackGetMessageHook(lpMsg);

            /*
             * Copy these values back into the queue if this message hasn't
             * been removed from the queue. Need to search through the
             * queue again because the pqmsg may have been removed when
             * we left the critical section above.
             */
            if (!fRemoveMsg) {
                if (pqmsg == FindQMsg(pti, pmlPost, pwndFilter, msgMin, msgMax, FALSE)) {
                    pqmsg->msg = *lpMsg;
                }
            }
        }
#if DBG
        else if (CheckMsgFilter(lpMsg->message, WM_DDE_FIRST, WM_DDE_LAST)) {
            if (fRemoveMsg) {
                TraceDdeMsg(lpMsg->message, (HWND)lpMsg->wParam, lpMsg->hwnd, MSG_RECV);
            } else {
                TraceDdeMsg(lpMsg->message, (HWND)lpMsg->wParam, lpMsg->hwnd, MSG_PEEK);
            }
        }
#endif
    }

    /*
     * If there are no posted messages available, clear the post message
     * bit so we don't go looking for them again.
     */
    if (pmlPost->cMsgs == 0 && !(pti->TIF_flags & TIF_QUITPOSTED)) {
        pti->pcti->fsWakeBits &= ~(QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
        pti->pcti->fsChangeBits &= ~QS_ALLPOSTMESSAGE;
    }

    return pqmsg != NULL;
}

#ifdef HUNGAPP_GHOSTING
/***************************************************************************\
* xxxProcessHungThreadEvent
*
* We check when a thread gets unhung when it reads the posted queue message.
*
* 6-10-99   vadimg      created
\***************************************************************************/
VOID xxxProcessHungThreadEvent(
    PWND pwnd)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndGhost;
    HWND hwnd, hwndGhost;
    TL tlpwndT1, tlpwndT2;
    BOOL fUnlockGhost = FALSE;

    CheckLock(pwnd);

    /*
     * The app processed this queue message, so update time last read
     * used for hung app calculations.
     */
    SET_TIME_LAST_READ(ptiCurrent);

    pwndGhost = FindGhost(pwnd);

    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT1);

    if (pwndGhost != NULL) {
        PCHECKPOINT pcp, pcpGhost;

        ThreadLockAlwaysWithPti(ptiCurrent, pwndGhost, &tlpwndT2);
        fUnlockGhost = TRUE;

        /*
         * Try to set the state of the hung window to the current state of
         * the ghost window.
         */
        if (TestWF(pwndGhost, WFMAXIMIZED)) {
            xxxMinMaximize(pwnd, SW_MAXIMIZE, MINMAX_KEEPHIDDEN);
        } else if (TestWF(pwndGhost, WFMINIMIZED)) {
            xxxMinMaximize(pwnd, SW_SHOWMINNOACTIVE, MINMAX_KEEPHIDDEN);
        } else {
            DWORD dwFlags;
            PTHREADINFO pti = GETPTI(pwndGhost);

            /*
             * If the ghost is the active foreground window, allow this
             * activation to bring the hung window to the foreground.
             */
            if (pti->pq == gpqForeground && pti->pq->spwndActive == pwndGhost) {
                dwFlags = 0;
                GETPTI(pwnd)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            } else {
                dwFlags = SWP_NOACTIVATE;
            }

            /*
             * Unless the user explicitly moved or sized the ghost window,
             * Don't copy it's location and size to the unhung window.
             * See bug#s 415519 and 413418
             */
            if (!GhostSizedOrMoved(pwnd)) {
                dwFlags |= (SWP_NOMOVE | SWP_NOSIZE) ;
            }
            /*
             * This will appropriately zorder, activate, and position the
             * hung window.
             */
            xxxSetWindowPos(pwnd, pwndGhost,
                    pwndGhost->rcWindow.left, pwndGhost->rcWindow.top,
                    pwndGhost->rcWindow.right - pwndGhost->rcWindow.left,
                    pwndGhost->rcWindow.bottom - pwndGhost->rcWindow.top,
                    dwFlags);
        }

        /*
         * Since the ghost window could've been minimized or maximized during
         * its lifetime, copy over the positioning checkpoint.
         */
        if ((pcpGhost = (PCHECKPOINT)_GetProp(pwndGhost,
                PROP_CHECKPOINT, PROPF_INTERNAL)) != NULL) {

            if ((pcp = (PCHECKPOINT)_GetProp(pwnd,
                    PROP_CHECKPOINT, PROPF_INTERNAL)) == NULL) {
                pcp = CkptRestore(pwnd, &pwnd->rcWindow);
            }

            if (pcp != NULL) {
                RtlCopyMemory(pcp, pcpGhost, sizeof(CHECKPOINT));
            }
        }
    }

    /*
     * Toggle the visible bit of the hung window and remove the ghost window
     * corresponding to this previously hung window.
     */
    if (TestWF(pwnd, WEFGHOSTMAKEVISIBLE)) {
        SetVisible(pwnd, SV_SET);
    }
    RemoveGhost(pwnd);

    /*
     * Make the shell aware again of the hung window.
     */
    hwnd = PtoHq(pwnd);
    hwndGhost = PtoH(pwndGhost);
    PostShellHookMessages(HSHELL_WINDOWREPLACING, (LPARAM)hwnd);
    PostShellHookMessages(HSHELL_WINDOWREPLACED, (LPARAM)hwndGhost);
    xxxCallHook(HSHELL_WINDOWREPLACED, (WPARAM)hwndGhost, (LPARAM)hwnd, WH_SHELL);

    /*
     * Completely invalidate the hung window, since it became visible again.
     */
    if (TestWF(pwnd, WEFGHOSTMAKEVISIBLE)) {
        xxxRedrawWindow(pwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE |
                RDW_ALLCHILDREN | RDW_FRAME);
    }
    if (fUnlockGhost) {
        ThreadUnlock(&tlpwndT2);
    }
    ThreadUnlock(&tlpwndT1);
}

#else // HUNGAPP_GHOSTING

VOID xxxProcessHungThreadEvent(
    PWND pwnd)
{
    CheckLock(pwnd);

    if (TestWF(pwnd, WFVISIBLE)) {
        RIPMSG0(RIP_WARNING, "xxxProcessHungThreadEvent: window is already visible");
    } else {
        SetVisible(pwnd, SV_SET);

        if (TestWF(pwnd, WFMINIMIZED)) {
            RIPMSG0(RIP_WARNING, "xxxProcessHungThreadEvent: window is already minmized");
        } else {
            xxxMinMaximize(pwnd, SW_SHOWMINNOACTIVE, MINMAX_KEEPHIDDEN);
        }
    }
}

#endif // HUNGAPP_GHOSTING

BEEPPROC pfnBP[] = {
    UpSiren,
    DownSiren,
    LowBeep,
    HighBeep,
    KeyClick};

/***************************************************************************\
* xxxProcessEventMessage
*
* This handles our processing for 'event' messages. We return a BOOL
* here telling the system whether or not to continue processing messages.
*
* History:
* 06-17-91 DavidPe      Created.
\***************************************************************************/

VOID xxxProcessEventMessage(
    PTHREADINFO ptiCurrent,
    PQMSG pqmsg)
{
    PWND pwnd;
    TL tlpwndT;
    TL tlMsg;
    PQ pq;

    UserAssert(IsWinEventNotifyDeferredOK());
    UserAssert(ptiCurrent == PtiCurrent());

    ThreadLockPoolCleanup(ptiCurrent, pqmsg, &tlMsg, CleanEventMessage);

    pq = ptiCurrent->pq;
    switch (pqmsg->dwQEvent) {
    case QEVENT_DESTROYWINDOW:
        /*
         * These events are posted from xxxDW_DestroyOwnedWindows
         * for owned windows that are not owned by the owner
         * window thread.
         */
        pwnd = RevalidateHwnd((HWND)pqmsg->msg.wParam);
        if (pwnd != NULL) {
            if (!TestWF(pwnd, WFCHILD))
                xxxDestroyWindow(pwnd);
            else {
                ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
                xxxFreeWindow(pwnd, &tlpwndT);
            }
        }
        break;

    case QEVENT_SHOWWINDOW:
        /*
         * These events are mainly used from within CascadeChildWindows()
         * and TileChildWindows() so that taskmgr doesn't hang while calling
         * these apis if it is trying to tile or cascade a hung application.
         */
        /* The HIWORD of lParam now has the preserved state of gfAnimate at the
         * time of the call.
         */
        pwnd = RevalidateHwnd((HWND)pqmsg->msg.wParam);
        if (pwnd != NULL && !TestWF(pwnd, WFINDESTROY)) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
            xxxShowWindow(pwnd, (DWORD)pqmsg->msg.lParam);
            /*
             * If this is coming from an async SetWindowPlacement, update the
             *  check point settings if the window is minimized.
             */
            if ((pqmsg->msg.message & WPF_ASYNCWINDOWPLACEMENT)
                    && TestWF(pwnd, WFMINIMIZED)) {

                WPUpdateCheckPointSettings(pwnd, (UINT)pqmsg->msg.message);
            }
            ThreadUnlock(&tlpwndT);
        }
        break;

    case QEVENT_NOTIFYWINEVENT:
        UserAssert(((PNOTIFY)pqmsg->msg.lParam)->dwWEFlags & WEF_POSTED);
        UserAssert(((PNOTIFY)pqmsg->msg.lParam)->dwWEFlags & WEF_ASYNC);
        xxxProcessNotifyWinEvent((PNOTIFY)pqmsg->msg.lParam);
        break;

    case QEVENT_SETWINDOWPOS:
        /*
         * QEVENT_SETWINDOWPOS events are generated when a thread calls
         * SetWindowPos with a list of windows owned by threads other than
         * itself. This way all WINDOWPOSing on a window is done the thread
         * that owns (created) the window and we don't have any of those
         * nasty inter-thread synchronization problems.
         */
        xxxProcessSetWindowPosEvent((PSMWP)pqmsg->msg.wParam);
        break;

    case QEVENT_UPDATEKEYSTATE:
        /*
         * Update the local key state with the state from those
         * keys that have changed since the last time key state
         * was synchronized.
         */
        ProcessUpdateKeyStateEvent(pq, (PBYTE)pqmsg->msg.wParam, (PBYTE)pqmsg->msg.wParam + CBKEYSTATE);
        break;

    case QEVENT_ACTIVATE:
    {
        if (pqmsg->msg.lParam == 0) {

            /*
             * Clear any visible tracking going on in system. We
             * only bother to do this if lParam == 0 since
             * xxxSetForegroundWindow2() deals with this in the
             * other case.
             */
            xxxCancelTracking();

            /*
             * Remove the clip cursor rectangle - it is a global mode that
             * gets removed when switching. Also remove any LockWindowUpdate()
             * that's still around.
             */
            zzzClipCursor(NULL);
            LockWindowUpdate2(NULL, TRUE);

            /*
             * Reload pq because it may have changed.
             */
            pq = ptiCurrent->pq;

            /*
             * If this event didn't originate from an initializing app
             * coming to the foreground [wParam == 0] then go ahead
             * and check if there's already an active window and if so make
             * it visually active. Also make sure we're still the foreground
             * queue.
             */
            if ((pqmsg->msg.wParam != 0) && (pq->spwndActive != NULL) &&
                    (pq == gpqForeground)) {
                PWND pwndActive;

                ThreadLockAlwaysWithPti(ptiCurrent, pwndActive = pq->spwndActive, &tlpwndT);
                xxxSendMessage(pwndActive, WM_NCACTIVATE, TRUE, 0);
                xxxUpdateTray(pwndActive);
                xxxSetWindowPos(pwndActive, PWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
                ThreadUnlock(&tlpwndT);
            } else if (pq != gpqForeground) {

                /*
                 * If we're not being activated, make sure we don't become foreground.
                 */
                ptiCurrent->TIF_flags &= ~TIF_ALLOWFOREGROUNDACTIVATE;
                TAGMSG1(DBGTAG_FOREGROUND, "xxxProcessEventMessage clear TIF %#p", ptiCurrent);
                ptiCurrent->ppi->W32PF_Flags &= ~W32PF_ALLOWFOREGROUNDACTIVATE;
                TAGMSG1(DBGTAG_FOREGROUND, "xxxProcessEventMessage clear W32PF %#p", ptiCurrent->ppi);
            }

        } else {

            pwnd = RevalidateHwnd((HWND)pqmsg->msg.lParam);
            if (pwnd == NULL)
                break;

            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);

            /*
             * If nobody is foreground, allow this app to become foreground.
             */
            if (gpqForeground == NULL) {
                xxxSetForegroundWindow2(pwnd, ptiCurrent, 0);
            } else {
                if (pwnd != pq->spwndActive) {
                    if (xxxActivateThisWindow(pwnd, (UINT)pqmsg->msg.wParam,
                            (ATW_SETFOCUS | ATW_ASYNC) |
                            ((pqmsg->msg.message & PEM_ACTIVATE_NOZORDER) ? ATW_NOZORDER : 0))) {

                        /*
                         * This event was posted by SetForegroundWindow2
                         * (i.e. pqmsg->msg.lParam != 0) so make sure
                         * mouse is on this window.
                         */
                        if (TestUP(ACTIVEWINDOWTRACKING)) {
                            zzzActiveCursorTracking(pwnd);
                        }
                    }
                } else {
                    BOOL fActive = (GETPTI(pwnd)->pq == gpqForeground);

                    xxxSendMessage(pwnd, WM_NCACTIVATE,
                            (DWORD)(fActive), 0);
                    if (fActive) {
                        xxxUpdateTray(pwnd);
                    }

                    /*
                     * Only bring the window to the top if it is becoming active.
                     */
                    if (fActive && !(pqmsg->msg.message & PEM_ACTIVATE_NOZORDER))
                        xxxSetWindowPos(pwnd, PWND_TOP, 0, 0, 0, 0,
                                SWP_NOSIZE | SWP_NOMOVE);
                }
            }

            /*
             * Check here to see if the window needs to be restored. This is a
             * hack so that we're compatible with what msmail expects out of
             * win3.1 alt-tab. msmail expects to always be active when it gets
             * asked to be restored. This will ensure that during alt-tab
             * activate.
             */
            if (pqmsg->msg.message & PEM_ACTIVATE_RESTORE) {
                if (TestWF(pwnd, WFMINIMIZED)) {
                    _PostMessage(pwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
                }
            }

            ThreadUnlock(&tlpwndT);
        }

    }
        break;

    case QEVENT_DEACTIVATE:
        xxxDeactivate(ptiCurrent, (DWORD)pqmsg->msg.wParam);
        break;

    case QEVENT_CANCELMODE:
        if (pq->spwndCapture != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pq->spwndCapture, &tlpwndT);
            xxxSendMessage(pq->spwndCapture, WM_CANCELMODE, 0, 0);
            ThreadUnlock(&tlpwndT);

            /*
             * Set QS_MOUSEMOVE so any sleeping modal loops,
             * like the move/size code, will wake up and figure
             * out that it should abort.
             */
            SetWakeBit(ptiCurrent, QS_MOUSEMOVE);
        }
        break;


    case QEVENT_POSTMESSAGE:
        /*
         * This event is used in situations where we need to ensure that posted
         * messages are processed after previous QEVENT's. Normally, posting a
         * queue event and then calling postmessage will result in the posted
         * message being seen first by the app (because posted messages are
         * processed before input.) Instead we will post a QEVENT_POSTMESSAGE
         * instead of doing a postmessage directly, which will result in the
         * correct ordering of messages.
         *
         */

        if (pwnd = RevalidateHwnd((HWND)pqmsg->msg.hwnd)) {

            _PostMessage(pwnd,pqmsg->msg.message,pqmsg->msg.wParam,pqmsg->msg.lParam);
        }
        break;


    case QEVENT_ASYNCSENDMSG:
        xxxProcessAsyncSendMessage((PASYNCSENDMSG)pqmsg->msg.wParam);
        break;

    case QEVENT_HUNGTHREAD:
        pwnd = RevalidateHwnd((HWND)pqmsg->msg.hwnd);
        if (pwnd != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
            xxxProcessHungThreadEvent(pwnd);
            ThreadUnlock(&tlpwndT);
        }
        break;

    case QEVENT_CANCELMOUSEMOVETRK: {
        /*
         * hwnd: hwndTrack. message: dwDTFlags.
         * wParam: htEx. lParam: dwDTCancel
         */
        PDESKTOP pdesk = ptiCurrent->rpdesk;
        pwnd = RevalidateHwnd((HWND)pqmsg->msg.hwnd);
        /*
         * Let's check that the app didn't manage to restart mouse leave
         *  tracking before we had a chance to cancel it.
         */
        UserAssert(!(pqmsg->msg.message & DF_TRACKMOUSELEAVE)
                    || !(pdesk->dwDTFlags & DF_TRACKMOUSELEAVE)
                    || (PtoHq(pdesk->spwndTrack) != pqmsg->msg.hwnd)
                    || !((pdesk->htEx == HTCLIENT) ^ ((int)pqmsg->msg.wParam == HTCLIENT)));
        /*
         * If we're back tracking at the same spot, bail
         */
        if ((pdesk->dwDTFlags & DF_MOUSEMOVETRK)
                && (PtoHq(pdesk->spwndTrack) == pqmsg->msg.hwnd)
                && (pdesk->htEx == (int)pqmsg->msg.wParam)) {
            /*
             * If we're tracking mouse leave,
             */
            break;
        }
        /*
         * Don't nuke the tooltip if it has been reactivated.
         */
        if (pdesk->dwDTFlags & DF_TOOLTIPACTIVE) {
            pqmsg->msg.lParam &= ~DF_TOOLTIP;
        }
        /*
         * Cancel tracking if the window is still around
         */
        if (pwnd != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
            xxxCancelMouseMoveTracking(pqmsg->msg.message, pwnd,
                                   (int)pqmsg->msg.wParam,
                                   (DWORD)pqmsg->msg.lParam);
            ThreadUnlock(&tlpwndT);
        } else if ((pqmsg->msg.lParam & DF_TOOLTIP)
                && (pqmsg->msg.message & DF_TOOLTIPSHOWING)) {
            /*
             * The window is gone and so must be tracking.
             * Just take care of the tooltip which is still showing.
             */
            pwnd = pdesk->spwndTooltip;
            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
            xxxResetTooltip((PTOOLTIPWND)pwnd);
            ThreadUnlock(&tlpwndT);
        }
    }
    break;

    case QEVENT_RITACCESSIBILITY:
        if (IsHooked(ptiCurrent, WHF_SHELL)) {
            xxxCallHook((UINT)pqmsg->msg.wParam,
                        (WPARAM)pqmsg->msg.lParam,
                        (LPARAM)0,
                        WH_SHELL);
        }

        PostShellHookMessages((UINT)pqmsg->msg.wParam, pqmsg->msg.lParam);
        break;

    case QEVENT_RITSOUND:
        /*
         * This should only happen on the desktop thread.
         */

#if !defined(_WIN64)

        switch(pqmsg->msg.message) {
        case RITSOUND_UPSIREN:
        case RITSOUND_DOWNSIREN:
        case RITSOUND_LOWBEEP:
        case RITSOUND_HIGHBEEP:
        case RITSOUND_KEYCLICK:
            (pfnBP[pqmsg->msg.message])();
            break;

        case RITSOUND_DOBEEP:
            switch(pqmsg->msg.wParam) {
            case RITSOUND_UPSIREN:
            case RITSOUND_DOWNSIREN:
            case RITSOUND_LOWBEEP:
            case RITSOUND_HIGHBEEP:
            case RITSOUND_KEYCLICK:
                DoBeep(pfnBP[pqmsg->msg.wParam], (DWORD)pqmsg->msg.lParam);
            }
            break;
        }

#else
        {
            UINT uCount;
            UINT uSound;

            /*
             * The above code uses UserBeep() - which doesn't do anything
             * useful on Win64. (IA64 spec doesn't include a h/w speaker.)
             *
             * Instead, we post a message to WinLogon to ask it to play a sound
             * for us using the PlaySound.
             */

            /*
             * RITSOUND_DOBEEP is used to repeat a sound n times. It is currently
             * only used to repeat UPSIREN 2 or 3 times, for stickykeys, when the
             * right shift is held down for 12 and 16 seconds.
             */

            if (pqmsg->msg.message == RITSOUND_DOBEEP) {
                uSound = (UINT) pqmsg->msg.wParam;
                uCount = (UINT) pqmsg->msg.lParam;
                if( uCount > 5 ) {
                    uCount = 5;
                }
            } else {
                uSound = pqmsg->msg.message;
                uCount = 1;
            }

            if (gspwndLogonNotify != NULL) {
                while(uCount--) {
                    _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                             LOGON_PLAYEVENTSOUND, MAKELPARAM(uSound, ACCESS_SOUND_RANGE));
                }
            }

            /*
             *  Since PlaySound doesn't currently flash the window if SoundSentry
             *  is active, we have to do it ourselces here.
             *  (On 32-bit, UserBeep() takes care of doing that.)
             */
             _UserSoundSentryWorker();
        }

#endif

        break;

    case QEVENT_APPCOMMAND: {
        /*
         * qevent app commands so we can post a wm_appcommand to the queue
         */
        THREADINFO  *ptiWindowOwner;
        int         cmd;
        UINT        keystate;

        /*
         * Check the appcommand's are within reasonable ranges. If they aren't
         * then we have an internal consistency error since xxxKeyEvent should
         * have generated correct ones for us.
         */
        UserAssert( pqmsg->msg.lParam >= VK_APPCOMMAND_FIRST &&
                    pqmsg->msg.lParam <= VK_APPCOMMAND_LAST );

        /*
         * We need to work out which window to send to here. Using the same
         * rules as from xxxScanSysQueue:
         * Assign the input to the focus window. If there is no focus
         * window, assign it to the active window as a SYS message.
         */
        pwnd = ptiCurrent->pq->spwndFocus;
        if (!pwnd) {
            pwnd = ptiCurrent->pq->spwndActive;
            if (!pwnd) {
                /*
                 * At the moment we will just eat the message since we can't find a foreground q
                 * This follows the method that any other app (eg hidserv) would mimic to
                 * find the window to send to.
                 */
                break;
            }
        }

        /*
         * We don't want to block on another thread since the xxxSendMessage is a synchronous call
         * so we post the message to the queue of the window owner thread
         */
        ptiWindowOwner = GETPTI(pwnd);
        if (ptiCurrent != ptiWindowOwner) {
            /*
             * Post the event message to the window who should get it
             */
            PostEventMessage(ptiWindowOwner, ptiWindowOwner->pq, QEVENT_APPCOMMAND,
                             NULL, 0, (WPARAM)0, pqmsg->msg.lParam);

            /*
             * Break out of this since we've now posted the message to a
             * different q - we don't want to deal with it here.
             */
            break;
        }

        cmd = APPCOMMAND_FIRST + ((UINT)pqmsg->msg.lParam - VK_APPCOMMAND_FIRST);
        keystate = GetMouseKeyFlags(ptiWindowOwner->pq);
        pqmsg->msg.lParam = MAKELPARAM(keystate, cmd);


        /*
         * Generate a WM_APPCOMMAND message from the keyboard keys.
         */
        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwndT);
        xxxSendMessage(pwnd, WM_APPCOMMAND, (WPARAM)HWq(pwnd), pqmsg->msg.lParam);
        ThreadUnlock(&tlpwndT);

        break;
    }
    default:
        RIPMSG1(RIP_ERROR, "xxxProcessEventMessage Bad pqmsg->dwQEvent:%#lx", pqmsg->dwQEvent);
        break;
    }

    ThreadUnlockPoolCleanup(ptiCurrent, &tlMsg);
}


#define QS_TEST_AND_CLEAR (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_SENDMESSAGE)
#define QS_TEST           (QS_MOUSEBUTTON | QS_KEY)

/***************************************************************************\
* _GetInputState (API)
*
* Returns the current input state for mouse buttons or keys.
*
* History:
* 11-06-90 DavidPe      Created.
\***************************************************************************/
BOOL _GetInputState(
    VOID)
{
    if (LOWORD(_GetQueueStatus(QS_TEST_AND_CLEAR)) & QS_TEST) {
        return TRUE;
    } else {
        return FALSE;
    }
}

#undef QS_TEST_AND_CLEAR
#undef QS_TEST

/***************************************************************************\
* _GetQueueStatus (API)
*
* Returns the changebits in the lo-word and wakebits in
* the hi-word for the current queue.
*
* History:
* 12-17-90 DavidPe      Created.
\***************************************************************************/
DWORD _GetQueueStatus(
    UINT flags)
{
    PTHREADINFO ptiCurrent;
    UINT fsChangeBits;

    ptiCurrent = PtiCurrentShared();

    flags &= (QS_ALLINPUT | QS_ALLPOSTMESSAGE | QS_TRANSFER);

    fsChangeBits = ptiCurrent->pcti->fsChangeBits;

    /*
     * Clear out the change bits the app is looking at
     * so it'll know what changed since it's last call
     * to GetQueueStatus().
     */
    ptiCurrent->pcti->fsChangeBits &= ~flags;

    /*
     * Return the current change/wake-bits.
     */
    return MAKELONG(fsChangeBits & flags,
            (ptiCurrent->pcti->fsWakeBits | ptiCurrent->pcti->fsWakeBitsJournal) & flags);
}

/***************************************************************************\
* xxxMsgWaitForMultipleObjects (API)
*
* Blocks until an 'event' satisifying dwWakeMask occurs for the
* current thread as well as all other objects specified by the other
* parameters which are the same as the base call WaitForMultipleObjects().
*
* pfnNonMsg indicates that pHandles is big enough for nCount+1 handles
* (empty slot at end, and to call pfnNonMsg for non message events).
*
* History:
* 12-17-90 DavidPe      Created.
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, xxxMsgWaitForMultipleObjects)
#endif

DWORD xxxMsgWaitForMultipleObjects(
    DWORD nCount,
    PVOID *apObjects,
    MSGWAITCALLBACK pfnNonMsg,
    PKWAIT_BLOCK WaitBlockArray)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    NTSTATUS Status;

    ptiCurrent = PtiCurrent();
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Setup the wake mask for this thread. Wait for QS_EVENT or the app won't
     * get event messages like deactivate.
     */
    ClearQueueServerEvent(QS_ALLINPUT | QS_EVENT);

    /*
     * Stuff the event handle for the current queue at the end.
     */
    apObjects[nCount] = ptiCurrent->pEventQueueServer;

    /*
     * Check to see if any input came inbetween when we
     * last checked and the NtClearEvent() call.
     */
    if (!(ptiCurrent->pcti->fsChangeBits & QS_ALLINPUT)) {

        /*
         * This app is going idle. Clear the spin count check to see
         * if we need to make this process foreground again.
         */
        if (ptiCurrent->TIF_flags & TIF_SPINNING) {
            CheckProcessForeground(ptiCurrent);
        }
        ptiCurrent->pClientInfo->cSpins = 0;

        if (ptiCurrent == gptiForeground &&
                IsHooked(ptiCurrent, WHF_FOREGROUNDIDLE)) {
            xxxCallHook(HC_ACTION, 0, 0, WH_FOREGROUNDIDLE);
        }

        /*
         * Set the input idle event to wake up any threads waiting
         * for this thread to go into idle state.
         */
        zzzWakeInputIdle(ptiCurrent);

Again:
        LeaveCrit();

        Status = KeWaitForMultipleObjects(nCount + 1, apObjects,
                WaitAny, WrUserRequest,
                UserMode, FALSE,
                NULL, WaitBlockArray);

        EnterCrit();

        UserAssert(NT_SUCCESS(Status));

        if (Status == STATUS_WAIT_0 && pfnNonMsg != NULL) {
            /*
             * Call pfnNonMsg for the first event
             */
            pfnNonMsg(DEVICE_TYPE_MOUSE);

            /*
             * Setup again the wake mask for this thread.
             * Wait for QS_EVENT or the app won't
             * get event messages like deactivate.
             */
            ptiCurrent->pcti->fsWakeMask = QS_ALLINPUT | QS_EVENT;
            goto Again;
        }

        if (Status == (NTSTATUS)(STATUS_WAIT_0 + nCount)) {

            /*
             * Reset the input idle event to block and threads waiting
             * for this thread to go into idle state.
             */
            SleepInputIdle(ptiCurrent);
        }
    } else {
        Status = nCount;
    }

    /*
     * Clear fsWakeMask since we're no longer waiting on the queue.
     */
    ptiCurrent->pcti->fsWakeMask = 0;

    return (DWORD)Status;
}

/***************************************************************************\
* xxxSleepThread
*
* Blocks until an 'event' satisifying fsWakeMask occurs for the
* current thread.
*
* History:
* 10-28-90 DavidPe      Created.
\***************************************************************************/
BOOL xxxSleepThread(
    UINT fsWakeMask,
    DWORD Timeout,
    BOOL fInputIdle)
{
    PTHREADINFO ptiCurrent;
    LARGE_INTEGER li, *pli;
    NTSTATUS status = STATUS_SUCCESS;
    BOOL fExclusive = fsWakeMask & QS_EXCLUSIVE;
    WORD fsWakeMaskSaved;
    BOOL fRet = FALSE;

    UserAssert(IsWinEventNotifyDeferredOK());

    if (fExclusive) {
        /*
         * The exclusive bit is a 'dummy' arg, turn it off to
         * avoid any possible conflicts.
         */
        fsWakeMask = fsWakeMask & ~QS_EXCLUSIVE;
    }

    if (Timeout) {
        /*
         * Convert dwMilliseconds to a relative-time (i.e. negative)
         * LARGE_INTEGER. NT Base calls take time values in 100 nanosecond
         * units.
         */
        li.QuadPart = Int32x32To64(-10000, Timeout);
        pli = &li;
    } else {
        pli = NULL;
    }

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    fsWakeMaskSaved = ptiCurrent->pcti->fsWakeMask;

    while (TRUE) {

        /*
         * First check if the input has arrived.
         */
        if (ptiCurrent->pcti->fsChangeBits & fsWakeMask) {
            fRet = TRUE;

GetOutFromHere:
            /*
             * Restore the wake mask to what it was before we went to sleep
             * to allow possible callbacks before KeWait... but after the mask
             * has been set and also APCs from KeWait... to still be able to
             * wake up. Simply clearing the mask here if we're in such a
             * callback or in an APC means that the thread will never wake up.
             */
            ptiCurrent->pcti->fsWakeMask = fsWakeMaskSaved;

            if (fRet) {
                /*
                 * Update timeLastRead - it is used for hung app calculations.
                 * If the thread is waking up to process input, it isn't hung!
                 */
                SET_TIME_LAST_READ(ptiCurrent);
            }
            return fRet;
        }

        /*
         * Next check for SendMessages
         */
        if (!fExclusive && ptiCurrent->pcti->fsWakeBits & QS_SENDMESSAGE) {
            xxxReceiveMessages(ptiCurrent);

            /*
             * Restore the change bits we took out in PeekMessage()
             */
            ptiCurrent->pcti->fsChangeBits |= (ptiCurrent->pcti->fsWakeBits & ptiCurrent->fsChangeBitsRemoved);
            ptiCurrent->fsChangeBitsRemoved = 0;
        }

        /*
         * Check to see if some resources need expunging.
         * This will unload hook DLLs, including WinEvent ones.
         */
        if (ptiCurrent->ppi->cSysExpunge != gcSysExpunge) {
            ptiCurrent->ppi->cSysExpunge = gcSysExpunge;
            if (ptiCurrent->ppi->dwhmodLibLoadedMask & gdwSysExpungeMask)
                xxxDoSysExpunge(ptiCurrent);
        }

        /*
         * OR QS_SENDMESSAGE in since ReceiveMessage() will end up
         * trashing pq->fsWakeMask. Do the same for QS_SYSEXPUNGE.
         */
        ClearQueueServerEvent((WORD)(fsWakeMask | (fExclusive ? 0 : QS_SENDMESSAGE)));

        /*
         * If we have timed out then return our error to the caller.
         */
        if (status == STATUS_TIMEOUT) {
            RIPERR1(ERROR_TIMEOUT, RIP_VERBOSE, "SleepThread: The timeout has expired %lX", Timeout);
            UserAssert(fRet == FALSE);
            goto GetOutFromHere;
        }

        /*
         * Because we do a non-alertable wait, we know that a status
         * of STATUS_USER_APC means that the thread was terminated.
         * If we have terminated, get back to user mode.
         */
        if (status == STATUS_USER_APC) {
#if DBG
            if (ptiCurrent == gptiRit || ptiCurrent == gTermIO.ptiDesktop) {
                /*
                 * If STATUS_USER_APC is caught in the system threads,
                 * that most likely means the thread was terminated by
                 * someone inadvertently.
                 */
                RIPMSG1(RIP_WARNING, "xxxSleepThread: STATUS_USER_APC caught in the system thread pti=%p", ptiCurrent);
            }
#endif

            ClientDeliverUserApc();
            UserAssert(fRet == FALSE);
            goto GetOutFromHere;
        }

        /*
         * If this is the power state callout thread, we might need to bail
         * out early.
         */
        if (gPowerState.pEvent == ptiCurrent->pEventQueueServer) {
            if (gPowerState.fCritical) {
                UserAssert(fRet == FALSE);
                goto GetOutFromHere;
            }
        }

        UserAssert(status == STATUS_SUCCESS);
        /*
         * Check to see if any input came inbetween when we
         * last checked and the NtClearEvent() call.
         *
         * We call NtWaitForSingleObject() rather than
         * WaitForSingleObject() so we can set fAlertable
         * to TRUE and thus allow timer APCs to be processed.
         */
        if (!(ptiCurrent->pcti->fsChangeBits & ptiCurrent->pcti->fsWakeMask)) {
            /*
             * This app is going idle. Clear the spin count check to see
             * if we need to make this process foreground again.
             */
            if (fInputIdle) {
                if (ptiCurrent->TIF_flags & TIF_SPINNING) {
                    CheckProcessForeground(ptiCurrent);
                }
                ptiCurrent->pClientInfo->cSpins = 0;
            }


            if (!(ptiCurrent->TIF_flags & TIF_16BIT))  {
                if (fInputIdle && ptiCurrent == gptiForeground &&
                        IsHooked(ptiCurrent, WHF_FOREGROUNDIDLE)) {
                    xxxCallHook(HC_ACTION, 0, 0, WH_FOREGROUNDIDLE);
                }

                /*
                 * Set the input idle event to wake up any threads waiting
                 * for this thread to go into idle state.
                 */
                if (fInputIdle) {
                    zzzWakeInputIdle(ptiCurrent);
                }

                xxxSleepTask(fInputIdle, NULL);

                LeaveCrit();
                status = KeWaitForSingleObject(ptiCurrent->pEventQueueServer,
                        WrUserRequest, UserMode, FALSE, pli);
                EnterCrit();

                /*
                 * Reset the input idle event to block and threads waiting
                 * for this thread to go into idle state.
                 */
                SleepInputIdle(ptiCurrent);

                /*
                 *  ptiCurrent is 16bit!
                 */
            } else {
                if (fInputIdle) {
                    zzzWakeInputIdle(ptiCurrent);
                }

                xxxSleepTask(fInputIdle, NULL);
            }
        }
    }
}


/***************************************************************************\
* SetWakeBit
*
* Adds the specified wake bit to specified THREADINFO and wakes its
* thread up if the bit is in its fsWakeMask.
*
* Nothing will happen in the system unless we come to this function.
* So be fast and small.
*
* History:
* 10-28-90 DavidPe      Created.
\***************************************************************************/
VOID SetWakeBit(
    PTHREADINFO pti,
    UINT wWakeBit)
{
    CheckCritIn();

    UserAssert(pti);

    /*
     * Win3.1 changes ptiKeyboard and ptiMouse accordingly if we're setting
     * those bits.
     */
    if (wWakeBit & QS_MOUSE)
        pti->pq->ptiMouse = pti;

#ifdef GENERIC_INPUT
    if (wWakeBit & (QS_KEY | QS_RAWINPUT)) {
        pti->pq->ptiKeyboard = pti;
    }
#else
    if (wWakeBit & QS_KEY)
        pti->pq->ptiKeyboard = pti;
#endif

    /*
     * OR in these bits - these bits represent what input this app has
     * (fsWakeBits), or what input has arrived since that last look
     * (fsChangeBits).
     */
    pti->pcti->fsWakeBits |= wWakeBit;
    pti->pcti->fsChangeBits |= wWakeBit;

    /*
     * Before waking, do screen saver check to see if it should
     * go away.
     */
    if ((wWakeBit & QS_INPUT)
            && (pti->ppi->W32PF_Flags & W32PF_IDLESCREENSAVER)) {
        if ((wWakeBit & QS_MOUSEMOVE)
            && (gpsi->ptCursor.x == gptSSCursor.x)
            && (gpsi->ptCursor.y == gptSSCursor.y)) {
            goto SkipScreenSaverStuff;
        }

        /*
         * Our idle screen saver needs to be given a priority boost so that it
         * can process input.
         */
        pti->ppi->W32PF_Flags &= ~W32PF_IDLESCREENSAVER;
        SetForegroundPriority(pti, TRUE);
    }

SkipScreenSaverStuff:
    if (wWakeBit & pti->pcti->fsWakeMask) {
        /*
         * Wake the Thread
         */
        if (pti->TIF_flags & TIF_16BIT) {
            pti->ptdb->nEvents++;
            gpsi->nEvents++;
            WakeWowTask(pti);
        } else {
            KeSetEvent(pti->pEventQueueServer, 2, FALSE);
        }
    }
}

/***************************************************************************\
* TransferWakeBit
*
* We have a mesasge from the system queue. If out input bit for this
* message isn't set, set ours and clear the guy whose bit was set
* because of this message.
*
* 10-22-92 ScottLu      Created.
\***************************************************************************/
VOID TransferWakeBit(
    PTHREADINFO pti,
    UINT message)
{
    PTHREADINFO ptiT;
    UINT fsMask;

    /*
     * Calculate the mask from the message range. Only interested
     * in hardware input here: mouse and keys.
     */
#ifdef GENERIC_INPUT
    fsMask = CalcWakeMask(message, message, 0) & QS_INPUT;
#else
    fsMask = CalcWakeMask(message, message, 0) & (QS_MOUSE | QS_KEY);
#endif

    /*
     * If it is set in this thread's wakebits, nothing to do.
     * Otherwise transfer them from the owner to this thread.
     */
    if (!(pti->pcti->fsWakeBits & fsMask)) {
        /*
         * Either mouse or key is set (not both). Remove this bit
         * from the thread that currently owns it, and change mouse /
         * key ownership to this thread.
         */
        if (fsMask & QS_KEY) {
            ptiT = pti->pq->ptiKeyboard;
            pti->pq->ptiKeyboard = pti;
        } else {
            ptiT = pti->pq->ptiMouse;
            pti->pq->ptiMouse = pti;
        }
        ptiT->pcti->fsWakeBits &= ~fsMask;

        /*
         * Transfer them to this thread (certainly this may be the
         * same thread for win32 threads not sharing queues).
         */
        pti->pcti->fsWakeBits |= fsMask;
        pti->pcti->fsChangeBits |= fsMask;
    }
}

/***************************************************************************\
* ClearWakeBit
*
* Clears wake bits. If fSysCheck is TRUE, this clears the input bits only
* if no messages are in the input queue. Otherwise, it clears input bits
* unconditionally.
*
* 11-05-92 ScottLu      Created.
\***************************************************************************/
VOID ClearWakeBit(
    PTHREADINFO pti,
    UINT wWakeBit,
    BOOL fSysCheck)
{

    /*
     * If fSysCheck is TRUE, clear bits only if we are not doing journal
     * playback and there are no more messages in the queue. fSysCheck
     * is TRUE if clearing because of no more input. FALSE if just
     * transfering input ownership from one thread to another.
     */
    if (fSysCheck) {
        if (pti->pq->mlInput.cMsgs != 0 || FJOURNALPLAYBACK())
            return;
        if (pti->pq->QF_flags & QF_MOUSEMOVED)
            wWakeBit &= ~QS_MOUSEMOVE;
    }

    /*
     * Only clear the wake bits, not the change bits as well!
     */
    pti->pcti->fsWakeBits &= ~wWakeBit;
}



/***************************************************************************\
* PtiFromThreadId
*
* Returns the THREADINFO for the specified thread or NULL if thread
* doesn't exist or doesn't have a THREADINFO.
*
* History:
* 01-30-91  DavidPe     Created.
\***************************************************************************/

PTHREADINFO PtiFromThreadId(
    DWORD dwThreadId)
{
    PETHREAD pEThread;
    PTHREADINFO pti;

    /*
     * NOTE: Pretty much every place else we do call LockThreadByClientId
     * while outside the user critical section so we don't cause any
     * potential deadlock in the kernel.
     * It's too late to change it now. 2/17/99
     *
     * UPDATE [2/18/00]: The window in which we could deadlock is very small,
     * and since we've never actually seen it here, there's no reason to
     * fix this.
     */

    if (!NT_SUCCESS(LockThreadByClientId((HANDLE)LongToHandle( dwThreadId ), &pEThread)))
        return NULL;

    /*
     * If the thread is not terminating, look up the pti. This is
     * needed because the value returned by PtiFromThread() is
     * undefined if the thread is terminating. See PspExitThread in
     * ntos\ps\psdelete.c.
     */
    if (!PsIsThreadTerminating(pEThread)) {
        pti = PtiFromThread(pEThread);
    } else {
        pti = NULL;
    }

    /*
     * Do a sanity check on the pti to make sure it's really valid.
     */
    if (pti != NULL) {
        try {
            if (GETPTIID(pti) != (HANDLE)LongToHandle( dwThreadId )) {
                pti = NULL;
            } else if (!(pti->TIF_flags & TIF_GUITHREADINITIALIZED)) {
                RIPMSG1(RIP_WARNING, "PtiFromThreadId: pti %#p not initialized", pti);
                pti = NULL;
            } else if (pti->TIF_flags & TIF_INCLEANUP) {
                RIPMSG1(RIP_WARNING, "PtiFromThreadId: pti %#p in cleanup", pti);
                pti = NULL;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            pti = NULL;
        }
    }

    UnlockThread(pEThread);

    return pti;
}


/***************************************************************************\
* StoreMessage
*
*
*
* History:
* 10-31-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
VOID StoreMessage(
    LPMSG pmsg,
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD time)
{
    CheckCritIn();

    pmsg->hwnd = HW(pwnd);
    pmsg->message = message;
    pmsg->wParam = wParam;
    pmsg->lParam = lParam;
    pmsg->time = (time != 0 ? time : NtGetTickCount());

    pmsg->pt = gpsi->ptCursor;
}


/***************************************************************************\
* StoreQMessage
*
* If 'time' is 0 grab the current time, if not, it means that this message
* is for an input event and eventually the mouse/keyboard hooks want to see
* the right time stamps.
*
* History:
* 02-27-91 DavidPe      Created.
* 06-15-96 CLupu        Add 'time' parameter
\***************************************************************************/
VOID StoreQMessage(
    PQMSG pqmsg,
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD time,
    DWORD dwQEvent,
    ULONG_PTR dwExtraInfo)
{
    CheckCritIn();

    pqmsg->msg.hwnd    = HW(pwnd);
    pqmsg->msg.message = message;
    pqmsg->msg.wParam  = wParam;
    pqmsg->msg.lParam  = lParam;
    pqmsg->msg.time    = (time == 0) ? NtGetTickCount() : time;

#ifdef REDIRECTION
    if (message >= WM_MOUSEFIRST && message <= WM_MOUSELAST) {
        pqmsg->msg.pt.x = LOWORD(lParam);
        pqmsg->msg.pt.y = HIWORD(lParam);
    } else {
        pqmsg->msg.pt = gpsi->ptCursor;
    }
#else
    pqmsg->msg.pt      = gpsi->ptCursor;
#endif
    pqmsg->dwQEvent    = dwQEvent;
    pqmsg->ExtraInfo   = dwExtraInfo;
}


/***************************************************************************\
* xxxInitProcessInfo
*
* This initializes the process info. Usually gets created before the
* CreateProcess() call returns (so we can synchronize with the starting
* process in several different ways).
*
* 09-18-91 ScottLu      Created.
\***************************************************************************/
NTSTATUS xxxInitProcessInfo(
    PW32PROCESS pwp)
{
    PPROCESSINFO ppi = (PPROCESSINFO)pwp;
    NTSTATUS Status;

    CheckCritIn();

    /*
     * Check if we need to initialize the process.
     */
    if (pwp->W32PF_Flags & W32PF_PROCESSCONNECTED) {
        return STATUS_ALREADY_WIN32;
    }
    pwp->W32PF_Flags |= W32PF_PROCESSCONNECTED;

#if defined(_WIN64)
    /* Tag as emulated 32bit. Flag is copied to be consistent with
     * the way WOW16 apps are tagged for win32k.
     */
    if (PsGetProcessWow64Process(pwp->Process)) {
        pwp->W32PF_Flags |= W32PF_WOW64;
    }
#endif

#ifdef GENERIC_INPUT
    UserAssert(ppi->pHidTable == NULL);
#endif

    /*
     * Mark this app as "starting" - it will be starting until its first
     * window activates.
     */
    UserVerify(xxxSetProcessInitState(pwp->Process, STARTF_FORCEOFFFEEDBACK));

    /*
     * link it into the starting processes list
     */
    SetAppStarting(ppi);
    /*
     * link it into the global processes list
     */
    ppi->ppiNextRunning = gppiList;
    gppiList = ppi;
    /*
     * If foreground activation has not been canceled and the parent process
     *  (or an ancestor) can force a foreground change, then allow this process
     *  to come to the foreground when it does its first activation.
     *
     * Bug 273518 - joejo
     *
     * This will allow console windows to set foreground correctly on new
     * process' it launches, as opposed it just forcing foreground.
     */
    if (TEST_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE) && CheckAllowForeground(pwp->Process)) {
        ppi->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
    }
    TAGMSG2(DBGTAG_FOREGROUND, "xxxInitProcessInfo %s W32PF %#p",
            ((ppi->W32PF_Flags & W32PF_ALLOWFOREGROUNDACTIVATE) ? "set" : "NOT"),
            ppi);

    /*
     * Get the logon session id. This is used to determine which
     * windowstation to connect to and to identify attempts to
     * call hooks across security contexts.
     */
    Status = GetProcessLuid(NULL, &ppi->luidSession);
    UserAssert(NT_SUCCESS(Status));

    /*
     * Ensure that we're in sync with the expunge count
     */
    ppi->cSysExpunge = gcSysExpunge;

    /*
     * Don't perform any LPK callbacks until GDI notifies
     * us that the LPK(s) are loaded and initialized.
     */
    ppi->dwLpkEntryPoints = 0;

    return STATUS_SUCCESS;
}

/***************************************************************************\
* DestroyProcessInfo
*
* This function is executed when the last thread of a process goes
* away.
*
* SO VERY IMPORTANT:
* Note that the last thread of the process might not be a w32 thread. So do
* not make any calls here that assume a w32 pti. Do avoid any function calling
* PtiCurrent() as it probably assumes it is on a nice w32 thread.
*
* Also note that if the process is locked, the ppi is not going away; this
* simply means that execution on this process has ended. So make sure to clean
* up in a way that the ppi data is still valid (for example, if you free a
* pointer, set it to NULL).
*
* zzz Note: Not a zzz routine although it calls zzzCalcStartCursorHide() -
*           Since we can't make callbacks on a non-GUI thread, we use
*           DeferWinEventNotify() & EndDeferWinEventNotifyWithoutProcessing()
*           to prevent callbacks.
*
* 04/08/96 GerardoB     Added header
\***************************************************************************/
BOOL DestroyProcessInfo(
    PW32PROCESS pwp)
{
    PPROCESSINFO ppi = (PPROCESSINFO)pwp;
    PDESKTOPVIEW pdv, pdvNext;
    BOOL  fHadThreads;
    PPUBOBJ ppo;

    CheckCritIn();

    /*
     * Free up input idle event if it exists - wake everyone waiting on it
     * first. This object will get created sometimes even for non-windows
     * processes (usually for WinExec(), which calls WaitForInputIdle()).
     */
    CLOSE_PSEUDO_EVENT(&pwp->InputIdleEvent);

    /*
     * Check to see if the startglass is on, and if so turn it off and update.
     * DeferWinEventNotify to because we cannot process notifications for this
     * thread now (we may have no PtiCurrent, see comment above)
     */
    BEGINATOMICCHECK();
    DeferWinEventNotify();
    if (pwp->W32PF_Flags & W32PF_STARTGLASS) {
        pwp->W32PF_Flags &= ~W32PF_STARTGLASS;
        zzzCalcStartCursorHide(NULL, 0);
    }
    /*
     * This is bookkeeping - restore original notification deferral but without
     * attempting to process any deferred notifications because we have no pti.
     */
    EndDeferWinEventNotifyWithoutProcessing();
    ENDATOMICCHECK();

    /*
     * If the process never called Win32k, we're done.
     */
    if (!(pwp->W32PF_Flags & W32PF_PROCESSCONNECTED)) {
        return FALSE;
    }

#ifdef GENERIC_INPUT
    /*
     * Cleanup the HID devices this process has requested.
     */
    if (ppi->pHidTable) {
        DestroyProcessHidRequests(ppi);
    }
#endif

    /*
     * Play the Process Close sound for non-console processes
     * running on the I/O windowstation.
     */

    if ((ppi->W32PF_Flags & W32PF_IOWINSTA) &&
        !(ppi->W32PF_Flags & W32PF_CONSOLEAPPLICATION) &&
        (gspwndLogonNotify != NULL) &&
        !(ppi->rpwinsta->dwWSF_Flags & WSF_OPENLOCK)) {

        PTHREADINFO pti = GETPTI(gspwndLogonNotify);
        PQMSG pqmsg;

        if ((pqmsg = AllocQEntry(&pti->mlPost)) != NULL) {
            StoreQMessage(pqmsg, gspwndLogonNotify, WM_LOGONNOTIFY,
                    LOGON_PLAYEVENTSOUND, USER_SOUND_CLOSE, 0, 0, 0);

            SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
        }

    }

    /*
     * Be like WIN95.
     * If this is the shell process, then send a LOGON_RESTARTSHELL
     *  notification to the winlogon process (only if not logging off)
     */
    if (IsShellProcess(ppi)) {

        /*
         * The shell process will get killed and it's better to set this
         * in the desktop info.
         */
        ppi->rpdeskStartup->pDeskInfo->ppiShellProcess = NULL;

        /*
         * If we're not logging off, notify winlogon
         */
        if ((gspwndLogonNotify != NULL) &&
             !(ppi->rpwinsta->dwWSF_Flags & WSF_OPENLOCK)) {

            PTHREADINFO pti = GETPTI(gspwndLogonNotify);
            PQMSG pqmsg;

            if ((pqmsg = AllocQEntry(&pti->mlPost)) != NULL) {
                StoreQMessage(pqmsg, gspwndLogonNotify, WM_LOGONNOTIFY,
                        LOGON_RESTARTSHELL, PsGetProcessExitStatus(ppi->Process), 0, 0, 0);
                SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
            }
        }
    }

    if (ppi->cThreads)
        RIPMSG1(RIP_ERROR, "Disconnect with %d threads remaining\n", ppi->cThreads);

    /*
     * If the app is still starting, remove it from the startup list
     */
    if (ppi->W32PF_Flags & W32PF_APPSTARTING) {
        /*
         * Bug 294193 - joejo
         *
         * Handle case when creator process exits before the child
         * process makes it to CheckAllowForeground code. This is typical with
         * stub EXEs that do nothing but create other processes.
         */
        GiveForegroundActivateRight(PsGetProcessId(ppi->Process));
        ClearAppStarting(ppi);
    }

    /*
     * remove it from the global list
     */
    REMOVE_FROM_LIST(PROCESSINFO, gppiList, ppi, ppiNextRunning);

    /*
     * If any threads ever connected, there may be DCs, classes,
     * cursors, etc. still lying around. If no threads connected
     * (which is the case for console apps), skip all of this cleanup.
     */
    fHadThreads = ppi->W32PF_Flags & W32PF_THREADCONNECTED;
    if (fHadThreads) {

        /*
         * When a process dies we need to make sure any DCE's it owns
         * and have not been deleted are cleanup up. The clean up
         * earlier may have failed if the DC was busy in GDI.
         */
        if (ppi->W32PF_Flags & W32PF_OWNDCCLEANUP) {
            DelayedDestroyCacheDC();
        }

#if DBG
        {
            PHE pheT, pheMax;

            /*
             * Loop through the table destroying all objects created by the current
             * process. All objects will get destroyed in their proper order simply
             * because of the object locking.
             */
            pheMax = &gSharedInfo.aheList[giheLast];
            for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {

                /*
                 * We should have no process objects left for this process.
                 */
                UserAssertMsg0(
                        pheT->bFlags & HANDLEF_DESTROY ||
                        !(gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) ||
                        (PPROCESSINFO)pheT->pOwner != ppi,
                        "We should have no process objects left for this process!");
            }
        }
#endif
    }

    if (pwp->UserHandleCount)
        RIPMSG1(RIP_ERROR, "Disconnect with %d User handle objects remaining\n", pwp->UserHandleCount);

    /*
     * check if we need to zap PID's for DDE objects
     */
    for (ppo = gpPublicObjectList;
            ppo != NULL;
                ppo = ppo->next) {
        if (ppo->pid == pwp->W32Pid) {
            ppo->pid = OBJECT_OWNER_PUBLIC;
        }
    }


    if (gppiScreenSaver == ppi) {
        UserAssert(ppi->W32PF_Flags & W32PF_SCREENSAVER);

        gppiScreenSaver = NULL;
    }

    if (gppiForegroundOld == ppi) {
        gppiForegroundOld = NULL;
    }

    if (gppiUserApiHook == ppi) {
        _UnregisterUserApiHook();
    }

    UnlockWinSta(&ppi->rpwinsta);
    UnlockDesktop(&ppi->rpdeskStartup, LDU_PPI_DESKSTARTUP3, (ULONG_PTR)ppi);

    /*
     * Close the startup desktop handle now if it's still around. If we wait
     * until handle table cleanup time we could potentially deadlock.
     */
    if (ppi->hdeskStartup) {
        UserVerify(NT_SUCCESS(CloseProtectedHandle(ppi->hdeskStartup)));
        ppi->hdeskStartup = NULL;
    }

    /*
     * Mark the process as terminated so access checks will work.
     */
    ppi->W32PF_Flags |= W32PF_TERMINATED;

    /*
     * Cleanup wow process info struct, if any
     */
    if (ppi->pwpi) {
        PWOWPROCESSINFO pwpi = ppi->pwpi;

        ObDereferenceObject(pwpi->pEventWowExec);

        REMOVE_FROM_LIST(WOWPROCESSINFO, gpwpiFirstWow, pwpi, pwpiNext);

        UserFreePool(pwpi);
        ppi->pwpi = NULL;
    }

    /*
     * Delete desktop views. System will do unmapping.
     */
    pdv = ppi->pdvList;
    while (pdv) {
        pdvNext = pdv->pdvNext;
        UserFreePool(pdv);
        pdv = pdvNext;
    }
    ppi->pdvList = NULL;

    /*
     * Clear the SendInput/Journalling hook caller ppi
     */
    if (ppi == gppiInputProvider) {
        gppiInputProvider = NULL;
    }
    /*
     * If this ppi locked SetForegroundWindow, clean up
     */
    if (ppi == gppiLockSFW) {
        gppiLockSFW = NULL;
    }

    return fHadThreads;
}

/***************************************************************************\
* ClearWakeMask
*
\***************************************************************************/
VOID ClearWakeMask(
    VOID)
{
    PtiCurrent()->pcti->fsWakeMask = 0;
}

/***************************************************************************\
* xxxGetInputEvent
*
* Returns a duplicated event-handle that the client process can use to
* wait on input events.
*
* History:
* 05-02-91  DavidPe     Created.
\***************************************************************************/
HANDLE xxxGetInputEvent(
    DWORD dwWakeMask)
{
    PTHREADINFO ptiCurrent;
    WORD wFlags = HIWORD(dwWakeMask);
    UserAssert(IsWinEventNotifyDeferredOK());

    ptiCurrent = PtiCurrent();

    /*
     * If our wait condition is satisfied, signal the event and return.
     * (Since the wake mask could have been anything at the time the input
     *  arrived, the event might not be signaled)
     */
    if (GetInputBits(ptiCurrent->pcti, LOWORD(dwWakeMask), (wFlags & MWMO_INPUTAVAILABLE))) {
        KeSetEvent(ptiCurrent->pEventQueueServer, 2, FALSE);
        return ptiCurrent->hEventQueueClient;
    }

    /*
     * If an idle hook is set, call it.
     */
    if (ptiCurrent == gptiForeground &&
            IsHooked(ptiCurrent, WHF_FOREGROUNDIDLE)) {
        xxxCallHook(HC_ACTION, 0, 0, WH_FOREGROUNDIDLE);
    }

    /*
     * What is the criteria for an "idle process"?
     * Answer: The first thread that calls zzzWakeInputIdle, or SleepInputIdle or...
     * Any thread that calls xxxGetInputEvent with any of the following
     * bits set in its wakemask: (sanfords)
     */
    if (dwWakeMask & (QS_POSTMESSAGE | QS_INPUT)) {
        ptiCurrent->ppi->ptiMainThread = ptiCurrent;
    }

    /*
     * When we return, this app is going to sleep. Since it is in its
     * idle mode when it goes to sleep, wake any apps waiting for this
     * app to go idle.
     */
    zzzWakeInputIdle(ptiCurrent);
    /*
     * Setup the wake mask for this thread. Wait for QS_EVENT or the app won't
     * get event messages like deactivate.
     */
    ClearQueueServerEvent((WORD)(dwWakeMask | QS_EVENT));
    /*
     * This app is going idle. Clear the spin count check to see
     * if we need to make this process foreground again.
     */
    ptiCurrent->pClientInfo->cSpins = 0;
    if (ptiCurrent->TIF_flags & TIF_SPINNING) {
        CheckProcessForeground(ptiCurrent);
    }

    UserAssert(ptiCurrent->pcti->fsWakeMask != 0);
    return ptiCurrent->hEventQueueClient;
}

/***************************************************************************\
* xxxWaitForInputIdle
*
* This routine waits on a particular input queue for "input idle", meaning
* it waits till that queue has no input to process.
*
* 09-13-91 ScottLu      Created.
\***************************************************************************/

DWORD xxxWaitForInputIdle(
    ULONG_PTR idProcess,
    DWORD dwMilliseconds,
    BOOL fSharedWow)
{
    PTHREADINFO ptiCurrent;
    PTHREADINFO pti;
    PEPROCESS Process;
    PW32PROCESS W32Process;
    PPROCESSINFO ppi;
    DWORD dwResult;
    NTSTATUS Status;
    TL tlProcess;

    ptiCurrent = PtiCurrent();

    /*
     * If fSharedWow is set, the client passed in a fake process
     * handle which CreateProcess returns for Win16 apps started
     * in the shared WOW VDM.
     *
     * CreateProcess returns a real process handle when you start
     * a Win16 app in a separate WOW VDM.
     */

    if (fSharedWow) {  // Waiting for a WOW task to go idle.
        PWOWTHREADINFO pwti;


        /*
         * Look for a matching thread in the WOW thread info list.
         */
        for (pwti = gpwtiFirst; pwti != NULL; pwti = pwti->pwtiNext) {
            if (pwti->idParentProcess == HandleToUlong(PsGetThreadProcessId(ptiCurrent->pEThread)) &&
                pwti->idWaitObject == idProcess) {
                break;
            }
        }

        /*
         * If we couldn't find the right thread, bail out.
         */
        if (pwti == NULL) {
            RIPMSG0(RIP_WARNING, "WaitForInputIdle couldn't find 16-bit task\n");
            return (DWORD)-1;
        }

        /*
         * Now wait for it to go idle and return.
         */
        dwResult = WaitOnPseudoEvent(&pwti->pIdleEvent, dwMilliseconds);
        if (dwResult == STATUS_ABANDONED) {
            dwResult = xxxPollAndWaitForSingleObject(pwti->pIdleEvent,
                                                     NULL,
                                                     dwMilliseconds);
        }
        return dwResult;

    }

    /*
     * We shouldn't get here for system threads.
     */
    UserAssert(!(ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD));

    /*
     * If the app is waiting for itself to go idle, error.
     */
    if (PsGetThreadProcessId(ptiCurrent->pEThread) == (HANDLE)idProcess &&
            ptiCurrent == ptiCurrent->ppi->ptiMainThread) {
        RIPMSG0(RIP_WARNING, "WaitForInputIdle waiting on self\n");
        return (DWORD)-1;
    }

    /*
     * Now find the ppi structure for this process.
     */
    LeaveCrit();
    Status = LockProcessByClientId((HANDLE)idProcess, &Process);
    EnterCrit();

    if (!NT_SUCCESS(Status))
        return (DWORD)-1;

    if (PsGetProcessExitProcessCalled(Process)) {
        UnlockProcess(Process);
        return (DWORD)-1;
    }

    W32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);

    /*
     * If we can't find that process info structure, return error.
     * Or, if this is a console application, don't wait on it.
     */
    if (W32Process == NULL || W32Process->W32PF_Flags & W32PF_CONSOLEAPPLICATION) {
        UnlockProcess(Process);
        return (DWORD)-1;
    }


    /*
     * We have to wait mark the Process as one which others are waiting on
     */
    ppi = (PPROCESSINFO)W32Process;
    ppi->W32PF_Flags |= W32PF_WAITFORINPUTIDLE;
    for (pti = ppi->ptiList; pti != NULL; pti = pti->ptiSibling) {
        pti->TIF_flags |= TIF_WAITFORINPUTIDLE;
    }

    /*
     * Thread lock the process to ensure that it will be dereferenced
     * if the thread exits.
     */
    LockW32Process(W32Process, &tlProcess);
    UnlockProcess(Process);

    dwResult = WaitOnPseudoEvent(&W32Process->InputIdleEvent, dwMilliseconds);
    if (dwResult == STATUS_ABANDONED) {
        dwResult = xxxPollAndWaitForSingleObject(W32Process->InputIdleEvent,
                                                 Process,
                                                 dwMilliseconds);
    }

    /*
     * Clear all thread TIF_WAIT bits from the process.
     */
    ppi->W32PF_Flags &= ~W32PF_WAITFORINPUTIDLE;
    for (pti = ppi->ptiList; pti != NULL; pti = pti->ptiSibling) {
        pti->TIF_flags &= ~TIF_WAITFORINPUTIDLE;
    }

    UnlockW32Process(&tlProcess);

    return dwResult;
}


#define INTERMEDIATE_TIMEOUT    (500)       // 1/2 second

/***************************************************************************\
* xxxPollAndWaitForSingleObject
*
* Sometimes we have to wait on an event but still want to periodically
* wake up and see if the client process has been terminated.
*
* dwMilliseconds is initially the total amount of time to wait and after
* each intermediate wait reflects the amount of time left to wait.
* -1 means wait indefinitely.
*
* 02-Jul-1993 johnc      Created.
\***************************************************************************/

// LATER!!! can we get rid of the Polling idea and wait additionally on
// LATER!!! the hEventServer and set that when a thread dies

DWORD xxxPollAndWaitForSingleObject(
    PKEVENT pEvent,
    PVOID pExecObject,
    DWORD dwMilliseconds)
{
    DWORD dwIntermediateMilliseconds, dwStartTickCount;
    PTHREADINFO ptiCurrent;
    UINT cEvent = 2;
    NTSTATUS Status = -1;
    LARGE_INTEGER li;
    TL tlEvent;

    ptiCurrent = PtiCurrent();

    if (ptiCurrent->apEvent == NULL) {
        ptiCurrent->apEvent = UserAllocPoolNonPaged(POLL_EVENT_CNT * sizeof(PKEVENT), TAG_EVENT);
        if (ptiCurrent->apEvent == NULL)
            return (DWORD)-1;
    }

    /*
     * Refcount the event to ensure that it won't go
     * away during the wait. By using a thread lock, the
     * event will be dereferenced if the thread exits
     * during a callback. The process pointer has already been
     * locked.
     */
    ThreadLockObject(pEvent, &tlEvent);

    /*
     * If a process was passed in, wait on it too. No need
     * to reference this because the caller has it referenced.
     */
    if (pExecObject) {
        cEvent++;
    }

    /*
     * We want to wake if there're sent messages pending
     */
    ClearQueueServerEvent(QS_SENDMESSAGE);

    /*
     * Wow Tasks MUST be descheduled while in the wait to allow
     * other tasks in the same wow scheduler to run.
     *
     * For example, 16 bit app A calls WaitForInputIdle on 32 bit app B.
     * App B starts up and tries to send a message to 16 bit app C. App C
     * will never be able to process the message unless app A yields
     * control to it, so app B will never go idle.
     */

    if (ptiCurrent->TIF_flags & TIF_16BIT) {
        xxxSleepTask(FALSE, HEVENT_REMOVEME);
        // caution: the wow task is no longer scheduled.
    }

    dwStartTickCount = NtGetTickCount();
    while (TRUE) {
        if (dwMilliseconds > INTERMEDIATE_TIMEOUT) {
            dwIntermediateMilliseconds = INTERMEDIATE_TIMEOUT;

            /*
             * If we are not waiting an infinite amount of time then subtract
             * the last loop duration from time left to wait.
             */
            if (dwMilliseconds != INFINITE) {
                DWORD dwNewTickCount = NtGetTickCount();
                DWORD dwDelta = ComputePastTickDelta(dwNewTickCount, dwStartTickCount);
                dwStartTickCount = dwNewTickCount;
                if (dwDelta < dwMilliseconds) {
                    dwMilliseconds -= dwDelta;
                } else {
                    dwMilliseconds = 0;
                }
            }
        } else {
            dwIntermediateMilliseconds = dwMilliseconds;
            dwMilliseconds = 0;
        }

        /*
         * Convert dwMilliseconds to a relative-time(i.e. negative) LARGE_INTEGER.
         * NT Base calls take time values in 100 nanosecond units.
         */
        if (dwIntermediateMilliseconds != INFINITE)
            li.QuadPart = Int32x32To64(-10000, dwIntermediateMilliseconds);

        /*
         * Load events into the wait array. Do this every time
         * through the loop in case of recursion.
         */
        ptiCurrent->apEvent[IEV_IDLE] = pEvent;
        ptiCurrent->apEvent[IEV_INPUT] = ptiCurrent->pEventQueueServer;
        ptiCurrent->apEvent[IEV_EXEC] = pExecObject;

        LeaveCrit();

        Status = KeWaitForMultipleObjects(cEvent,
                                          &ptiCurrent->apEvent[IEV_IDLE],
                                          WaitAny,
                                          WrUserRequest,
                                          UserMode,
                                          FALSE,
                                          (dwIntermediateMilliseconds == INFINITE ?
                                                  NULL : &li),
                                          NULL);

        EnterCrit();

        if (!NT_SUCCESS(Status)) {
            Status = -1;
        } else {

            /*
             * Because we do a non-alertable wait, we know that a status
             * of STATUS_USER_APC means that the thread was terminated.
             * If we have terminated, get back to user mode
             */
            if (Status == STATUS_USER_APC) {
                ClientDeliverUserApc();
                Status = -1;
            }
        }

        if (ptiCurrent->pcti->fsChangeBits & QS_SENDMESSAGE) {
            /*
             *  Wow Tasks MUST wait to be rescheduled in the wow non-premptive
             *  scheduler before doing anything which might invoke client code.
             */
            if (ptiCurrent->TIF_flags & TIF_16BIT) {
                xxxDirectedYield(DY_OLDYIELD);
            }

            xxxReceiveMessages(ptiCurrent);

            if (ptiCurrent->TIF_flags & TIF_16BIT) {
                xxxSleepTask(FALSE, HEVENT_REMOVEME);
                // caution: the wow task is no longer scheduled.
            }
        }

        /*
         * If we returned from the wait for some other reason than a timeout
         * or to receive messages we are done. If it is a timeout we are
         * only done waiting if the overall time is zero.
         */
        if (Status != STATUS_TIMEOUT && Status != 1)
            break;

        if (dwMilliseconds == 0) {
            /*
             * Fix up the return if the last poll was interupted by a message
             */
            if (Status == 1)
                Status = WAIT_TIMEOUT;
            break;
        }

    }

    /*
     * reschedule the 16 bit app
     */
    if (ptiCurrent->TIF_flags & TIF_16BIT) {
        xxxDirectedYield(DY_OLDYIELD);
    }

    /*
     * Unlock the events.
     */
    ThreadUnlockObject(&tlEvent);

    return Status;
}



/***************************************************************************\
 * WaitOnPseudoEvent
 *
 * Similar semantics to WaitForSingleObject() but works with pseudo events.
 * Could fail if creation on the fly fails.
 * Returns STATUS_ABANDONED_WAIT if caller needs to wait on the event and event is
 * created and ready to be waited on.
 *
 * This assumes the event was created with fManualReset=TRUE, fInitState=FALSE
 *
 * 10/28/93 SanfordS    Created
\***************************************************************************/
DWORD WaitOnPseudoEvent(
    HANDLE *phE,
    DWORD dwMilliseconds)
{
    HANDLE hEvent;
    NTSTATUS Status;

    CheckCritIn();
    if (*phE == PSEUDO_EVENT_OFF) {
        if (!NT_SUCCESS(ZwCreateEvent(&hEvent, EVENT_ALL_ACCESS, NULL,
                NotificationEvent, FALSE))) {
            UserAssert(!"Could not create event on the fly.");
            if (dwMilliseconds != INFINITE) {
                return STATUS_TIMEOUT;
            } else {
                return (DWORD)-1;
            }
        }
        Status = ObReferenceObjectByHandle(hEvent, EVENT_ALL_ACCESS, *ExEventObjectType,
                KernelMode, phE, NULL);
        ZwClose(hEvent);
        if (!NT_SUCCESS(Status))
            return (DWORD)-1;
    } else if (*phE == PSEUDO_EVENT_ON) {
        return STATUS_WAIT_0;
    }
    return(STATUS_ABANDONED);
}

/***************************************************************************\
* xxxSetCsrssThreadDesktop
*
* Set/clear and lock/unlock a desktop for a csrss thread
* When setting a desktop, ppdeskRestore must be valid and will receive
* the old (previous) desktop, if any; the caller is expected to restore
* this pdesk when done.
*
* When restoring a desktop, ppdeskRestore must be NULL. pdesk must have been
* previously returned by this same function (in *ppdeskRestore).
*
* History:
* 02-18-97 GerardoB     Extracted from SetInformationThread
\***************************************************************************/
NTSTATUS xxxSetCsrssThreadDesktop(PDESKTOP pdesk, PDESKRESTOREDATA pdrdRestore)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    NTSTATUS Status = STATUS_SUCCESS;
    MSG msg;

    /*
     * Only csr should come here
     */
    UserAssert(ISCSRSS());
    UserAssert(pdrdRestore);
    UserAssert(pdrdRestore->pdeskRestore == NULL);

#if 0
    /*
     * If we're in clean up, csrss worker threads should not be messing around
     */
    if (gdwHydraHint & HH_INITIATEWIN32KCLEANUP) {
        FRE_RIPMSG0(RIP_ERROR, "xxxSetCsrssThreadDesktop: HH_INITIATEWIN32KCLEANUP is set");
    }
#endif

    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG1(RIP_WARNING, "xxxSetCsrssThreadDesktop: pdesk %#p destroyed",
                pdesk);
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Lock the current desktop (set operation). Also, create and save a
     * handle to the new desktop.
     */
    pdrdRestore->pdeskRestore = ptiCurrent->rpdesk;

    if (pdrdRestore->pdeskRestore != NULL) {
        Status = ObReferenceObjectByPointer(pdrdRestore->pdeskRestore,
                                       MAXIMUM_ALLOWED,
                                       *ExDesktopObjectType,
                                       KernelMode);

        if (!NT_SUCCESS(Status)) {
            pdrdRestore->pdeskRestore = NULL;
            pdrdRestore->hdeskNew = NULL;
            return Status;
        }
        LogDesktop(pdrdRestore->pdeskRestore, LD_REF_FN_SETCSRSSTHREADDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());
    }

    Status = ObOpenObjectByPointer(
             pdesk,
             0,
             NULL,
             EVENT_ALL_ACCESS,
             NULL,
             KernelMode,
             &(pdrdRestore->hdeskNew));


    if (!NT_SUCCESS(Status)) {
        RIPNTERR2(Status, RIP_WARNING, "SetCsrssThreadDesktop, can't open handle, pdesk %#p. Status: %#x", pdesk, Status);
        if (pdrdRestore->pdeskRestore) {
            LogDesktop(pdrdRestore->pdeskRestore, LD_DEREF_FN_SETCSRSSTHREADDESKTOP1, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdrdRestore->pdeskRestore);
            pdrdRestore->pdeskRestore = NULL;
        }
        pdrdRestore->hdeskNew = NULL;
        return Status;
    }
    /*
     * Set the new desktop, if switching
     */
    if (pdesk != ptiCurrent->rpdesk) {
        /*
         * Process any remaining messages before we leave the desktop
         */
        if (ptiCurrent->rpdesk) {
            while (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD))
                xxxDispatchMessage(&msg);
        }

        if (!xxxSetThreadDesktop(NULL, pdesk)) {
            RIPMSG1(RIP_WARNING, "xxxSetCsrssThreadDesktop: xxxSetThreadDesktop(%#p) failed", pdesk);
            Status = STATUS_INVALID_HANDLE;
            /*
             * We're failing so deref if needed.
             */
            if (pdrdRestore->pdeskRestore != NULL) {
                LogDesktop(pdrdRestore->pdeskRestore, LD_DEREF_FN_SETCSRSSTHREADDESKTOP1, FALSE, (ULONG_PTR)PtiCurrent());
                ObDereferenceObject(pdrdRestore->pdeskRestore);
                pdrdRestore->pdeskRestore = NULL;
            }
            CloseProtectedHandle(pdrdRestore->hdeskNew);
            pdrdRestore->hdeskNew = NULL;
        }
    }


    UserAssert(NT_SUCCESS(Status));
    return Status;
}

NTSTATUS xxxRestoreCsrssThreadDesktop(PDESKRESTOREDATA pdrdRestore)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    NTSTATUS Status = STATUS_SUCCESS;
    MSG msg;

    /*
     * Only csr should come here
     */
    UserAssert(ISCSRSS());
    UserAssert(pdrdRestore);

    /*
     * Set the new desktop, if switching
     */
    if (pdrdRestore->pdeskRestore != ptiCurrent->rpdesk) {
        /*
         * Process any remaining messages before we leave the desktop
         */
        if (ptiCurrent->rpdesk) {
            while (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD))
                xxxDispatchMessage(&msg);
        }

        if (!xxxSetThreadDesktop(NULL, pdrdRestore->pdeskRestore)) {
            FRE_RIPMSG1(RIP_ERROR, "xxxRestoreCsrssThreadDesktop: xxxRestoreThreadDesktop(%#p) failed", pdrdRestore->pdeskRestore);
            Status = STATUS_INVALID_HANDLE;
        }
    }

    /*
     * Dereference the desktop,
     *   even if failing the call.
     */
    if (pdrdRestore->pdeskRestore != NULL) {
        LogDesktop(pdrdRestore->pdeskRestore, LD_DEREF_FN_SETCSRSSTHREADDESKTOP2, FALSE, 0);
        ObDereferenceObject(pdrdRestore->pdeskRestore);
        pdrdRestore->pdeskRestore = NULL;
    }

    if(pdrdRestore->hdeskNew) {
        CloseProtectedHandle(pdrdRestore->hdeskNew);
        UserAssert(NT_SUCCESS(Status));
        pdrdRestore->hdeskNew = NULL;
    }
    return Status;
}

/***************************************************************************\
* GetTaskName
*
* Gets the application name from a thread.
\***************************************************************************/
ULONG GetTaskName(
    PTHREADINFO pti,
    PWSTR Buffer,
    ULONG BufferLength)
{
    ANSI_STRING strAppName;
    UNICODE_STRING strAppNameU;
    NTSTATUS Status;
    ULONG NameLength = 0;

    if (pti == NULL) {
        *Buffer = 0;
        return 0;
    }
    if (pti->pstrAppName != NULL) {
        NameLength = min(pti->pstrAppName->Length + sizeof(WCHAR), BufferLength);
        RtlCopyMemory(Buffer, pti->pstrAppName->Buffer, NameLength);
    } else {
        RtlInitAnsiString(&strAppName, PsGetProcessImageFileName(PsGetThreadProcess(pti->pEThread)));
        if (BufferLength < sizeof(WCHAR))
            NameLength = (strAppName.Length + 1) * sizeof(WCHAR);
        else {
            strAppNameU.Buffer = Buffer;
            strAppNameU.MaximumLength = (SHORT)BufferLength - sizeof(WCHAR);
            Status = RtlAnsiStringToUnicodeString(&strAppNameU, &strAppName,
                    FALSE);
            if (NT_SUCCESS(Status))
                NameLength = strAppNameU.Length + sizeof(WCHAR);
        }
    }
    Buffer[(NameLength / sizeof(WCHAR)) - 1] = 0;

    return NameLength;
}

/***************************************************************************\
* QueryInformationThread
*
* Returns information about a thread.
*
* History:
* 03-01-95 JimA         Created.
\***************************************************************************/

NTSTATUS xxxQueryInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL)
{
    PUSERTHREAD_SHUTDOWN_INFORMATION pShutdown;
    PUSERTHREAD_WOW_INFORMATION pWow;
    PETHREAD Thread;
    PTHREADINFO pti;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LocalReturnLength = 0;
    DWORD dwClientFlags;

    /*
     * Only allow CSRSS to make this call
     */
    UserAssert(ISCSRSS());

    Status = ObReferenceObjectByHandle(hThread,
                                        THREAD_QUERY_INFORMATION,
                                        *PsThreadType,
                                        UserMode,
                                        &Thread,
                                        NULL);
    if (!NT_SUCCESS(Status))
        return Status;

    pti = PtiFromThread(Thread);

    switch (ThreadInfoClass) {
    case UserThreadShutdownInformation:
        LocalReturnLength = sizeof(USERTHREAD_SHUTDOWN_INFORMATION);
        UserAssert(ThreadInformationLength == sizeof(USERTHREAD_SHUTDOWN_INFORMATION));
        pShutdown = ThreadInformation;
        /*
         * Read the client flags and zero out the structure,
         *  except for pdeskRestore (which is supposed
         *  to be the last field)
         */
        dwClientFlags = pShutdown->dwFlags;
        UserAssert(FIELD_OFFSET(USERTHREAD_SHUTDOWN_INFORMATION, drdRestore)
            == (sizeof(USERTHREAD_SHUTDOWN_INFORMATION) - sizeof(DESKRESTOREDATA)));
        RtlZeroMemory(pShutdown,
            sizeof(USERTHREAD_SHUTDOWN_INFORMATION) - sizeof(DESKRESTOREDATA));

        /*
         * Return the desktop window handle if the thread
         * has a desktop and the desktop is on a visible
         * windowstation.
         */
        if (pti != NULL && pti->rpdesk != NULL &&
                !(pti->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO))
            pShutdown->hwndDesktop = HW(pti->rpdesk->pDeskInfo->spwnd);

        /*
         * Return shutdown status. Zero indicates that the thread
         * has windows and can be shut down in the normal manner.
         */
        if (PsGetThreadProcessId(Thread) == gpidLogon) {
            /*
             * Do not shutdown the logon process.
             */
            pShutdown->StatusShutdown = SHUTDOWN_KNOWN_PROCESS;
        } else if (pti == NULL || pti->rpdesk == NULL) {

            /*
             * The thread either is not a gui thread or it doesn't
             * have a desktop. Make console do the shutdown.
             */
            pShutdown->StatusShutdown = SHUTDOWN_UNKNOWN_PROCESS;
        }

        /*
         * Return flags
         */
        if (pti != NULL && pti->cWindows != 0)
            pShutdown->dwFlags |= USER_THREAD_GUI;

        /*
         * If we return the desktop window handle and the
         * app should be shut down, switch to the desktop
         *  and assign it to the shutdown worker thread.
         */
        if ((pShutdown->dwFlags & USER_THREAD_GUI) &&
                pShutdown->StatusShutdown == 0) {
            /*
             * The current csrss thread is going to
             *  make activation calls, send messages,
             *  switch video modes, etc  so we need to
             *  assign it to a dekstop
             */
            PTHREADINFO ptiCurrent = PtiCurrent();
            UserAssert(pti->rpdesk != NULL);

            if (ptiCurrent->rpdesk != pti->rpdesk) {
                /*
                 * If this thread already has a desktop,
                 *   restore the old one first.
                 *  This might happen when threads of the same
                 *  process are attached to different desktops.
                 */
                if (ptiCurrent->rpdesk != NULL) {
                    Status = xxxRestoreCsrssThreadDesktop(&pShutdown->drdRestore);
                    UserAssert(pti == PtiFromThread(Thread));
                }
                if (NT_SUCCESS(Status)) {
                    Status = xxxSetCsrssThreadDesktop(pti->rpdesk, &pShutdown->drdRestore);
                    UserAssert(pti == PtiFromThread(Thread));
                }
            }
            /*
             * If we're forcing a shutdown, then there is no need to switch
             *  since we won't send any messages or bring up the EndTask dialog
             * (We still want to have a proper rpdesk since BoostHardError might
             *   call PostThreadMessage)
             */
            if (!(dwClientFlags & WMCS_NORETRY)) {
                if (NT_SUCCESS(Status)) {
                    xxxSwitchDesktop(pti->rpdesk->rpwinstaParent, pti->rpdesk, SDF_SLOVERRIDE);
                    UserAssert(pti == PtiFromThread(Thread));
                }
            }
        }
        break;

    case UserThreadFlags:
        LocalReturnLength = sizeof(DWORD);
        if (pti == NULL)
            Status = STATUS_INVALID_HANDLE;
        else {
            UserAssert(ThreadInformationLength == sizeof(DWORD));
            *(LPDWORD)ThreadInformation = pti->TIF_flags;
        }
        break;

    case UserThreadTaskName:
        LocalReturnLength = GetTaskName(pti, ThreadInformation, ThreadInformationLength);
        break;

    case UserThreadWOWInformation:
        LocalReturnLength = sizeof(USERTHREAD_WOW_INFORMATION);
        UserAssert(ThreadInformationLength == sizeof(USERTHREAD_WOW_INFORMATION));
        pWow = ThreadInformation;
        RtlZeroMemory(pWow, sizeof(USERTHREAD_WOW_INFORMATION));

        /*
         * If the thread is 16-bit, Status = the exit task function
         * and task id.
         */
        if (pti && pti->TIF_flags & TIF_16BIT) {
            pWow->lpfnWowExitTask = pti->ppi->pwpi->lpfnWowExitTask;
            if (pti->ptdb)
                pWow->hTaskWow = pti->ptdb->hTaskWow;
            else
                pWow->hTaskWow = 0;
        }
        break;

    case UserThreadHungStatus:
        LocalReturnLength = sizeof(DWORD);
        UserAssert(ThreadInformationLength >= sizeof(DWORD));

        /*
         * Return hung status.
         */
        if (pti) {
            *(PDWORD)ThreadInformation =
                    (DWORD)FHungApp(pti, (DWORD)*(PDWORD)ThreadInformation);
        } else {
            *(PDWORD)ThreadInformation = FALSE;
        }
        break;

    default:
        Status = STATUS_INVALID_INFO_CLASS;
        RIPMSG1(RIP_ERROR, "Invalid ThreadInfoClass 0x%x", ThreadInfoClass);
        break;
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = LocalReturnLength;
    }

    UnlockThread(Thread);

    return Status;
}

/***************************************************************************\
* xxxSetInformationThread
*
* Sets information about a thread.
*
* History:
* 03-01-95 JimA         Created.
\***************************************************************************/

NTSTATUS xxxSetInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength)
{
    PUSERTHREAD_FLAGS pFlags;
    HANDLE hClientThread;
    DWORD dwOldFlags;
    PTHREADINFO ptiT;
    NTSTATUS Status = STATUS_SUCCESS;
    PETHREAD Thread;
    PETHREAD ThreadClient;
    PTHREADINFO pti;
    HANDLE CsrPortHandle;

    UNREFERENCED_PARAMETER(ThreadInformationLength);

    /*
     * Only allow CSRSS to make this call
     */
    UserAssert(ISCSRSS());

    Status = ObReferenceObjectByHandle(hThread,
                                        THREAD_SET_INFORMATION,
                                        *PsThreadType,
                                        UserMode,
                                        &Thread,
                                        NULL);
    if (!NT_SUCCESS(Status))
        return Status;

    pti = PtiFromThread(Thread);

    switch (ThreadInfoClass) {
    case UserThreadFlags:
        if (pti == NULL)
            Status = STATUS_INVALID_HANDLE;
        else {
            UserAssert(ThreadInformationLength == sizeof(USERTHREAD_FLAGS));
            pFlags = ThreadInformation;
            dwOldFlags = pti->TIF_flags;
            pti->TIF_flags ^= ((dwOldFlags ^ pFlags->dwFlags) & pFlags->dwMask);
        }
        break;

    case UserThreadHungStatus:
        if (pti == NULL)
            Status = STATUS_INVALID_HANDLE;
        else {

            /*
             * No arguments, simple set the last time read.
             */
            SET_TIME_LAST_READ(pti);
        }
        break;

    case UserThreadInitiateShutdown:
        UserAssert(ThreadInformationLength == sizeof(ULONG));
        Status = InitiateShutdown(Thread, (PULONG)ThreadInformation);
        break;

    case UserThreadEndShutdown:
        UserAssert(ThreadInformationLength == sizeof(NTSTATUS));
        Status = EndShutdown(Thread, *(NTSTATUS *)ThreadInformation);
        break;

    case UserThreadUseDesktop:
        UserAssert(ThreadInformationLength == sizeof(USERTHREAD_USEDESKTOPINFO));
        if (pti == NULL) {
            Status = STATUS_INVALID_HANDLE;
            break;
        }

        /*
         * If the caller provides a thread handle, then we use that
         *  thread's pdesk and return the pdesk currently used
         *  by the caller (set operation). Otherwise,
         *  we use the pdesk provided by the caller (restore operation).
         */
        hClientThread = ((PUSERTHREAD_USEDESKTOPINFO)ThreadInformation)->hThread;
        if (hClientThread != NULL) {
            Status = ObReferenceObjectByHandle(hClientThread,
                                            THREAD_QUERY_INFORMATION,
                                            *PsThreadType,
                                            UserMode,
                                            &ThreadClient,
                                            NULL);
            if (!NT_SUCCESS(Status))
                break;

            ptiT = PtiFromThread(ThreadClient);
            if ((ptiT == NULL) || (ptiT->rpdesk == NULL)) {
                Status = STATUS_INVALID_HANDLE;
                goto DerefClientThread;
            }
            Status = xxxSetCsrssThreadDesktop(ptiT->rpdesk, &((PUSERTHREAD_USEDESKTOPINFO)ThreadInformation)->drdRestore);
        } else {
            Status = xxxRestoreCsrssThreadDesktop(&((PUSERTHREAD_USEDESKTOPINFO)ThreadInformation)->drdRestore);
        }


        if (hClientThread != NULL) {
DerefClientThread:
            ObDereferenceObject(ThreadClient);
        }
        break;

    case UserThreadUseActiveDesktop:
    {
        UserAssert(ThreadInformationLength == sizeof(USERTHREAD_USEDESKTOPINFO));
        if (pti == NULL || grpdeskRitInput == NULL) {
            Status = STATUS_INVALID_HANDLE;
            break;
        }
        Status = xxxSetCsrssThreadDesktop(grpdeskRitInput,
                    &((PUSERTHREAD_USEDESKTOPINFO)ThreadInformation)->drdRestore);
        break;
    }
    case UserThreadCsrApiPort:

        /*
         * Only CSR can call this
         */
        if (PsGetThreadProcess(Thread) != gpepCSRSS) {
            Status = STATUS_ACCESS_DENIED;
            break;
        }

        UserAssert(ThreadInformationLength == sizeof(HANDLE));

        /*
         * Only set it once.
         */
        if (CsrApiPort != NULL)
            break;

        CsrPortHandle = *(PHANDLE)ThreadInformation;
        Status = ObReferenceObjectByHandle(
                CsrPortHandle,
                0,
                NULL, //*LpcPortObjectType,
                UserMode,
                &CsrApiPort,
                NULL);
        if (!NT_SUCCESS(Status)) {
            CsrApiPort = NULL;
            RIPMSG1(RIP_WARNING,
                    "CSR port reference failed, Status=%#lx",
                    Status);
        }

        break;

    default:
        Status = STATUS_INVALID_INFO_CLASS;
        UserAssert(FALSE);
        break;
    }

    UnlockThread(Thread);

    return Status;
}

/***************************************************************************\
* _GetProcessDefaultLayout (API)
*
* Retreives the default layout information about a process.
*
* History:
* 23-01-98 SamerA         Created.
\***************************************************************************/
BOOL _GetProcessDefaultLayout(
    OUT DWORD *pdwDefaultLayout)
{
    BOOL fSuccess = FALSE;

    /*
     * Do not allow CSRSS to make this call. This call might
     * happen due to the inheritence code. See xxxCreateWindowEx(...)
     */
    if (ISCSRSS()) {
        UserSetLastError(ERROR_INVALID_ACCESS);
        goto api_error;
    }

    try {
        ProbeForWriteUlong(pdwDefaultLayout);
        *pdwDefaultLayout = PpiCurrent()->dwLayout;
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        goto api_error;
    }

    fSuccess = TRUE;

api_error:
    return fSuccess;
}

/***************************************************************************\
* _SetProcessDefaultLayout (API)
*
* Sets the default layout information about a process.
*
* History:
* 23-01-98 SamerA         Created.
\***************************************************************************/
BOOL _SetProcessDefaultLayout(
    IN DWORD dwDefaultLayout)
{
    /*
     * Do not allow CSRSS to make this call
     */
    UserAssert(PsGetCurrentProcess() != gpepCSRSS);

    /*
     * Validate dwDefaultLayout
     */
    if (dwDefaultLayout & ~LAYOUT_ORIENTATIONMASK)
    {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Calling SetProcessDefaultLayout with invalid layout = %lX",
                dwDefaultLayout);
        return FALSE;
    }

    /*
     * Update the process default layout param
     */
    PpiCurrent()->dwLayout = dwDefaultLayout;

    return TRUE;
}

/***************************************************************************\
* SetInformationProcess
*
* Sets information about a process.
*
* History:
* 09-27-96 GerardoB         Created.
\***************************************************************************/

NTSTATUS SetInformationProcess(
    IN HANDLE hProcess,
    IN USERPROCESSINFOCLASS ProcessInfoClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength)
{
    PUSERPROCESS_FLAGS pFlags;
    DWORD dwOldFlags;
    NTSTATUS Status = STATUS_SUCCESS;
    PEPROCESS Process;
    PPROCESSINFO ppi;

    UNREFERENCED_PARAMETER(ProcessInformationLength);

    UserAssert(ISCSRSS());

    Status = ObReferenceObjectByHandle(hProcess,
                                        PROCESS_SET_INFORMATION,
                                        *PsProcessType,
                                        UserMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ppi = PpiFromProcess(Process);

    switch (ProcessInfoClass) {
    case UserProcessFlags:
        if (ppi == NULL) {
            Status = STATUS_INVALID_HANDLE;
        } else {
            UserAssert(ProcessInformationLength == sizeof(USERPROCESS_FLAGS));
            pFlags = ProcessInformation;
            dwOldFlags = ppi->W32PF_Flags;
            ppi->W32PF_Flags ^= ((dwOldFlags ^ pFlags->dwFlags) & pFlags->dwMask);
        }
        break;

    default:
        Status = STATUS_INVALID_INFO_CLASS;
        UserAssert(FALSE);
        break;
    }

    UnlockProcess(Process);

    return Status;
}


/***************************************************************************\
* xxxSetConsoleCaretInfo
*
* Store information about the console's homegrown caret and notify any
* interested apps that it changed. We need this for accessibility.
*
* History:
* 26-May-1999 JerrySh   Created.
\***************************************************************************/
VOID xxxSetConsoleCaretInfo(
    PCONSOLE_CARET_INFO pcci)
{
    PWND pwnd;
    TL tlpwnd;

    pwnd = ValidateHwnd(pcci->hwnd);
    if (pwnd && pwnd->head.rpdesk) {
        pwnd->head.rpdesk->cciConsole = *pcci;
        ThreadLock(pwnd, &tlpwnd);
        xxxWindowEvent(EVENT_OBJECT_LOCATIONCHANGE, pwnd, OBJID_CARET, INDEXID_CONTAINER, WEF_ASYNC);
        ThreadUnlock(&tlpwnd);
    }
}

/***************************************************************************\
* xxxConsoleControl
*
* Performs special control operations for console.
*
* History:
* 03-01-95 JimA         Created.
\***************************************************************************/
NTSTATUS xxxConsoleControl(
    IN CONSOLECONTROL ConsoleControl,
    IN PVOID ConsoleInformation,
    IN ULONG ConsoleInformationLength)
{
    PCONSOLEDESKTOPCONSOLETHREAD pDesktopConsole;
    PCONSOLEWINDOWSTATIONPROCESS pConsoleWindowStationInfo;
    PDESKTOP pdesk;
    DWORD dwThreadIdOld;
    NTSTATUS Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(ConsoleInformationLength);
    UserAssert(ISCSRSS());

    switch (ConsoleControl) {
    case ConsoleDesktopConsoleThread:
        UserAssert(ConsoleInformationLength == sizeof(CONSOLEDESKTOPCONSOLETHREAD));
        pDesktopConsole = (PCONSOLEDESKTOPCONSOLETHREAD)ConsoleInformation;

        Status = ObReferenceObjectByHandle(
                pDesktopConsole->hdesk,
                0,
                *ExDesktopObjectType,
                UserMode,
                &pdesk,
                NULL);
        if (!NT_SUCCESS(Status))
            return Status;

        LogDesktop(pdesk, LD_REF_FN_CONSOLECONTROL1, TRUE, (ULONG_PTR)PtiCurrent());

        dwThreadIdOld = pdesk->dwConsoleThreadId;

        if (pDesktopConsole->dwThreadId != (DWORD)-1) {
            pdesk->dwConsoleThreadId =
                    pDesktopConsole->dwThreadId;

            /*
             * Make sure that the console input thread is not starting while
             * shutting down.
             */
            if ((pDesktopConsole->dwThreadId != 0) && (gdwHydraHint & HH_INITIATEWIN32KCLEANUP)) {
                FRE_RIPMSG1(RIP_ERROR, "xxxConsoleControl: Console input thread starting during shutdown. dwThreadId: %lx",
                    pDesktopConsole->dwThreadId);
            }
        }

        pDesktopConsole->dwThreadId = dwThreadIdOld;
        LogDesktop(pdesk, LD_DEREF_FN_CONSOLECONTROL1, FALSE, (ULONG_PTR)PtiCurrent());
        ObDereferenceObject(pdesk);
        break;

    case ConsoleClassAtom:
        UserAssert(ConsoleInformationLength == sizeof(ATOM));
        gatomConsoleClass = *(ATOM *)ConsoleInformation;
        break;

    case ConsoleNotifyConsoleApplication:
        /*
         * Bug 273518 - joejo
         *
         * Adding optimization to bug fix
         */
        UserAssert(ConsoleInformationLength == sizeof(CONSOLE_PROCESS_INFO));
        xxxUserNotifyConsoleApplication((PCONSOLE_PROCESS_INFO)ConsoleInformation);
        break;

    case ConsoleSetVDMCursorBounds:
        UserAssert((ConsoleInformation == NULL) ||
            (ConsoleInformationLength == sizeof(RECT)));
        SetVDMCursorBounds(ConsoleInformation);
        break;

    case ConsolePublicPalette:
        UserAssert(ConsoleInformationLength == sizeof(HPALETTE));
        GreSetPaletteOwner(*(HPALETTE *)ConsoleInformation, OBJECT_OWNER_PUBLIC);
        break;

    case ConsoleWindowStationProcess:
        UserAssert(ConsoleInformationLength == sizeof(CONSOLEWINDOWSTATIONPROCESS));

        pConsoleWindowStationInfo = (PCONSOLEWINDOWSTATIONPROCESS)ConsoleInformation;
        UserSetConsoleProcessWindowStation(pConsoleWindowStationInfo->dwProcessId,
                                           pConsoleWindowStationInfo->hwinsta);
        break;

#if defined(FE_IME)
    /*
     * For console IME issue
     *
     * Console IME do register thread ID in DESKTOP info.
     * So should be per desktop.
     */
    case ConsoleRegisterConsoleIME:
        {
            PCONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;
            DWORD dwConsoleIMEThreadIdOld;

            UserAssert(ConsoleInformationLength == sizeof(CONSOLE_REGISTER_CONSOLEIME));

            RegConIMEInfo = (PCONSOLE_REGISTER_CONSOLEIME)ConsoleInformation;
            RegConIMEInfo->dwConsoleInputThreadId = 0;

            Status = ObReferenceObjectByHandle(
                    RegConIMEInfo->hdesk,
                    0,
                    *ExDesktopObjectType,
                    UserMode,
                    &pdesk,
                    NULL);
            if (!NT_SUCCESS(Status))
                return Status;

            LogDesktop(pdesk, LD_REF_FN_CONSOLECONTROL2, TRUE, (ULONG_PTR)PtiCurrent());

            Status = STATUS_SUCCESS;
            if (pdesk->dwConsoleThreadId)
            {
                /*
                 * Exists console input thread
                 */
                RegConIMEInfo->dwConsoleInputThreadId = pdesk->dwConsoleThreadId;

                dwConsoleIMEThreadIdOld = pdesk->dwConsoleIMEThreadId;

                if (RegConIMEInfo->dwAction != REGCONIME_QUERY) {
                    PTHREADINFO ptiConsoleIME;

                    if ((ptiConsoleIME = PtiFromThreadId(RegConIMEInfo->dwThreadId)) != NULL)
                    {
                        if ( (RegConIMEInfo->dwAction == REGCONIME_REGISTER) &&
                             !(ptiConsoleIME->TIF_flags & TIF_DONTATTACHQUEUE) )
                        {
                            /*
                             * Register
                             */
                            ptiConsoleIME->TIF_flags |= TIF_DONTATTACHQUEUE;
                            pdesk->dwConsoleIMEThreadId = RegConIMEInfo->dwThreadId;
                        }
                        else if ( (RegConIMEInfo->dwAction == REGCONIME_UNREGISTER) &&
                                  (ptiConsoleIME->TIF_flags & TIF_DONTATTACHQUEUE) )
                        {
                            /*
                             * Unregister
                             */
                            ptiConsoleIME->TIF_flags &= ~TIF_DONTATTACHQUEUE;
                            pdesk->dwConsoleIMEThreadId = 0;
                        }
                        else if (RegConIMEInfo->dwAction == REGCONIME_TERMINATE)
                        {
                            /*
                             * Terminate console IME (Logoff/Shutdown)
                             */
                            pdesk->dwConsoleIMEThreadId = 0;
                        }
                    }
                    else if (RegConIMEInfo->dwAction == REGCONIME_TERMINATE)
                    {
                        /*
                         * Abnormal end console IME
                         */
                        pdesk->dwConsoleIMEThreadId = 0;
                    }
                    else
                        Status = STATUS_ACCESS_DENIED;
                }
                RegConIMEInfo->dwThreadId = dwConsoleIMEThreadIdOld;
            }
            LogDesktop(pdesk, LD_DEREF_FN_CONSOLECONTROL2, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdesk);
            return Status;
        }
        break;
#endif

    case ConsoleFullscreenSwitch:
        UserAssert(ConsoleInformationLength == sizeof(CONSOLE_FULLSCREEN_SWITCH));
        xxxbFullscreenSwitch(((PCONSOLE_FULLSCREEN_SWITCH)ConsoleInformation)->bFullscreenSwitch,
                             ((PCONSOLE_FULLSCREEN_SWITCH)ConsoleInformation)->hwnd);
        break;

    case ConsoleSetCaretInfo:
        UserAssert(ConsoleInformationLength == sizeof(CONSOLE_CARET_INFO));
        xxxSetConsoleCaretInfo((PCONSOLE_CARET_INFO)ConsoleInformation);
        break;

    default:
        RIPMSG1(RIP_ERROR, "xxxConsoleControl - invalid control class: 0x%x\n", ConsoleControl);
        return STATUS_INVALID_INFO_CLASS;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\sbapi.c ===
/**************************** Module Header ********************************\
* Module Name:
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Scroll bar public APIs
*
* History:
*   11/21/90 JimA      Created.
*   01-31-91 IanJa     Revalidaion added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxShowScrollBar
*
* Shows and hides standard scroll bars or scroll bar controls. If wBar is
* SB_HORZ, SB_VERT, or SB_BOTH, pwnd is assumed to be the handle of the window
* which has the standard scroll bars as styles. If wBar is SB_CTL, pwnd is
* assumed to be the handle of the scroll bar control.
*
* It does not destroy pwnd->rgwScroll like xxxSetScrollBar() does, so that the
* app can hide a standard scroll bar and then show it, without having to reset
* the range and thumbposition.
*
* History:
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/

BOOL xxxShowScrollBar(
    PWND pwnd,
    UINT wBar,      /* SB_HORZ, SB_VERT, SB_BOTH , SB_CTL */
    BOOL fShow)     /* Show or Hide. */
{
    BOOL fChanged = FALSE;
    DWORD   dwStyle;

    CheckLock(pwnd);

    switch (wBar)
    {
    case SB_CTL:
        {

            xxxShowWindow(
                    pwnd,
                    (fShow ? SHOW_OPENWINDOW : HIDE_WINDOW) | TEST_PUDF(PUDF_ANIMATE));

            return(TRUE);
        }

    case SB_HORZ:
        dwStyle = WS_HSCROLL;
        break;

    case SB_VERT:
        dwStyle = WS_VSCROLL;
        break;

    case SB_BOTH:
        dwStyle = WS_HSCROLL | WS_VSCROLL;
        break;
    }

    if (!fShow)
    {
        if (pwnd->style & dwStyle)
        {
            fChanged = TRUE;
            pwnd->style &= ~dwStyle;
        }
    } else {
        if ((pwnd->style & dwStyle) != dwStyle)
        {
            fChanged = TRUE;
            pwnd->style |= dwStyle;
        }

        /*
         * Make sure that pwsb is initialized.
         */
        if (pwnd->pSBInfo == NULL)
            _InitPwSB(pwnd);
    }

    /*
     * If the state changed, redraw the frame and force WM_NCPAINT.
     */
    if (fChanged) {

        /*
         * We always redraw even if minimized or hidden...  Otherwise, it seems
         * the scroll bars aren't properly hidden/shown when we become
         * visible
         */
        xxxRedrawFrame(pwnd);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\rare.c ===
/****************************** Module Header ******************************\
* Module Name: rare.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 06-28-91 MikeHar      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * MetricsRecalc flags
 */
#define CALC_RESIZE         0x0001
#define CALC_FRAME          0x0002
#define CALC_MINIMIZE       0x0004

/*
 * NormalizeRect flags
 */
#define NORMALIZERECT_NORMAL        0
#define NORMALIZERECT_MAXIMIZED     1
#define NORMALIZERECT_FULLSCREEN    2

/***************************************************************************\
* SnapshotMonitorRects
*
*   This is called from ResetDisplay to memorize the monitor positions so
* DesktopRecalcEx will know where to move stuff.
*
* Returns the MONITORRECTS if succeeded, NULL otherwise.
*
* History:
* 09-Dec-1996 adams     Created.
\***************************************************************************/

PMONITORRECTS
SnapshotMonitorRects(void)
{
    PMONITOR        pMonitor;
    PMONITORRECTS   pmr;
    PMONITORPOS     pmp;
#if DBG
    ULONG           cVisMon = 0;
#endif

    pmr = UserAllocPool(
            sizeof(MONITORRECTS) + sizeof(MONITORPOS) * (gpDispInfo->cMonitors - 1),
            TAG_MONITORRECTS);

    if (!pmr) {
        RIPERR0(ERROR_OUTOFMEMORY, RIP_WARNING, "Out of memory in SnapshotMonitorRects");
        return NULL;
    }

    pmp = pmr->amp;
    for (   pMonitor = gpDispInfo->pMonitorFirst;
            pMonitor;
            pMonitor = pMonitor->pMonitorNext) {

        if (!(pMonitor->dwMONFlags & MONF_VISIBLE))
            continue;
#if DBG
        cVisMon++;
#endif

        CopyRect(&pmp->rcMonitor, &pMonitor->rcMonitor);
        CopyRect(&pmp->rcWork,    &pMonitor->rcWork);

        /*
         * If the device for this monitor object is not active, don't store
         * the pointer to it in the list.  This way the windows on the inactive
         * monitor will be later moved to the default one.
         */
        if (HdevFromMonitor(pMonitor) == -1) {
            pmp->pMonitor = NULL;
        } else {
            pmp->pMonitor = pMonitor;
        }

        pmp++;
    }
    UserAssert(cVisMon == gpDispInfo->cMonitors);

    pmr->cMonitor = (int)(pmp - pmr->amp);

    return pmr;
}


/***************************************************************************\
* UpdateMonitorRectsSnapShot
*
* Updates a Monitor rects snapshot. Every pMonitor in MONITORPOS is checked
* to still be a valid monitor. If the pMonitor is no loger valid (deleted
* by a ChangeDisplaySettings. it is zeroed so that its windows will be repositioned
* on the primary monitor. This code is only used on by the Reconnect in TS scenarii
* and is there for cases that are not happening today: today reconnect always happens
* from disconnected state where we go from  1 monitor (the disconnected display driver)
* to n monitors and this monitor (starting in (0,0) never gets deleted because it
* alway matches one of the new n monitors (the one starting in (0,0). So this
* code is just in case of futur changes.
* History:
\***************************************************************************/


void
UpdateMonitorRectsSnapShot(
    PMONITORRECTS pmr)
{
    int i;
    PMONITORPOS   pmp = pmr->amp;

    for (i=0 ; i < pmr->cMonitor ; i++) {
        if (pmp->pMonitor != NULL) {
            if (!IsValidMonitor(pmp->pMonitor)) {
                pmp->pMonitor = NULL;
            }
        }
        pmp++;
    }
}

BOOL
IsValidMonitor(
    PMONITOR pMonitor)
{
    PMONITOR pMonitorNext = gpDispInfo->pMonitorFirst;

    while (pMonitorNext != NULL) {
        if (pMonitorNext == pMonitor) {
            return TRUE;
        }
        pMonitorNext = pMonitorNext->pMonitorNext;

    }
    return FALSE;

}

/***************************************************************************\
* NormalizeRect
*
* Adjusts a window rectangle when the working area changes.  This can be
* because of a tray move, with the resolution staying the same, or
* because of a dynamic resolution change, with the tray staying the same
* relatively.
*
* History:
\***************************************************************************/

PMONITOR NormalizeRect(
    LPRECT          lprcDest,
    LPRECT          lprcSrc,
    PMONITORRECTS   pmrOld,
    int             iOldMonitor,
    int             codeFullScreen,
    DWORD           style)
{
    LPCRECT     lprcOldMonitor;
    LPCRECT     lprcOldWork;
    LPRECT      lprcNewWork;
    PMONITOR    pMonitor;
    int         cxOldMonitor;
    int         cyOldMonitor;
    int         cxNewMonitor;
    int         cyNewMonitor;
    int         dxOrg, dyOrg;

    /*
     * Track the window so it stays in the same place on the same monitor.
     * If the old monitor is no longer active then pick a default.
     */
    if ((pMonitor = pmrOld->amp[iOldMonitor].pMonitor) == NULL) {
        pMonitor = GetPrimaryMonitor();
    }

    lprcOldMonitor = &pmrOld->amp[iOldMonitor].rcMonitor;
    lprcOldWork = &pmrOld->amp[iOldMonitor].rcWork;

    /*
     * If is a fullscreen app just make it fullscreen at the new location.
     */
    if (codeFullScreen != NORMALIZERECT_NORMAL) {
        LPCRECT lprcOldSnap, lprcNewSnap;

        /*
         * If it is a maximized window snap it to the work area.
         * Otherwise it is a rude app so snap it to the screen.
         */
        if (codeFullScreen == NORMALIZERECT_MAXIMIZED) {
            lprcOldSnap = lprcOldWork;
            lprcNewSnap = &pMonitor->rcWork;
        } else {
            lprcOldSnap = lprcOldMonitor;
            lprcNewSnap = &pMonitor->rcMonitor;
        }

        lprcDest->left = lprcSrc->left +
            lprcNewSnap->left - lprcOldSnap->left;

        lprcDest->top = lprcSrc->top +
            lprcNewSnap->top - lprcOldSnap->top;

        lprcDest->right = lprcSrc->right +
            lprcNewSnap->right - lprcOldSnap->right;

        lprcDest->bottom = lprcSrc->bottom +
            lprcNewSnap->bottom - lprcOldSnap->bottom;

        goto AllDone;
    }

    /*
     * Offset the window by the change in desktop origin.
     */
    dxOrg = pMonitor->rcMonitor.left - lprcOldMonitor->left;
    dyOrg = pMonitor->rcMonitor.top - lprcOldMonitor->top;

    /*
     * Calculate the change in screen size (we need it in more than one place).
     */
    cxOldMonitor = lprcOldMonitor->right - lprcOldMonitor->left;
    cyOldMonitor = lprcOldMonitor->bottom - lprcOldMonitor->top;
    cxNewMonitor = pMonitor->rcMonitor.right - pMonitor->rcMonitor.left;
    cyNewMonitor = pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top;

    /*
     * If the monitor resolution has changed (or we moved to a new monitor)
     * then factor in the size change.
     */
    if (cxNewMonitor != cxOldMonitor || cyNewMonitor != cyOldMonitor) {
        int xWnd = lprcSrc->left - lprcOldMonitor->left;
        int yWnd = lprcSrc->top - lprcOldMonitor->top;

        dxOrg += MultDiv(xWnd, cxNewMonitor - cxOldMonitor, cxOldMonitor);
        dyOrg += MultDiv(yWnd, cyNewMonitor - cyOldMonitor, cyOldMonitor);
    }

    /*
     * Compute the initial new position.
     */
    CopyOffsetRect(lprcDest, lprcSrc, dxOrg, dyOrg);
    lprcNewWork = &pMonitor->rcWork;

    /*
     * Fit horizontally.  Try to fit so that the window isn't out of the
     * working area horizontally.  Keep left edge visible always.
     */
    if (lprcDest->right > lprcNewWork->right) {
        OffsetRect(lprcDest, lprcNewWork->right - lprcDest->right, 0);
    }

    if (lprcDest->left < lprcNewWork->left) {
        OffsetRect(lprcDest, lprcNewWork->left - lprcDest->left, 0);
    }

    /*
     * Fit vertically.  Try to fit so that the window isn't out of the
     * working area vertically.  Keep top edge visible always.
     */
    if (lprcDest->bottom > lprcNewWork->bottom) {
        OffsetRect(lprcDest, 0, lprcNewWork->bottom - lprcDest->bottom);
    }

    if (lprcDest->top < lprcNewWork->top) {
        OffsetRect(lprcDest, 0, lprcNewWork->top - lprcDest->top);
    }

    /*
     * If the window is sizeable then shrink it if necessary.
     */
    if (style & WS_THICKFRAME)
    {
        int cSnap = 0;

        if (lprcDest->right > lprcNewWork->right) {
            lprcDest->right = lprcNewWork->right;
            cSnap++;
        }

        if (lprcDest->bottom > lprcNewWork->bottom) {
            lprcDest->bottom = lprcNewWork->bottom;
            cSnap++;
        }


        /*
         * Now make sure we didn't turn this normal window into a
         * fullscreen window.  This is a complete hack but it is much
         * better than changing from 800x600 to 640x480 and ending up with
         * a bunch of fullscreen apps...
         */
        if (cSnap == 2) {
            InflateRect(lprcDest, -1, -1);
        }
    }

AllDone:
    return pMonitor;
}


/***************************************************************************\
* _SetRipFlags
*
* Sets the debug rip flags
*
* History:
* 16-Aug-1996 adams     Created.
\***************************************************************************/

VOID _SetRipFlags(
    DWORD dwRipFlags, DWORD dwPID)
{
    if (gpsi) {
        if ((dwRipFlags != (DWORD)-1) && !(dwRipFlags & ~RIPF_VALIDUSERFLAGS)) {
            gpsi->wRIPFlags = (WORD)((gpsi->wRIPFlags & ~RIPF_VALIDUSERFLAGS) | dwRipFlags);
        }
        if (dwPID != (DWORD)-1) {
            gpsi->wRIPPID = (WORD)dwPID;
        }
    }
}

/***************************************************************************\
* _SetDbgTag
*
* Sets debugging level for a tag.
*
* History:
* 16-Aug-1996 adams     Created.
\***************************************************************************/

void
_SetDbgTag(int tag, DWORD dwDBGTAGFlags)
{
#if DEBUGTAGS
    if((tag > DBGTAG_Max)||(tag < 0)) {
        return;
    }
    if (gpsi && tag < DBGTAG_Max && !(dwDBGTAGFlags & ~DBGTAG_VALIDUSERFLAGS)) {
        COPY_FLAG(gpsi->adwDBGTAGFlags[tag], dwDBGTAGFlags, DBGTAG_VALIDUSERFLAGS);
    }
#else
    UNREFERENCED_PARAMETER(tag);
    UNREFERENCED_PARAMETER(dwDBGTAGFlags);
#endif
}


/***************************************************************************\
* UpdateWinIniInt
*
* History:
* 18-Apr-1994 mikeke     Created
\***************************************************************************/
BOOL UpdateWinIniInt(PUNICODE_STRING pProfileUserName,
    UINT         idSection,
    UINT         wKeyNameId,
    int          value
    )
{
    WCHAR szTemp[40];
    WCHAR            szKeyName[40];
    swprintf(szTemp, L"%d", value);

    ServerLoadString(hModuleWin,
                         wKeyNameId,
                         szKeyName,
                         sizeof(szKeyName) / sizeof(WCHAR));

    return FastWriteProfileStringW(pProfileUserName,
                                   idSection,
                                   szKeyName,
                                   szTemp);


}

/***************************************************************************\
* SetDesktopMetrics
*
* History:
* 31-Jan-1994 mikeke    Ported
\***************************************************************************/

void SetDesktopMetrics()
{
    LPRECT      lprcWork;

    lprcWork = &GetPrimaryMonitor()->rcWork;

    SYSMET(CXFULLSCREEN)      = lprcWork->right - lprcWork->left;
    SYSMET(CXMAXIMIZED)       = lprcWork->right - lprcWork->left + 2*SYSMET(CXSIZEFRAME);

    SYSMET(CYFULLSCREEN)      = lprcWork->bottom - lprcWork->top - SYSMET(CYCAPTION);
    SYSMET(CYMAXIMIZED)       = lprcWork->bottom - lprcWork->top + 2*SYSMET(CYSIZEFRAME);
}

/***************************************************************************\
* xxxMetricsRecalc (Win95: MetricsRecalc)
*
* Does work to size/position all minimized or nonminimized
* windows.  Called when frame metrics or min metrics are changed.
*
* Note that you can NOT do DeferWindowPos() with this function.  SWP doesn't
* work when you do parents and children at the same time--it's only for
* peer windows.  Thus we must do SetWindowPos() for each window.
*
* History:
* 06-28-91 MikeHar      Ported.
\***************************************************************************/
void xxxMetricsRecalc(
    UINT wFlags,
    int  dx,
    int  dy,
    int  dyCaption,
    int  dyMenu)
{
    PHWND       phwnd;
    PWND        pwnd;
    RECT        rc;
    PCHECKPOINT pcp;
    TL          tlpwnd;
    BOOL        fResized;
    PBWL        pbwl;
    PTHREADINFO ptiCurrent;
    int         c;

    ptiCurrent = PtiCurrent();
    pbwl = BuildHwndList(
            GETDESKINFO(ptiCurrent)->spwnd->spwndChild,
            BWL_ENUMLIST | BWL_ENUMCHILDREN,
            NULL);

    if (!pbwl)
        return;

    UserAssert(*pbwl->phwndNext == (HWND) 1);
    for (   c = (int)(pbwl->phwndNext - pbwl->rghwnd), phwnd = pbwl->rghwnd;
            c > 0;
            c--, phwnd++) {

        pwnd = RevalidateHwnd(*phwnd);
        if (!pwnd)
            continue;

        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

        fResized = FALSE;

        if ((wFlags & CALC_MINIMIZE) && TestWF(pwnd, WFMINIMIZED)) {
            /*
             * We're changing the minimized window dimensions.  We need to
             * resize.  Note that we do NOT move.
             */
            CopyRect(&rc, (&pwnd->rcWindow));
            rc.right += dx;
            rc.bottom += dy;

            goto PositionWnd;
        }

        /*
         * We're changing the size of the window because the sizing border
         * changed.
         */
        if ((wFlags & CALC_RESIZE) && TestWF(pwnd, WFSIZEBOX)) {

            pcp = (CHECKPOINT *)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);

            /*
             * Update maximized position to account for sizing border
             * We do this for DOS box also.  This way client of max'ed windows
             * stays in same relative position.
             */
            if (pcp && (pcp->fMaxInitialized)) {
                pcp->ptMax.x -= dx;
                pcp->ptMax.y -= dy;
            }

            if (TestWF(pwnd, WFMINIMIZED)) {
                if (pcp)
                    InflateRect(&pcp->rcNormal, dx, dy);
            } else {
                CopyInflateRect(&rc, (&pwnd->rcWindow), dx, dy);
                if (TestWF(pwnd, WFCPRESENT))
                    rc.bottom += dyCaption;
                if (TestWF(pwnd, WFMPRESENT))
                    rc.bottom += dyMenu;

PositionWnd:
                fResized = TRUE;

                /*
                 * Remember SWP expects values in PARENT CLIENT coordinates.
                 */
                if (pwnd->spwndParent != PWNDDESKTOP(pwnd)) {
                    OffsetRect(&rc,
                        -pwnd->spwndParent->rcClient.left,
                        -pwnd->spwndParent->rcClient.top);
                }

                xxxSetWindowPos(pwnd,
                                PWND_TOP,
                                rc.left,
                                rc.top,
                                rc.right-rc.left,
                                rc.bottom-rc.top,

#if 0 // Win95 flags
                                SWP_NOZORDER | SWP_NOACTIVATE | SWP_DEFERDRAWING | SWP_FRAMECHANGED);
#else
                                SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS | SWP_FRAMECHANGED | SWP_NOREDRAW);
#endif
            }
        }

        /*
         * We're changing the nonclient widgets, so recalculate the
         * client.
         */
        if (wFlags & CALC_FRAME) {

            /*
             * Delete any cached small icons...
             */
            if (dyCaption)
                 xxxSendMessage(pwnd, WM_SETICON, ICON_RECREATE, 0);

            if (!TestWF(pwnd, WFMINIMIZED) && !fResized) {

                CopyRect(&rc, &(pwnd->rcWindow));
                if (TestWF(pwnd, WFMPRESENT))
                    rc.bottom += dyMenu;

                if (TestWF(pwnd, WFCPRESENT)) {
                    rc.bottom += dyCaption;
                    /*
                     * Maximized MDI child windows position their caption
                     *  outside their parent's client area (negative y).
                     *  If the caption has changed, they need to be
                     *  repositioned.
                     */
                    if (TestWF(pwnd, WFMAXIMIZED)
                            && TestWF(pwnd, WFCHILD)
                            && (GETFNID(pwnd->spwndParent) == FNID_MDICLIENT)) {

                        xxxSetWindowPos(pwnd,
                                        PWND_TOP,
                                        rc.left  - pwnd->spwndParent->rcWindow.left,
                                        rc.top   - pwnd->spwndParent->rcWindow.top - dyCaption,
                                        rc.right - rc.left,
                                        rc.bottom- rc.top, SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED | SWP_NOREDRAW);
                        goto LoopCleanup;
                    }
                }

                xxxSetWindowPos(pwnd,
                                PWND_TOP,
                                0,
                                0,
                                rc.right-rc.left,
                                rc.bottom-rc.top,
#if 0 // Win95 flags
                                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED | SWP_NOREDRAW);
#else
                                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED | SWP_NOCOPYBITS | SWP_NOREDRAW);
#endif
            }
        }

LoopCleanup:
        ThreadUnlock(&tlpwnd);
    }

    FreeHwndList(pbwl);
}

/***************************************************************************\
* FindOldMonitor
*
* Returns the index of the monitor in "pmr" which has the greatest
* overlap with a rectangle. This function is used to determine which
* monitor a window was on after one or more monitor rectangles have
* changed.
*
* History:
* 11-Sep-1996 adams     Created.
\***************************************************************************/

int
FindOldMonitor(LPCRECT lprc, PMONITORRECTS pmr)
{
    DWORD       dwClosest;
    int         iClosest, i;
    int         cxRect, cyRect;
    PMONITORPOS pmp;

    iClosest = -1;
    dwClosest = 0;

    cxRect = (lprc->right - lprc->left);
    cyRect = (lprc->bottom - lprc->top);

    for (i = 0, pmp = pmr->amp; i < pmr->cMonitor; pmp++, i++)
    {
        RECT rcT;

        if (IntersectRect(&rcT, lprc, &pmp->rcMonitor))
        {
            DWORD dwT;

            //
            // convert to width/height
            //
            rcT.right -= rcT.left;
            rcT.bottom -= rcT.top;

            //
            // if fully enclosed, we're done
            //
            if ((rcT.right == cxRect) && (rcT.bottom == cyRect))
                return i;

            //
            // use largest area
            //
            dwT = (DWORD)rcT.right * (DWORD)rcT.bottom;
            if (dwT > dwClosest)
            {
                dwClosest = dwT;
                iClosest = i;
            }
        }
    }

    return iClosest;
}





/***************************************************************************\
* xxxDesktopRecalc
*
* Moves all top-level nonpopup windows into free desktop area,
* attempting to keep them in the same position relative to the monitor
* they were on.  Also resets minimized info (so that when a window is
* subsequently minimized it will go to the correct location).
*
* History:
* 11-Sep-1996 adams     Created.
\***************************************************************************/

void
xxxDesktopRecalc(PMONITORRECTS pmrOld)
{
    PWND            pwndDesktop;
    PSMWP           psmwp;
    PHWND           phwnd;
    PBWL            pbwl;
    PWND            pwnd;
    CHECKPOINT *    pcp;
    int             iOldMonitor;
    int             codeFullScreen;
    UINT            flags = SWP_NOACTIVATE | SWP_NOZORDER;


    /*
     * We never want csrss to position windows synchronously because he might get
     * blocked by a hung app. Csrss needs to reposition windows in the TS reconnect
     * and disconnect path as part of changing display setting to switch display drivers
     * or to match new client resolution.
     */

    if (ISCSRSS()) {
        flags |= SWP_ASYNCWINDOWPOS;
    }


    UserVerify(pwndDesktop = _GetDesktopWindow());
    if ((pbwl = BuildHwndList(pwndDesktop->spwndChild, BWL_ENUMLIST, NULL)) == NULL)
        return;

    if ((psmwp = InternalBeginDeferWindowPos(4)) != NULL) {
        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1 && psmwp; phwnd++) {
            /*
             * Make sure this hwnd is still around.
             */
            if (    (pwnd = RevalidateHwnd(*phwnd)) == NULL ||
                    TestWF(pwnd, WEFTOOLWINDOW)) {

                continue;
            }

            codeFullScreen = TestWF(pwnd, WFFULLSCREEN) ?
                NORMALIZERECT_FULLSCREEN : NORMALIZERECT_NORMAL;

            pcp = (CHECKPOINT *)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);
            if (pcp) {

                /*
                 * We don't need to blow away saved maximized positions
                 * anymore, since the max position is always (for top level
                 * windows) relative to the origin of the monitor's working
                 * area.  And for child windows, we shouldn't do it period
                 * anyway.
                 */
                pcp->fMinInitialized = FALSE;

                /*
                 * Figure out which monitor the position was on before things
                 * got shuffled around and try to keep it on that monitor.  If
                 * it was never visible on a monitor then leave it alone.
                 */
                iOldMonitor = FindOldMonitor(&pcp->rcNormal, pmrOld);
                if (iOldMonitor != (UINT)-1) {
                    NormalizeRect(
                            &pcp->rcNormal,
                            &pcp->rcNormal,
                            pmrOld,
                            iOldMonitor,
                            codeFullScreen,
                            pwnd->style);
                }
            }

            /*
             * Figure out which monitor the position was on before things got
             * shuffled around and try to keep it on that monitor.  If it
             * was never visible on a monitor then leave it alone.
             */

            iOldMonitor = FindOldMonitor(&pwnd->rcWindow, pmrOld);
            if (iOldMonitor != -1) {

                PMONITOR pMonitorDst;
                RECT rc;

                /*
                 * Check for maximized apps that are truly maximized.
                 * (As opposed to apps that manage their owm maximized rect.)
                 */
                if (TestWF(pwnd, WFMAXIMIZED)) {
                    LPRECT lprcOldWork = &pmrOld->amp[iOldMonitor].rcWork;

                    if (    (pwnd->rcWindow.right - pwnd->rcWindow.left >=
                                lprcOldWork->right - lprcOldWork->left)
                            &&
                            (pwnd->rcWindow.bottom - pwnd->rcWindow.top >=
                                lprcOldWork->bottom - lprcOldWork->top)) {

                        codeFullScreen = NORMALIZERECT_MAXIMIZED;
                    }
                }

                pMonitorDst = NormalizeRect(
                        &rc,
                        &pwnd->rcWindow,
                        pmrOld,
                        iOldMonitor,
                        codeFullScreen,
                        pwnd->style);

                if (TestWF(pwnd, WFMAXFAKEREGIONAL)) {
                    UserAssert(pMonitorDst->hrgnMonitor);
                    pwnd->hrgnClip = pMonitorDst->hrgnMonitor;
                }


                psmwp = _DeferWindowPos(
                        psmwp,
                        pwnd,
                        (PWND)HWND_TOP,
                        rc.left,
                        rc.top,
                        rc.right - rc.left,
                        rc.bottom - rc.top,
                        flags);
            }
        }

        if (psmwp) {
            xxxEndDeferWindowPosEx(psmwp, TRUE);
        }
    }

    FreeHwndList(pbwl);
}



/***************************************************************************\
* SetWindowMetricInt
*
* History:
* 25-Feb-96 BradG       Added Pixel -> TWIPS conversion
\***************************************************************************/

BOOL SetWindowMetricInt(PUNICODE_STRING pProfileUserName,
        WORD wKeyNameId,
        int iIniValue
        )
{
    /*
     * If you change the below list of STR_* make sure you make a corresponding
     * change in FastGetProfileIntFromID (profile.c)
     */
    switch (wKeyNameId) {
    case STR_BORDERWIDTH:
    case STR_SCROLLWIDTH:
    case STR_SCROLLHEIGHT:
    case STR_CAPTIONWIDTH:
    case STR_CAPTIONHEIGHT:
    case STR_SMCAPTIONWIDTH:
    case STR_SMCAPTIONHEIGHT:
    case STR_MENUWIDTH:
    case STR_MENUHEIGHT:
    case STR_ICONHORZSPACING:
    case STR_ICONVERTSPACING:
    case STR_MINWIDTH:
    case STR_MINHORZGAP:
    case STR_MINVERTGAP:
      /*
       * Always store window metrics in TWIPS
       */
        iIniValue = -MultDiv(iIniValue, 72*20, gpsi->dmLogPixels);
        break;
    }

      return UpdateWinIniInt(pProfileUserName,
                             PMAP_METRICS,
                             wKeyNameId,
                             iIniValue);
}

/***************************************************************************\
* SetWindowMetricFont
*
* History:
\***************************************************************************/

BOOL SetWindowMetricFont(PUNICODE_STRING pProfileUserName,
    UINT idKey,
    LPLOGFONT lplf
    )
{
    return FastWriteProfileValue(
            pProfileUserName,
            PMAP_METRICS,
            (LPWSTR)UIntToPtr( idKey ),
            REG_BINARY,
            (LPBYTE)lplf,
            sizeof(LOGFONTW)
            );
}


/***************************************************************************\
* SetAndDrawNCMetrics
*
* History:
\***************************************************************************/

BOOL xxxSetAndDrawNCMetrics(PUNICODE_STRING pProfileUserName,
    int clNewBorder,
    LPNONCLIENTMETRICS lpnc)
{
    int dl;
    int dxMinOld;
    int dyMinOld;
    int cxBorder;
    int cyBorder;
    int dyCaption;
    int dyMenu;

    dl = clNewBorder - gpsi->gclBorder;
    dxMinOld = SYSMET(CXMINIMIZED);
    dyMinOld = SYSMET(CYMINIMIZED);
    cxBorder = SYSMET(CXBORDER);
    cyBorder = SYSMET(CYBORDER);


    /*
     * Do we need to recalculate?
     */
    if ((lpnc == NULL) && !dl)
        return(FALSE);

    if (lpnc) {
        dyCaption = (int)lpnc->iCaptionHeight - SYSMET(CYSIZE);
        dyMenu = (int)lpnc->iMenuHeight - SYSMET(CYMENUSIZE);
    } else {
        dyCaption = dyMenu = 0;
    }


    /*
     * Recalculate the system metrics
     */
    xxxSetWindowNCMetrics(pProfileUserName, lpnc, TRUE, clNewBorder);

    /*
     * Reset our saved menu size/position info
     */
    MenuRecalc();

    /*
     * Reset window sized, positions, frames
     */
    xxxMetricsRecalc(
            CALC_FRAME | (dl ? CALC_RESIZE : 0),
            dl*cxBorder,
            dl*cyBorder,
            dyCaption,
            dyMenu);

    dxMinOld = SYSMET(CXMINIMIZED) - dxMinOld;
    dyMinOld = SYSMET(CYMINIMIZED) - dyMinOld;
    if (dxMinOld || dyMinOld) {
        xxxMetricsRecalc(CALC_MINIMIZE, dxMinOld, dyMinOld, 0, 0);
    }

    xxxRedrawScreen();


    return TRUE;
}

/***************************************************************************\
* xxxSetAndDrawMinMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/
BOOL xxxSetAndDrawMinMetrics(PUNICODE_STRING pProfileUserName,
        LPMINIMIZEDMETRICS lpmin
        )
{
    /*
     * Save minimized window dimensions
     */
    int dxMinOld = SYSMET(CXMINIMIZED);
    int dyMinOld = SYSMET(CYMINIMIZED);


    SetMinMetrics(pProfileUserName,lpmin);

    /*
     * Do we need to adjust minimized size?
     */
    dxMinOld = SYSMET(CXMINIMIZED) - dxMinOld;
    dyMinOld = SYSMET(CYMINIMIZED) - dyMinOld;

    if (dxMinOld || dyMinOld) {
        xxxMetricsRecalc(CALC_MINIMIZE, dxMinOld, dyMinOld, 0, 0);
    }

    xxxRedrawScreen();


    return TRUE;
}


/***************************************************************************\
* xxxSPISetNCMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/

BOOL xxxSPISetNCMetrics(PUNICODE_STRING pProfileUserName,
        LPNONCLIENTMETRICS lpnc,
        BOOL fAlterWinIni
        )
{
    BOOL fWriteAllowed = !fAlterWinIni;
    BOOL fChanged = FALSE;

    if (fAlterWinIni) {
        fChanged  = SetWindowMetricInt(pProfileUserName,STR_BORDERWIDTH,     (int) lpnc->iBorderWidth        );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_SCROLLWIDTH,     (int) lpnc->iScrollWidth        );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_SCROLLHEIGHT,    (int) lpnc->iScrollHeight       );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_CAPTIONWIDTH,    (int) lpnc->iCaptionWidth       );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_CAPTIONHEIGHT,   (int) lpnc->iCaptionHeight      );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_SMCAPTIONWIDTH,  (int) lpnc->iSmCaptionWidth     );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_SMCAPTIONHEIGHT, (int) lpnc->iSmCaptionHeight    );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_MENUWIDTH,       (int) lpnc->iMenuWidth          );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_MENUHEIGHT,      (int) lpnc->iMenuHeight         );

        fChanged &= SetWindowMetricFont(pProfileUserName,STR_CAPTIONFONT,    &lpnc->lfCaptionFont            );
        fChanged &= SetWindowMetricFont(pProfileUserName,STR_SMCAPTIONFONT,  &lpnc->lfSmCaptionFont          );
        fChanged &= SetWindowMetricFont(pProfileUserName,STR_MENUFONT,       &lpnc->lfMenuFont               );
        fChanged &= SetWindowMetricFont(pProfileUserName,STR_STATUSFONT,     &lpnc->lfStatusFont             );
        fChanged &= SetWindowMetricFont(pProfileUserName,STR_MESSAGEFONT,    &lpnc->lfMessageFont            );

        fWriteAllowed = fChanged;
    }

    if (fWriteAllowed)
        xxxSetAndDrawNCMetrics(pProfileUserName,(int) lpnc->iBorderWidth, lpnc);

    return fChanged;
}

/***************************************************************************\
* xxxSPISetMinMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/

BOOL xxxSPISetMinMetrics(PUNICODE_STRING pProfileUserName,
    LPMINIMIZEDMETRICS lpmin,
    BOOL fAlterWinIni
    )
{
    BOOL fWriteAllowed = !fAlterWinIni;
    BOOL fChanged = FALSE;

    if (fAlterWinIni) {
        fChanged  = SetWindowMetricInt(pProfileUserName,STR_MINWIDTH,   (int) lpmin->iWidth      );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_MINHORZGAP, (int) lpmin->iHorzGap    );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_MINVERTGAP, (int) lpmin->iVertGap    );
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_MINARRANGE, (int) lpmin->iArrange    );

        fWriteAllowed = fChanged;
    }

    if (fWriteAllowed) {
        xxxSetAndDrawMinMetrics(pProfileUserName,lpmin);
    }

    return fChanged;
}


/***************************************************************************\
* SPISetIconMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/
BOOL SPISetIconMetrics(PUNICODE_STRING pProfileUserName,
    LPICONMETRICS lpicon,
    BOOL          fAlterWinIni
    )
{
    BOOL fWriteAllowed = !fAlterWinIni;
    BOOL fChanged = FALSE;

    if (fAlterWinIni) {
        fChanged  = SetWindowMetricInt(pProfileUserName,STR_ICONHORZSPACING, (int) lpicon->iHorzSpacing);
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_ICONVERTSPACING, (int) lpicon->iVertSpacing);
        fChanged &= SetWindowMetricInt(pProfileUserName,STR_ICONTITLEWRAP,   (int) lpicon->iTitleWrap);
        fChanged &= SetWindowMetricFont(pProfileUserName,STR_ICONFONT,             &lpicon->lfFont);

        fWriteAllowed = fChanged;
    }

    if (fWriteAllowed) {

        SetIconMetrics(pProfileUserName,lpicon);

        xxxRedrawScreen();
    }

    return fChanged;
}


/***************************************************************************\
* SPISetIconTitleFont
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/

BOOL SPISetIconTitleFont(PUNICODE_STRING pProfileUserName,
    LPLOGFONT lplf,
    BOOL      fAlterWinIni
    )
{
    HFONT hfnT;
    BOOL  fWriteAllowed = !fAlterWinIni;
    BOOL  fWinIniChanged = FALSE;

    if (hfnT = CreateFontFromWinIni(pProfileUserName,lplf, STR_ICONFONT)) {
        if (fAlterWinIni) {

            if (lplf) {
                LOGFONT lf;

                GreExtGetObjectW(hfnT, sizeof(LOGFONTW), &lf);
                fWinIniChanged = SetWindowMetricFont(pProfileUserName,STR_ICONFONT, &lf);
            } else {
                /*
                 * !lParam so go back to current win.ini settings so
                 */
                fWinIniChanged = TRUE;
            }

            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {

            if (ghIconFont) {
                GreMarkDeletableFont(ghIconFont);
                GreDeleteObject(ghIconFont);
            }

            ghIconFont = hfnT;

        } else {
            GreMarkDeletableFont(hfnT);
            GreDeleteObject(hfnT);
        }
    }

    return fWinIniChanged;
}

/***************************************************************************\
* xxxSetSPIMetrics
*
* History:
* 13-May-1994 mikeke     mikeke     Ported
\***************************************************************************/

BOOL
xxxSetSPIMetrics(PUNICODE_STRING pProfileUserName,
        DWORD wFlag,
        LPVOID lParam,
        BOOL fAlterWinIni
        )
{
    BOOL fWinIniChanged;

    switch (wFlag) {
    case SPI_SETANIMATION:
        if (fAlterWinIni) {
            fWinIniChanged = SetWindowMetricInt(pProfileUserName,
                    STR_MINANIMATE,
                    (int) ((LPANIMATIONINFO) lParam)->iMinAnimate
                    );

            if (!fWinIniChanged) {
                return FALSE;
            }
        } else {
            fWinIniChanged = FALSE;
        }

        SET_OR_CLEAR_PUDF(PUDF_ANIMATE, ((LPANIMATIONINFO) lParam)->iMinAnimate);
        return fWinIniChanged;

    case SPI_SETNONCLIENTMETRICS:
        return xxxSPISetNCMetrics(pProfileUserName,(LPNONCLIENTMETRICS) lParam, fAlterWinIni);

    case SPI_SETICONMETRICS:
        return SPISetIconMetrics(pProfileUserName,(LPICONMETRICS) lParam, fAlterWinIni);

    case SPI_SETMINIMIZEDMETRICS:
        return xxxSPISetMinMetrics(pProfileUserName,(LPMINIMIZEDMETRICS) lParam, fAlterWinIni);

    case SPI_SETICONTITLELOGFONT:
        return SPISetIconTitleFont(pProfileUserName,(LPLOGFONT) lParam, fAlterWinIni);

    default:
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "SetSPIMetrics. Invalid wFlag: %#lx", wFlag);
        return FALSE;
    }
}

/***************************************************************************\
* SetFilterKeys
*
* History:
* 10-12-94 JimA         Created.
\***************************************************************************/

BOOL SetFilterKeys(PUNICODE_STRING pProfileUserName,
    LPFILTERKEYS pFilterKeys)
{
    LPWSTR           pwszd = L"%d";
    BOOL             fWinIniChanged;
    WCHAR            szTemp[40];

    swprintf(szTemp, pwszd, pFilterKeys->dwFlags);
    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
            PMAP_KEYBOARDRESPONSE,
            L"Flags",
            szTemp
            );

    swprintf(szTemp, pwszd, pFilterKeys->iWaitMSec);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
            PMAP_KEYBOARDRESPONSE,
            L"DelayBeforeAcceptance",
            szTemp
            );

    swprintf(szTemp, pwszd, pFilterKeys->iDelayMSec);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
            PMAP_KEYBOARDRESPONSE,
            L"AutoRepeatDelay",
            szTemp
            );

    swprintf(szTemp, pwszd, pFilterKeys->iRepeatMSec);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
            PMAP_KEYBOARDRESPONSE,
            L"AutoRepeatRate",
            szTemp
            );

    swprintf(szTemp, pwszd, pFilterKeys->iBounceMSec);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
            PMAP_KEYBOARDRESPONSE,
            L"BounceTime",
            szTemp
            );

    return fWinIniChanged;
}

/***************************************************************************\
* SetMouseKeys
*
* History:
* 10-12-94 JimA         Created.
\***************************************************************************/

BOOL SetMouseKeys(PUNICODE_STRING pProfileUserName,
    LPMOUSEKEYS  pMK)
{
    LPWSTR           pwszd = L"%d";
    BOOL             fWinIniChanged;
    WCHAR            szTemp[40];

    swprintf(szTemp, pwszd, pMK->dwFlags);
    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
            PMAP_MOUSEKEYS,
            L"Flags",
            szTemp
            );

    swprintf(szTemp, pwszd, pMK->iMaxSpeed);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
            PMAP_MOUSEKEYS,
            L"MaximumSpeed",
            szTemp
            );

    swprintf(szTemp, pwszd, pMK->iTimeToMaxSpeed);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
            PMAP_MOUSEKEYS,
            L"TimeToMaximumSpeed",
            szTemp
            );

    return fWinIniChanged;
}

/***************************************************************************\
* SetSoundSentry
*
* History:
* 10-12-94 JimA         Created.
\***************************************************************************/

BOOL SetSoundSentry(PUNICODE_STRING pProfileUserName,
    LPSOUNDSENTRY pSS)
{
    LPWSTR           pwszd = L"%d";
    BOOL             fWinIniChanged;
    WCHAR            szTemp[40];

    swprintf(szTemp, pwszd, pSS->dwFlags);
    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
            PMAP_SOUNDSENTRY,
            L"Flags",
            szTemp
            );

    swprintf(szTemp, pwszd, pSS->iFSTextEffect);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
            PMAP_SOUNDSENTRY,
            L"TextEffect",
            szTemp
            );

    swprintf(szTemp, pwszd, pSS->iWindowsEffect);
    fWinIniChanged &= FastWriteProfileStringW(pProfileUserName,
            PMAP_SOUNDSENTRY,
            L"WindowsEffect",
            szTemp
            );

    return fWinIniChanged;
}


/***************************************************************************\
* CalculateMouseSensitivity
*
*      The resultant table looks like this...
*
*      Sens |  Sensitivity Adjustment
*       0   |  0           * SENS_SCALAR  ALGORITHM 0<=NUM<=2
*       1   |  1/32        * SENS_SCALAR   (NUM/32)*SENS_SCALAR
*       2   |  1/16        * SENS_SCALAR
*       3   |  1/8         * SENS_SCALAR  ALGORITHM 3<=NUM<=10
*       4   |  1/4  (2/8)  * SENS_SCALAR   ((NUM-2)/8)*SENS_SCALAR
*       5   |  3/8         * SENS_SCALAR
*       6   |  1/2  (4/8)  * SENS_SCALAR
*       7   |  5/8         * SENS_SCALAR
*       8   |  3/4  (6/8)  * SENS_SCALAR
*       9   |  7/8         * SENS_SCALAR
*       10  |  1           * SENS_SCALAR
*       11  |  5/4         * SENS_SCALAR  ALGORITHM NUM>=11
*       12  |  3/2  (6/4)  * SENS_SCALAR   ((NUM-6)/4)*SENS_SCALAR
*       13  |  7/4         * SENS_SCALAR
*       14  |  2    (8/4)  * SENS_SCALAR
*       15  |  9/4         * SENS_SCALAR
*       16  |  5/2  (10/4) * SENS_SCALAR
*       17  |  11/4        * SENS_SCALAR
*       18  |  3    (12/4) * SENS_SCALAR
*       19  |  13/4        * SENS_SCALAR
*       20  |  7/2  (14/4) * SENS_SCALAR
*
*     COMMENTS:  Sensitivities are constrained to be between 1 and 20.
*
* History:
* 09-27-96 jparsons     Created.
\***************************************************************************/
LONG CalculateMouseSensitivity(
    LONG lSens)
{
    LONG lSenFactor;

    if (lSens <= 2) {
       lSenFactor = lSens * 256 / 32;
    } else if (lSens >= 3 && lSens <= 10 ) {
       lSenFactor = (lSens - 2) * 256 /8;
    } else {
       lSenFactor= (lSens - 6) * 256 / 4;
    }

    return lSenFactor;
}


/***************************************************************************\
* xxxSystemParametersInfo
*
* SPI_GETBEEP:   wParam is not used. lParam is long pointer to a boolean which
*                gets true if beep on, false if beep off.
*
* SPI_SETBEEP:   wParam is a bool which sets beep on (true) or off (false).
*                lParam is not used.
*
* SPI_GETMOUSE:  wParam is not used. lParam is long pointer to an integer
*                array where rgw[0] gets xMouseThreshold, rgw[1] gets
*                yMouseThreshold, and rgw[2] gets gMouseSpeed.
*
* SPI_SETMOUSE:  wParam is not used. lParam is long pointer to an integer
*                array as described above.  User's values are set to values
*                in array.
*
* SPI_GETBORDER: wParam is not used. lParam is long pointer to an integer
*                which gets the value of clBorder (border multiplier factor).
*
* SPI_SETBORDER: wParam is an integer which sets gpsi->gclBorder.
*                lParam is not used.
*
* SPI_GETKEYBOARDDELAY: wParam is not used. lParam is a long pointer to an int
*                which gets the current keyboard repeat delay setting.
*
* SPI_SETKEYBOARDDELAY: wParam is the new keyboard delay setting.
*                lParam is not used.
*
* SPI_GETKEYBOARDSPEED: wParam is not used.  lParam is a long pointer
*                to an int which gets the current keyboard repeat
*                speed setting.
*
* SPI_SETKEYBOARDSPEED: wParam is the new keyboard speed setting.
*                lParam is not used.
*
* SPI_KANJIMENU: wParam contains:
*                    1 - Mouse accelerator
*                    2 - ASCII accelerator
*                    3 - Kana accelerator
*                lParam is not used.  The wParam value is stored in the global
*                KanjiMenu for use in accelerator displaying & searching.
*
* SPI_LANGDRIVER: wParam is not used.
*                 lParam contains a LPSTR to the new language driver filename.
*
* SPI_ICONHORIZONTALSPACING: wParam is the width in pixels of an icon cell.
*
* SPI_ICONVERTICALSPACING: wParam is the height in pixels of an icon cell.
*
* SPI_GETSCREENSAVETIMEOUT: wParam is not used
*                lParam is a pointer to an int which gets the screen saver
*                timeout value.
*
* SPI_SETSCREENSAVETIMEOUT: wParam is the time in seconds for the system
*                to be idle before screensaving.
*
* SPI_GETSCREENSAVEACTIVE: lParam is a pointer to a BOOL which gets TRUE
*                if the screensaver is active else gets false.
*
* SPI_SETSCREENSAVEACTIVE: if wParam is TRUE, screensaving is activated
*                else it is deactivated.
*
* SPI_SETBLOCKSENDINPUTRESETS:
* SPI_GETBLOCKSENDINPUTRESETS:
*     wParam is BOOL signifying if this is active or not.
*
* SPI_GETLOWPOWERTIMEOUT:
* SPI_GETPOWEROFFTIMEOUT: wParam is not used
*                lParam is a pointer to an int which gets the appropriate
*                power saving screen blanker timeout value.
*
* SPI_SETLOWPOWERTIMEOUT:
* SPI_SETPOWEROFFTIMEOUT: wParam is the time in seconds for the system
*                to be idle before power saving screen blanking.
*
* SPI_GETLOWPOWERACTIVE:
* SPI_GETPOWEROFFACTIVE: lParam is a pointer to a BOOL which gets TRUE
*                if the power saving screen blanker is active else gets false.
*
* SPI_SETLOWPOWERACTIVE:
* SPI_SETPOWEROFFACTIVE: if wParam is TRUE, power saving screen blanking is
*                activated else it is deactivated.
*
* SPI_GETGRIDGRANULARITY: Obsolete. Returns 1 always.
*
* SPI_SETGRIDGRANULARITY: Obsolete.  Does nothing.
*
* SPI_SETDESKWALLPAPER: wParam is not used; lParam is a long ptr to a string
*                that holds the name of the bitmap file to be used as the
*                desktop wall paper.
*
* SPI_SETDESKPATTERN: Both wParam and lParam are not used; USER will read the
*                "pattern=" from WIN.INI and make it as the current desktop
*                 pattern;
*
* SPI_GETICONTITLEWRAP: lParam is LPINT which gets 0 if wrapping if off
*                       else gets 1.
*
* SPI_SETICONTITLEWRAP: wParam specifies TRUE to turn wrapping on else false
*
* SPI_GETMENUDROPALIGNMENT: lParam is LPINT which gets 0 specifies if menus
*                 drop left aligned else 1 if drop right aligned.
*
* SPI_SETMENUDROPALIGNMENT: wParam 0 specifies if menus drop left aligned else
*                 the drop right aligned.
*
* SPI_SETDOUBLECLKWIDTH: wParam specifies the width of the rectangle
*                 within which the second click of a double click must fall
*                 for it to be registered as a double click.
*
* SPI_SETDOUBLECLKHEIGHT: wParam specifies the height of the rectangle
*                 within which the second click of a double click must fall
*                 for it to be registered as a double click.
*
* SPI_GETICONTITLELOGFONT: lParam is a pointer to a LOGFONT struct which
*                 gets the logfont for the current icon title font. wParam
*                 specifies the size of the logfont struct.
*
* SPI_SETDOUBLECLICKTIME: wParm specifies the double click time
*
* SPI_SETMOUSEBUTTONSWAP: if wParam is 1, swap mouse buttons else if wParam
*                 is 0, don't swap buttons
* SPI_SETDRAGFULLWINDOWS: wParam = fSet.
* SPI_GETDRAGFULLWINDOWS: returns fSet.
*
* SPI_GETFILTERKEYS: lParam is a pointer to a FILTERKEYS struct.  wParam
*                 specifies the size of the filterkeys struct.
*
* SPI_SETFILTERKEYS: lParam is a pointer to a FILTERKEYS struct.  wParam
*                 is not used.
*
* SPI_GETSTICKYKEYS: lParam is a pointer to a STICKYKEYS struct.  wParam
*                 specifies the size of the stickykeys struct.
*
* SPI_SETSTICKYKEYS: lParam is a pointer to a STICKYKEYS struct.  wParam
*                 is not used.
*
* SPI_GETMOUSEKEYS: lParam is a pointer to a MOUSEKEYS struct.  wParam
*                 specifies the size of the mousekeys struct.
*
* SPI_SETMOUSEKEYS: lParam is a pointer to a MOUSEKEYS struct.  wParam
*                 is not used.
*
* SPI_GETACCESSTIMEOUT: lParam is a pointer to an ACCESSTIMEOUT struct.
*                 wParam specifies the size of the accesstimeout struct.
*
* SPI_SETACCESSTIMEOUT: lParam is a pointer to a ACCESSTIMEOUT struct.
*                 wParam is not used.
*
* SPI_GETTOGGLEKEYS: lParam is a pointer to a TOGGLEKEYS struct.  wParam
*                 specifies the size of the togglekeys struct.
*
* SPI_SETTOGGLEKEYS: lParam is a pointer to a TOGGLEKEYS struct.  wParam
*                 is not used.
*
* SPI_GETKEYBOARDPREF: lParam is a pointer to a BOOL.
*                 wParam is not used.
*
* SPI_SETKEYBOARDPREF: wParam is a BOOL.
*                 lParam is not used.
*
* SPI_GETSCREENREADER: lParam is a pointer to a BOOL.
*                 wParam is not used.
*
* SPI_SETSCREENREADER: wParam is a BOOL.
*                 lParam is not used.
*
* SPI_GETSHOWSOUNDS: lParam is a pointer to a SHOWSOUNDS struct.  wParam
*                 specifies the size of the showsounds struct.
*
* SPI_SETSHOWSOUNDS: lParam is a pointer to a SHOWSOUNDS struct.  wParam
*                 is not used.
*
* SPI_GETNONCLIENTMETRICS: lParam is a pointer to a NONCLIENTMETRICSW struct.
*                 wPAram is not used.
*
* SPI_GETSNAPTODEFBUTTON: lParam is a pointer to a BOOL which gets TRUE
*                if the snap to default push button is active else gets false.
*
* SPI_SETSNAPTODEFBUTTON: if wParam is TRUE, dialog boxes will snap the mouse
*                pointer to the default push button when created.
*
* SPI_GETFONTSMOOTHING:
*     wParam is unused
*     lParam is LPINT for boolean fFontSmoothing
*
* SPI_SETFONTSMOOTHING:
*     wParam is INT for boolean fFontSmoothing
*
* SPI_GETWHEELSCROLLLINES: lParam is a pointer to a ULONG to receive the
*                 suggested number of lines to scroll when the wheel is
*                 rotated. wParam is unused.
*
* SPI_SETWHEELSCROLLLINES: wParam is a ULONG containing the suggested number
*                 of lines to scroll when the wheel is rotated. lParam is
*                 unused.
*
* SPI_SETSCREENSAVERRUNNING / SPI_SCREENSAVERRUNNING: not supported on NT.
* SPI_GETSCREENSAVERRUNNING: wParam - Not used. lParam a pointer to a BOOL which
*                 will receive TRUE is a screen saver is running or FALSE otherwise.
*
* SPI_SETSHOWIMEUI wParam is TRUE or FALSE
* SPI_GETSHOWIMEUI neither wParam or lParam used
*
* History:
* 06-28-91      MikeHar     Ported.
* 12-8-93       SanfordS    Added SPI_SET/GETDRAGFULLWINDOWS
* 20-May-1996   adams       Added SPI_SET/GETWHEELSCROLLLINES
* 02-Mar-2002   MMcCr       Added SPI_SET/GETBLOCKSENDINPUTRESETS
\***************************************************************************/

BOOL xxxSystemParametersInfo(
        UINT         wFlag,     // Item to change
        DWORD        wParam,
        PVOID        lParam,
        UINT         flags
        )
{
    PPROCESSINFO         ppi = PpiCurrent();
    int                  clBorderOld;
    int                  clBorderNew;
    LPWSTR               pwszd = L"%d";
    WCHAR                szSection[40];
    WCHAR                szTemp[40];
    WCHAR                szPat[MAX_PATH];
    BOOL                 fWinIniChanged = FALSE;
    BOOL                 fAlterWinIni = ((flags & SPIF_UPDATEINIFILE) != 0);
    BOOL                 fSendWinIniChange = ((flags & SPIF_SENDCHANGE) != 0);
    BOOL                 fWriteAllowed = !fAlterWinIni;
    ACCESS_MASK          amRequest;
    LARGE_UNICODE_STRING strSection;
    int                  *piTimeOut;
    int                  iResID;
    TL tlName;
    PUNICODE_STRING pProfileUserName = NULL;

    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * CONSIDER(adams) : Many of the SPI_GET* could be implemented
     * on the client side (SnapTo, WheelScrollLines, etc.).
     */

    /*
     * Features not implemented
     */

    switch (wFlag)
    {
        case SPI_TIMEOUTS:
        case SPI_KANJIMENU:
        case SPI_LANGDRIVER:
        case SPI_UNUSED39:
        case SPI_UNUSED40:
        case SPI_SETPENWINDOWS:

        case SPI_GETWINDOWSEXTENSION:
        case SPI_SETSCREENSAVERRUNNING:     // same as SPI_SCREENSAVERRUNNING

        case SPI_GETSERIALKEYS:
        case SPI_SETSERIALKEYS:
            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "SPI_ 0x%lx parameter not supported", wFlag );

            return FALSE;
    }


    /*
     * Perform access check.  Always grant access to CSR.
     */
    if (ppi->Process != gpepCSRSS) {
        switch (wFlag) {
        case SPI_SETBEEP:
        case SPI_SETMOUSE:
        case SPI_SETBORDER:
        case SPI_SETKEYBOARDSPEED:
        case SPI_SETDEFAULTINPUTLANG:
        case SPI_SETSCREENSAVETIMEOUT:
        case SPI_SETSCREENSAVEACTIVE:
        case SPI_SETBLOCKSENDINPUTRESETS:
        case SPI_SETLOWPOWERTIMEOUT:
        case SPI_SETPOWEROFFTIMEOUT:
        case SPI_SETLOWPOWERACTIVE:
        case SPI_SETPOWEROFFACTIVE:
        case SPI_SETGRIDGRANULARITY:
        case SPI_SETDESKWALLPAPER:
        case SPI_SETDESKPATTERN:
        case SPI_SETKEYBOARDDELAY:
        case SPI_SETICONTITLEWRAP:
        case SPI_SETMENUDROPALIGNMENT:
        case SPI_SETDOUBLECLKWIDTH:
        case SPI_SETDOUBLECLKHEIGHT:
        case SPI_SETDOUBLECLICKTIME:
        case SPI_SETMOUSEBUTTONSWAP:
        case SPI_SETICONTITLELOGFONT:
        case SPI_SETFASTTASKSWITCH:
        case SPI_SETFILTERKEYS:
        case SPI_SETTOGGLEKEYS:
        case SPI_SETMOUSEKEYS:
        case SPI_SETSHOWSOUNDS:
        case SPI_SETSTICKYKEYS:
        case SPI_SETACCESSTIMEOUT:
        case SPI_SETSOUNDSENTRY:
        case SPI_SETKEYBOARDPREF:
        case SPI_SETSCREENREADER:
        case SPI_SETSNAPTODEFBUTTON:
        case SPI_SETANIMATION:
        case SPI_SETNONCLIENTMETRICS:
        case SPI_SETICONMETRICS:
        case SPI_SETMINIMIZEDMETRICS:
        case SPI_SETWORKAREA:

        case SPI_SETFONTSMOOTHING:
        case SPI_SETMOUSEHOVERWIDTH:
        case SPI_SETMOUSEHOVERHEIGHT:
        case SPI_SETMOUSEHOVERTIME:
        case SPI_SETWHEELSCROLLLINES:
        case SPI_SETMENUSHOWDELAY:
        case SPI_SETHIGHCONTRAST:
        case SPI_SETDRAGFULLWINDOWS:
        case SPI_SETDRAGWIDTH:
        case SPI_SETDRAGHEIGHT:
        case SPI_SETCURSORS:
        case SPI_SETICONS:
        case SPI_SETLANGTOGGLE:
            amRequest = WINSTA_WRITEATTRIBUTES;
            break;

        case SPI_ICONHORIZONTALSPACING:
        case SPI_ICONVERTICALSPACING:
            if (IS_PTR(lParam)) {
                amRequest = WINSTA_READATTRIBUTES;
            } else if (wParam) {
                amRequest = WINSTA_WRITEATTRIBUTES;
            } else
                return TRUE;
            break;

        default:
            if ((wFlag & SPIF_RANGETYPEMASK) && (wFlag & SPIF_SET)) {
                amRequest = WINSTA_WRITEATTRIBUTES;
            } else {
                amRequest = WINSTA_READATTRIBUTES;
            }
            break;
        }

        if (amRequest == WINSTA_READATTRIBUTES) {
            RETURN_IF_ACCESS_DENIED(ppi->amwinsta, amRequest, FALSE);
        } else {
            UserAssert(amRequest == WINSTA_WRITEATTRIBUTES);
            if (!CheckWinstaWriteAttributesAccess()) {
                return FALSE;
            }
        }

        /*
         * If we're reading, then set the write flag to ensure that
         * the return value will be TRUE.
         */
        if (amRequest == WINSTA_READATTRIBUTES)
            fWriteAllowed = TRUE;
    } else {
        fWriteAllowed = TRUE;
    }

    /*
     * Make sure the section buffer is terminated.
     */
    szSection[0] = 0;

    switch (wFlag) {
    case SPI_GETBEEP:
        (*(BOOL *)lParam) = TEST_BOOL_PUDF(PUDF_BEEP);
        break;

    case SPI_SETBEEP:
        if (fAlterWinIni) {
            ServerLoadString(
                    hModuleWin,
                    (UINT)(wParam ? STR_BEEPYES : STR_BEEPNO),
                    (LPWSTR)szTemp, 10);

            fWinIniChanged = FastUpdateWinIni(NULL,
                    PMAP_BEEP,
                    (UINT) STR_BEEP,
                    szTemp
                    );

            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            SET_OR_CLEAR_PUDF(PUDF_BEEP, wParam);
        }

        break;


    case SPI_SETMOUSESPEED:
        /*
         * JasonSch - 11/16/2000:
         * Temporary hack to allow the shell control panel to modify the new
         * mouse parameter. A better solution (most likely a new SPI) needs
         * to be determined.
         */
        if (((LONG_PTR) lParam < MOUSE_SENSITIVITY_MIN) || ((LONG_PTR) lParam > MOUSE_SENSITIVITY_MAX)) {
            return FALSE;
        }

        if (fAlterWinIni) {
            swprintf(szTemp, pwszd, lParam) ;
            fWinIniChanged = FastUpdateWinIni(NULL,
                    PMAP_MOUSE,
                    STR_MOUSESENSITIVITY,
                    szTemp
                    );

            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            gMouseSensitivity = PtrToLong(lParam);
            gMouseSensitivityFactor = CalculateMouseSensitivity(PtrToLong(lParam));

#ifdef SUBPIXEL_MOUSE
            ResetMouseAccelerationCurves();
#endif // SUBPIXEL_MOUSE
        }
        break;

    case SPI_GETMOUSESPEED:
        *((LPINT)lParam) = gMouseSensitivity;
        break;

    case SPI_SETMOUSETRAILS:
        if (fAlterWinIni) {
            swprintf(szTemp, pwszd, wParam) ;
            fWinIniChanged = FastUpdateWinIni(NULL,
                    PMAP_MOUSE,
                    STR_MOUSETRAILS,
                    szTemp
                    );

            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            SetMouseTrails(wParam);
        }
        break;

    case SPI_GETMOUSETRAILS:
        *((LPINT)lParam) = gMouseTrails ? gMouseTrails + 1 : gMouseTrails;
        break;

    case SPI_GETMOUSE:
        ((LPINT)lParam)[0] = gMouseThresh1;
        ((LPINT)lParam)[1] = gMouseThresh2;
        ((LPINT)lParam)[2] = gMouseSpeed;
        break;

    case SPI_SETMOUSE:
        if (fAlterWinIni) {
            BOOL bWritten1, bWritten2, bWritten3;

            pProfileUserName = CreateProfileUserName(&tlName);
            bWritten1 = UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSETHRESH1, ((LPINT)lParam)[0]);
            bWritten2 = UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSETHRESH2, ((LPINT)lParam)[1]);
            bWritten3 = UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSESPEED,   ((LPINT)lParam)[2]);
            if (bWritten1 && bWritten2 && bWritten3) {
                fWinIniChanged = TRUE;
            } else {
                /*
                 * Attempt to backout any changes.
                 */
                if (bWritten1) {
                    UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSETHRESH1, gMouseThresh1);
                }
                if (bWritten2) {
                    UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSETHRESH2, gMouseThresh2);
                }
                if (bWritten3) {
                    UpdateWinIniInt(pProfileUserName, PMAP_MOUSE, STR_MOUSESPEED,   gMouseSpeed);
                }
            }
            fWriteAllowed = fWinIniChanged;
            FreeProfileUserName(pProfileUserName, &tlName);
        }

        if (fWriteAllowed) {
            gMouseThresh1 = ((LPINT)lParam)[0];
            gMouseThresh2 = ((LPINT)lParam)[1];
            gMouseSpeed = ((LPINT)lParam)[2];
        }
        break;

    case SPI_GETSNAPTODEFBUTTON:
        (*(LPBOOL)lParam) = TEST_BOOL_PUSIF(PUSIF_SNAPTO);
        break;

    case SPI_SETSNAPTODEFBUTTON:
        wParam = (wParam != 0);

        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_SNAPTO, wParam);
            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed) {
            SET_OR_CLEAR_PUSIF(PUSIF_SNAPTO, wParam);
        }

        break;

    case SPI_GETBORDER:
        (*(LPINT)lParam) = gpsi->gclBorder;
        break;

    case SPI_SETBORDER:
        pProfileUserName = CreateProfileUserName(&tlName);
        if (fAlterWinIni) {
            fWinIniChanged = SetWindowMetricInt(pProfileUserName, STR_BORDERWIDTH, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            clBorderOld = gpsi->gclBorder;
            clBorderNew = wParam;

            if (clBorderNew < 1) {
                clBorderNew = 1;
            } else if (clBorderNew > 50) {
                clBorderNew = 50;
            }

            if (clBorderOld == clBorderNew) {

                /*
                 * If border size doesn't change, don't waste time.
                 */
                FreeProfileUserName(pProfileUserName, &tlName);
                break;
            }

            xxxSetAndDrawNCMetrics(pProfileUserName, clBorderNew, NULL);

            /*
             * Nice magic number of 3.  So if the border is set to 1, there are actualy
             * 4 pixels in the border
             */

            bSetDevDragWidth(gpDispInfo->hDev, gpsi->gclBorder + BORDER_EXTRA);
        }
        FreeProfileUserName(pProfileUserName, &tlName);
        break;

    case SPI_GETFONTSMOOTHING:
        (*(LPINT)lParam) = !!(GreGetFontEnumeration() & FE_AA_ON);
        break;

    case SPI_SETFONTSMOOTHING:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_FONTSMOOTHING)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        wParam = (wParam ? FE_AA_ON : 0);
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_DESKTOP, STR_FONTSMOOTHING, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            GreSetFontEnumeration(wParam | FE_SET_AA);
        }
        break;

    case SPI_GETKEYBOARDSPEED:
        (*(int *)lParam) = (gnKeyboardSpeed & KSPEED_MASK);
        break;

    case SPI_SETKEYBOARDSPEED:
        /*
         * Limit the range to max value; SetKeyboardRate takes both speed and delay
         */
        if (wParam > KSPEED_MASK) {           // KSPEED_MASK == KSPEED_MAX
            wParam = KSPEED_MASK;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_KEYBOARD, STR_KEYSPEED, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            gnKeyboardSpeed = (gnKeyboardSpeed & ~KSPEED_MASK) | wParam;
            SetKeyboardRate(gnKeyboardSpeed);
        }
        break;

    case SPI_GETKEYBOARDDELAY:
        (*(int *)lParam) = (gnKeyboardSpeed & KDELAY_MASK) >> KDELAY_SHIFT;
        break;

    case SPI_SETKEYBOARDDELAY:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_KEYBOARD, STR_KEYDELAY, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            gnKeyboardSpeed = (gnKeyboardSpeed & ~KDELAY_MASK) | (wParam << KDELAY_SHIFT);
            SetKeyboardRate(gnKeyboardSpeed);
        }
        break;

    case SPI_SETLANGTOGGLE:

        /*
         * wParam unused, lParam unused.  Simply reread the registry setting.
         */

        return GetKbdLangSwitch(NULL);

        break;

    case SPI_GETDEFAULTINPUTLANG:
        /*
         * wParam unused.  lParam is a pointer to buffer to store hkl.
         */
        UserAssert(gspklBaseLayout != NULL);
        (*(HKL *)lParam) = gspklBaseLayout->hkl;
        break;

    case SPI_SETDEFAULTINPUTLANG: {
        PKL pkl;
        /*
         * wParam unused.  lParam is new language of hkl (depending on whether the
         * hiword is set.
         */
        pkl = HKLtoPKL(PtiCurrent(), *(HKL *)lParam);
        if (pkl == NULL) {
            return FALSE;
        }
        if (fWriteAllowed) {
            Lock(&gspklBaseLayout, pkl);
        }
        break;
    }

    case SPI_ICONHORIZONTALSPACING:
        if (IS_PTR(lParam)) {
            *(LPINT)lParam = SYSMET(CXICONSPACING);
        } else if (wParam) {

            /*
             * Make sure icon spacing is reasonable.
             */
            wParam = max(wParam, (DWORD)SYSMET(CXICON));

            if (fAlterWinIni) {
                fWinIniChanged = SetWindowMetricInt(NULL, STR_ICONHORZSPACING, wParam );
                fWriteAllowed = fWinIniChanged;
            }
            if (fWriteAllowed) {
                SYSMET(CXICONSPACING) = (UINT)wParam;
            }
        }
        break;

    case SPI_ICONVERTICALSPACING:
        if (IS_PTR(lParam)) {
            *(LPINT)lParam = SYSMET(CYICONSPACING);
        } else if (wParam) {
            wParam = max(wParam, (DWORD)SYSMET(CYICON));

            if (fAlterWinIni) {
                fWinIniChanged = SetWindowMetricInt(NULL, STR_ICONVERTSPACING, wParam);
                fWriteAllowed = fWinIniChanged;
            }
            if (fWriteAllowed) {
                SYSMET(CYICONSPACING) = (UINT)wParam;
            }
        }
        break;

    case SPI_GETSCREENSAVETIMEOUT:
        piTimeOut = &giScreenSaveTimeOutMs;
        goto HandleGetTimeouts;

    case SPI_GETLOWPOWERTIMEOUT:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD1))) {
            return FALSE;
        }
        piTimeOut = &giLowPowerTimeOutMs;
        goto HandleGetTimeouts;

    case SPI_GETPOWEROFFTIMEOUT:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3))) {
            return FALSE;
        }
        piTimeOut = &giPowerOffTimeOutMs;

HandleGetTimeouts:
        /*
         * If the screen saver is disabled, I store this fact as a negative
         * time out value.  So, we give the Control Panel the absolute value
         * of the screen save time out. We store this in milliseconds.
         */
        if (*piTimeOut < 0)
            (*(int *)lParam) = -*piTimeOut / 1000;
        else
            (*(int *)lParam) = *piTimeOut / 1000;
        break;

    case SPI_SETSCREENSAVETIMEOUT:
        piTimeOut = &giScreenSaveTimeOutMs;
        iResID = STR_SCREENSAVETIMEOUT;
        goto HandleSetTimeouts;

    case SPI_SETLOWPOWERTIMEOUT:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD1))) {
            return FALSE;
        }
        piTimeOut = &giLowPowerTimeOutMs;
        iResID = STR_LOWPOWERTIMEOUT;
        goto HandleSetTimeouts;

    case SPI_SETPOWEROFFTIMEOUT:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3))) {
            return FALSE;
        }
        piTimeOut = &giPowerOffTimeOutMs;
        iResID = STR_POWEROFFTIMEOUT;

HandleSetTimeouts:
        if (gfSwitchInProgress) {
            return FALSE;
        }
        /*
         * Maintain the screen save active/inactive state when setting the
         * time out value.  Timeout value is given in seconds but stored
         * in milliseconds
         */
        if (CheckDesktopPolicy(NULL, (PCWSTR)IntToPtr(iResID))) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_DESKTOP, iResID, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
                // Call video driver here to exit power down mode.
//                KdPrint(("Exit video power down mode\n"));
                DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
            }
            glinp.dwFlags &= ~LINP_INPUTTIMEOUTS;
            if (!gbBlockSendInputResets) {
                glinp.timeLastInputMessage = NtGetTickCount();
            }
            if (*piTimeOut < 0) {
                *piTimeOut = -((int)wParam);
            } else {
                *piTimeOut = wParam;
            }
            *piTimeOut *= 1000;
        }
        break;

    case SPI_GETBLOCKSENDINPUTRESETS:
        (*(BOOL *)lParam) = (gbBlockSendInputResets != 0);
        break;
    
    case SPI_GETSCREENSAVEACTIVE:
        (*(BOOL *)lParam) = (giScreenSaveTimeOutMs > 0);
        break;

    case SPI_GETLOWPOWERACTIVE:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD1))) {
            return FALSE;
        }
        (*(BOOL *)lParam) = (giLowPowerTimeOutMs > 0);
        break;

    case SPI_GETPOWEROFFACTIVE:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3))) {
            return FALSE;
        }
        (*(BOOL *)lParam) = (giPowerOffTimeOutMs > 0);
        break;

    case SPI_SETSCREENSAVEACTIVE:
        piTimeOut = &giScreenSaveTimeOutMs;
        iResID = STR_SCREENSAVEACTIVE;
        goto HandleSetActive;

    case SPI_SETLOWPOWERACTIVE:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD1))) {
            return FALSE;
        }
        piTimeOut = &giLowPowerTimeOutMs;
        iResID = STR_LOWPOWERACTIVE;
        goto HandleSetActive;

    case SPI_SETPOWEROFFACTIVE:
        if (!NT_SUCCESS(DrvGetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD3))) {
            return FALSE;
        }
        piTimeOut = &giPowerOffTimeOutMs;
        iResID = STR_POWEROFFACTIVE;

HandleSetActive:
        if (gfSwitchInProgress) {
            return FALSE;
        }

        wParam = (wParam != 0);

        if (CheckDesktopPolicy(NULL, (PCWSTR)IntToPtr(iResID))) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_DESKTOP, iResID, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
                // Call video driver here to exit power down mode.
//                KdPrint(("Exit video power down mode\n"));
                DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
            }
            glinp.dwFlags &= ~LINP_INPUTTIMEOUTS;
            
            if (!gbBlockSendInputResets) {
                glinp.timeLastInputMessage = NtGetTickCount();
            }
            
            if ((*piTimeOut < 0 && wParam) ||
                (*piTimeOut >= 0 && !wParam)) {
                *piTimeOut = -*piTimeOut;
            }
        }
        break;

	case SPI_SETBLOCKSENDINPUTRESETS:
            wParam = (wParam != 0);
            if (CheckDesktopPolicy(NULL, (PCWSTR)IntToPtr(STR_BLOCKSENDINPUTRESETS))) {
                fAlterWinIni = FALSE;
                fWriteAllowed = FALSE;
            }
            if (fAlterWinIni) {
                fWinIniChanged = UpdateWinIniInt(NULL,PMAP_DESKTOP, STR_BLOCKSENDINPUTRESETS, wParam);
                fWriteAllowed = fWinIniChanged;
            }
            if (fWriteAllowed) {
                gbBlockSendInputResets = wParam;
            }
            break;
    
    case SPI_SETDESKWALLPAPER:
        pProfileUserName = CreateProfileUserName(&tlName);
        if (CheckDesktopPolicy(pProfileUserName, (PCWSTR)STR_DTBITMAP)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {

            if (wParam != (WPARAM)-1) {

                /*
                 * Save current wallpaper in case of failure.
                 *
                 * Unlike the rest of per user settings that got updated in xxxUpdatePerUserSystemParameters
                 * Wallpaper is being updated via a direct call to SystemParametersInfo from UpdatePerUserSystemParameters.
                 * Force remote settings check in this case.
                 */
                FastGetProfileStringFromIDW(pProfileUserName,
                       PMAP_DESKTOP,
                       STR_DTBITMAP,
                       TEXT(""),
                       szPat,
                       sizeof(szPat) / sizeof(WCHAR),
                       POLICY_REMOTE);

                fWinIniChanged = FastUpdateWinIni(pProfileUserName,
                       PMAP_DESKTOP,
                       STR_DTBITMAP,
                       (LPWSTR)lParam
                       );

                fWriteAllowed = fWinIniChanged;

            } else {
                fWriteAllowed = TRUE;
            }
        }

        if (fWriteAllowed) {

            if (xxxSetDeskWallpaper(pProfileUserName,(LPWSTR)lParam)) {

                if (grpdeskRitInput) {

                    xxxInternalInvalidate(grpdeskRitInput->pDeskInfo->spwnd,
                                          HRGN_FULL,
                                          RDW_INVALIDATE |
                                              RDW_ERASE |
                                              RDW_FRAME |
                                              RDW_ALLCHILDREN);
                }

            } else if (fAlterWinIni && (wParam != 0xFFFFFFFF)) {

                /*
                 * Backout any change to win.ini.
                 */
                FastUpdateWinIni(pProfileUserName,PMAP_DESKTOP, STR_DTBITMAP, szPat);
                fWinIniChanged = FALSE;
                fWriteAllowed = fWinIniChanged;
            } else if (!fAlterWinIni) {
                /*
                 * Bug 304109 - joejo
                 * Make sure we return a 0 retval if we didn't do anything!
                 */
                fWinIniChanged = FALSE;
                fWriteAllowed = fWinIniChanged;
            }
        }
        FreeProfileUserName(pProfileUserName, &tlName);
        break;

    /*
     * Bug 257718 - joejo
     * Add SPI_GETDESKWALLPAPER to SystemParametersInfo
     */
    case SPI_GETDESKWALLPAPER:
        /*
         * Bug 283318 - jojeo
         *
         * Get the string from the gobal var, not the registry,
         * as it's more current.
         */
        if (gpszWall != NULL) {
            /*
             * Copy the global wallpaper name ONLY if nun null
             */
            wcscpy(lParam, gpszWall);
        } else {
            /*
             * Null out the string so no garbage can corrupt the user's
             * buffer.
             */
            (*(LPWSTR)lParam) = (WCHAR)0;
        }
        break;

    case SPI_SETDESKPATTERN: {
            BOOL fRet;

            if (wParam == -1 && lParam != 0)
                return FALSE;

            pProfileUserName = CreateProfileUserName(&tlName);
            if (CheckDesktopPolicy(pProfileUserName, (PCWSTR)STR_DESKPATTERN)) {
                fAlterWinIni = FALSE;
                fWriteAllowed = FALSE;
            }
            if (fAlterWinIni && wParam != -1) {

                /*
                 * Save the current pattern in case of failure.
                 */
                FastGetProfileStringFromIDW(pProfileUserName,
                        PMAP_DESKTOP,
                        STR_DESKPATTERN,
                        TEXT(""),
                        szPat,
                        sizeof(szPat) / sizeof(WCHAR),
                        0);

                fWinIniChanged = FastUpdateWinIni(pProfileUserName,
                        PMAP_DESKTOP,
                        STR_DESKPATTERN,
                        (LPWSTR)lParam
                        );

                fWriteAllowed = fWinIniChanged;
            }

            if (fWriteAllowed) {

                fRet = xxxSetDeskPattern(pProfileUserName,
                        wParam == -1 ? (LPWSTR)-1 : (LPWSTR)lParam,
                        FALSE);

                if (!fRet) {

                    /*
                     * Back out any change to win.ini
                     */
                    if (fAlterWinIni && wParam != -1) {

                        FastUpdateWinIni(pProfileUserName,
                                PMAP_DESKTOP,
                                STR_DESKPATTERN,
                                szPat
                                );
                    }

                    FreeProfileUserName(pProfileUserName, &tlName);
                    return FALSE;
                }
            }
        }
        FreeProfileUserName(pProfileUserName, &tlName);
        break;

    case SPI_GETICONTITLEWRAP:
        *((int *)lParam) = TEST_BOOL_PUDF(PUDF_ICONTITLEWRAP);
        break;

    case SPI_SETICONTITLEWRAP:
        wParam = (wParam != 0);
        if (fAlterWinIni) {
            fWinIniChanged = SetWindowMetricInt(NULL, STR_ICONTITLEWRAP, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SET_OR_CLEAR_PUDF(PUDF_ICONTITLEWRAP, wParam);
            xxxMetricsRecalc(CALC_FRAME, 0, 0, 0, 0);
        }
        break;

    case SPI_SETDRAGWIDTH:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_DRAGWIDTH)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_DRAGWIDTH, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(CXDRAG) = wParam;
        }
        break;

    case SPI_SETDRAGHEIGHT:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_DRAGHEIGHT)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_DRAGHEIGHT, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(CYDRAG) = wParam;
        }
        break;

    case SPI_GETMENUDROPALIGNMENT:
        (*(int *)lParam) = (SYSMET(MENUDROPALIGNMENT));
        break;

    case SPI_SETMENUDROPALIGNMENT:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_WINDOWSU, STR_MENUDROPALIGNMENT, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(MENUDROPALIGNMENT) = (BOOL)(wParam != 0);
        }
        break;

    case SPI_SETDOUBLECLKWIDTH:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_DOUBLECLICKWIDTH, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(CXDOUBLECLK) = wParam;
        }
        break;

    case SPI_SETDOUBLECLKHEIGHT:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_DOUBLECLICKHEIGHT, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SYSMET(CYDOUBLECLK) = wParam;
        }
        break;

    case SPI_GETICONTITLELOGFONT:
        GreExtGetObjectW(ghIconFont, sizeof(LOGFONTW), lParam);
        break;

    case SPI_SETICONTITLELOGFONT:
    {
        if (lParam != NULL) {
            if (wParam != sizeof(LOGFONTW))
                return FALSE;
        } else if (wParam) {
            return FALSE;
        }

        pProfileUserName = CreateProfileUserName(&tlName);
        fWinIniChanged = xxxSetSPIMetrics(pProfileUserName, wFlag, lParam, fAlterWinIni);
        FreeProfileUserName(pProfileUserName, &tlName);
        if (fAlterWinIni) {
            fWriteAllowed = fWinIniChanged;
        }
        break;
    }

    case SPI_SETDOUBLECLICKTIME:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL,PMAP_MOUSE, STR_DBLCLKSPEED, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            _SetDoubleClickTime((UINT)wParam);
        }
        break;

    case SPI_GETANIMATION: {
        LPANIMATIONINFO lpai = (LPANIMATIONINFO) lParam;

        if (lpai == NULL || (wParam != sizeof(ANIMATIONINFO)))
            return(FALSE);

        lpai->cbSize        = sizeof(ANIMATIONINFO);
        lpai->iMinAnimate   = TEST_BOOL_PUDF(PUDF_ANIMATE);

        break;
    }

    case SPI_GETNONCLIENTMETRICS: {
        LPNONCLIENTMETRICS lpnc = (LPNONCLIENTMETRICS) lParam;
        if (lpnc == NULL)
            return FALSE;

        GetWindowNCMetrics(lpnc);
        break;
    }

    case SPI_GETMINIMIZEDMETRICS: {
        LPMINIMIZEDMETRICS lpmin = (LPMINIMIZEDMETRICS)lParam;

        lpmin->cbSize        = sizeof(MINIMIZEDMETRICS);

            lpmin->iWidth    = SYSMET(CXMINIMIZED) - 2*SYSMET(CXFIXEDFRAME);
            lpmin->iHorzGap  = SYSMET(CXMINSPACING) - SYSMET(CXMINIMIZED);
            lpmin->iVertGap  = SYSMET(CYMINSPACING) - SYSMET(CYMINIMIZED);
            lpmin->iArrange  = SYSMET(ARRANGE);

        break;
    }

    case SPI_GETICONMETRICS: {
        LPICONMETRICS lpicon = (LPICONMETRICS)lParam;

        lpicon->cbSize          = sizeof(ICONMETRICS);

        lpicon->iHorzSpacing    = SYSMET(CXICONSPACING);
        lpicon->iVertSpacing    = SYSMET(CYICONSPACING);
        lpicon->iTitleWrap      = TEST_BOOL_PUDF(PUDF_ICONTITLEWRAP);
        GreExtGetObjectW(ghIconFont, sizeof(LOGFONTW), &(lpicon->lfFont));

        break;
    }

    case SPI_SETANIMATION:
    case SPI_SETNONCLIENTMETRICS:
    case SPI_SETICONMETRICS:
    case SPI_SETMINIMIZEDMETRICS:
    {
        fWinIniChanged = xxxSetSPIMetrics(NULL, wFlag, lParam, fAlterWinIni);
        if (fAlterWinIni) {
            fWriteAllowed = fWinIniChanged;
        }
        ServerLoadString(hModuleWin, STR_METRICS, szSection, ARRAY_SIZE(szSection));
        break;
    }
    case SPI_SETMOUSEBUTTONSWAP:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_SWAPBUTTONS, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            _SwapMouseButton((wParam != 0));
        }
        break;

    case SPI_GETFASTTASKSWITCH:
        *((PINT)lParam) = TRUE;    // do the work so we don't anger anybody

    case SPI_SETFASTTASKSWITCH:
        RIPMSG0(RIP_WARNING,"SPI_SETFASTTASKSWITCH and SPI_GETFASTTASKSWITCH are obsolete actions.");
        break;

    case SPI_GETWORKAREA:
        CopyRect((LPRECT)lParam, &GetPrimaryMonitor()->rcWork);
        break;

    case SPI_SETWORKAREA:
    {
        RECT        rcNewWork;
        LPRECT      lprcNewWork;
        PMONITOR    pMonitorWork;


        lprcNewWork = (LPRECT)lParam;

        /*
         * Validate Rectangle
         */
        if ((lprcNewWork != NULL) &&
            ((lprcNewWork->right < lprcNewWork->left) ||
             (lprcNewWork->bottom < lprcNewWork->top))) {

            RIPMSG0(RIP_WARNING, "Bad work rectangle passed to SystemParametersInfo(SPI_SETWORKAREA, ...)\n");
            return FALSE;
        }

        /*
         * Figure out which monitor has the working area.
         */
        if (!lprcNewWork) {
            pMonitorWork = GetPrimaryMonitor();
            lprcNewWork = &pMonitorWork->rcMonitor;
        } else {
            pMonitorWork = _MonitorFromRect(lprcNewWork, MONITOR_DEFAULTTOPRIMARY);
        }


        /*
         * Get new working area, clipped to monitor of course.
         */
        if (!IntersectRect(&rcNewWork, lprcNewWork, &pMonitorWork->rcMonitor) ||
            !EqualRect(&rcNewWork, lprcNewWork))
        {
            /*
             * Complain.
             */
            RIPERR4(
                    ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Bad work rectangle passed to SystemParametersInfo(SPI_SETWORKAREA, ...) %d, %d, %d, %d",
                    lprcNewWork->left, lprcNewWork->top, lprcNewWork->right, lprcNewWork->bottom);
            return FALSE;
        }

        if (!EqualRect(&pMonitorWork->rcWork, &rcNewWork))
        {
            PMONITORRECTS   pmr;

            /*
             * If we are going to reposition windows, remember the old
             * monitor positions for xxxDesktopRecalc.
             */
            if (wParam) {
                pmr = SnapshotMonitorRects();
                if (!pmr) {
                    return FALSE;
                }
            }

            pMonitorWork->rcWork = rcNewWork;
            if (pMonitorWork == GetPrimaryMonitor()) {
                SetDesktopMetrics();
            }

            /*
             * Reposition windows
             */

            if (wParam) {

                TL tlPool;

                ThreadLockPool(PtiCurrent(), pmr, &tlPool);
                xxxDesktopRecalc(pmr);
                ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);
            }

            fWinIniChanged = TRUE;
        }

        fWriteAllowed = TRUE;
        break;
    }

    case SPI_SETDRAGFULLWINDOWS:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_DRAGFULLWINDOWS)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        wParam = (wParam == 1);
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_DRAGFULLWINDOWS, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SET_OR_CLEAR_PUDF(PUDF_DRAGFULLWINDOWS, wParam);
        }
        break;

    case SPI_GETDRAGFULLWINDOWS:
        *((PINT)lParam) = TEST_BOOL_PUDF(PUDF_DRAGFULLWINDOWS);
        break;

    case SPI_GETFILTERKEYS:
        {
            LPFILTERKEYS pFK = (LPFILTERKEYS)lParam;
            int cbSkip = sizeof(gFilterKeys.cbSize);

            if ((wParam != 0) && (wParam != sizeof(FILTERKEYS))) {
                return FALSE;
            }
            if (!pFK || (pFK->cbSize != sizeof(FILTERKEYS))) {
                return FALSE;
            }
            /*
             * In the future we may support multiple sizes of this data structure.  Don't
             * change the cbSize field of the data structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pFK + cbSkip),
                          (LPVOID)((LPBYTE)&gFilterKeys + cbSkip),
                          pFK->cbSize - cbSkip);
        }
        break;

    case SPI_SETFILTERKEYS:
        {
            LPFILTERKEYS pFK = (LPFILTERKEYS)lParam;

            if ((wParam != 0) && (wParam != sizeof(FILTERKEYS))) {
                return FALSE;
            }
            if (!pFK || (pFK->cbSize != sizeof(FILTERKEYS)))
                return FALSE;

            /*
             * SlowKeys and BounceKeys cannot both be active simultaneously
             */
            if (pFK->iWaitMSec && pFK->iBounceMSec) {
                return FALSE;
            }

            /*
             * Do some parameter validation.  We will fail on unsupported and
             * undefined bits being set.
             */
            if ((pFK->dwFlags & FKF_VALID) != pFK->dwFlags) {
                return FALSE;
            }
            /*
             * FKF_AVAILABLE can't be set via API.  Use registry value.
             */
            if (TEST_ACCESSFLAG(FilterKeys, FKF_AVAILABLE)) {
                pFK->dwFlags |= FKF_AVAILABLE;
            } else {
                pFK->dwFlags &= ~FKF_AVAILABLE;
            }
            if ((pFK->iWaitMSec > 20000) ||
                (pFK->iDelayMSec > 20000) ||
                (pFK->iRepeatMSec > 20000) ||
                (pFK->iBounceMSec > 20000)) {
                return FALSE;
            }

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                fWinIniChanged = SetFilterKeys(pProfileUserName, pFK);
                fWriteAllowed = fWinIniChanged;
                if (!fWinIniChanged) {

                    /*
                     * Back out any changes to win.ini
                     */
                    SetFilterKeys(pProfileUserName, &gFilterKeys);
                }
                FreeProfileUserName(pProfileUserName, &tlName);
            }
            if (fWriteAllowed) {
                RtlCopyMemory(&gFilterKeys, pFK, pFK->cbSize);

                /*
                 * Don't allow user to change cbSize field
                 */
                gFilterKeys.cbSize = sizeof(FILTERKEYS);

                if (!TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)) {
                    StopFilterKeysTimers();
                }
                SetAccessEnabledFlag();
                if (FCallHookTray())
                    xxxCallHook(HSHELL_ACCESSIBILITYSTATE,
                                ACCESS_FILTERKEYS,
                                (LONG)0,
                                WH_SHELL);
                PostShellHookMessages(HSHELL_ACCESSIBILITYSTATE, ACCESS_FILTERKEYS);
            }
        }
        break;

    case SPI_GETSTICKYKEYS:
        {
            LPSTICKYKEYS pSK = (LPSTICKYKEYS)lParam;
            int cbSkip = sizeof(gStickyKeys.cbSize);

            if ((wParam != 0) && (wParam != sizeof(STICKYKEYS))) {
                return FALSE;
            }
            if (!pSK || (pSK->cbSize != sizeof(STICKYKEYS))) {
                return FALSE;
            }
            /*
             * In the future we may support multiple sizes of this data structure.  Don't
             * change the cbSize field of the data structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pSK + cbSkip),
                          (LPVOID)((LPBYTE)&gStickyKeys + cbSkip),
                          pSK->cbSize - cbSkip);

            pSK->dwFlags &= ~SKF_STATEINFO;
            pSK->dwFlags |= (gLatchBits&0xff) <<24;

#if SKF_LALTLATCHED != 0x10000000
#error SKF_LALTLATCHED value is incorrect
#endif
#if SKF_LCTLLATCHED != 0x04000000
#error SKF_LCTLLATCHED value is incorrect
#endif
#if SKF_LSHIFTLATCHED != 0x01000000
#error SKF_LSHIFTLATCHED value is incorrect
#endif
#if SKF_RALTLATCHED  !=  0x20000000
#error SKF_RALTLATCHED value is incorrect
#endif
#if  SKF_RCTLLATCHED != 0x08000000
#error SKF_RCTLLATCHED value is incorrect
#endif
#if SKF_RSHIFTLATCHED != 0x02000000
#error SKF_RSHIFTLATCHED value is incorrect
#endif
            pSK->dwFlags |= (gLockBits&0xff) <<16;
#if SKF_LALTLOCKED != 0x00100000
#error SKF_LALTLOCKED value is incorrect
#endif
#if SKF_LCTLLOCKED != 0x00040000
#error SKF_LCTLLOCKED value is incorrect
#endif
#if SKF_LSHIFTLOCKED != 0x00010000
#error SKF_LSHIFTLOCKED value is incorrect
#endif
#if SKF_RALTLOCKED  != 0x00200000
#error SKF_RALTLOCKED value is incorrect
#endif
#if SKF_RCTLLOCKED != 0x00080000
#error SKF_RCTLLOCKED value is incorrect
#endif
#if SKF_RSHIFTLOCKED != 0x00020000
#error SKF_RSHIFTLOCKED value is incorrect
#endif

        }

        break;

    case SPI_SETSTICKYKEYS:
        {
            LPSTICKYKEYS pSK = (LPSTICKYKEYS)lParam;
            BOOL fWasOn;

            fWasOn = TEST_BOOL_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
            if ((wParam != 0) && (wParam != sizeof(STICKYKEYS))) {
                return FALSE;
            }
            if (!pSK || (pSK->cbSize != sizeof(STICKYKEYS)))
                return FALSE;

            pSK->dwFlags &= ~SKF_STATEINFO;  /* Don't penalize them for using
                                              * data from SPI_GETSTICKYKEYS.
                                              */

            /*
             * Do some parameter validation.  We will fail on unsupported and
             * undefined bits being set.
             */
            if ((pSK->dwFlags & SKF_VALID) != pSK->dwFlags) {
                return FALSE;
            }
            /*
             * SKF_AVAILABLE can't be set via API.  Use registry value.
             */
            if (TEST_ACCESSFLAG(StickyKeys, SKF_AVAILABLE)) {
                pSK->dwFlags |= SKF_AVAILABLE;
            } else {
                pSK->dwFlags &= ~SKF_AVAILABLE;
            }

            if (fAlterWinIni) {
                swprintf(szTemp, pwszd, pSK->dwFlags);
                fWinIniChanged = FastWriteProfileStringW(NULL,
                        PMAP_STICKYKEYS,
                        L"Flags",
                        szTemp
                        );
                fWriteAllowed = fWinIniChanged;
            }
            if (fWriteAllowed) {
                RtlCopyMemory(&gStickyKeys, pSK, pSK->cbSize);

                /*
                 * Don't allow user to change cbSize field
                 */
                gStickyKeys.cbSize = sizeof(STICKYKEYS);
                if (!TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) && fWasOn) {
                    xxxTurnOffStickyKeys();
                }

                SetAccessEnabledFlag();
                if (FCallHookTray())
                    xxxCallHook(HSHELL_ACCESSIBILITYSTATE,
                                ACCESS_STICKYKEYS,
                                (LONG)0,
                                WH_SHELL);
                PostShellHookMessages(HSHELL_ACCESSIBILITYSTATE, ACCESS_STICKYKEYS);
            }
        }
        break;

    case SPI_GETTOGGLEKEYS:
        {
            LPTOGGLEKEYS pTK = (LPTOGGLEKEYS)lParam;
            int cbSkip = sizeof(gToggleKeys.cbSize);

            if ((wParam != 0) && (wParam != sizeof(TOGGLEKEYS))) {
                return FALSE;
            }
            if (!pTK || (pTK->cbSize != sizeof(TOGGLEKEYS))) {
                return FALSE;
            }
            /*
             * In the future we may support multiple sizes of this data structure.  Don't
             * change the cbSize field of the data structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pTK + cbSkip),
                          (LPVOID)((LPBYTE)&gToggleKeys + cbSkip),
                          pTK->cbSize - cbSkip);
        }
        break;

    case SPI_SETTOGGLEKEYS:
        {
            LPTOGGLEKEYS pTK = (LPTOGGLEKEYS)lParam;

            if ((wParam != 0) && (wParam != sizeof(TOGGLEKEYS))) {
                return FALSE;
            }
            if (!pTK || (pTK->cbSize != sizeof(TOGGLEKEYS)))
                return FALSE;

            /*
             * Do some parameter validation.  We will fail on unsupported and
             * undefined bits being set.
             */
            if ((pTK->dwFlags & TKF_VALID) != pTK->dwFlags) {
                return FALSE;
            }
            /*
             * TKF_AVAILABLE can't be set via API.  Use registry value.
             */
            if (TEST_ACCESSFLAG(ToggleKeys, TKF_AVAILABLE)) {
                pTK->dwFlags |= TKF_AVAILABLE;
            } else {
                pTK->dwFlags &= ~TKF_AVAILABLE;
            }

            if (fAlterWinIni) {
                swprintf(szTemp, pwszd, pTK->dwFlags);
                fWinIniChanged = FastWriteProfileStringW(NULL,
                        PMAP_TOGGLEKEYS,
                        L"Flags",
                        szTemp
                        );
                fWriteAllowed = fWinIniChanged;
            }
            if (fWriteAllowed) {
                RtlCopyMemory(&gToggleKeys, pTK, pTK->cbSize);

                /*
                 * Don't allow user to change cbSize field
                 */
                gToggleKeys.cbSize = sizeof(TOGGLEKEYS);

                SetAccessEnabledFlag();
            }
        }
        break;

    case SPI_GETMOUSEKEYS:
        {
            LPMOUSEKEYS pMK = (LPMOUSEKEYS)lParam;
            int cbSkip = sizeof(gMouseKeys.cbSize);

            if ((wParam != 0) && (wParam != sizeof(MOUSEKEYS))) {
                return FALSE;
            }
            if (!pMK || (pMK->cbSize != sizeof(MOUSEKEYS))) {
                return FALSE;
            }
            /*
             * In the future we may support multiple sizes of this data structure.  Don't
             * change the cbSize field of the data structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pMK + cbSkip),
                          (LPVOID)((LPBYTE)&gMouseKeys + cbSkip),
                          pMK->cbSize - cbSkip);


            pMK->dwFlags &= ~MKF_STATEINFO;

            if (gbMKMouseMode) pMK->dwFlags |= MKF_MOUSEMODE;

            pMK->dwFlags |= (gwMKButtonState & 3) << 24;
#if MOUSE_BUTTON_LEFT != 0x01
#error MOUSE_BUTTON_LEFT value is incorrect
#endif
#if MOUSE_BUTTON_RIGHT != 0x02
#error MOUSE_BUTTON_RIGHT value is incorrect
#endif
#if MKF_LEFTBUTTONDOWN != 0x01000000
#error MKF_LEFTBUTTONDOWN value is incorrect
#endif
#if MKF_RIGHTBUTTONDOWN != 0x02000000
#error MKF_RIGHTBUTTONDOWN value is incorrect
#endif

            pMK->dwFlags |= (gwMKCurrentButton & 3)<< 28;
#if MKF_LEFTBUTTONSEL != 0x10000000
#error MKF_LEFTBUTTONSEL value is incorrect
#endif
#if MKF_RIGHTBUTTONSEL != 0x20000000
#error MKF_RIGHTBUTTONSEL value is incorrect
#endif
        }
        break;

    case SPI_SETMOUSEKEYS: {
            LPMOUSEKEYS pMK = (LPMOUSEKEYS)lParam;

            if ((wParam != 0) && (wParam != sizeof(MOUSEKEYS))) {
                return FALSE;
            }
            if (!pMK || (pMK->cbSize != sizeof(MOUSEKEYS)))
                return FALSE;

            /*
             * Do some parameter validation.  We will fail on unsupported and
             * undefined bits being set.
             */
            pMK->dwFlags &= ~MKF_STATEINFO;  /* Don't penalize them for using
                                              * data from SPI_GETMOUSEKEYS.
                                              */

            if ((pMK->dwFlags & MKF_VALID) != pMK->dwFlags) {
                return FALSE;
            }
            /*
             * MKF_AVAILABLE can't be set via API.  Use registry value.
             */
            if (TEST_ACCESSFLAG(MouseKeys, MKF_AVAILABLE)) {
                pMK->dwFlags |= MKF_AVAILABLE;
            } else {
                pMK->dwFlags &= ~MKF_AVAILABLE;
            }
            if ((pMK->iMaxSpeed < MAXSPEED_MIN) || (pMK->iMaxSpeed > MAXSPEED_MAX)) {
                return FALSE;
            }
            if ((pMK->iTimeToMaxSpeed < TIMETOMAXSPEED_MIN) || (pMK->iTimeToMaxSpeed > TIMETOMAXSPEED_MAX)) {
                return FALSE;
            }

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                fWinIniChanged = SetMouseKeys(pProfileUserName, pMK);
                fWriteAllowed = fWinIniChanged;
                if (!fWinIniChanged) {

                    /*
                     * Back out any changes to win.ini
                     */
                    SetMouseKeys(pProfileUserName, &gMouseKeys);
                }
                FreeProfileUserName(pProfileUserName, &tlName);
            }
            if (fWriteAllowed) {
                RtlCopyMemory(&gMouseKeys, pMK, pMK->cbSize);

                /*
                 * Don't allow user to change cbSize field
                 */
                gMouseKeys.cbSize = sizeof(MOUSEKEYS);

                CalculateMouseTable();

                if (TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
                    if ((TestAsyncKeyStateToggle(gNumLockVk) != 0) ^
                        (TEST_ACCESSFLAG(MouseKeys, MKF_REPLACENUMBERS) != 0))
                        gbMKMouseMode = TRUE;
                    else
                        gbMKMouseMode = FALSE;
                    MKShowMouseCursor();
                } else {
                    MKHideMouseCursor();
                }

                SetAccessEnabledFlag();

                if (FCallHookTray())
                    xxxCallHook(HSHELL_ACCESSIBILITYSTATE,
                                ACCESS_MOUSEKEYS,
                                (LONG)0,
                                WH_SHELL);
                PostShellHookMessages(HSHELL_ACCESSIBILITYSTATE, ACCESS_MOUSEKEYS);
            }
        }
        break;

    case SPI_GETHIGHCONTRAST:
        {
            LPHIGHCONTRAST pHC = (LPHIGHCONTRAST)lParam;

            /*
             * In the future we may support multiple sizes of this data structure.  Don't
             * change the cbSize field of the data structure passed in.
             */

            pHC->dwFlags = gHighContrast.dwFlags;

            /*
             * A hostile app could deallocate the memory using a second thread,
             * so shelter the copy with a try.
             */
            try {
                RtlCopyMemory(pHC->lpszDefaultScheme, gHighContrastDefaultScheme, MAX_SCHEME_NAME_SIZE * sizeof(WCHAR));
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            }
        }

        break;

    case SPI_SETHIGHCONTRAST:
        {
            LPINTERNALSETHIGHCONTRAST pHC = (LPINTERNALSETHIGHCONTRAST)lParam;
            WCHAR wcDefaultScheme[MAX_SCHEME_NAME_SIZE];

            if (pHC->usDefaultScheme.Length >= MAX_SCHEME_NAME_SIZE*sizeof(WCHAR) )
                return FALSE;

            if (pHC->usDefaultScheme.Buffer) {
                /*
                 * Only set the scheme if the user specifies a scheme.  An empty
                 * buffer is ignored.  We do the copy here so that we don't need to
                 * put a try/except around the WriteProfileString code.
                 */

                try {
                    RtlCopyMemory(wcDefaultScheme, pHC->usDefaultScheme.Buffer, pHC->usDefaultScheme.Length);
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    return FALSE;
                }
            }
            wcDefaultScheme[pHC->usDefaultScheme.Length / sizeof(WCHAR)] = 0;

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                swprintf(szTemp, pwszd, pHC->dwFlags);
                fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                        PMAP_HIGHCONTRAST,
                        L"Flags",
                        szTemp
                        );

                fWriteAllowed = fWinIniChanged;
                /*
                 * Note -- we do not write anything if there is no default scheme
                 * from the app.  This is consistent with Win95/Win98 behavior.
                 */

                if (pHC->usDefaultScheme.Buffer) {
                    fWinIniChanged |= FastWriteProfileStringW(pProfileUserName,
                        PMAP_HIGHCONTRAST,
                        TEXT("High Contrast Scheme"),
                        wcDefaultScheme
                        );
                }
                FreeProfileUserName(pProfileUserName, &tlName);

            }
            if (fWriteAllowed) {
                DWORD dwFlagsOld = gHighContrast.dwFlags;
                LPARAM lp = fAlterWinIni?0:ACCESS_HIGHCONTRASTNOREG;

#if (ACCESS_HIGHCONTRASTNOREG | ACCESS_HIGHCONTRASTOFF) != ACCESS_HIGHCONTRASTOFFNOREG
#error ACCESS_HIGHCONTRASTOFF value is incorrect
#endif
#if (ACCESS_HIGHCONTRASTNOREG | ACCESS_HIGHCONTRASTON) != ACCESS_HIGHCONTRASTONNOREG
#error ACCESS_HIGHCONTRASTON value is incorrect
#endif
#if (ACCESS_HIGHCONTRASTNOREG | ACCESS_HIGHCONTRASTCHANGE) != ACCESS_HIGHCONTRASTCHANGENOREG
#error ACCESS_HIGHCONTRASTCHANGE value is incorrect
#endif

                /*
                 * If a NULL is specified in the lpszDefaultScheme, then it is
                 * not changed.  This is consistent with Win95/Win98 behavior.
                 */

                if (pHC->usDefaultScheme.Buffer)
                    wcscpy(gHighContrastDefaultScheme, wcDefaultScheme);

                gHighContrast.dwFlags = pHC->dwFlags;

                SetAccessEnabledFlag();

                /*
                 * now, post message to turn high contrast on or off
                 */

                if (pHC->dwFlags & HCF_HIGHCONTRASTON) {
                    _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, LOGON_ACCESSNOTIFY,
                        (dwFlagsOld & HCF_HIGHCONTRASTON)? (ACCESS_HIGHCONTRASTCHANGE | lp):
                                                           (ACCESS_HIGHCONTRASTON | lp));
                } else {
                    _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, LOGON_ACCESSNOTIFY, ACCESS_HIGHCONTRASTOFF | lp);
                }

            }
        break;
        }

    case SPI_GETACCESSTIMEOUT:
        {
            LPACCESSTIMEOUT pTO = (LPACCESSTIMEOUT)lParam;
            int cbSkip = sizeof(gAccessTimeOut.cbSize);

            if ((wParam != 0) && (wParam != sizeof(ACCESSTIMEOUT))) {
                return FALSE;
            }
            if (!pTO || (pTO->cbSize != sizeof(ACCESSTIMEOUT))) {
                return FALSE;
            }
            /*
             * In the future we may support multiple sizes of this data structure.  Don't
             * change the cbSize field of the data structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pTO + cbSkip),
                          (LPVOID)((LPBYTE)&gAccessTimeOut + cbSkip),
                          pTO->cbSize - cbSkip);
        }
        break;

    case SPI_SETACCESSTIMEOUT:
        {
            LPACCESSTIMEOUT pTO = (LPACCESSTIMEOUT)lParam;

            if ((wParam != 0) && (wParam != sizeof(ACCESSTIMEOUT))) {
                return FALSE;
            }
            if (!pTO || (pTO->cbSize != sizeof(ACCESSTIMEOUT)))
                return FALSE;

            /*
             * Do some parameter validation.  We will fail on unsupported and
             * undefined bits being set.
             */
            if ((pTO->dwFlags & ATF_VALID) != pTO->dwFlags) {
                return FALSE;
            }
            if (pTO->iTimeOutMSec > 3600000) {
                return FALSE;
            }

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                swprintf(szTemp, pwszd, pTO->dwFlags);
                fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                        PMAP_TIMEOUT,
                        L"Flags",
                        szTemp
                        );

                swprintf(szTemp, pwszd, pTO->iTimeOutMSec);
                fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                        PMAP_TIMEOUT,
                        L"TimeToWait",
                        szTemp
                        );

                fWriteAllowed = fWinIniChanged;
                if (!fWinIniChanged) {

                    /*
                     * Back out any changes to win.ini
                     */
                    swprintf(szTemp, pwszd, gAccessTimeOut.dwFlags);
                    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                            PMAP_TIMEOUT,
                            L"Flags",
                            szTemp
                            );

                    swprintf(szTemp, pwszd, gAccessTimeOut.iTimeOutMSec);
                    fWinIniChanged = FastWriteProfileStringW(pProfileUserName,
                            PMAP_TIMEOUT,
                            L"TimeToWait",
                            szTemp
                            );
                }
                FreeProfileUserName(pProfileUserName, &tlName);
            }
            if (fWriteAllowed) {
                RtlCopyMemory(&gAccessTimeOut, pTO, pTO->cbSize);

                /*
                 * Don't allow user to change cbSize field
                 */
                gAccessTimeOut.cbSize = sizeof(ACCESSTIMEOUT);

                SetAccessEnabledFlag();

                AccessTimeOutReset();
            }
        }
        break;

    case SPI_SETSHOWSOUNDS:
        if (fAlterWinIni) {
            swprintf(szTemp, pwszd, (wParam == 1));
            fWinIniChanged = FastWriteProfileStringW(NULL,
                    PMAP_SHOWSOUNDS,
                    L"On",
                    szTemp
                    );

            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            SET_OR_CLEAR_ACCF(ACCF_SHOWSOUNDSON, wParam == 1);
            SetAccessEnabledFlag();

            /*
            * Bug 2079.  Update the System Metrics Info.
            */
            SYSMET(SHOWSOUNDS) = TEST_BOOL_ACCF(ACCF_SHOWSOUNDSON);
        }
        break;

    case SPI_GETSHOWSOUNDS: {
            PINT pint = (int *)lParam;

            *pint = TEST_BOOL_ACCF(ACCF_SHOWSOUNDSON);
        }
        break;

    case SPI_GETKEYBOARDPREF:
        {
            PBOOL pfKeyboardPref = (PBOOL)lParam;

            *pfKeyboardPref = TEST_BOOL_ACCF(ACCF_KEYBOARDPREF);
        }
        break;

    case SPI_SETKEYBOARDPREF:
        {
            BOOL fKeyboardPref = (BOOL)wParam;

            if (fAlterWinIni) {
                fWinIniChanged = FastWriteProfileStringW(NULL,
                        PMAP_KEYBOARDPREF,
                        L"On",
                        (fKeyboardPref) ? L"1" : L"0"
                        );

                fWriteAllowed = fWinIniChanged;
            }
            if (fWriteAllowed)
            {
                SET_OR_CLEAR_ACCF(ACCF_KEYBOARDPREF, wParam);
            }
        }
        break;

    case SPI_GETSCREENREADER:
        {
            PBOOL pfScreenReader = (PBOOL)lParam;

            *pfScreenReader = TEST_BOOL_ACCF(ACCF_SCREENREADER);
        }
        break;

    case SPI_SETSCREENREADER:
        {
            BOOL fScreenReader = (BOOL)wParam;

            if (fAlterWinIni) {
                fWinIniChanged = FastWriteProfileStringW(NULL,
                    PMAP_SCREENREADER,
                    L"On",
                    (fScreenReader) ? L"1" : L"0"
                    );
                fWriteAllowed = fWinIniChanged;
            }
            if (fWriteAllowed)
            {
                SET_OR_CLEAR_ACCF(ACCF_SCREENREADER, wParam);
            }
        }
        break;

    case SPI_GETSOUNDSENTRY:
        {
            LPSOUNDSENTRY pSS = (LPSOUNDSENTRY)lParam;
            int cbSkip = sizeof(gSoundSentry.cbSize);

            if ((wParam != 0) && (wParam != sizeof(SOUNDSENTRY))) {
                return FALSE;
            }
            if (!pSS || (pSS->cbSize != sizeof(SOUNDSENTRY))) {
                return FALSE;
            }
            /*
             * In the future we may support multiple sizes of this data structure.  Don't
             * change the cbSize field of the data structure passed in.
             */
            RtlCopyMemory((LPVOID)((LPBYTE)pSS + cbSkip),
                          (LPVOID)((LPBYTE)&gSoundSentry + cbSkip),
                          pSS->cbSize - cbSkip);
        }
        break;

    case SPI_SETSOUNDSENTRY:
        {
            LPSOUNDSENTRY pSS = (LPSOUNDSENTRY)lParam;

            if ((wParam != 0) && (wParam != sizeof(SOUNDSENTRY))) {
                return FALSE;
            }
            if (!pSS || (pSS->cbSize != sizeof(SOUNDSENTRY)))
                return FALSE;

            /*
             * Do some parameter validation.  We will fail on unsupported and
             * undefined bits being set.
             */
            if ((pSS->dwFlags & SSF_VALID) != pSS->dwFlags) {
                return FALSE;
            }
            /*
             * We don't support SSWF_CUSTOM.
             */
            if (pSS->iWindowsEffect > SSWF_DISPLAY) {
                return FALSE;
            }
            /*
             * No support for non-windows apps.
             */
            if (pSS->iFSTextEffect != SSTF_NONE) {
                return FALSE;
            }
            if (pSS->iFSGrafEffect != SSGF_NONE) {
                return FALSE;
            }
            /*
             * SSF_AVAILABLE can't be set via API.  Use registry value.
             */
            if (TEST_ACCESSFLAG(SoundSentry, SSF_AVAILABLE)) {
                pSS->dwFlags |= SSF_AVAILABLE;
            } else {
                pSS->dwFlags &= ~SSF_AVAILABLE;
            }

            if (fAlterWinIni) {
                pProfileUserName = CreateProfileUserName(&tlName);
                fWinIniChanged = SetSoundSentry(pProfileUserName, pSS);
                fWriteAllowed = fWinIniChanged;
                if (!fWinIniChanged) {

                    /*
                     * Back out any changes to win.ini
                     */
                    SetSoundSentry(pProfileUserName, &gSoundSentry);
                }
                FreeProfileUserName(pProfileUserName, &tlName);
            }
            if (fWriteAllowed) {
                RtlCopyMemory(&gSoundSentry, pSS, pSS->cbSize);

                /*
                 * Don't allow user to change cbSize field
                 */
                gSoundSentry.cbSize = sizeof(SOUNDSENTRY);

                SetAccessEnabledFlag();
            }
        }
        break;

    case SPI_SETCURSORS:
            pProfileUserName = CreateProfileUserName(&tlName);
            xxxUpdateSystemCursorsFromRegistry(pProfileUserName);
            FreeProfileUserName(pProfileUserName, &tlName);

            break;

    case SPI_SETICONS:
            pProfileUserName = CreateProfileUserName(&tlName);
            xxxUpdateSystemIconsFromRegistry(pProfileUserName);
            FreeProfileUserName(pProfileUserName, &tlName);

            break;

    case SPI_GETMOUSEHOVERWIDTH:
        *((UINT *)lParam) = gcxMouseHover;
        break;

    case SPI_SETMOUSEHOVERWIDTH:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_MOUSEHOVERWIDTH, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            gcxMouseHover = wParam;
        }
        break;

    case SPI_GETMOUSEHOVERHEIGHT:
        *((UINT *)lParam) = gcyMouseHover;
        break;

    case SPI_SETMOUSEHOVERHEIGHT:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_MOUSEHOVERHEIGHT, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            gcyMouseHover = wParam;
        }
        break;

    case SPI_GETMOUSEHOVERTIME:
        *((UINT *)lParam) = gdtMouseHover;
        break;

    case SPI_SETMOUSEHOVERTIME:
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_MOUSE, STR_MOUSEHOVERTIME, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed) {
            gdtMouseHover = wParam;
        }
        break;

    case SPI_GETWHEELSCROLLLINES:
        (*(LPDWORD)lParam) = gpsi->ucWheelScrollLines;
        break;

    case SPI_SETWHEELSCROLLLINES:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_WHEELSCROLLLINES)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_WHEELSCROLLLINES, wParam);
            fWriteAllowed = fWinIniChanged;
        }

        if (fWriteAllowed)
            gpsi->ucWheelScrollLines = (UINT)wParam;
        break;

    case SPI_GETMENUSHOWDELAY:
        (*(LPDWORD)lParam) = gdtMNDropDown;
        break;

    case SPI_SETMENUSHOWDELAY:
        if (CheckDesktopPolicy(NULL, (PCWSTR)STR_MENUSHOWDELAY)) {
            fAlterWinIni = FALSE;
            fWriteAllowed = FALSE;
        }
        if (fAlterWinIni) {
            fWinIniChanged = UpdateWinIniInt(NULL, PMAP_DESKTOP, STR_MENUSHOWDELAY, wParam);
            fWriteAllowed = fWinIniChanged;
        }
        if (fWriteAllowed)
            gdtMNDropDown = wParam;
        break;

    case SPI_GETSCREENSAVERRUNNING:
        (*(LPBOOL)lParam) = gppiScreenSaver != NULL;
        break;

    case SPI_SETSHOWIMEUI:
        return xxxSetIMEShowStatus(!!wParam);

    case SPI_GETSHOWIMEUI:
        (*(LPBOOL)lParam) = _GetIMEShowStatus();
        break;

    default:

#define ppvi (UPDWORDPointer(wFlag))
#define uDataRead ((UINT)fWinIniChanged)

        if (wFlag < SPI_MAX) {
            RIPERR1(ERROR_INVALID_SPI_VALUE, RIP_WARNING, "xxxSystemParamtersInfo: Invalid SPI_:%#lx", wFlag);
            return FALSE;
        }

        UserAssert(wFlag & SPIF_RANGETYPEMASK);

        if (!(wFlag & SPIF_SET)) {

            if ((wFlag & SPIF_RANGETYPEMASK) == SPIF_BOOL) {
                BOOL fDisable, fDisableValue;

                UserAssert(UPIsBOOLRange(wFlag));
                /*
                 * Handle settings that can be disabled by additional conditions.
                 */
                fDisable = fDisableValue = FALSE;
                if (wFlag < SPI_GETUIEFFECTS) {
                    if (!TestUP(UIEFFECTS)) {
                        switch (wFlag) {
                        case SPI_GETACTIVEWNDTRKZORDER:
                        case SPI_GETACTIVEWINDOWTRACKING:
#ifdef MOUSE_IP
                        case SPI_GETMOUSESONAR:
#endif
                        case SPI_GETMOUSECLICKLOCK:
                            break;

                        case SPI_GETKEYBOARDCUES:
                            fDisableValue = TRUE;
                            /* Fall Through */

                        default:
                            fDisable = TRUE;
                            break;
                        }
                    } else { /* if (!TestUP(UIEFFECTS) */
                        switch (wFlag) {
                        case SPI_GETKEYBOARDCUES:
                            if (TEST_BOOL_ACCF(ACCF_KEYBOARDPREF)) {
                                fDisableValue = TRUE;
                                fDisable = TRUE;
                            }
                            break;

                        case SPI_GETGRADIENTCAPTIONS:
                        case SPI_GETSELECTIONFADE:
                        case SPI_GETMENUFADE:
                        case SPI_GETTOOLTIPFADE:
                        case SPI_GETCURSORSHADOW:
                            if (gbDisableAlpha) {
                                fDisable = TRUE;
                            }
                            break;
                        }
                    }
                } /* if (wFlag < SPI_GETUIEFFECTS) */
                /*
                 * Give them the disabled value or read the actual one
                 */
                if (fDisable) {
                    *((BOOL *)lParam) = fDisableValue;
                } else {
                    *((BOOL *)lParam) = !!TestUPBOOL(gpdwCPUserPreferencesMask, wFlag);
                }
            } else {
                UserAssert(UPIsDWORDRange(wFlag));
                *((DWORD *)lParam) = UPDWORDValue(wFlag);
                switch(wFlag)
                {
                    case SPI_GETFONTSMOOTHINGCONTRAST:
                        /* if the contrast value was never set by the user, we will return the default value from the display driver */
                        if (*((DWORD *)lParam) == 0)
                            *((DWORD *)lParam) = GreGetFontContrast();
                        break;
                    default:
                        break;
                }
            }

        } else { /* if (!(wFlag & SPIF_SET)) */
            pProfileUserName = CreateProfileUserName(&tlName);

            if ((wFlag & SPIF_RANGETYPEMASK) == SPIF_BOOL) {
                DWORD pdwValue [SPI_BOOLMASKDWORDSIZE];

                UserAssert(UPIsBOOLRange(wFlag));
                UserAssert(sizeof(pdwValue) == sizeof(gpdwCPUserPreferencesMask));

                if (gpviCPUserPreferences->uSection == PMAP_DESKTOP) {
                    if (CheckDesktopPolicy(pProfileUserName, gpviCPUserPreferences->pwszKeyName)) {
                        fAlterWinIni = FALSE;
                        fWriteAllowed = FALSE;
                    }
                }
                if (fAlterWinIni) {
                    /*
                     * We only need to set/clear the bit passed in, however, we write the whole
                     *  bit mask to the registry. Since the info in gpdwCPUserPreferencesMask
                     *  might not match what it is in the registry, we need to read the registry before
                     *  we write to it.
                     */
                    uDataRead = FastGetProfileValue(pProfileUserName,
                            gpviCPUserPreferences->uSection,
                            gpviCPUserPreferences->pwszKeyName,
                            NULL,
                            (LPBYTE)pdwValue,
                            sizeof(pdwValue),
                            0);

                    /*
                     * If some bits are not in the registry, get them from gpdwCPUserPreferencesMask
                     */
                    UserAssert(uDataRead <= sizeof(gpdwCPUserPreferencesMask));
                    RtlCopyMemory(pdwValue + uDataRead,
                                  gpdwCPUserPreferencesMask + uDataRead,
                                  sizeof(gpdwCPUserPreferencesMask) - uDataRead);

                    /*
                     * Set/Clear the new state and write it
                     */
                    if (lParam) {
                        SetUPBOOL(pdwValue, wFlag);
                    } else {
                        ClearUPBOOL(pdwValue, wFlag);
                    }

                    fWinIniChanged = FastWriteProfileValue(pProfileUserName,
                            gpviCPUserPreferences->uSection,
                            gpviCPUserPreferences->pwszKeyName,
                            REG_BINARY,
                            (LPBYTE)pdwValue,
                            sizeof(pdwValue)
                            );

                    fWriteAllowed = fWinIniChanged;
                }

                if (fWriteAllowed) {
                    if (lParam) {
                        SetUPBOOL(gpdwCPUserPreferencesMask, wFlag);
                    } else {
                        ClearUPBOOL(gpdwCPUserPreferencesMask, wFlag);
                    }

                    /*
                     * Propagate gpsi flags
                     */
                    switch (wFlag) {
                    case SPI_SETUIEFFECTS:
                        PropagetUPBOOLTogpsi(UIEFFECTS);
                        SetPointer(TRUE);
                        /*
                         * Fall through
                         */

                    case SPI_SETGRADIENTCAPTIONS:
                        CreateBitmapStrip();
                        xxxRedrawScreen();
                        break;

                    case SPI_SETCOMBOBOXANIMATION:
                        PropagetUPBOOLTogpsi(COMBOBOXANIMATION);
                        break;

                    case SPI_SETLISTBOXSMOOTHSCROLLING:
                        PropagetUPBOOLTogpsi(LISTBOXSMOOTHSCROLLING);
                        break;

                    case SPI_SETKEYBOARDCUES:
                        PropagetUPBOOLTogpsi(KEYBOARDCUES);
                        break;

                    case SPI_SETCURSORSHADOW:
                        SetPointer(TRUE);
                        break;

                    case SPI_SETFLATMENU:
                        xxxRedrawScreen();
                        break;

                    } /* switch (wFlag) */

                } /* if (fWriteAllowed) */

            } else { /* if ((wFlag & SPIF_RANGETYPEMASK) == SPIF_BOOL) */

                UserAssert(UPIsDWORDRange(wFlag));

                if (ppvi->uSection == PMAP_DESKTOP) {
                    if (CheckDesktopPolicy(pProfileUserName, ppvi->pwszKeyName)) {
                        fAlterWinIni = FALSE;
                        fWriteAllowed = FALSE;
                    }
                }
                if (fAlterWinIni) {
                    fWinIniChanged = FastWriteProfileValue(pProfileUserName,
                            ppvi->uSection,
                            ppvi->pwszKeyName,
                            REG_DWORD,
                            (LPBYTE)&lParam,
                            sizeof(DWORD)
                            );

                    fWriteAllowed = fWinIniChanged;
                }

                if (fWriteAllowed) {

                    ppvi->dwValue = PtrToUlong(lParam);

                    switch(wFlag) {
                    case SPI_SETCARETWIDTH:
                        gpsi->uCaretWidth = ppvi->dwValue;
                        break;

                    case SPI_SETFOCUSBORDERWIDTH:
                        if (ppvi->dwValue) {
                            SYSMET(CXFOCUSBORDER) = ppvi->dwValue;
                        }
                        break;

                    case SPI_SETFOCUSBORDERHEIGHT:
                        if (ppvi->dwValue) {
                            SYSMET(CYFOCUSBORDER) = ppvi->dwValue;
                        }
                        break;

                    case SPI_SETFONTSMOOTHINGTYPE:
                        GreSetFontEnumeration( (ppvi->dwValue  & FE_FONTSMOOTHINGCLEARTYPE) ? FE_CT_ON | FE_SET_CT : FE_SET_CT );
                        break;
                    case SPI_SETFONTSMOOTHINGCONTRAST:
                        GreSetFontContrast(ppvi->dwValue);
                        break;
                    case SPI_SETFONTSMOOTHINGORIENTATION:
                        GreSetLCDOrientation(ppvi->dwValue);
                        break;
                    default:
                        break;
                    }
                }

            } /* if ((wFlag & SPIF_RANGETYPEMASK) == SPIF_BOOL) */

            FreeProfileUserName(pProfileUserName, &tlName);
        } /* if (!(wFlag & SPIF_SET)) */

        break;
#undef ppvi
#undef uDataRead
    } /* switch (wFlag) */


    if (fWinIniChanged && fSendWinIniChange) {
        ULONG_PTR dwResult;

        /*
         * dwResult is defined so that xxxSendMessageTimeout will really
         * and truly do a timeout.  Yeah, I know, this is a hack, but,
         * it is compatible.
         */

        RtlInitLargeUnicodeString(&strSection, szSection, (UINT)-1);
        xxxSendMessageTimeout(PWND_BROADCAST, WM_SETTINGCHANGE, wFlag, (LPARAM)&strSection,
                SMTO_NORMAL, 100, &dwResult);
    }

    return fWriteAllowed;
}

/***************************************************************************\
* _RegisterShellHookWindow
*
* History:
\***************************************************************************/

BOOL _RegisterShellHookWindow(PWND pwnd) {
    PDESKTOPINFO pdeskinfo;

    if (pwnd->head.rpdesk == NULL)
        return FALSE;

    pdeskinfo = pwnd->head.rpdesk->pDeskInfo;

    /*
     * Add pwnd to the desktop's Volatile Window Pointer List (VWPL) of
     * ShellHook windows. If this call initializes the VWPL, set the
     * (re)allocation threshhold to 2 PWNDs (we know we never have more than
     * 2 windows in this list anyway)
     */
    if (VWPLAdd(&(pdeskinfo->pvwplShellHook), pwnd, 2)) {
        SetWF(pwnd, WFSHELLHOOKWND);
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
* _DeregisterShellHookWindow
*
* History:
\***************************************************************************/

BOOL _DeregisterShellHookWindow(PWND pwnd) {
    PDESKTOPINFO pdeskinfo;

    if (pwnd->head.rpdesk == NULL)
        return FALSE;

    pdeskinfo = pwnd->head.rpdesk->pDeskInfo;

    if (VWPLRemove(&(pdeskinfo->pvwplShellHook), pwnd)) {
        ClrWF(pwnd, WFSHELLHOOKWND);
    }
    return TRUE;
}

/***************************************************************************\
* xxxSendMinRectMessages
*
* History:
\***************************************************************************/

BOOL xxxSendMinRectMessages(PWND pwnd, RECT *lpRect) {
    BOOL fRet = FALSE;
    HWND hwnd = HW(pwnd);
    PTHREADINFO pti = PtiCurrent();
    PDESKTOPINFO pdeskinfo;
    DWORD nPwndShellHook;
    PWND pwndShellHook;

    if (IsHooked(pti, WHF_SHELL)) {
        xxxCallHook(HSHELL_GETMINRECT, (WPARAM)hwnd,
            (LPARAM)lpRect, WH_SHELL);
        fRet = TRUE;
    }

    pdeskinfo = GETDESKINFO(pti);
    if (pdeskinfo->pvwplShellHook == NULL)
        return fRet;

    nPwndShellHook = 0;
    pwndShellHook = NULL;
    while (pwndShellHook = VWPLNext(pdeskinfo->pvwplShellHook, pwndShellHook, &nPwndShellHook)) {
        TL tlpwnd;
        ULONG_PTR dwRes;

        ThreadLock(pwndShellHook, &tlpwnd);
        if (xxxSendMessageTimeout(pwndShellHook, WM_KLUDGEMINRECT, (WPARAM)(hwnd), (LPARAM)lpRect,
            SMTO_NORMAL, 100, &dwRes))
            fRet = TRUE;

        /*
         * pdeskinfo->pvwplShellHook may have been realloced to a different
         * location and size during the WM_KLUDGEMINRECT callback.
         */
        ThreadUnlock(&tlpwnd);
    }
    return fRet;
}

/***************************************************************************\
* PostShellHookMessages
*
* History:
\***************************************************************************/

void PostShellHookMessages(UINT message, LPARAM lParam) {
    PDESKTOPINFO pdeskinfo = GETDESKINFO(PtiCurrent());
    DWORD nPwndShellHook;
    PWND pwndShellHook;

    nPwndShellHook = 0;
    pwndShellHook = NULL;

    /*
     * Hack for WM_APPCOMMAND (bug 389210):
     * We want to allow anyone who's listening for these wm_appcommand messages to be able to
     * take the foreground. ie pressing mail will launch outlook AND bring it to the foreground
     * We set the token to null so anyone can steal the foreground - else it isn't clear who should
     * have the right to steal it - only one person gets the right. We let them fight it out to
     * decide who gets foreground if more than one listener will try make a foreground change.
     */
    if (HSHELL_APPCOMMAND == message) {
        TAGMSG0(DBGTAG_FOREGROUND, "PostShellHookMessages cleared last input token - open foreground.");

        glinp.ptiLastWoken = NULL;
    }

    /*
     * Loop through all the windows registered to listen for shell hooks and post the message
     * to them
     */
    while (pwndShellHook = VWPLNext(pdeskinfo->pvwplShellHook, pwndShellHook, &nPwndShellHook)) {
        if (pwndShellHook == pdeskinfo->spwndProgman) {
            switch (message) {
            case HSHELL_WINDOWCREATED:
                _PostMessage(pwndShellHook, gpsi->uiShellMsg, guiOtherWindowCreated, lParam);
                break;
            case HSHELL_WINDOWDESTROYED:
                _PostMessage(pwndShellHook, gpsi->uiShellMsg, guiOtherWindowDestroyed, lParam);
                break;
            }
        } else {
            _PostMessage(pwndShellHook, gpsi->uiShellMsg, message, lParam);
        }
    }

}

/***************************************************************************\
* _ResetDblClk
*
* History:
\***************************************************************************/

VOID _ResetDblClk(VOID)
{
    PtiCurrent()->pq->timeDblClk = 0L;
}

/***************************************************************************\
* SetMsgBox
*
* History:
\***************************************************************************/

void SetMsgBox(PWND pwnd)
{
    pwnd->head.rpdesk->pDeskInfo->cntMBox++;
    SetWF(pwnd, WFMSGBOX);
    return;
}

/***************************************************************************\
* xxxSimulateShiftF10
*
* This routine is called to convert a WM_CONTEXTHELP message back to a
* SHIFT-F10 sequence for old applications.  It is called from the default
* window procedure.
*
* History:
* 22-Aug-95 BradG       Ported from Win95 (rare.asm)
\***************************************************************************/

VOID xxxSimulateShiftF10( VOID )
{
        /*
     *  VK_SHIFT down
     */
    xxxKeyEvent(VK_LSHIFT, 0x2A | SCANCODE_SIMULATED, NtGetTickCount(), 0,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);

    /*
     *  VK_F10 down
     */
    xxxKeyEvent(VK_F10, 0x44 | SCANCODE_SIMULATED, NtGetTickCount(), 0,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);

    /*
     *  VK_F10 up
     */
    xxxKeyEvent(VK_F10 | KBDBREAK, 0x44 | SCANCODE_SIMULATED, NtGetTickCount(), 0,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);

    /*
     *  VK_SHIFT up
     */
    xxxKeyEvent(VK_LSHIFT | KBDBREAK, 0x2A | SCANCODE_SIMULATED, NtGetTickCount(), 0,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);
}

/*
 * VWPL (Volatile Window Pointer List) Implementation details.
 * ===========================================================
 * Volatile Window Pointer Lists are used to keep a list of windows that we want
 * to send messages to, where the list may get altered during each of those send
 * message callbacks.
 *
 * The list is volatile in that it can change its size, contents and location
 * while we continue to traverse the list.
 *
 * Examples of use:
 * - hungapp redraw code in hungapp.c
 * - xxxSendMinRectMessages stuff in rare.c
 *
 * Members of the VWPL struct:
 * cPwnd
 *   The number of pwnds in the list, not including NULLs
 * cElem
 *   The size of the list, including NULLs.
 * cThreshhold
 *   When growing, the number of extra spaces to add to the list.
 *   When (cElem - cPwnd) > cThreshhold, that's when we reallocate to shrink.
 * apwnd[]
 *   An array of pwnds.
 *   The array may have some empty slots, but they will all be at the end.
 *
 * VWPL Internal Invariants:
 * - no pwnd appears more than once.
 * - cPwnd <= cElem
 * - number of unused slots (cElem - cPwnd) < cThreshhold
 * - all unused slots are at the end of the aPwnd[] array
 *
 * Restrictions on use of VWPLs:
 * - NULL pwnd is not allowed (except in unused slots)
 * - all pwnds in the list must be valid: pwnds must be explicitly removed from
 *   the list in their xxxFreeWindow.
 */

#if DBG_VWPL
BOOL DbgCheckVWPL(PVWPL pvwpl)
{
    DWORD ixPwnd;

    if (!pvwpl) {
        return TRUE;
    }

    UserAssert(pvwpl->cElem >= pvwpl->cPwnd);
    // Low memory may have made a shrinking realloc fail, which doesn't
    // really bother us.
    // UserAssert((pvwpl->cElem - pvwpl->cPwnd) < pvwpl->cThreshhold);

    // Check that cElem is not too big
    UserAssert(pvwpl->cElem < 1000);

    // check that the pwnds are all in the first cPwnd slots.
    for (ixPwnd = 0; ixPwnd < pvwpl->cPwnd; ixPwnd++) {
        UserAssert(pvwpl->aPwnd[ixPwnd] != NULL);
    }

#if ZERO_INIT_VWPL
    // check that the NULLs are all in the last few slots.
    for (ixPwnd = pvwpl->cPwnd; ixPwnd < pvwpl->cElem; ixPwnd++) {
        UserAssert(pvwpl->aPwnd[ixPwnd] == NULL);
    }
#endif

#if 0
    // check that all pwnds are valid?
    for (ixPwnd = 0; ixPwnd < pvwpl->cPwnd; ixPwnd++) {
         PWND pwnd = pvwpl->aPwnd[ixPwnd];
         UserAssert(ValidateHwnd(pwnd->head.h) == pwnd);
    }
#endif

    // check that no pwnds appears twice
    for (ixPwnd = 0; ixPwnd < pvwpl->cPwnd; ixPwnd++) {
        DWORD ix2;
        for (ix2 = ixPwnd + 1; ix2 < pvwpl->cPwnd; ix2++) {
            UserAssert(pvwpl->aPwnd[ixPwnd] != pvwpl->aPwnd[ix2]);
        }
    }
}
#else
#define DbgCheckVWPL(foo)
#endif

/*****************************************************************************\
* VWPLAdd
*
* Adds a pwnd to a VWPL (Volatile Window Pointer List).
* Allocates or reallocates memory as required.
*
* History:
* 98-01-30 IanJa   Created.
\*****************************************************************************/
BOOL VWPLAdd(
    PVWPL *ppvwpl,
    PWND pwnd,
    DWORD dwThreshhold)
{
    PVWPL pvwpl;
    DWORD ixPwnd;

    TAGMSG2(DBGTAG_VWPL, "VWPL %#p + %#p", *ppvwpl, pwnd);
    UserAssert(pwnd);

    if (*ppvwpl == NULL) {
        /*
         * Initialize the VWPL
         */
        UserAssert(dwThreshhold >= 2); // could be 1, but that would be silly
        pvwpl = (PVWPL)UserAllocPool(
                sizeof(VWPL) + (sizeof(PWND) * dwThreshhold), TAG_VWPL);
        if (pvwpl == NULL) {
            RIPMSG1(RIP_WARNING,
                    "VWPLAdd fail to allocate initial %lx",
                    sizeof(VWPL) + (sizeof(PWND) * dwThreshhold));
            DbgCheckVWPL(*ppvwpl);
            return FALSE;
        }
        pvwpl->cElem = dwThreshhold;
        pvwpl->cThreshhold = dwThreshhold;
#if ZERO_INIT_VWPL
        RtlZeroMemory(&(pvwpl->aPwnd[0]), (sizeof(PWND) * dwThreshhold));
#endif
        pvwpl->cPwnd = 0;
        *ppvwpl = pvwpl;
        ixPwnd = 0;
        goto AddPwnd;
    } else {
        pvwpl = *ppvwpl;
        for (ixPwnd = 0; ixPwnd < pvwpl->cElem; ixPwnd++) {
            if (pwnd == pvwpl->aPwnd[ixPwnd]) {
                DbgCheckVWPL(*ppvwpl);
                return FALSE; // callers require FALSE this case
            }
        }

        if (pvwpl->cPwnd >= pvwpl->cElem ) {
            /*
             *  didn't find it already there, and no space so grow the VWPL
             */
            DWORD dwSize;
            DWORD dwSizeNew;

            dwSize = sizeof(VWPL) + (sizeof(PWND) * pvwpl->cElem);
            dwSizeNew = dwSize + (sizeof(PWND) * pvwpl->cThreshhold);
            pvwpl = (PVWPL)UserReAllocPool(pvwpl, dwSize, dwSizeNew, TAG_VWPL);
            if (pvwpl == NULL) {
                RIPMSG2(RIP_WARNING,
                        "VWPLAdd fail to reallocate %lx to %lx", dwSize, dwSizeNew);
                DbgCheckVWPL(*ppvwpl);
                return FALSE;
            }
#if ZERO_INIT_VWPL
            RtlZeroMemory(&(pvwpl->aPwnd[pvwpl->cPwnd]), (sizeof(PWND) * dwThreshhold));
#endif
            pvwpl->cElem += pvwpl->cThreshhold;
            *ppvwpl = pvwpl;
        }
    }

AddPwnd:
    ixPwnd = pvwpl->cPwnd;
    pvwpl->aPwnd[ixPwnd] = pwnd;
    pvwpl->cPwnd++;
    DbgCheckVWPL(*ppvwpl);
    return TRUE;
}

/*****************************************************************************\
* VWPLRemove
*
* Removes a pwnd from a VWPL list of pwnds.
* Reallocates memory as required.
*
* Returns FALSE if the pwnd was not found
*
* History:
* 98-01-30 IanJa   Created.
\*****************************************************************************/
BOOL VWPLRemove(
    PVWPL *ppvwpl,
    PWND pwnd)
{
    PVWPL pvwpl = *ppvwpl;
    DWORD ixPwnd;

    TAGMSG2(DBGTAG_VWPL, "VWPL %#p - %#p", *ppvwpl, pwnd);
    UserAssert(pwnd);

    if (!pvwpl) {
        return FALSE;
    }
    for (ixPwnd = 0; ixPwnd < pvwpl->cElem; ixPwnd++) {
        if (pwnd == pvwpl->aPwnd[ixPwnd]) {
            goto PwndIsFound;
        }
    }
    DbgCheckVWPL(*ppvwpl);
    return FALSE;

PwndIsFound:
    pvwpl->aPwnd[ixPwnd] = NULL;
    pvwpl->cPwnd--;

    if (pvwpl->cPwnd == 0) {
        UserFreePool(pvwpl);
        *ppvwpl = NULL;
        return TRUE;
    }

    /*
     * Compact the VWPL to keep all the empty slots at the end.
     * If these free slots exceeds the threshhold, realloc to shrink.
     * It doesn't matter that we change the order.
     */
    pvwpl->aPwnd[ixPwnd] = pvwpl->aPwnd[pvwpl->cPwnd];
#if ZERO_INIT_VWPL
    pvwpl->aPwnd[pvwpl->cPwnd] = NULL;
#endif


    if ((pvwpl->cElem - pvwpl->cPwnd) >= pvwpl->cThreshhold) {
        DWORD dwSize;
        DWORD dwSizeNew;

        // Low memory may have made a shrinking realloc fail, which doesn't
        // really bother us.
        // UserAssert((pvwpl->cElem - pvwpl->cPwnd) == pvwpl->cThreshhold);

        dwSize = sizeof(VWPL) + (sizeof(PWND) * pvwpl->cElem);
        dwSizeNew = sizeof(VWPL) + (sizeof(PWND) * pvwpl->cPwnd);
        pvwpl = (PVWPL)UserReAllocPool(pvwpl, dwSize, dwSizeNew, TAG_VWPL);
        if (pvwpl == NULL) {
            RIPMSG2(RIP_WARNING,
                    "VWPLRemove fail to reallocate %lx to %lx",
                    dwSize, dwSizeNew);
            DbgCheckVWPL(*ppvwpl);
            return TRUE;
        }
        pvwpl->cElem = pvwpl->cPwnd;
        *ppvwpl = pvwpl;
    }

    DbgCheckVWPL(*ppvwpl);
    return TRUE;
}

/*****************************************************************************\
* VWPLNext
*
* Returns the next pwnd from a VWPL (Volatile Window Pointer List).
*
* Setting *pnPrev to 0 will return the first pwnd in the VWPL, and gets a new
* value in *pnPrev which is to be used in a subsequent call to VWPLNext to
* obtain the next pwnd.
* Returns NULL when the last pwnd has been obtained, and sets *pnPrev back to 0
*
* History:
* 98-01-30 IanJa   Created.
\*****************************************************************************/
PWND VWPLNext(PVWPL pvwpl, PWND pwndPrev, DWORD *pnPrev)
{
    DbgCheckVWPL(pvwpl);

    if (!pvwpl) {
        TAGMSG1(DBGTAG_VWPL, "VWPL %#p => NULL (empty)", pvwpl);
        return NULL;
    }

    if (*pnPrev >= pvwpl->cPwnd) {
        goto NoMorePwnds;
    }

    /*
     * If our previous pwnd is still there, advance to the next slot
     * (else it has gone, so return the one now occupying its slot)
     */
    if (pvwpl->aPwnd[*pnPrev] == pwndPrev) {
        (*pnPrev)++;
    }

    if (*pnPrev < pvwpl->cPwnd) {
        UserAssert(pvwpl->aPwnd[*pnPrev] != pwndPrev);
        TAGMSG2(DBGTAG_VWPL, "VWPL %#p => %#p", pvwpl, pvwpl->aPwnd[*pnPrev]);
        return pvwpl->aPwnd[*pnPrev];
    }

    /*
     * We came to the end
     */
NoMorePwnds:
    TAGMSG1(DBGTAG_VWPL, "VWPL %#p => NULL (end)", pvwpl);
    *pnPrev = 0;
    return NULL;
}




/*****************************************************************************\
* RestoreMonitorsAndWindowsRects
*
* Restore a windows sizes and positions previously captured in a WMSNAPSHOT
* structure. Capture happens when disconnecting from local console and
* restore happens when connecting back to local console.
*
*
\*****************************************************************************/

NTSTATUS RestoreMonitorsAndWindowsRects(void)

{
    PMONITORRECTS pmr;
    int i;
    int j;
    BOOL bFound;
    PSMWP psmwp;
    PWND pwnd;
    NTSTATUS Status;
    PWPSNAPSHOT pwps = NULL;

    /*
     * Dont do anything if not mutlimon
     */
    if (!IsMultimon()) {
        return STATUS_SUCCESS;
    }

    /*
     * Nothing to do if we don't currently have captured monitors or windows snapshots.
     */


    if (gwms.pmr == NULL || gwms.pwps == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }
    /*
     * Get Current monitors layout.
     */


    pmr = SnapshotMonitorRects();
    if (pmr == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * make sure monitors we captured are still there.
     */

    Status = STATUS_SUCCESS;
    for ( i = 0; i < gwms.pmr->cMonitor; i++) {
        bFound = FALSE;
        for (j = 0; j < pmr->cMonitor; j++) {
            if (EqualRect(&gwms.pmr->amp[i].rcMonitor, &pmr->amp[j].rcMonitor)) {
                bFound = TRUE;
                break;
            }
        }
        if (!bFound) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
    }
    UserFreePool(pmr);

    /*
     * Position Windows now.
     */
    if (NT_SUCCESS(Status)) {
        if ((psmwp = InternalBeginDeferWindowPos(4)) != NULL) {
            for (i = 0, pwps = gwms.pwps; (i < gwms.cWindows) && (psmwp != NULL) ; i++, pwps++) {
                /*
                 * Make sure this hwnd is still here.
                 */
                if (    (pwnd = RevalidateHwnd(pwps->hwnd)) == NULL ||
                        TestWF(pwnd, WEFTOOLWINDOW)) {

                    continue;
                }

                psmwp = _DeferWindowPos(
                        psmwp,
                        pwnd,
                        (PWND)HWND_TOP,
                        pwps->rcWindow.left,
                        pwps->rcWindow.top,
                        pwps->rcWindow.right - pwps->rcWindow.left,
                        pwps->rcWindow.bottom - pwps->rcWindow.top,
                        SWP_NOACTIVATE | SWP_NOZORDER);
            }
            if (psmwp != NULL) {
                xxxEndDeferWindowPosEx(psmwp, TRUE);
            } else{
                Status = STATUS_NO_MEMORY;
            }

        }
    }
Exit:
    CleanupMonitorsAndWindowsSnapShot();
    return Status;
}

/*****************************************************************************\
* SnapShotMonitorsAndWindowsRects
*
* Captures  windows sizes and positions a WMSNAPSHOT structure. Capture
* happens when disconnecting from local console .
*
*
\*****************************************************************************/

NTSTATUS SnapShotMonitorsAndWindowsRects(void)

{

    /*
     * First, cleanup anything left over from previous captures
     */

    if ((gwms.pmr != NULL) || (gwms.pwps != NULL)) {
        CleanupMonitorsAndWindowsSnapShot();
    }

    /*
     * Get a snaphot of current monitors configuration
     */

    if ((gwms.pmr = SnapshotMonitorRects()) == NULL) {
        return STATUS_NO_MEMORY;
    }
    /*
     * Get a snaphsot of windows positions.
     */

    if ((gwms.pwps = SnapshotWindowRects(&gwms.cWindows)) == NULL) {
        CleanupMonitorsAndWindowsSnapShot();
        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}


/*****************************************************************************\
* CleanupMonitorsAndWindowsSnapShot
*
* Frees memory allocated to capture  windows sizes and positions a WMSNAPSHOT
* structure.
*
*
\*****************************************************************************/
void  CleanupMonitorsAndWindowsSnapShot(void)
{
    PWPSNAPSHOT pwps =  gwms.pwps;

    if (gwms.pmr != NULL) {
        UserFreePool(gwms.pmr);
        gwms.pmr = NULL;
    }
    if (pwps != NULL) {
        UserFreePool(gwms.pwps);
        gwms.pwps = NULL;
    }
    gwms.cWindows = 0;
}


/*****************************************************************************\
* SnapshotWindowRects
*
* Frees memory allocated to capture  windows sizes and positions a WMSNAPSHOT
* structure.
*
*
\*****************************************************************************/

PWPSNAPSHOT SnapshotWindowRects(int *pnWindows)
{
    PWND            pwndDesktop;
    PHWND           phwnd;
    PBWL            pbwl;
    PWND            pwnd;
    int             nWindows = 0;
    PWPSNAPSHOT     pwps = NULL;
    PWPSNAPSHOT     pReturnedpwps = NULL;

    /*
     * Initialize captured windows count.
     */

    *pnWindows = 0;

    /*
     * Build a list of top windows.
     */

    UserVerify(pwndDesktop = _GetDesktopWindow());
    if ((pbwl = BuildHwndList(pwndDesktop->spwndChild, BWL_ENUMLIST, NULL)) == NULL){
        return NULL;
    }

    /*
     * Count maximum captured  windows to allocate WPSNAPSHOT array.
     */

    phwnd = pbwl->rghwnd;
    while ( *phwnd != (HWND)1 ){
        nWindows++;
        phwnd++;
    }
    if (nWindows != 0) {
        pwps = UserAllocPoolWithQuotaZInit(sizeof(WPSNAPSHOT) * nWindows, TAG_SWP);
    }

    if (pwps == NULL) {
        FreeHwndList(pbwl);
        return NULL;
    }
    pReturnedpwps = pwps;


    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1 ; phwnd++) {
        /*
         * Make sure this hwnd is still around.
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL || TestWF(pwnd, WEFTOOLWINDOW) ) {
            continue;
        }

        pwps->hwnd = *phwnd;
        CopyRect(&pwps->rcWindow, &pwnd->rcWindow);
        (*pnWindows)++;
        pwps++;

    }

    if (*pnWindows != 0) {
        return pReturnedpwps;
    }  else {
        UserFreePool(pReturnedpwps);
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\scrollw.c ===
/****************************** Module Header ******************************\
* Module Name: scrollw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Window and DC scrolling routines.
*
* History:
* 18-Jul-1991 DarrinM   Recreated from Win 3.1 source.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Problems so far:
 * DCs not at origin (0, 0)
 * funny coordinate systems
 */

/***************************************************************************\
* GetTrueClipRgn
*
* Get copy of true clip region and its bounds.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int GetTrueClipRgn(
    HDC  hdc,
    HRGN hrgnClip)
{
    POINT pt;
    int   code;

    code = GreCopyVisRgn(hdc, hrgnClip);

    /*
     * NOTE!!! The global ghrgnScrl2 is used in this routine!
     */
    GreGetDCOrg(hdc, &pt);

    if (GreGetRandomRgn(hdc, ghrgnScrl2, 1)) {
        GreOffsetRgn(ghrgnScrl2, pt.x, pt.y);
        code = IntersectRgn(hrgnClip, hrgnClip, ghrgnScrl2);
    }

    /*
     * Finally convert the result to DC coordinates
     */
    GreOffsetRgn(hrgnClip, -pt.x, -pt.y);

    return code;
}

/***************************************************************************\
* InternalScrollDC
*
* This function requires all input parameters in device coordinates
* (NOT screen!)
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int InternalScrollDC(
    HDC    hdc,
    int    dx,
    int    dy,
    RECT   *prcSrc,
    RECT   *prcClip,
    HRGN   hrgnInvalid,
    HRGN   hrgnUpdate,
    LPRECT prcUpdate,
    BOOL   fLogUnits)
{
    RECT  rcVis;
    RECT  rcSrc;
    RECT  rcClip;
    RECT  rcUnclippedSrc;
    RECT  rcDst;
    RECT  rcUpdate;
    RECT  rcValid;
    BOOL  fSrcNotEmpty;
    BOOL  fHaveVisRgn;
    POINT rgpt[2];
    int   dxLog;
    int   dyLog;
    int   wClip;
    int   wClipValid;
    BOOL  bMirroredDC=FALSE;

    fHaveVisRgn = FALSE;

    /*
     * Enter a critical region to ensure that no one changes visrgns
     * or update regions while we scroll bits around.
     */
    GreLockDisplay(gpDispInfo->hDev);

    if ((wClip = GreGetClipBox(hdc, &rcVis, TRUE)) == ERROR) {

ErrorExit:

        GreUnlockDisplay(gpDispInfo->hDev);
        return ERROR;
    }

    CopyRect(&rcSrc, (prcSrc) ? prcSrc : &rcVis);
    if (prcClip) {
        CopyRect(&rcClip, prcClip);
    }

    dxLog = dx;
    dyLog = dy;

    if (fLogUnits) {

        /*
         * Convert input parameters to device coordinates
         */
        GreLPtoDP(hdc, (LPPOINT)&rcVis, 2);
        GreLPtoDP(hdc, (LPPOINT)&rcSrc, 2);

        //
        // Since this is a mirrored DC, then the resulting
        // device coord will be flowing from right to left
        // (i.e. rc.right < rc.left) so they should be flipped.
        // [samera]
        //
        if (GreGetLayout(hdc) & LAYOUT_RTL) {
            int iTemp   = rcVis.left;
            rcVis.left  = rcVis.right;
            rcVis.right = iTemp;

            iTemp       = rcSrc.left;
            rcSrc.left  = rcSrc.right;
            rcSrc.right = iTemp;

            bMirroredDC = TRUE;
        }

        if (prcClip) {
            GreLPtoDP(hdc, (LPPOINT)&rcClip, 2);

            //
            // Since this is a mirrored DC, then the resulting
            // device coord will be flowing from right to left
            // (i.e. rc.right < rc.left) so they should be flipped.
            // [samera]
            //
            if (bMirroredDC) {
                int iTemp    = rcClip.left;
                rcClip.left  = rcClip.right;
                rcClip.right = iTemp;
            }
        }

        /*
         * The delta values must be treated as a vector from
         * the point (0, 0) to (dx, dy).  Scale it as such, then
         * compute the difference.  This handles flipped coordinate systems.
         */
        rgpt[0].x = rgpt[0].y = 0;
        rgpt[1].x = dx;
        rgpt[1].y = dy;

        GreLPtoDP(hdc, rgpt, 2);

        dx = rgpt[1].x - rgpt[0].x;
        dy = rgpt[1].y - rgpt[0].y;
    }

    switch (wClip) {
    case NULLREGION:

NullExit:

        if (hrgnUpdate && !SetEmptyRgn(hrgnUpdate))
            goto ErrorExit;

        if (prcUpdate) {
            SetRectEmpty(prcUpdate);
        }

        GreUnlockDisplay(gpDispInfo->hDev);
        return NULLREGION;

    case COMPLEXREGION:
        GetTrueClipRgn(hdc, ghrgnScrlVis);
        fHaveVisRgn = TRUE;
        break;
    }

    /*
     * First compute the source and destination rectangles.
     *
     * rcDst = Offset(rcSrc, dx, dy)
     */
    rcDst.left   = rcSrc.left   + dx;
    rcDst.right  = rcSrc.right  + dx;
    rcDst.top    = rcSrc.top    + dy;
    rcDst.bottom = rcSrc.bottom + dy;

    /*
     * If necessary, intersect with caller-supplied clip rect.
     */
    if (prcClip) {

        if ((wClip == SIMPLEREGION) &&
            ((hrgnInvalid == NULL) || (hrgnInvalid == HRGN_FULL))) {

            /*
             * Simple clip region: just a rect intersection
             */
            if (!IntersectRect(&rcVis, &rcVis, &rcClip))
                goto NullExit;

        } else {

            if (!fHaveVisRgn) {

                if (GetTrueClipRgn(hdc, ghrgnScrlVis) == ERROR)
                    goto ErrorExit;

                fHaveVisRgn = TRUE;
            }

            SetRectRgnIndirect(ghrgnScrl1, &rcClip);
            wClip = IntersectRgn(ghrgnScrlVis, ghrgnScrl1, ghrgnScrlVis);
            switch (wClip) {
            case ERROR:
                goto ErrorExit;

            case NULLREGION:
                goto NullExit;

            case SIMPLEREGION:

                /*
                 * If the clipped region is simple, we're back in fat
                 * rect city.
                 */
                GreGetRgnBox(ghrgnScrlVis, &rcVis);
                break;

            case COMPLEXREGION:
                break;
            }
        }
    }

    /*
     * Time for basic scrolling area calculations:
     *
     * Dst    = Offset(Src, dx, dy) & Vis
     * Src    = Src & Vis
     * Valid  = Offset(Src, dx, dy) & Dst
     * Valid  = Valid & Invalid & Offset(Invalid, dx, dy)
     * Update = (Src | Dst) - Valid
     *
     * If the vis region is simple, then we know that the valid region
     * will be rectangular.
     *
     * The rectangular calculation case can only deal with
     * ghrgnInvalid == NULL or (HRGN)1: the region case is handled the hard way.
     */
    if ((wClip == SIMPLEREGION) &&
            ((hrgnInvalid == NULL) || (hrgnInvalid == HRGN_FULL))) {

        /*
         * Save a copy of this for update rect calc optimization.
         */
        CopyRect(&rcUnclippedSrc, &rcSrc);

        /*
         * Dst = Offset(Src, dx, dy) & Vis.
         */
        IntersectRect(&rcDst, &rcDst, &rcVis);

        /*
         * Src = Src & Vis.
         */
        fSrcNotEmpty = IntersectRect(&rcSrc, &rcSrc, &rcVis);

        /*
         * Valid = Offset(Src, dx, dy) & Dst.
         */
        if (hrgnInvalid == HRGN_FULL) {
            SetRectEmpty(&rcValid);
        } else {

            rcValid.left   = rcSrc.left   + dx;
            rcValid.right  = rcSrc.right  + dx;
            rcValid.top    = rcSrc.top    + dy;
            rcValid.bottom = rcSrc.bottom + dy;

            IntersectRect(&rcValid, &rcValid, &rcDst);
        }

        /*
         * Now calculate the update area.
         *
         * There are two cases where the result will be a rectangle:
         *
         * 1) The source rectangle lies completely within the visrgn,
         *    and the source and destination don't overlap.  In this
         *    case the update region is equal to the source rect.
         *
         * 2) The clipped source rectangle is empty, in which case
         *    the update region is equal to the clipped dest rect.
         *
         * 3) We're scrolling in one dimension only, and the source
         *    and destination DO overlap.  In this case we can use
         *    UnionRect() and SubtractRect() to do the area arithmetic.
         */
        if (!fSrcNotEmpty) {

            /*
             * Clipped source is empty.  Update area is the clipped dest.
             */
            CopyRect(&rcUpdate, &rcDst);
            goto RectUpdate;

        } else if (IntersectRect(&rcUpdate, &rcSrc, &rcDst)) {

            /*
             * They overlap.  If we're scrolling in one dimension only
             * then we can use rect arithmetic...
             */
            if (dx == 0 || dy == 0) {

                UnionRect(&rcUpdate, &rcSrc, &rcDst);
                SubtractRect(&rcUpdate, &rcUpdate, &rcValid);
                goto RectUpdate;
            }

        } else if (EqualRect(&rcSrc, &rcUnclippedSrc)) {

            /*
             * They don't overlap, and the source lies completely
             * within the visible region.  Update region is the source.
             */
            CopyRect(&rcUpdate, &rcSrc);
RectUpdate:
            if (prcUpdate) {
                CopyRect(prcUpdate, &rcUpdate);
            }

            if (hrgnUpdate && !SetRectRgnIndirect(hrgnUpdate, &rcUpdate)) {
                goto ErrorExit;
            }

            wClip = SIMPLEREGION;
            if (rcUpdate.left >= rcUpdate.right ||
                rcUpdate.top >= rcUpdate.bottom)

                wClip = NULLREGION;

            goto DoRectBlt;
        }

        /*
         * The update region isn't rectangular.  Need to do our
         * area calculations with region calls.  Skip all this
         * if the caller doesn't care about the update region.
         *
         * If he wants a rectangle but no region, use ghrgnScrl2 as a temp.
         */
        if (hrgnUpdate == NULL && prcUpdate) {
            hrgnUpdate = ghrgnScrl2;
        }

        if (hrgnUpdate != NULL) {

            /*
             * hrgnUpdateCalc = (rcSrc | rcDst) - rcBltDst
             */
            SetRectRgnIndirect(ghrgnScrl1, &rcSrc);
            SetRectRgnIndirect(hrgnUpdate, &rcDst);
            if (UnionRgn(hrgnUpdate, hrgnUpdate, ghrgnScrl1) == ERROR)
                goto ErrorExit;

            SetRectRgnIndirect(ghrgnScrl1, &rcValid);
            wClip = SubtractRgn(hrgnUpdate, hrgnUpdate, ghrgnScrl1);
            if (wClip == ERROR)
                goto ErrorExit;

            if (prcUpdate) {
                GreGetRgnBox(hrgnUpdate, prcUpdate);
            }
        }

DoRectBlt:

        /*
         * If the valid rectangle's not empty, then copy those bits...
         */
        if (rcValid.left < rcValid.right && rcValid.top < rcValid.bottom) {

            /*
             * If the DC is in a funny map mode, then be sure to map from
             * device to logical coordinates for BLT call...
             */
            if (fLogUnits)
                GreDPtoLP(hdc, (LPPOINT)&rcValid, 2);

            GreBitBlt(hdc,
                      rcValid.left,
                      rcValid.top,
                      rcValid.right - rcValid.left,
                      rcValid.bottom - rcValid.top,
                      hdc,
                      rcValid.left - dxLog,
                      rcValid.top - dyLog,
                      SRCCOPY,
                      0);
        }

    } else {

        /*
         * Get the true visrgn if we haven't already.
         */
        if (!fHaveVisRgn) {

            if (GetTrueClipRgn(hdc, ghrgnScrlVis) == ERROR)
                goto ErrorExit;

            fHaveVisRgn = TRUE;
        }

        /*
         * The visrgn is not empty.  Need to do all our calculations
         * with regions.
         *
         * hrgnSrc = hrgnSrc & ghrgnScrlVis
         */
        SetRectRgnIndirect(ghrgnScrlSrc, &rcSrc);
        if (IntersectRgn(ghrgnScrlSrc, ghrgnScrlSrc, ghrgnScrlVis) == ERROR)
            goto ErrorExit;

        /*
         * hrgnDst = hrgnDst & ghrgnScrlVis
         */
        SetRectRgnIndirect(ghrgnScrlDst, &rcDst);
        if (IntersectRgn(ghrgnScrlDst, ghrgnScrlDst, ghrgnScrlVis) == ERROR)
            goto ErrorExit;

        /*
         * Now compute the valid region:
         *
         * Valid = Offset(Src, dx, dy) & Dst.
         * Valid = Valid & Invalid & Offset(Invalid, dx, dy)
         *
         * If hrgnInvalid is (HRGN)1, then the valid area is empty.
         */
        wClipValid = NULLREGION;
        if (hrgnInvalid != HRGN_FULL) {

            /*
             * Valid = Offset(Src, dx, dy) & Dst
             */
            if (CopyRgn(ghrgnScrlValid, ghrgnScrlSrc) == ERROR)
                goto ErrorExit;

            GreOffsetRgn(ghrgnScrlValid, dx, dy);
            wClipValid = IntersectRgn(ghrgnScrlValid,
                                      ghrgnScrlValid,
                                      ghrgnScrlDst);

            /*
             * Valid = Valid - Invalid - Offset(Invalid, dx, dy)
             * We need bother only if hrgnInvalid is a real region.
             */
            if (hrgnInvalid > HRGN_FULL) {

                if (wClipValid != ERROR && wClipValid != NULLREGION) {
                    POINT pt;

                    GetDCOrgOnScreen(hdc, &pt);

                    /*
                     * hrgnInvalid is in screen coordinates: map to dc coords
                     */
                    CopyRgn(ghrgnScrl2, hrgnInvalid);
                    GreOffsetRgn(ghrgnScrl2, -pt.x, -pt.y);

                    wClipValid = SubtractRgn(ghrgnScrlValid,
                                             ghrgnScrlValid,
                                             ghrgnScrl2);
                }

                if (wClipValid != ERROR && wClipValid != NULLREGION) {
                    GreOffsetRgn(ghrgnScrl2, dx, dy);

                    wClipValid = SubtractRgn(ghrgnScrlValid,
                                             ghrgnScrlValid,
                                             ghrgnScrl2);
                }
            }

            if (wClipValid == ERROR)
                goto ErrorExit;
        }

        /*
         * If he wants a rectangle but no region, use ghrgnScrl2 as a temp.
         */
        if (hrgnUpdate == NULL && prcUpdate) {
            hrgnUpdate = ghrgnScrl2;
        }

        if (hrgnUpdate != NULL) {

            /*
             * Update = (Src | Dst) - Valid.
             */
            wClip = UnionRgn(hrgnUpdate, ghrgnScrlDst, ghrgnScrlSrc);
            if (wClip == ERROR)
                goto ErrorExit;

            if (wClipValid != NULLREGION) {
                wClip = SubtractRgn(hrgnUpdate, hrgnUpdate, ghrgnScrlValid);
            }

            if (prcUpdate) {
                GreGetRgnBox(hrgnUpdate, prcUpdate);
            }
        }

        if (wClipValid != NULLREGION) {

            #ifdef LATER

                /*
                 * don't use the visrgn here
                 */
                HRGN hrgnSaveVis = CreateEmptyRgn();
                if (hrgnSaveVis != NULL) {

                    BOOL fClipped;

                    fClipped = (GreGetRandomRgn(hdc, hrgnSaveVis, 1) == 1);
                    GreExtSelectClipRgn(hdc, ghrgnScrlValid, RGN_COPY);

                    /*
                     * If the DC is in a funny map mode, then be sure to
                     * map from device to logical coordinates for BLT call...
                     */
                    if (fLogUnits)
                        GreDPtoLP(hdc, (LPPOINT)&rcDst, 2);

                    /*
                     * Gdi can take along time to process this call if
                     * it's a printer DC
                     */
                    GreBitBlt(hdc,
                              rcDst.left,
                              rcDst.top,
                              rcDst.right - rcDst.left,
                              rcDst.bottom - rcDst.top,
                              hdc,
                              rcDst.left - dxLog,
                              rcDst.top - dyLog,
                              SRCCOPY,
                              0);

                    GreExtSelectClipRgn(hdc,
                                        (fClipped ? hrgnSaveVis : NULL),
                                        RGN_COPY);

                    GreDeleteObject(hrgnSaveVis);
                }

            #else

                /*
                 * Visrgn is expected in DC surface coordinates: offset
                 * as appropriate.
                 */
                POINT pt;
                GreGetDCOrg(hdc, &pt);

                GreOffsetRgn(ghrgnScrlValid, pt.x, pt.y);

                /*
                 * Select in the temporary vis rgn, saving the old
                 */

                GreSelectVisRgn(hdc, ghrgnScrlValid, SVR_SWAP);

                /*
                 * If the DC is in a funny map mode, then be sure to map from
                 * device to logical coordinates for BLT call...
                 */
                if (fLogUnits)
                    GreDPtoLP(hdc, (LPPOINT)&rcDst, 2);

                /*
                 * Gdi can take along time to process this call if it's
                 * a printer DC.
                 */
                GreBitBlt(hdc,
                          rcDst.left,
                          rcDst.top,
                          rcDst.right - rcDst.left,
                          rcDst.bottom - rcDst.top,
                          hdc,
                          rcDst.left - dxLog,
                          rcDst.top - dyLog,
                          SRCCOPY,
                          0);

                /*
                 * Restore the old vis rgn, leaving ghrgnScrlValid with
                 * a valid rgn
                 */
                GreSelectVisRgn(hdc, ghrgnScrlValid, SVR_SWAP);

            #endif
        }
    }

    /*
     * If necessary, convert the resultant update rect back
     * to logical coordinates.
     */
    if (fLogUnits && prcUpdate) {
        GreDPtoLP(hdc, (LPPOINT)prcUpdate, 2);
    }

    GreUnlockDisplay(gpDispInfo->hDev);

    return wClip;
}

/***************************************************************************\
* _ScrollDC (API)
*
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL _ScrollDC(
    HDC    hdc,
    int    dx,
    int    dy,
    LPRECT prcSrc,
    LPRECT prcClip,
    HRGN   hrgnUpdate,
    LPRECT prcUpdate)
{
    RECT rcSrc;
    RECT rcSpb;
    PWND pwnd;
    HRGN hrgnInvalid;
    BOOL fRet;

    /*
     * ScrollDC does not scroll update region. Under WinNT, an app calling
     * GetUpdateRgn() then ScrollDC() then InvalidateRgn() will not get
     * any new update region that happened between the Get and Scroll. Under
     * Win3.1, that was not a problem because no other app ran during this
     * time. So pass hrgnInvalid - this will affect the hrgnUpdate and
     * prcUpdate values being returned from ScrollDC with the update region.
     */
    hrgnInvalid = NULL;
    if ((pwnd = FastWindowFromDC(hdc)) != NULL) {

        hrgnInvalid = pwnd->hrgnUpdate;

        if (hrgnInvalid == HRGN_FULL) {

            /*
             * This is a fix for winhell, a performance testing app
             * written by some guy working for a windows magazine.
             * this app scrolls it's window while it is completely
             * invalid.  We normaly won't scroll invalid bits but
             * but we make the exception here
             */
            hrgnInvalid = NULL;
        }
    }

    fRet = InternalScrollDC(hdc,
                            dx,
                            dy,
                            prcSrc,
                            prcClip,
                            hrgnInvalid,
                            hrgnUpdate,
                            prcUpdate,
                            TRUE) != ERROR;

    /*
     * InternalScrollDC() only scrolls those areas inside the visible region.
     * This means it does no operations on parts of the window if the window
     * isn't visible. This means SPBs don't get properly invalidated. This
     * could be seen by starting a dir, then moving another window with the
     * mouse (and keeping the mouse down until the dir finished). The
     * screen is remembered with an SPB, and the dir window doesn't get
     * properly invalidated because of this.
     */
    if (pwnd != NULL && AnySpbs()) {

        if (prcSrc) {

            rcSrc = *prcSrc;
            OffsetRect(&rcSrc, pwnd->rcClient.left, pwnd->rcClient.top);

            rcSpb = rcSrc;
            OffsetRect(&rcSpb, dx, dy);
            UnionRect(&rcSpb, &rcSpb, &rcSrc);

        } else {
            rcSpb = pwnd->rcClient;
        }

        SpbCheckRect(pwnd, &rcSpb, 0);
    }

    return fRet;
}

/***************************************************************************\
* ScrollWindowEx (API)
*
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
int xxxScrollWindowEx(
    PWND    pwnd,
    int    dx,
    int    dy,
    RECT   *prcScroll,
    RECT   *prcClip,
    HRGN   hrgnUpdate,
    LPRECT prcUpdate,
    DWORD  flags)
{
    INT    code;
    HDC    hdc;
    int    dxDev;
    int    dyDev;
    RECT   rcSrcDev;
    RECT   rcSpb, rcSrc;
    DWORD  flagsDCX;
    BOOL   fHideCaret;
    BOOL   fRcScroll = (prcScroll != NULL);
    BOOL   fInvisible = FALSE;
    PCARET pcaret;
    POINT  pt;
    TL     tlpwndChild;
    HRGN   hrgnInvalid;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());


    if (pwnd == NULL)
        pwnd = ptiCurrent->rpdesk->pDeskInfo->spwnd;       // pwndDesktop

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        dx = -dx;

        MirrorRegion(pwnd, hrgnUpdate, TRUE);

        if(prcScroll) {
            MirrorClientRect(pwnd, prcScroll);
        }

        if (prcClip) {
            MirrorClientRect(pwnd, prcClip);
        }
    }

    /*
     * If nothing's moving, nothing to do.
     */
    if ((dx | dy) == 0 ) {

        goto DoNothing;

    } else if (!IsVisible(pwnd)) {

        /* We want to offset our children if we're not minimized.  IsVisible()
         * will return FALSE if we're minimized, invisible, or the child of
         * a minimized/invisible ancestore.
         */
        if (!TestWF(pwnd, WFMINIMIZED) &&
          (flags & SW_SCROLLCHILDREN) &&
          !fRcScroll) {

            fInvisible = TRUE;
            flags &= ~SW_INVALIDATE;
        }

DoNothing:

        if (hrgnUpdate) {
            SetEmptyRgn(hrgnUpdate);
        }

        if (prcUpdate) {
            SetRectEmpty(prcUpdate);
        }

        if (!fInvisible)
            return NULLREGION;
    }

    /*
     * Hide the caret.
     */
    fHideCaret = FALSE;

    if (!fInvisible) {
        pcaret = &ptiCurrent->pq->caret;
        if (pcaret->spwnd != NULL && _IsDescendant(pcaret->spwnd, pwnd)) {
            fHideCaret = TRUE;
            zzzInternalHideCaret();
        }
    }

    /*
     * If scrollwindow, and window is clipchildren, use a cache entry.
     * Otherwise, always use a
     *
     * Determine what kind of DC we'll be needing.  If the DCX_CACHE bit
     * isn't set, it means that we'll be operating in logical coordinates.
     */
    if (flags & SW_SCROLLWINDOW) {

        /*
         *  ScrollWindow() call: use the cache if not OWNDC or CLASSDC.
         */
        flagsDCX = DCX_USESTYLE;
        if (!TestCF(pwnd, CFOWNDC) && !TestCF(pwnd, CFCLASSDC))
            flagsDCX |= DCX_CACHE;

        /*
         * If SW_SCROLLCHILDREN (i.e., lprcScroll == NULL) and CLIPCHILDREN,
         * then use the cache and don't clip children.
         * This is screwy, but 3.0 backward compatible.
         */
        if ((flags & SW_SCROLLCHILDREN) && TestWF(pwnd, WFCLIPCHILDREN))
            flagsDCX |= DCX_NOCLIPCHILDREN | DCX_CACHE;

    } else {

        /*
         * ScrollWindowEx() call: always use the cache
         */
        flagsDCX = DCX_USESTYLE | DCX_CACHE;

        /*
         * if SW_SCROLLCHILDREN, always use noclipchildren.
         */
        if (flags & SW_SCROLLCHILDREN)
            flagsDCX |= DCX_NOCLIPCHILDREN;
    }

    flagsDCX |= DCX_NOMIRROR;
    hdc = _GetDCEx(pwnd, NULL, flagsDCX);

    if (flags & SW_INVALIDATE) {

        /*
         * Get device origin while DC is valid, for later offsetting
         */
        GetDCOrgOnScreen(hdc, &pt);

        /*
         * If the user didn't give us a region to use, use ghrgnSW.
         */
        if (hrgnUpdate == NULL)
            hrgnUpdate = ghrgnSW;
    }

    /*
     * The DC will be in some logical coordinate system if OWNDC or CLASSDC.
     */
    if (!fRcScroll) {
        prcScroll = &rcSrc;

        /*
         * IMPORTANT:
         * We have to use CopyOffsetRect() here because GetClientRect() gives
         * unreliable results for minimized windows.  3.1 dudes get told that
         * their client is non-empty, for compatibility reasons.
         */
        GetRect(pwnd, &rcSrc, GRECT_CLIENT | GRECT_CLIENTCOORDS);

        /*
         * If the DC might be a screwy one, then map the
         * rect to logical units.
         */
        if (!(flagsDCX & DCX_CACHE))
            GreDPtoLP(hdc, (LPPOINT)&rcSrc, 2);
    }

    /*
     * If the DC is in logical coordinates, map *prcScroll and dx, dy
     * to device units for use later.
     */
    dxDev = dx;
    dyDev = dy;
    rcSrcDev = *prcScroll;

    if (!(flagsDCX & DCX_CACHE)) {

        POINT rgpt[2];

        GreLPtoDP(hdc, (POINT FAR*)&rcSrcDev, 2);

        /*
         * The delta values must be treated as a vector from
         * the point (0, 0) to (dx, dy).  Scale it as such, then
         * compute the difference.  This handles flipped coordinate systems.
         */
        rgpt[0].x = rgpt[0].y = 0;
        rgpt[1].x = dx;
        rgpt[1].y = dy;

        GreLPtoDP(hdc, rgpt, 2);

        dxDev = rgpt[1].x - rgpt[0].x;
        dyDev = rgpt[1].y - rgpt[0].y;
    }

    if (fInvisible)
        code = NULLREGION;
    else {
        hrgnInvalid = pwnd->hrgnUpdate;
        if ((flags & SW_SCROLLWINDOW) && !TestWF(pwnd, WFWIN31COMPAT)) {
            /*
             * 3.0 Backward compatibility hack:
             * The following incorrect code is what 3.0 used to do, and
             * there are apps such as Finale and Scrapbook+ that have worked
             * around this bug in ways that don't work with the "correct" code.
             */
            if (pwnd->hrgnUpdate > HRGN_FULL) {
                RECT rc;

                GreGetRgnBox(pwnd->hrgnUpdate, &rc);
                OffsetRect(&rc,
                           dxDev - pwnd->rcClient.left,
                           dyDev - pwnd->rcClient.top);

                xxxRedrawWindow(pwnd,
                                &rc, NULL,
                                RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
            }
            hrgnInvalid = NULL;
        }

        code = InternalScrollDC(hdc,
                                dx,
                                dy,
                                prcScroll,
                                prcClip,
                                hrgnInvalid,
                                hrgnUpdate,
                                prcUpdate,
                                !(flagsDCX & DCX_CACHE));
        if (prcUpdate && TestWF(pwnd, WEFLAYOUTRTL)) {
            MirrorClientRect(pwnd, prcUpdate);
        }
    }

    /*
     * Release the hdc we used.
     */
    _ReleaseDC(hdc);

    /*
     * Check the union of the src and dst rectangle against any SPBs.
     * We do this because the window
     * might be completely obscured by some window with an SPB, but
     * since we're completely covered no BitBlt call will be made
     * to accumulate bounds in that area.
     */
    if (!fInvisible && AnySpbs()) {

        if (fRcScroll) {
            if (pwnd == PWNDDESKTOP(pwnd)) {
                rcSrc = rcSrcDev;
            } else {
                CopyOffsetRect(
                        &rcSrc,
                        &rcSrcDev,
                        pwnd->rcClient.left,
                        pwnd->rcClient.top);
            }

            rcSpb = rcSrc;
            OffsetRect(&rcSpb, dxDev, dyDev);
            UnionRect(&rcSpb, &rcSpb, &rcSrc);

        } else {

            /*
             * Use the entire client area.
             */
            rcSpb = pwnd->rcClient;
        }

        SpbCheckRect(pwnd, &rcSpb, 0);
    }

    /*
     * If this guy wants to scroll his children, go at it.  Only scroll those
     * children intersecting prcScroll.  Then invalidate any vis rgns
     * calculated for these child windows.
     */
    if (flags & SW_SCROLLCHILDREN) {

        RECT rc;

        /*
         * If this window has the caret then offset it if:
         * a) The whole window is scrolling
         * b) The rectangle scrolled contains the caret rectangle
         */
        if (!fInvisible && (pwnd == pcaret->spwnd)) {

            if (fRcScroll)
                SetRect(&rc,
                        pcaret->x,
                        pcaret->y,
                        pcaret->x + pcaret->cx,
                        pcaret->y + pcaret->cy);

            if (!fRcScroll || IntersectRect(&rc, &rc, &rcSrcDev)) {
                pcaret->x += dxDev;
                pcaret->y += dyDev;
            }
        }

        if (fRcScroll) {

            /*
             * Create a copy of prcScroll and map to absolute coordinates...
             */
            if (pwnd == PWNDDESKTOP(pwnd)) {
                CopyRect(&rc, &rcSrcDev);
            } else {
                CopyOffsetRect(
                        &rc,
                        &rcSrcDev,
                        pwnd->rcClient.left,
                        pwnd->rcClient.top);
            }
        }

        if (pwnd->spwndChild) {

            OffsetChildren(pwnd,
                           dxDev,
                           dyDev,
                           (fRcScroll ? (LPRECT)&rc : NULL));

            /*
             * If we're clipchildren, then shuffling our children
             * will affect our client visrgn (but not our window visrgn).
             * Otherwise, only our children's
             * visrgns were affected by the scroll.
             * No need to DeferWinEventNotify() judging by xxxInternalInvalidate() below
             */
            zzzInvalidateDCCache(pwnd,
                              TestWF(pwnd, WFCLIPCHILDREN) ?
                                  IDC_CLIENTONLY : IDC_CHILDRENONLY);

        }
    }

    if (flags & SW_INVALIDATE) {

        /*
         * If the caller supplied a region, invalidate using a copy,
         * because InternalInvalidate may trash the passed-in region.
         */
        if (hrgnUpdate != ghrgnSW)
            CopyRgn(ghrgnSW, hrgnUpdate);

        /*
         * Make ghrgnSW screen-relative before invalidation...
         */
        GreOffsetRgn(ghrgnSW, pt.x, pt.y);

        xxxInternalInvalidate(
                pwnd,
                ghrgnSW,
                (flags & SW_ERASE) ?
                    (RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE) :
                    (RDW_INVALIDATE | RDW_ALLCHILDREN));
    }

    /*
     * Send child move messages if needed.
     */
    if (flags & SW_SCROLLCHILDREN) {

        PWND pwndChild;
        RECT rc;
        RECT rcScrolledChildren;

        /*
         * NOTE: the following code will send MOVE messages
         * to windows that didn't move but were in the source rectangle.
         * This is not a big deal, and definitely not worth fixing.
         */
        if (fRcScroll) {
            if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
                CopyOffsetRect(&rcScrolledChildren, &rcSrcDev, dxDev, dyDev);
            } else {
                CopyOffsetRect(
                        &rcScrolledChildren,
                        &rcSrcDev,
                        dxDev + pwnd->spwndParent->rcClient.left,
                        dyDev + pwnd->spwndParent->rcClient.top);
            }
        }

        ThreadLockNever(&tlpwndChild);
        pwndChild = pwnd->spwndChild;
        while (pwndChild != NULL) {

            if (    !fRcScroll ||
                    IntersectRect(&rc, &rcScrolledChildren, &pwndChild->rcWindow)) {

                /*
                 * NOTE: Win 3.0 and below passed wParam == TRUE here.
                 * This was not documented or used, so it was changed
                 * to be consistent with the documentation.
                 */
                ThreadLockExchangeAlways(pwndChild, &tlpwndChild);
                xxxSendMessage(
                        pwndChild,
                        WM_MOVE,
                        0,
                        (pwnd == PWNDDESKTOP(pwnd)) ?
                            MAKELONG(pwndChild->rcClient.left, pwndChild->rcClient.top) :
                            MAKELONG(pwndChild->rcClient.left - pwnd->rcClient.left,
                                     pwndChild->rcClient.top - pwnd->rcClient.top));
            }

            pwndChild = pwndChild->spwndNext;
        }

        ThreadUnlock(&tlpwndChild);
    }

    if (fHideCaret) {

        /*
         * Show the caret again.
         */
        zzzInternalShowCaret();
    }

    /*
     * Return the region code.
     */
    return code;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\security.c ===
/**************************** Module Header ********************************\
* Module Name: security.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Securable Object Routines
*
* History:
* 12-31-90 JimA       Created.
* 04-14-92 RichardW   Changed ACE_HEADER
\***************************************************************************/

#define _SECURITY 1
#include "precomp.h"
#pragma hdrstop

#pragma alloc_text(INIT, InitSecurity)

/*
 * General security stuff
 */
PSECURITY_DESCRIPTOR gpsdInitWinSta;

PRIVILEGE_SET psTcb = { 1, PRIVILEGE_SET_ALL_NECESSARY,
    { SE_TCB_PRIVILEGE, 0 }
};

/***************************************************************************\
* AllocAce
*
* Allocates and initializes an ACE list.
*
* History:
* 04-25-91 JimA         Created.
\***************************************************************************/

PACCESS_ALLOWED_ACE AllocAce(
    PACCESS_ALLOWED_ACE pace,
    BYTE bType,
    BYTE bFlags,
    ACCESS_MASK am,
    PSID psid,
    LPDWORD lpdwLength)
{
    PACCESS_ALLOWED_ACE paceNew;
    DWORD iEnd;
    DWORD dwLength, dwLengthSid;

    /*
     * Allocate space for the ACE.
     */
    dwLengthSid = RtlLengthSid(psid);
    dwLength = dwLengthSid + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
    if (pace == NULL) {
        iEnd = 0;
        pace = UserAllocPoolWithQuota(dwLength, TAG_SECURITY);
        if (pace == NULL)
            return NULL;
    } else {
        iEnd = *lpdwLength;
        paceNew = UserAllocPoolWithQuota(iEnd + dwLength, TAG_SECURITY);
        if (paceNew == NULL)
            return NULL;
        RtlCopyMemory(paceNew, pace, iEnd);
        UserFreePool(pace);
        pace = paceNew;
    }
    *lpdwLength = dwLength + iEnd;

    /*
     * Insert the new ACE.
     */
    paceNew = (PACCESS_ALLOWED_ACE)((PBYTE)pace + iEnd);
    paceNew->Header.AceType = bType;
    paceNew->Header.AceSize = (USHORT)dwLength;
    paceNew->Header.AceFlags = bFlags;
    paceNew->Mask = am;
    RtlCopySid(dwLengthSid, &paceNew->SidStart, psid);
    return pace;
}

/***************************************************************************\
* CreateSecurityDescriptor
*
* Allocates and initializes a security descriptor.
*
* History:
* 04-25-91 JimA         Created.
\***************************************************************************/

PSECURITY_DESCRIPTOR CreateSecurityDescriptor(
    PACCESS_ALLOWED_ACE paceList,
    DWORD cbAce,
    BOOLEAN fDaclDefaulted)
{
    PSECURITY_DESCRIPTOR psd;
    PACL pacl;
    NTSTATUS Status;

    /*
     * Allocate the security descriptor
     */
    psd = (PSECURITY_DESCRIPTOR)UserAllocPoolWithQuota(
            cbAce + sizeof(ACL) + SECURITY_DESCRIPTOR_MIN_LENGTH,
            TAG_SECURITY);
    if (psd == NULL)
        return NULL;
    RtlCreateSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION);

    /*
     * Initialize the ACL
     */
    pacl = (PACL)((PBYTE)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);
    Status = RtlCreateAcl(pacl, sizeof(ACL) + cbAce, ACL_REVISION);
    if (NT_SUCCESS(Status)) {

        /*
         * Add the ACEs to the ACL.
         */
        Status = RtlAddAce(pacl, ACL_REVISION, MAXULONG, paceList, cbAce);
        if (NT_SUCCESS(Status)) {

            /*
             * Initialize the SD
             */
            Status = RtlSetDaclSecurityDescriptor(psd, (BOOLEAN)TRUE,
                    pacl, fDaclDefaulted);
            RtlSetSaclSecurityDescriptor(psd, (BOOLEAN)FALSE, NULL,
                    (BOOLEAN)FALSE);
            RtlSetOwnerSecurityDescriptor(psd, NULL, (BOOLEAN)FALSE);
            RtlSetGroupSecurityDescriptor(psd, NULL, (BOOLEAN)FALSE);
        }
    }

    if (!NT_SUCCESS(Status)) {
        UserFreePool(psd);
        return NULL;
    }

    return psd;
}

/***************************************************************************\
* InitSecurity
*
* Initialize global security information.
*
* History:
* 01-29-91 JimA         Created.
\***************************************************************************/

BOOL InitSecurity(
    VOID)
{
    PACCESS_ALLOWED_ACE paceList = NULL, pace;
    DWORD dwLength;

    /*
     * Get access to exported constants
     */
    //SeEnableAccessToExports();

    /*
     * Create ACE list.
     */
    paceList = AllocAce(NULL,
            ACCESS_ALLOWED_ACE_TYPE,
            CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE | NO_PROPAGATE_INHERIT_ACE,
            WinStaMapping.GenericAll,
            SeExports->SeWorldSid,
            &dwLength);
    if (paceList == NULL)
        return FALSE;

    pace = AllocAce(paceList,
            ACCESS_ALLOWED_ACE_TYPE,
            CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE | NO_PROPAGATE_INHERIT_ACE,
            WinStaMapping.GenericAll,
            SeExports->SeRestrictedSid,
            &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE,
            GENERIC_ALL, SeExports->SeWorldSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE,
            GENERIC_ALL, SeExports->SeRestrictedSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            0, DIRECTORY_QUERY | DIRECTORY_CREATE_OBJECT,
            SeExports->SeAliasAdminsSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            0, DIRECTORY_TRAVERSE, SeExports->SeWorldSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    pace = AllocAce(paceList, ACCESS_ALLOWED_ACE_TYPE,
            0, DIRECTORY_TRAVERSE, SeExports->SeRestrictedSid, &dwLength);
    if (pace == NULL) {
        UserFreePool(paceList);
        return FALSE;
    }
    paceList = pace;

    /*
     * Create the SD
     */
    gpsdInitWinSta = CreateSecurityDescriptor(paceList, dwLength, FALSE);
    UserFreePool(paceList);

    if (gpsdInitWinSta == NULL) {
        RIPMSG0(RIP_WARNING, "Initial windowstation security was not created!");
    }

    return (BOOL)(gpsdInitWinSta != NULL);
}


/***************************************************************************\
* TestForInteractiveUser
*
* Returns STATUS_SUCCESS if the LUID passed represents an
* interactiveUser user logged on by winlogon, otherwise FALSE
*
* History:
* 03-08-95 JimA         Created.
\***************************************************************************/

NTSTATUS
TestForInteractiveUser(
    PLUID pluidCaller
    )
{
    PWINDOWSTATION pwinsta;

    UserAssert(grpWinStaList != NULL);

    /*
     * !!!
     *
     * This relies on the fact that there is only ONE interactive
     * windowstation and that it is the first one in the list.
     * If multiple windowstations are ever supported
     * a lookup will have to be done here.
     */
    pwinsta = grpWinStaList;

    /*
     * Compare it with the id of the logged on user.
     */
    if (RtlEqualLuid(pluidCaller, &pwinsta->luidUser))
        return STATUS_SUCCESS;
    else
        return STATUS_ACCESS_DENIED;
}



/***************************************************************************\
* _UserTestForWinStaAccess
*
* Returns STATUS_SUCCESS if the current user has GENERIC_EXECUTE access on
*  WindowStation pstrWinSta
*
*
* History:
* 06-05-96  Created     SalimC
\***************************************************************************/
NTSTATUS
_UserTestForWinStaAccess(
    PUNICODE_STRING pstrWinSta,
    BOOL fInherit
    )
{
    PTOKEN_STATISTICS   pStats;
    ULONG               BytesRequired;
    PWINDOWSTATION      pwinsta;
    HWINSTA             hwsta = NULL;
    POBJECT_ATTRIBUTES  pObjAttr = NULL;
    PUNICODE_STRING     pstrStatic;
    NTSTATUS            Status =  STATUS_SUCCESS;
    SIZE_T              cbObjA;
    UNICODE_STRING      strDefWinSta;
    HANDLE              htoken;
    BOOLEAN             fDefWinSta;

    CheckCritIn();

    UserAssert(NtCurrentTeb());
#if DBG
        try {
            UserAssert(pstrWinSta->Buffer == NtCurrentTeb()->StaticUnicodeBuffer);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }
#endif

    /*
     * If we are testing against Default WindowStation (WinSta0) retreive
     * pwinsta from the top of the grpwinstaList instead of doing an
     * OpenWindowStation()
     *
     * !!!
     *
     * This relies on the fact that there is only ONE interactive
     * windowstation and that it is the first one in the list.
     * If multiple windowstations are ever supported
     * a lookup will have to be done instead.
     */
    RtlInitUnicodeString(&strDefWinSta, DEFAULT_WINSTA);

    try {
        fDefWinSta = RtlEqualUnicodeString(pstrWinSta, &strDefWinSta, TRUE);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return GetExceptionCode();
    }
    if (fDefWinSta) {


        if (!NT_SUCCESS(Status = OpenEffectiveToken(&htoken))) {
            return Status;
        }

        Status = ZwQueryInformationToken(
                     htoken,                 // Handle
                     TokenStatistics,           // TokenInformationClass
                     NULL,                      // TokenInformation
                     0,                         // TokenInformationLength
                     &BytesRequired             // ReturnLength
                     );

        if (Status != STATUS_BUFFER_TOO_SMALL) {
            ZwClose(htoken);
            return Status;
        }

        //
        // Allocate space for the user info
        //

        pStats = (PTOKEN_STATISTICS)UserAllocPoolWithQuota(BytesRequired, TAG_SECURITY);
        if (pStats == NULL) {
            Status = STATUS_NO_MEMORY;
            ZwClose(htoken);
            return Status;
        }

        //
        // Read in the user info
        //

        if (!NT_SUCCESS(Status = ZwQueryInformationToken(
                     htoken,             // Handle
                     TokenStatistics,       // TokenInformationClass
                     pStats,                // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     ))) {
            ZwClose(htoken);
            UserFreePool(pStats);
            return Status;
        }

        /*
         * Make sure that current process has access to this window station
         */
        Status = STATUS_ACCESS_DENIED;

        if (grpWinStaList != NULL) {

            /*
             * !!!
             *
             * This relies on the fact that there is only ONE interactive
             * windowstation and that it is the first one in the list.
             * If multiple windowstations are ever supported
             * a lookup will have to be done here.
             */
            pwinsta = grpWinStaList;

            /*
             * For now we will just do the user luid test till we figure out
             * what fInherit means for a Multi-User system
             */
            if (fInherit) {
                if ( (RtlEqualLuid(&pStats->AuthenticationId, &pwinsta->luidUser)) ||
                     (RtlEqualLuid(&pStats->AuthenticationId, &luidSystem)) ||
                     (AccessCheckObject(pwinsta, GENERIC_EXECUTE, UserMode, &WinStaMapping)) )  {
                   Status = STATUS_SUCCESS;
                }
            } else {
                /* Bug 42905. Service Controller clears the flag
                 * ScStartupInfo.dwFlags &= (~STARTF_DESKTOPINHERIT) to make services
                 * running under the context of system non-interactive. Hence if fInherit
                 * is false don't do the SystemLuid and AccessCheckObject tests.
                 */

                if (RtlEqualLuid(&pStats->AuthenticationId, &pwinsta->luidUser)) {
                   Status = STATUS_SUCCESS;
                }
            }
        }

        ZwClose(htoken);
        UserFreePool(pStats);
        return Status;
    }

    /*
     * Since we don't have a pointer to the WindowStation Object we will do
     * a OpenWindowStation() to make sure we have the desired access.
     */
    cbObjA = sizeof(*pObjAttr) + sizeof(*pstrStatic);
    Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
            &pObjAttr, 0, &cbObjA, MEM_COMMIT, PAGE_READWRITE);
    pstrStatic = (PUNICODE_STRING)((PBYTE)pObjAttr + sizeof(*pObjAttr));

    if (NT_SUCCESS(Status)) {

        /*
         * Note -- the string must be in client-space or the
         * address validation in OpenWindowStation will fail.
         *
         * This code is called from xxxResolveDesktop and the buffer of the passed-in string
         * is in the teb already.
         */
        try {
            *pstrStatic = *pstrWinSta;
            InitializeObjectAttributes( pObjAttr,
                                        pstrStatic,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL
                                        );
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            Status = GetExceptionCode();
        }

        if (NT_SUCCESS(Status)) {
            hwsta = _OpenWindowStation(pObjAttr, GENERIC_EXECUTE, UserMode);
        }
    } else {
        return Status;
    }

    if (pObjAttr != NULL) {
        ZwFreeVirtualMemory(NtCurrentProcess(), &pObjAttr, &cbObjA,
                        MEM_RELEASE);
    }

    if (!hwsta) {
        return STATUS_ACCESS_DENIED;
    }

    Status = ZwClose(hwsta);

    UserAssert(NT_SUCCESS(Status));
    return Status;
}
/***************************************************************************\
* CheckGrantedAccess
*
* Confirms all requested accesses are granted and sets error status.
*
* History:
* 06-26-95 JimA       Created.
\***************************************************************************/

BOOL CheckGrantedAccess(
    ACCESS_MASK amGranted,
    ACCESS_MASK amRequest)
{

    /*
     * Check the granted access.
     */
    if (!RtlAreAllAccessesGranted(amGranted, amRequest)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "");
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* CheckWinstaWriteAttributesAccess
*
* Checks if the current process has WINSTA_WRITEATTRIBUTES access
* to its windowstation, and whether that windowstation is an
* interactive windowstation.
*
* History:
* 06-Jun-1996 adams     Created.
\***************************************************************************/
BOOL CheckWinstaWriteAttributesAccess(
    VOID)
{
    PPROCESSINFO ppiCurrent = PpiCurrent();

    /*
     * winlogon has rights to all windowstations.
     */
    if (PsGetCurrentProcessId() == gpidLogon)
        return TRUE;

    if (!(ppiCurrent->W32PF_Flags & W32PF_IOWINSTA)) {
        RIPERR0(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION,
                RIP_WARNING,
                "Operation invalid on a non-interactive WindowStation.");

        return FALSE;
    }

    if (!RtlAreAllAccessesGranted(ppiCurrent->amwinsta, WINSTA_WRITEATTRIBUTES)) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "WINSTA_WRITEATTRIBUTES access to WindowStation denied.");

        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* AccessCheckObject
*
* Performs an access check on an object
*
* History:
* 12-31-90 JimA       Created.
\***************************************************************************/

BOOL AccessCheckObject(
    PVOID pobj,
    ACCESS_MASK amRequest,
    KPROCESSOR_MODE AccessMode,
    CONST GENERIC_MAPPING *pGenericMapping)
{
    NTSTATUS Status;
    ACCESS_STATE AccessState;
    BOOLEAN fAccessGranted;
    AUX_ACCESS_DATA AuxData;
    BOOLEAN bMutexLocked = (pGenericMapping == (&KeyMapping));
    /*
     * Due to a resource problem in the object manager, we must pass in a TRUE
     * when checking access for registry keys, even if we do not explicitly have
     * the object type mutex.  If we do not, we can get into a deadlock situation with this mutex
     * and the CmpRegistry lock.
     */

    SeCreateAccessState(&AccessState, &AuxData, amRequest, (PGENERIC_MAPPING)pGenericMapping);
    fAccessGranted = ObCheckObjectAccess(
            pobj,
            &AccessState,
            bMutexLocked,
            AccessMode,
            &Status);
    SeDeleteAccessState(&AccessState);
    return (BOOL)(fAccessGranted == TRUE);
}

/***************************************************************************\
* IsPrivileged
*
* Check to see if the client has the specified privileges
*
* History:
* 01-02-91 JimA       Created.
\***************************************************************************/

BOOL IsPrivileged(
    PPRIVILEGE_SET ppSet)
{
    SECURITY_SUBJECT_CONTEXT Context;
    BOOLEAN bHeld;

    SeCaptureSubjectContext(&Context);
    SeLockSubjectContext(&Context);

    bHeld = SePrivilegeCheck(ppSet, &Context, UserMode);
    SePrivilegeObjectAuditAlarm(NULL, &Context, 0, ppSet, bHeld, UserMode);

    SeUnlockSubjectContext(&Context);
    SeReleaseSubjectContext(&Context);

    if (!bHeld)
        RIPERR0(ERROR_PRIVILEGE_NOT_HELD, RIP_VERBOSE, "");

    /*
     * Return result of privilege check
     */
    return (BOOL)bHeld;
}

/***************************************************************************\
* _GetUserObjectInformation (API)
*
* Gets information about a secure USER object
*
* History:
* 04-25-94 JimA       Created.
\***************************************************************************/

BOOL _GetUserObjectInformation(
    HANDLE h,
    int nIndex,
    PVOID ccxpvInfo,
    DWORD nLength,
    LPDWORD lpnLengthNeeded)
{
    PUSEROBJECTFLAGS puof;
    BOOL fSuccess = TRUE;
    PVOID pObject;
    POBJECT_HEADER pHead;
    DWORD dwLengthNeeded = 0;
    OBJECT_HANDLE_INFORMATION ohi;
    PUNICODE_STRING pstrInfo;
    PWINDOWSTATION pwinsta;
    NTSTATUS Status;

    /*
     * Validate the object
     */
    Status = ObReferenceObjectByHandle(
            h,
            0,
            NULL,
            UserMode,   // this is always called from the client side
            &pObject,
            &ohi);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "ObReferenceObjectByHandle Failed");
        return FALSE;
    }

    pHead = OBJECT_TO_OBJECT_HEADER(pObject);
    if (pHead->Type != *ExWindowStationObjectType &&
            pHead->Type != *ExDesktopObjectType) {
        RIPERR0(ERROR_INVALID_FUNCTION, RIP_WARNING, "Object is not a USER object");
        ObDereferenceObject(pObject);
        return FALSE;
    }

#ifdef LOGDESKTOPLOCKS
    if (OBJECT_TO_OBJECT_HEADER(pObject)->Type == *ExDesktopObjectType) {
        LogDesktop(pObject, LD_REF_FN_GETUSEROBJECTINFORMATION, TRUE, (ULONG_PTR)PtiCurrentShared());
    }
#endif

    try {
        switch (nIndex) {
        case UOI_FLAGS:
            dwLengthNeeded = sizeof(USEROBJECTFLAGS);
            if (nLength < sizeof(USEROBJECTFLAGS)) {
                RIPERR0(ERROR_INSUFFICIENT_BUFFER, RIP_VERBOSE, "");
                fSuccess = FALSE;
                break;
            }
            puof = ccxpvInfo;
            puof->fInherit = (ohi.HandleAttributes & OBJ_INHERIT) ? TRUE : FALSE;
            puof->fReserved = 0;
            puof->dwFlags = 0;
            if (pHead->Type == *ExDesktopObjectType) {
                if (CheckHandleFlag(NULL, ((PDESKTOP)pObject)->dwSessionId, h, HF_DESKTOPHOOK)) {
                    puof->dwFlags |= DF_ALLOWOTHERACCOUNTHOOK;
                }
            } else {
                if (!(((PWINDOWSTATION)pObject)->dwWSF_Flags & WSF_NOIO))
                    puof->dwFlags |= WSF_VISIBLE;
            }
            break;

        case UOI_NAME:
            pstrInfo = POBJECT_NAME(pObject);
            goto docopy;

        case UOI_TYPE:
            pstrInfo = &pHead->Type->Name;
docopy:
            if (pstrInfo) {
                dwLengthNeeded = pstrInfo->Length + sizeof(WCHAR);
                if (dwLengthNeeded > nLength) {
                    RIPERR0(ERROR_INSUFFICIENT_BUFFER, RIP_VERBOSE, "");
                    fSuccess = FALSE;
                    break;
                }
                RtlCopyMemory(ccxpvInfo, pstrInfo->Buffer, pstrInfo->Length);
                *(PWCHAR)((PBYTE)ccxpvInfo + pstrInfo->Length) = 0;
            } else {
                dwLengthNeeded = 0;
            }
            break;

        case UOI_USER_SID:
            if (pHead->Type == *ExWindowStationObjectType)
                pwinsta = pObject;
            else
                pwinsta = ((PDESKTOP)pObject)->rpwinstaParent;
            if (pwinsta->psidUser == NULL) {
                dwLengthNeeded = 0;
            } else {
                dwLengthNeeded = RtlLengthSid(pwinsta->psidUser);
                if (dwLengthNeeded > nLength) {
                    RIPERR0(ERROR_INSUFFICIENT_BUFFER, RIP_VERBOSE, "");
                    fSuccess = FALSE;
                    break;
                }
                RtlCopyMemory(ccxpvInfo, pwinsta->psidUser, dwLengthNeeded);
            }
            break;

        default:
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            fSuccess = FALSE;
            break;
        }
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        fSuccess = FALSE;
    }

    *lpnLengthNeeded = dwLengthNeeded;

#ifdef LOGDESKTOPLOCKS
    if (OBJECT_TO_OBJECT_HEADER(pObject)->Type == *ExDesktopObjectType) {
        LogDesktop(pObject, LD_DEREF_FN_GETUSEROBJECTINFORMATION, FALSE, (ULONG_PTR)PtiCurrentShared());
    }
#endif

    ObDereferenceObject(pObject);

    return fSuccess;
}

/***************************************************************************\
* _SetUserObjectInformation (API)
*
* Sets information about a secure USER object
*
* History:
* 04-25-94 JimA       Created.
\***************************************************************************/

BOOL _SetUserObjectInformation(
    HANDLE h,
    int nIndex,
    PVOID ccxpvInfo,
    DWORD nLength)
{
    PUSEROBJECTFLAGS puof;
    BOOL fSuccess = TRUE;
    PVOID pObject;
    POBJECT_HEADER pHead;
    DWORD dwLengthNeeded = 0;
    OBJECT_HANDLE_INFORMATION ohi;
    OBJECT_HANDLE_FLAG_INFORMATION ofi;
    NTSTATUS Status;

    /*
     * Validate the object
     */
    Status = ObReferenceObjectByHandle(
            h,
            0,
            NULL,
            UserMode,   // this is always called from the client side
            &pObject,
            &ohi);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "ObReferenceObjectByHandle Failed");
        return FALSE;
    }

    pHead = OBJECT_TO_OBJECT_HEADER(pObject);
    if (pHead->Type != *ExWindowStationObjectType &&
            pHead->Type != *ExDesktopObjectType) {
        RIPERR0(ERROR_INVALID_FUNCTION, RIP_WARNING, "Object is not a USER object");
        ObDereferenceObject(pObject);
        return FALSE;
    }

#ifdef LOGDESKTOPLOCKS
    if (OBJECT_TO_OBJECT_HEADER(pObject)->Type == *ExDesktopObjectType) {
        LogDesktop(pObject, LD_REF_FN_SETUSEROBJECTINFORMATION, TRUE, (ULONG_PTR)PtiCurrent());
    }
#endif

    try {
        switch (nIndex) {
        case UOI_FLAGS:
            if (nLength < sizeof(USEROBJECTFLAGS)) {
                RIPERR0(ERROR_INVALID_DATA, RIP_VERBOSE, "");
                fSuccess = FALSE;
                break;
            }
            puof = ccxpvInfo;
            ZwQueryObject(h, ObjectHandleFlagInformation,
                    &ofi, sizeof(ofi), NULL);
            ofi.Inherit = (puof->fInherit != FALSE);
            ZwSetInformationObject(h, ObjectHandleFlagInformation,
                    &ofi, sizeof(ofi));
            if (pHead->Type == *ExDesktopObjectType) {
                SetHandleFlag(h, HF_DESKTOPHOOK,
                        puof->dwFlags & DF_ALLOWOTHERACCOUNTHOOK);
            }
            break;
        default:
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            fSuccess = FALSE;
            break;
        }
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        fSuccess = FALSE;
    }

#ifdef LOGDESKTOPLOCKS
    if (OBJECT_TO_OBJECT_HEADER(pObject)->Type == *ExDesktopObjectType) {
        LogDesktop(pObject, LD_DEREF_FN_SETUSEROBJECTINFORMATION, FALSE, (ULONG_PTR)PtiCurrent());
    }
#endif

    ObDereferenceObject(pObject);

    return fSuccess;
}

/***************************************************************************\
* UserScreenAccessCheck
*
* Called from the engine to determine if the thread's desktop is
* active and the process has WINSTA_READSCREEN access.
*
* Note that we may or may not be in USER's critical section when this
* is called.  This is OK as long as we don't reference thing belonging
* to other threads.  If we did try to enter the critical section here,
* a deadlock may occur between the engine and user.
*
* History:
* 05-20-1993 JimA         Created.
* 11-22-1996 BradG        Brought back to life.
* 05-07-2001 JasonSch     CSRSS threads aren't always attached to a desktop,
*                         but they need to draw anyway (for console).
\***************************************************************************/

BOOL FASTCALL UserScreenAccessCheck(VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    UserAssert(ptiCurrent != NULL);

    return (ptiCurrent != NULL &&
            (ptiCurrent->rpdesk == grpdeskRitInput || (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) != 0) && 
            (W32GetCurrentProcess()->W32PF_Flags & (W32PF_READSCREENACCESSGRANTED | W32PF_IOWINSTA)) == (W32PF_READSCREENACCESSGRANTED | W32PF_IOWINSTA)
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains a random collection of support routines for the User
* API functions.  Many of these functions will be moved to more appropriate
* files once we get our act together.
*
* History:
* 10-17-90 DarrinM      Created.
* 02-06-91 IanJa        HWND revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* xxxUpdateWindows
*
* User mode wrapper
\***************************************************************************/

BOOL xxxUpdateWindows(PWND pwnd, HRGN hrgn)
{
    CheckLock(pwnd);

    xxxUpdateThreadsWindows(PtiCurrent(), pwnd, hrgn);

    /*
     * This function needs to return a value, since it is
     * called through NtUserCallHwndParam.
     */
    return TRUE;
}

/***************************************************************************\
* ValidateState
*
* States allowed to be set/cleared by Set/ClearWindowState. If you're
* allowing a new flag here, you must make sure it won't cause an AV
* in the kernel if someone sets it maliciously.
\***************************************************************************/

#define NUM_BYTES 16  // Window state bytes are 0 to F, explanation in user.h

CONST BYTE abValidateState[NUM_BYTES] = {
    0,      // 0
    0,      // 1
    0,      // 2
    0,      // 3
    0,      // 4
    LOBYTE(WFWIN40COMPAT),
    0,      // 6
    LOBYTE(WFNOANIMATE),
    0,      // 8
    LOBYTE(WEFEDGEMASK),
    LOBYTE(WEFSTATICEDGE),
    0,      // B
    LOBYTE(EFPASSWORD),
    LOBYTE(CBFHASSTRINGS | EFREADONLY),
    LOBYTE(WFTABSTOP | WFSYSMENU | WFVSCROLL | WFHSCROLL | WFBORDER),
    LOBYTE(WFCLIPCHILDREN)
};

BOOL ValidateState(DWORD dwFlags)
{
    BYTE bOffset = HIBYTE(dwFlags), bState = LOBYTE(dwFlags);

    if (bOffset > NUM_BYTES - 1)
        return FALSE;

    return ((bState & abValidateState[bOffset]) == bState);
}

/***************************************************************************\
* Set/ClearWindowState
*
* Wrapper functions for User mode to be able to set state fags
\***************************************************************************/

void SetWindowState(
    PWND pwnd,
    DWORD dwFlags)
{
    /*
     * Don't let anyone mess with someone else's window
     */
    if (GETPTI(pwnd)->ppi == PtiCurrent()->ppi) {
        if (ValidateState(dwFlags)) {
            SetWF(pwnd, dwFlags);
        } else {
            RIPMSG1(RIP_ERROR, "SetWindowState: invalid flag %x", dwFlags);
        }
    } else {
        RIPMSG1(RIP_WARNING, "SetWindowState: current ppi doesn't own pwnd %#p", pwnd);
    }

}

void ClearWindowState(
    PWND pwnd,
    DWORD dwFlags)
{
    /*
     * Don't let anyone mess with someone else's window
     */
    if (GETPTI(pwnd)->ppi == PtiCurrent()->ppi) {
        if (ValidateState(dwFlags)) {
            ClrWF(pwnd, dwFlags);
        } else {
            RIPMSG1(RIP_ERROR, "SetWindowState: invalid flag %x", dwFlags);
        }
    } else {
        RIPMSG1(RIP_WARNING, "ClearWindowState: current ppi doesn't own pwnd %#p", pwnd);
    }

}


/***************************************************************************\
* CheckPwndFilter
*
*
*
* History:
* 11-07-90 DarrinM      Translated Win 3.0 ASM code.
\***************************************************************************/

BOOL CheckPwndFilter(
    PWND pwnd,
    PWND pwndFilter)
{
    if ((pwndFilter == NULL) || (pwndFilter == pwnd) ||
            ((pwndFilter == (PWND)1) && (pwnd == NULL))) {
        return TRUE;
    }

    return _IsChild(pwndFilter, pwnd);
}


/***************************************************************************\
* AllocateUnicodeString
*
* History:
* 10-25-90 MikeHar      Wrote.
* 11-09-90 DarrinM      Fixed.
* 01-13-92 GregoryW     Neutralized.
* 03-05-98 FritzS       Only allocate Length+1
\***************************************************************************/

BOOL
AllocateUnicodeString(
    PUNICODE_STRING pstrDst,
    PUNICODE_STRING cczpstrSrc)
{
    if (cczpstrSrc == NULL) {
        RtlInitUnicodeString(pstrDst, NULL);
        return TRUE;
    }

    pstrDst->Buffer = UserAllocPoolWithQuota(cczpstrSrc->Length+sizeof(UNICODE_NULL), TAG_TEXT);
    if (pstrDst->Buffer == NULL) {
        return FALSE;
    }

    try {
        RtlCopyMemory(pstrDst->Buffer, cczpstrSrc->Buffer, cczpstrSrc->Length);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        UserFreePool(pstrDst->Buffer);
        pstrDst->Buffer = NULL;
        return FALSE;
    }
    pstrDst->MaximumLength = cczpstrSrc->Length+sizeof(UNICODE_NULL);
    pstrDst->Length = cczpstrSrc->Length;
    pstrDst->Buffer[pstrDst->Length / sizeof(WCHAR)] = 0;

    return TRUE;
}


/***************************************************************************\
* xxxGetControlColor
*
* <brief description>
*
* History:
* 02-12-92 JimA     Ported from Win31 sources
\***************************************************************************/

HBRUSH xxxGetControlColor(
    PWND pwndParent,
    PWND pwndCtl,
    HDC hdc,
    UINT message)
{
    HBRUSH hbrush;

    /*
     * If we're sending to a window of another thread, don't send this message
     * but instead call DefWindowProc().  New rule about the CTLCOLOR messages.
     * Need to do this so that we don't send an hdc owned by one thread to
     * another thread.  It is also a harmless change.
     */
    if (PpiCurrent() != GETPTI(pwndParent)->ppi) {
        return (HBRUSH)xxxDefWindowProc(pwndParent, message, (WPARAM)hdc, (LPARAM)HW(pwndCtl));
    }

    hbrush = (HBRUSH)xxxSendMessage(pwndParent, message, (WPARAM)hdc, (LPARAM)HW(pwndCtl));

    /*
     * If the brush returned from the parent is invalid, get a valid brush from
     * xxxDefWindowProc.
     */
    if ((hbrush == 0) || !GreValidateServerHandle(hbrush, BRUSH_TYPE)) {
#if DBG
        if (hbrush != 0)
            RIPMSG2(RIP_WARNING,
                    "Invalid HBRUSH from WM_CTLCOLOR*** msg %lX brush %lX", message, hbrush);
#endif
        hbrush = (HBRUSH)xxxDefWindowProc(pwndParent, message,
                (WPARAM)hdc, (LPARAM)pwndCtl);
    }

    return hbrush;
}


/***************************************************************************\
* xxxGetControlBrush
*
* <brief description>
*
* History:
* 12-10-90 IanJa   type replaced with new 32-bit message
* 01-21-91 IanJa   Prefix '_' denoting exported function (although not API)
\***************************************************************************/

HBRUSH xxxGetControlBrush(
    PWND pwnd,
    HDC hdc,
    UINT message)
{
    HBRUSH hbr;
    PWND pwndSend;
    TL tlpwndSend;

    CheckLock(pwnd);

    if ((pwndSend = (TestwndPopup(pwnd) ? pwnd->spwndOwner : pwnd->spwndParent))
         == NULL)
        pwndSend = pwnd;

    ThreadLock(pwndSend, &tlpwndSend);

    /*
     * Last parameter changes the message into a ctlcolor id.
     */
    hbr = xxxGetControlColor(pwndSend, pwnd, hdc, message);
    ThreadUnlock(&tlpwndSend);

    return hbr;
}

/***************************************************************************\
* xxxHardErrorControl
*
* Performs kernel-mode hard error support functions.
*
* History:
* 02-08-95 JimA         Created.
\***************************************************************************/

UINT xxxHardErrorControl(
    DWORD dwCmd,
    HANDLE handle,
    PDESKRESTOREDATA pdrdRestore)
{
    PTHREADINFO ptiClient, ptiCurrent = PtiCurrent();
    PDESKTOP pdesk;
    PUNICODE_STRING pstrName;
    NTSTATUS Status;
    PETHREAD Thread;
    BOOL fAllowForeground;

    /*
     * turn off BlockInput so the user can respond to the hard error popup
     */
    gptiBlockInput = NULL;

    UserAssert(ISCSRSS());
    switch (dwCmd) {
    case HardErrorSetup:

        /*
         * Don't do it if the system has not been initialized.
         */
        if (grpdeskRitInput == NULL) {
            RIPMSG0(RIP_WARNING, "HardErrorControl: System not initialized");
            return HEC_ERROR;
        }

        /*
         * Setup caller as the hard error handler.
         */
        if (gHardErrorHandler.pti != NULL) {
            RIPMSG1(RIP_WARNING, "HardErrorControl: pti not NULL %#p", gHardErrorHandler.pti);
            return HEC_ERROR;
        }

        /*
         * Mark the handler as active.
         */
        gHardErrorHandler.pti = ptiCurrent;

        /*
         * Clear any pending quits.
         */
        ptiCurrent->TIF_flags &= ~TIF_QUITPOSTED;

        break;

    case HardErrorCleanup:

        /*
         * Remove caller as the hard error handler.
         */
        if (gHardErrorHandler.pti != ptiCurrent)  {
            return HEC_ERROR;
        }

        gHardErrorHandler.pti = NULL;
        break;

    case HardErrorAttachUser:
    case HardErrorInDefDesktop:
        /*
         * Check for exit conditions. We do not allow attaches to the
         * disconnect desktop.
         */
        if (ISTS()) {
            if ((grpdeskRitInput == NULL) ||

                 ((grpdeskRitInput == gspdeskDisconnect) &&
                  (gspdeskShouldBeForeground == NULL)) ||

                 ((grpdeskRitInput == gspdeskDisconnect) &&
                  (gspdeskShouldBeForeground == gspdeskDisconnect))) {
                return HEC_ERROR;
            }
        }

        /*
         * Only attach to a user desktop.
         */
        if (ISTS() && grpdeskRitInput == gspdeskDisconnect) {
            pstrName = POBJECT_NAME(gspdeskShouldBeForeground);
        } else {
            pstrName = POBJECT_NAME(grpdeskRitInput);
        }

        if (pstrName && (!_wcsicmp(TEXT("Winlogon"), pstrName->Buffer) ||
                !_wcsicmp(TEXT("Disconnect"), pstrName->Buffer) ||
                !_wcsicmp(TEXT("Screen-saver"), pstrName->Buffer))) {
            RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "");
            return HEC_WRONGDESKTOP;
        }
        if (dwCmd == HardErrorInDefDesktop) {
            /*
             * Clear any pending quits.
             */
            ptiCurrent->TIF_flags &= ~TIF_QUITPOSTED;
            return HEC_SUCCESS;
        }


        /*
         * Fall through.
         */

    case HardErrorAttach:

        /*
         * Save a pointer to and prevent destruction of the
         * current queue.  This will give us a queue to return
         * to if journalling is occuring when we tear down the
         * hard error popup.
         */
        gHardErrorHandler.pqAttach = ptiCurrent->pq;
        (ptiCurrent->pq->cLockCount)++;

        /*
         * Fall through.
         */

    case HardErrorAttachNoQueue:

        /*
         * Check for exit conditions. We do not allow attaches to the
         * disconnect desktop.
         */
        if (ISTS()) {
            if ((grpdeskRitInput == NULL) ||

                 ((grpdeskRitInput == gspdeskDisconnect) &&
                  (gspdeskShouldBeForeground == NULL)) ||

                 ((grpdeskRitInput == gspdeskDisconnect) &&
                  (gspdeskShouldBeForeground == gspdeskDisconnect))) {
                return HEC_ERROR;
            }
        }

        /*
         * Attach the handler to the current desktop.
         */
        /*
         * Don't allow an attach to the disconnected desktop, but
         * remember this for later when we detach.
         */
        gbDisconnectHardErrorAttach = FALSE;

        if (ISTS() && grpdeskRitInput == gspdeskDisconnect) {
            pdesk = gspdeskShouldBeForeground;
            gbDisconnectHardErrorAttach = TRUE;
        } else {
            pdesk = grpdeskRitInput;
        }

        UserAssert(pdesk != NULL);

        Status = xxxSetCsrssThreadDesktop(pdesk, pdrdRestore);

        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "HardErrorControl: HardErrorAttachNoQueue failed:%#lx", Status);
            if (dwCmd != HardErrorAttachNoQueue) {
                gHardErrorHandler.pqAttach = NULL;
                UserAssert(ptiCurrent->pq->cLockCount);
                (ptiCurrent->pq->cLockCount)--;
            }
            return HEC_ERROR;
        }

        /*
         * Make sure we actually set the pdesk in the current thread
         */
        UserAssert(ptiCurrent->rpdesk != NULL);

        /*
         * Determine if this box can come to the foreground.
         * Let it come to the foreground if it doesn't have a pti
         * (it might have just failed to load).
         */
        fAllowForeground = FALSE;
        if (handle != NULL) {
            Status = ObReferenceObjectByHandle(handle,
                                                THREAD_QUERY_INFORMATION,
                                                *PsThreadType,
                                                UserMode,
                                                &Thread,
                                                NULL);
            if (NT_SUCCESS(Status)) {
                ptiClient = PtiFromThread(Thread);
                if ((ptiClient == NULL) || CanForceForeground(ptiClient->ppi)) {
                    fAllowForeground = TRUE;
                }

                UnlockThread(Thread);

            } else {
                RIPMSG2(RIP_WARNING, "HardErrorControl: HardErrorAttach failed to get thread (%#lx) pointer:%#lx", handle, Status);
            }
        }

        if (fAllowForeground) {
            ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxHardErrorControl set TIF %#lx", ptiCurrent);
        } else {
            ptiCurrent->TIF_flags &= ~TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxHardErrorControl clear TIF %#lx", ptiCurrent);
        }

        break;

    case HardErrorDetach:

        /*
         * xxxSwitchDesktop may have sent WM_QUIT to the msgbox, so
         * ensure that the quit flag is reset.
         */
        ptiCurrent->TIF_flags &= ~TIF_QUITPOSTED;

        /*
         * We will reset the hard-error queue to the pre-allocated
         * one so if we end up looping back (i.e. from a desktop
         * switch), we will have a valid queue in case the desktop
         * was deleted.
         */
        UserAssert(gHardErrorHandler.pqAttach->cLockCount);
        (gHardErrorHandler.pqAttach->cLockCount)--;

        DeferWinEventNotify();

        BEGINATOMICCHECK();

        if (ptiCurrent->pq != gHardErrorHandler.pqAttach) {
            UserAssert(gHardErrorHandler.pqAttach->cThreads == 0);
            AllocQueue(NULL, gHardErrorHandler.pqAttach);
            gHardErrorHandler.pqAttach->cThreads++;
            zzzAttachToQueue(ptiCurrent, gHardErrorHandler.pqAttach, NULL, FALSE);
        }

        gHardErrorHandler.pqAttach = NULL;

        ENDATOMICCHECK();

        zzzEndDeferWinEventNotify();

        /*
         * Fall through.
         */

    case HardErrorDetachNoQueue:
        /*
         * Detach the handler from the desktop and return
         * status to indicate if a switch has occured.
         */
        pdesk = ptiCurrent->rpdesk;
        xxxRestoreCsrssThreadDesktop(pdrdRestore);

        if (ISTS()) {
            /*
             * The hard error message box gets a desktop switch notification,
             * so remember that we lied to him and lie (or unlie) to him again.
             * A desktop switch did occur.
             */
            if (gbDisconnectHardErrorAttach) {
               gbDisconnectHardErrorAttach = FALSE;
               return HEC_DESKTOPSWITCH;
            }
#ifdef WAY_LATER
            /*
             * This happened once and caused a trap when a KeyEvent() came in and we
             * directed it to this queue.  I think this is a MS window that we caught
             * since we use this so much for license popup's.
             */
            if (gHardErrorHandler.pqAttach == gpqForeground) {
                gpqForeground = NULL;
            }
#endif
        }

        return (pdesk != grpdeskRitInput ? HEC_DESKTOPSWITCH : HEC_SUCCESS);
    }
    return HEC_SUCCESS;
}

#if 0 // not used anywhere (IanJa)
/***************************************************************************\
* VersionFromWindowFlag
*
* Returns the version of a window from its window state flags.
*
* History:
* 04-Apr-1997 adams     Created.
\***************************************************************************/

WORD
VersionFromWindowFlag(PWND pwnd)
{
    BYTE    bFlags = TestWF(pwnd, WFWINCOMPATMASK);
    if (bFlags == LOBYTE(WFWIN50COMPAT | WFWIN40COMPAT | WFWIN31COMPAT)) {
        return VER50;
    } else if (bFlags == LOBYTE(WFWIN40COMPAT | WFWIN31COMPAT)) {
        return VER40;
    } else if (bFlags == LOBYTE(WFWIN31COMPAT)) {
        return VER31;
    } else {
        return VER30;
    }
}
#endif // not used anywhere (IanJa)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\sbctl.c ===
/**************************** Module Header ********************************\
* Module Name: sbctl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Scroll bar internal routines
*
* History:
*   11/21/90 JimA      Created.
*   02-04-91 IanJa     Revalidaion added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

void CalcSBStuff(
    PWND pwnd,
    PSBCALC pSBCalc,
    BOOL fVert);

#define IsScrollBarControl(h) (GETFNID(h) == FNID_SCROLLBAR)

/*
 * Now it is possible to selectively Enable/Disable just one arrow of a Window
 * scroll bar; Various bits in the 7th word in the rgwScroll array indicates which
 * one of these arrows are disabled; The following masks indicate which bit of the
 * word indicates which arrow;
 */
#define WSB_HORZ_LF  0x0001  // Represents the Left arrow of the horizontal scroll bar.
#define WSB_HORZ_RT  0x0002  // Represents the Right arrow of the horizontal scroll bar.
#define WSB_VERT_UP  0x0004  // Represents the Up arrow of the vert scroll bar.
#define WSB_VERT_DN  0x0008  // Represents the Down arrow of the vert scroll bar.

#define WSB_VERT (WSB_VERT_UP | WSB_VERT_DN)
#define WSB_HORZ   (WSB_HORZ_LF | WSB_HORZ_RT)

void DrawCtlThumb(PSBWND);

/*
 * RETURN_IF_PSBTRACK_INVALID:
 * This macro tests whether the pSBTrack we have is invalid, which can happen
 * if it gets freed during a callback.
 * This protects agains the original pSBTrack being freed and no new one
 * being allocated or a new one being allocated at a different address.
 * This does not protect against the original pSBTrack being freed and a new
 * one being allocated at the same address.
 * If pSBTrack has changed, we assert that there is not already a new one
 * because we are really not expecting this.
 */
#define RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd) \
    if ((pSBTrack) != PWNDTOPSBTRACK(pwnd)) {      \
        UserAssert(PWNDTOPSBTRACK(pwnd) == NULL);  \
        return;                                    \
    }

/*
 * REEVALUATE_PSBTRACK
 * This macro just refreshes the local variable pSBTrack, in case it has
 * been changed during a callback.  After performing this operation, pSBTrack
 * should be tested to make sure it is not now NULL.
 */
#if DBG
#define REEVALUATE_PSBTRACK(pSBTrack, pwnd, str)          \
    if ((pSBTrack) != PWNDTOPSBTRACK(pwnd)) {             \
        RIPMSG3(RIP_VERBOSE,                              \
                "%s: pSBTrack changed from %#p to %#p",   \
                (str), (pSBTrack), PWNDTOPSBTRACK(pwnd)); \
    }                                                     \
    (pSBTrack) = PWNDTOPSBTRACK(pwnd)
#else
#define REEVALUATE_PSBTRACK(pSBTrack, pwnd, str)          \
    (pSBTrack) = PWNDTOPSBTRACK(pwnd)
#endif

/***************************************************************************\
* HitTestScrollBar
*
* 11/15/96      vadimg          ported from Memphis sources
\***************************************************************************/

int HitTestScrollBar(PWND pwnd, BOOL fVert, POINT pt)
{
    UINT wDisable;
    int px;
    BOOL fCtl = IsScrollBarControl(pwnd);
    SBCALC SBCalc, *pSBCalc;

    if (fCtl) {
        wDisable = ((PSBWND)pwnd)->wDisableFlags;
    } else {
        //
        // Reflect the click coordinates on the horizontal
        // scroll bar if the window is mirrored
        //
        if (TestWF(pwnd,WEFLAYOUTRTL) && !fVert) {
            pt.x = pwnd->rcWindow.right - pt.x;
        } else {
            pt.x -= pwnd->rcWindow.left;
        }

        pt.y -= pwnd->rcWindow.top;
        wDisable = GetWndSBDisableFlags(pwnd, fVert);
    }

    if ((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        return HTERROR;
    }

    if (fCtl) {
        pSBCalc = &(((PSBWND)pwnd)->SBCalc);
    } else {
        pSBCalc = &SBCalc;
        CalcSBStuff(pwnd, pSBCalc, fVert);
    }

    px = fVert ? pt.y : pt.x;

    if (px < pSBCalc->pxUpArrow) {
        if (wDisable & LTUPFLAG) {
            return HTERROR;
        }
        return HTSCROLLUP;
    } else if (px >= pSBCalc->pxDownArrow) {
        if (wDisable & RTDNFLAG) {
            return HTERROR;
        }
        return HTSCROLLDOWN;
    } else if (px < pSBCalc->pxThumbTop) {
        return HTSCROLLUPPAGE;
    } else if (px < pSBCalc->pxThumbBottom) {
        return HTSCROLLTHUMB;
    } else if (px < pSBCalc->pxDownArrow) {
        return HTSCROLLDOWNPAGE;
    }
    return HTERROR;
}

BOOL _SBGetParms(
    PWND pwnd,
    int code,
    PSBDATA pw,
    LPSCROLLINFO lpsi)
{
    PSBTRACK pSBTrack;

    pSBTrack = PWNDTOPSBTRACK(pwnd);


    if (lpsi->fMask & SIF_RANGE) {
        lpsi->nMin = pw->posMin;
        lpsi->nMax = pw->posMax;
    }

    if (lpsi->fMask & SIF_PAGE)
        lpsi->nPage = pw->page;

    if (lpsi->fMask & SIF_POS) {
        lpsi->nPos = pw->pos;
    }

    if (lpsi->fMask & SIF_TRACKPOS)
    {
        if (pSBTrack && (pSBTrack->nBar == code) && (pSBTrack->spwndTrack == pwnd)) {
            // posNew is in the context of psbiSB's window and bar code
            lpsi->nTrackPos = pSBTrack->posNew;
        } else {
            lpsi->nTrackPos = pw->pos;
        }
    }
    return ((lpsi->fMask & SIF_ALL) ? TRUE : FALSE);
}

/***************************************************************************\
* GetWndSBDisableFlags
*
* This returns the scroll bar Disable flags of the scroll bars of a
*  given Window.
*
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

UINT GetWndSBDisableFlags(
    PWND pwnd,  // The window whose scroll bar Disable Flags are to be returned;
    BOOL fVert)  // If this is TRUE, it means Vertical scroll bar.
{
    PSBINFO pw;

    if ((pw = pwnd->pSBInfo) == NULL) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    return (fVert ? (pw->WSBflags & WSB_VERT) >> 2 : pw->WSBflags & WSB_HORZ);
}


/***************************************************************************\
*  xxxEnableSBCtlArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar Control
*
* History:
* 04-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableSBCtlArrows(
    PWND pwnd,
    UINT wArrows)
{
    UINT wOldFlags;
    UINT wNewFlags;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    wOldFlags = ((PSBWND)pwnd)->wDisableFlags; // Get the original status

    if (wArrows == ESB_ENABLE_BOTH) {      // Enable both the arrows
        ((PSBWND)pwnd)->wDisableFlags &= ~SB_DISABLE_MASK;
    } else {
        ((PSBWND)pwnd)->wDisableFlags |= wArrows;
    }

    /*
     * Check if the status has changed because of this call
     */
    if (wOldFlags == ((PSBWND)pwnd)->wDisableFlags)
        return FALSE;

    /*
     * Else, redraw the scroll bar control to reflect the new state
     */
    if (IsVisible(pwnd))
        xxxInvalidateRect(pwnd, NULL, TRUE);

    wNewFlags = ((PSBWND)pwnd)->wDisableFlags;

    /*
     * state change notifications
     */
    if ((wOldFlags & ESB_DISABLE_UP) != (wNewFlags & ESB_DISABLE_UP)) {
        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_CLIENT,
                INDEX_SCROLLBAR_UP, WEF_USEPWNDTHREAD);
    }

    if ((wOldFlags & ESB_DISABLE_DOWN) != (wNewFlags & ESB_DISABLE_DOWN)) {
        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_CLIENT,
                INDEX_SCROLLBAR_DOWN, WEF_USEPWNDTHREAD);
    }

    return TRUE;
}


/***************************************************************************\
* xxxEnableWndSBArrows()
*
*  This function can be used to selectively Enable/Disable
*     the arrows of a Window Scroll bar(s)
*
* History:
*  4-18-91 MikeHar      Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableWndSBArrows(
    PWND pwnd,
    UINT wSBflags,
    UINT wArrows)
{
    INT wOldFlags;
    PSBINFO pw;
    BOOL bRetValue = FALSE;
    HDC hdc;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if ((pw = pwnd->pSBInfo) != NULL) {
        wOldFlags = pw->WSBflags;
    } else {

        /*
         * Originally everything is enabled; Check to see if this function is
         * asked to disable anything; Otherwise, no change in status; So, must
         * return immediately;
         */
        if(!wArrows)
            return FALSE;          // No change in status!

        wOldFlags = 0;    // Both are originally enabled;
        if((pw = _InitPwSB(pwnd)) == NULL)  // Allocate the pSBInfo for hWnd
            return FALSE;
    }


    if((hdc = _GetWindowDC(pwnd)) == NULL)
        return FALSE;

    /*
     *  First Take care of the Horizontal Scroll bar, if one exists.
     */
    if((wSBflags == SB_HORZ) || (wSBflags == SB_BOTH)) {
        if(wArrows == ESB_ENABLE_BOTH)      // Enable both the arrows
            pw->WSBflags &= ~SB_DISABLE_MASK;
        else
            pw->WSBflags |= wArrows;

        /*
         * Update the display of the Horizontal Scroll Bar;
         */
        if(pw->WSBflags != wOldFlags) {
            bRetValue = TRUE;
            wOldFlags = pw->WSBflags;
            if (TestWF(pwnd, WFHPRESENT) && !TestWF(pwnd, WFMINIMIZED) &&
                    IsVisible(pwnd)) {
                xxxDrawScrollBar(pwnd, hdc, FALSE);  // Horizontal Scroll Bar.
            }
        }
        // Left button
        if ((wOldFlags & ESB_DISABLE_LEFT) != (pw->WSBflags & ESB_DISABLE_LEFT)) {
            xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_HSCROLL,
                    INDEX_SCROLLBAR_UP, WEF_USEPWNDTHREAD);
        }

        // Right button
        if ((wOldFlags & ESB_DISABLE_RIGHT) != (pw->WSBflags & ESB_DISABLE_RIGHT)) {
            xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_HSCROLL,
                    INDEX_SCROLLBAR_DOWN, WEF_USEPWNDTHREAD);
        }
    }

    /*
     *  Then take care of the Vertical Scroll bar, if one exists.
     */
    if((wSBflags == SB_VERT) || (wSBflags == SB_BOTH)) {
        if(wArrows == ESB_ENABLE_BOTH)      // Enable both the arrows
            pw->WSBflags &= ~(SB_DISABLE_MASK << 2);
        else
            pw->WSBflags |= (wArrows << 2);

        /*
         * Update the display of the Vertical Scroll Bar;
         */
        if(pw->WSBflags != wOldFlags) {
            bRetValue = TRUE;
            if (TestWF(pwnd, WFVPRESENT) && !TestWF(pwnd, WFMINIMIZED) &&
                    IsVisible(pwnd)) {
                xxxDrawScrollBar(pwnd, hdc, TRUE);  // Vertical Scroll Bar
            }

            // Up button
            if ((wOldFlags & (ESB_DISABLE_UP << 2)) != (pw->WSBflags & (ESB_DISABLE_UP << 2))) {
                xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_VSCROLL,
                        INDEX_SCROLLBAR_UP, WEF_USEPWNDTHREAD);
            }

            // Down button
            if ((wOldFlags & (ESB_DISABLE_DOWN << 2)) != (pw->WSBflags & (ESB_DISABLE_DOWN << 2))) {
                xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_VSCROLL,
                        INDEX_SCROLLBAR_DOWN, WEF_USEPWNDTHREAD);
            }
        }
    }

    _ReleaseDC(hdc);

    return bRetValue;
}


/***************************************************************************\
* EnableScrollBar()
*
* This function can be used to selectively Enable/Disable
*     the arrows of a scroll bar; It could be used with Windows Scroll
*     bars as well as scroll bar controls
*
* History:
*  4-18-91 MikeHar Ported for the 31 merge
\***************************************************************************/

BOOL xxxEnableScrollBar(
    PWND pwnd,
    UINT wSBflags,  // Whether it is a Window Scroll Bar; if so, HORZ or VERT?
                    // Possible values are SB_HORZ, SB_VERT, SB_CTL or SB_BOTH
    UINT wArrows)   // Which arrows must be enabled/disabled:
                    // ESB_ENABLE_BOTH = > Enable both arrows.
                    // ESB_DISABLE_LTUP = > Disable Left/Up arrow;
                    // ESB_DISABLE_RTDN = > DIsable Right/Down arrow;
                    // ESB_DISABLE_BOTH = > Disable both the arrows;
{
#define ES_NOTHING 0
#define ES_DISABLE 1
#define ES_ENABLE  2
    UINT wOldFlags;
    UINT wEnableWindow;

    CheckLock(pwnd);

    if(wSBflags != SB_CTL) {
        return xxxEnableWndSBArrows(pwnd, wSBflags, wArrows);
    }

    /*
     *  Let us assume that we don't have to call EnableWindow
     */
    wEnableWindow = ES_NOTHING;

    wOldFlags = ((PSBWND)pwnd)->wDisableFlags & (UINT)SB_DISABLE_MASK;

    /*
     * Check if the present state of the arrows is exactly the same
     *  as what the caller wants:
     */
    if (wOldFlags == wArrows)
        return FALSE ;          // If so, nothing needs to be done;

    /*
     * Check if the caller wants to disable both the arrows
     */
    if (wArrows == ESB_DISABLE_BOTH) {
        wEnableWindow = ES_DISABLE;      // Yes! So, disable the whole SB Ctl.
    } else {

        /*
         * Check if the caller wants to enable both the arrows
         */
        if(wArrows == ESB_ENABLE_BOTH) {

            /*
             * We need to enable the SB Ctl only if it was already disabled.
             */
            if(wOldFlags == ESB_DISABLE_BOTH)
                wEnableWindow = ES_ENABLE;// EnableWindow(.., TRUE);
        } else {

            /*
             * Now, Caller wants to disable only one arrow;
             * Check if one of the arrows was already disabled and we want
             * to disable the other;If so, the whole SB Ctl will have to be
             * disabled; Check if this is the case:
             */
            if((wOldFlags | wArrows) == ESB_DISABLE_BOTH)
                wEnableWindow = ES_DISABLE;      // EnableWindow(, FALSE);
         }
    }
    if(wEnableWindow != ES_NOTHING) {

        /*
         * EnableWindow returns old state of the window; We must return
         * TRUE only if the Old state is different from new state.
         */
        if(xxxEnableWindow(pwnd, (BOOL)(wEnableWindow == ES_ENABLE))) {
            return !(TestWF(pwnd, WFDISABLED));
        } else {
            return TestWF(pwnd, WFDISABLED);
        }
    }

    return (BOOL)xxxSendMessage(pwnd, SBM_ENABLE_ARROWS, (DWORD)wArrows, 0);
#undef ES_NOTHING
#undef ES_DISABLE
#undef ES_ENABLE
}

/***************************************************************************\
*
*  DrawSize() -
*
\***************************************************************************/
void FAR DrawSize(PWND pwnd, HDC hdc, int cxFrame,int cyFrame)
{
    int     x, y;
    //HBRUSH  hbrSave;

    if (TestWF(pwnd, WEFLEFTSCROLL)) {
        x = cxFrame;
    } else {
        x = pwnd->rcWindow.right - pwnd->rcWindow.left - cxFrame - SYSMET(CXVSCROLL);
    }
    y = pwnd->rcWindow.bottom - pwnd->rcWindow.top  - cyFrame - SYSMET(CYHSCROLL);

    // If we have a scrollbar control, or the sizebox is not associated with
    // a sizeable window, draw the flat gray sizebox.  Otherwise, use the
    // sizing grip.
    if (IsScrollBarControl(pwnd))
    {
        if (TestWF(pwnd, SBFSIZEGRIP))
            goto DrawSizeGrip;
        else
            goto DrawBox;

    }
    else if (!SizeBoxHwnd(pwnd))
    {
DrawBox:
        {
            //hbrSave = GreSelectBrush(hdc, SYSHBR(3DFACE));
            //GrePatBlt(hdc, x, y, SYSMET(CXVSCROLL), SYSMET(CYHSCROLL), PATCOPY);
            //GreSelectBrush(hdc, hbrSave);

            POLYPATBLT PolyData;

            PolyData.x         = x;
            PolyData.y         = y;
            PolyData.cx        = SYSMET(CXVSCROLL);
            PolyData.cy        = SYSMET(CYHSCROLL);
            PolyData.BrClr.hbr = SYSHBR(3DFACE);

            GrePolyPatBlt(hdc,PATCOPY,&PolyData,1,PPB_BRUSH);

        }
    }
    else
    {
DrawSizeGrip:
        // Blt out the grip bitmap.
        BitBltSysBmp(hdc, x, y, TestWF(pwnd, WEFLEFTSCROLL) ? OBI_NCGRIP_L : OBI_NCGRIP);
    }
}

/***************************************************************************\
* xxxSelectColorObjects
*
*
*
* History:
\***************************************************************************/

HBRUSH xxxGetColorObjects(
    PWND pwnd,
    HDC hdc)
{
    HBRUSH hbrRet;

    CheckLock(pwnd);

    // Use the scrollbar color even if the scrollbar is disabeld.
    if (!IsScrollBarControl(pwnd))
        hbrRet = (HBRUSH)xxxDefWindowProc(pwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)HWq(pwnd));
    else {
        // B#12770 - GetControlBrush sends a WM_CTLCOLOR message to the
        // owner.  If the app doesn't process the message, DefWindowProc32
        // will always return the appropriate system brush. If the app.
        // returns an invalid object, GetControlBrush will call DWP for
        // the default brush. Thus hbrRet doesn't need any validation
        // here.
        hbrRet = xxxGetControlBrush(pwnd, hdc, WM_CTLCOLORSCROLLBAR);
    }

    return hbrRet;
}

/***************************************************************************\
*
*  DrawGroove()
*
*  Draws lines & middle of thumb groove
*  Note that pw points into prc.  Moreover, note that both pw & prc are
*  NEAR pointers, so *prc better not be on the stack.
*
\***************************************************************************/
void NEAR DrawGroove(HDC hdc, HBRUSH  hbr, LPRECT prc, BOOL fVert)
{
    if ((hbr == SYSHBR(3DHILIGHT)) || (hbr == gpsi->hbrGray))
        FillRect(hdc, prc, hbr);
    else
    {
        RECT    rc;

    // Draw sides
        CopyRect(&rc, prc);
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_ADJUST | BF_FLAT |
            (fVert ? BF_LEFT | BF_RIGHT : BF_TOP | BF_BOTTOM));

    // Fill middle
        FillRect(hdc, &rc, hbr);
    }
}

/***************************************************************************\
* CalcTrackDragRect
*
* Give the rectangle for a scrollbar in pSBTrack->pSBCalc,
* calculate pSBTrack->rcTrack, the rectangle where tracking
* may occur without cancelling the thumbdrag operation.
*
\***************************************************************************/

void CalcTrackDragRect(PSBTRACK pSBTrack) {

    int     cx;
    int     cy;
    LPINT   pwX, pwY;

    //
    // Point pwX and pwY at the parts of the rectangle
    // corresponding to pSBCalc->pxLeft, pxTop, etc.
    //
    // pSBTrack->pSBCalc->pxLeft is the left edge of a vertical
    // scrollbar and the top edge of horizontal one.
    // pSBTrack->pSBCalc->pxTop is the top of a vertical
    // scrollbar and the left of horizontal one.
    // etc...
    //
    // Point pwX and pwY to the corresponding parts
    // of pSBTrack->rcTrack.
    //

    pwX = pwY = (LPINT)&pSBTrack->rcTrack;

    if (pSBTrack->fTrackVert) {
        cy = SYSMET(CYVTHUMB);
        pwY++;
    } else {
        cy = SYSMET(CXHTHUMB);
        pwX++;
    }
    /*
     * Later5.0 GerardoB: People keep complaining about this tracking region
     *  being too narrow so let's make it wider while PM decides what to do
     *  about it.
     * We also used to have some hard coded min and max values but that should
     *  depend on some metric, if at all needed.
     */
    cx = (pSBTrack->pSBCalc->pxRight - pSBTrack->pSBCalc->pxLeft) * 8;
    cy *= 2;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft - cx;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop - cy;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight + cx;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom + cy;
}

void RecalcTrackRect(PSBTRACK pSBTrack) {
    LPINT pwX, pwY;
    RECT rcSB;


    if (!pSBTrack->fCtlSB)
        CalcSBStuff(pSBTrack->spwndTrack, pSBTrack->pSBCalc, pSBTrack->fTrackVert);

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    *(pwX + 0) = pSBTrack->pSBCalc->pxLeft;
    *(pwY + 0) = pSBTrack->pSBCalc->pxTop;
    *(pwX + 2) = pSBTrack->pSBCalc->pxRight;
    *(pwY + 2) = pSBTrack->pSBCalc->pxBottom;

    switch(pSBTrack->cmdSB) {
    case SB_LINEUP:
        *(pwY + 2) = pSBTrack->pSBCalc->pxUpArrow;
        break;
    case SB_LINEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    case SB_PAGEUP:
        *(pwY + 0) = pSBTrack->pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBTrack->pSBCalc->pxThumbTop;
        break;
    case SB_THUMBPOSITION:
        CalcTrackDragRect(pSBTrack);
        break;
    case SB_PAGEDOWN:
        *(pwY + 0) = pSBTrack->pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBTrack->pSBCalc->pxDownArrow;
        break;
    }

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }
}

/***************************************************************************\
* DrawThumb2
*
*
*
* History:
* 01-03-94  FritzS   Chicago changes
\***************************************************************************/

void DrawThumb2(
    PWND pwnd,
    PSBCALC pSBCalc,
    HDC hdc,
    HBRUSH hbr,
    BOOL fVert,
    UINT wDisable)  /* Disabled flags for the scroll bar */
{
    int    *pLength;
    int    *pWidth;
    RECT   rcSB;
    PSBTRACK pSBTrack;

    //
    // Bail out if the scrollbar has an empty rect
    //
    if ((pSBCalc->pxTop >= pSBCalc->pxBottom) || (pSBCalc->pxLeft >= pSBCalc->pxRight))
        return;
    pLength = (LPINT)&rcSB;
    if (fVert)
        pWidth = pLength++;
    else
        pWidth  = pLength + 1;

    pWidth[0] = pSBCalc->pxLeft;
    pWidth[2] = pSBCalc->pxRight;

    /*
     * If both scroll bar arrows are disabled, then we should not draw
     * the thumb.  So, quit now!
     */
    if (((wDisable & LTUPFLAG) && (wDisable & RTDNFLAG)) ||
        ((pSBCalc->pxDownArrow - pSBCalc->pxUpArrow) < pSBCalc->cpxThumb)) {
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxDownArrow;

        DrawGroove(hdc, hbr, &rcSB, fVert);
        return;
    }

    if (pSBCalc->pxUpArrow < pSBCalc->pxThumbTop) {
        // Fill in space above Thumb
        pLength[0] = pSBCalc->pxUpArrow;
        pLength[2] = pSBCalc->pxThumbTop;

        DrawGroove(hdc, hbr, &rcSB, fVert);
    }

    if (pSBCalc->pxThumbBottom < pSBCalc->pxDownArrow) {
        // Fill in space below Thumb
        pLength[0] = pSBCalc->pxThumbBottom;
        pLength[2] = pSBCalc->pxDownArrow;

        DrawGroove(hdc, hbr, &rcSB, fVert);
    }

    //
    // Draw elevator
    //
    pLength[0] = pSBCalc->pxThumbTop;
    pLength[2] = pSBCalc->pxThumbBottom;

    // Not soft!
    DrawPushButton(hdc, &rcSB, 0, 0);

    /*
     * If we're tracking a page scroll, then we've obliterated the hilite.
     * We need to correct the hiliting rectangle, and rehilite it.
     */
    pSBTrack = PWNDTOPSBTRACK(pwnd);

    if (pSBTrack && (pSBTrack->cmdSB == SB_PAGEUP || pSBTrack->cmdSB == SB_PAGEDOWN) &&
            (pwnd == pSBTrack->spwndTrack) &&
            (BOOL)pSBTrack->fTrackVert == fVert) {

        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        pLength = (int *)&pSBTrack->rcTrack;

        if (fVert)
            pLength++;

        if (pSBTrack->cmdSB == SB_PAGEUP)
            pLength[2] = pSBCalc->pxThumbTop;
        else
            pLength[0] = pSBCalc->pxThumbBottom;

        if (pLength[0] < pLength[2])
            InvertRect(hdc, &pSBTrack->rcTrack);
    }
}

/***************************************************************************\
* xxxDrawSB2
*
*
*
* History:
\***************************************************************************/

void xxxDrawSB2(
    PWND pwnd,
    PSBCALC pSBCalc,
    HDC hdc,
    BOOL fVert,
    UINT wDisable)
{

    int     cLength;
    int     cWidth;
    int     *pwX;
    int     *pwY;
    HBRUSH hbr;
    HBRUSH hbrSave;
    int cpxArrow;
    RECT    rc, rcSB;
    COLORREF crText, crBk;

    CheckLock(pwnd);

    cLength = (pSBCalc->pxBottom - pSBCalc->pxTop) / 2;
    cWidth = (pSBCalc->pxRight - pSBCalc->pxLeft);

    if ((cLength <= 0) || (cWidth <= 0)) {
        return;
    }
    if (fVert)
        cpxArrow = SYSMET(CYVSCROLL);
    else
        cpxArrow = SYSMET(CXHSCROLL);

    /*
     * Save background and DC color, since they get changed in
     * xxxGetColorObjects. Restore before we return.
     */
    crBk = GreGetBkColor(hdc);
    crText = GreGetTextColor(hdc);

    hbr = xxxGetColorObjects(pwnd, hdc);

    if (cLength > cpxArrow)
        cLength = cpxArrow;
    pwX = (int *)&rcSB;
    pwY = pwX + 1;
    if (!fVert)
        pwX = pwY--;

    pwX[0] = pSBCalc->pxLeft;
    pwY[0] = pSBCalc->pxTop;
    pwX[2] = pSBCalc->pxRight;
    pwY[2] = pSBCalc->pxBottom;

    hbrSave = GreSelectBrush(hdc, SYSHBR(BTNTEXT));

    //
    // BOGUS
    // Draw scrollbar arrows as disabled if the scrollbar itself is
    // disabled OR if the window it is a part of is disabled?
    //
    if (fVert) {
        if ((cLength == SYSMET(CYVSCROLL)) && (cWidth == SYSMET(CXVSCROLL))) {
            BitBltSysBmp(hdc, rcSB.left, rcSB.top, (wDisable & LTUPFLAG) ? OBI_UPARROW_I : OBI_UPARROW);
            BitBltSysBmp(hdc, rcSB.left, rcSB.bottom - cLength, (wDisable & RTDNFLAG) ? OBI_DNARROW_I : OBI_DNARROW);
        } else {
            CopyRect(&rc, &rcSB);
            rc.bottom = rc.top + cLength;
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLUP | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));

            rc.bottom = rcSB.bottom;
            rc.top = rcSB.bottom - cLength;
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLDOWN | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
    } else {
        if ((cLength == SYSMET(CXHSCROLL)) && (cWidth == SYSMET(CYHSCROLL))) {
            BitBltSysBmp(hdc, rcSB.left, rcSB.top, (wDisable & LTUPFLAG) ? OBI_LFARROW_I : OBI_LFARROW);
            BitBltSysBmp(hdc, rcSB.right - cLength, rcSB.top, (wDisable & RTDNFLAG) ? OBI_RGARROW_I : OBI_RGARROW);
        } else {
            CopyRect(&rc, &rcSB);
            rc.right = rc.left + cLength;
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLLEFT | ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));

            rc.right = rcSB.right;
            rc.left = rcSB.right - cLength;
            DrawFrameControl(hdc, &rc, DFC_SCROLL,
                DFCS_SCROLLRIGHT | ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
        }
    }

    hbrSave = GreSelectBrush(hdc, hbrSave);
    DrawThumb2(pwnd, pSBCalc, hdc, hbr, fVert, wDisable);
    GreSelectBrush(hdc, hbrSave);

    GreSetBkColor(hdc, crBk);
    GreSetTextColor(hdc, crText);
}

/***************************************************************************\
* zzzSetSBCaretPos
*
*
*
* History:
\***************************************************************************/

void zzzSetSBCaretPos(
    PSBWND psbwnd)
{

    if ((PWND)psbwnd == PtiCurrent()->pq->spwndFocus) {
        zzzSetCaretPos((psbwnd->fVert ? psbwnd->SBCalc.pxLeft : psbwnd->SBCalc.pxThumbTop) + SYSMET(CXEDGE),
                (psbwnd->fVert ? psbwnd->SBCalc.pxThumbTop : psbwnd->SBCalc.pxLeft) + SYSMET(CYEDGE));
    }
}

/***************************************************************************\
* CalcSBStuff2
*
*
*
* History:
\***************************************************************************/

void CalcSBStuff2(
    PSBCALC  pSBCalc,
    LPRECT lprc,
    CONST PSBDATA pw,
    BOOL fVert)
{
    int cpx;
    DWORD dwRange;
    int denom;

    if (fVert) {
        pSBCalc->pxTop = lprc->top;
        pSBCalc->pxBottom = lprc->bottom;
        pSBCalc->pxLeft = lprc->left;
        pSBCalc->pxRight = lprc->right;
        pSBCalc->cpxThumb = SYSMET(CYVSCROLL);
    } else {

        /*
         * For horiz scroll bars, "left" & "right" are "top" and "bottom",
         * and vice versa.
         */
        pSBCalc->pxTop = lprc->left;
        pSBCalc->pxBottom = lprc->right;
        pSBCalc->pxLeft = lprc->top;
        pSBCalc->pxRight = lprc->bottom;
        pSBCalc->cpxThumb = SYSMET(CXHSCROLL);
    }

    pSBCalc->pos = pw->pos;
    pSBCalc->page = pw->page;
    pSBCalc->posMin = pw->posMin;
    pSBCalc->posMax = pw->posMax;

    dwRange = ((DWORD)(pSBCalc->posMax - pSBCalc->posMin)) + 1;

    //
    // For the case of short scroll bars that don't have enough
    // room to fit the full-sized up and down arrows, shorten
    // their sizes to make 'em fit
    //
    cpx = min((pSBCalc->pxBottom - pSBCalc->pxTop) / 2, pSBCalc->cpxThumb);

    pSBCalc->pxUpArrow   = pSBCalc->pxTop    + cpx;
    pSBCalc->pxDownArrow = pSBCalc->pxBottom - cpx;

    if ((pw->page != 0) && (dwRange != 0)) {
        // JEFFBOG -- This is the one and only place where we should
        // see 'range'.  Elsewhere it should be 'range - page'.

        /*
         * The minimun thumb size used to depend on the frame/edge metrics.
         * People that increase the scrollbar width/height expect the minimun
         *  to grow with proportianally. So NT5 bases the minimun on
         *  CXH/YVSCROLL, which is set by default in cpxThumb.
         */
        /*
         * i is used to keep the macro "max" from executing EngMulDiv twice.
         */
        int i = EngMulDiv(pSBCalc->pxDownArrow - pSBCalc->pxUpArrow,
                                             pw->page, dwRange);
        pSBCalc->cpxThumb = max(pSBCalc->cpxThumb / 2, i);
    }

    pSBCalc->pxMin = pSBCalc->pxTop + cpx;
    pSBCalc->cpx = pSBCalc->pxBottom - cpx - pSBCalc->cpxThumb - pSBCalc->pxMin;

    denom = dwRange - (pw->page ? pw->page : 1);
    if (denom)
        pSBCalc->pxThumbTop = EngMulDiv(pw->pos - pw->posMin,
            pSBCalc->cpx, denom) +
            pSBCalc->pxMin;
    else
        pSBCalc->pxThumbTop = pSBCalc->pxMin - 1;

    pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;

}

/***************************************************************************\
* SBCtlSetup
*
*
*
* History:
\***************************************************************************/

void SBCtlSetup(
    PSBWND psbwnd)
{
    RECT rc;

    GetRect((PWND)psbwnd, &rc, GRECT_CLIENT | GRECT_CLIENTCOORDS);
    CalcSBStuff2(&psbwnd->SBCalc, &rc, (PSBDATA)&psbwnd->SBCalc, psbwnd->fVert);
}

/***************************************************************************\
* HotTrackSB
*
\***************************************************************************/

#ifdef COLOR_HOTTRACKING

DWORD GetTrackFlags(int ht, BOOL fDraw)
{
    if (fDraw) {
        switch(ht) {
        case HTSCROLLUP:
        case HTSCROLLUPPAGE:
            return LTUPFLAG;

        case HTSCROLLDOWN:
        case HTSCROLLDOWNPAGE:
            return RTDNFLAG;

        case HTSCROLLTHUMB:
            return LTUPFLAG | RTDNFLAG;

        default:
            return 0;
        }
    } else {
        return 0;
    }
}

BOOL xxxHotTrackSB(PWND pwnd, int htEx, BOOL fDraw)
{
    SBCALC SBCalc;
    HDC  hdc;
    BOOL fVert = HIWORD(htEx);
    int ht = LOWORD(htEx);
    DWORD dwTrack = GetTrackFlags(ht, fDraw);

    CheckLock(pwnd);

    /*
     * xxxDrawSB2 does not callback or leave the critical section when it's
     * not a SB control and the window belongs to a different thread. It
     * calls xxxDefWindowProc which simply returns the brush color.
     */
    CalcSBStuff(pwnd, &SBCalc, fVert);
    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    xxxDrawSB2(pwnd, &SBCalc, hdc, fVert, GetWndSBDisableFlags(pwnd, fVert), dwTrack);
    _ReleaseDC(hdc);
    return TRUE;
}

void xxxHotTrackSBCtl(PSBWND psbwnd, int ht, BOOL fDraw)
{
    DWORD dwTrack = GetTrackFlags(ht, fDraw);
    HDC hdc;

    CheckLock(psbwnd);

    SBCtlSetup(psbwnd);
    hdc = _GetDCEx((PWND)psbwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    xxxDrawSB2((PWND)psbwnd, &psbwnd->SBCalc, hdc, psbwnd->fVert, psbwnd->wDisableFlags, dwTrack);
    _ReleaseDC(hdc);
}
#endif // COLOR_HOTTRACKING

BOOL SBSetParms(PSBDATA pw, LPSCROLLINFO lpsi, LPBOOL lpfScroll, LPLONG lplres)
{
    // pass the struct because we modify the struct but don't want that
    // modified version to get back to the calling app

    BOOL fChanged = FALSE;

    if (lpsi->fMask & SIF_RETURNOLDPOS)
        // save previous position
        *lplres = pw->pos;

    if (lpsi->fMask & SIF_RANGE) {
        // if the range MAX is below the range MIN -- then treat is as a
        // zero range starting at the range MIN.
        if (lpsi->nMax < lpsi->nMin)
            lpsi->nMax = lpsi->nMin;

        if ((pw->posMin != lpsi->nMin) || (pw->posMax != lpsi->nMax)) {
            pw->posMin = lpsi->nMin;
            pw->posMax = lpsi->nMax;

            if (!(lpsi->fMask & SIF_PAGE)) {
                lpsi->fMask |= SIF_PAGE;
                lpsi->nPage = pw->page;
            }

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_PAGE) {
        DWORD dwMaxPage = (DWORD) abs(pw->posMax - pw->posMin) + 1;

        // Clip page to 0, posMax - posMin + 1

        if (lpsi->nPage > dwMaxPage)
            lpsi->nPage = dwMaxPage;


        if (pw->page != (int)(lpsi->nPage)) {
            pw->page = lpsi->nPage;

            if (!(lpsi->fMask & SIF_POS)) {
                lpsi->fMask |= SIF_POS;
                lpsi->nPos = pw->pos;
            }

            fChanged = TRUE;
        }
    }

    if (lpsi->fMask & SIF_POS) {
        int iMaxPos = pw->posMax - ((pw->page) ? pw->page - 1 : 0);
        // Clip pos to posMin, posMax - (page - 1).

        if (lpsi->nPos < pw->posMin)
            lpsi->nPos = pw->posMin;
        else if (lpsi->nPos > iMaxPos)
            lpsi->nPos = iMaxPos;


        if (pw->pos != lpsi->nPos) {
            pw->pos = lpsi->nPos;
            fChanged = TRUE;
        }
    }

    if (!(lpsi->fMask & SIF_RETURNOLDPOS)) {
        // Return the new position
        *lplres = pw->pos;
    }

    /*
     * This was added by JimA as Cairo merge but will conflict
     * with the documentation for SetScrollPos
     */
/*
    else if (*lplres == pw->pos)
        *lplres = 0;
*/
    if (lpsi->fMask & SIF_RANGE) {
        if (*lpfScroll = (pw->posMin != pw->posMax))
            goto checkPage;
    } else if (lpsi->fMask & SIF_PAGE)
checkPage:
        *lpfScroll = (pw->page <= (pw->posMax - pw->posMin));

    return fChanged;
}


/***************************************************************************\
* CalcSBStuff
*
*
*
* History:
\***************************************************************************/

void CalcSBStuff(
    PWND pwnd,
    PSBCALC pSBCalc,
    BOOL fVert)
{
    RECT    rcT;
    RECT    rcClient;
    int     cx, iTemp;

    //
    // Get client rectangle.  We know that scrollbars always align to the right
    // and to the bottom of the client area.
    //
    GetRect(pwnd, &rcClient, GRECT_CLIENT | GRECT_WINDOWCOORDS);
    
    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        cx             = pwnd->rcWindow.right - pwnd->rcWindow.left;
        iTemp          = rcClient.left;
        rcClient.left  = cx - rcClient.right;
        rcClient.right = cx - iTemp;
    }

    if (fVert) {
         // Only add on space if vertical scrollbar is really there.
        if (TestWF(pwnd, WEFLEFTSCROLL)) {
            rcT.right = rcT.left = rcClient.left;
            if (TestWF(pwnd, WFVPRESENT))
                rcT.left -= SYSMET(CXVSCROLL);
        } else {
            rcT.right = rcT.left = rcClient.right;
            if (TestWF(pwnd, WFVPRESENT))
                rcT.right += SYSMET(CXVSCROLL);
        }

        rcT.top = rcClient.top;
        rcT.bottom = rcClient.bottom;
    } else {
        // Only add on space if horizontal scrollbar is really there.
        rcT.bottom = rcT.top = rcClient.bottom;
        if (TestWF(pwnd, WFHPRESENT))
            rcT.bottom += SYSMET(CYHSCROLL);

        rcT.left = rcClient.left;
        rcT.right = rcClient.right;
    }

    // If InitPwSB stuff fails (due to our heap being full) there isn't anything reasonable
    // we can do here, so just let it go through.  We won't fault but the scrollbar won't work
    // properly either...
    if (_InitPwSB(pwnd))
        CalcSBStuff2(pSBCalc, &rcT, (fVert) ? &pwnd->pSBInfo->Vert :  &pwnd->pSBInfo->Horz, fVert);

}

/***************************************************************************\
*
*  DrawCtlThumb()
*
\***************************************************************************/
void DrawCtlThumb(PSBWND psb)
{
    HBRUSH  hbr, hbrSave;
    HDC     hdc = (HDC) _GetWindowDC((PWND) psb);

    SBCtlSetup(psb);

    hbrSave = GreSelectBrush(hdc, hbr = xxxGetColorObjects((PWND) psb, hdc));

    DrawThumb2((PWND) psb, &psb->SBCalc, hdc, hbr, psb->fVert, psb->wDisableFlags);

    GreSelectBrush(hdc, hbrSave);
    _ReleaseDC(hdc);
}


/***************************************************************************\
* xxxDrawThumb
*
*
*
* History:
\***************************************************************************/

void xxxDrawThumb(
    PWND pwnd,
    PSBCALC pSBCalc,
    BOOL fVert)
{
    HBRUSH hbr, hbrSave;
    HDC hdc;
    UINT wDisableFlags;
    SBCALC SBCalc;

    CheckLock(pwnd);

    if (!pSBCalc) pSBCalc = &SBCalc;
    hdc = (HDC)_GetWindowDC(pwnd);

    CalcSBStuff(pwnd, &SBCalc, fVert);
    wDisableFlags = GetWndSBDisableFlags(pwnd, fVert);

    hbrSave = GreSelectBrush(hdc, hbr = xxxGetColorObjects(pwnd, hdc));

    DrawThumb2(pwnd, &SBCalc, hdc, hbr, fVert, wDisableFlags);

    GreSelectBrush(hdc, hbrSave);

    /*
     * Won't hurt even if DC is already released (which happens automatically
     * if window is destroyed during xxxSelectColorObjects)
     */
    _ReleaseDC(hdc);
}

/***************************************************************************\
* xxxSetScrollBar
*
*
*
* History:
\***************************************************************************/

LONG xxxSetScrollBar(
    PWND pwnd,
    int code,
    LPSCROLLINFO lpsi,
    BOOL fRedraw)
{
    BOOL        fVert;
    PSBDATA pw;
    PSBINFO pSBInfo;
    BOOL fOldScroll;
    BOOL fScroll;
    WORD        wfScroll;
    LONG     lres;
    BOOL        fNewScroll;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if (fRedraw)
        // window must be visible to redraw
        fRedraw = IsVisible(pwnd);

    if (code == SB_CTL)
#ifdef FE_SB // xxxSetScrollBar()
        // scroll bar control; send the control a message
        if(GETPTI(pwnd)->TIF_flags & TIF_16BIT) {
            //
            // If the target application is 16bit apps, we don't pass win40's message.
            // This fix for Ichitaro v6.3. It eats the message. It never forwards
            // the un-processed messages to original windows procedure via
            // CallWindowProc().
            //
            // Is this from xxxSetScrollPos() ?
            if(lpsi->fMask == (SIF_POS|SIF_RETURNOLDPOS)) {
                return (int)xxxSendMessage(pwnd, SBM_SETPOS, lpsi->nPos, fRedraw);
            // Is this from xxxSetScrollRange() ?
            } else if(lpsi->fMask == SIF_RANGE) {
                xxxSendMessage(pwnd, SBM_SETRANGE, lpsi->nMin, lpsi->nMax);
                return TRUE;
            // Others...
            } else {
                return (LONG)xxxSendMessage(pwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
            }
        } else {
            return (LONG)xxxSendMessage(pwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
        }
#else
        // scroll bar control; send the control a message
        return (LONG)xxxSendMessage(pwnd, SBM_SETSCROLLINFO, (WPARAM) fRedraw, (LPARAM) lpsi);
#endif // FE_SB

    fVert = (code != SB_HORZ);

    wfScroll = (fVert) ? WFVSCROLL : WFHSCROLL;

    fScroll = fOldScroll = (TestWF(pwnd, wfScroll)) ? TRUE : FALSE;

    /*
     * Don't do anything if we're setting position of a nonexistent scroll bar.
     */
    if (!(lpsi->fMask & SIF_RANGE) && !fOldScroll && (pwnd->pSBInfo == NULL)) {
        RIPERR0(ERROR_NO_SCROLLBARS, RIP_VERBOSE, "");
        return 0;
    }

    if (fNewScroll = !(pSBInfo = pwnd->pSBInfo)) {
        if ((pSBInfo = _InitPwSB(pwnd)) == NULL)
            return 0;
    }

    pw = (fVert) ? &(pSBInfo->Vert) : &(pSBInfo->Horz);

    if (!SBSetParms(pw, lpsi, &fScroll, &lres) && !fNewScroll) {
        // no change -- but if REDRAW is specified and there's a scrollbar,
        // redraw the thumb
        if (fOldScroll && fRedraw)
            goto redrawAfterSet;

        return lres;
    }

    ClrWF(pwnd, wfScroll);

    if (fScroll)
        SetWF(pwnd, wfScroll);
    else if (!TestWF(pwnd, (WFHSCROLL | WFVSCROLL))) {
        // if neither scroll bar is set and both ranges are 0, then free up the
        // scroll info

        pSBInfo = pwnd->pSBInfo;

        if ((pSBInfo->Horz.posMin == pSBInfo->Horz.posMax) &&
            (pSBInfo->Vert.posMin == pSBInfo->Vert.posMax)) {
            DesktopFree(pwnd->head.rpdesk, (HANDLE)(pwnd->pSBInfo));
            pwnd->pSBInfo = NULL;
        }
    }

    if (lpsi->fMask & SIF_DISABLENOSCROLL) {
        if (fOldScroll) {
            SetWF(pwnd, wfScroll);
            xxxEnableWndSBArrows(pwnd, code, (fScroll) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
        }
    } else if (fOldScroll ^ fScroll) {
        PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);
        if (pSBTrack && (pwnd == pSBTrack->spwndTrack)) {
            pSBTrack->fTrackRecalc = TRUE;
        }
        xxxRedrawFrame(pwnd);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
        return lres;
    }

    if (fScroll && fRedraw && (fVert ? TestWF(pwnd, WFVPRESENT) : TestWF(pwnd, WFHPRESENT))) {
        PSBTRACK pSBTrack;
redrawAfterSet:
        xxxWindowEvent(EVENT_OBJECT_VALUECHANGE, pwnd, (fVert ? OBJID_VSCROLL : OBJID_HSCROLL),
                INDEX_SCROLLBAR_SELF, WEF_USEPWNDTHREAD);
        
        pSBTrack = PWNDTOPSBTRACK(pwnd);
        // Bail out if the caller is trying to change the position of
        // a scrollbar that is in the middle of tracking.  We'll hose
        // TrackThumb() otherwise.

        if (pSBTrack && (pwnd == pSBTrack->spwndTrack) &&
                ((BOOL)(pSBTrack->fTrackVert) == fVert) &&
                (pSBTrack->xxxpfnSB == xxxTrackThumb)) {
            return lres;
        }

        xxxDrawThumb(pwnd, NULL, fVert);
        // Note: after xxx, pSBTrack may no longer be valid (but we return now)
    }

    return lres;
}



/***************************************************************************\
* xxxDrawScrollBar
*
*
*
* History:
\***************************************************************************/

void xxxDrawScrollBar(
    PWND pwnd,
    HDC hdc,
    BOOL fVert)
{
    SBCALC SBCalc;
    PSBCALC pSBCalc;
    PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);

    CheckLock(pwnd);
    if (pSBTrack && (pwnd == pSBTrack->spwndTrack) && (pSBTrack->fCtlSB == FALSE)
         && (fVert == (BOOL)pSBTrack->fTrackVert)) {
        pSBCalc = pSBTrack->pSBCalc;
    } else {
        pSBCalc = &SBCalc;
    }
    CalcSBStuff(pwnd, pSBCalc, fVert);

    xxxDrawSB2(pwnd, pSBCalc, hdc, fVert, GetWndSBDisableFlags(pwnd, fVert));
}

/***************************************************************************\
* SBPosFromPx
*
* Compute scroll bar position from pixel location
*
* History:
\***************************************************************************/

int SBPosFromPx(
    PSBCALC  pSBCalc,
    int px)
{
    if (px < pSBCalc->pxMin) {
        return pSBCalc->posMin;
    }
    if (px >= pSBCalc->pxMin + pSBCalc->cpx) {
        return (pSBCalc->posMax - (pSBCalc->page ? pSBCalc->page - 1 : 0));
    }
    if (pSBCalc->cpx)
        return (pSBCalc->posMin + EngMulDiv(pSBCalc->posMax - pSBCalc->posMin -
            (pSBCalc->page ? pSBCalc->page - 1 : 0),
            px - pSBCalc->pxMin, pSBCalc->cpx));
    else
        return (pSBCalc->posMin - 1);
}

/***************************************************************************\
* InvertScrollHilite
*
*
*
* History:
\***************************************************************************/

void InvertScrollHilite(
    PWND pwnd,
    PSBTRACK pSBTrack)
{
    HDC hdc;

    /*
     * Don't invert if the thumb is all the way at the top or bottom
     * or you will end up inverting the line between the arrow and the thumb.
     */
    if (!IsRectEmpty(&pSBTrack->rcTrack)) {
        if (pSBTrack->fTrackRecalc) {
            RecalcTrackRect(pSBTrack);
            pSBTrack->fTrackRecalc = FALSE;
        }

        hdc = (HDC)_GetWindowDC(pwnd);
        InvertRect(hdc, &pSBTrack->rcTrack);
        _ReleaseDC(hdc);
    }
}

/***************************************************************************\
* xxxDoScroll
*
* Sends scroll notification to the scroll bar owner
*
* History:
\***************************************************************************/

void xxxDoScroll(
    PWND pwnd,
    PWND pwndNotify,
    int cmd,
    int pos,
    BOOL fVert
)
{
    TL tlpwndNotify;

    /*
     * Special case!!!! this routine is always passed pwnds that are
     * not thread locked, so they need to be thread locked here.  The
     * callers always know that by the time DoScroll() returns,
     * pwnd and pwndNotify could be invalid.
     */
    ThreadLock(pwndNotify, &tlpwndNotify);
    xxxSendMessage(pwndNotify, (UINT)(fVert ? WM_VSCROLL : WM_HSCROLL),
            MAKELONG(cmd, pos), (LPARAM)HW(pwnd));

    ThreadUnlock(&tlpwndNotify);
}

// -------------------------------------------------------------------------
//
//  CheckScrollRecalc()
//
// -------------------------------------------------------------------------
//void CheckScrollRecalc(PWND pwnd, PSBSTATE pSBState, PSBCALC pSBCalc)
//{
//    if ((pSBState->pwndCalc != pwnd) || ((pSBState->nBar != SB_CTL) && (pSBState->nBar != ((pSBState->fVertSB) ? SB_VERT : SB_HORZ))))
//    {
//        // Calculate SB stuff based on whether it's a control or in a window
//        if (pSBState->fCtlSB)
//            SBCtlSetup((PSBWND) pwnd);
//        else
//            CalcSBStuff(pwnd, pSBCalc, pSBState->fVertSB);
//    }
//}


/***************************************************************************\
* xxxMoveThumb
*
* History:
\***************************************************************************/

void xxxMoveThumb(
    PWND pwnd,
    PSBCALC  pSBCalc,
    int px)
{
    HBRUSH  hbr, hbrSave;
    HDC     hdc;
    PSBTRACK pSBTrack;

    CheckLock(pwnd);

    pSBTrack = PWNDTOPSBTRACK(pwnd);

    if ((pSBTrack == NULL) || (px == pSBTrack->pxOld))
        return;

pxReCalc:

    pSBTrack->posNew = SBPosFromPx(pSBCalc, px);

    /* Tentative position changed -- notify the guy. */
    if (pSBTrack->posNew != pSBTrack->posOld) {
        if (pSBTrack->spwndSBNotify != NULL) {
            xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify, SB_THUMBTRACK, pSBTrack->posNew, pSBTrack->fTrackVert
            );

        }
        // After xxxDoScroll, re-evaluate pSBTrack
        REEVALUATE_PSBTRACK(pSBTrack, pwnd, "xxxMoveThumb(1)");
        if ((pSBTrack == NULL) || (pSBTrack->xxxpfnSB == NULL))
            return;

        pSBTrack->posOld = pSBTrack->posNew;

        //
        // Anything can happen after the SendMessage above!
        // Make sure that the SBINFO structure contains data for the
        // window being tracked -- if not, recalculate data in SBINFO
        //
//        CheckScrollRecalc(pwnd, pSBState, pSBCalc);
        // when we yield, our range can get messed with
        // so make sure we handle this

        if (px >= pSBCalc->pxMin + pSBCalc->cpx)
        {
            px = pSBCalc->pxMin + pSBCalc->cpx;
            goto pxReCalc;
        }

    }

    hdc = _GetWindowDC(pwnd);

    pSBCalc->pxThumbTop = px;
    pSBCalc->pxThumbBottom = pSBCalc->pxThumbTop + pSBCalc->cpxThumb;

    // at this point, the disable flags are always going to be 0 --
    // we're in the middle of tracking.
    hbrSave = GreSelectBrush(hdc, hbr = xxxGetColorObjects(pwnd, hdc));

    // After xxxGetColorObjects, re-evaluate pSBTrack
    REEVALUATE_PSBTRACK(pSBTrack, pwnd, "xxxMoveThumb(2)");
    if (pSBTrack == NULL) {
        RIPMSG1(RIP_ERROR, "Did we use to leak hdc %#p?", hdc) ;
        _ReleaseDC(hdc);
        return;
    }
    DrawThumb2(pwnd, pSBCalc, hdc, hbr, pSBTrack->fTrackVert, 0);
    GreSelectBrush(hdc, hbrSave);
    _ReleaseDC(hdc);

    pSBTrack->pxOld = px;
}

/***************************************************************************\
* zzzDrawInvertScrollArea
*
*
*
* History:
\***************************************************************************/

void zzzDrawInvertScrollArea(
    PWND pwnd,
    PSBTRACK pSBTrack,
    BOOL fHit,
    UINT cmd)
{
    HDC hdc;
    RECT rcTemp;
    int cx, cy;
    UINT bm;

    if ((cmd != SB_LINEUP) && (cmd != SB_LINEDOWN)) {
        // not hitting on arrow -- just invert the area and return
        InvertScrollHilite(pwnd, pSBTrack);

        if (cmd == SB_PAGEUP) {
            if (fHit)
                SetWF(pwnd, WFPAGEUPBUTTONDOWN);
            else
                ClrWF(pwnd, WFPAGEUPBUTTONDOWN);
        } else {
            if (fHit)
                SetWF(pwnd, WFPAGEDNBUTTONDOWN);
            else
                ClrWF(pwnd, WFPAGEDNBUTTONDOWN);
        }

        zzzWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd,
                (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                ((cmd == SB_PAGEUP) ? INDEX_SCROLLBAR_UPPAGE : INDEX_SCROLLBAR_DOWNPAGE),
                WEF_USEPWNDTHREAD);
        // Note: after zzz, pSBTrack may no longer be valid (but we return now)
        return;
    }

    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }

    CopyRect(&rcTemp, &pSBTrack->rcTrack);

    hdc = _GetWindowDC(pwnd);

    if (pSBTrack->fTrackVert) {
        cx = SYSMET(CXVSCROLL);
        cy = SYSMET(CYVSCROLL);
    } else {
        cx = SYSMET(CXHSCROLL);
        cy = SYSMET(CYHSCROLL);
    }

    if ((cx == (rcTemp.right - rcTemp.left)) &&
        (cy == (rcTemp.bottom - rcTemp.top))) {
        if (cmd == SB_LINEUP)
            bm = (pSBTrack->fTrackVert) ? OBI_UPARROW : OBI_LFARROW;
        else // SB_LINEDOWN
            bm = (pSBTrack->fTrackVert) ? OBI_DNARROW : OBI_RGARROW;

        if (fHit)
            bm += DOBI_PUSHED;

        BitBltSysBmp(hdc, rcTemp.left, rcTemp.top, bm);
    } else {
        DrawFrameControl(hdc, &rcTemp, DFC_SCROLL,
            ((pSBTrack->fTrackVert) ? DFCS_SCROLLVERT : DFCS_SCROLLHORZ) |
            ((fHit) ? DFCS_PUSHED | DFCS_FLAT : 0) |
            ((cmd == SB_LINEUP) ? DFCS_SCROLLMIN : DFCS_SCROLLMAX));
    }

    _ReleaseDC(hdc);


    if (cmd == SB_LINEUP) {
        if (fHit)
            SetWF(pwnd, WFLINEUPBUTTONDOWN);
        else
            ClrWF(pwnd, WFLINEUPBUTTONDOWN);
    } else {
        if (fHit)
            SetWF(pwnd, WFLINEDNBUTTONDOWN);
        else
            ClrWF(pwnd, WFLINEDNBUTTONDOWN);
    }

    zzzWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd,
            (pSBTrack->fCtlSB ? OBJID_CLIENT : (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
            (cmd == SB_LINEUP ? INDEX_SCROLLBAR_UP : INDEX_SCROLLBAR_DOWN),
            WEF_USEPWNDTHREAD);
        // Note: after zzz, pSBTrack may no longer be valid (but we return now)
}

/***************************************************************************\
* xxxEndScroll
*
*
*
* History:
\***************************************************************************/

void xxxEndScroll(
    PWND pwnd,
    BOOL fCancel)
{
    UINT oldcmd;
    PSBTRACK pSBTrack;
    CheckLock(pwnd);
    UserAssert(!IsWinEventNotifyDeferred());

    pSBTrack = PWNDTOPSBTRACK(pwnd);
    if (pSBTrack && PtiCurrent()->pq->spwndCapture == pwnd && pSBTrack->xxxpfnSB != NULL) {

        oldcmd = pSBTrack->cmdSB;
        pSBTrack->cmdSB = 0;
        xxxReleaseCapture();

        // After xxxReleaseCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

        if (pSBTrack->xxxpfnSB == xxxTrackThumb) {

            if (fCancel) {
                pSBTrack->posOld = pSBTrack->pSBCalc->pos;
            }

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            if (pSBTrack->spwndSBNotify != NULL) {
                xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                        SB_THUMBPOSITION, pSBTrack->posOld, pSBTrack->fTrackVert
                );
                // After xxxDoScroll, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
            }

            if (pSBTrack->fCtlSB) {
                DrawCtlThumb((PSBWND) pwnd);
            } else {
                xxxDrawThumb(pwnd, pSBTrack->pSBCalc, pSBTrack->fTrackVert);
                // Note: after xxx, pSBTrack may no longer be valid
            }

        } else if (pSBTrack->xxxpfnSB == xxxTrackBox) {
            DWORD lParam;
            POINT ptMsg;

            if (pSBTrack->hTimerSB != 0) {
                _KillSystemTimer(pwnd, IDSYS_SCROLL);
                pSBTrack->hTimerSB = 0;
            }
            lParam = _GetMessagePos();
            if (TestWF(pwnd, WEFLAYOUTRTL)) {
                ptMsg.x = pwnd->rcWindow.right - GET_X_LPARAM(lParam);
            } else {
                ptMsg.x = GET_X_LPARAM(lParam) - pwnd->rcWindow.left;
            }
            ptMsg.y = GET_Y_LPARAM(lParam) - pwnd->rcWindow.top;
            if (PtInRect(&pSBTrack->rcTrack, ptMsg)) {
                zzzDrawInvertScrollArea(pwnd, pSBTrack, FALSE, oldcmd);
                // Note: after zzz, pSBTrack may no longer be valid
            }
        }

        /*
         * Always send SB_ENDSCROLL message.
         *
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */

        // After xxxDrawThumb or zzzDrawInvertScrollArea, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

        if (pSBTrack->spwndSBNotify != NULL) {
            xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                    SB_ENDSCROLL, 0, pSBTrack->fTrackVert);
            // After xxxDoScroll, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
        }

        ClrWF(pwnd, WFSCROLLBUTTONDOWN);
        ClrWF(pwnd, WFVERTSCROLLTRACK);

        xxxWindowEvent(EVENT_SYSTEM_SCROLLINGEND, pwnd,
                (pSBTrack->fCtlSB ? OBJID_CLIENT :
                        (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
                INDEXID_CONTAINER, 0);
        
        // After xxxWindowEvent, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

        /*
         * If this is a Scroll Bar Control, turn the caret back on.
         */
        if (pSBTrack->spwndSB != NULL) {
            zzzShowCaret(pSBTrack->spwndSB);
            // After zzz, revalidate pSBTrack
            RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
        }


        pSBTrack->xxxpfnSB = NULL;

        /*
         * Unlock structure members so they are no longer holding down windows.
         */
        Unlock(&pSBTrack->spwndSB);
        Unlock(&pSBTrack->spwndSBNotify);
        Unlock(&pSBTrack->spwndTrack);
        UserFreePool(pSBTrack);
        PWNDTOPSBTRACK(pwnd) = NULL;
    }
}


/***************************************************************************\
* xxxContScroll
*
*
*
* History:
\***************************************************************************/

VOID xxxContScroll(
    PWND pwnd,
    UINT message,
    UINT_PTR ID,
    LPARAM lParam)
{
    LONG pt;
    PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);

    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(ID);
    UNREFERENCED_PARAMETER(lParam);

    if (pSBTrack == NULL)
        return;

    CheckLock(pwnd);

    pt = _GetMessagePos();

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        pt = MAKELONG(pwnd->rcWindow.right - GET_X_LPARAM(pt), GET_Y_LPARAM(pt) - pwnd->rcWindow.top);
    } else {
        pt = MAKELONG( GET_X_LPARAM(pt) - pwnd->rcWindow.left, GET_Y_LPARAM(pt) - pwnd->rcWindow.top);
    }
    xxxTrackBox(pwnd, WM_NULL, 0, pt, NULL);
    // After xxxTrackBox, revalidate pSBTrack
    RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

    if (pSBTrack->fHitOld) {
        pSBTrack->hTimerSB = _SetSystemTimer(pwnd, IDSYS_SCROLL,
                gpsi->dtScroll / 8, xxxContScroll);

        /*
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */
        if (pSBTrack->spwndSBNotify != NULL) {
            xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                    pSBTrack->cmdSB, 0, pSBTrack->fTrackVert);
            // Note: after xxx, pSBTrack may no longer be valid (but we return now)
        }
    }

    return;
}

/***************************************************************************\
* xxxTrackBox
*
*
*
* History:
\***************************************************************************/

void xxxTrackBox(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    BOOL fHit;
    POINT ptHit;
    PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);
    int cmsTimer;

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(pSBCalc);

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if (pSBTrack == NULL)
        return;

    if (message != WM_NULL && HIBYTE(message) != HIBYTE(WM_MOUSEFIRST))
        return;

    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }

    ptHit.x = GET_X_LPARAM(lParam);
    ptHit.y = GET_Y_LPARAM(lParam);
    fHit = PtInRect(&pSBTrack->rcTrack, ptHit);

    if (fHit != (BOOL)pSBTrack->fHitOld) {
        zzzDrawInvertScrollArea(pwnd, pSBTrack, fHit, pSBTrack->cmdSB);
        // After zzz, pSBTrack may no longer be valid
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
    }

    cmsTimer = gpsi->dtScroll / 8;

    switch (message) {
    case WM_LBUTTONUP:
        xxxEndScroll(pwnd, FALSE);
        // Note: after xxx, pSBTrack may no longer be valid
        break;

    case WM_LBUTTONDOWN:
        pSBTrack->hTimerSB = 0;
        cmsTimer = gpsi->dtScroll;

        /*
         *** FALL THRU **
         */

    case WM_MOUSEMOVE:
        if (fHit && fHit != (BOOL)pSBTrack->fHitOld) {

            /*
             * We moved back into the normal rectangle: reset timer
             */
            pSBTrack->hTimerSB = _SetSystemTimer(pwnd, IDSYS_SCROLL,
                    cmsTimer, xxxContScroll);

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            if (pSBTrack->spwndSBNotify != NULL) {
                xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                        pSBTrack->cmdSB, 0, pSBTrack->fTrackVert);
                // Note: after xxx, pSBTrack may no longer be valid
            }
        }
    }
    // After xxxDoScroll or xxxEndScroll, revalidate pSBTrack
    RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
    pSBTrack->fHitOld = fHit;
}


/***************************************************************************\
* xxxTrackThumb
*
*
*
* History:
\***************************************************************************/

void xxxTrackThumb(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    int px;
    PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);
    POINT pt;

    UNREFERENCED_PARAMETER(wParam);

    CheckLock(pwnd);

    if (HIBYTE(message) != HIBYTE(WM_MOUSEFIRST))
        return;

    if (pSBTrack == NULL)
        return;

    // Make sure that the SBINFO structure contains data for the
    // window being tracked -- if not, recalculate data in SBINFO
//    CheckScrollRecalc(pwnd, pSBState, pSBCalc);
    if (pSBTrack->fTrackRecalc) {
        RecalcTrackRect(pSBTrack);
        pSBTrack->fTrackRecalc = FALSE;
    }


    pt.y = GET_Y_LPARAM(lParam);
    pt.x = GET_X_LPARAM(lParam);
    if (!PtInRect(&pSBTrack->rcTrack, pt))
        px = pSBCalc->pxStart;
    else {
        px = (pSBTrack->fTrackVert ? pt.y : pt.x) + pSBTrack->dpxThumb;
        if (px < pSBCalc->pxMin)
            px = pSBCalc->pxMin;
        else if (px >= pSBCalc->pxMin + pSBCalc->cpx)
            px = pSBCalc->pxMin + pSBCalc->cpx;
    }

    xxxMoveThumb(pwnd, pSBCalc, px);

    /*
     * We won't get the WM_LBUTTONUP message if we got here through
     * the scroll menu, so test the button state directly.
     */
    if (message == WM_LBUTTONUP || _GetKeyState(VK_LBUTTON) >= 0) {
        xxxEndScroll(pwnd, FALSE);
    }

}

/***************************************************************************\
* xxxSBTrackLoop
*
*
*
* History:
\***************************************************************************/

void xxxSBTrackLoop(
    PWND pwnd,
    LPARAM lParam,
    PSBCALC pSBCalc)
{
    MSG msg;
    UINT cmd;
    PTHREADINFO ptiCurrent;
    VOID (*xxxpfnSB)(PWND, UINT, WPARAM, LPARAM, PSBCALC);
    PSBTRACK pSBTrack;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    pSBTrack = PWNDTOPSBTRACK(pwnd);

    if ((pSBTrack == NULL) || (NULL == (xxxpfnSB = pSBTrack->xxxpfnSB)))
        // mode cancelled -- exit track loop
        return;

    if (pSBTrack->fTrackVert)
        SetWF(pwnd, WFVERTSCROLLTRACK);

    xxxWindowEvent(EVENT_SYSTEM_SCROLLINGSTART, pwnd,
            (pSBTrack->fCtlSB ? OBJID_CLIENT :
                    (pSBTrack->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL)),
            INDEXID_CONTAINER, 0);
    // Note: after xxx, pSBTrack may no longer be valid

    (*xxxpfnSB)(pwnd, WM_LBUTTONDOWN, 0, lParam, pSBCalc);
    // Note: after xxx, pSBTrack may no longer be valid

    ptiCurrent = PtiCurrent();

    while (ptiCurrent->pq->spwndCapture == pwnd) {
        if (!xxxGetMessage(&msg, NULL, 0, 0)) {
            // Note: after xxx, pSBTrack may no longer be valid
            break;
        }

        if (!_CallMsgFilter(&msg, MSGF_SCROLLBAR)) {
            cmd = msg.message;

            if (msg.hwnd == HWq(pwnd) && ((cmd >= WM_MOUSEFIRST && cmd <=
                    WM_MOUSELAST) || (cmd >= WM_KEYFIRST &&
                    cmd <= WM_KEYLAST))) {
                cmd = SystoChar(cmd, msg.lParam);

                // After xxxWindowEvent, xxxpfnSB, xxxTranslateMessage or
                // xxxDispatchMessage, re-evaluate pSBTrack.
                REEVALUATE_PSBTRACK(pSBTrack, pwnd, "xxxTrackLoop");
                if ((pSBTrack == NULL) || (NULL == (xxxpfnSB = pSBTrack->xxxpfnSB)))
                    // mode cancelled -- exit track loop
                    return;

                (*xxxpfnSB)(pwnd, cmd, msg.wParam, msg.lParam, pSBCalc);
            } else {
                xxxTranslateMessage(&msg, 0);
                xxxDispatchMessage(&msg);
            }
        }
    }
}


/***************************************************************************\
* xxxSBTrackInit
*
* History:
\***************************************************************************/

void xxxSBTrackInit(
    PWND pwnd,
    LPARAM lParam,
    int curArea,
    UINT uType)
{
    int px;
    LPINT pwX;
    LPINT pwY;
    UINT wDisable;     // Scroll bar disable flags;
    SBCALC SBCalc;
    PSBCALC pSBCalc;
    RECT rcSB;
    PSBTRACK pSBTrack;

    CheckLock(pwnd);


    if (PWNDTOPSBTRACK(pwnd)) {
        RIPMSG1(RIP_WARNING, "xxxSBTrackInit: PWNDTOPSBTRACK(pwnd) == %#p",
                PWNDTOPSBTRACK(pwnd));
        return;
    }

    pSBTrack = (PSBTRACK)UserAllocPoolWithQuota(sizeof(*pSBTrack), TAG_SCROLLTRACK);
    if (pSBTrack == NULL)
        return;

    pSBTrack->hTimerSB = 0;
    pSBTrack->fHitOld = FALSE;

    pSBTrack->xxxpfnSB = xxxTrackBox;

    pSBTrack->spwndTrack = NULL;
    pSBTrack->spwndSB = NULL;
    pSBTrack->spwndSBNotify = NULL;
    Lock(&pSBTrack->spwndTrack, pwnd);
    PWNDTOPSBTRACK(pwnd) = pSBTrack;

    pSBTrack->fCtlSB = (!curArea);
    if (pSBTrack->fCtlSB) {

        /*
         * This is a scroll bar control.
         */
        Lock(&pSBTrack->spwndSB, pwnd);
        pSBTrack->fTrackVert = ((PSBWND)pwnd)->fVert;
        Lock(&pSBTrack->spwndSBNotify, pwnd->spwndParent);
        wDisable = ((PSBWND)pwnd)->wDisableFlags;
        pSBCalc = &((PSBWND)pwnd)->SBCalc;
        pSBTrack->nBar = SB_CTL;
    } else {

        /*
         * This is a scroll bar that is part of the window frame.
         */

        //
        // Mirror the window coord of the scroll bar,
        // if it is a mirrored one
        //
        if (TestWF(pwnd,WEFLAYOUTRTL)) {
            lParam = MAKELONG(
                    pwnd->rcWindow.right - GET_X_LPARAM(lParam),
                    GET_Y_LPARAM(lParam) - pwnd->rcWindow.top);
        } else {
            lParam = MAKELONG(
                    GET_X_LPARAM(lParam) - pwnd->rcWindow.left,
                    GET_Y_LPARAM(lParam) - pwnd->rcWindow.top);
        }

        Lock(&pSBTrack->spwndSBNotify, pwnd);
        Lock(&pSBTrack->spwndSB, NULL);
        pSBTrack->fTrackVert = (curArea - HTHSCROLL);
        wDisable = GetWndSBDisableFlags(pwnd, pSBTrack->fTrackVert);
        pSBCalc = &SBCalc;
        pSBTrack->nBar = (curArea - HTHSCROLL) ? SB_VERT : SB_HORZ;
    }

    pSBTrack->pSBCalc = pSBCalc;
    /*
     *  Check if the whole scroll bar is disabled
     */
    if((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        Unlock(&pSBTrack->spwndSBNotify);
        Unlock(&pSBTrack->spwndSB);
        Unlock(&pSBTrack->spwndTrack);
        UserFreePool(pSBTrack);
        PWNDTOPSBTRACK(pwnd) = NULL;
        return;  // It is a disabled scroll bar; So, do not respond.
    }

    if (!pSBTrack->fCtlSB) {
        CalcSBStuff(pwnd, pSBCalc, pSBTrack->fTrackVert);
    }

    pwX = (LPINT)&rcSB;
    pwY = pwX + 1;
    if (!pSBTrack->fTrackVert)
        pwX = pwY--;

    px = (pSBTrack->fTrackVert ? GET_Y_LPARAM(lParam) : GET_X_LPARAM(lParam));

    *(pwX + 0) = pSBCalc->pxLeft;
    *(pwY + 0) = pSBCalc->pxTop;
    *(pwX + 2) = pSBCalc->pxRight;
    *(pwY + 2) = pSBCalc->pxBottom;
    pSBTrack->cmdSB = (UINT)-1;
    if (px < pSBCalc->pxUpArrow) {

        /*
         *  The click occurred on Left/Up arrow; Check if it is disabled
         */
        if(wDisable & LTUPFLAG) {
            if(pSBTrack->fCtlSB) {   // If this is a scroll bar control,
                zzzShowCaret(pSBTrack->spwndSB);  // show the caret before returning;
                // After zzzShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
            }

            Unlock(&pSBTrack->spwndSBNotify);
            Unlock(&pSBTrack->spwndSB);
            Unlock(&pSBTrack->spwndTrack);
            UserFreePool(pSBTrack);
            PWNDTOPSBTRACK(pwnd) = NULL;
            return;         // Yes! disabled. Do not respond.
        }

        // LINEUP -- make rcSB the Up Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEUP;
        *(pwY + 2) = pSBCalc->pxUpArrow;
    } else if (px >= pSBCalc->pxDownArrow) {

        /*
         * The click occurred on Right/Down arrow; Check if it is disabled
         */
        if (wDisable & RTDNFLAG) {
            if (pSBTrack->fCtlSB) {    // If this is a scroll bar control,
                zzzShowCaret(pSBTrack->spwndSB);  // show the caret before returning;
                // After zzzShowCaret, revalidate pSBTrack
                RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);
            }

            Unlock(&pSBTrack->spwndSBNotify);
            Unlock(&pSBTrack->spwndSB);
            Unlock(&pSBTrack->spwndTrack);
            UserFreePool(pSBTrack);
            PWNDTOPSBTRACK(pwnd) = NULL;
            return;// Yes! disabled. Do not respond.
        }

        // LINEDOWN -- make rcSB the Down Arrow's Rectangle
        pSBTrack->cmdSB = SB_LINEDOWN;
        *(pwY + 0) = pSBCalc->pxDownArrow;
    } else if (px < pSBCalc->pxThumbTop) {
        // PAGEUP -- make rcSB the rectangle between Up Arrow and Thumb
        pSBTrack->cmdSB = SB_PAGEUP;
        *(pwY + 0) = pSBCalc->pxUpArrow;
        *(pwY + 2) = pSBCalc->pxThumbTop;
    } else if (px < pSBCalc->pxThumbBottom) {

DoThumbPos:
        /*
         * Elevator isn't there if there's no room.
         */
        if (pSBCalc->pxDownArrow - pSBCalc->pxUpArrow <= pSBCalc->cpxThumb) {
            Unlock(&pSBTrack->spwndSBNotify);
            Unlock(&pSBTrack->spwndSB);
            Unlock(&pSBTrack->spwndTrack);
            UserFreePool(pSBTrack);
            PWNDTOPSBTRACK(pwnd) = NULL;
            return;
        }
        // THUMBPOSITION -- we're tracking with the thumb
        pSBTrack->cmdSB = SB_THUMBPOSITION;
        CalcTrackDragRect(pSBTrack);

        pSBTrack->xxxpfnSB = xxxTrackThumb;
        pSBTrack->pxOld = pSBCalc->pxStart = pSBCalc->pxThumbTop;
        pSBTrack->posNew = pSBTrack->posOld = pSBCalc->pos;
        pSBTrack->dpxThumb = pSBCalc->pxStart - px;

        xxxCapture(PtiCurrent(), pwnd, WINDOW_CAPTURE);
        // After xxxCapture, revalidate pSBTrack
        RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

        /*
         * DoScroll does thread locking on these two pwnds -
         * this is ok since they are not used after this
         * call.
         */
        if (pSBTrack->spwndSBNotify != NULL) {
            xxxDoScroll(pSBTrack->spwndSB, pSBTrack->spwndSBNotify,
                    SB_THUMBTRACK, pSBTrack->posOld, pSBTrack->fTrackVert
            );
            // Note: after xxx, pSBTrack may no longer be valid
        }
    } else if (px < pSBCalc->pxDownArrow) {
        // PAGEDOWN -- make rcSB the rectangle between Thumb and Down Arrow
        pSBTrack->cmdSB = SB_PAGEDOWN;
        *(pwY + 0) = pSBCalc->pxThumbBottom;
        *(pwY + 2) = pSBCalc->pxDownArrow;
    }

    /*
     * If the shift key is down, we'll position the thumb directly so it's
     * centered on the click point.
     */
    if ((uType == SCROLL_DIRECT && pSBTrack->cmdSB != SB_LINEUP && pSBTrack->cmdSB != SB_LINEDOWN) ||
            (uType == SCROLL_MENU)) {
        if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
            goto DoThumbPos;
        }
        pSBTrack->dpxThumb = -(pSBCalc->cpxThumb / 2);
    }

    xxxCapture(PtiCurrent(), pwnd, WINDOW_CAPTURE);
    // After xxxCapture, revalidate pSBTrack
    RETURN_IF_PSBTRACK_INVALID(pSBTrack, pwnd);

    if (pSBTrack->cmdSB != SB_THUMBPOSITION) {
        CopyRect(&pSBTrack->rcTrack, &rcSB);
    }

    xxxSBTrackLoop(pwnd, lParam, pSBCalc);

    // After xxx, re-evaluate pSBTrack
    REEVALUATE_PSBTRACK(pSBTrack, pwnd, "xxxTrackLoop");
    if (pSBTrack) {
        Unlock(&pSBTrack->spwndSBNotify);
        Unlock(&pSBTrack->spwndSB);
        Unlock(&pSBTrack->spwndTrack);
        UserFreePool(pSBTrack);
        PWNDTOPSBTRACK(pwnd) = NULL;
    }
}

/***************************************************************************\
* GetScrollMenu
*
* History:
\***************************************************************************/

PMENU xxxGetScrollMenu(
    PWND pwnd,
    BOOL fVert)
{
    PMENU pMenu;
    PMENU *ppDesktopMenu;

    /*
     * Grab the menu from the desktop.  If the desktop menu
     * has not been loaded and this is not a system thread,
     * load it now.  Callbacks cannot be made from a system
     * thread or when a thread is in cleanup.
     */
    if (fVert) {
        ppDesktopMenu = &pwnd->head.rpdesk->spmenuVScroll;
    } else {
        ppDesktopMenu = &pwnd->head.rpdesk->spmenuHScroll;
    }
    pMenu = *ppDesktopMenu;
    if (pMenu == NULL && !(PtiCurrent()->TIF_flags & (TIF_SYSTEMTHREAD | TIF_INCLEANUP))) {
        UNICODE_STRING strMenuName;

        RtlInitUnicodeStringOrId(&strMenuName,
            fVert ? MAKEINTRESOURCE(ID_VSCROLLMENU) : MAKEINTRESOURCE(ID_HSCROLLMENU));
        pMenu = xxxClientLoadMenu(NULL, &strMenuName);
        LockDesktopMenu(ppDesktopMenu, pMenu);
    }

    /*
     * Return the handle to the scroll menu.
     */
    if (pMenu != NULL) {
        return _GetSubMenu(pMenu, 0);
    }

    return NULL;
}

/***************************************************************************\
* xxxDoScrollMenu
*
* History:
\***************************************************************************/

VOID
xxxDoScrollMenu(
    PWND pwndNotify,
    PWND pwndSB,
    BOOL fVert,
    LPARAM lParam)
{
    PMENU pMenu;
    SBCALC SBCalc, *pSBCalc;
    UINT cmd;
    POINT pt;
    TL tlpmenu;
    UINT wDisable;

    /*
     * Check the compatibility flag.  Word 6.0 AV's when selecting an item
     * in this menu.
     * NOTE: If this hack is to be extended for other apps we should use
     * another bit for GACF_NOSCROLLBARCTXMENU as the current one is re-used
     *  MCostea #119380
     */
    if (GetAppCompatFlags(NULL) & GACF_NOSCROLLBARCTXMENU) {
        return;
    }

    /*
     * Initialize some stuff.
     */
    POINTSTOPOINT(pt, lParam);
    if (pwndSB) {
        SBCtlSetup((PSBWND)pwndSB);
        pSBCalc = &(((PSBWND)pwndSB)->SBCalc);
        wDisable = ((PSBWND)pwndSB)->wDisableFlags;
        pt.x -= pwndSB->rcWindow.left;
        pt.y -= pwndSB->rcWindow.top;
    } else {
        pSBCalc = &SBCalc;
        CalcSBStuff(pwndNotify, pSBCalc, fVert);
        wDisable = GetWndSBDisableFlags(pwndNotify, fVert);
        pt.x -= pwndNotify->rcWindow.left;
        pt.y -= pwndNotify->rcWindow.top;
    }

    /*
     * Make sure the scrollbar isn't disabled.
     */
    if ((wDisable & SB_DISABLE_MASK) == SB_DISABLE_MASK) {
        return;
    }

    /*
     * Put up a menu and scroll accordingly.
     */
    if ((pMenu = xxxGetScrollMenu(pwndNotify, fVert)) != NULL) {
        ThreadLockAlways(pMenu, &tlpmenu);
        cmd = xxxTrackPopupMenuEx(pMenu,
                                  TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY,
                                  GET_X_LPARAM(lParam),
                                  GET_Y_LPARAM(lParam),
                                  pwndNotify,
                                  NULL);
        ThreadUnlock(&tlpmenu);
        if (cmd) {
            if ((cmd & 0x00FF) == SB_THUMBPOSITION) {
                if (pwndSB) {
                    xxxSBTrackInit(pwndSB, MAKELPARAM(pt.x, pt.y), 0, SCROLL_MENU);
                } else {
                    xxxSBTrackInit(pwndNotify, lParam, fVert ? HTVSCROLL : HTHSCROLL, SCROLL_MENU);
                }
            } else {
                xxxDoScroll(pwndSB,
                            pwndNotify,
                            cmd & 0x00FF,
                            0,
                            fVert
                );
                xxxDoScroll(pwndSB,
                            pwndNotify,
                            SB_ENDSCROLL,
                            0,
                            fVert
                );
            }
        }
    }
}

/***************************************************************************\
* xxxSBWndProc
*
* History:
* 08-15-95 jparsons Added guard against NULL lParam [51986]
\***************************************************************************/

LRESULT xxxSBWndProc(
    PSBWND psbwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LONG l;
    LONG lres;
    int cx;
    int cy;
    UINT cmd;
    UINT uSide;
    HDC hdc;
    RECT rc;
    POINT pt;
    BOOL fSizeReal;
    HBRUSH hbrSave;
    BOOL fSize;
    PAINTSTRUCT ps;
    UINT style;
    TL tlpwndParent;
    SCROLLINFO      si;
    LPSCROLLINFO    lpsi = &si;
    BOOL            fRedraw = FALSE;
    BOOL            fScroll;

    CheckLock(psbwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    VALIDATECLASSANDSIZE(((PWND)psbwnd), message, wParam, lParam, FNID_SCROLLBAR, WM_CREATE);

    style = LOBYTE(psbwnd->wnd.style);
    fSize = ((style & (SBS_SIZEBOX | SBS_SIZEGRIP)) != 0);

    switch (message) {
    case WM_CREATE:
        /*
         * Guard against lParam being NULL since the thunk allows it [51986]
         */
        if (lParam) {
            rc.right = (rc.left = ((LPCREATESTRUCT)lParam)->x) +
                    ((LPCREATESTRUCT)lParam)->cx;
            rc.bottom = (rc.top = ((LPCREATESTRUCT)lParam)->y) +
                    ((LPCREATESTRUCT)lParam)->cy;
            // This is because we can't just rev CardFile -- we should fix the
            // problem here in case anyone else happened to have some EXTRA
            // scroll styles on their scroll bar controls (jeffbog 03/21/94)
            if (!TestWF((PWND)psbwnd, WFWIN40COMPAT))
                psbwnd->wnd.style &= ~(WS_HSCROLL | WS_VSCROLL);

            if (!fSize) {
                l = PtrToLong(((LPCREATESTRUCT)lParam)->lpCreateParams);
                psbwnd->SBCalc.pos = psbwnd->SBCalc.posMin = LOWORD(l);
                psbwnd->SBCalc.posMax = HIWORD(l);
                psbwnd->fVert = ((LOBYTE(psbwnd->wnd.style) & SBS_VERT) != 0);
                psbwnd->SBCalc.page = 0;
            }

            if (psbwnd->wnd.style & WS_DISABLED)
                psbwnd->wDisableFlags = SB_DISABLE_MASK;

            if (style & (SBS_TOPALIGN | SBS_BOTTOMALIGN)) {
                if (fSize) {
                    if (style & SBS_SIZEBOXBOTTOMRIGHTALIGN) {
                        rc.left = rc.right - SYSMET(CXVSCROLL);
                        rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }

                    rc.right = rc.left + SYSMET(CXVSCROLL);
                    rc.bottom = rc.top + SYSMET(CYHSCROLL);
                } else {
                    if (style & SBS_VERT) {
                        if (style & SBS_LEFTALIGN)
                            rc.right = rc.left + SYSMET(CXVSCROLL);
                        else
                            rc.left = rc.right - SYSMET(CXVSCROLL);
                    } else {
                        if (style & SBS_TOPALIGN)
                            rc.bottom = rc.top + SYSMET(CYHSCROLL);
                        else
                            rc.top = rc.bottom - SYSMET(CYHSCROLL);
                    }
                }

                xxxMoveWindow((PWND)psbwnd, rc.left, rc.top, rc.right - rc.left,
                         rc.bottom - rc.top, FALSE);
            }
        } /* if */

        else {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
                    "xxxSBWndProc - NULL lParam for WM_CREATE\n") ;
        } /* else */

        break;

    case WM_SIZE:
        if (PtiCurrent()->pq->spwndFocus != (PWND)psbwnd)
            break;

        // scroll bar has the focus -- recalc it's thumb caret size
        // no need to DeferWinEventNotify() - see xxxCreateCaret below.
        zzzDestroyCaret();

            //   |             |
            //   |  FALL THRU  |
            //   V             V

    case WM_SETFOCUS:
        SBCtlSetup(psbwnd);

        cx = (psbwnd->fVert ? psbwnd->wnd.rcWindow.right - psbwnd->wnd.rcWindow.left
                            : psbwnd->SBCalc.cpxThumb) - 2 * SYSMET(CXEDGE);
        cy = (psbwnd->fVert ? psbwnd->SBCalc.cpxThumb
                            : psbwnd->wnd.rcWindow.bottom - psbwnd->wnd.rcWindow.top) - 2 * SYSMET(CYEDGE);

        xxxCreateCaret((PWND)psbwnd, (HBITMAP)1, cx, cy);
        zzzSetSBCaretPos(psbwnd);
        zzzShowCaret((PWND)psbwnd);
        break;

    case WM_KILLFOCUS:
        zzzDestroyCaret();
        break;

    case WM_ERASEBKGND:

        /*
         * Do nothing, but don't let DefWndProc() do it either.
         * It will be erased when its painted.
         */
        return (LONG)TRUE;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        if ((hdc = (HDC)wParam) == NULL) {
            hdc = xxxBeginPaint((PWND)psbwnd, (LPPAINTSTRUCT)&ps);
        }
        if (!fSize) {
            SBCtlSetup(psbwnd);
            xxxDrawSB2((PWND)psbwnd, &psbwnd->SBCalc, hdc, psbwnd->fVert, psbwnd->wDisableFlags);
        } else {
            fSizeReal = TestWF((PWND)psbwnd, WFSIZEBOX);
            if (!fSizeReal)
                SetWF((PWND)psbwnd, WFSIZEBOX);

            DrawSize((PWND)psbwnd, hdc, 0, 0);

            if (!fSizeReal)
                ClrWF((PWND)psbwnd, WFSIZEBOX);
        }

        if (wParam == 0L)
            xxxEndPaint((PWND)psbwnd, (LPPAINTSTRUCT)&ps);
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS;

    case WM_CONTEXTMENU:
            ThreadLock(psbwnd->wnd.spwndParent, &tlpwndParent);
            xxxDoScrollMenu(psbwnd->wnd.spwndParent, (PWND)psbwnd, psbwnd->fVert, lParam);
            ThreadUnlock(&tlpwndParent);
        break;

    case WM_NCHITTEST:
        if (style & SBS_SIZEGRIP) {
            /*
             * If the scroll bar is RTL mirrored, then
             * mirror the hittest of the grip location.
             */
            if (TestWF((PWND)psbwnd, WEFLAYOUTRTL)) {
                return HTBOTTOMLEFT;
            } else {
                return HTBOTTOMRIGHT;
            }
        } else {
            goto DoDefault;
        }
        break;

#ifdef COLOR_HOTTRACKING
    case WM_MOUSELEAVE:
        xxxHotTrackSBCtl(psbwnd, 0, FALSE);
        psbwnd->ht = 0;
        break;

    case WM_MOUSEMOVE:
        {
            int ht;

            if (psbwnd->ht == 0) {
                TRACKMOUSEEVENT tme = {sizeof(TRACKMOUSEEVENT), TME_LEAVE, HWq(psbwnd), 0};
                TrackMouseEvent(&tme);
            }

            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            ht = HitTestScrollBar((PWND)psbwnd, psbwnd->fVert, pt);
            if (psbwnd->ht != ht) {
                xxxHotTrackSBCtl(psbwnd, ht, TRUE);
                psbwnd->ht = ht;
            }
        }
        break;
#endif // COLOR_HOTTRACKING

    case WM_LBUTTONDBLCLK:
        cmd = SC_ZOOM;
        if (fSize)
            goto postmsg;

        /*
         *** FALL THRU **
         */

    case WM_LBUTTONDOWN:
            //
            // Note that SBS_SIZEGRIP guys normally won't ever see button
            // downs.  This is because they return HTBOTTOMRIGHT to
            // WindowHitTest handling.  This will walk up the parent chain
            // to the first sizeable ancestor, bailing out at caption windows
            // of course.  That dude, if he exists, will handle the sizing
            // instead.
            //
        if (!fSize) {
            if (TestWF((PWND)psbwnd, WFTABSTOP)) {
                xxxSetFocus((PWND)psbwnd);
            }

            zzzHideCaret((PWND)psbwnd);
            SBCtlSetup(psbwnd);

            /*
             * SBCtlSetup enters SEM_SB, and xxxSBTrackInit leaves it.
             */
            xxxSBTrackInit((PWND)psbwnd, lParam, 0, (_GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
            break;
        } else {
            cmd = SC_SIZE;
postmsg:
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            _ClientToScreen((PWND)psbwnd, &pt);
            lParam = MAKELONG(pt.x, pt.y);

            /*
             * convert HT value into a move value.  This is bad,
             * but this is purely temporary.
             */
            if (TestWF(((PWND)psbwnd)->spwndParent,WEFLAYOUTRTL)) {
                uSide = HTBOTTOMLEFT;
            } else {
                uSide = HTBOTTOMRIGHT;
            }
            ThreadLock(((PWND)psbwnd)->spwndParent, &tlpwndParent);
            xxxSendMessage(((PWND)psbwnd)->spwndParent, WM_SYSCOMMAND,
                    (cmd | (uSide - HTSIZEFIRST + 1)), lParam);
            ThreadUnlock(&tlpwndParent);
        }
        break;

    case WM_KEYUP:
        switch (wParam) {
        case VK_HOME:
        case VK_END:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_LEFT:
        case VK_UP:
        case VK_RIGHT:
        case VK_DOWN:

            /*
             * Send end scroll message when user up clicks on keyboard
             * scrolling.
             *
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll((PWND)psbwnd, psbwnd->wnd.spwndParent,
                    SB_ENDSCROLL, 0, psbwnd->fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_HOME:
            wParam = SB_TOP;
            goto KeyScroll;

        case VK_END:
            wParam = SB_BOTTOM;
            goto KeyScroll;

        case VK_PRIOR:
            wParam = SB_PAGEUP;
            goto KeyScroll;

        case VK_NEXT:
            wParam = SB_PAGEDOWN;
            goto KeyScroll;

        case VK_LEFT:
        case VK_UP:
            wParam = SB_LINEUP;
            goto KeyScroll;

        case VK_RIGHT:
        case VK_DOWN:
            wParam = SB_LINEDOWN;
KeyScroll:

            /*
             * DoScroll does thread locking on these two pwnds -
             * this is ok since they are not used after this
             * call.
             */
            xxxDoScroll((PWND)psbwnd, psbwnd->wnd.spwndParent, (int)wParam,
                    0, psbwnd->fVert
            );
            break;

        default:
            break;
        }
        break;

    case WM_ENABLE:
        return xxxSendMessage((PWND)psbwnd, SBM_ENABLE_ARROWS,
               (wParam ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH), 0);

    case SBM_ENABLE_ARROWS:

        /*
         * This is used to enable/disable the arrows in a SB ctrl
         */
        return (LONG)xxxEnableSBCtlArrows((PWND)psbwnd, (UINT)wParam);

    case SBM_GETPOS:
        return (LONG)psbwnd->SBCalc.pos;

    case SBM_GETRANGE:
        *((LPINT)wParam) = psbwnd->SBCalc.posMin;
        *((LPINT)lParam) = psbwnd->SBCalc.posMax;
        return MAKELRESULT(LOWORD(psbwnd->SBCalc.posMin), LOWORD(psbwnd->SBCalc.posMax));

    case SBM_GETSCROLLINFO:
        return (LONG)_SBGetParms((PWND)psbwnd, SB_CTL, (PSBDATA)&psbwnd->SBCalc, (LPSCROLLINFO) lParam);

    case SBM_SETRANGEREDRAW:
        fRedraw = TRUE;

    case SBM_SETRANGE:
        // Save the old values of Min and Max for return value
        si.cbSize = sizeof(si);
//        si.nMin = LOWORD(lParam);
//        si.nMax = HIWORD(lParam);
        si.nMin = (int)wParam;
        si.nMax = (int)lParam;
        si.fMask = SIF_RANGE | SIF_RETURNOLDPOS;
        goto SetInfo;

    case SBM_SETPOS:
        fRedraw = (BOOL) lParam;
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS | SIF_RETURNOLDPOS;
        si.nPos  = (int)wParam;
        goto SetInfo;

    case SBM_SETSCROLLINFO:
        lpsi = (LPSCROLLINFO) lParam;
        fRedraw = (BOOL) wParam;
SetInfo:
        fScroll = TRUE;

        if (SBSetParms((PSBDATA)&psbwnd->SBCalc, lpsi, &fScroll, &lres)) {
            xxxWindowEvent(EVENT_OBJECT_VALUECHANGE, (PWND)psbwnd, OBJID_CLIENT,
                    INDEX_SCROLLBAR_SELF, WEF_USEPWNDTHREAD);
        }

        if (!fRedraw)
            return lres;


        /*
         * We must set the new position of the caret irrespective of
         * whether the window is visible or not;
         * Still, this will work only if the app has done a xxxSetScrollPos
         * with fRedraw = TRUE;
         * Fix for Bug #5188 --SANKAR-- 10-15-89
         * No need to DeferWinEventNotify since psbwnd is locked.
         */
        zzzHideCaret((PWND)psbwnd);
        SBCtlSetup(psbwnd);
        zzzSetSBCaretPos(psbwnd);

            /*
             ** The following zzzShowCaret() must be done after the DrawThumb2(),
             ** otherwise this caret will be erased by DrawThumb2() resulting
             ** in this bug:
             ** Fix for Bug #9263 --SANKAR-- 02-09-90
             *
             */

            /*
             *********** zzzShowCaret((PWND)psbwnd); ******
             */

        if (_FChildVisible((PWND)psbwnd) && fRedraw) {
            UINT    wDisable;
            HBRUSH  hbrUse;

            if (!fScroll)
                fScroll = !(lpsi->fMask & SIF_DISABLENOSCROLL);

            wDisable = (fScroll) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH;
            xxxEnableScrollBar((PWND) psbwnd, SB_CTL, wDisable);

            hdc = _GetWindowDC((PWND)psbwnd);
            hbrSave = GreSelectBrush(hdc, hbrUse = xxxGetColorObjects((PWND)psbwnd, hdc));

                /*
                 * Before we used to only hideshowthumb() if the mesage was
                 * not SBM_SETPOS.  I am not sure why but this case was ever
                 * needed for win 3.x but on NT it resulted in trashing the border
                 * of the scrollbar when the app called SetScrollPos() during
                 * scrollbar tracking.  - mikehar 8/26
                 */
            DrawThumb2((PWND)psbwnd, &psbwnd->SBCalc, hdc, hbrUse, psbwnd->fVert,
                         psbwnd->wDisableFlags);
            GreSelectBrush(hdc, hbrSave);
            _ReleaseDC(hdc);
        }

            /*
             * This zzzShowCaret() has been moved to this place from above
             * Fix for Bug #9263 --SANKAR-- 02-09-90
             */
        zzzShowCaret((PWND)psbwnd);
        return lres;

    case SBM_GETSCROLLBARINFO:
        return (LONG)xxxGetScrollBarInfo((PWND)psbwnd, OBJID_CLIENT, (PSCROLLBARINFO)lParam);

    default:
DoDefault:
        return xxxDefWindowProc((PWND)psbwnd, message, wParam, lParam);
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\sendmsg.c ===
/****************************** Module Header ******************************\
* Module Name: sendmsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains SendMessage, xxxSendNotifyMessage, ReplyMessage, InSendMessage,
* RegisterWindowMessage and a few closely related functions.
*
* History:
* 10-19-90 darrinm      Created.
* 02-04-91 IanJa        Window handle revalidation added
\***************************************************************************/

#include "precomp.h"

#include <dbt.h>

#pragma hdrstop

#define IsASwitchWnd( pw )  \
        (gpsi->atomSysClass[ICLS_SWITCH] == pw->pcls->atomClassName)

#define IsOleMainThreadWnd( pw )  \
        (gaOleMainThreadWndClass == pw->pcls->atomClassName)

VOID UnlinkSendListSms(PSMS, PSMS *);
VOID ReceiverDied(PSMS, PSMS *);
VOID SenderDied(PSMS, PSMS *);
NTSTATUS InitSMSLookaside(VOID);

#pragma alloc_text(INIT, InitSMSLookaside)

/*
 * Globals local to this file only
 */
PPAGED_LOOKASIDE_LIST SMSLookaside;

#ifdef DEBUG_SMS

/*
 * JimA - 08-24-94
 * In addition to doing no useful work, the psmsSendList/psmsSendNext
 * stuff is broken and therefore should be  removed.  It works fine as
 * long as straight SendMessage is used.  The list will be broken if
 * a thread calls SendMessage while processing a message sent with
 * SentNotifyMessage or SendMessageCallback.
 */
void ValidateSmsSendLists(PSMS psms)
{
    PSMS psmsT2;
    PSMS psmsT3;

    /*
     * First try to find this SMS.
     */
    if (psms != NULL) {
        for (psmsT2 = gpsmsList; psmsT2 != NULL; psmsT2 = psmsT2->psmsNext) {
            if (psmsT2 == psms)
                break;
        }

        UserAssertMsg1(psmsT2 != NULL, "sms %#p is not on global sms list\n", psms);
    }

    /*
     * Validate every SMS's send list.
     */
    for (psmsT2 = gpsmsList; psmsT2 != NULL; psmsT2 = psmsT2->psmsNext) {
        if (psmsT2->ptiSender != NULL) {
            for (psmsT3 = psmsT2->psmsSendList; psmsT3 != NULL;
                    psmsT3 = psmsT3->psmsSendNext) {
                if (psmsT3 == psmsT2)
                    break;
            }

            UserAssertMsg2(psmsT3 != NULL,
                           "sms %#p is not on send list %#p\n",
                           psmsT2,
                           psmsT2->psmsSendList);
        }
    }
}
#endif

/***************************************************************************\
* BroadcastProc
*
* Some windows need to be insulated from Broadcast messages.
* These include icon title windows, the switch window, all
* menu windows, etc.  Before stuffing the message in the task's
* queue, check to see if it is one we want to trash.
*
* Notes:  this procedure does not do exactly the same thing it does in
* windows 3.1.  There it actually posts/Sends the message.  For NT, it
* just returns TRUE if we SHOULD post the message, or FALSE other wise
*
* History:
* 25-Jun-1992 JonPa      Ported from Windows 3.1 sources
\***************************************************************************/
#define fBroadcastProc( pwnd )  \
    (!(ISAMENU(pwnd) || IsASwitchWnd(pwnd) || IsOleMainThreadWnd(pwnd)))



/***************************************************************************\
* StubAllocSMS / StubFreeSMS
*
* These are stub routines for SMS allocations. We need these to call
* our debug UserAlloc routines
*
* Dec-16-97  clupu   Created.
\***************************************************************************/
PVOID StubAllocSMS(
    POOL_TYPE PoolType,
    SIZE_T uBytes,
    ULONG iTag)
{
    return UserAllocPool(uBytes, iTag);

    UNREFERENCED_PARAMETER(PoolType);
}

VOID StubFreeSMS(
    PVOID p)
{
    UserFreePool(p);
}

/***************************************************************************\
* InitSMSLookaside
*
* Initializes the SMS entry lookaside list. This improves SMS entry locality
* by keeping SMS entries in a single page
*
* 09-09-93  Markl   Created.
\***************************************************************************/

NTSTATUS
InitSMSLookaside()
{
    SMSLookaside = Win32AllocPoolNonPagedNS(sizeof(PAGED_LOOKASIDE_LIST),
                                            TAG_LOOKASIDE);
    if (SMSLookaside == NULL) {
        return STATUS_NO_MEMORY;
    }

    ExInitializePagedLookasideList(SMSLookaside,
                                   StubAllocSMS,
                                   StubFreeSMS,
                                   POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                   sizeof(SMS),
                                   TAG_SMS,
                                   8);

    return STATUS_SUCCESS;
}

/***************************************************************************\
* AllocSMS
*
* Allocates a message on a message list. DelSMS deletes a message
* on a message list.
*
* 10-22-92 ScottLu      Created.
\***************************************************************************/

PSMS AllocSMS(
    VOID)
{
    return ExAllocateFromPagedLookasideList(SMSLookaside);
}

/***************************************************************************\
* FreeSMS
*
* Returns a qmsg to the lookaside buffer or free the memory.
*
* 10-26-93 JimA         Created.
\***************************************************************************/

void FreeSMS(
    PSMS psms)
{
    ExFreeToPagedLookasideList(SMSLookaside, psms);
}

/***************************************************************************\
* _ReplyMessage (API)
*
* This function replies to a message sent from one thread to another, using
* the provided lRet value.
*
* The return value is TRUE if the calling thread is processing a SendMessage()
* and FALSE otherwise.
*
* History:
* 01-13-91 DavidPe      Ported.
* 01-24-91 DavidPe      Rewrote for Windows.
\***************************************************************************/

BOOL _ReplyMessage(
    LRESULT lRet)
{
    PTHREADINFO ptiCurrent;
    PSMS psms;

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    /*
     * Are we processing a SendMessage?
     */
    psms = ptiCurrent->psmsCurrent;
    if (psms == NULL)
        return FALSE;

    /*
     * See if the reply has been made already.
     */
    if (psms->flags & SMF_REPLY)
        return FALSE;

    /*
     * Blow off the rest of the call if the SMS came
     * from xxxSendNotifyMessage().  Obviously there's
     * no one around to reply to in the case.
     */
    if (psms->ptiSender != NULL) {

        /*
         * Reply to this message.  The sender should not free the SMS
         * because the receiver still considers it valid.  Thus we
         * mark it with a special bit indicating it has been replied
         * to.  We wait until both the sender and receiver are done
         * with the sms before we free it.
         */
        psms->lRet = lRet;
        psms->flags |= SMF_REPLY;

        /*
         * Wake up the sender.
         * ??? why don't we test that psms == ptiSender->psmsSent?
         */
        SetWakeBit(psms->ptiSender, QS_SMSREPLY);
    } else if (psms->flags & SMF_CB_REQUEST) {

        /*
         * From SendMessageCallback REQUEST callback.  Send the message
         * back with a the REPLY value.
         */
        TL tlpwnd;
        INTRSENDMSGEX ism;

        psms->flags |= SMF_REPLY;

        if (!(psms->flags & SMF_SENDERDIED)) {
            ism.fuCall = ISM_CALLBACK | ISM_REPLY;
            if (psms->flags & SMF_CB_CLIENT)
                ism.fuCall |= ISM_CB_CLIENT;
            ism.lpResultCallBack = psms->lpResultCallBack;
            ism.dwData = psms->dwData;
            ism.lRet = lRet;

            ThreadLockWithPti(ptiCurrent, psms->spwnd, &tlpwnd);

            xxxInterSendMsgEx(psms->spwnd, psms->message, 0L, 0L,
                    NULL, psms->ptiCallBackSender, &ism );

            ThreadUnlock(&tlpwnd);
        }
    }

    /*
     * We have 4 conditions to satisfy:
     *
     * 16 - 16 : receiver yields if sender is waiting for this reply
     * 32 - 16 : receiver yields if sender is waiting for this reply
     * 16 - 32 : no yield required
     * 32 - 32 : No yielding required.
     */
    if (psms->ptiSender &&
        (psms->ptiSender->TIF_flags & TIF_16BIT || ptiCurrent->TIF_flags & TIF_16BIT)) {

        DirectedScheduleTask(ptiCurrent, psms->ptiSender, FALSE, psms);
        if (ptiCurrent->TIF_flags & TIF_16BIT && psms->ptiSender->psmsSent == psms) {
            xxxSleepTask(TRUE, NULL);
        }
    }

    return TRUE;
}

VOID
UserLogError(
    PCWSTR pwszError,
    ULONG cbError,
    NTSTATUS ErrorCode)
{
    PIO_ERROR_LOG_PACKET perrLogEntry;

    /*
     * Allocate an error packet, fill it out, and write it to the log.
     */
    perrLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(gpWin32kDriverObject,
                                (UCHAR)(cbError + sizeof(IO_ERROR_LOG_PACKET)));
    if (perrLogEntry) {
        perrLogEntry->ErrorCode = ErrorCode;
        if (cbError) {
            perrLogEntry->NumberOfStrings = 1;
            perrLogEntry->StringOffset = FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
            RtlCopyMemory(perrLogEntry->DumpData, pwszError, cbError);
        }
        IoWriteErrorLogEntry(perrLogEntry);
    }
}

NTSTATUS
GetWindowLuid(
    PWND pwnd,
    PLUID pluidWnd
    )
{
    PACCESS_TOKEN pUserToken = NULL;
    BOOLEAN fCopyOnOpen;
    BOOLEAN fEffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    NTSTATUS Status;
    PTHREADINFO pti = GETPTI(pwnd);

    //
    // Get the window's thread token
    //
    pUserToken = PsReferenceImpersonationToken(pti->pEThread,
            &fCopyOnOpen, &fEffectiveOnly, &ImpersonationLevel);

    if (pUserToken == NULL) {

        //
        // No thread token, go to the process
        //

        pUserToken = PsReferencePrimaryToken(pti->ppi->Process);
        if (pUserToken == NULL)
            return STATUS_NO_TOKEN;
    }

    Status = SeQueryAuthenticationIdToken(pUserToken, pluidWnd);

    //
    // We're finished with the token
    //

    ObDereferenceObject(pUserToken);

    return Status;
}

BOOL xxxSendBSMtoDesktop(
    PWND pwndDesk,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPBROADCASTSYSTEMMSGPARAMS pbsmParams)
{
    PBWL pbwl;
    HWND *phwnd;
    PWND pwnd;
    TL tlpwnd;
    BOOL fReturnValue = TRUE;
    BOOL fFilterDriveMsg = FALSE;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL fPrivateMessage = (message >= WM_USER) && (message < MAXINTATOM);
    DEV_BROADCAST_VOLUME dbv;


    if (fPrivateMessage) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Attempt to broadcast a private message");
    }

    pbwl = BuildHwndList(pwndDesk->spwndChild, BWL_ENUMLIST, NULL);

    if (pbwl == NULL)
        return 0;

    if (!(pbsmParams->dwFlags & BSF_POSTMESSAGE)) {
        /*
         * Does the caller want to allow the receivers to take the foreground
         *  while processing the notification?
         */
        /*
         * Bug 412159. In order to allow the AppsHelp window to come to the
         * foreground we set ptiLastWoken to NULL, which will allow any window
         * to come to the foreground after a CD's been inserted.
         */
        if ((pbsmParams->dwFlags & BSF_ALLOWSFW) &&
           (GETPDESK(pwndDesk) == grpdeskRitInput) &&
           ((ptiCurrent->TIF_flags & TIF_CSRSSTHREAD)
            || CanForceForeground(ptiCurrent->ppi FG_HOOKLOCK_PARAM(ptiCurrent)))) {
             glinp.ptiLastWoken = NULL;
         }

    }

    /*
     * Determine if we need to filter the Drive Letter mask in fnINDEVICECHANGE
     * WM_DEVICECHANGE message are sent synchronously
     * LUID DosDevices maps must be enabled
     */
    if ((gLUIDDeviceMapsEnabled == TRUE) &&
        (message == WM_DEVICECHANGE) &&
        ((wParam == DBT_DEVICEREMOVECOMPLETE) || (wParam == DBT_DEVICEARRIVAL)) &&
        (((struct _DEV_BROADCAST_HEADER *)lParam)->dbcd_devicetype == DBT_DEVTYP_VOLUME)
        ) {
        LUID luidClient;
        NTSTATUS Status;

        if( ((DEV_BROADCAST_VOLUME *)lParam)->dbcv_unitmask & DBV_FILTER_MSG ) {
            return 0;
        }
        else {
            dbv = *((DEV_BROADCAST_VOLUME *)lParam);
            dbv.dbcv_unitmask |= DBV_FILTER_MSG;
        }

        /*
         * Caller must be LocalSystem and BSF_LUID is not specified
         */
        if (!(pbsmParams->dwFlags & BSF_LUID)) {
            Status = GetProcessLuid(NULL, &luidClient);
            if (NT_SUCCESS(Status) &&
                    RtlEqualLuid(&luidClient, &luidSystem)) {
                fFilterDriveMsg = TRUE;
            }
        }
    }

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        BOOL UseFilterLparam = FALSE;

        /*
         * Make sure this hwnd is still around.
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        if (pbsmParams->dwFlags &  BSF_IGNORECURRENTTASK) {
        // Don't deal with windows in the current task.
            if (GETPTI(pwnd)->pq == ptiCurrent->pq)
                continue;
        }

        if (pbsmParams->dwFlags &  BSF_LUID) {
            LUID luidWnd;

            luidWnd.LowPart = luidWnd.HighPart = 0;
            /*
             * Now we have the window Luid LuidWindow
             * Check to see if it is equal to the callers Luid or not
             */
            if (!NT_SUCCESS(GetWindowLuid(pwnd, &luidWnd)) ||
                    !RtlEqualLuid(&pbsmParams->luid, &luidWnd)) {
                continue;
            }
        }

        if (fFilterDriveMsg == TRUE) {
            LUID luidWnd;

            if (!NT_SUCCESS(GetWindowLuid(pwnd, &luidWnd))) {
                continue;
            }

            /*
             * Since LocalSystem uses the Global DosDevices,
             * don't filter for windows owned by LocalSystem
             */
            if(!RtlEqualLuid(&luidSystem, &luidWnd)) {
                UseFilterLparam = TRUE;
            }
        }

        /*
         * Make sure this window can handle broadcast messages
         */

        if (!fBroadcastProc(pwnd)) {
            continue;
        }

        if (fPrivateMessage && TestWF(pwnd, WFWIN40COMPAT)) { // Don't broadcast
            continue;                                         // private message
        }                                                     // to 4.0 apps.

        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

        // Now, send message; This could be a query; so, remember the return value.
        if (pbsmParams->dwFlags & BSF_POSTMESSAGE) {
            _PostMessage(pwnd, message, wParam, lParam);
        } else if (pbsmParams->dwFlags & BSF_SENDNOTIFYMESSAGE) {
            /*
             * We don't want to wait for an answer, but we don't want to use
             * PostMessage either. This is useful if you need to maintain the
             * order in which messages are delivered, but you only want to
             * wait for some of them. See WM_POWERBROADCAST for an example.
             */
            xxxSendNotifyMessage(pwnd, message, wParam, lParam);
        } else if (pbsmParams->dwFlags & BSF_QUEUENOTIFYMESSAGE) {
            /*
             * We don't want to wait for an answer, but we don't want to use
             * PostMessage either. This is useful if you need to maintain the
             * order in which messages are delivered, but you only want to
             * wait for some of them. See WM_POWERBROADCAST for an example.
             */
            QueueNotifyMessage(pwnd, message, wParam, lParam);
        } else {
            /*
             * pbsmParams->dwFlags can be changed while we loop here
             *  so we need to check it in every iteration.
             */
            BOOL fNoHang = (BOOL)pbsmParams->dwFlags & BSF_NOHANG;
            BOOL fForce = (BOOL)pbsmParams->dwFlags & BSF_FORCEIFHUNG;
            DWORD dwTimeout;
            ULONG_PTR dwResult = 0;

            if (fNoHang)
                dwTimeout = CMSWAITTOKILLTIMEOUT;
            else
                dwTimeout = 0;

            if (xxxSendMessageTimeout(pwnd, message, wParam,
                (UseFilterLparam ? (LPARAM)&dbv : lParam),
                (fNoHang ? SMTO_ABORTIFHUNG : SMTO_NORMAL) |
                ((pbsmParams->dwFlags & BSF_NOTIMEOUTIFNOTHUNG) ? SMTO_NOTIMEOUTIFNOTHUNG : 0),
                dwTimeout, &dwResult)) {

                if (pbsmParams->dwFlags & BSF_QUERY) {
                    // For old messages, returning 0 means a deny
                    if(message == WM_QUERYENDSESSION)
                        fReturnValue = (dwResult != 0);
                    else
                    // For all new messages, returning BROADCAST_QUERY_DENY is
                    // the way to deny a query.
                        fReturnValue = (dwResult != BROADCAST_QUERY_DENY);
                }
            } else {
                fReturnValue = fForce;
            }

            /*
             * If our query was denied, return immediately.
             */
            if (fReturnValue == 0) {
                // Store who denied the query.
                pbsmParams->hwnd = HWq(pwnd);
                if (pbsmParams->dwFlags & BSF_RETURNHDESK) {
                    NTSTATUS Status;
                    HDESK hdesk = NULL;
                    if (pwnd->head.rpdesk) {
                        Status = ObOpenObjectByPointer(pwnd->head.rpdesk,
                                                       0,
                                                       NULL,
                                                       EVENT_ALL_ACCESS,
                                                       NULL,
                                                       UserMode,
                                                       &hdesk);
                        if (!NT_SUCCESS(Status)) {
                            RIPMSG2(RIP_WARNING, "Could not get a handle for pdesk %#p Status %x",
                                    pwnd->head.rpdesk, Status);
                        }
                    }
                    pbsmParams->hdesk = hdesk;
                }

                if (message == WM_POWERBROADCAST && wParam == PBT_APMQUERYSUSPEND) {
                    WCHAR wchTask[40];
                    ULONG cbTask;

                    /*
                     * Get the application name and log an error.
                     */
                    cbTask = GetTaskName(GETPTI(pwnd), wchTask, sizeof(wchTask));
                    UserLogError(wchTask, cbTask, WARNING_POWER_QUERYSUSPEND_CANCELLED);
                }
                ThreadUnlock(&tlpwnd);
                break;
            }
        }
        ThreadUnlock(&tlpwnd);
    }

    FreeHwndList(pbwl);

    return fReturnValue;
}

LONG xxxSendMessageBSM(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPBROADCASTSYSTEMMSGPARAMS pbsmParams)

{
    PTHREADINFO ptiCurrent = PtiCurrent();
    LONG        lRet;

    if (pbsmParams->dwRecipients & BSM_ALLDESKTOPS) {
        PWINDOWSTATION  pwinsta;
        PDESKTOP        pdesk;
        TL              tlpwinsta;
        TL              tlpdesk;

        /*
         * Walk through all windowstations and desktop looking for
         * top-level windows.
         */
        ThreadLockWinSta(ptiCurrent, NULL, &tlpwinsta);
        ThreadLockDesktop(ptiCurrent, NULL, &tlpdesk, LDLT_FN_SENDMESSAGEBSM);
        for (pwinsta = grpWinStaList; pwinsta != NULL; ) {
            ThreadLockExchangeWinSta(ptiCurrent, pwinsta, &tlpwinsta);
            for (pdesk = pwinsta->rpdeskList; pdesk != NULL; ) {
                ThreadLockExchangeDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_SENDMESSAGEBSM);

                lRet = xxxSendBSMtoDesktop(pdesk->pDeskInfo->spwnd,
                              message, wParam, lParam, pbsmParams);

                /*
                 * If our query was denied, return immediately.
                 */
                if ((lRet == 0) && (pbsmParams->dwFlags & BSF_QUERY)) {
                    ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_SENDMESSAGEBSM1);
                    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
                    return 0;
                }
                pdesk = pdesk->rpdeskNext;
            }
            pwinsta = pwinsta->rpwinstaNext;
        }
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_SENDMESSAGEBSM2);
        ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    } else {
        lRet = xxxSendBSMtoDesktop(pwnd, message, wParam, lParam,
                    pbsmParams);
    }

    return lRet;
}


/***************************************************************************\
* xxxSendMessageFF
*
* We can't check for -1 in the thunks because that would allow all message
* thunk apis to take -1 erroneously. Since all message apis need to go through
* the message thunks, the message thunks can only do least-common-denominator
* hwnd validation (can't allow -1). So I made a special thunk that gets called
* when SendMessage(-1) gets called. This means the client side will do the
* special stuff to make sure the pwnd passed goes through thunk validation
* ok. I do it this way rather than doing validation in all message apis and
* not in the thunks (if I did it this way the code would be larger and
* inefficient in the common cases).
*
* 03-20-92 ScottLu      Created.
\***************************************************************************/

LRESULT xxxSendMessageFF(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    DBG_UNREFERENCED_PARAMETER(pwnd);

    /*
     * Call xxxSendMessage() to do broadcasting rather than calling
     * broadcast from here in case any internal code that calls
     * sendmessage passes a -1 (that way the internal code doesn't
     * need to know about this weird routine).
     */
    if (xParam != 0L) {
        /*
         * SendMessageTimeout call
         */
        return xxxSendMessageEx(PWND_BROADCAST, message, wParam, lParam, xParam);
    } else {
        /*
         * Normal SendMessage call
         */
        return xxxSendMessageTimeout(PWND_BROADCAST, message, wParam,
                lParam, SMTO_NORMAL, 0, NULL );
    }
}

/***************************************************************************\
* xxxSendMessageEx
*
* The SendMessageTimeOut sends a pointer to struct that holds the extra
* params needed for the timeout call.  Instead of chaning a bunch of things,
* we use the xParam to hold a ptr to a struct.  So we change the client/srv
* entry point to hear so we can check for the extra param and extract the
* stuff we need if it's there.
*
*
* WARNING!!!! RETURN VALUE SWAPPED
*
* Only call this function from the thunks!
*
* our thunks are written for SendMessage where it returns the value of
* the message.  This routine is used to dispatch SendMessageTimeout calls.
* SendMessageTimeout returns only TRUE or FALSE and returns the retval of
* the function in lpdwResult.  So here the meanings are swapped and fixed
* up again in Client side SendMessageTimeout
*
*
* 08-10-92 ChrisBl      Created.
\***************************************************************************/

LRESULT xxxSendMessageEx(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    /*
     * extract values from the xParam if from TimeOut call
     * This should be the only way this function is ever
     * called, but check it just in case...
     */
    if (xParam != 0L) {
        LRESULT lRet;
        LRESULT lResult;
        NTSTATUS Status;
        SNDMSGTIMEOUT smto;
        PETHREAD Thread = PsGetCurrentThread();

        if (Thread == NULL)
            return FALSE;

        /*
         * Probe all read arguments
         */
        try {
            ProbeForWrite((PVOID)xParam, sizeof(smto), sizeof(ULONG));
            smto = *(SNDMSGTIMEOUT *)xParam;
            Status = STATUS_SUCCESS;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            Status = GetExceptionCode();
        }
        if ( !NT_SUCCESS(Status) ) {
            return FALSE;
        }

        lRet = xxxSendMessageTimeout(pwnd, message, wParam, lParam,
                smto.fuFlags, smto.uTimeout, &lResult );

        /*
         * put the result back into the client
         */
        smto.lSMTOResult = lResult;
        smto.lSMTOReturn = lRet;

        try {
            *(SNDMSGTIMEOUT *)xParam = smto;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            lResult = FALSE;
        }

        /*
         * Return the lResult so our thunks are happy.
         */
        return lResult;
    }

    return xxxSendMessageTimeout(pwnd, message, wParam,
            lParam, SMTO_NORMAL, 0, NULL );
}


/***********************************************************************\
* xxxSendMessage (API)
*
* This function synchronously sends a message to a window. The four
* parameters hwnd, message, wParam, and lParam are passed to the window
* procedure of the receiving window.  If the window receiving the message
* belongs to the same queue as the current thread, the window proc is called
* directly.  Otherwise, we set up an sms structure, wake the appropriate
* thread to receive the message and wait for a reply.
*
* Returns:
*   the value returned by the window procedure, or NULL if there is an error
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

LRESULT xxxSendMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    return xxxSendMessageTimeout( pwnd, message, wParam, lParam,
            SMTO_NORMAL, 0, NULL );
}

/***********************************************************************\
* xxxSendMessageToClient
*
* History:
* 04-22-98 GerardoB   Extracted from xxxSendMessageTimeout, xxxSendMesageCallback
*                      and xxxReceiveMessage
* 05-12-00 JStall     Changed from macro to inline function.
\***********************************************************************/
__inline void
xxxSendMessageToClient(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PSMS psms,
    BOOL fLock,
    LRESULT * plRet)
{
    DWORD dwSCMSFlags;
    WORD fnid;

    /*
     * If the window has a client side worker proc and has
     * not been subclassed, dispatch the message directly
     * to the worker proc.  Otherwise, dispatch it normally.
     */
    dwSCMSFlags = TestWF((pwnd), WFANSIPROC) ? SCMS_FLAGS_ANSI : 0;

    if (gihmodUserApiHook >= 0) {
        /*
         * UserApiHooks are installed, so we can't optimize the sending because
         * the OverrideWndProc's needs to get the message.
         */
        goto StandardSend;
    }

    fnid = GETFNID((pwnd));
    if ((fnid >= FNID_CONTROLSTART && fnid <= FNID_CONTROLEND) &&
        ((ULONG_PTR)(pwnd)->lpfnWndProc == FNID_TO_CLIENT_PFNW(fnid) ||
         (ULONG_PTR)(pwnd)->lpfnWndProc == FNID_TO_CLIENT_PFNA(fnid))) {
        PWNDMSG pwm = &gSharedInfo.awmControl[fnid - FNID_START] ;
        /*
         * If this message is not processed by the control, call
         * xxxDefWindowProc
         */
        if (pwm->abMsgs && (((message) > pwm->maxMsgs) ||
                !((pwm->abMsgs)[(message) / 8] & (1 << ((message) & 7))))) {
            /*
             * If this is a dialog window, we need to call the client because
             *  the app might want this message (eventhough DefDlgProc doesn't
             *  want it).
             * If the dialog hasn't been marked as such, the app's DlgProc is
             *  not yet available so it's OK to ignore the message.
             */
            if (TestWF((pwnd), WFDIALOGWINDOW)) {
                *plRet = ScSendMessageSMS((pwnd), (message), (wParam), (lParam),
                        dwSCMSFlags, (PROC)(FNID_TO_CLIENT_PFNWORKER(fnid)),
                        dwSCMSFlags, (psms));
            } else {
                TL tlpwnd;
                if (fLock) {
                    ThreadLock((pwnd), &tlpwnd);
                }
                *plRet = xxxDefWindowProc((pwnd), (message), (wParam), (lParam));
                if (fLock) {
                    ThreadUnlock(&tlpwnd);
                }
            }
        } else {
            *plRet = ScSendMessageSMS((pwnd), (message), (wParam), (lParam),
                    dwSCMSFlags, (PROC)(FNID_TO_CLIENT_PFNWORKER(fnid)),
                    dwSCMSFlags, (psms));
        }
    } else {
StandardSend:
        *plRet = ScSendMessageSMS((pwnd), (message), (wParam), (lParam),
                (ULONG_PTR)(pwnd)->lpfnWndProc,
                gpsi->apfnClientW.pfnDispatchMessage, dwSCMSFlags, (psms));
    }
}


/***********************************************************************\
* xxxSendMessageTimeout (API)
*
* This function synchronously sends a message to a window. The four
* parameters hwnd, message, wParam, and lParam are passed to the window
* procedure of the receiving window.  If the window receiving the message
* belongs to the same queue as the current thread, the window proc is called
* directly.  Otherwise, we set up an sms structure, wake the appropriate
* thread to receive the message and wait for a reply.
* If the thread is 'hung' or if the time-out value is exceeded, we will
* fail the request.
*
* lpdwResult = NULL if normal sendmessage, if !NULL then it's a timeout call
*
* Returns:
*   the value returned by the window procedure, or NULL if there is an error
*
* History:
* 07-13-92 ChrisBl      Created/extended from SendMessage
\***********************************************************************/

LRESULT xxxSendMessageTimeout(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    UINT fuFlags,
    UINT uTimeout,
    PLONG_PTR lpdwResult)
{
    LRESULT lRet;
    PTHREADINFO ptiCurrent;
    ULONG_PTR uResult;   // holder for DDE_INITIATE case

    CheckCritIn();

    if (lpdwResult != NULL)
       *lpdwResult = 0L;

    /*
     * Is this a BroadcastMsg()?
     */
    if (pwnd == PWND_BROADCAST) {
        BROADCASTMSG bcm;
        PBROADCASTMSG pbcm = NULL;
        UINT uCmd = BMSG_SENDMSG;

        if (lpdwResult != NULL) {
            uCmd = BMSG_SENDMSGTIMEOUT;
            bcm.to.fuFlags = fuFlags;
            bcm.to.uTimeout = uTimeout;
            bcm.to.lpdwResult = lpdwResult;
            pbcm = &bcm;
        }

        return xxxBroadcastMessage(NULL, message, wParam, lParam, uCmd, pbcm );
    }

    CheckLock(pwnd);

    if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST) {
        /*
         * Even though apps should only send WM_DDE_INITIATE or WM_DDE_ACK
         * messages, we hook them all so DDESPY can monitor them.
         */
        if (!xxxDDETrackSendHook(pwnd, message, wParam, lParam)) {
            return 0;
        }
        if (message == WM_DDE_INITIATE && guDdeSendTimeout) {
            /*
             * This hack prevents DDE apps from locking up because some
             * one in the system has a top level window and is not
             * processing messages.  guDdeSendTimeout is registry set.
             */
            if (lpdwResult == NULL) {
                lpdwResult = &uResult;
            }
            fuFlags |= SMTO_ABORTIFHUNG;
            uTimeout = guDdeSendTimeout;
        }
    }

    ptiCurrent = PtiCurrent();

    /*
     * Do inter-thread call if window queue differs from current queue
     */
    if (ptiCurrent != GETPTI(pwnd)) {
        INTRSENDMSGEX ism;
        PINTRSENDMSGEX pism = NULL;

        /*
         * If this window is a zombie, don't allow inter-thread send messages
         * to it.
         */
        if (HMIsMarkDestroy(pwnd))
            return xxxDefWindowProc(pwnd, message, wParam, lParam);

        if ( lpdwResult != NULL ) {
            /*
             * fail if we think the thread is hung
             */
            if ((fuFlags & SMTO_ABORTIFHUNG) && FHungApp(GETPTI(pwnd), CMSWAITTOKILLTIMEOUT))
               return 0;

            /*
             * Setup for a InterSend time-out call
             */
            ism.fuCall = ISM_TIMEOUT;
            ism.fuSend = fuFlags;
            ism.uTimeout = uTimeout;
            ism.lpdwResult = lpdwResult;
            pism = &ism;
        }

        lRet = xxxInterSendMsgEx(pwnd, message, wParam, lParam,
                ptiCurrent, GETPTI(pwnd), pism );

        return lRet;
    }

    /*
     * Call WH_CALLWNDPROC if it's installed and the window is not marked
     * as destroyed.
     */
    if (IsHooked(ptiCurrent, WHF_CALLWNDPROC)) {
        CWPSTRUCTEX cwps;

        cwps.hwnd = HWq(pwnd);
        cwps.message = message;
        cwps.wParam = wParam;
        cwps.lParam = lParam;
        cwps.psmsSender = NULL;

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.
         */
        xxxCallHook(HC_ACTION, FALSE, (LPARAM)&cwps, WH_CALLWNDPROC);

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.  If this behavior reverts to
         * Win3.1 semantics, we will need to copy the new parameters
         * from cwps.
         */
    }

    /*
     * If this window's proc is meant to be executed from the server side
     * we'll just stay inside the semaphore and call it directly.  Note
     * how we don't convert the pwnd into an hwnd before calling the proc.
     */
    if (TestWF(pwnd, WFSERVERSIDEPROC)) {

        /*
         * We have a number of places where we do recursion in User.  This often goes
         * through SendMessage (when we send a message to the parent for example) which
         * can eat the amount of stack we have
         */
        if ((IoGetRemainingStackSize() < KERNEL_STACK_MINIMUM_RESERVE)
#if defined(_IA64_)
                || (GET_CURRENT_BSTORE() < KERNEL_BSTORE_MINIMUM_RESERVE)
#endif
            ) {
            RIPMSG1(RIP_ERROR, "SendMessage: Thread recursing in User with message %lX; failing", message);
            return FALSE;
        }


        lRet = pwnd->lpfnWndProc(pwnd, message, wParam, lParam);

        if ( lpdwResult == NULL ) {
            return lRet;
        } else {      /* time-out call */
            *lpdwResult = lRet;
            return TRUE;
        }
    }

    /*
     * Call the client or xxxDefWindowProc. pwnd is already locked.
     */
    xxxSendMessageToClient(pwnd, message, wParam, lParam, NULL, FALSE, &lRet);

    /*
     * Call WH_CALLWNDPROCRET if it's installed.
     */
    if (IsHooked(ptiCurrent, WHF_CALLWNDPROCRET)) {
        CWPRETSTRUCTEX cwps;

        cwps.hwnd = HWq(pwnd);
        cwps.message = message;
        cwps.wParam = wParam;
        cwps.lParam = lParam;
        cwps.lResult = lRet;
        cwps.psmsSender = NULL;

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.
         */
        xxxCallHook(HC_ACTION, FALSE, (LPARAM)&cwps, WH_CALLWNDPROCRET);

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.  If this behavior reverts to
         * Win3.1 semantics, we will need to copy the new parameters
         * from cwps.
         */
    }

    if ( lpdwResult != NULL ) {     /* time-out call */
        *lpdwResult = lRet;
        return TRUE;
    }

    return lRet;
}

/***************************************************************************\
* QueueNotifyMessage
*
* This routine queues up a notify message *only*, and does NOT do any callbacks
* or any waits. This is for certain code that cannot do a callback for
* compatibility reasons, but still needs to send notify messages (normal
* notify messages actually do a callback if the calling thread created the
* pwnd. Also this will NOT callback any hooks (sorry!)
*
* 04-13-93 ScottLu      Created.
\***************************************************************************/
void QueueNotifyMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TL tlpwnd;
    BEGINATOMICCHECK();

    /*
     * We have to thread lock the window even though we don't leave
     * the critical section or else xxxSendMessageCallback complains.
     */
    ThreadLock(pwnd, &tlpwnd);
    xxxSendMessageCallback(pwnd, message, wParam, lParam, NULL, 1L, 0);
    ThreadUnlock(&tlpwnd);
    ENDATOMICCHECK();
}


/***************************************************************************\
* xxxSystemBroadcastMessage
*
* Sends a message to all top-level windows in the system.  To do this
* for messages with parameters that point to data structures in a way
* that won't block on a hung app, post an event message for
* each window that is to receive the real message.  The real message
* will be sent when the event message is processed.
*
* History:
* 05-12-94 JimA         Created.
\***************************************************************************/

VOID xxxSystemBroadcastMessage(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    UINT wCmd,
    PBROADCASTMSG pbcm)
{
    PTHREADINFO     ptiCurrent = PtiCurrent();
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdesk;
    TL              tlpwinsta;
    TL              tlpdesk;

    /*
     * Walk through all windowstations and desktop looking for
     * top-level windows.
     */
    ThreadLockWinSta(ptiCurrent, NULL, &tlpwinsta);
    ThreadLockDesktop(ptiCurrent, NULL, &tlpdesk, LDLT_FN_SYSTEMBROADCASTMESSAGE);
    for (pwinsta = grpWinStaList; pwinsta != NULL; ) {
        UINT wCmd1;

        if ((wCmd == BMSG_SENDMSG) && (pwinsta != ptiCurrent->rpdesk->rpwinstaParent))
            wCmd1 = BMSG_SENDNOTIFYMSG;
        else
            wCmd1 = wCmd;

        ThreadLockExchangeWinSta(ptiCurrent, pwinsta, &tlpwinsta);
        for (pdesk = pwinsta->rpdeskList; pdesk != NULL; ) {

            ThreadLockExchangeDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_SYSTEMBROADCASTMESSAGE);

            /*
             * Bug 276814. Don't recurse calling again xxxBroadcastMessage if there
             * is no window on this desktop.
             */
            if (pdesk->pDeskInfo->spwnd != NULL) {
                xxxBroadcastMessage(pdesk->pDeskInfo->spwnd, message, wParam, lParam,
                        wCmd1, pbcm);
            }

            pdesk = pdesk->rpdeskNext;
        }
        pwinsta = pwinsta->rpwinstaNext;
    }
    ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_SYSTEMBROADCASTMESSAGE);
    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
}


/***********************************************************************\
* xxxSendNotifyMessage (API)
*
* This function sends a message to the window proc associated with pwnd.
* The window proc is executed in the context of the thread which created
* pwnd.  The function is identical to SendMessage() except that in the
* case of an inter-thread call, the send does not wait for a reply from
* the receiver, it simply returns a BOOL indicating success or failure.
* If the message is sent to a window on the current thread, then the
* function behaves just like SendMessage() and essentially does a
* subroutine call to pwnd's window procedure.
*
* History:
* 01-23-91 DavidPe      Created.
* 07-14-92 ChrisBl      Will return T/F if in same thread, as documented
\***********************************************************************/

BOOL xxxSendNotifyMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    /*
     * If this is a broadcast of one of the system
     * notification messages,  send it to all top-level
     * windows in the system.
     */
    if (pwnd == PWND_BROADCAST) {
        switch (message) {
        case WM_WININICHANGE:
        case WM_DEVMODECHANGE:
        case WM_SPOOLERSTATUS:
            xxxSystemBroadcastMessage(message, wParam, lParam,
                    BMSG_SENDNOTIFYMSG, NULL);
            return 1;

        default:
            break;
        }
    }

    return xxxSendMessageCallback( pwnd, message, wParam, lParam,
            NULL, 0L, 0 );
}


/***********************************************************************\
* xxxSendMessageCallback (API)
*
* This function synchronously sends a message to a window. The four
* parameters hwnd, message, wParam, and lParam are passed to the window
* procedure of the receiving window.  If the window receiving the message
* belongs to the same queue as the current thread, the window proc is called
* directly.  Otherwise, we set up an sms structure, wake the appropriate
* thread to receive the message and give him a call back function to send
* the result to.
*
* History:
* 07-13-92 ChrisBl      Created/extended from SendNotifyMessage
\***********************************************************************/

BOOL xxxSendMessageCallback(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    SENDASYNCPROC lpResultCallBack,
    ULONG_PTR dwData,
    BOOL fClientRequest)
{
    LRESULT lRet;
    PTHREADINFO ptiCurrent;
    BOOL fQueuedNotify;

    /*
     * See if this is a queued notify message.
     */
    fQueuedNotify = FALSE;
    if (lpResultCallBack == NULL && dwData == 1L)
        fQueuedNotify = TRUE;

    /*
     * First check to see if this message takes DWORDs only. If it does not,
     * fail the call. Cannot allow an app to post a message with pointers or
     * handles in it - this can cause the server to fault and cause other
     * problems - such as causing apps in separate address spaces to fault.
     * (or even an app in the same address space to fault!)
     */
    if (TESTSYNCONLYMESSAGE(message, wParam)) {
        RIPERR1(ERROR_MESSAGE_SYNC_ONLY, RIP_WARNING,
                "Trying to non-synchronously send a structure msg=%lX", message);
        return FALSE;
    }

    CheckCritIn();

    /*
     * Is this a BroadcastMsg()?
     */
    if (pwnd == PWND_BROADCAST) {
        BROADCASTMSG bcm;
        PBROADCASTMSG pbcm = NULL;
        UINT uCmd = BMSG_SENDNOTIFYMSG;

        if (lpResultCallBack != NULL) {
            uCmd = BMSG_SENDMSGCALLBACK;
            bcm.cb.lpResultCallBack = lpResultCallBack;
            bcm.cb.dwData = dwData;
            bcm.cb.bClientRequest = fClientRequest;
            pbcm = &bcm;
        }

        return xxxBroadcastMessage(NULL, message, wParam, lParam, uCmd, pbcm );
    }

    CheckLock(pwnd);

    ptiCurrent = PtiCurrent();

    /*
     * Do inter-thread call if window thead differs from current thread.
     * We pass NULL for ptiSender to tell xxxInterSendMsgEx() that this is
     * a xxxSendNotifyMessage() and that there's no need for a reply.
     *
     * If this is a queued notify, always call InterSendMsgEx() so that
     * we queue it up and return - we don't do callbacks here with queued
     * notifies.
     */
    if (fQueuedNotify || ptiCurrent != GETPTI(pwnd)) {
        INTRSENDMSGEX ism;
        PINTRSENDMSGEX pism = NULL;

        if (lpResultCallBack != NULL) {  /* CallBack request */
            ism.fuCall = ISM_CALLBACK | (fClientRequest ? ISM_CB_CLIENT : 0);
            ism.lpResultCallBack = lpResultCallBack;
            ism.dwData = dwData;
            pism = &ism;
        }
        return (BOOL)xxxInterSendMsgEx(pwnd, message, wParam, lParam,
                NULL, GETPTI(pwnd), pism );
    }

    /*
     * Call WH_CALLWNDPROC if it's installed.
     */
    if (!fQueuedNotify && IsHooked(ptiCurrent, WHF_CALLWNDPROC)) {
        CWPSTRUCTEX cwps;

        cwps.hwnd = HWq(pwnd);
        cwps.message = message;
        cwps.wParam = wParam;
        cwps.lParam = lParam;
        cwps.psmsSender = NULL;

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.
         */
        xxxCallHook(HC_ACTION, FALSE, (LPARAM)&cwps, WH_CALLWNDPROC);

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.  If this behavior reverts to
         * Win3.1 semantics, we will need to copy the new parameters
         * from cwps.
         */
    }

    /*
     * If this window's proc is meant to be executed from the server side
     * we'll just stay inside the semaphore and call it directly.  Note
     * how we don't convert the pwnd into an hwnd before calling the proc.
     */
    if (TestWF(pwnd, WFSERVERSIDEPROC)) {
        lRet = pwnd->lpfnWndProc(pwnd, message, wParam, lParam);
    } else {
        /*
         * Call the client or xxxDefWindowProc. pwnd is already locked
         */
        xxxSendMessageToClient(pwnd, message, wParam, lParam, NULL, FALSE, &lRet);
    }

    if (lpResultCallBack != NULL) {
       /*
        * Call the callback funtion for the return value
        */
        if (fClientRequest) {
            /*
             * The application-defined callback proc is neither Unicode/ANSI
             */
            SET_FLAG(ptiCurrent->pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE);
            CallClientProcA(pwnd, message, dwData, lRet,
                    (ULONG_PTR)lpResultCallBack);
            CLEAR_FLAG(ptiCurrent->pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE);
        } else {
            (*lpResultCallBack)((HWND)pwnd, message, dwData, lRet);
        }
    }

    /*
     * Call WH_CALLWNDPROCRET if it's installed.
     */
    if (!fQueuedNotify && IsHooked(ptiCurrent, WHF_CALLWNDPROCRET)) {
        CWPRETSTRUCTEX cwps;

        cwps.hwnd = HWq(pwnd);
        cwps.message = message;
        cwps.wParam = wParam;
        cwps.lParam = lParam;
        cwps.lResult = lRet;
        cwps.psmsSender = NULL;

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.
         */
        xxxCallHook(HC_ACTION, FALSE, (LPARAM)&cwps, WH_CALLWNDPROCRET);

        /*
         * Unlike Win3.1, NT and Win95 ignore any changes the app makes
         * to the CWPSTRUCT contents.  If this behavior reverts to
         * Win3.1 semantics, we will need to copy the new parameters
         * from cwps.
         */
    }

    return TRUE;
}


/***********************************************************************\
* xxxInterSendMsgEx
*
* This function does an inter-thread send message.  If ptiSender is NULL,
* that means we're called from xxxSendNotifyMessage() and should act
* accordingly.
*
* History:
* 07-13-92 ChrisBl       Created/extended from xxxInterSendMsg
\***********************************************************************/

#define NoString        0
#define IsAnsiString    1
#define IsUnicodeString 2

/*
 * We will capture the an address in two cases
 * 1- If the address is a user mode address or
 * 2- The call is a SendNotifyMessafe or SendMessageCallback.
 *
 * #2 is true if ptiSender is NULL see xxxSendMessageCallback implementation.
 * Why we do that?
 * if we are in SendNotifyMessafe or SendMessageCallback then force capture.
 * because these two APIs will not wait till the receiver thread handles the
 * message, then any kernel stack memory will be invalid once we return from
 * these two APIs.
 */
#define FORCE_CAPTURE(Addr) (!IS_SYSTEM_ADDRESS(Addr) || (ptiSender == NULL))

LRESULT xxxInterSendMsgEx(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PTHREADINFO ptiSender,
    PTHREADINFO ptiReceiver,
    PINTRSENDMSGEX pism)
{
    PSMS psms, *ppsms;
    PSMS psmsSentSave;
    LRESULT lRet = 0;
    DWORD cbCapture, cbOutput;
    PBYTE lpCapture;
    PCOPYDATASTRUCT pcds;
    PMDICREATESTRUCTEX pmdics;
    LPHLP phlp;
    LPHELPINFO phelpinfo;
    LARGE_STRING str;
    LPARAM lParamSave;
    UINT fString = NoString;
    BOOLEAN bWasSwapEnabled;

    CheckCritIn();


    /*
     * If the sender is dying, fail the call
     */
    if ((ptiSender != NULL) && (ptiSender->TIF_flags & TIF_INCLEANUP))
        return 0;

    /*
     * Some messages cannot be sent across process because we don't know how to thunk them
     * Fail attempts to read passwords across processes.
     */
    if (pwnd && GETPTI(pwnd)->ppi != PpiCurrent()) {
        switch (message) {
        case WM_NOTIFY:
            RIPMSG0(RIP_WARNING | RIP_THERESMORE, "xxxInterSendMsgEx: message cannot be sent across processes");
            RIPMSG4(RIP_WARNING | RIP_THERESMORE, " pwnd:%#p message:%#x wParam:%#p lParam:%#p", pwnd, message, wParam, lParam);
            return 0;

        /*
         * A change was introduced here to check with IS_EDIT macro instead of directly
         * accessing FNID.  The reason is to maintain conformity and not break
         * comctl32 v6 password edits which can't set fnid field in pwnd.
         */
        case WM_GETTEXT:
        case EM_GETLINE:
        case EM_SETPASSWORDCHAR:
            if (IS_EDIT(pwnd) && TestWF(pwnd, EFPASSWORD)) {
                RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Can't access protected edit control");
                return 0;
            }
            break;
        }
    }

    /*
     * Alloc SMS structure.
     */
    psms = AllocSMS();
    if (psms == NULL) {

        /*
         * Set to zero so xxxSendNotifyMessage would return FALSE.
         */
        return 0;
    }

    /*
     * Prepare to capture variable length data from client
     * space.  Addresses have already been probed.  Fixed-length
     * data is probed and captured in the message thunk.
     */
    psms->pvCapture = NULL;
    cbCapture = cbOutput = 0;
    lpCapture = (LPBYTE)lParam;

    /*
     * If this is a reply message then wParam and lParam is equal NULL.
     * No need to capture anything.
     */
    if ((pism != NULL) && (pism->fuCall == (ISM_CALLBACK | ISM_REPLY))) {
        goto REPLY_MSG;
    }

    /*
     * For messages with indirect data, set cbCapture and lpCapture
     * (if not lParam) as approp.
     */
    try {
        switch (message) {
        case WM_COPYGLOBALDATA:     // fnCOPYGLOBALDATA
            cbCapture = (DWORD)wParam;
            break;

        case WM_COPYDATA:           // fnCOPYDATA
            pcds = (PCOPYDATASTRUCT)lParam;
            if (pcds->lpData) {
                cbCapture = sizeof(COPYDATASTRUCT) + pcds->cbData;
            } else {
                cbCapture = sizeof(COPYDATASTRUCT);
            }
            break;

        case WM_CREATE:             // fnINLPCREATESTRUCT
        case WM_NCCREATE:           // fnINLPCREATESTRUCT
            RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Can't Intersend WM_CREATE or WM_NCCREATE message");
            FreeSMS(psms);
            return 0;

        case WM_HELP:               // fnINLPHELPINFOSTRUCT
            phelpinfo = (LPHELPINFO)lParam;
            cbCapture = phelpinfo->cbSize;
            break;

        case WM_WINHELP:            // fnINLPHLPSTRUCT
            phlp = (LPHLP)lParam;
            cbCapture = phlp->cbData;
            break;

        case WM_MDICREATE:          // fnINLPMDICREATESTRUCT
            pmdics = (PMDICREATESTRUCTEX)lParam;
            cbCapture = pmdics->strTitle.MaximumLength +
                    pmdics->strClass.MaximumLength;
            UserAssert(pmdics->strClass.Buffer == NULL || pmdics->strClass.Buffer == pmdics->mdics.szClass);
            if (pmdics->strTitle.Buffer)
                UserAssert(pmdics->strTitle.Buffer == pmdics->mdics.szTitle);
            break;

        case LB_ADDSTRING:           // INLBOXSTRING calls fnINSTRING
        case LB_INSERTSTRING:        // INLBOXSTRING calls fnINSTRING
        case LB_SELECTSTRING:        // INLBOXSTRING calls fnINSTRING
        case LB_FINDSTRING:          // INLBOXSTRING calls fnINSTRING
        case LB_FINDSTRINGEXACT:     // INLBOXSTRING calls fnINSTRING
            /*
             * See if the control is ownerdraw and does not have the LBS_HASSTRINGS
             * style. If so, treat lParam as a DWORD.
             */
            if (pwnd && !(pwnd->style & LBS_HASSTRINGS) &&
                    (pwnd->style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE))) {
                /*
                 * Treat lParam as a dword.
                 */
                break;
            } else {
                goto fnINSTRINGThunk;
            }
            break;

        case CB_ADDSTRING:           // INCBOXSTRING calls fnINSTRING
        case CB_INSERTSTRING:        // INCBOXSTRING calls fnINSTRING
        case CB_SELECTSTRING:        // INCBOXSTRING calls fnINSTRING
        case CB_FINDSTRING:          // INCBOXSTRING calls fnINSTRING
        case CB_FINDSTRINGEXACT:     // INCBOXSTRING calls fnINSTRING
            /*
             * See if the control is ownerdraw and does not have the CBS_HASSTRINGS
             * style. If so, treat lParam as a DWORD.
             */
            if (pwnd && !(pwnd->style & CBS_HASSTRINGS) &&
                    (pwnd->style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))) {

                /*
                 * Treat lParam as a dword.
                 */
                break;
            } else {
                goto fnINSTRINGThunk;
            }
            break;

        case EM_REPLACESEL:         // fnINSTRINGNULL
        case WM_SETTEXT:            // fnINSTRINGNULL
        case WM_WININICHANGE:       // fnINSTRINGNULL
            if (lParam == 0)
                break;

            /*
             * Fall through
             */

        case CB_DIR:                // fnINSTRING
        case LB_ADDFILE:            // fnINSTRING
        case LB_DIR:                // fnINSTRING
        case WM_DEVMODECHANGE:      // fnINSTRING
fnINSTRINGThunk:

            /*
             * Only capture strings if they are not in system space or ptiSender
             * is NULL (see FORCE_CAPTURE definition).
             *
             * Also we are going to capture the LARGE_STRING structure itself because
             * it is (lParam) a stack memory.
             */
            str = *(PLARGE_STRING)lParam;

            if (FORCE_CAPTURE(str.Buffer))
                cbCapture = str.Length + sizeof(WCHAR) + sizeof(LARGE_STRING);
            break;

        case WM_DEVICECHANGE:
            if (lParam == 0)
                break;

            /*
             * Only capture data if lParam is a pointer and
             * the data is not in system space
             */
            if ((wParam & 0x8000) != 0x8000)
                break;

            if (FORCE_CAPTURE((LPVOID)lParam)) {
                cbCapture = *((DWORD *)lpCapture);
                UserAssert(FALSE);
            }
            break;

        case EM_SETTABSTOPS:        // fnPOPTINLPUINT
        case LB_SETTABSTOPS:        // fnPOPTINLPUINT
        case LB_GETSELITEMS:        // fnPOUTLPINT
            cbCapture = (UINT)wParam * sizeof(INT);
            break;

        case EM_GETLINE:            // fnINCNTOUTSTRING
        case WM_ASKCBFORMATNAME:    // fnINCNTOUTSTRINGNULL
        case WM_GETTEXT:            // fnOUTSTRING
        case LB_GETTEXT:            // fnOUTLBOXSTRING
        case CB_GETLBTEXT:          // fnOUTCBOXSTRING

            /*
             * Only allocate output buffer if the real one is not in system space
             */
            str = *(PLARGE_STRING)lParam;
            /*
            * Bug 18108. For WM_GETTEXT only copy the actual string and not the
            * the maximum size into the output buffer
            */
            if(str.bAnsi) {
                fString = IsAnsiString  ;
            } else {
                fString  = IsUnicodeString ;
            }
            lParam = (LPARAM)&str;
            if (FORCE_CAPTURE(str.Buffer))
                cbCapture = str.MaximumLength;
            break;
        }
        if (cbCapture &&
                (psms->pvCapture = UserAllocPoolWithQuota(cbCapture, TAG_SMS_CAPTURE)) != NULL) {

            lParamSave = lParam;

            /*
             * now actually copy memory from lpCapture to psms->pvCapture
             * and fixup any references to the indirect data to point to
             * psms->pvCapture.
             */
            switch (message) {
            case WM_COPYDATA:     // fnCOPYDATA
                {
                    PCOPYDATASTRUCT pcdsNew = (PCOPYDATASTRUCT)psms->pvCapture;
                    lParam = (LPARAM)pcdsNew;
                    RtlCopyMemory(pcdsNew, pcds, sizeof(COPYDATASTRUCT));
                    if (pcds->lpData) {
                        pcdsNew->lpData = (PVOID)((PBYTE)pcdsNew + sizeof(COPYDATASTRUCT));
                        RtlCopyMemory(pcdsNew->lpData, pcds->lpData, pcds->cbData);
                    }
                }
                break;
            case WM_MDICREATE:          // fnINLPMDICREATESTRUCT
                if (pmdics->strClass.Buffer) {
                    RtlCopyMemory(psms->pvCapture, pmdics->strClass.Buffer,
                            pmdics->strClass.MaximumLength);
                    pmdics->mdics.szClass = (LPWSTR)psms->pvCapture;
                }
                if (pmdics->strTitle.Length) {
                    lpCapture = (PBYTE)psms->pvCapture + pmdics->strClass.MaximumLength;
                    RtlCopyMemory(lpCapture, pmdics->strTitle.Buffer,
                            pmdics->strTitle.MaximumLength);
                    pmdics->mdics.szTitle = (LPWSTR)lpCapture;
                }
                break;

            case CB_DIR:                // fnINSTRING
            case LB_FINDSTRING:         // INLBOXSTRING calls fnINSTRING
            case LB_FINDSTRINGEXACT:    // INLBOXSTRING calls fnINSTRING
            case CB_FINDSTRING:         // INCBOXSTRING calls fnINSTRING
            case CB_FINDSTRINGEXACT:    // INCBOXSTRING calls fnINSTRING
            case LB_ADDFILE:            // fnINSTRING
            case LB_ADDSTRING:          // INLBOXSTRING calls fnINSTRING
            case LB_INSERTSTRING:       // INLBOXSTRING calls fnINSTRING
            case LB_SELECTSTRING:       // INLBOXSTRING calls fnINSTRING
            case CB_ADDSTRING:          // INCBOXSTRING calls fnINSTRING
            case CB_INSERTSTRING:       // INCBOXSTRING calls fnINSTRING
            case CB_SELECTSTRING:       // INCBOXSTRING calls fnINSTRING
            case LB_DIR:                // fnINSTRING
            case WM_DEVMODECHANGE:      // fnINSTRING
            case EM_REPLACESEL:         // fnINSTRINGNULL
            case WM_SETTEXT:            // fnINSTRINGNULL
            case WM_WININICHANGE:       // fnINSTRINGNULL
                {
                    PLARGE_STRING pstr = psms->pvCapture;
                    lParam = (LPARAM)pstr;
                    pstr->bAnsi  = str.bAnsi;
                    pstr->Length = str.Length;
                    pstr->Buffer = (LPBYTE)pstr + sizeof(LARGE_STRING);
                    pstr->MaximumLength = cbCapture - sizeof(LARGE_STRING);
                    UserAssert(pstr->MaximumLength == pstr->Length + sizeof(WCHAR));
                    RtlCopyMemory(pstr->Buffer, str.Buffer, pstr->MaximumLength);
                }
                break;

            case LB_GETSELITEMS:
                 cbOutput = cbCapture;
                 RtlCopyMemory(psms->pvCapture, lpCapture, cbCapture);
                 lParam = (LPARAM)psms->pvCapture;
                 break;

            case EM_GETLINE:            // fnINCNTOUTSTRING
                 *(WORD *)psms->pvCapture = *(WORD *)str.Buffer;

                /*
                 * Fall through
                 */
            case WM_ASKCBFORMATNAME:    // fnINCNTOUTSTRINGNULL
            case WM_GETTEXT:            // fnOUTSTRING
            case LB_GETTEXT:            // fnOUTLBOXSTRING
            case CB_GETLBTEXT:          // fnOUTCBOXSTRING
                cbOutput = cbCapture;
                lParamSave = (LPARAM)str.Buffer;
                str.Buffer = psms->pvCapture;
                break;

            default:
                RtlCopyMemory(psms->pvCapture, lpCapture, cbCapture);
                lParam = (LPARAM)psms->pvCapture;
                break;
            }
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        if (psms->pvCapture != NULL)
            UserFreePool(psms->pvCapture);
        FreeSMS(psms);
        return 0;
    }

    if (cbCapture && psms->pvCapture == NULL) {
        FreeSMS(psms);
        return 0;
    }
REPLY_MSG:
    /*
     * Copy message parms
     */
    psms->spwnd = NULL;
    psms->psmsReceiveNext = NULL;
#if DBG
    psms->psmsSendList = NULL;
    psms->psmsSendNext = NULL;
#endif
    Lock(&(psms->spwnd), pwnd);
    psms->message = message;
    psms->wParam = wParam;
    psms->lParam = lParam;
    psms->flags = 0;

    /*
     * Link into gpsmsList
     */
    psms->psmsNext = gpsmsList;
    gpsmsList = psms;

    /*
     * Time stamp message
     */
    psms->tSent = NtGetTickCount();

    /*
     * Set queue fields
     */
    psms->ptiReceiver = ptiReceiver;
    psms->ptiSender = ptiSender;
    psms->ptiCallBackSender = NULL;

    if ((pism != NULL) && (pism->fuCall & ISM_CALLBACK)) {
        /*
         * Setup for a SendMessageCallback
         */
        psms->flags |= (pism->fuCall & ISM_CB_CLIENT) ? SMF_CB_CLIENT : SMF_CB_SERVER;
        psms->lpResultCallBack = pism->lpResultCallBack;
        psms->dwData = pism->dwData;

        if (pism->fuCall & ISM_REPLY) {
            psms->flags |= SMF_CB_REPLY;
            psms->lRet = pism->lRet;
        } else {  /* REQUEST */
            psms->flags |= SMF_CB_REQUEST;
            psms->ptiCallBackSender = PtiCurrent();
        }
    }

    /*
     * Add SMS to the end of the ptiReceiver's receive list
     */
    ppsms = &ptiReceiver->psmsReceiveList;
    while (*ppsms != NULL) {
        ppsms = &((*ppsms)->psmsReceiveNext);
    }
    *ppsms = psms;

    /*
     * Link this SMS into the SendMsg chain.  Of course only do this if
     * it's not from a xxxSendNotifyMessage() call.
     *
     * The psmsSendNext field implements a chain of messages being
     * processed because of an initial SendMsg call.  For example, if
     * thread A sends message M1 to thread B, which causes B to send
     * message M2 to thread C, the SendMsg chain is M1->M2.  If the
     * system hangs in this situation, the chain is traversed to find
     * the offending thread (C).
     *
     * psms->psmsSendList always points to the head of this list so
     * we can tell where to begin a list traversal.
     *
     * ptiSender->psmsCurrent is the last SMS in the chain.
     */
#if DBG
    if (ptiSender != NULL && ptiSender->psmsCurrent != NULL) {
        /*
         * sending queue is currently processing a message sent to it,
         * so append SMS to the chain.  Link in the new sms because
         * psmsSendNext may be pointing to a replied-to message.
         */
        psms->psmsSendNext = ptiSender->psmsCurrent->psmsSendNext;
        ptiSender->psmsCurrent->psmsSendNext = psms;
        psms->psmsSendList = ptiSender->psmsCurrent->psmsSendList;

    } else {
        /*
         * sending queue is initiating a send sequence, so put sms at
         * the head of the chain
         */
        psms->psmsSendList = psms;
    }
#endif

    if (ptiSender != NULL) {
        /*
         * ptiSender->psmsSent marks the most recent message sent from this
         * thread that has not yet been replied to.  Save the previous value
         * on the stack so it can be restored when we get the reply.
         *
         * This way when an "older" SMS for this thread gets a reply before
         * the "current" one does, the thread does get woken up.
         */
        psmsSentSave = ptiSender->psmsSent;
        ptiSender->psmsSent = psms;
    } else {

        /*
         * Set SMF_RECEIVERFREE since we'll be returning to
         * xxxSendNotifyMessage() right away and won't get a
         * chance to free it.
         */
        psms->flags |= SMF_RECEIVERFREE;
    }

#ifdef DEBUG_SMS
    ValidateSmsSendLists(psms);
#endif

    /*
     * If we're not being called from xxxSendNotifyMessage() or
     * SendMessageCallback(), then sleep while we wait for the reply.
     */
    if (ptiSender == NULL) {
        /*
         * Wake receiver for the sent message
         */
        SetWakeBit(ptiReceiver, QS_SENDMESSAGE);

        return (LONG)TRUE;
    } else {
        BOOL fTimeOut = FALSE;
        UINT uTimeout = 0;
        UINT uWakeMask = QS_SMSREPLY;

        /*
         * Wake up the receiver thread.
         */
        SetWakeBit(ptiReceiver, QS_SENDMESSAGE);

        /*
         * We have 4 sending cases:
         *
         * 16 - 16 : yield to the 16 bit receiver
         * 32 - 16 : no yielding required
         * 16 - 32 : sender yields while receiver processes the message
         * 32 - 32 : no yielding required.
         */
        if (ptiSender->TIF_flags & TIF_16BIT || ptiReceiver->TIF_flags & TIF_16BIT) {
            DirectedScheduleTask(ptiSender, ptiReceiver, TRUE, psms);
        }

        /*
         * Put this thread to sleep until the reply arrives.  First clear
         * the QS_SMSREPLY bit, then leave the semaphore and go to sleep.
         *
         * IMPORTANT:  The QS_SMSREPLY bit is not cleared once we get a
         * reply because of the following case:
         *
         * We've recursed a second level into SendMessage() when the first level
         * receiver thread dies, causing exit list processing to simulate
         * a reply to the first message.  When the second level send returns,
         * SleepThread() is called again to get the first reply.
         *
         * Keeping QS_SMSREPLY set causes this call to SleepThread()
         * to return without going to sleep to wait for the reply that has
         * already happened.
         */
        if ( pism != NULL ) {
            if (pism->fuSend & SMTO_BLOCK) {
                /*
                 * only wait for a return, all other events will
                 * be ignored until timeout or return
                 */
                uWakeMask |= QS_EXCLUSIVE;
            }

            uTimeout = pism->uTimeout;
        }


        /*
         * Don't swap this guys stack while sleeping during a sendmessage
         */
        if (ptiSender->cEnterCount == 0) {
            bWasSwapEnabled = KeSetKernelStackSwapEnable(FALSE);
        } else {
            UserAssert(ptiSender->cEnterCount > 0);
        }
        ptiSender->cEnterCount++;


        while (!(psms->flags & SMF_REPLY) && !fTimeOut) {
            PHOOK phk = NULL;
            TL tl;
            BOOLEAN fRememberTimeout = FALSE;

            ptiSender->pcti->fsChangeBits &= ~QS_SMSREPLY;

            if (message == WM_HOOKMSG && lParam && GetAppCompatFlags2ForPti(ptiReceiver, VER51)) {
                phk = ((PHOOKMSGSTRUCT)lParam)->phk;
                switch (phk->iHook) {
                case WH_KEYBOARD_LL:
                case WH_MOUSE_LL:
                    ThreadLock(phk, &tl);
                    fRememberTimeout = TRUE;
                    break;
                }
            }

            /*
             * If SendMessageTimeout, sleep for timeout amount, else wait
             * forever.  Since this is not technically a transition to an
             * idle condition, indicate that this sleep is not going "idle".
             */
            fTimeOut = !xxxSleepThread(uWakeMask, uTimeout, FALSE);

            /*
             * Windows bug 307738: EverQuest LL hook is virtually
             * hung, blocking the DirectInput thread.
             */
            if (fRememberTimeout) {
                phk->fLastHookHung = fTimeOut;
                ThreadUnlock(&tl);
            }

            /*
             * If a timeout occurs, and the SMTO_NOTIMEOUTIFNOTHUNG bit is set,
             * and the app is still calling GetMessage(), then just try again.
             * This probably means that the receiver has put up some UI in
             * response to this message but the user hasn't completed the
             * interaction yet.
             */
            if (fTimeOut && pism && (pism->fuSend & SMTO_NOTIMEOUTIFNOTHUNG) &&
                    !FHungApp(ptiReceiver, CMSHUNGAPPTIMEOUT)) {
                fTimeOut = FALSE;
            }
        }

        UserAssert(ptiSender->cEnterCount > 0);
        if (--ptiSender->cEnterCount == 0) {
            KeSetKernelStackSwapEnable(bWasSwapEnabled);
        }

        /*
         * The reply bit should always be set! (even if we timed out). That
         * is because if we're recursed into intersendmsg, we're going to
         * return to the first intersendmsg's call to SleepThread() - and
         * it needs to return back to intersendmsgex to see if its sms
         * has been replied to.
         */
        SetWakeBit(ptiSender, QS_SMSREPLY);

        /*
         * Copy out captured data.  If cbOutput != 0 we know
         * that the output buffer is in user-mode address
         * space.
         */
        if (!fTimeOut && cbOutput) {
            PBYTE pbOutput;
            INT len;

            /*
             * Probe output buffer if it is in the user's address space
             */

            pbOutput = (PBYTE)lParamSave;
            try {
                if(fString == NoString) {
                    RtlCopyMemory((PBYTE)pbOutput, psms->pvCapture,
                            cbOutput);
                } else if(fString == IsAnsiString) {
                    len = strncpycch((LPSTR)pbOutput,(LPCSTR)psms->pvCapture,
                            cbOutput);
                    #if DBG
                     len--; //Length includes terminating NULL char
                     if(len != psms->lRet) {
                        RIPMSG0(RIP_WARNING,
                            "Length of the copied string being returned is diffrent from the actual string length");
                     }
                    #endif
                } else  { //IsUnicodeString
                    len = wcsncpycch((LPWSTR)pbOutput,(LPCWSTR)psms->pvCapture,
                            cbOutput/sizeof(WCHAR));
                    #if DBG
                    len--;
                     if(len != psms->lRet) {
                        RIPMSG0(RIP_WARNING,
                            "Length of the copied string being returned is diffrent from the actual string length");
                     }
                    #endif
                }
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {

                /*
                 * Return 0 to indicate an error.
                 */
                psms->lRet = 0;
            }
        }

        /*
         * we now have the reply -- restore psmsSent and save the return value
         */
        ptiSender->psmsSent = psmsSentSave;

        if (pism == NULL) {
            lRet = psms->lRet;
        } else {
            /*
             * save the values off for a SendMesssageTimeOut
             */
            *pism->lpdwResult = psms->lRet;
            lRet = (!fTimeOut) ? TRUE : FALSE;  /* do this to ensure ret is T or F... */

            /*
             * If we did timeout and no reply was received, rely on
             * the receiver to free the sms.
             */
            if (!(psms->flags & SMF_REPLY))
                psms->flags |= SMF_REPLY | SMF_RECEIVERFREE;
        }

        /*
         * If the reply came while the receiver is still processing
         * the sms, force the receiver to free the sms.  This can occur
         * via timeout, ReplyMessage or journal cancel.
         */
        if ((psms->flags & (SMF_RECEIVERBUSY | SMF_RECEIVEDMESSAGE)) !=
                SMF_RECEIVEDMESSAGE) {
            psms->flags |= SMF_RECEIVERFREE;
        }

        /*
         * Unlink the SMS structure from both the SendMsg chain and gpsmsList
         * list and free it.  This sms could be anywhere in the chain.
         *
         * If the SMS was replied to by a thread other than the receiver
         * (ie.  through ReplyMessage()), we don't free the SMS because the
         * receiver is still processing it and will free it when done.
         */
        if (!(psms->flags & SMF_RECEIVERFREE)) {
            UnlinkSendListSms(psms, NULL);
        }
    }

    return lRet;
}


/***********************************************************************\
* xxxReceiveMessage
*
* This function receives a message sent from another thread.  Physically,
* it gets the message, calls the window proc and then cleans up the
* fsWakeBits and sms stuctures.
*
* History:
* 01-13-91 DavidPe      Ported.
* 01-23-91 DavidPe      Add xxxSendNotifyMessage() support.
* 07-14-92 ChrisBl      Added xxxSendMessageCallback support.
\***********************************************************************/

VOID xxxReceiveMessage(
    PTHREADINFO ptiReceiver)
{
    PSMS psms;
    PSMS psmsCurrentSave;
    PTHREADINFO ptiSender;
    LRESULT lRet = 0;
    TL tlpwnd;

    CheckCritIn();

    /*
     * Get the SMS and unlink it from the list of SMSs we've received
     */
    psms = ptiReceiver->psmsReceiveList;

    /*
     * This can be NULL because an SMS can be removed in our cleanup
     * code without clearing the QS_SENDMESSAGE bit.
     */
    if (psms == NULL) {
        ptiReceiver->pcti->fsWakeBits &= ~QS_SENDMESSAGE;
        ptiReceiver->pcti->fsChangeBits &= ~QS_SENDMESSAGE;
        return;
    }

    ptiReceiver->psmsReceiveList = psms->psmsReceiveNext;
    psms->psmsReceiveNext = NULL;

    /*
     * We've taken the SMS off the receive list - mark the SMS with this
     * information - used during cleanup.
     */
    psms->flags |= SMF_RECEIVERBUSY | SMF_RECEIVEDMESSAGE;

    /*
     * Clear QS_SENDMESSAGE wakebit if list is now empty
     */
    if (ptiReceiver->psmsReceiveList == NULL) {
        ptiReceiver->pcti->fsWakeBits &= ~QS_SENDMESSAGE;
        ptiReceiver->pcti->fsChangeBits &= ~QS_SENDMESSAGE;
    }

    ptiSender = psms->ptiSender;

    if (psms->flags & SMF_CB_REPLY) {
        /*
         * From SendMessageCallback REPLY to callback.  We need to call
         * the call back function to give the return value.
         * Don't process any this message, just mechanism for notification
         * the sender's thread lock is already gone, so we need to re-lock here.
         */
        if (ptiSender == NULL) {
            ThreadLock(psms->spwnd, &tlpwnd);
        }

        if (psms->flags & SMF_CB_CLIENT) {
            PTHREADINFO ptiCurrent = PtiCurrent();
            /*
             * Application-defined callback proc is neither Unicode nor ANSI
             */
            SET_FLAG(ptiCurrent->pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE);
            CallClientProcA(psms->spwnd, psms->message, psms->dwData,
                    psms->lRet, (ULONG_PTR)psms->lpResultCallBack);
            CLEAR_FLAG(ptiCurrent->pcti->CTIF_flags, CTIF_INCALLBACKMESSAGE);
        } else {
            psms->lpResultCallBack(HW(psms->spwnd), psms->message,
                    psms->dwData, psms->lRet);
        }

        if (ptiSender == NULL) {
            ThreadUnlock(&tlpwnd);
        }
    } else if (!(psms->flags & (SMF_REPLY | SMF_SENDERDIED | SMF_RECEIVERDIED))) {
        /*
         * Don't process message if it has been replied to already or
         * if the sending or receiving thread has died
         */

        /*
         * Set new psmsCurrent for this queue, saving the current one
         */
        psmsCurrentSave = ptiReceiver->psmsCurrent;
        ptiReceiver->psmsCurrent = psms;
        SET_FLAG(ptiReceiver->pcti->CTIF_flags, CTIF_INSENDMESSAGE);

        /*
         * If this SMS originated from a xxxSendNotifyMessage() or a
         * xxxSendMessageCallback() call, the sender's thread lock is
         * already gone, so we need to re-lock here.
         */
        if (ptiSender == NULL) {
            ThreadLock(psms->spwnd, &tlpwnd);
        }

        if (psms->message == WM_HOOKMSG) {
            union {
                EVENTMSG emsg;          // WH_JOURNALRECORD/PLAYBACK
                MOUSEHOOKSTRUCTEX mhs;  // WH_MOUSE
                KBDLLHOOKSTRUCT   kbds; // WH_KEYBORD_LL
                MSLLHOOKSTRUCT    mslls;// WH_MOUSE_LL
#ifdef REDIRECTION
                HTHOOKSTRUCT      ht;   // WH_HITTEST
#endif // REDIRECTION
            } LocalData;
            PVOID pSendersData;
            PHOOKMSGSTRUCT phkmp;
            int iHook;
            BOOL bAnsiHook;

            /*
             * Some hook types (eg: WH_JOURNALPLAYBACK) pass pointers to
             * data in the calling thread's stack.  We must copy this to our
             * own (called thread's) stack for safety because of the way this
             * "message" is handled and in case the calling thread dies. #13577
             *
             * Originally only WH_JOURNALRECORD and WH_JOURNALPLAYBACK went
             * through this code, but now all sorts of hooks do.
             */
            phkmp = (PHOOKMSGSTRUCT)psms->lParam;
            pSendersData = (PVOID)(phkmp->lParam);
            iHook = phkmp->phk->iHook;

            switch (iHook) {
            case WH_JOURNALRECORD:
            case WH_JOURNALPLAYBACK:
                if (pSendersData)
                    LocalData.emsg = *(PEVENTMSG)pSendersData;
                break;

            case WH_MOUSE:
                if (pSendersData)
                    LocalData.mhs = *(LPMOUSEHOOKSTRUCTEX)pSendersData;
                break;

            case WH_KEYBOARD_LL:
                if (pSendersData)
                    LocalData.kbds = *(LPKBDLLHOOKSTRUCT)pSendersData;
                break;

            case WH_MOUSE_LL:
                if (pSendersData)
                    LocalData.mslls = *(LPMSLLHOOKSTRUCT)pSendersData;
                break;

#ifdef REDIRECTION
            case WH_HITTEST:
                if (pSendersData)
                    LocalData.ht = *(LPHTHOOKSTRUCT)pSendersData;
                break;
#endif // REDIRECTION

            case WH_KEYBOARD:
            case WH_SHELL:
                /*
                 * Fall thru...
                 */
                pSendersData = NULL;
                break;

            default:
                /*
                 * No pointers: wParam & lParam can be sent as is.
                 */
                RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "Receive hook %d", iHook);
                pSendersData = NULL;
                break;
            }


            lRet = xxxCallHook2(phkmp->phk, phkmp->nCode, psms->wParam,
                    pSendersData ? (LPARAM)&LocalData : phkmp->lParam, &bAnsiHook);

            /*
             * Copy back data only if the sender hasn't died or timed out
             * (timed out messages are marked SMF_REPLY by the sending thread)
             */
            if (!(psms->flags & (SMF_SENDERDIED|SMF_REPLY)) && pSendersData) {
                switch (iHook) {
                case WH_JOURNALRECORD:
                case WH_JOURNALPLAYBACK:
                    *(PEVENTMSG)pSendersData = LocalData.emsg;
                    break;

                case WH_KEYBOARD_LL:
                    *(LPKBDLLHOOKSTRUCT)pSendersData = LocalData.kbds;
                    break;

                case WH_MOUSE_LL:
                    *(LPMSLLHOOKSTRUCT)pSendersData = LocalData.mslls;
                    break;

                case WH_MOUSE:
                    *(LPMOUSEHOOKSTRUCTEX)pSendersData = LocalData.mhs;
                    break;

#ifdef REDIRECTION
                case WH_HITTEST:
                    *(LPHTHOOKSTRUCT)pSendersData = LocalData.ht;
                    break;
#endif // REDIRECTION
                }
            }

        } else {
            /*
             * Call WH_CALLWNDPROC if it's installed and the window is not marked
             * as destroyed.
             */
            if (IsHooked(ptiReceiver, WHF_CALLWNDPROC)) {
                CWPSTRUCTEX cwps;

                cwps.hwnd = HW(psms->spwnd);
                cwps.message = psms->message;
                cwps.wParam = psms->wParam;
                cwps.lParam = psms->lParam;
                cwps.psmsSender = psms;

                xxxCallHook(HC_ACTION, TRUE, (LPARAM)&cwps, WH_CALLWNDPROC);

                /*
                 * Unlike Win3.1, NT and Win95 ignore any changes the app makes
                 * to the CWPSTRUCT contents.  If this behavior reverts to
                 * Win3.1 semantics, we will need to copy the new parameters
                 * from cwps.
                 */
            }

            if (!(psms->flags & (SMF_REPLY | SMF_SENDERDIED | SMF_RECEIVERDIED)) &&
                    psms->spwnd != NULL) {
                if (TestWF(psms->spwnd, WFSERVERSIDEPROC)) {
                    TL tlpwndKernel;

                    ThreadLock(psms->spwnd, &tlpwndKernel);
                    /*
                     * If this window's proc is meant to be executed from the server side
                     * we'll just stay inside the semaphore and call it directly.  Note
                     * how we don't convert the pwnd into an hwnd before calling the proc.
                     */
                    lRet = psms->spwnd->lpfnWndProc(psms->spwnd, psms->message,
                            psms->wParam, psms->lParam);

                    ThreadUnlock(&tlpwndKernel);
                } else {
                    /*
                     * Call the client or xxxDefWindowProc.
                     */
                    xxxSendMessageToClient(psms->spwnd, psms->message, psms->wParam, psms->lParam,
                                        psms, TRUE, &lRet);
                }

                /*
                 * Call WH_CALLWNDPROCRET if it's installed.
                 */
                if (IsHooked(ptiReceiver, WHF_CALLWNDPROCRET) &&
                        !(psms->flags & SMF_SENDERDIED)) {
                    CWPRETSTRUCTEX cwps;

                    cwps.hwnd = HW(psms->spwnd);
                    cwps.message = psms->message;
                    cwps.wParam = psms->wParam;
                    cwps.lParam = psms->lParam;
                    cwps.lResult = lRet;
                    cwps.psmsSender = psms;

                    /*
                     * Unlike Win3.1, NT and Win95 ignore any changes the app makes
                     * to the CWPSTRUCT contents.
                     */
                    xxxCallHook(HC_ACTION, TRUE, (LPARAM)&cwps, WH_CALLWNDPROCRET);

                    /*
                     * Unlike Win3.1, NT and Win95 ignore any changes the app makes
                     * to the CWPSTRUCT contents.  If this behavior reverts to
                     * Win3.1 semantics, we will need to copy the new parameters
                     * from cwps.
                     */
                }
            }
        }

        if ((psms->flags & (SMF_CB_REQUEST | SMF_REPLY)) == SMF_CB_REQUEST) {

            /*
             * From SendMessageCallback REQUEST callback.  Send the message
             * back with a the REPLY value.
             */
            INTRSENDMSGEX ism;

            psms->flags |= SMF_REPLY;

            if (!(psms->flags & SMF_SENDERDIED)) {
                ism.fuCall = ISM_CALLBACK | ISM_REPLY;
                if (psms->flags & SMF_CB_CLIENT)
                    ism.fuCall |= ISM_CB_CLIENT;
                ism.lpResultCallBack = psms->lpResultCallBack;
                ism.dwData = psms->dwData;
                ism.lRet = lRet;

                xxxInterSendMsgEx(psms->spwnd, psms->message, 0L, 0L,
                        NULL, psms->ptiCallBackSender, &ism );
            }
        }

        if (ptiSender == NULL) {
            ThreadUnlock(&tlpwnd);
        }

        /*
         * Restore receiver's original psmsCurrent.
         */
        ptiReceiver->psmsCurrent = psmsCurrentSave;
        SET_OR_CLEAR_FLAG(ptiReceiver->pcti->CTIF_flags,
                          CTIF_INSENDMESSAGE,
                          ptiReceiver->psmsCurrent);

#ifdef DEBUG_SMS
        ValidateSmsSendLists(psmsCurrentSave);
#endif
    }

    /*
     * We're done with this sms, so the appropriate thread
     * can now free it.
     */
    psms->flags &= ~SMF_RECEIVERBUSY;

    /*
     * Free the sms and return without reply if the
     * SMF_RECEIVERFREE bit is set.  Handily, this does just what we
     * want for xxxSendNotifyMessage() since we set SMF_RECEIVERFREE
     * in that case.
     */
    if (psms->flags & SMF_RECEIVERFREE) {
        UnlinkSendListSms(psms, NULL);
        return;
    }

    /*
     * Set reply flag and return value if this message has not already
     * been replied to with ReplyMessage().
     */
    if (!(psms->flags & SMF_REPLY)) {
        psms->lRet = lRet;
        psms->flags |= SMF_REPLY;

        /*
         * Tell the sender, the reply is done
         */
        if (ptiSender != NULL) {
            /*
             * Wake up the sender thread.
             */
            SetWakeBit(ptiSender, QS_SMSREPLY);

            /*
             * We have 4 conditions to satisfy:
             *
             * 16 - 16 : yielding required, if sender is waiting for this reply
             * 32 - 16 : yielding required, if sender is waiting for this reply
             * 16 - 32 : no yielding required
             * 32 - 32 : No yielding required.
             */

            if (ptiSender->TIF_flags & TIF_16BIT || ptiReceiver->TIF_flags & TIF_16BIT) {
                DirectedScheduleTask(ptiReceiver, ptiSender, FALSE, psms);
                if (ptiReceiver->TIF_flags & TIF_16BIT &&
                    ptiSender->psmsSent == psms)
                  {
                    xxxSleepTask(TRUE, NULL);
                }
            }
        }
    }

}


/***********************************************************************\
* SendMsgCleanup
*
* This function cleans up sendmessage structures when the thread associated
* with a queue terminates.  In the following, S is the sending thread,
* R the receiving thread.
*
* Case Table:
*
* single death:
*   R no reply, S dies:  mark that S died, R will free sms
*   R no reply, R dies:  fake reply for S
*   R replied,  S dies:  free sms
*   R replied,  R dies:  no problem
*
* double death:
*   R no reply, S dies, R dies:  free sms
*   R no reply, R dies, S dies:  free sms
*   R replied,  S dies, R dies:  sms freed when S dies, as in single death
*   R replied,  R dies, S dies:  sms freed when S dies, as in single death
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID SendMsgCleanup(
    PTHREADINFO ptiCurrent)
{
    PSMS *ppsms;
    PSMS psmsNext;

    CheckCritIn();

    for (ppsms = &gpsmsList; *ppsms; ) {
        psmsNext = (*ppsms)->psmsNext;

        if ((*ppsms)->ptiSender == ptiCurrent ||
                (*ppsms)->ptiCallBackSender == ptiCurrent) {
            SenderDied(*ppsms, ppsms);
        } else if ((*ppsms)->ptiReceiver == ptiCurrent) {
            ReceiverDied(*ppsms, ppsms);
        }

        /*
         * If the message was not unlinked, go to the next one.
         */
        if (*ppsms != psmsNext)
            ppsms = &(*ppsms)->psmsNext;
    }
}


/***********************************************************************\
* ClearSendMessages
*
* This function marks messages destined for a given window as invalid.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID ClearSendMessages(
    PWND pwnd)
{
    PSMS psms, psmsNext;
    PSMS *ppsms;

    CheckCritIn();

    psms = gpsmsList;
    while (psms != NULL) {
        /*
         * Grab the next one beforehand in case we free the current one.
         */
        psmsNext = psms->psmsNext;

        if (psms->spwnd == pwnd) {

            /*
             * If the sender has died, then mark this receiver free so the
             * receiver will destroy it in its processing.
             */
            if (psms->flags & SMF_SENDERDIED) {
                psms->flags |= SMF_REPLY | SMF_RECEIVERFREE;
            } else {
                /*
                 * The sender is alive. If the receiver hasn't replied to
                 * this yet, make a reply so the sender gets it. Make sure
                 * the receiver is the one free it so we don't have a race
                 * condition.
                 */
                if (!(psms->flags & SMF_REPLY)) {

                    /*
                     * The sms is either still on the receive list
                     * or is currently being received. Since the sender
                     * is alive, we want the sender to get the reply
                     * to this SMS. If it hasn't been received, take
                     * it off the receive list and reply to it. If it
                     * has been received, then just leave it alone:
                     * it'll get replied to normally.
                     */
                    if (psms->flags & SMF_CB_REQUEST) {
                        /*
                         * From SendMessageCallback REQUEST callback.  Send the
                         * message back with a the REPLY value.
                         */
                        TL tlpwnd;
                        INTRSENDMSGEX ism;

                        psms->flags |= SMF_REPLY;

                        ism.fuCall = ISM_CALLBACK | ISM_REPLY;
                        if (psms->flags & SMF_CB_CLIENT)
                            ism.fuCall |= ISM_CB_CLIENT;
                        ism.lpResultCallBack = psms->lpResultCallBack;
                        ism.dwData = psms->dwData;
                        ism.lRet = 0L;    /* null return */

                        ThreadLock(psms->spwnd, &tlpwnd);

                        xxxInterSendMsgEx(psms->spwnd, psms->message, 0L, 0L,
                                NULL, psms->ptiCallBackSender, &ism );

                        ThreadUnlock(&tlpwnd);
                    } else if (!(psms->flags & SMF_RECEIVERBUSY)) {
                        /*
                         * If there is no sender, this is a notification
                         * message (nobody to reply to). In this case,
                         * just set the SMF_REPLY bit (SMF_RECEIVERFREE
                         * is already set) and this'll cause ReceiveMessage
                         * to just free this SMS and return.
                         */
                        if (psms->ptiSender == NULL) {
                            psms->flags |= SMF_REPLY;
                        } else {
                            /*
                             * There is a sender, and it wants a reply: take
                             * this SMS off the receive list, and reply
                             * to the sender.
                             */
                            for (ppsms = &(psms->ptiReceiver->psmsReceiveList);
                                        *ppsms != NULL;
                                        ppsms = &((*ppsms)->psmsReceiveNext)) {

                                if (*ppsms == psms) {
                                    *ppsms = psms->psmsReceiveNext;
                                    break;
                                }
                            }


      /*
                             * Reply to this message so the sender
                             * wakes up.
                             */
                            psms->flags |= SMF_REPLY;
                            psms->lRet = 0;
                            psms->psmsReceiveNext = NULL;
                            SetWakeBit(psms->ptiSender, QS_SMSREPLY);

                            /*
                             *  16 bit senders need to be notifed that sends completed
                             *  otherwise it may wait for a very long time for the reply.
                             */
                            if (psms->ptiSender->TIF_flags & TIF_16BIT) {
                                DirectedScheduleTask(psms->ptiReceiver, psms->ptiSender, FALSE, psms);
                            }
                        }
                    }
                }
            }

            /*
             * Unlock the pwnd from the SMS structure.
             */
            Unlock(&psms->spwnd);
        }

        psms = psmsNext;
    }
}

/***********************************************************************\
* ReceiverDied
*
* This function cleans up the send message structures after a message
* receiver window or queue has died.  It fakes a reply if one has not
* already been sent and the sender has not died.  It frees the sms if
* the sender has died.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID ReceiverDied(
    PSMS psms,
    PSMS *ppsmsUnlink)
{
    PSMS *ppsms;
    PTHREADINFO ptiReceiver;
    PTHREADINFO ptiSender;

    /*
     * mark that the receiver died
     */
    ptiReceiver = psms->ptiReceiver;
    psms->ptiReceiver = NULL;
    psms->flags |= SMF_RECEIVERDIED;

    /*
     * Unlink sms from thread if it is not dying.  We need to do
     * this for journal cleanup.
     */
    if (!(ptiReceiver->TIF_flags & TIF_INCLEANUP)) {

        /*
         * unlink sms from the receiver's receive list
         */
        for (ppsms = &(ptiReceiver->psmsReceiveList); *ppsms != NULL;
                    ppsms = &((*ppsms)->psmsReceiveNext)) {

            if (*ppsms == psms) {
                *ppsms = psms->psmsReceiveNext;
                break;
            }
        }

        /*
         * clear the QS_SENDMESSAGE bit if there are no more messages
         */
        if (ptiReceiver->psmsReceiveList == NULL) {
            ptiReceiver->pcti->fsWakeBits &= ~QS_SENDMESSAGE;
            ptiReceiver->pcti->fsChangeBits &= ~QS_SENDMESSAGE;
        }
    } else {

        /*
         * The receiver thread is dying.  Clear the received flag
         * so that if there is a sender, it will free the sms.
         */
        psms->flags &= ~SMF_RECEIVERBUSY;
    }

    psms->psmsReceiveNext = NULL;

    /*
     * Check if the sender died or if the receiver was marked to
     * free the sms.
     */
    if (psms->ptiSender == NULL) {

        if (!(psms->flags & SMF_SENDERDIED) &&
                (psms->flags & (SMF_CB_REQUEST | SMF_REPLY)) == SMF_CB_REQUEST) {

            /*
             * From SendMessageCallback REQUEST callback.  Send the message
             * back with a the REPLY value.
             */
            TL tlpwnd;
            INTRSENDMSGEX ism;

            psms->flags |= SMF_REPLY;

            ism.fuCall = ISM_CALLBACK | ISM_REPLY;
            if (psms->flags & SMF_CB_CLIENT)
                ism.fuCall |= ISM_CB_CLIENT;
            ism.lpResultCallBack = psms->lpResultCallBack;
            ism.dwData = psms->dwData;
            ism.lRet = 0L;    /* null return */

            ThreadLock(psms->spwnd, &tlpwnd);

            xxxInterSendMsgEx(psms->spwnd, psms->message, 0L, 0L,
                    NULL, psms->ptiCallBackSender, &ism );

            ThreadUnlock(&tlpwnd);
        }

        /*
         * If the receiver is not processing the message, free it.
         */
        if (!(psms->flags & SMF_RECEIVERBUSY))
            UnlinkSendListSms(psms, ppsmsUnlink);
        return;

    } else if (!(psms->flags & SMF_REPLY)) {

        /*
         * fake a reply
         */
        psms->flags |= SMF_REPLY;
        psms->lRet = 0;
        psms->ptiReceiver = NULL;

        /*
         * wake the sender if he was waiting for us
         */
        SetWakeBit(psms->ptiSender, QS_SMSREPLY);
    } else {
        /*
         * There is a reply. We know the receiver is dying, so clear the
         * SMF_RECEIVERFREE bit or the sender won't free this SMS!
         * Although the sender's wake bit has already been set by the
         * call to ClearSendMessages() earlier in the cleanup code,
         * set it here again for safety.
         *
         * ??? Why would SMF_RECEIVERFREE be set?
         */
        psms->flags &= ~SMF_RECEIVERFREE;
        SetWakeBit(psms->ptiSender, QS_SMSREPLY);
    }

    /*
     * If the sender is a WOW task, that task is now blocked in the non-
     * preemptive scheduler waiting for a reply.  DestroyTask will
     * clean this up (even if ptiReceiver is 32-bit).
     */
    ptiSender = psms->ptiSender;
    if (ptiSender->TIF_flags & TIF_16BIT) {
        DirectedScheduleTask(ptiReceiver, ptiSender, FALSE, psms);
    }

    /*
     * Unlock this window from the sms: it is no longer needed, and will get
     * rid of lock warnings.
     */
    Unlock(&psms->spwnd);
}


/***********************************************************************\
* SenderDied
*
* This function cleans up the send message structures after a message
* sender has died.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID SenderDied(
    PSMS psms,
    PSMS *ppsmsUnlink)
{
    PTHREADINFO ptiSender;
    BOOL fReply = FALSE;

    /*
     * mark the death
     */
    if (psms->ptiSender != NULL)
        ptiSender = psms->ptiSender;
    else
        ptiSender = psms->ptiCallBackSender;
    psms->ptiSender = NULL;
    psms->flags |= SMF_SENDERDIED;

    /*
     * There are two cases where we leave the sms alone so the receiver
     * can handle the message and then free the sms itself.
     *
     *  1.  When the receiver is processing the message.
     *
     *  2.  When the message has not yet been received.
     */

    /*
     * If the receiver is processing the message, make it free the sms.
     * Fake a reply for journal cancel.
     */
    if (psms->flags & SMF_RECEIVERBUSY) {
        psms->flags |= SMF_RECEIVERFREE;
        fReply = TRUE;
    }

    /*
     * This sms may be in the process of being sent, but has not yet
     * been received.  In so, fake a reply and wake the sender.
     * The last thread to touch the sms, either the sender or
     * receiver, will free the sms.
     */
    if (ptiSender->psmsSent == psms)
        fReply = TRUE;

    /*
     * If journalling is being cancelled and reply needs to be made,
     * fake a reply and return.
     */
    if (!(ptiSender->TIF_flags & TIF_INCLEANUP) && fReply) {

        /*
         * fake a reply
         */
        psms->flags |= SMF_REPLY;
        psms->lRet = 0;

        /*
         * wake the sender if he was waiting for us
         */
        SetWakeBit(ptiSender, QS_SMSREPLY);
        return;
    }

    /*
     * If the receiver isn't dead, check to see if it has honestly replied to
     * this SMS. If it has not replied, leave it alone so the receiver can
     * reply to it (it'll then clean it up). If it has replied, then it's
     * ok to free it.
     *
     * It is also ok to free it if the receiver is dead.
     */
    if ((psms->flags & SMF_RECEIVERDIED) ||
            (psms->flags & (SMF_REPLY | SMF_RECEIVERFREE)) == SMF_REPLY) {
        UnlinkSendListSms(psms, ppsmsUnlink);
    } else {
        psms->flags |= SMF_RECEIVERFREE;
    }
}


/***********************************************************************\
* UnlinkSendListSms
*
* This function unlinks an sms structure from both its SendMsg chain and
* the global gpsmsList and frees it.
*
* History:
* 01-13-91 DavidPe      Ported.
\***********************************************************************/

VOID UnlinkSendListSms(
    PSMS psms,
    PSMS *ppsmsUnlink)
{
#if DBG
    PSMS psmsT;
    BOOL fUpdateSendList;
    PSMS *ppsms;
#endif

    CheckCritIn();

#ifdef DEBUG_SMS
    ValidateSmsSendLists(psms);
#endif

    UserAssert(psms->psmsReceiveNext == NULL);

#if DBG
    /*
     * Remember ahead of time if the psms we're unlinking is also the
     * head of the sms send list (so we know if we need to update this field
     * member in every SMS in this list).
     */
    fUpdateSendList = (psms == psms->psmsSendList);

    /*
     * Unlink sms from the sendlist chain. This effectively unlinks the SMS
     * and updates psms->psmsSendList with the right head....
     */
    ppsms = &(psms->psmsSendList);
    while (*ppsms != NULL) {
        if (*ppsms == psms) {
            *ppsms = psms->psmsSendNext;
            break;
        }
        ppsms = &(*ppsms)->psmsSendNext;
    }

    /*
     * Update psmsSendList if necessary. psms->psmsSendList has been updated
     * with the right sms send list head... distribute this head to all other
     * sms's in this chain if this sms we're removing the current head.
     */
    if (fUpdateSendList) {
        for (psmsT = psms->psmsSendList; psmsT != NULL;
                psmsT = psmsT->psmsSendNext) {
            psmsT->psmsSendList = psms->psmsSendList;
        }
    }

    psms->psmsSendList = NULL;
#endif

    /*
     * This unlinks an sms structure from the global gpsmsList and frees it.
     */
    if (ppsmsUnlink == NULL) {
        ppsmsUnlink = &gpsmsList;

        while (*ppsmsUnlink && (*ppsmsUnlink != psms)) {
            ppsmsUnlink = &((*ppsmsUnlink)->psmsNext);
        }
    }

    UserAssert(*ppsmsUnlink);

    *ppsmsUnlink = psms->psmsNext;

    Unlock(&psms->spwnd);

#if DBG
    UserAssert(!(psms == psms->psmsSendList && psms->psmsSendNext != NULL));
#endif

    if (psms->pvCapture)
        UserFreePool(psms->pvCapture);

    FreeSMS(psms);
}


/***************************************************************************\
* xxxSendSizeMessages
*
*
*
* History:
* 10-19-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

void xxxSendSizeMessage(
    PWND pwnd,
    UINT cmdSize)
{
    RECT rc;
    CheckLock(pwnd);

    // Added by Chicago: HACK ALERT:
    // If the window is minimized then the real client width and height are
    // zero. But, in win3.1 they were non-zero. Under Chicago, PrintShop
    // Deluxe ver 1.2 hits a divide by zero. To fix this we fake the width
    // and height for old apps to be non-zero values.
    // GetClientRect does that job for us.
    _GetClientRect(pwnd, &rc);

    xxxSendMessage(pwnd, WM_SIZE, cmdSize,
            MAKELONG(rc.right - rc.left, rc.bottom - rc.top));
}


/***************************************************************************\
* xxxProcessAsyncSendMessage
*
* Processes an event message posted by xxxSystemBroadcastMessage by
* sending a message to the window stored in the event.
*
* History:
* 05-12-94 JimA         Created.
\***************************************************************************/

VOID xxxProcessAsyncSendMessage(
    PASYNCSENDMSG pmsg)
{
    PWND pwnd;
    TL tlpwndT;
    WCHAR awchString[MAX_PATH];
    ATOM Atom = 0;
    LARGE_UNICODE_STRING str;

    pwnd = RevalidateHwnd(pmsg->hwnd);
    if (pwnd != NULL) {
        ThreadLockAlways(pwnd, &tlpwndT);
        switch (pmsg->message) {
        case WM_WININICHANGE:
        case WM_DEVMODECHANGE:
            if (pmsg->lParam) {
                if (UserGetAtomName((ATOM)pmsg->lParam, awchString, sizeof(awchString))) {
                    Atom = (ATOM)pmsg->lParam;
                    RtlInitLargeUnicodeString(&str, awchString, (UINT)-1);
                    pmsg->lParam = (LPARAM)&str;
                } else {
                    UserAssert(FALSE);
                    pmsg->lParam = 0;
                }
            }
            break;
        }
        xxxSendMessage(pwnd, pmsg->message, pmsg->wParam, pmsg->lParam);
        ThreadUnlock(&tlpwndT);
    }
    if (Atom) {
        UserDeleteAtom(Atom);
    }
    UserFreePool(pmsg);
}


/***************************************************************************\
* xxxBroadcastMessage
*
*
*
* History:
* 02-21-91 DavidPe      Created.
\***************************************************************************/

LONG xxxBroadcastMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    UINT wCmd,
    PBROADCASTMSG pbcm)
{
    PBWL pbwl;
    HWND *phwnd;
    TL tlpwnd;
    PASYNCSENDMSG pmsg;
    PPROCESSINFO ppiCurrent;
    LONG lRet = TRUE;
    TL tlPool;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL fPrivateMessage = (message >= WM_USER) && (message < MAXINTATOM);

    if (fPrivateMessage) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Attempt to broadcast a private message");
    }

    if (pwnd == NULL) {
        LARGE_UNICODE_STRING str;
        PLARGE_STRING pstr;

        /*
         * Handle special system-wide broadcasts.
         */
        switch (message) {
        case WM_SPOOLERSTATUS:
            xxxSystemBroadcastMessage(message, wParam, lParam, wCmd, pbcm);
            return 1;

        case WM_WININICHANGE:
        case WM_DEVMODECHANGE:

            /*
             * Probe and capture the string.
             */
            if (lParam) {
                UINT cbAlloc;
                NTSTATUS Status;

                /*
                 * Allocate a temp buffer and convert
                 * the string to Unicode
                 */
                pstr = ((PLARGE_STRING)lParam);
                if (pstr->bAnsi)
                    cbAlloc = (pstr->Length + 1) * sizeof(WCHAR);
                else
                    cbAlloc = pstr->Length + sizeof(WCHAR);
                str.Buffer = UserAllocPoolWithQuota(cbAlloc, TAG_SMS_STRING);
                if (str.Buffer == NULL) {
                    return 0;
                }
                str.MaximumLength = cbAlloc;
                str.bAnsi = FALSE;
                try {
                    if (pstr->bAnsi) {
                        Status = RtlMultiByteToUnicodeN(
                                        (PWCH)str.Buffer,
                                        cbAlloc,
                                        &cbAlloc,
                                        (PCH)pstr->Buffer,
                                        pstr->Length
                                        );
                        str.Length = cbAlloc;
                    } else {
                        str.Length = pstr->Length;
                        RtlCopyMemory(str.Buffer, pstr->Buffer, str.Length);
                        Status = STATUS_SUCCESS;
                    }
                    str.Buffer[str.Length / sizeof(WCHAR)] = 0;
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                    Status = GetExceptionCode();
                }
                if (!NT_SUCCESS(Status)) {
                    UserFreePool(str.Buffer);
                    return 0;
                }
                pstr->Buffer = str.Buffer;
            }
            if (lParam) {
                ThreadLockPool(ptiCurrent, str.Buffer, &tlPool);
            }
            xxxSystemBroadcastMessage(message, wParam,
                    lParam ? (LPARAM)&str : 0, wCmd, pbcm);
            if (lParam)
                ThreadUnlockAndFreePool(ptiCurrent, &tlPool);
            return 1;

        case WM_TIMECHANGE:
            /*
             * We automatically broadcast a WM_TIMECHANGE message whenever the
             * kernel tells us the time has changed, so blow off any apps who
             * are trying to do the same thing.
             */
            if (!(ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD)) {
                RIPMSG0(RIP_WARNING, "Only system should broadcast WM_TIMECHANGE");
                return 0;
            }
            break;
        }

        UserAssert(ptiCurrent->rpdesk);

        pwnd = ptiCurrent->rpdesk->pDeskInfo->spwnd;

        if (pwnd == NULL) {
            RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "sender must have an associated desktop");
            return 0;
        }
    }

    pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL);
    if (pbwl == NULL)
        return 0;

    ppiCurrent = PpiCurrent();

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Make sure this hwnd is still around.
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        /*
         * Make sure this window can handle broadcast messages
         */
        if (!fBroadcastProc(pwnd))
            continue;

        if (fPrivateMessage && TestWF(pwnd, WFWIN40COMPAT)) { // Don't broadcast
            continue;                                         // private message
        }                                                     // to 4.0 apps.

        /*
         * Don't bother sending palette messages to windows that are not
         * visible on threads that are not palette aware.
         */
        if ((message == WM_PALETTEISCHANGING || message == WM_PALETTECHANGED) &&
                !TestWF(pwnd, WFVISIBLE) &&
                !(GETPTI(pwnd)->TIF_flags & TIF_PALETTEAWARE)) {
            continue;
        }

        ThreadLockAlways(pwnd, &tlpwnd);

        switch (wCmd) {
        case BMSG_SENDMSG:
            xxxSendMessage(pwnd, message, wParam, lParam);
            break;

        case BMSG_SENDNOTIFYMSG:
            {
                ATOM Atom = 0;

                switch (message) {
                case WM_WININICHANGE:
                case WM_DEVMODECHANGE:
                    if (lParam) {
                        PLARGE_STRING pstr = (PLARGE_STRING)lParam;

                        /*
                         * Convert strings to atoms for the post.
                         */
                        if (pstr)
                            Atom = UserAddAtom(pstr->Buffer, FALSE);
                        if (!Atom) {
                            lRet = FALSE;
                            break;
                        }
                    }

                    /*
                     * These messages need to be able to cross
                     * desktops so PostEvent 'em.
                     */
                    pmsg = UserAllocPool(sizeof(ASYNCSENDMSG),
                        TAG_SMS_ASYNC);
                    if (pmsg == NULL) {
                        goto CleanupAtom;
                    }

                    pmsg->hwnd = *phwnd;
                    pmsg->message = message;
                    pmsg->wParam = wParam;
                    pmsg->lParam = Atom;

                    if (!PostEventMessage(GETPTI(pwnd), GETPTI(pwnd)->pq,
                                         QEVENT_ASYNCSENDMSG,NULL, 0,
                                         (WPARAM)pmsg, 0)) {

                        UserFreePool(pmsg);
CleanupAtom:
                        if (Atom) {
                            UserDeleteAtom(Atom);
                        }
                        lRet = FALSE;
                    }
                    break;

                default:
                    /*
                     * A regular kind of guy.  No desktop crossing.
                     */
                    xxxSendNotifyMessage(pwnd, message, wParam, lParam);
                    break;
                }
            }
            break;

        case BMSG_SENDNOTIFYMSGPROCESS:
            UserAssert(message != WM_WININICHANGE && message != WM_DEVMODECHANGE);

            /*
             * Intra-process messages are synchronous; 22238.
             * WM_PALETTECHANGED was being sent after the WM_DESTROY
             * but console thread must not be synchronous.
             */
            if ((GETPTI(pwnd)->ppi == ppiCurrent) && !(GETPTI(pwnd)->TIF_flags & TIF_CSRSSTHREAD)) {
                xxxSendMessage(pwnd, message, wParam, lParam);
            } else {
                xxxSendNotifyMessage(pwnd, message, wParam, lParam);
            }
            break;

        case BMSG_POSTMSG:
            /*
             * Don't broadcast-post to owned windows (Win3.1 compatiblilty)
             */
            if (pwnd->spwndOwner == NULL)
                _PostMessage(pwnd, message, wParam, lParam);
            break;

        case BMSG_SENDMSGCALLBACK:
            xxxSendMessageCallback(pwnd, message, wParam, lParam,
                    pbcm->cb.lpResultCallBack, pbcm->cb.dwData, pbcm->cb.bClientRequest);
            break;

        case BMSG_SENDMSGTIMEOUT:
            xxxSendMessageTimeout(pwnd, message, wParam, lParam,
                    pbcm->to.fuFlags, pbcm->to.uTimeout, pbcm->to.lpdwResult);
            break;
        }

        ThreadUnlock(&tlpwnd);
    }

    FreeHwndList(pbwl);

    /*
     * Excel-Solver 3.0 expects a non-zero return value from a
     * SendMessage(-1,WM_DDE_INITIATE,....); Because, we had
     * FFFE_FARFRAME in 3.0, the DX register at this point always had
     * a value of 0x102; But, because we removed it under Win3.1, we get
     * a zero value in ax and dx; This makes solver think that the DDE has
     * failed.  So, to support the existing SOLVER, we make dx nonzero.
     * Fix for Bug #6005 -- SANKAR -- 05-16-91 --
     */
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\server.c ===
/**************************************************************************\
* Module Name: server.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Server support routines for the CSR stuff. This basically performs the
* startup/initialization for USER.
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "prefetch.h"

extern WORD gDispatchTableValues;

BOOL gbUserInitialized;

/*
 * Initialization Routines (external).
 */
NTSTATUS     InitQEntryLookaside(VOID);
NTSTATUS     InitSMSLookaside(VOID);

NTSTATUS    InitCreateSharedSection(VOID);
NTSTATUS    InitCreateObjectDirectory(VOID);
BOOL        InitCreateUserSubsystem(VOID);
VOID        InitFunctionTables(VOID);
VOID        InitMessageTables(VOID);
VOID        InitWindowMsgTable(PBYTE*, PUINT, CONST WORD*);

VOID        VerifySyncOnlyMessages(VOID);
BOOL        InitOLEFormats(VOID);
NTSTATUS    Win32UserInitialize(VOID);

#pragma alloc_text(INIT, InitCreateSharedSection)
#pragma alloc_text(INIT, InitCreateUserCrit)
#pragma alloc_text(INIT, InitCreateObjectDirectory)
#pragma alloc_text(INIT, InitCreateUserSubsystem)
//#pragma alloc_text(INIT, InitDbgTags)
#pragma alloc_text(INIT, InitFunctionTables)
#pragma alloc_text(INIT, InitMessageTables)
#pragma alloc_text(INIT, InitWindowMsgTable)

#pragma alloc_text(INIT, VerifySyncOnlyMessages)
#pragma alloc_text(INIT, InitOLEFormats)
#pragma alloc_text(INIT, Win32UserInitialize)

/*
 * Constants pertaining to the user-initialization.
 */
#define USRINIT_SHAREDSECT_SIZE   32
#define USRINIT_ATOMBUCKET_SIZE   37

#define USRINIT_WINDOWSECT_SIZE  512
#define USRINIT_NOIOSECT_SIZE    128

#define USRINIT_SHAREDSECT_BUFF_SIZE     640
#define USRINIT_SHAREDSECT_READ_SIZE     (USRINIT_SHAREDSECT_BUFF_SIZE-33)


/***************************************************************************\
* Globals stored in the INIT section. These should only be accessed at
* load time!
\***************************************************************************/
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT$Data")
#endif

CONST WCHAR szCHECKPOINT_PROP_NAME[]  = L"SysCP";
CONST WCHAR szDDETRACK_PROP_NAME[]    = L"SysDT";
CONST WCHAR szQOS_PROP_NAME[]         = L"SysQOS";
CONST WCHAR szDDEIMP_PROP_NAME[]      = L"SysDDEI";
CONST WCHAR szWNDOBJ_PROP_NAME[]      = L"SysWNDO";
CONST WCHAR szIMELEVEL_PROP_NAME[]    = L"SysIMEL";
CONST WCHAR szLAYER_PROP_NAME[]       = L"SysLayer";
CONST WCHAR szUSER32[]                = L"USER32";
CONST WCHAR szCONTEXTHELPIDPROP[]     = L"SysCH";
CONST WCHAR szICONSM_PROP_NAME[]      = L"SysICS";
CONST WCHAR szICON_PROP_NAME[]        = ICON_PROP_NAME;
CONST WCHAR szSHELLHOOK[]             = L"SHELLHOOK";
CONST WCHAR szACTIVATESHELLWINDOW[]   = L"ACTIVATESHELLWINDOW";
CONST WCHAR szOTHERWINDOWCREATED[]    = L"OTHERWINDOWCREATED";
CONST WCHAR szOTHERWINDOWDESTROYED[]  = L"OTHERWINDOWDESTROYED";
CONST WCHAR szOLEMAINTHREADWNDCLASS[] = L"OleMainThreadWndClass";
CONST WCHAR szFLASHWSTATE[]           = L"FlashWState";

#ifdef HUNGAPP_GHOSTING
CONST WCHAR szGHOST[]                 = L"Ghost";
#endif // HUNGAPP_GHOSTING

CONST WCHAR szSHADOW[]                = L"SysShadow";

/***************************************************************************\
* Message Tables
*
*   DefDlgProc
*   MenuWndProc
*   ScrollBarWndProc
*   StaticWndProc
*   ButtonWndProc
*   ListboxWndProc
*   ComboWndProc
*   EditWndProc
*   DefWindowMsgs
*   DefWindowSpecMsgs
*
* These are used in InitMessageTables() to initialize gSharedInfo.awmControl[]
* using the INITMSGTABLE() macro.
*
* 25-Aug-1995 ChrisWil  Created comment block.
\***************************************************************************/

CONST WORD gawDefDlgProc[] = {
    WM_COMPAREITEM,
    WM_VKEYTOITEM,
    WM_CHARTOITEM,
    WM_INITDIALOG,
    WM_QUERYDRAGICON,
    WM_CTLCOLOR,
    WM_CTLCOLORMSGBOX,
    WM_CTLCOLOREDIT,
    WM_CTLCOLORLISTBOX,
    WM_CTLCOLORBTN,
    WM_CTLCOLORDLG,
    WM_CTLCOLORSCROLLBAR,
    WM_CTLCOLORSTATIC,
    WM_ERASEBKGND,
    WM_SHOWWINDOW,
    WM_SYSCOMMAND,
    WM_SYSKEYDOWN,
    WM_ACTIVATE,
    WM_SETFOCUS,
    WM_CLOSE,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    DM_REPOSITION,
    DM_SETDEFID,
    DM_GETDEFID,
    WM_NEXTDLGCTL,
    WM_ENTERMENULOOP,
    WM_LBUTTONDOWN,
    WM_NCLBUTTONDOWN,
    WM_GETFONT,
    WM_NOTIFYFORMAT,
    WM_INPUTLANGCHANGEREQUEST,
    0
};

CONST WORD gawMenuWndProc[] = {
    WM_NCCREATE,
    WM_FINALDESTROY,
    WM_PAINT,
    WM_NCCALCSIZE,
    WM_CHAR,
    WM_SYSCHAR,
    WM_KEYDOWN,
    WM_SYSKEYDOWN,
    WM_TIMER,
    MN_SETHMENU,
    MN_SIZEWINDOW,
    MN_OPENHIERARCHY,
    MN_CLOSEHIERARCHY,
    MN_SELECTITEM,
    MN_SELECTFIRSTVALIDITEM,
    MN_CANCELMENUS,
    MN_FINDMENUWINDOWFROMPOINT,
    MN_SHOWPOPUPWINDOW,
    MN_BUTTONDOWN,
    MN_MOUSEMOVE,
    MN_BUTTONUP,
    MN_SETTIMERTOOPENHIERARCHY,
    WM_ACTIVATE,
    MN_GETHMENU,
    MN_DBLCLK,
    MN_ACTIVATEPOPUP,
    MN_ENDMENU,
    MN_DODRAGDROP,
    WM_ACTIVATEAPP,
    WM_MOUSELEAVE,
    WM_SIZE,
    WM_MOVE,
    WM_NCHITTEST,
    WM_NCPAINT,
    WM_PRINT,
    WM_PRINTCLIENT,
    WM_ERASEBKGND,
    WM_WINDOWPOSCHANGING,
    WM_WINDOWPOSCHANGED,
    0
};

CONST WORD gawDesktopWndProc[] = {
    WM_PAINT,
    WM_ERASEBKGND,
    0
};

CONST WORD gawScrollBarWndProc[] = {
    WM_CREATE,
    WM_SETFOCUS,
    WM_KILLFOCUS,
    WM_ERASEBKGND,
    WM_PAINT,
    WM_LBUTTONDBLCLK,
    WM_LBUTTONDOWN,
    WM_KEYUP,
    WM_KEYDOWN,
    WM_ENABLE,
    SBM_ENABLE_ARROWS,
    SBM_SETPOS,
    SBM_SETRANGEREDRAW,
    SBM_SETRANGE,
    SBM_SETSCROLLINFO,
    SBM_GETSCROLLINFO,
    SBM_GETSCROLLBARINFO,
    WM_PRINTCLIENT,
    WM_MOUSEMOVE,
    WM_MOUSELEAVE,
    0
};

CONST WORD gawStaticWndProc[] = {
    STM_GETICON,
    STM_GETIMAGE,
    STM_SETICON,
    STM_SETIMAGE,
    WM_ERASEBKGND,
    WM_PAINT,
    WM_PRINTCLIENT,
    WM_CREATE,
    WM_DESTROY,
    WM_NCCREATE,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_NCHITTEST,
    WM_LBUTTONDOWN,
    WM_NCLBUTTONDOWN,
    WM_LBUTTONDBLCLK,
    WM_NCLBUTTONDBLCLK,
    WM_SETTEXT,
    WM_ENABLE,
    WM_GETDLGCODE,
    WM_SETFONT,
    WM_GETFONT,
    WM_GETTEXT,
    WM_TIMER,
    WM_INPUTLANGCHANGEREQUEST,
    WM_UPDATEUISTATE,
    0
};

CONST WORD gawButtonWndProc[] = {
    WM_NCHITTEST,
    WM_ERASEBKGND,
    WM_PRINTCLIENT,
    WM_PAINT,
    WM_SETFOCUS,
    WM_GETDLGCODE,
    WM_CAPTURECHANGED,
    WM_KILLFOCUS,
    WM_LBUTTONDBLCLK,
    WM_LBUTTONUP,
    WM_MOUSEMOVE,
    WM_LBUTTONDOWN,
    WM_CHAR,
    BM_CLICK,
    WM_KEYDOWN,
    WM_KEYUP,
    WM_SYSKEYUP,
    BM_GETSTATE,
    BM_SETSTATE,
    BM_GETCHECK,
    BM_SETCHECK,
    BM_SETSTYLE,
    WM_SETTEXT,
    WM_ENABLE,
    WM_SETFONT,
    WM_GETFONT,
    BM_GETIMAGE,
    BM_SETIMAGE,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_NCCREATE,
    WM_INPUTLANGCHANGEREQUEST,
    WM_UPDATEUISTATE,
    0
};

CONST WORD gawListboxWndProc[] = {
    LB_GETTOPINDEX,
    LB_SETTOPINDEX,
    WM_SIZE,
    WM_ERASEBKGND,
    LB_RESETCONTENT,
    WM_TIMER,
    WM_MOUSEMOVE,
    WM_MBUTTONDOWN,
    WM_LBUTTONDOWN,
    WM_LBUTTONUP,
    WM_LBUTTONDBLCLK,
    WM_CAPTURECHANGED,
    LBCB_STARTTRACK,
    LBCB_ENDTRACK,
    WM_PRINTCLIENT,
    WM_PAINT,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_SETFOCUS,
    WM_KILLFOCUS,
    WM_VSCROLL,
    WM_HSCROLL,
    WM_GETDLGCODE,
    WM_CREATE,
    WM_SETREDRAW,
    WM_ENABLE,
    WM_SETFONT,
    WM_GETFONT,
    WM_DRAGSELECT,
    WM_DRAGLOOP,
    WM_DRAGMOVE,
    WM_DROPFILES,
    WM_QUERYDROPOBJECT,
    WM_DROPOBJECT,
    LB_GETITEMRECT,
    LB_GETITEMDATA,
    LB_SETITEMDATA,
    LB_ADDSTRINGUPPER,
    LB_ADDSTRINGLOWER,
    LB_ADDSTRING,
    LB_INSERTSTRINGUPPER,
    LB_INSERTSTRINGLOWER,
    LB_INSERTSTRING,
    LB_INITSTORAGE,
    LB_DELETESTRING,
    LB_DIR,
    LB_ADDFILE,
    LB_SETSEL,
    LB_SETCURSEL,
    LB_GETSEL,
    LB_GETCURSEL,
    LB_SELITEMRANGE,
    LB_SELITEMRANGEEX,
    LB_GETTEXTLEN,
    LB_GETTEXT,
    LB_GETCOUNT,
    LB_SETCOUNT,
    LB_SELECTSTRING,
    LB_FINDSTRING,
    LB_GETLOCALE,
    LB_SETLOCALE,
    WM_KEYDOWN,
    WM_CHAR,
    LB_GETSELITEMS,
    LB_GETSELCOUNT,
    LB_SETTABSTOPS,
    LB_GETHORIZONTALEXTENT,
    LB_SETHORIZONTALEXTENT,
    LB_SETCOLUMNWIDTH,
    LB_SETANCHORINDEX,
    LB_GETANCHORINDEX,
    LB_SETCARETINDEX,
    LB_GETCARETINDEX,
    LB_SETITEMHEIGHT,
    LB_GETITEMHEIGHT,
    LB_FINDSTRINGEXACT,
    LB_ITEMFROMPOINT,
    LB_SETLOCALE,
    LB_GETLOCALE,
    LBCB_CARETON,
    LBCB_CARETOFF,
    LB_GETLISTBOXINFO,
    WM_NCCREATE,
    WM_WINDOWPOSCHANGED,
    WM_MOUSEWHEEL,
    WM_STYLECHANGED,
    WM_STYLECHANGING,
    0
};

CONST WORD gawComboWndProc[] = {
    CBEC_KILLCOMBOFOCUS,
    WM_COMMAND,
    WM_CTLCOLORMSGBOX,
    WM_CTLCOLOREDIT,
    WM_CTLCOLORLISTBOX,
    WM_CTLCOLORBTN,
    WM_CTLCOLORDLG,
    WM_CTLCOLORSCROLLBAR,
    WM_CTLCOLORSTATIC,
    WM_CTLCOLOR,
    WM_GETTEXT,
    WM_GETTEXTLENGTH,
    WM_CLEAR,
    WM_CUT,
    WM_PASTE,
    WM_COPY,
    WM_SETTEXT,
    WM_CREATE,
    WM_ERASEBKGND,
    WM_GETFONT,
    WM_PRINT,
    WM_PRINTCLIENT,
    WM_PAINT,
    WM_GETDLGCODE,
    WM_SETFONT,
    WM_SYSKEYDOWN,
    WM_KEYDOWN,
    WM_CHAR,
    WM_LBUTTONDBLCLK,
    WM_LBUTTONDOWN,
    WM_CAPTURECHANGED,
    WM_LBUTTONUP,
    WM_MOUSEMOVE,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_SETFOCUS,
    WM_KILLFOCUS,
    WM_SETREDRAW,
    WM_ENABLE,
    WM_SIZE,
    CB_GETDROPPEDSTATE,
    CB_GETDROPPEDCONTROLRECT,
    CB_SETDROPPEDWIDTH,
    CB_GETDROPPEDWIDTH,
    CB_DIR,
    CB_SETEXTENDEDUI,
    CB_GETEXTENDEDUI,
    CB_GETEDITSEL,
    CB_LIMITTEXT,
    CB_SETEDITSEL,
    CB_ADDSTRING,
    CB_DELETESTRING,
    CB_INITSTORAGE,
    CB_SETTOPINDEX,
    CB_GETTOPINDEX,
    CB_GETCOUNT,
    CB_GETCURSEL,
    CB_GETLBTEXT,
    CB_GETLBTEXTLEN,
    CB_INSERTSTRING,
    CB_RESETCONTENT,
    CB_GETHORIZONTALEXTENT,
    CB_SETHORIZONTALEXTENT,
    CB_FINDSTRING,
    CB_FINDSTRINGEXACT,
    CB_SELECTSTRING,
    CB_SETCURSEL,
    CB_GETITEMDATA,
    CB_SETITEMDATA,
    CB_SETITEMHEIGHT,
    CB_GETITEMHEIGHT,
    CB_SHOWDROPDOWN,
    CB_SETLOCALE,
    CB_GETLOCALE,
    CB_GETCOMBOBOXINFO,
    WM_MEASUREITEM,
    WM_DELETEITEM,
    WM_DRAWITEM,
    WM_COMPAREITEM,
    WM_NCCREATE,
    WM_HELP,
    WM_MOUSEWHEEL,
    WM_MOUSELEAVE,
    WM_STYLECHANGED,
    WM_STYLECHANGING,
    WM_UPDATEUISTATE,
    0
};

CONST WORD gawEditWndProc[] = {
    EM_CANUNDO,
    EM_CHARFROMPOS,
    EM_EMPTYUNDOBUFFER,
    EM_FMTLINES,
    EM_GETFIRSTVISIBLELINE,
    EM_GETFIRSTVISIBLELINE,
    EM_GETHANDLE,
    EM_GETLIMITTEXT,
    EM_GETLINE,
    EM_GETLINECOUNT,
    EM_GETMARGINS,
    EM_GETMODIFY,
    EM_GETPASSWORDCHAR,
    EM_GETRECT,
    EM_GETSEL,
    EM_GETWORDBREAKPROC,
    EM_SETIMESTATUS,
    EM_GETIMESTATUS,
    EM_LINEFROMCHAR,
    EM_LINEINDEX,
    EM_LINELENGTH,
    EM_LINESCROLL,
    EM_POSFROMCHAR,
    EM_REPLACESEL,
    EM_SCROLL,
    EM_SCROLLCARET,
    EM_SETHANDLE,
    EM_SETLIMITTEXT,
    EM_SETMARGINS,
    EM_SETMODIFY,
    EM_SETPASSWORDCHAR,
    EM_SETREADONLY,
    EM_SETRECT,
    EM_SETRECTNP,
    EM_SETSEL,
    EM_SETTABSTOPS,
    EM_SETWORDBREAKPROC,
    EM_UNDO,
    WM_CAPTURECHANGED,
    WM_CHAR,
    WM_CLEAR,
    WM_CONTEXTMENU,
    WM_COPY,
    WM_CREATE,
    WM_CUT,
    WM_ENABLE,
    WM_ERASEBKGND,
    WM_GETDLGCODE,
    WM_GETFONT,
    WM_GETTEXT,
    WM_GETTEXTLENGTH,
    WM_HSCROLL,
    WM_IME_STARTCOMPOSITION,
    WM_IME_ENDCOMPOSITION,
    WM_IME_COMPOSITION,
    WM_IME_SETCONTEXT,
    WM_IME_NOTIFY,
    WM_IME_COMPOSITIONFULL,
    WM_IME_SELECT,
    WM_IME_CHAR,
    WM_IME_REQUEST,
    WM_INPUTLANGCHANGE,
    WM_KEYUP,
    WM_KEYDOWN,
    WM_KILLFOCUS,
    WM_MBUTTONDOWN,
    WM_LBUTTONDBLCLK,
    WM_LBUTTONDOWN,
    WM_LBUTTONUP,
    WM_MOUSEMOVE,
    WM_NCCREATE,
    WM_NCDESTROY,
    WM_RBUTTONDOWN,
    WM_RBUTTONUP,
    WM_FINALDESTROY,
#if 0
    WM_NCPAINT,
#endif
    WM_PAINT,
    WM_PASTE,
    WM_PRINTCLIENT,
    WM_SETFOCUS,
    WM_SETFONT,
    WM_SETREDRAW,
    WM_SETTEXT,
    WM_SIZE,
    WM_STYLECHANGED,
    WM_STYLECHANGING,
    WM_SYSCHAR,
    WM_SYSKEYDOWN,
    WM_SYSTIMER,
    WM_UNDO,
    WM_VSCROLL,
    WM_MOUSEWHEEL,
    0
};

CONST WORD gawImeWndProc[] = {
    WM_ERASEBKGND,
    WM_PAINT,
    WM_DESTROY,
    WM_NCDESTROY,
    WM_FINALDESTROY,
    WM_CREATE,
    WM_IME_SYSTEM,
    WM_IME_SELECT,
    WM_IME_CONTROL,
    WM_IME_SETCONTEXT,
    WM_IME_NOTIFY,
    WM_IME_COMPOSITION,
    WM_IME_STARTCOMPOSITION,
    WM_IME_ENDCOMPOSITION,
    WM_IME_REQUEST,
    WM_COPYDATA,
    0
};

/*
 * This array is for all the messages that need to be passed straight
 * across to the server for handling.
 */
CONST WORD gawDefWindowMsgs[] = {
    WM_GETHOTKEY,
    WM_SETHOTKEY,
    WM_SETREDRAW,
    WM_SETTEXT,
    WM_PAINT,
    WM_CLOSE,
    WM_ERASEBKGND,
    WM_CANCELMODE,
    WM_SETCURSOR,
    WM_PAINTICON,
    WM_ICONERASEBKGND,
    WM_DRAWITEM,
    WM_KEYF1,
    WM_ISACTIVEICON,
    WM_NCCREATE,
    WM_SETICON,
    WM_NCCALCSIZE,
    WM_NCPAINT,
    WM_NCACTIVATE,
    WM_NCMOUSEMOVE,
    WM_NCRBUTTONUP,
    WM_NCRBUTTONDOWN,
#ifndef LAME_BUTTON
    WM_NCLBUTTONDOWN,
#endif // !LAME_BUTTON
    WM_NCLBUTTONUP,
    WM_NCLBUTTONDBLCLK,
    WM_KEYUP,
    WM_SYSKEYUP,
#ifndef LAME_BUTTON
    WM_SYSCHAR,
    WM_SYSCOMMAND,
#endif // !LAME_BUTTON
    WM_QUERYDROPOBJECT,
    WM_CLIENTSHUTDOWN,
    WM_SYNCPAINT,
    WM_PRINT,
    WM_GETICON,
    WM_CONTEXTMENU,
    WM_SYSMENU,
    WM_INPUTLANGCHANGEREQUEST,
    WM_INPUTLANGCHANGE,
    WM_UPDATEUISTATE,
    WM_NCUAHDRAWCAPTION,
    WM_NCUAHDRAWFRAME,
    WM_UAHINIT,
    0
};

/*
 * This array is for all messages that can be handled with some special
 * code by the client. DefWindowProcWorker returns 0 for all messages
 * that aren't in this array or the one above.
 */
CONST WORD gawDefWindowSpecMsgs[] = {
    WM_ACTIVATE,
    WM_GETTEXT,
    WM_GETTEXTLENGTH,
    WM_RBUTTONUP,
    WM_QUERYENDSESSION,
    WM_QUERYOPEN,
    WM_SHOWWINDOW,
    WM_MOUSEACTIVATE,
    WM_HELP,
    WM_VKEYTOITEM,
    WM_CHARTOITEM,
    WM_KEYDOWN,
#ifdef LAME_BUTTON
    WM_SYSCOMMAND,
    WM_SYSCHAR,
#endif // LAME_BUTTON
    WM_SYSKEYDOWN,
    WM_UNICHAR,
    WM_DROPOBJECT,
    WM_WINDOWPOSCHANGING,
    WM_WINDOWPOSCHANGED,
    WM_KLUDGEMINRECT,
    WM_CTLCOLOR,
    WM_CTLCOLORMSGBOX,
    WM_CTLCOLOREDIT,
    WM_CTLCOLORLISTBOX,
    WM_CTLCOLORBTN,
    WM_CTLCOLORDLG,
    WM_CTLCOLORSCROLLBAR,
    WM_NCHITTEST,
#ifdef LAME_BUTTON
    WM_NCLBUTTONDOWN,
#endif // LAME_BUTTON
    WM_NCXBUTTONUP,
    WM_CTLCOLORSTATIC,
    WM_NOTIFYFORMAT,
    WM_DEVICECHANGE,
    WM_POWERBROADCAST,
    WM_MOUSEWHEEL,
    WM_XBUTTONUP,
    WM_IME_KEYDOWN,
    WM_IME_KEYUP,
    WM_IME_CHAR,
    WM_IME_COMPOSITION,
    WM_IME_STARTCOMPOSITION,
    WM_IME_ENDCOMPOSITION,
    WM_IME_COMPOSITIONFULL,
    WM_IME_SETCONTEXT,
    WM_IME_CONTROL,
    WM_IME_NOTIFY,
    WM_IME_SELECT,
    WM_IME_SYSTEM,
    WM_LPKDRAWSWITCHWND,
    WM_QUERYDRAGICON,
    WM_CHANGEUISTATE,
    WM_QUERYUISTATE,
    WM_APPCOMMAND,
    0
};

static CONST LPCWSTR lpszOLEFormats[] = {
    L"ObjectLink",
    L"OwnerLink",
    L"Native",
    L"Binary",
    L"FileName",
    L"FileNameW",
    L"NetworkName",
    L"DataObject",
    L"Embedded Object",
    L"Embed Source",
    L"Custom Link Source",
    L"Link Source",
    L"Object Descriptor",
    L"Link Source Descriptor",
    L"OleDraw",
    L"PBrush",
    L"MSDraw",
    L"Ole Private Data",
    L"Screen Picture",
    L"OleClipboardPersistOnFlush",
    L"MoreOlePrivateData"
};

static CONST LPCWSTR lpszControls[] = {
    L"Button",
    L"Edit",
    L"Static",
    L"ListBox",
    L"ScrollBar",
    L"ComboBox",
    L"MDIClient",
    L"ComboLBox",
    L"DDEMLEvent",
    L"DDEMLMom",
    L"DMGClass",
    L"DDEMLAnsiClient",
    L"DDEMLUnicodeClient",
    L"DDEMLAnsiServer",
    L"DDEMLUnicodeServer",
    L"IME",
};


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

/***************************************************************************\
* DispatchServerMessage
*
*
* 19-Aug-1992 MikeKe    Created
\***************************************************************************/

#define WRAPPFN(pfn, type)                                   \
LRESULT xxxWrap ## pfn(                                      \
    PWND  pwnd,                                              \
    UINT  message,                                           \
    WPARAM wParam,                                           \
    LPARAM lParam,                                           \
    ULONG_PTR xParam)                                         \
{                                                            \
    DBG_UNREFERENCED_PARAMETER(xParam);                      \
                                                             \
    return xxx ## pfn((type)pwnd, message, wParam, lParam);  \
}

WRAPPFN(SBWndProc, PSBWND)
WRAPPFN(MenuWindowProc, PWND)
WRAPPFN(DesktopWndProc, PWND);
WRAPPFN(RealDefWindowProc, PWND)
WRAPPFN(SwitchWndProc, PWND)

LRESULT xxxWrapSendMessageCallback(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    SNDMSGCALLBACK smcb;
    TL tlpwnd;
    LRESULT lRet = 0;
    NTSTATUS Status = STATUS_SUCCESS;


    UserAssert (xParam != 0L);

    /*
     * Prevent apps from setting hi 16 bits so we can use them internally.
     */
    if (message & MSGFLAG_MASK) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid message");
        return 0;
    }

    /*
     * Probe all read arguments
     */
    try {
        ProbeForWrite((PVOID)xParam, sizeof(smcb), sizeof(ULONG));
        smcb = *(PSNDMSGCALLBACK)xParam;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        Status = GetExceptionCode();
    }
    if ( !NT_SUCCESS(Status) ) {
        return 0;
    }

    if (pwnd != PWND_BROADCAST)
        ThreadLockAlways(pwnd, &tlpwnd);

    lRet = (LRESULT)xxxSendMessageCallback(pwnd,
                                           message,
                                           wParam,
                                           lParam,
                                           smcb.lpResultCallBack,
                                           smcb.dwData,
                                           TRUE);
    if (pwnd != PWND_BROADCAST)
        ThreadUnlock(&tlpwnd);

    return lRet;
}

LRESULT xxxWrapSendNotifyMessage(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    TL tlpwnd;
    LRESULT lRet = 0;

    DBG_UNREFERENCED_PARAMETER(xParam);

    if (message & MSGFLAG_MASK) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Invalid message");
        return 0;
    }

    if (pwnd != PWND_BROADCAST)
        ThreadLockAlways(pwnd, &tlpwnd);

    lRet = (LRESULT)xxxSendNotifyMessage(pwnd,
                                         message,
                                         wParam,
                                         lParam);
    if (pwnd != PWND_BROADCAST)
        ThreadUnlock(&tlpwnd);

    return lRet;
}

LRESULT xxxWrapSendMessage(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    DBG_UNREFERENCED_PARAMETER(xParam);

    return xxxSendMessageTimeout(pwnd,
                                 message,
                                 wParam,
                                 lParam,
                                 SMTO_NORMAL,
                                 0,
                                 NULL);
}

LRESULT xxxWrapSendMessageBSM(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    BROADCASTSYSTEMMSGPARAMS bsmParams;
    LRESULT lRet;

    try {
        ProbeForWriteBroadcastSystemMsgParams((LPBROADCASTSYSTEMMSGPARAMS)xParam);
        RtlCopyMemory(&bsmParams, (LPBROADCASTSYSTEMMSGPARAMS)xParam, sizeof(BROADCASTSYSTEMMSGPARAMS));
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return 0;
    }

    /*
     * If this broadcast is going to all desktops, make sure the thread has
     * sufficient privileges. Do the check here, so we don't effect kernel
     * generated broadcasts (i.e power messages).
     */
    if (bsmParams.dwRecipients & (BSM_ALLDESKTOPS)) {
        if (!IsPrivileged(&psTcb)) {
            bsmParams.dwRecipients &= ~(BSM_ALLDESKTOPS);
        }
    }

    lRet = xxxSendMessageBSM(pwnd,
                             message,
                             wParam,
                             lParam,
                             &bsmParams);
    /*
     * If our query was denied, return who denied the query.
     */
    if ((lRet == 0) && (bsmParams.dwFlags & BSF_QUERY)) {
        try {
            RtlCopyMemory((LPBROADCASTSYSTEMMSGPARAMS)xParam, &bsmParams, sizeof(BROADCASTSYSTEMMSGPARAMS));
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            return 0;
        }
    }
    return lRet;
}

/***************************************************************************\
* xxxUnusedFunctionId
*
* This function is catches attempts to access invalid entries in the server
* side function dispatch table.
*
\***************************************************************************/

LRESULT xxxUnusedFunctionId(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    DBG_UNREFERENCED_PARAMETER(pwnd);
    DBG_UNREFERENCED_PARAMETER(message);
    DBG_UNREFERENCED_PARAMETER(wParam);
    DBG_UNREFERENCED_PARAMETER(lParam);
    DBG_UNREFERENCED_PARAMETER(xParam);

    UserAssert(FALSE);
    return 0;
}

/***************************************************************************\
* xxxWrapCallWindowProc
*
* Warning should only be called with valid CallProc Handles or the
* EditWndProc special handlers.
*
*
* 21-Apr-1993 JohnC     Created
\***************************************************************************/

LRESULT xxxWrapCallWindowProc(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    PCALLPROCDATA pCPD;
    LRESULT       lRet = 0;

    if (pCPD = HMValidateHandleNoRip((PVOID)xParam, TYPE_CALLPROC)) {

        lRet = ScSendMessage(pwnd,
                              message,
                              wParam,
                              lParam,
                              pCPD->pfnClientPrevious,
                              gpsi->apfnClientW.pfnDispatchMessage,
                              (pCPD->wType & CPD_UNICODE_TO_ANSI) ?
                                      SCMS_FLAGS_ANSI : 0);

    } else {

        /*
         * If it is not a real call proc handle it must be a special
         * handler for editwndproc or regular EditWndProc
         */
        lRet = ScSendMessage(pwnd,
                              message,
                              wParam,
                              lParam,
                              xParam,
                              gpsi->apfnClientA.pfnDispatchMessage,
                              (xParam == (ULONG_PTR)gpsi->apfnClientA.pfnEditWndProc) ?
                                      SCMS_FLAGS_ANSI : 0);
    }

    return lRet;
}

#if DBG
VOID VerifySyncOnlyMessages(VOID)
{
    int i;

    TRACE_INIT(("UserInit: Verify Sync Only Messages\n"));

    /*
     * There are a couple of thunks that just pass parameters. There are other
     * thunks besides SfnDWORD that do a straight pass through because they
     * do other processing beside the wparam and lparam
     */

    /*
     * Allow posting of LB_DIR and CB_DIR because DlgDirList allows a DDL_POSTMSGS
     * flag that makes the API post the messages. This should be OK as long as we
     * don't handle these messages in the kernel. NT 3.51 allowed posting these.
     */
    for (i=0; i<WM_USER; i++) {
        if (    i != LB_DIR
                && i != CB_DIR
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnDWORD)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnNCDESTROY)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnINWPARAMCHAR)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnINWPARAMDBCSCHAR)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnSENTDDEMSG)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnPOWERBROADCAST)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnLOGONNOTIFY)
                && (gapfnScSendMessage[MessageTable[i].iFunction] != SfnINDESTROYCLIPBRD)) {
            if (!(TESTSYNCONLYMESSAGE(i,0x8000)))
                RIPMSG1(RIP_ERROR, "InitSyncOnly: is this message sync-only 0x%lX", i);
        } else {
            if (TESTSYNCONLYMESSAGE(i,0))
                RIPMSG1(RIP_VERBOSE, "InitSyncOnly: is this message not sync-only 0x%lX", i);
        }

    }
}
#endif // DBG

/***************************************************************************\
* InitWindowMsgTables
*
* This function generates a bit-array lookup table from a list of messages.
* The lookup table is used to determine whether the message needs to be
* passed over to the server for handling or whether it can be handled
* directly on the client.
*
* LATER: Some memory (a couple hundred bytes per process) could be saved
*        by putting this in the shared read-only heap.
*
*
* 27-Mar-1992 DarrinM   Created.
* 06-Dec-1993 MikeKe    Added support for all of our window procs.
\***************************************************************************/
VOID InitWindowMsgTable(
    PBYTE      *ppbyte,
    PUINT      pmax,
    CONST WORD *pw)
{
    UINT i;
    WORD msg;
    UINT cbTable;

    *pmax = 0;
    for (i = 0; (msg = pw[i]) != 0; i++) {
        if (msg > *pmax)
            *pmax = msg;
    }

    cbTable = *pmax / 8 + 1;
    *ppbyte = SharedAlloc(cbTable);
    if (*ppbyte == NULL) {
        return;
    }

    for (i = 0; (msg = pw[i]) != 0; i++)
        (*ppbyte)[msg / 8] |= (BYTE)(1 << (msg & 7));
}

/***************************************************************************\
* InitFunctionTables
*
* Initialize the procedures and function tables.
*
*
* 25-Aug-1995 ChrisWil  Created comment block.
\***************************************************************************/
VOID InitFunctionTables(VOID)
{
    UINT i;

    TRACE_INIT(("UserInit: Initialize Function Tables\n"));

#if DBG
        try {
            UserAssert(sizeof(CLIENTINFO) <= sizeof(NtCurrentTeb()->Win32ClientInfo));
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }
#endif

    /*
     * This table is used to convert from server procs to client procs.
     */
    STOCID(FNID_SCROLLBAR)              = (WNDPROC_PWND)xxxSBWndProc;
    STOCID(FNID_ICONTITLE)              = xxxDefWindowProc;
    STOCID(FNID_MENU)                   = xxxMenuWindowProc;
    STOCID(FNID_DESKTOP)                = xxxDesktopWndProc;
    STOCID(FNID_DEFWINDOWPROC)          = xxxDefWindowProc;
    STOCID(FNID_MESSAGEWND)             = xxxDefWindowProc;

    /*
     * This table is used to determine the number minimum number
     * of reserved windows words required for the server proc.
     */
    CBFNID(FNID_SCROLLBAR)              = sizeof(SBWND);
    CBFNID(FNID_ICONTITLE)              = sizeof(WND);
    CBFNID(FNID_MENU)                   = sizeof(MENUWND);

    /*
     * Initialize this data structure (api function table).
     */
    for (i = 0; i < FNID_ARRAY_SIZE; i++) {
        FNID((i + FNID_START)) = xxxUnusedFunctionId;
    }
    FNID(FNID_SCROLLBAR)                = xxxWrapSBWndProc;
    FNID(FNID_ICONTITLE)                = xxxWrapRealDefWindowProc;
    FNID(FNID_MENU)                     = xxxWrapMenuWindowProc;
    FNID(FNID_DESKTOP)                  = xxxWrapDesktopWndProc;
    FNID(FNID_DEFWINDOWPROC)            = xxxWrapRealDefWindowProc;
    FNID(FNID_MESSAGEWND)               = xxxWrapRealDefWindowProc;
    FNID(FNID_SENDMESSAGE)              = xxxWrapSendMessage;
    FNID(FNID_HKINLPCWPEXSTRUCT)        = fnHkINLPCWPEXSTRUCT;
    FNID(FNID_HKINLPCWPRETEXSTRUCT)     = fnHkINLPCWPRETEXSTRUCT;
    FNID(FNID_SENDMESSAGEFF)            = xxxSendMessageFF;
    FNID(FNID_SENDMESSAGEEX)            = xxxSendMessageEx;
    FNID(FNID_CALLWINDOWPROC)           = xxxWrapCallWindowProc;
    FNID(FNID_SENDMESSAGEBSM)           = xxxWrapSendMessageBSM;
    FNID(FNID_SWITCH)                   = xxxWrapSwitchWndProc;
    FNID(FNID_SENDNOTIFYMESSAGE)        = xxxWrapSendNotifyMessage;
    FNID(FNID_SENDMESSAGECALLBACK)      = xxxWrapSendMessageCallback;

#if DBG
    {
        PULONG_PTR pdw;

        /*
         * Make sure that everyone got initialized.
         */
        for (pdw = (PULONG_PTR)&STOCID(FNID_START);
                (ULONG_PTR)pdw<(ULONG_PTR)(&STOCID(FNID_WNDPROCEND)); pdw++) {
            UserAssert(*pdw);
        }

        for (pdw=(PULONG_PTR)&FNID(FNID_START);
                (ULONG_PTR)pdw<(ULONG_PTR)(&FNID(FNID_WNDPROCEND)); pdw++) {
            UserAssert(*pdw);
        }
    }
#endif
}

/***************************************************************************\
* InitMessageTables
*
* Initialize the message tables.
*
*
* 25-Aug-1995 ChrisWil      Created.
\***************************************************************************/
VOID InitMessageTables(VOID)
{
    TRACE_INIT(("UserInit: Initialize Message Tables\n"));

#define INITMSGTABLE(member, procname)                \
    InitWindowMsgTable(&(gSharedInfo.member.abMsgs),  \
                       &(gSharedInfo.member.maxMsgs), \
                       gaw ## procname);

    INITMSGTABLE(DefWindowMsgs, DefWindowMsgs);
    INITMSGTABLE(DefWindowSpecMsgs, DefWindowSpecMsgs);

    INITMSGTABLE(awmControl[FNID_DIALOG       - FNID_START], DefDlgProc);
    INITMSGTABLE(awmControl[FNID_SCROLLBAR    - FNID_START], ScrollBarWndProc);
    INITMSGTABLE(awmControl[FNID_MENU         - FNID_START], MenuWndProc);
    INITMSGTABLE(awmControl[FNID_DESKTOP      - FNID_START], DesktopWndProc);
    INITMSGTABLE(awmControl[FNID_STATIC       - FNID_START], StaticWndProc);
    INITMSGTABLE(awmControl[FNID_BUTTON       - FNID_START], ButtonWndProc);
    INITMSGTABLE(awmControl[FNID_LISTBOX      - FNID_START], ListboxWndProc);
    INITMSGTABLE(awmControl[FNID_COMBOBOX     - FNID_START], ComboWndProc);
    INITMSGTABLE(awmControl[FNID_COMBOLISTBOX - FNID_START], ListboxWndProc);
    INITMSGTABLE(awmControl[FNID_EDIT         - FNID_START], EditWndProc);
    INITMSGTABLE(awmControl[FNID_IME          - FNID_START], ImeWndProc);
}

/***************************************************************************\
* InitOLEFormats
*
* OLE performance hack. OLE was previously having to call the server
* 15 times for clipboard formats and another 15 LPC calls for the global
* atoms. Now we preregister them. We also assert they are in order so
* OLE only has to query the first to know them all. We call AddAtom
* directly instead of RegisterClipboardFormat.
*
*
* 25-Aug-1995 ChrisWil      Created.
\***************************************************************************/
BOOL InitOLEFormats(VOID)
{
    UINT idx;
    ATOM a1;
    ATOM a2;
    BOOL fSuccess = TRUE;

    TRACE_INIT(("UserInit: Initialize OLE Formats\n"));

    a1 = UserAddAtom(lpszOLEFormats[0], TRUE);

    for (idx = 1; idx < ARRAY_SIZE(lpszOLEFormats); idx++) {
        a2 = UserAddAtom(lpszOLEFormats[idx], TRUE);
        fSuccess &= !!a2;

        UserAssert(((a1 + 1) == a2) && (a1 = a2));
    }

    if (!fSuccess) {
        RIPMSG0(RIP_ERROR, "InitOLEFormats: at least one atom not registered");
    }

    return fSuccess;
}

/***************************************************************************\
* InitGlobalRIPFlags (debug only)
*
* This initializes the global RIP flags from the registry.
*
*
* 25-Aug-1995 ChrisWil      Created.
\***************************************************************************/
#if DBG
VOID
InitGlobalRIPFlags()
{

    UINT  idx;
    UINT  nCount;
    DWORD dwFlag;

    static CONST struct {
        LPWSTR lpszKey;
        DWORD  dwDef;
        DWORD  dwFlag;
    } aRIPFlags[] = {
        {L"fPromptOnError"  , 1, RIPF_PROMPTONERROR},
        {L"fPromptOnWarning", 0, RIPF_PROMPTONWARNING},
        {L"fPromptOnVerbose", 0, RIPF_PROMPTONVERBOSE},
        {L"fPrintError"     , 1, RIPF_PRINTONERROR},
        {L"fPrintWarning"   , 1, RIPF_PRINTONWARNING},
        {L"fPrintVerbose"   , 0, RIPF_PRINTONVERBOSE},
        {L"fPrintFileLine"  , 0, RIPF_PRINTFILELINE},
    };

    TRACE_INIT(("UserInit: Initialize Global RIP Flags\n"));

    nCount = sizeof(aRIPFlags) / sizeof(aRIPFlags[0]);

    /*
     * Turn off the rip-on-warning bit. This is necessary to prevent
     * the FastGetProfileDwordW() routine from breaking into the
     * debugger if an entry can't be found. Since we provide default
     * values, there's no sense to break.
     */
    CLEAR_FLAG(gpsi->wRIPFlags, RIPF_PROMPTONWARNING);
    CLEAR_FLAG(gpsi->wRIPFlags, RIPF_PRINTONWARNING);

    for (idx = 0; idx < nCount; idx++) {
        FastGetProfileDwordW(NULL, PMAP_WINDOWSM,
                             aRIPFlags[idx].lpszKey,
                             aRIPFlags[idx].dwDef,
                             &dwFlag,
                             0);

        SET_OR_CLEAR_FLAG(gpsi->wRIPFlags, aRIPFlags[idx].dwFlag, dwFlag);
    }
}

#else // DBG

#define InitGlobalRIPFlags()

#endif // DBG



/***************************************************************************\
* _GetTextMetricsW
* _TextOutW
*
* Server shared function thunks.
*
* History:
* 10-Nov-1993 MikeKe    Created
\***************************************************************************/
BOOL _GetTextMetricsW(
    HDC           hdc,
    LPTEXTMETRICW ptm)
{
    TMW_INTERNAL tmi;
    BOOL         fret;

    fret = GreGetTextMetricsW(hdc, &tmi);

    *ptm = tmi.tmw;

    return fret;
}

BOOL _TextOutW(
    HDC     hdc,
    int     x,
    int     y,
    LPCWSTR lp,
    UINT    cc)
{
    return GreExtTextOutW(hdc, x, y, 0, NULL, (LPWSTR)lp, cc, NULL);
}


#define ROUND_UP_TO_PAGES(SIZE) \
        (((ULONG)(SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

/***************************************************************************\
* InitCreateSharedSection
*
* This creates the shared section.
*
*
* 25-Aug-1995 ChrisWil      Created comment block.
\***************************************************************************/
NTSTATUS InitCreateSharedSection(VOID)
{
    ULONG             ulHeapSize;
    ULONG             ulHandleTableSize;
    NTSTATUS          Status;
    LARGE_INTEGER     SectionSize;
    SIZE_T            ViewSize;
    PVOID             pHeapBase;

    TRACE_INIT(("UserInit: Create Shared Memory Section\n"));

    UserAssert(ghSectionShared == NULL);

    ulHeapSize        = ROUND_UP_TO_PAGES(USRINIT_SHAREDSECT_SIZE * 1024);
    ulHandleTableSize = ROUND_UP_TO_PAGES(0x10000 * sizeof(HANDLEENTRY));

    TRACE_INIT(("UserInit: Share: TableSize = %X; HeapSize = %X\n",
            ulHandleTableSize, ulHeapSize));

    SectionSize.LowPart  = ulHeapSize + ulHandleTableSize;
    SectionSize.HighPart = 0;

    Status = Win32CreateSection(&ghSectionShared,
                                SECTION_ALL_ACCESS,
                                (POBJECT_ATTRIBUTES)NULL,
                                &SectionSize,
                                PAGE_EXECUTE_READWRITE,
                                SEC_RESERVE,
                                (HANDLE)NULL,
                                NULL,
                                TAG_SECTION_SHARED);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "MmCreateSection failed in InitCreateSharedSection with Status %x",
                Status);
        return Status;
    }

    ViewSize = 0;
    gpvSharedBase = NULL;

    Status = Win32MapViewInSessionSpace(ghSectionShared, &gpvSharedBase, &ViewSize);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Win32MapViewInSessionSpace failed with Status %x",
                Status);
        Win32DestroySection(ghSectionShared);
        ghSectionShared = NULL;
        return Status;
    }

    pHeapBase = ((PBYTE)gpvSharedBase + ulHandleTableSize);

    TRACE_INIT(("UserInit: Share: BaseAddr = %#p; Heap = %#p, ViewSize = %X\n",
            gpvSharedBase, pHeapBase, ViewSize));

    /*
     * Create shared heap.
     */
    if ((gpvSharedAlloc = UserCreateHeap(
            ghSectionShared,
            ulHandleTableSize,
            pHeapBase,
            ulHeapSize,
            UserCommitSharedMemory)) == NULL) {
        RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "Can't create shared memory heap.");

        Win32UnmapViewInSessionSpace(gpvSharedBase);

        Win32DestroySection(ghSectionShared);
        gpvSharedAlloc = NULL;
        gpvSharedBase = NULL;
        ghSectionShared = NULL;

        return STATUS_NO_MEMORY;
    }

    UserAssert(Win32HeapGetHandle(gpvSharedAlloc) == pHeapBase);

    return STATUS_SUCCESS;
}

/**************************************************************************\
* InitCreateUserCrit
*
* Create and initialize the user critical sections needed throughout the
* system.
*
* 23-Jan-1996 ChrisWil      Created.
\**************************************************************************/
BOOL InitCreateUserCrit(VOID)
{
    TRACE_INIT(("Win32UserInit: InitCreateUserCrit()\n"));

    /*
     * Initialize a critical section structure that will be used to protect
     * all of the User Server's critical sections (except a few special
     * cases like the RIT -- see below).
     */
    gpresUser = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(ERESOURCE),
                                      TAG_ERESOURCE);
    if (!gpresUser) {
        goto InitCreateUserCritExit;
    }

    if (!NT_SUCCESS(ExInitializeResourceLite(gpresUser))) {
        goto InitCreateUserCritExit;
    }

    /*
     * Initialize a critical section to be used in [Un]QueueMouseEvent
     * to protect the queue of mouse input events that the desktop thread
     * uses to pass input on to the RIT, after having moved the cursor
     * without obtaining gpresUser itself.
     */
    gpresMouseEventQueue = ExAllocatePoolWithTag(NonPagedPool,
                                                 sizeof(ERESOURCE),
                                                 TAG_ERESOURCE);
    if (!gpresMouseEventQueue) {
        goto InitCreateUserCritExit;
    }
    if (!NT_SUCCESS(ExInitializeResourceLite(gpresMouseEventQueue))) {
        goto InitCreateUserCritExit;
    }

    /*
     * Initialize a critical section to protect the list of DEVICEINFO structs
     * kept under gpDeviceInfoList. This is used by the RIT when reading kbd
     * input, the desktop thread when reading mouse input, and the PnP callback
     * routines DeviceClassNotify() and DeviceNotify() when devices come and go.
     */
    gpresDeviceInfoList = ExAllocatePoolWithTag(NonPagedPool,
                                            sizeof(ERESOURCE),
                                            TAG_ERESOURCE);
    if (!gpresDeviceInfoList) {
        goto InitCreateUserCritExit;
    }
    if (!NT_SUCCESS(ExInitializeResourceLite(gpresDeviceInfoList))) {
        goto InitCreateUserCritExit;
    }

    /*
     * Create the handle flag mutex. We'll need this once we start creating
     * windowstations and desktops.
     */
    gpHandleFlagsMutex = ExAllocatePoolWithTag(NonPagedPool,
                                               sizeof(FAST_MUTEX),
                                               TAG_SYSTEM);
    if (gpHandleFlagsMutex == NULL) {
        goto InitCreateUserCritExit;
    }
    ExInitializeFastMutex(gpHandleFlagsMutex);

    TRACE_INIT(("Win32UserInit: gpHandleFlagsMutex = %#p\n", gpHandleFlagsMutex));
    TRACE_INIT(("Win32UserInit: gpresDeviceInfoList = %#p\n", gpresDeviceInfoList));
    TRACE_INIT(("Win32UserInit: gpresMouseEventQueue = %#p\n", gpresMouseEventQueue));
    TRACE_INIT(("Win32UserInit: gpresUser  = %#p\n", gpresUser));

    TRACE_INIT(("Win32UserInit: exit InitCreateUserCrit()\n"));
    return TRUE;

InitCreateUserCritExit:
    RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_ERROR,
            "Win32UserInit: InitCreateUserCrit failed");

    if (gpresUser) {
        ExFreePool(gpresUser);
    }
    if (gpresMouseEventQueue) {
        ExFreePool(gpresMouseEventQueue);
    }
    if (gpresDeviceInfoList) {
        ExFreePool(gpresDeviceInfoList);
    }
    return FALSE;
}

/**************************************************************************\
* InitCreateObjectDirectory
*
* Create and initialize the user critical sections needed throughout the
* system.
*
* 23-Jan-1996 ChrisWil      Created.
\**************************************************************************/
NTSTATUS InitCreateObjectDirectory(VOID)
{
    HANDLE            hDir;
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UnicodeString;
    ULONG             attributes = OBJ_CASE_INSENSITIVE | OBJ_PERMANENT;

    TRACE_INIT(("UserInit: Create User Object-Directory\n"));

    RtlInitUnicodeString(&UnicodeString, szWindowStationDirectory);

    if (gbRemoteSession) {
       /*
        * Remote sessions don't use this flag
        */
       attributes &= ~OBJ_PERMANENT;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               attributes,
                               NULL,
                               gpsdInitWinSta);

    Status = ZwCreateDirectoryObject(&hDir,
                                     DIRECTORY_CREATE_OBJECT,
                                     &ObjectAttributes);

    UserFreePool(gpsdInitWinSta);

    /*
     * Do not close this handle for remote session because
     * if we do close it then the directory will go away and
     * we don't want that to happen. When CSRSS will go away
     * this handle will be freed also.
     */
    if (!gbRemoteSession)
        ZwClose(hDir);

    gpsdInitWinSta = NULL;

    return Status;
}

/**************************************************************************\
* InitCreateUserSubsystem
*
* Create and initialize the user subsystem stuff.
* system.
*
* 23-Jan-1996 ChrisWil      Created.
\**************************************************************************/
BOOL
InitCreateUserSubsystem()
{
    LPWSTR         lpszSubSystem;
    LPWSTR         lpszT;
    UNICODE_STRING strSize;

    TRACE_INIT(("UserInit: Create User SubSystem\n"));

    /*
     * Initialize the subsystem section. This identifies the default
     * user-heap size.
     */
    lpszSubSystem = UserAllocPoolWithQuota(USRINIT_SHAREDSECT_BUFF_SIZE * sizeof(WCHAR),
                                           TAG_SYSTEM);

    if (lpszSubSystem == NULL) {
        return FALSE;
    }

    if (FastGetProfileStringW(NULL, PMAP_SUBSYSTEMS,
                              L"Windows",
                              L"SharedSection=,3072",
                              lpszSubSystem,
                              USRINIT_SHAREDSECT_READ_SIZE,
                              0) == 0) {
        RIPMSG0(RIP_WARNING,
                "UserInit: Windows subsystem definition not found");
        UserFreePool(lpszSubSystem);
        return FALSE;
    }

    /*
     * Locate the SharedSection portion of the definition and extract
     * the second value.
     */
    gdwDesktopSectionSize = USRINIT_WINDOWSECT_SIZE;
    gdwNOIOSectionSize    = USRINIT_NOIOSECT_SIZE;

    if (lpszT = wcsstr(lpszSubSystem, L"SharedSection")) {

        *(lpszT + 32) = UNICODE_NULL;

        if (lpszT = wcschr(lpszT, L',')) {

            RtlInitUnicodeString(&strSize, ++lpszT);
            RtlUnicodeStringToInteger(&strSize, 0, &gdwDesktopSectionSize);

            /*
             * Assert this logic doesn't need to change.
             */
            UserAssert(gdwDesktopSectionSize >= USRINIT_WINDOWSECT_SIZE);

            gdwDesktopSectionSize = max(USRINIT_WINDOWSECT_SIZE, gdwDesktopSectionSize);
            gdwNOIOSectionSize    = gdwDesktopSectionSize;

            /*
             * Now see if the optional non-interactive desktop
             * heap size was specified.
             */
            if (lpszT = wcschr(lpszT, L',')) {

                RtlInitUnicodeString(&strSize, ++lpszT);
                RtlUnicodeStringToInteger(&strSize, 0, &gdwNOIOSectionSize);

                UserAssert(gdwNOIOSectionSize >= USRINIT_NOIOSECT_SIZE);
                gdwNOIOSectionSize = max(USRINIT_NOIOSECT_SIZE, gdwNOIOSectionSize);
            }
        }
    }

    UserFreePool(lpszSubSystem);

    return TRUE;
}

extern UNICODE_STRING *gpastrSetupExe;     // These are used in
extern int giSetupExe;                     // SetAppImeCompatFlags in
                                           // queue.c

WCHAR* glpSetupPrograms;

/******************************************************
*
* Create and initialize the arrary of setup app names.
* We inherited this hack From Chicago. See queue.c for
* more details.
*******************************************************/

BOOL CreateSetupNameArray() {
    DWORD  dwProgNames;
    int    iSetupProgramCount = 0;
    WCHAR* lpTemp;
    int    ic, icnt, icMax;

    dwProgNames = FastGetProfileValue(NULL, PMAP_SETUPPROGRAMNAMES,
                        L"SetupProgramNames",NULL,NULL, 0, 0);

    /*
     * This key is a multi-string, so is best to read as a value.
     * First, get the length and create the buffer to hold all of
     * the strings.
     */
    if (dwProgNames == 0) {
        return FALSE;
    }

    glpSetupPrograms = UserAllocPoolWithQuota(dwProgNames,
                                       TAG_SYSTEM);

    if (glpSetupPrograms == NULL) {
        RIPMSG0(RIP_WARNING, "CreateSetupNameArray: Memory allocation failure");
        return FALSE;
    }

    FastGetProfileValue(NULL,
                        PMAP_SETUPPROGRAMNAMES,
                        L"SetupProgramNames",
                        NULL,
                        (PBYTE)glpSetupPrograms,
                        dwProgNames,
                        0);

    lpTemp = glpSetupPrograms;
    icMax = dwProgNames/2;
    ic = 0; icnt=0;
    /*
     * Now count the strings.
     */
    while (ic < icMax) {
        if (*(lpTemp+ic) == 0) {
            ic++;
            continue;
        }
        ic += wcslen(lpTemp+ic)+1;
        icnt++;
    }

    /*
     * gpastrSetupExe is a pointer to an array of UNICODE_STRING structures.
     * Each structure is the name of one setup program.
     */
    giSetupExe = icnt;
    gpastrSetupExe = UserAllocPoolWithQuota(giSetupExe * sizeof(UNICODE_STRING),
                                       TAG_SYSTEM);

    if (gpastrSetupExe == NULL) {
        RIPMSG0(RIP_WARNING, "CreateSetupNameArray: Memory allocation failure");
        giSetupExe = 0;
        UserFreePool(glpSetupPrograms);
        glpSetupPrograms = NULL;
        return FALSE;
    }

    ic = 0; icnt=0;
    while (ic < icMax) {
        if (*(lpTemp+ic) == 0) {
            ic++;
            continue;
        }
        gpastrSetupExe[icnt].Buffer = lpTemp+ic;
        gpastrSetupExe[icnt].Length = sizeof(WCHAR)*wcslen(lpTemp+ic);
        gpastrSetupExe[icnt].MaximumLength = gpastrSetupExe[icnt].Length + sizeof(WCHAR);
        ic += wcslen(lpTemp+ic)+1;
        icnt++;

    }

    return TRUE;
}

#define CALC_DELTA(element)                   \
        (PVOID)((PBYTE)pClientBase +          \
        ((PBYTE)gSharedInfo.element -         \
        (PBYTE)gpvSharedBase))

/***************************************************************************\
* InitMapSharedSection
*
* This maps the shared section.
*
*
* 25-Aug-1995 ChrisWil      Created comment block.
\***************************************************************************/

NTSTATUS InitMapSharedSection(
    PEPROCESS    Process,
    PUSERCONNECT pUserConnect)
{
    int           i;
    PVOID         pClientBase = NULL;
    ULONG_PTR      ulSharedDelta;
    PW32PROCESS   pw32p;

    TRACE_INIT(("UserInit: Map Shared Memory Section\n"));

    UserAssert(ghSectionShared != NULL);

    ValidateProcessSessionId(Process);

    /*
     * Check to see if we haven't already mapped the section
     * This might happen for multiple LoadLibrary()/FreeLibrary calls
     * in one process. MCostea #56946
     */
    pw32p = PsGetProcessWin32Process(Process);
    if (pw32p == NULL ||
        ((PPROCESSINFO)pw32p)->pClientBase == NULL) {

        SIZE_T        ViewSize;
        LARGE_INTEGER liOffset;
        NTSTATUS Status;

        ViewSize = 0;
        liOffset.QuadPart = 0;

        Status = MmMapViewOfSection(ghSectionShared,
                                Process,
                                &pClientBase,
                                0,
                                0,
                                &liOffset,
                                &ViewSize,
                                ViewUnmap,
                                SEC_NO_CHANGE,
                                PAGE_EXECUTE_READ);
        if (NT_SUCCESS(Status)) {
            TRACE_INIT(("UserInit: Map: Client SharedInfo Base = %#p\n", pClientBase));

            UserAssert(gpvSharedBase > pClientBase);
            pw32p = PsGetProcessWin32Process(Process);
            if (pw32p != NULL) {
                ((PPROCESSINFO)pw32p)->pClientBase = pClientBase;
            }
        } else {
            return Status;
        }

    } else {
        pClientBase = ((PPROCESSINFO)PsGetProcessWin32Process(Process))->pClientBase;
    }
    ulSharedDelta = (PBYTE)gpvSharedBase - (PBYTE)pClientBase;
    pUserConnect->siClient.ulSharedDelta = ulSharedDelta;

    pUserConnect->siClient.psi          = CALC_DELTA(psi);
    pUserConnect->siClient.aheList      = CALC_DELTA(aheList);
    pUserConnect->siClient.pDispInfo    = CALC_DELTA(pDispInfo);


    pUserConnect->siClient.DefWindowMsgs.maxMsgs     = gSharedInfo.DefWindowMsgs.maxMsgs;
    pUserConnect->siClient.DefWindowMsgs.abMsgs      = CALC_DELTA(DefWindowMsgs.abMsgs);
    pUserConnect->siClient.DefWindowSpecMsgs.maxMsgs = gSharedInfo.DefWindowSpecMsgs.maxMsgs;
    pUserConnect->siClient.DefWindowSpecMsgs.abMsgs  = CALC_DELTA(DefWindowSpecMsgs.abMsgs);

    for (i = 0; i < (FNID_END - FNID_START + 1); ++i) {

        pUserConnect->siClient.awmControl[i].maxMsgs = gSharedInfo.awmControl[i].maxMsgs;

        if (gSharedInfo.awmControl[i].abMsgs)
            pUserConnect->siClient.awmControl[i].abMsgs = CALC_DELTA(awmControl[i].abMsgs);
        else
            pUserConnect->siClient.awmControl[i].abMsgs = NULL;
    }
    return STATUS_SUCCESS;
}
/**************************************************************************\
* InitLoadResources
*
*
* 25-Aug-1995 ChrisWil      Created.
\**************************************************************************/

VOID InitLoadResources()
{
    PRECT   prc;

    DISPLAYRESOURCE dr = {
        17,     // Height of vertical thumb
        17,     // Width of horizontal thumb
        2,      // Icon horiz compression factor
        2,      // Icon vert compression factor
        2,      // Cursor horz compression factor
        2,      // Cursor vert compression factor
        0,      // Kanji window height
        1,      // cxBorder (thickness of vertical lines)
        1       // cyBorder (thickness of horizontal lines)
    };


    TRACE_INIT(("UserInit: Load Display Resources\n"));

    /*
     * For high-DPI systems, don't compress the cursor as much.
     * This really should be a more configurable method, such as a System
     * Parameter Info setting or something. But for now, we'll hard-code
     * 150dpi to be the threshhold at which we'll double the cursor size.
     */
    if (gpsi->dmLogPixels >= 150) {
        dr.xCompressCursor = 1;
        dr.yCompressCursor = 1;
    }

    if (dr.xCompressIcon > 10) {

        /*
         * If so, the actual dimensions of icons and cursors are
         * kept in OEMBIN.
         */
        SYSMET(CXICON)   = dr.xCompressIcon;
        SYSMET(CYICON)   = dr.yCompressIcon;
        SYSMET(CXCURSOR) = dr.xCompressCursor;
        SYSMET(CYCURSOR) = dr.yCompressCursor;

    } else {

        /*
         * Else, only the ratio of (64/icon dimensions) is kept there.
         */
        SYSMET(CXICON)   = (64 / dr.xCompressIcon);
        SYSMET(CYICON)   = (64 / dr.yCompressIcon);
        SYSMET(CXCURSOR) = (64 / dr.xCompressCursor);
        SYSMET(CYCURSOR) = (64 / dr.yCompressCursor);
    }

    SYSMET(CXSMICON) = SYSMET(CXICON) / 2;
    SYSMET(CYSMICON) = SYSMET(CYICON) / 2;

    SYSMET(CYKANJIWINDOW) = dr.yKanji;

    /*
     * Get border thicknesses.
     */
    SYSMET(CXBORDER) = dr.cxBorder;
    SYSMET(CYBORDER) = dr.cyBorder;

    /*
     * Edge is two borders.
     */
    SYSMET(CXEDGE) = 2 * SYSMET(CXBORDER);
    SYSMET(CYEDGE) = 2 * SYSMET(CYBORDER);

    /*
     * Fixed frame is outer edge + border.
     */
    SYSMET(CXDLGFRAME) = SYSMET(CXEDGE) + SYSMET(CXBORDER);
    SYSMET(CYDLGFRAME) = SYSMET(CYEDGE) + SYSMET(CYBORDER);

    if (gbRemoteSession) {
        return;
    }

    prc = &GetPrimaryMonitor()->rcMonitor;
    SYSMET(CXFULLSCREEN) = prc->right;
    SYSMET(CYFULLSCREEN) = prc->bottom - SYSMET(CYCAPTION);

    /*
     * Set the initial cursor position to the center of the primary screen.
     */
    gpsi->ptCursor.x = prc->right / 2;
    gpsi->ptCursor.y = prc->bottom / 2;
}

/***************************************************************************\
* GetCharDimensions
*
* This function loads the Textmetrics of the font currently selected into
* the hDC and returns the Average char width of the font; Pl Note that the
* AveCharWidth value returned by the Text metrics call is wrong for
* proportional fonts. So, we compute them On return, lpTextMetrics contains
* the text metrics of the currently selected font.
*
* History:
* 10-Nov-1993 mikeke   Created
\***************************************************************************/
int GetCharDimensions(
        HDC          hdc,
        TEXTMETRIC*  lptm,
        LPINT        lpcy
        )
{
    TEXTMETRIC tm;

    /*
     * Didn't find it in cache, store the font metrics info.
     */
    if (!_GetTextMetricsW(hdc, &tm)) {
        RIPMSG1(RIP_WARNING, "GetCharDimensions: _GetTextMetricsW failed. hdc %#lx", hdc);
        tm = gpsi->tmSysFont; // damage control

        if (tm.tmAveCharWidth == 0) {
            RIPMSG0(RIP_WARNING, "GetCharDimensions: _GetTextMetricsW first time failure");
            tm.tmAveCharWidth = 8;
        }
    }
    if (lptm != NULL)
        *lptm = tm;
    if (lpcy != NULL)
        *lpcy = tm.tmHeight;

    /*
     * If variable_width font
     */
    if (tm.tmPitchAndFamily & TMPF_FIXED_PITCH) {
        SIZE size;
        static CONST WCHAR wszAvgChars[] =
                L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

        /*
         * Change from tmAveCharWidth. We will calculate a true average
         * as opposed to the one returned by tmAveCharWidth. This works
         * better when dealing with proportional spaced fonts.
         */
        if (GreGetTextExtentW(
                hdc, (LPWSTR)wszAvgChars,
                (sizeof(wszAvgChars) / sizeof(WCHAR)) - 1,
                &size, GGTE_WIN3_EXTENT)) {

            UserAssert((((size.cx / 26) + 1) / 2) > 0);
            return ((size.cx / 26) + 1) / 2;    // round up
        } else {
            RIPMSG1(RIP_WARNING, "GetCharDimensions: GreGetTextExtentW failed. hdc %#lx", hdc);
        }
    }

    UserAssert(tm.tmAveCharWidth > 0);

    return tm.tmAveCharWidth;
}


/**************************************************************************\
* InitVideo
*
* Create pmdev.
*
* 03-March-1998 CLupu  Moved from UserInitialize code
\**************************************************************************/
PMDEV InitVideo(
    BOOL bReenumerationNeeded)
{
    PMDEV pmdev;
    LONG  ChangeStatus;

    if (NT_SUCCESS(DrvInitConsole(bReenumerationNeeded)) == FALSE) {
        RIPMSG0(RIP_WARNING, "InitVideo: Failed to initialize console");
        return NULL;
    }

    /*
     * BASEVIDEO may be on or off, whether we are in setup or not.
     */

    ChangeStatus = DrvChangeDisplaySettings(NULL,
                                            NULL,
                                            NULL,
                                            (PVOID) (GW_DESKTOP_ID),
                                            KernelMode,
                                            FALSE,
                                            TRUE,
                                            NULL,
                                            &pmdev,
                                            GRE_DEFAULT,
                                            TRUE);


    if (ChangeStatus != GRE_DISP_CHANGE_SUCCESSFUL) {
        /*
         * If we fail, try BASEVIDEO temporarily
         */
        DrvSetBaseVideo(TRUE);

        ChangeStatus = DrvChangeDisplaySettings(NULL,
                                                NULL,
                                                NULL,
                                                (PVOID) (GW_DESKTOP_ID),
                                                KernelMode,
                                                FALSE,
                                                TRUE,
                                                NULL,
                                                &pmdev,
                                                GRE_DEFAULT,
                                                TRUE);

        DrvSetBaseVideo(FALSE);

        /*
         * Give it one last try, not in basevideo, to handle TGA
         * (non-vgacompatible) during GUI-mode setup (BASEVIDEO is on by
         * default)
         */

        if (ChangeStatus != GRE_DISP_CHANGE_SUCCESSFUL) {
            ChangeStatus = DrvChangeDisplaySettings(NULL,
                                                    NULL,
                                                    NULL,
                                                    (PVOID) (GW_DESKTOP_ID),
                                                    KernelMode,
                                                    FALSE,
                                                    TRUE,
                                                    NULL,
                                                    &pmdev,
                                                    GRE_DEFAULT,
                                                    TRUE);

        }
    }

    if (ChangeStatus != GRE_DISP_CHANGE_SUCCESSFUL) {
        RIPMSG0(RIP_WARNING, "InitVideo: No working display driver found");
        return NULL;
    }

    /*
     * Remove the basevideo flag. We want it set only on the first modeset.
     */
    DrvSetBaseVideo(FALSE);

    gpDispInfo->hDev  = pmdev->hdevParent;
    gpDispInfo->pmdev = pmdev;

    GreUpdateSharedDevCaps(gpDispInfo->hDev);

    if (!InitUserScreen()) {
        RIPMSG0(RIP_WARNING, "InitUserScreen failed");
        return NULL;
    }

    HYDRA_HINT(HH_INITVIDEO);

    return pmdev;
}

void DrvDriverFailure(void)
{
    KeBugCheckEx(VIDEO_DRIVER_INIT_FAILURE,
                 0,
                 0,
                 0,
                 USERCURRENTVERSION);
}

/***************************************************************************\
* BeginBootPhase
*
* Let's kernel know of boot progress on the console.
*
* 10-Apr-2001 Cenke  Created.
\***************************************************************************/
NTSTATUS
BeginBootPhase(
    PF_BOOT_PHASE_ID Phase
    )
{
    PREFETCHER_INFORMATION PrefetcherInformation;
    NTSTATUS Status;

    /*
     * We should be called only on the console.
     */

    UserAssert(gSessionId == 0);

    /*
     * Setup the structure that will be passed to system call.
     */

    PrefetcherInformation.Magic = PF_SYSINFO_MAGIC_NUMBER;
    PrefetcherInformation.Version = PF_CURRENT_VERSION;
    PrefetcherInformation.PrefetcherInformationClass = PrefetcherBootPhase;
    PrefetcherInformation.PrefetcherInformation = &Phase;
    PrefetcherInformation.PrefetcherInformationLength = sizeof(Phase);

    /*
     * Call system and return status to caller.
     */

    Status = ZwSetSystemInformation(SystemPrefetcherInformation,
                                    &PrefetcherInformation,
                                    sizeof(PrefetcherInformation));

    return Status;
}

/**************************************************************************\
* UserInitialize
*
* Worker routine for user initialization.
*
* 25-Aug-1995 ChrisWil  Created comment block/Multiple desktop support.
* 15-Dec-1995 BradG     Modified to return MediaChangeEvent Handle.
\**************************************************************************/
NTSTATUS
UserInitialize(
    VOID)
{
    NTSTATUS Status;
    DWORD    dwData;

    /*
     * Allow a trace of all the init stuff going on related to display drivers.
     * Usefull to debug boot time problems related to graphics.
     */
    if (RtlGetNtGlobalFlags() & FLG_SHOW_LDR_SNAPS)
        TraceInitialization = 1;

    TRACE_INIT(("Entering UserInitialize\n"));

    EnterCrit();

    HYDRA_HINT(HH_USERINITIALIZE);

    if (ISTS() && gbRemoteSession) {
        swprintf(szWindowStationDirectory, L"%ws\\%ld%ws",
                 SESSION_ROOT, gSessionId, WINSTA_DIR);
    } else {
        wcscpy(szWindowStationDirectory, WINSTA_DIR);
    }

    /*
     * Create WindowStation object directory.
     */
    Status = InitCreateObjectDirectory();

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "InitCreateObjectDirectory failed with Status %x",
                Status);

        goto Exit;
    }

    /*
     * Create the event for  PnP RequestDeviceChangeSyncronization
     */
    gpEventPnPWainting = CreateKernelEvent(SynchronizationEvent, TRUE);

    if (gpEventPnPWainting == NULL) {
        RIPMSG0(RIP_WARNING, "Failed to create gpEventPnPWainting");
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * Read the registry configuration for the multimon snapsot flag
     */

    if (FastGetProfileIntFromID(NULL,PMAP_TS, STR_SNAPSHOTMONITORS, 1, &dwData, 0)) {
        if (dwData != 0) {
            gbSnapShotWindowsAndMonitors = TRUE;
        } else {
            gbSnapShotWindowsAndMonitors = FALSE;
        }
    }  else{
        gbSnapShotWindowsAndMonitors = TRUE;
    }



    /*
     * Create the event for the diconnect desktop creation
     */
    gpEventDiconnectDesktop = CreateKernelEvent(SynchronizationEvent, FALSE);

    if (gpEventDiconnectDesktop == NULL) {
        RIPMSG0(RIP_WARNING, "Failed to create gpEventDiconnectDesktop");
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * WinStations get init'ed on the first connect.
     */
    if (!gbRemoteSession) {
        BeginBootPhase(PfVideoInitPhase);
        
        if (InitVideo(TRUE) == NULL) {
            DrvDriverFailure();
        }

        BeginBootPhase(PfPostVideoInitPhase);

        /*
         * Do this here so power callouts
         * have the pmdev in gpDispInfo set
         */
        gbVideoInitialized = TRUE;
    }

    gbUserInitialized = TRUE;

    /*
     * Now that the system is initialized, allocate
     * a pti for this thread.
     */
    Status = xxxCreateThreadInfo(PsGetCurrentThread(), FALSE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxCreateThreadInfo failed during UserInitialize with Status",
                Status);
        goto Exit;
    }

    /*
     * Initialize Global RIP flags (debug only).
     */
    InitGlobalRIPFlags();

    /*
     * WinStations get init'ed on the first connect
     */
    if (!gbRemoteSession)
        UserVerify(LW_BrushInit());

    InitLoadResources();

Exit:
    LeaveCrit();

    TRACE_INIT(("Leaving UserInitialize\n"));

    return Status;
}

/**************************************************************************\
* IsDBCSEnabledSystem
*
* check if the system is configured as FE Enabled
*
* 07-Feb-1997 HiroYama  Created
\**************************************************************************/
BOOL IsDBCSEnabledSystem()
{
    return !!NLS_MB_CODE_PAGE_TAG;
}


BOOL IsIMMEnabledSystem()
{
    DWORD dwRet = 0;

    // if the entire system is DBCS enabled, IMM/IME should be activated anyway
    if (IsDBCSEnabledSystem())
        return TRUE;

    FastGetProfileDwordW(NULL, PMAP_IMM, TEXT("LoadIMM"), 0, &dwRet, 0);
    return dwRet;
}

#ifdef CUAS_ENABLE

BOOL IsCTFIMEEnabledSystem(
    VOID)
{
    DWORD dwRet = 0;

    FastGetProfileDwordW(NULL, PMAP_IMM, TEXT("DontLoadCTFIME"), 0, &dwRet, 0);
    if (dwRet)
        return FALSE;

    return IsIMMEnabledSystem();
}

#endif

// Get ACP and check if the system is configured as ME Enabled
BOOL IsMidEastEnabledSystem()
{
    extern __declspec(dllimport) USHORT NlsAnsiCodePage;
    //1255 Hebrew and 1256 Arabic
    if ((NlsAnsiCodePage == 1255) || (NlsAnsiCodePage == 1256)) {
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* SetupClassAtoms
*
* 10/01/1998   clupu          moved from Win32UserInitialize
\***************************************************************************/
BOOL SetupClassAtoms(
    VOID)
{
    BOOL fSuccess = TRUE;
    int  ind;

    /*
     * Set up class atoms
     */
     /*
     * HACK: Controls are registered on the client side so we can't
     * fill in their atomSysClass entry the same way we do for the other
     * classes.
     */
    for (ind = ICLS_BUTTON; ind < ICLS_CTL_MAX; ind++) {
        gpsi->atomSysClass[ind] = UserAddAtom(lpszControls[ind], TRUE);
        fSuccess &= !!gpsi->atomSysClass[ind];
    }

    gpsi->atomSysClass[ICLS_DIALOG]    = PTR_TO_ID(DIALOGCLASS);
    gpsi->atomSysClass[ICLS_ICONTITLE] = PTR_TO_ID(ICONTITLECLASS);
    gpsi->atomSysClass[ICLS_TOOLTIP]   = PTR_TO_ID(TOOLTIPCLASS);
    gpsi->atomSysClass[ICLS_DESKTOP]   = PTR_TO_ID(DESKTOPCLASS);
    gpsi->atomSysClass[ICLS_SWITCH]    = PTR_TO_ID(SWITCHWNDCLASS);
    gpsi->atomSysClass[ICLS_MENU]      = PTR_TO_ID(MENUCLASS);

    gpsi->atomContextHelpIdProp = UserAddAtom(szCONTEXTHELPIDPROP, TRUE);
    fSuccess &= !!gpsi->atomContextHelpIdProp;

    gpsi->atomIconSmProp        = UserAddAtom(szICONSM_PROP_NAME, TRUE);
    fSuccess &= !!gpsi->atomIconSmProp;

    gpsi->atomIconProp          = UserAddAtom(szICON_PROP_NAME, TRUE);
    fSuccess &= !!gpsi->atomIconProp;

    gpsi->uiShellMsg            = UserAddAtom(szSHELLHOOK, TRUE);
    fSuccess &= !!gpsi->uiShellMsg;

    /*
     * Initialize the integer atoms for our magic window properties
     */
    atomCheckpointProp = UserAddAtom(szCHECKPOINT_PROP_NAME, TRUE);
    fSuccess &= !!atomCheckpointProp;

    atomDDETrack = UserAddAtom(szDDETRACK_PROP_NAME, TRUE);
    fSuccess &= !!atomDDETrack;

    atomQOS = UserAddAtom(szQOS_PROP_NAME, TRUE);
    fSuccess &= !!atomQOS;

    atomDDEImp = UserAddAtom(szDDEIMP_PROP_NAME, TRUE);
    fSuccess &= !!atomDDEImp;

    atomWndObj = UserAddAtom(szWNDOBJ_PROP_NAME, TRUE);
    fSuccess &= !!atomWndObj;

    atomImeLevel = UserAddAtom(szIMELEVEL_PROP_NAME, TRUE);
    fSuccess &= !!atomImeLevel;

    atomLayer = UserAddAtom(szLAYER_PROP_NAME, TRUE);
    fSuccess &= !!atomLayer;

    guiActivateShellWindow = UserAddAtom(szACTIVATESHELLWINDOW, TRUE);
    fSuccess &= !!guiActivateShellWindow;

    guiOtherWindowCreated = UserAddAtom(szOTHERWINDOWCREATED, TRUE);
    fSuccess &= !!guiOtherWindowCreated;

    guiOtherWindowDestroyed = UserAddAtom(szOTHERWINDOWDESTROYED, TRUE);
    fSuccess &= !!guiOtherWindowDestroyed;

    gatomMessage = UserAddAtom(szMESSAGE, TRUE);
    fSuccess &= !!gatomMessage;

#ifdef HUNGAPP_GHOSTING
    gatomGhost = UserAddAtom(szGHOST, TRUE);
    fSuccess &= !!gatomGhost;
#endif // HUNGAPP_GHOSTING

    gatomShadow = UserAddAtom(szSHADOW, TRUE);
    fSuccess &= !!gatomShadow;

    gaOleMainThreadWndClass = UserAddAtom(szOLEMAINTHREADWNDCLASS, TRUE);
    fSuccess &= !!gaOleMainThreadWndClass;

    gaFlashWState = UserAddAtom(szFLASHWSTATE, TRUE);
    fSuccess &= !!gaFlashWState;

    gatomLastPinned = gaOleMainThreadWndClass;

    return fSuccess;
}


/**************************************************************************\
* Win32UserInitialize
*
* Worker routine for user initialization called from Win32k.sys DriverEntry()
*
\**************************************************************************/
NTSTATUS Win32UserInitialize(VOID)
{
    NTSTATUS                 Status;
    POBJECT_TYPE_INITIALIZER pTypeInfo;
    LONG                     lTemp;

    TRACE_INIT(("Entering Win32UserInitialize\n"));

    /*
     * Create the shared section.
     */
    Status = InitCreateSharedSection();
    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "InitCreateSharedSection failed");
        return Status;
    }

    EnterCrit();

    /*
     * Initialize security stuff.
     */
    if (!InitSecurity()) {
        RIPMSG0(RIP_WARNING, "InitSecurity failed");
        goto ExitWin32UserInitialize;
    }

    /*
     * Fill in windowstation and desktop object types
     */
    pTypeInfo = &(*ExWindowStationObjectType)->TypeInfo;
    pTypeInfo->DefaultNonPagedPoolCharge = sizeof(WINDOWSTATION) + sizeof(KEVENT);
    pTypeInfo->DefaultPagedPoolCharge    = 0;
    pTypeInfo->MaintainHandleCount       = TRUE;
    pTypeInfo->ValidAccessMask           = WinStaMapping.GenericAll;
    pTypeInfo->GenericMapping            = WinStaMapping;

    pTypeInfo = &(*ExDesktopObjectType)->TypeInfo;
    pTypeInfo->DefaultNonPagedPoolCharge = sizeof(DESKTOP);
    pTypeInfo->DefaultPagedPoolCharge    = 0;
    pTypeInfo->MaintainHandleCount       = TRUE;
    pTypeInfo->ValidAccessMask           = DesktopMapping.GenericAll;
    pTypeInfo->GenericMapping            = DesktopMapping;

    /*
     * Get this process so we can use the profiles.
     */
    gpepInit = PsGetCurrentProcess();

    Status  = InitQEntryLookaside();
    Status |= InitSMSLookaside();
    Status |= UserRtlCreateAtomTable(USRINIT_ATOMBUCKET_SIZE);

    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "Initialization failure");
        goto ExitWin32UserInitialize;
    }

    atomUSER32 = UserAddAtom(szUSER32, TRUE);

    gatomFirstPinned = atomUSER32;

    if (gatomFirstPinned == 0) {
        RIPMSG0(RIP_WARNING, "Could not create atomUSER32");
        goto ExitWin32UserInitialize;
    }

    /*
     * Initialize the user subsystem information.
     */
    if (!InitCreateUserSubsystem()) {
        RIPMSG0(RIP_WARNING, "InitCreateUserSubsystem failed");
        goto ExitWin32UserInitialize;
    }

    /*
     * Don't bail out if CreateSetupNameArray fails
     * MCostea #326652
     */
    CreateSetupNameArray();

    /*
     * Allocated shared SERVERINFO structure.
     */
    if ((gpsi = (PSERVERINFO)SharedAlloc(sizeof(SERVERINFO))) == NULL) {
        RIPMSG0(RIP_WARNING, "Could not allocate SERVERINFO");
        goto ExitWin32UserInitialize;
    }

    /*
     * Set the default rip-flags to rip on just about
     * everything. We'll truly set this in the InitGlobalRIPFlags()
     * routine. These are needed so that we can do appropriate ripping
     * during the rest of the init-calls.
     */

    SET_FLAG(gpsi->wRIPFlags, RIPF_DEFAULT);

    /*
     * Make sure we will not get a division by zero if the initialization
     * will not complete correctly. Set these to their normal values.
     */
    gpsi->cxMsgFontChar = 6;
    gpsi->cyMsgFontChar = 13;
    gpsi->cxSysFontChar = 8;
    gpsi->cySysFontChar = 16;

    /*
     * Initialize the last time we updated system-wide LastSystemRITEventTickCount
     * on system shared page.
     */

    gpsi->dwLastSystemRITEventTickCountUpdate = 0;

    /*
     * Initialize the DISPLAYINFO structure.
     */
    gpDispInfo = SharedAlloc(sizeof(*gpDispInfo));
    if (!gpDispInfo) {
        RIPMSG0(RIP_WARNING, "Could not allocate gpDispInfo");
        goto ExitWin32UserInitialize;
    }

    InitDbgTags();

    SET_OR_CLEAR_SRVIF(SRVIF_DBCS, IsDBCSEnabledSystem());
    SET_OR_CLEAR_SRVIF(SRVIF_IME, IsIMMEnabledSystem());
#ifdef CUAS_ENABLE
    SET_OR_CLEAR_SRVIF(SRVIF_CTFIME_ENABLED, IsCTFIMEEnabledSystem());
#endif // CUAS_ENABLE

    SET_OR_CLEAR_SRVIF(SRVIF_MIDEAST, IsMidEastEnabledSystem());

#if DBG
    SET_SRVIF(SRVIF_CHECKED);

#if !defined(CUAS_ENABLE)
    RIPMSG3(RIP_WARNING, "*** win32k: DBCS:[%d] IME:[%d] MiddleEast:[%d]",
            IS_DBCS_ENABLED(),
            IS_IME_ENABLED(),
            IS_MIDEAST_ENABLED());
#else
    RIPMSG4(RIP_WARNING, "*** win32k: DBCS:[%d] IME:[%d] MiddleEast:[%d] CTFIME:[%d]",
            IS_DBCS_ENABLED(),
            IS_IME_ENABLED(),
            IS_MIDEAST_ENABLED(),
            IS_CICERO_ENABLED());
#endif
#endif

    gpsi->dwDefaultHeapSize = gdwDesktopSectionSize * 1024;

    /*
     * Initialize procedures and message tables.
     * Initialize the class structures for Get/SetClassWord/Long.
     * Initialize message-box strings.
     * Initialize OLE-Formats (performance-hack).
     */
    InitFunctionTables();
    InitMessageTables();
#if DBG
    VerifySyncOnlyMessages();
#endif
    if (!InitOLEFormats()) {
        RIPMSG0(RIP_WARNING, "InitOLEFormats failed");
        goto ExitWin32UserInitialize;
    }

    /*
     * Set up class atoms
     */
    if (!SetupClassAtoms()) {
        RIPMSG0(RIP_WARNING, "SetupClassAtoms failed to register atoms");
        goto ExitWin32UserInitialize;
    }

    /*
     * Initialize the handle manager.
     */
    if (!HMInitHandleTable(gpvSharedBase)) {
        RIPMSG0(RIP_WARNING, "HMInitHandleTable failed");
        goto ExitWin32UserInitialize;
    }

    /*
     * Setup shared info block.
     */
    gSharedInfo.psi = gpsi;
    gSharedInfo.pDispInfo = gpDispInfo;

    /*
     * Determine if we have unsigned drivers installed
     * Use      2BD63D28D7BCD0E251195AEB519243C13142EBC3 as current key to check.
     * Old key: 300B971A74F97E098B67A4FCEBBBF6B9AE2F404C
     */
    if (NT_SUCCESS(RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE, L"\\Registry\\Machine\\SOFTWARE\\Policies\\Microsoft\\SystemCertificates\\Root\\Certificates\\2BD63D28D7BCD0E251195AEB519243C13142EBC3")) ||
        NT_SUCCESS(RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE, L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\SystemCertificates\\Root\\Certificates\\2BD63D28D7BCD0E251195AEB519243C13142EBC3")) ||
        NT_SUCCESS(RtlCheckRegistryKey(RTL_REGISTRY_USER, L"\\SOFTWARE\\Microsoft\\SystemCertificates\\Root\\Certificates\\2BD63D28D7BCD0E251195AEB519243C13142EBC3"))) {
        gfUnsignedDrivers = TRUE;
    }

    /*
     * Set up a desktop info structure that is visible in all
     * clients.
     */
    FastGetProfileDwordW(NULL,
                         PMAP_WINDOWSM,
                         L"USERProcessHandleQuota",
                         gUserProcessHandleQuota,
                         &lTemp,
                         0);

    if ((lTemp > MINIMUM_USER_HANDLE_QUOTA) && (lTemp <= INITIAL_USER_HANDLE_QUOTA)) {
        gUserProcessHandleQuota = lTemp;
    }

    /*
     * The maximum number of posted message for a thread.
     */
    FastGetProfileDwordW(NULL,
                         PMAP_WINDOWSM,
                         L"USERPostMessageLimit",
                         gUserPostMessageLimit,
                         &lTemp,
                         0);
    if (lTemp > MINIMUM_POSTMESSAGE_LIMIT) {
        gUserPostMessageLimit = lTemp;
    } else if (lTemp == 0) {
        /*
         * 0 means (virtually) No Limit.
         */
        gUserPostMessageLimit = ~0;
    } else {
        RIPMSG1(RIP_WARNING, "Win32UserInitialize: USERPostMessageLimit value (%d) is too low.", lTemp);
    }

    if (!gDrawVersionAlways) {
        FastGetProfileDwordW(NULL,
                             PMAP_WINDOWSM,
                             L"DisplayVersion",
                             0,
                             &gDrawVersionAlways,
                             0);
    }

    FastGetProfileDwordW(NULL,
                         PMAP_TABLETPC,
                         L"Installed",
                         0,
                         &SYSMET(TABLETPC),
                         0);

    FastGetProfileDwordW(NULL,
                         PMAP_MEDIACENTER,
                         L"Installed",
                         0,
                         &SYSMET(MEDIACENTER),
                         0);
    
    /*
     * Initialize SMWP structure
     */
    if (!AllocateCvr(&gSMWP, 4)) {
        RIPMSG0(RIP_WARNING, "AllocateCvr failed");
        goto ExitWin32UserInitialize;
    }
    LeaveCrit();

    UserAssert(NT_SUCCESS(Status));
    return Status;

ExitWin32UserInitialize:
    LeaveCrit();

    if (NT_SUCCESS(Status)) {
        Status = STATUS_NO_MEMORY;
    }

    RIPMSG1(RIP_WARNING, "UserInitialize failed with Status = %x", Status);
    return Status;
}


/**************************************************************************\
* UserGetDesktopDC
*
* 09-Jan-1992 mikeke created
*    Dec-1993 andreva changed to support desktops.
\**************************************************************************/

HDC UserGetDesktopDC(
    ULONG type,
    BOOL  bAltType,
    BOOL  bValidate)
{
    PETHREAD    Thread;
    HDC         hdc;
    PTHREADINFO pti = PtiCurrentShared();  // This is called from outside the crit sec
    HDEV        hdev  = gpDispInfo->hDev;

    if (bValidate && type != DCTYPE_INFO &&
        IS_THREAD_RESTRICTED(pti, JOB_OBJECT_UILIMIT_HANDLES)) {

        UserAssert(pti->rpdesk != NULL);

        if (!ValidateHwnd(PtoH(pti->rpdesk->pDeskInfo->spwnd))) {
            RIPMSG0(RIP_WARNING,
                    "UserGetDesktopDC fails desktop window validation");
            return NULL;
        }
    }

    /*
     * NOTE:
     * This is a real nasty trick to get both DCs created on a desktop on
     * a different device to work (for the video applet) and to be able
     * to clip DCs that are actually on the same device ...
     */
    if (pti && pti->rpdesk)
        hdev = pti->rpdesk->pDispInfo->hDev;

    /*
     * We want to turn this call that was originally OpenDC("Display", ...)
     * into GetDC null call so this DC will be clipped to the current
     * desktop or else the DC can write to any desktop. Only do this
     * for client apps; let the server do whatever it wants.
     */
    Thread = PsGetCurrentThread();
    if ((type != DCTYPE_DIRECT)  ||
        (hdev != gpDispInfo->hDev) ||
        PsIsSystemThread(Thread) ||
        (PsGetThreadProcess(Thread) == gpepCSRSS)) {

        hdc = GreCreateDisplayDC(hdev, type, bAltType);

    } else {

        PDESKTOP pdesk;

        EnterCrit();

        if (pdesk = PtiCurrent()->rpdesk) {

            hdc = _GetDCEx(pdesk->pDeskInfo->spwnd,
                           NULL,
                           DCX_WINDOW | DCX_CACHE | DCX_CREATEDC);
        } else {
            hdc = NULL;
        }

        LeaveCrit();
    }

    return hdc;
}


/**************************************************************************\
* UserThreadCallout
*
*
* Called by the kernel when a thread starts or ends.
*
* Dec-1993 andreva created.
\**************************************************************************/

NTSTATUS UserThreadCallout(
    IN PETHREAD pEThread,
    IN PSW32THREADCALLOUTTYPE CalloutType)
{
    PTHREADINFO pti;
    NTSTATUS    Status = STATUS_SUCCESS;

    UserAssert(gpresUser != NULL);

    switch (CalloutType) {
        case PsW32ThreadCalloutInitialize:
            TRACE_INIT(("Entering UserThreadCallout PsW32ThreadCalloutInitialize\n"));

            if (gbNoMorePowerCallouts) {
                RIPMSG0(RIP_WARNING, "No more GUI threads allowed");
                return STATUS_UNSUCCESSFUL;
            }

            /*
             * Only create a thread info structure if we're initialized.
             */
            if (gbUserInitialized) {
                EnterCrit();
                UserAssert(gpepCSRSS != NULL);

                /*
                 * Initialize this thread
                 */
                Status = xxxCreateThreadInfo(pEThread, FALSE);

                LeaveCrit();
            }
            break;

        case PsW32ThreadCalloutExit:

            TRACE_INIT(("Entering UserThreadCallout PsW32ThreadCalloutExit\n"));

            /*
             * If we aren't already inside the critical section, enter it.
             * Because this is the first pass, we remain in the critical
             * section when we return so that our try/finally handlers
             * are protected by the critical section.
             * EnterCrit here before GreUnlockDisplay() provides a pti which
             * may be required if unlocking the display may release some
             * deferred WinEvents, for which a pti is required.
             */
            EnterCrit();

            pti = (PTHREADINFO)PsGetThreadWin32Thread(pEThread);

            /*
             * Mark this thread as in the middle of cleanup. This is useful for
             * several problems in USER where we need to know this information.
             */
            pti->TIF_flags |= TIF_INCLEANUP;

            /*
             * If we died during a full screen switch make sure we cleanup
             * correctly
             */
            FullScreenCleanup();

            /*
             * Cleanup gpDispInfo->hdcScreen - if we crashed while using it,
             * it may have owned objects still selected into it. Cleaning
             * it this way will ensure that gdi doesn't try to delete these
             * objects while they are still selected into this public hdc.
             */

            /*
             * WinStations that haven't gone through the first connect do not
             * have any of the graphics setup.
             */
            if (!gbRemoteSession || gbVideoInitialized) {
                GreCleanDC(gpDispInfo->hdcScreen);
            }

            /*
             * This thread is exiting execution; xxxDestroyThreadInfo cleans
             *  up everything that can go now
             */
            UserAssert(pti == PtiCurrent());
            xxxDestroyThreadInfo();
            LeaveCrit();

            break;
    }

    TRACE_INIT(("Leaving UserThreadCallout\n"));

    return Status;
}

/**************************************************************************\
* NtUserInitialize
*
* 01-Dec-1993 andreva created.
* 01-Dec-1995 BradG   Modified to return handle to Media Change Event
\**************************************************************************/

BOOL TellGdiToGetReady();

NTSTATUS NtUserInitialize(
    IN DWORD   dwVersion,
    IN HANDLE  hPowerRequestEvent,
    IN HANDLE  hMediaRequestEvent)
{
    NTSTATUS Status;

    TRACE_INIT(("Entering NtUserInitialize\n"));

    /*
     * Make sure we're not trying to load this twice.
     */
    if (gpepCSRSS != NULL) {
        RIPMSG0(RIP_WARNING, "Can't initialize more than once");
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Check version number
     */
    if (dwVersion != USERCURRENTVERSION) {
        KeBugCheckEx(WIN32K_INIT_OR_RIT_FAILURE,
                     0,
                     0,
                     dwVersion,
                     USERCURRENTVERSION);
    }

    /*
     * Get the session ID from the EPROCESS structure
     */
    gSessionId = PsGetCurrentProcessSessionId();

    UserAssert(gSessionId == 0 || gbRemoteSession == TRUE);

    /*
     * Initialize the power request list.
     */
    Status = InitializePowerRequestList(hPowerRequestEvent);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    InitializeMediaChange(hMediaRequestEvent);

    /*
     * Save the system process structure.
     */
    gpepCSRSS = PsGetCurrentProcess();
    ObReferenceObject(gpepCSRSS);

    if (!TellGdiToGetReady())
    {
        RIPMSG0(RIP_WARNING, "TellGdiToGetReady failed");
        Status = STATUS_UNSUCCESSFUL;
        return Status;
    }

    /*
     * Allow CSR to read the screen
     */
    ((PW32PROCESS)PsGetProcessWin32Process(gpepCSRSS))->W32PF_Flags |= (W32PF_READSCREENACCESSGRANTED|W32PF_IOWINSTA);


    Status = UserInitialize();

    TRACE_INIT(("Leaving NtUserInitialize\n"));
    return Status;
}

/**************************************************************************\
* NtUserProcessConnect
*
* 01-Dec-1993   Andreva     Created.
\**************************************************************************/

NTSTATUS NtUserProcessConnect(
    IN HANDLE    hProcess,
    IN OUT PVOID pConnectInfo,
    IN ULONG     cbConnectInfo)
{
    PEPROCESS    Process;
    PUSERCONNECT pucConnect = (PUSERCONNECT)pConnectInfo;
    USERCONNECT  ucLocal;
    NTSTATUS     Status = STATUS_SUCCESS;


    TRACE_INIT(("Entering NtUserProcessConnect\n"));

    if (!pucConnect || (cbConnectInfo != sizeof(USERCONNECT))) {
        return STATUS_UNSUCCESSFUL;
    }

    try {
        ProbeForWrite(pucConnect, cbConnectInfo, sizeof(DWORD));

        ucLocal = *pucConnect;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return GetExceptionCode();
    }

    /*
     * Check client/server versions.
     */
    if (ucLocal.ulVersion != USERCURRENTVERSION) {

        RIPMSG2(RIP_ERROR,
            "Client version %lx > server version %lx\n",
            ucLocal.ulVersion, USERCURRENTVERSION);
        return STATUS_UNSUCCESSFUL;
    }



    if (ucLocal.dwDispatchCount != gDispatchTableValues) {
        RIPMSG2(RIP_ERROR,
            "!!!! Client Dispatch info %lX != Server %lX\n",
            ucLocal.dwDispatchCount, gDispatchTableValues);
    }


    /*
     * Reference the process.
     */
    Status = ObReferenceObjectByHandle(hProcess,
                                       PROCESS_VM_OPERATION,
                                       *PsProcessType,
                                       UserMode,
                                       &Process,
                                       NULL);
    if (!NT_SUCCESS(Status))
        return Status;
    /*
     * Return client's view of shared data.
     */
    EnterCrit();
    Status = InitMapSharedSection(Process, &ucLocal);
    LeaveCrit();

    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_WARNING,
              "Failed to map shared data into client %x, status = %x\n",
              GetCurrentProcessId(), Status);
    }

    ObDereferenceObject(Process);

    if (NT_SUCCESS(Status)) {

        try {
             *pucConnect = ucLocal;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            Status = GetExceptionCode();
        }
    }

    TRACE_INIT(("Leaving NtUserProcessConnect\n"));

    return Status;
}

/**************************************************************************\
* xxxUserProcessCallout
*
* 01-Dec-1993   andreva     Created.
\**************************************************************************/

NTSTATUS xxxUserProcessCallout(
    IN PW32PROCESS Process,
    IN BOOLEAN     Initialize)
{
    NTSTATUS     Status = STATUS_SUCCESS;

    if (Initialize) {

        TRACE_INIT(("Entering xxxUserProcessCallout Initialize\n"));

        UserAssert(gpresUser != NULL);
        EnterCrit();

        /*
         * Initialize the important process level stuff.
         */
        Status = xxxInitProcessInfo(Process);

        LeaveCrit();

        if (Status == STATUS_SUCCESS) {

            PEJOB Job = PsGetProcessJob(Process->Process);

            if (Job != NULL &&
                PsGetJobUIRestrictionsClass(Job) != 0) {

                WIN32_JOBCALLOUT_PARAMETERS Parms;

                /*
                 * aquire the job's lock and after that enter the user
                 * critical section.
                 */
                KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite(PsGetJobLock(Job), TRUE);

                Parms.Job = Job;
                Parms.CalloutType = PsW32JobCalloutAddProcess;
                Parms.Data = Process;

                UserAssert(PsGetJobSessionId(Job) == PsGetProcessSessionId(Process->Process));

                UserJobCallout(&Parms);

                ExReleaseResourceLite(PsGetJobLock(Job));
                KeLeaveCriticalRegion();
            }
        }
    } else {

        int  i;
        PHE  phe;
        PDCE *ppdce;
        PDCE pdce;

        TRACE_INIT(("Entering xxxUserProcessCallout Cleanup\n"));

        UserAssert(gpresUser != NULL);

        EnterCrit();

#if DBG
        if (Process->Process == gpepCSRSS) {

            /*
             * CSRSS should be the last to go ...
             */
            UserAssert(gppiList->ppiNextRunning == NULL);
        }
#endif // DBG

        if (Process->Process && PsGetProcessJob(Process->Process) != NULL) {
            RemoveProcessFromJob((PPROCESSINFO)Process);
        }

        /*
         * DestroyProcessInfo will return TRUE if any threads ever
         * connected. If nothing ever connected, we needn't do
         * this cleanup.
         */
        if (DestroyProcessInfo(Process)) {

            /*
             * See if we can compact the handle table.
             */
            i = giheLast;
            phe = &gSharedInfo.aheList[giheLast];
            while ((phe > &gSharedInfo.aheList[0]) && (phe->bType == TYPE_FREE)) {
                phe--;
                giheLast--;
            }

            /*
             * Scan the DC cache to find any DC's that need to be destroyed.
             */
            for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL; ) {

                pdce = *ppdce;
                if (pdce->DCX_flags & DCX_DESTROYTHIS)
                    DestroyCacheDC(ppdce, pdce->hdc);

                /*
                 * Step to the next DC. If the DC was deleted, there
                 * is no need to calculate the address of the next entry.
                 */
                if (pdce == *ppdce)
                    ppdce = &pdce->pdceNext;
            }
        }

        UserAssert(gpresUser != NULL);

        LeaveCrit();
    }

    TRACE_INIT(("Leaving xxxUserProcessCallout\n"));

    return Status;
}

/**************************************************************************\
* UserGetHDEV
*
* Provided as a means for GDI to get a hold of USER's hDev.
*
* 01-Jan-1996   ChrisWil    Created.
\**************************************************************************/

HDEV UserGetHDEV(VOID)
{

    /*
     *  NOTE: This is busted.
     *        This need to return the device for the current desktop.
     *        The graphics device may not be the same for all desktops.
     *        -Andre
     */
    return gpDispInfo->hDev;
}

/**************************************************************************\
* _UserGetGlobalAtomTable
*
* This function is called by the kernel mode global atom manager to get the
* address of the current thread's global atom table.
*
* Pointer to the global atom table for the current thread or NULL if unable
* to access it.
\**************************************************************************/
PVOID UserGlobalAtomTableCallout(
    VOID)
{
    PETHREAD       Thread;
    PTHREADINFO    pti;
    PWINDOWSTATION pwinsta;
    PW32JOB        pW32Job;
    PEJOB          Job;
    PVOID          GlobalAtomTable = NULL;

    Thread = PsGetCurrentThread();
    pti = PtiFromThread(Thread);

    EnterCrit();

    /*
     * For restricted threads access the atom table off of the job object
     */
    if (pti != NULL && IS_THREAD_RESTRICTED(pti, JOB_OBJECT_UILIMIT_GLOBALATOMS)) {
        TAGMSG1(DBGTAG_Callout, "Retrieving global atom table for pti 0x%p", pti);

        pW32Job = pti->ppi->pW32Job;

        UserAssert(pW32Job->pAtomTable != NULL);
        GlobalAtomTable = pW32Job->pAtomTable;

        goto End;
    }

    Job = PsGetProcessJob(PsGetCurrentProcess());

    /*
     * Now handle the case where this is not a GUI thread/process
     * but it is assigned to a job that has JOB_OBJECT_UILIMIT_GLOBALATOMS
     * restrictions set. There is no easy way to convert this thread
     * to GUI.
     */
    if (pti == NULL && Job != NULL &&
        (PsGetJobUIRestrictionsClass(Job) & JOB_OBJECT_UILIMIT_GLOBALATOMS)) {

        /*
         * find the W32JOB in the global list
         */
        pW32Job = gpJobsList;

        while (pW32Job) {
            if (pW32Job->Job == Job) {
                break;
            }
            pW32Job = pW32Job->pNext;
        }

        UserAssert(pW32Job != NULL && pW32Job->pAtomTable != NULL);

        GlobalAtomTable = pW32Job->pAtomTable;

        goto End;
    }

#if DBG
    pwinsta = NULL;
#endif

    if (NT_SUCCESS(ReferenceWindowStation(Thread,
                                    PsGetCurrentProcessWin32WindowStation(),
                                    WINSTA_ACCESSGLOBALATOMS,
                                    &pwinsta,
                                    TRUE))) {
        UserAssert(pwinsta != NULL);

        GlobalAtomTable = pwinsta->pGlobalAtomTable;
    }

End:
    LeaveCrit();

#if DBG
    if (GlobalAtomTable == NULL) {
        RIPMSG1(RIP_WARNING,
                "_UserGetGlobalAtomTable: NULL Atom Table for pwinsta=%#p",
                pwinsta);
    }
#endif

    return GlobalAtomTable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\sirens.c ===
/****************************** Module Header ******************************\
* Module Name: sirens.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the functions used by the Access Pack features to
* provide audible feedback.
*
* History:
*   4 Feb 93 Gregoryw   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define TONE_HIGH_FREQ 2000   // High tone frequency (Hz)
#define TONE_HIGH_LEN 75      // High tone duration (ms)
#define TONE_LOW_FREQ 500     // Low tone frequency (Hz)
#define TONE_LOW_LEN 75       // Low tone duration (ms)
#define TONE_CLICK_FREQ 400   // Key click tone frequency (Hz)
#define TONE_CLICK_LEN 4      // Key click tone duration (ms)
#define TONE_SILENT 10
#define SIREN_LOW_FREQ 1200   // Lowest freq for siren (Hz)
#define SIREN_HIGH_FREQ 2000  // Highest freq for siren (Hz)
#define SIREN_INTERVAL 100    // +/- interval SIREN_LOW_FREQ <-> SIREN_HIGH_FREQ

/***************************************************************************\
* HighBeep
*
* Send a high beep to the beep device
*
* History:
\***************************************************************************/

BOOL HighBeep(void)
{
    BOOL Status;

    LeaveCrit();
    Status = UserBeep(TONE_HIGH_FREQ, TONE_HIGH_LEN);
    EnterCrit();
    return Status;
}

/***************************************************************************\
* LowBeep
*
* Send a low beep to the beep device
*
* History:
\***************************************************************************/

BOOL LowBeep(void)
{
    BOOL Status;

    LeaveCrit();
    Status = UserBeep(TONE_LOW_FREQ, TONE_LOW_LEN);
    EnterCrit();
    return Status;
}

/***************************************************************************\
* KeyClick
*
* Send a key click to the beep device
*
* History:
\***************************************************************************/

BOOL KeyClick(void)
{
    BOOL Status;

    LeaveCrit();
    Status = UserBeep(TONE_CLICK_FREQ, TONE_CLICK_LEN);
    EnterCrit();
    return Status;
}

/***************************************************************************\
* UpSiren
*
* Generate an up-siren tone.
*
* History:
\***************************************************************************/

BOOL UpSiren(void)
{
    DWORD freq;
    BOOL BeepStatus = TRUE;

    LeaveCrit();
    for (freq = SIREN_LOW_FREQ;
        BeepStatus && freq <= SIREN_HIGH_FREQ;
            freq += SIREN_INTERVAL) {
        BeepStatus = UserBeep(freq, (DWORD)1);
    }
    EnterCrit();
    return BeepStatus;
}

/***************************************************************************\
* DownSiren
*
* Generate a down-siren tone.
*
* History:
\***************************************************************************/

BOOL DownSiren(void)
{
    DWORD freq;
    BOOL BeepStatus = TRUE;

    LeaveCrit();

    for (freq = SIREN_HIGH_FREQ;
        BeepStatus && freq >= SIREN_LOW_FREQ;
            freq -= SIREN_INTERVAL) {
        BeepStatus = UserBeep(freq, (DWORD)1);
    }
    EnterCrit();
    return BeepStatus;
}

BOOL DoBeep(BEEPPROC BeepProc, UINT Count)
{
    while (Count--) {
        (*BeepProc)();
        UserSleep(100);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\showwin.c ===
/****************************** Module Header ******************************\
* Module Name: showwin.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains the xxxShowWindow API and related functions.
*
* History:
* 10-20-90 darrinm      Created.
* 02-04-91 IanJa        Window handle revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _ShowWindowAsync
*
* This queues a show window event in another thread's queue. Used mainly from
* within taskmgr, so that taskmgr doesn't hang waiting on hung apps.
*
* 04-23-93 ScottLu      Created.
\***************************************************************************/

BOOL _ShowWindowAsync(PWND pwnd, int cmdShow, UINT uWPFlags)
{

    return PostEventMessage(
            GETPTI(pwnd),
            GETPTI(pwnd)->pq,
            QEVENT_SHOWWINDOW,
            NULL,
            uWPFlags,
            (WPARAM)HWq(pwnd),
            cmdShow | TEST_PUDF(PUDF_ANIMATE));
}

/***************************************************************************\
* xxxShowWindow (API)
*
* This function changes the "state" of a window based upon the cmdShow
* parameter.  The action taken is:
*
* SW_HIDE             0  Hide the window and pass avtivation to someone else
*
* SW_SHOWNORMAL       1  Show a window in its most recent "normal"
* SW_RESTORE             size and position.  This will "restore" a iconic
*                        or zoomed window.  This is compatible with 1.03
*                        SHOW_OPENWINDOW.  This will also activate the window.
*
* SW_SHOWMINIMIZED    2  Show the window as iconic and make it active.
*
* SW_SHOWMAXIMIZED    3  Show the window as maximized and make it active.
*
* SW_SHOWNOACTIVATE   4  Same as SW_SHOWNORMAL except that it doesn't change
*                        the activation (currently active window stays active).
*
* All the above are compatible with 1.03 ShowWindow parameters.  Now here are
* the new ones:
*
* SW_SHOW             5  Show the window in its current state (iconic, etc.)
*                        That is, if the window is iconic when hidden, it will
*                        still be iconic. This will activate the window.
*                        (This is one we don't have today)
*
* SW_MINIMIZE         6  minimize the window, activate the toplevel open window
*
* SW_SHOWMINNOACTIVE  7  show the icon, don't change activation.
*
* SW_SHOWNA           8  Same as SW_SHOW except that it doesn't change
*                        the activation.
*
* SW_SHOWDEFAULT      10 Use value obtained from STARTUPINFO.
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
* 04-16-91 JimA         Added SW_SHOWDEFAULT support.
\***************************************************************************/

/*
 * cmdShow now has fAnimate as the lower bit in the upper word.  This puts it in the
 * MINMAX_ANIMATE position for calling MinMaximize.
 */

BOOL xxxShowWindow(
    PWND pwnd,
    DWORD cmdShowAnimate)
{
    BOOL fVisOld, fVisNew;
    UINT swpFlags = SWP_NOMOVE | SWP_NOSIZE;
    PTHREADINFO pti;
    BOOL bFirstMain = FALSE;
    int cmdShow = LOWORD(cmdShowAnimate);

    CheckLock(pwnd);

    fVisOld = TestWF(pwnd, WFVISIBLE);
    pti = PtiCurrent();

    /*
     * See if this is the first "main" top level
     * window being created by this application - if show, assume it
     * is showing with the SW_SHOWDEFAULT command.
     *
     * Checks for:
     * - cmdShow is a "default" show command
     * - we haven't done startupinfo yet (we only use it once)
     * - this is not a child (it is a top level window)
     * - this has a titlebar (indicator of the main window)
     * - it isn't owned (indicator of the main window)
     */
    if ((pti->ppi->usi.dwFlags & STARTF_USESHOWWINDOW) &&
            !TestwndChild(pwnd) &&
            (TestWF(pwnd, WFBORDERMASK) == (BYTE)LOBYTE(WFCAPTION)) &&
            (pwnd->spwndOwner == NULL)) {

        bFirstMain = TRUE;

        switch (cmdShow) {
        case SW_SHOWNORMAL:
        case SW_SHOW:

            /*
             * Then assume default!
             */
            cmdShow = SW_SHOWDEFAULT;
            break;
        }
    }

    /*
     * If this application specified SW_SHOWDEFAULT, then we get the
     * real SW_* command from the application's STARTUPINFO structure
     * (STARTUPINFO is passed to CreateProcess() when this application
     * was launched).
     */
    if (cmdShow == SW_SHOWDEFAULT) {

        /*
         * Call the client to get the SW_* command from the STARTUPINFO
         * for this process.
         */
        if (pti->ppi->usi.dwFlags & STARTF_USESHOWWINDOW) {

            bFirstMain = TRUE;

            cmdShow = pti->ppi->usi.wShowWindow;

            /*
             * The following code was removed in 3.51
             *
             * switch (cmdShow) {
             * case SW_SHOWMINIMIZED:
             * case SW_MINIMIZE:
             *
             *      *
             *      * If the default show was "minimized", then make sure it doesn't
             *      * become active.  Minimized is effectively "background".
             *      *
             *     cmdShow = SW_SHOWMINNOACTIVE;
             *     break;
             * }
             *
             */
        }
    }


    /*
     * This is in case someone said SW_SHOWDEFAULT but has no startupinfo.
     * Or in case cmdShow inside of STARTUPINFO is SW_SHOWDEFAULT.
     */
    if (cmdShow == SW_SHOWDEFAULT)
        cmdShow = SW_SHOWNORMAL;

    /*
     * Turn off startup info.  We turn this off after the first call to
     * ShowWindow.  If we don't apps can be started by progman with
     * the start info being minimized and then be restored and then
     * call ShowWindow(SW_SHOW) and the app would minimize again.
     * Notepad had that problem 2985.
     */
    if (bFirstMain) {
        pti->ppi->usi.dwFlags &=
                ~(STARTF_USESHOWWINDOW | STARTF_USESIZE | STARTF_USEPOSITION);
    }


    /*
     * Take care of all the OLD show commands with columns & iconslot.
     */
    if (cmdShow & 0xFF00) {
        if ((cmdShow & 0xFF80) == (int)0xFF80)
            cmdShow = SW_SHOWMINNOACTIVE;
        else
            cmdShow = SW_SHOW;
    }

    /*
     * Change to new fullscreen if needed and in same desktop
     */
    if ((GetFullScreen(pwnd) != WINDOWED)
            && (pwnd->head.rpdesk == grpdeskRitInput)) {
        if ((cmdShow == SW_SHOWNORMAL) ||
            (cmdShow == SW_RESTORE) ||
            (cmdShow == SW_MAXIMIZE) ||
            (cmdShow == SW_SHOWMAXIMIZED)) {
            cmdShow = SW_SHOWMINIMIZED;

            if (GetFullScreen(pwnd) == FULLSCREENMIN) {
                SetFullScreen(pwnd, FULLSCREEN);
            }

            if (gpqForeground != NULL &&
                gpqForeground->spwndActive == pwnd) {
                xxxMakeWindowForegroundWithState(NULL, 0);
            }
        }
    }

    switch (cmdShow) {
    case SW_SHOWNOACTIVATE:
    case SW_SHOWNORMAL:
    case SW_RESTORE:

        /*
         * If min/max, let xxxMinMaximize() do all the work.
         */
        if (TestWF(pwnd, WFMINIMIZED) || TestWF(pwnd, WFMAXIMIZED)) {
            xxxMinMaximize(pwnd, (UINT)cmdShow, cmdShowAnimate & MINMAX_ANIMATE);
            return fVisOld;

        } else {

            /*
             * Ignore if the window is already visible.
             */
            if (fVisOld) {
                return fVisOld;
            }

            swpFlags |= SWP_SHOWWINDOW;
            if (   cmdShow == SW_SHOWNOACTIVATE) {
                swpFlags |= SWP_NOZORDER;
#ifdef NEVER
                /*
                 * This is what win3.1 does. On NT, since each "queue" has
                 * its own active window, there is often no active window.
                 * In this case, win3.1 turns a SHOWNOACTIVATE into a "SHOW
                 * with activate". Since win3.1 almost always has an active
                 * window, this almost never happens. So on NT, we're not
                 * going to do this check - that way we'll be more compatible
                 * with win3.1 because we'll usally not activate (like win3.1).
                 * With this check, this causes FoxPro 2.5 for Windows to not
                 * properly activate its command window when first coming up.
                 */
                if (pti->pq->spwndActive != NULL)
                    swpFlags |= SWP_NOACTIVATE;
#else
                swpFlags |= SWP_NOACTIVATE;
#endif
            }
        }
        break;

    case SW_FORCEMINIMIZE:
        xxxMinimizeHungWindow(pwnd);
        return fVisOld;

    case SW_SHOWMINNOACTIVE:
    case SW_SHOWMINIMIZED:
    case SW_SHOWMAXIMIZED:
    case SW_MINIMIZE:
        xxxMinMaximize(pwnd, (UINT)cmdShow, cmdShowAnimate & MINMAX_ANIMATE);
        return fVisOld;

    case SW_SHOWNA:
        swpFlags |= SWP_SHOWWINDOW | SWP_NOACTIVATE;


        /*
         * LATER removed this to be compatible with SHOWNOACTIVATE
         * if (pti->pq->spwndActive != NULL)
         *     swpFlags |= SWP_NOACTIVATE;
         */
        break;

    case SW_SHOW:

        /*
         * Don't bother if it is already visible.
         */
        if (fVisOld)
            return fVisOld;

        swpFlags |= SWP_SHOWWINDOW;
        UserAssert(cmdShow != SW_SHOWNOACTIVATE);
        break;

    case SW_HIDE:

        /*
         * Don't bother if it is already hidden.
         */
        if (!fVisOld)
            return fVisOld;

        swpFlags |= SWP_HIDEWINDOW;
        if (pwnd != pti->pq->spwndActive)
            swpFlags |= (SWP_NOACTIVATE | SWP_NOZORDER);
        break;

    default:
        RIPERR0(ERROR_INVALID_SHOWWIN_COMMAND, RIP_VERBOSE, "");
        return fVisOld;
    }

    /*
     * If we're changing from visible to hidden or vise-versa, send
     * WM_SHOWWINDOW.
     */
    fVisNew = !(cmdShow == SW_HIDE);
    if (fVisNew != fVisOld) {
        xxxSendMessage(pwnd, WM_SHOWWINDOW, fVisNew, 0L);
        if (!TestWF(pwnd, WFWIN31COMPAT)) {
            xxxSendMessage(pwnd, WM_SETVISIBLE, fVisNew, 0L);
        }
    }

    if (!TestwndChild(pwnd)) {
        if (TestCF(pwnd, CFSAVEBITS)) {

            /*
             * Activate to prevent discarding saved bits???
             */
            if (cmdShow == SW_SHOW || cmdShow == SW_SHOWNORMAL) {
                xxxActivateWindow(pwnd, AW_USE);
                swpFlags |= SWP_NOZORDER | SWP_NOACTIVATE;
            }
        }
    } else {

        /*
         * Children can't get activation...
         */
        swpFlags |= (SWP_NOACTIVATE | SWP_NOZORDER);
    }

    /*
     * If our parent is hidden, don't bother to call xxxSetWindowPos.
     */
    if (_FChildVisible(pwnd)) {
        xxxSetWindowPos(pwnd, (PWND)NULL, 0, 0, 0, 0, swpFlags);
    } else {
        if (cmdShow == SW_HIDE) {
            SetVisible(pwnd, SV_UNSET);
            ClrWF(pwnd, WEFGHOSTMAKEVISIBLE);
        }    
        else {
            SetVisible(pwnd, SV_SET);
            SetWF(pwnd, WEFGHOSTMAKEVISIBLE);
        }     
    }

    /*
     * Send size and move messages AFTER repainting
     */
    if (TestWF(pwnd, WFSENDSIZEMOVE)) {
        ClrWF(pwnd, WFSENDSIZEMOVE);
        if (TestWF(pwnd, WFMINIMIZED)) {
            xxxSendSizeMessage(pwnd, SIZE_MINIMIZED);
        } else if (TestWF(pwnd, WFMAXIMIZED)) {
            xxxSendSizeMessage(pwnd, SIZE_MAXIMIZED);
        } else {
            xxxSendSizeMessage(pwnd, SIZE_RESTORED);
        }

        xxxSendMessage(pwnd, WM_MOVE, 0,
                (pwnd->spwndParent == PWNDDESKTOP(pwnd)) ?
                MAKELONG(pwnd->rcClient.left, pwnd->rcClient.top) :
                MAKELONG(
                    pwnd->rcClient.left - pwnd->spwndParent->rcClient.left,
                    pwnd->rcClient.top - pwnd->spwndParent->rcClient. top));
    }

    /*
     * If hiding and is active-foreground window, activate someone else.
     * If hiding a active window make someone active.
     */
    if (cmdShow == SW_HIDE) {
        if ((pwnd == pti->pq->spwndActive) && (pti->pq == gpqForeground)) {
            xxxActivateWindow(pwnd, AW_SKIP);
        } else {
            xxxCheckFocus(pwnd);
        }
    }

    return fVisOld;
}

/***************************************************************************\
* xxxShowOwnedWindows
*
* xxxShowOwnedWindows is used to hide or show associated popups for the
* following reasons:
*
*     1. Window going iconic
*     2. Popup window being hidden
*     3. Iconic window being opened
*     4. Popup window being shown
*     5. Window being zoomed or unzoomed
*
* For cases 1 and 2, all popups associated with that window are hidden,
* and the WFHIDDENPOPUP bit is set.  This bit is used to differentiate
* between windows hidded by xxxShowOwnedWindows and those hidden by the
* application.
*
* For cases 3 and 4, all popups associated with that window that have the
* WFHIDDENPOPUP bit set are shown.
*
* For case 5, all popups associated with any window BUT the supplied
* window are hidden or shown.  In this case as well, the SW_OTHERZOOM
* or SW_OTHERUNZOOM message is send to all tiled windows to notify them
* that they are being covered or uncovered by the zoomed window.
*
* In all cases, the WM_SHOWWINDOW message is sent to the window to hide or
* show it.
*
* This routine works by simply enumerating all popup windows checking to see
* if the owner of the popup matches the pwndOwner parameter, and taking the
* appropriate action.
*
* We will eventually want 3 separate hide bits: one each for other zoom/unzoom,
* owner iconic/open, owner hide/show.  Right now, there is only one bit, so
* we show windows sometimes when we shouldn't
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

void xxxShowOwnedWindows(
    PWND pwndOwner,
    UINT cmdShow,
    HRGN hrgnHung)
{
    BOOL fShow;
    int cmdZoom;
    HWND *phwnd;
    PBWL pbwl;
    PWND pwnd, pwndTopOwner;
    TL tlpwnd;

    CheckLock(pwndOwner);

    /*
     * Not interested in child windows
     */
    if (TestwndChild(pwndOwner))
        return;

    if ((pbwl = BuildHwndList(PWNDDESKTOP(pwndOwner)->spwndChild, BWL_ENUMLIST, NULL)) == NULL)
        return;

    /*
     * NOTE: The following code assumes the values of SW_* are 1, 2, 3, and 4
     */
    fShow = (cmdShow >= SW_PARENTOPENING);

    cmdZoom = 0;
    if (cmdShow == SW_OTHERZOOM)
        cmdZoom = SIZEZOOMHIDE;

    if (cmdShow == SW_OTHERUNZOOM)
        cmdZoom = SIZEZOOMSHOW;

    /*
     * If zoom/unzoom, then open/close all popups owned by all other
     * windows.  Otherwise, open/close popups owned by pwndOwner.
     */
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Lock the window before we play with it.
         * If the window handle is invalid, skip it
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        /*
         * Kanji windows can't be owned, so skip it.
         */
        if (TestCF(pwnd, CFKANJIWINDOW))
            continue;

        /*
         * If same as window passed in, skip it.
         */
        if (pwnd == pwndOwner)
            continue;

        /*
         * Find ultimate owner of popup, but only go up as far as pwndOwner.
         */
        if ((pwndTopOwner = pwnd->spwndOwner) != NULL) {

            /*
             * The TestwndHI is needed since if it has an icon, pwndOwner
             * is invalid.
             */
            while (!TestwndHI(pwndTopOwner) && pwndTopOwner != pwndOwner &&
                    pwndTopOwner->spwndOwner != NULL)
                pwndTopOwner = pwndTopOwner->spwndOwner;
        }

        /*
         * Zoom/Unzoom case.
         */
        if (cmdZoom != 0) {

            /*
             * If no parent, or parents are the same, skip.
             */
            if (pwndTopOwner == NULL || pwndTopOwner == pwndOwner)
                continue;

            /*
             * If owner is iconic, then this window should stay hidden,
             * UNLESS the minimized window is disabled, in which case we'd
             * better show the window.
             */
            if (   cmdShow == SW_OTHERUNZOOM
                && pwndTopOwner != NULL
                && TestWF(pwndTopOwner, WFMINIMIZED)
                && !TestWF(pwndTopOwner, WFDISABLED)
               )
                continue;
        } else {
            /*
             * Hide/Iconize/Show/Open case.
             */
            /*
             * If parents aren't the same, skip.
             */
            if (pwndTopOwner != pwndOwner)
                continue;
        }

        /*
         * Hide or show if:
         * Showing & this is a hidden popup
         *   OR
         * Hiding & this is a visible window
         */
        if ((fShow && TestWF(pwnd, WFHIDDENPOPUP)) ||
                (!fShow && TestWF(pwnd, WFVISIBLE))) {
            /*
             * For hung minimization, just set the HIDDENPOPUP bit, clear
             * the visible bit and add the window rect to the region to
             * be repainted.
             */
            if (hrgnHung != NULL) {
                HRGN hrgn = GreCreateRectRgnIndirect(&pwnd->rcWindow);
                UnionRgn(hrgnHung, hrgnHung, hrgn);
                GreDeleteObject(hrgn);

                UserAssert(!fShow);

                SetWF(pwnd, WFHIDDENPOPUP);
                SetVisible(pwnd, SV_UNSET);
            } else {
                ThreadLockAlways(pwnd, &tlpwnd);
                xxxSendMessage(pwnd, WM_SHOWWINDOW, fShow, (LONG)cmdShow);
                ThreadUnlock(&tlpwnd);
            }
        }
    }

    /*
     * Free the window list.
     */
    FreeHwndList(pbwl);
}


/***************************************************************************\
* xxxShowOwnedPopups (API)
*
* This routine is accessable to the user.  It will either show or
* hide all popup windows owned by the window handle specified.  If
* fShow if TRUE, all hidden popups will be shown.  If it is FALSE, all
* visible popups will be hidden.
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

BOOL xxxShowOwnedPopups(
    PWND pwndOwner,
    BOOL fShow)
{
    CheckLock(pwndOwner);

    xxxShowOwnedWindows(pwndOwner,
            (UINT)(fShow ? SW_PARENTOPENING : SW_PARENTCLOSING), NULL);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\shadow.c ===
/****************************** Module Header ******************************\
* Module Name: shadow.c
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Drop shadow support.
*
* History:
* 04/12/2000      vadimg      created
* 02/12/2001      msadek      added rounded rectangular shadow support 
*                             for rectangular windows
* 05/08/2001      msadek      rewrote the non rounded corners shadow algorithm
*                             to work well with regional windows, correct visuall effect.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

// shadow horizontal and veritcal offsets
#define CX_SHADOW 5
#define CY_SHADOW 5
#define C_SHADOW CX_SHADOW

// black as the shadow color
#define RGBA_SHADOW 0x00FFFFFF
// white as the transparent color
#define RGBA_TRANSPARENT 0x00000000

typedef struct tagSHADOW *PSHADOW;
typedef struct tagSHADOW {
    PWND pwnd;              // window we're shadowing
    PWND pwndShadow;        // the shadow window we create
    PSHADOW pshadowNext;    // link to the next shadow struct
} SHADOW;

PSHADOW gpshadowFirst;

// Macro used to map gray scale shadow values to alpha blending scale.
#define ALPHA(x) ((255 - (x)) << 24)
#define ARGB(a, r, g, b) (((DWORD)a<<24)|((DWORD)r<<16)|((DWORD)g<<8)|b)

// Gray scale values for the shadow grades
#define GS01 255
#define GS02 254
#define GS03 253
#define GS04 252
#define GS05 250
#define GS06 246
#define GS07 245
#define GS08 242
#define GS09 241
#define GS10 227
#define GS11 217
#define GS12 213
#define GS13 212
#define GS14 199
#define GS15 180 
#define GS16 172 
#define GS17 171
#define GS18 155
#define GS19 144
#define GS20 142

// pre-computed alpha values for the shadow
CONST BYTE grgShadow[C_SHADOW] =             {
                                             GS04, GS09, GS13, GS17, GS20,
                                             };

CONST ULONG TopRightLTR [CY_SHADOW][CX_SHADOW] = {
                                             ALPHA(GS08), ALPHA(GS06), ALPHA(GS05), ALPHA(GS03), ALPHA(GS02), 
                                             ALPHA(GS11), ALPHA(GS10), ALPHA(GS09), ALPHA(GS05), ALPHA(GS02), 
                                             ALPHA(GS15), ALPHA(GS14), ALPHA(GS10), ALPHA(GS07), ALPHA(GS03), 
                                             ALPHA(GS18), ALPHA(GS15), ALPHA(GS11), ALPHA(GS08), ALPHA(GS03), 
                                             ALPHA(GS19), ALPHA(GS16), ALPHA(GS12), ALPHA(GS09), ALPHA(GS04),
                                             };

CONST ULONG RightLTR [CX_SHADOW] =           {
                                             ALPHA(GS20), ALPHA(GS17), ALPHA(GS13), ALPHA(GS09), ALPHA(GS04), 
                                             };

CONST ULONG BottomRightLTR [CY_SHADOW][CX_SHADOW] = {
                                             ALPHA(GS18), ALPHA(GS15), ALPHA(GS11), ALPHA(GS08), ALPHA(GS03), 
                                             ALPHA(GS15), ALPHA(GS14), ALPHA(GS10), ALPHA(GS07), ALPHA(GS03),
                                             ALPHA(GS11), ALPHA(GS10), ALPHA(GS09), ALPHA(GS05), ALPHA(GS02),
                                             ALPHA(GS08), ALPHA(GS06), ALPHA(GS05), ALPHA(GS03), ALPHA(GS02), 
                                             ALPHA(GS03), ALPHA(GS03), ALPHA(GS02), ALPHA(GS02), ALPHA(GS01),
                                             };

CONST ULONG Bottom [CY_SHADOW] =             {
                                             ALPHA(GS20), ALPHA(GS17), ALPHA(GS13), ALPHA(GS09), ALPHA(GS04),     
                                             };

CONST ULONG BottomLeftLTR [CY_SHADOW][CX_SHADOW] = {
                                             ALPHA(GS08), ALPHA(GS11), ALPHA(GS15), ALPHA(GS18), ALPHA(GS19), 
                                             ALPHA(GS06), ALPHA(GS10), ALPHA(GS14), ALPHA(GS15), ALPHA(GS16),
                                             ALPHA(GS05), ALPHA(GS09), ALPHA(GS10), ALPHA(GS11), ALPHA(GS12),
                                             ALPHA(GS03), ALPHA(GS05), ALPHA(GS07), ALPHA(GS08), ALPHA(GS09),
                                             ALPHA(GS02), ALPHA(GS02), ALPHA(GS03), ALPHA(GS03), ALPHA(GS04),
                                             };
/***************************************************************************\
* DrawWindowShadow
*
\***************************************************************************/

BOOL DrawWindowShadow(PWND pwnd, HDC hdc, BOOL fRTL, BOOL fForceComplexRgn, PBOOL pfSimpleRgn)
{
    HRGN hrgn1, hrgn2;
    RECT rc;
    HBRUSH hBrushShadow;
    BOOL bRet = FALSE;

    UserAssert(pfSimpleRgn != NULL);
        
    hrgn1 = GreCreateRectRgn(0, 0, 0, 0);
    hrgn2 = GreCreateRectRgn(0, 0, 0, 0);

    if (hrgn1 == NULL || hrgn2 == NULL) {
        goto Cleanup;
    }

    /*
     * Handle the case when the window is a rectangle or a regional window.
     */
    if (pwnd->hrgnClip == NULL || TestWF(pwnd, WFMAXFAKEREGIONAL)) {
        rc = pwnd->rcWindow;
        OffsetRect(&rc, -rc.left, -rc.top);
        GreSetRectRgn(hrgn1, 0, 0, rc.right, rc.bottom);
        *pfSimpleRgn = TRUE;
    } else {
        GreCombineRgn(hrgn1, pwnd->hrgnClip, NULL, RGN_COPY);
        GreOffsetRgn(hrgn1, -pwnd->rcWindow.left, -pwnd->rcWindow.top);
        *pfSimpleRgn = FALSE;
    }

    /*
     * Offset the window by the shadow offsets and fill the difference
     * with the shadow color. The result will be window's shadow.
     */
    GreCombineRgn(hrgn2, hrgn1, NULL, RGN_COPY);
    if (fRTL) {
        GreOffsetRgn(hrgn1, CX_SHADOW, 0);
        GreOffsetRgn(hrgn2, 0, CY_SHADOW);
    } else {
        GreOffsetRgn(hrgn2, CX_SHADOW, CY_SHADOW);
    }
    bRet = TRUE;
    
    if (!*pfSimpleRgn || fForceComplexRgn) {
        int i;
        BYTE gs;

        for (i = C_SHADOW ; i > 0; i--) {
            gs = grgShadow[i - 1]; 
            hBrushShadow = GreCreateSolidBrush(RGB(gs , gs , gs));
            if (hBrushShadow == NULL) {
                bRet = FALSE;
                goto Cleanup;
            }
            NtGdiFrameRgn(hdc, hrgn2, hBrushShadow, i, i);
            GreDeleteObject(hBrushShadow);
        }
        GreFillRgn(hdc, hrgn1, (HBRUSH)GreGetStockObject(BLACK_BRUSH));
    } else {
        GreCombineRgn(hrgn2, hrgn2, hrgn1, RGN_DIFF);
        GreFillRgn(hdc, hrgn2, (HBRUSH)GreGetStockObject(WHITE_BRUSH));
        }

Cleanup:
    GreDeleteObject(hrgn1);
    GreDeleteObject(hrgn2);
    return bRet;
}

/***************************************************************************\
* DrawTopLogicallyRightCorner
*
* Draw the shadow effect of the top, logically right (visually right for LTR, left for RTL window layout)
* corner of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawTopLogicallyRightCorner(VOID* pBits, LONG cx, LONG cy, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i = CY_SHADOW; i < (2 * CY_SHADOW); i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((cy - i - 1) * cx) + j;
                *ppixel = TopRightLTR[i - CY_SHADOW][CX_SHADOW - 1 - j];                
            }
        }
    }
    else {
        for (i = CY_SHADOW; i < (2 * CY_SHADOW); i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((cy - i) * cx) - CX_SHADOW + j;
                *ppixel = TopRightLTR[i - CY_SHADOW][j];
            }
        }
    }
}

/***************************************************************************\
* DrawLogicallyRightSide
*
* Draw the shadow effect of the logically right (visually right for LTR, left for RTL window layout)
* side of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawLogicallyRightSide(VOID* pBits, LONG cx, LONG cy, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i =  (2 * CY_SHADOW); i < (cy - CY_SHADOW); i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                ppixel = (ULONG*)pBits + (cx * ( cy - i -1)) + j;
                *ppixel = RightLTR[CX_SHADOW - 1 - j];
            }    
        }
    } else {
        for (i = (2 * CY_SHADOW); i < (cy - CY_SHADOW); i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                ppixel = (ULONG*)pBits + (cx * ( cy - i -1)) + (cx - CX_SHADOW) + j;
                *ppixel = RightLTR[j];
            }    
        }
    }
}

/***************************************************************************\
* DrawBottomLogicallyRightCorner
*
* Draw the shadow effect of the bottom logically right (visually right for LTR, left for RTL window layout)
* side of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawBottomLogicallyRightCorner(VOID* pBits, LONG cx, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                ppixel = (ULONG*)pBits + ((CY_SHADOW - i - 1) * cx) + j;
                *ppixel = BottomRightLTR[i][CX_SHADOW - 1 - j];
            }    
        }
    } else {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i) * cx) - CX_SHADOW + j;
                *ppixel = BottomRightLTR[i][j];
            }    
        }
    }
}

/***************************************************************************\
* DrawBottomSide
*
* Draw the shadow effect of the bottom side of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawBottomSide(VOID* pBits, LONG cx, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = CX_SHADOW; j < (cx - (2 * CX_SHADOW)); j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i - 1) * cx) + j;
                *ppixel = Bottom[i];
            }    
        }
    } else {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j =  (2 * CX_SHADOW); j < (cx - CX_SHADOW); j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i - 1) * cx) + j;
                *ppixel = Bottom[i];
            }    
        }
    }
}

/***************************************************************************\
* DrawBottomLogicallyLeftCorner
*
* Draw the shadow effect of the bottom logically left (visually left for LTR, right for RTL window layout)
* side of a rounded rectangular shadow.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawBottomLogicallyLeftCorner(VOID* pBits, LONG cx, BOOL fRTL)
{
    LONG i, j;
    ULONG* ppixel;

    if (fRTL) {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i) * cx) - (2 * CX_SHADOW) + j;
                *ppixel = BottomLeftLTR[i][CX_SHADOW - 1 -j];
            }    
        }
        
    } else {
        for (i = 0; i < CY_SHADOW; i++) {
            for (j = 0; j < CX_SHADOW; j++) {
                 ppixel = (ULONG*)pBits + ((CY_SHADOW - i - 1) * cx) + CX_SHADOW + j;
                *ppixel = BottomLeftLTR[i][j];
            }    
        }
    }
}

/***************************************************************************\
* DrawRoundedRectangularShadow
* Draw a rounded rectangular shadow effect.
* Does not search for shadow pixel location in the bitmap but rather assumes
* it to be the corners of the bitmap.
*
* History:
* 02/12/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawRoundedRectangularShadow(VOID* pBits, LONG cx, LONG cy, BOOL fRTL)
{
    DrawTopLogicallyRightCorner(pBits, cx, cy, fRTL);
    DrawLogicallyRightSide(pBits, cx, cy,  fRTL);
    DrawBottomLogicallyRightCorner(pBits, cx, fRTL);
    DrawBottomSide(pBits, cx, fRTL);
    DrawBottomLogicallyLeftCorner(pBits, cx, fRTL);
}

/***************************************************************************\
* DrawRegionalShadow
* Search for shadow pixel location in the bitmap (those with gray scale in grgShadow
* and adjust the alpha values.
*
*
* History:
* 05/08/2001      Mohamed Sadek [msadek]      created
\***************************************************************************/

_inline void DrawRegionalShadow(VOID* pBits, LONG cx, LONG cy)
{
    LONG i, j, k;
    ULONG* pixel;    
    BYTE gs;

    for (i = 0; i < cy; i++) {
        for (j = 0; j < cx; j++) {
            pixel = (ULONG*)pBits + (cy - 1 - i) * cx + j;
            for (k = 0; k < C_SHADOW; k++) {
                gs = grgShadow[k];
                if (*pixel == ARGB(0, gs, gs, gs)) {
                    *pixel = ALPHA(gs);
                }
            }
        }
    }
}

/***************************************************************************\
* GenerateWindowShadow
*
\***************************************************************************/

HBITMAP GenerateWindowShadow(PWND pwnd, HDC hdc)
{
    BITMAPINFO bmi;
    HBITMAP hbm;
    VOID* pBits;
    LONG cx, cy;
    RECT rc;
    BOOL fRTL = TestWF(pwnd, WEFLAYOUTRTL);
    BOOL fSimpleRgn, fForceComplexRgn = FALSE;

    rc = pwnd->rcWindow;
    OffsetRect(&rc, -rc.left, -rc.top);
    
    /*
     * Doesn't make sense to have a shadow for a window with zero height or width
     */
    if (IsRectEmpty(&rc)) {
        return NULL;
    }

    rc.right += CX_SHADOW;
    rc.bottom += CY_SHADOW;

    cx = rc.right;
    cy = rc.bottom;

    /*
     * Create the DIB section.
     */
    RtlZeroMemory(&bmi, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = cx;
    bmi.bmiHeader.biHeight = cy;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    hbm = GreCreateDIBitmapReal(hdc, 0, NULL, &bmi, DIB_RGB_COLORS,
            sizeof(bmi), 0, NULL, 0, NULL, 0, 0, &pBits);

    if (hbm == NULL) {
        return NULL;
    }

    /*
     * Fill the dib section with the transparent color and then
     * draw the shadow on top of it.
     */
    GreSelectBitmap(hdc, hbm);
    FillRect(hdc, &rc, (HBRUSH)GreGetStockObject(BLACK_BRUSH));

    /*
     * Rectangular window shadow assumes the bitmap dimension to be greater than
     * or equal 2 * CX_SHADOW and 2 * CY_SHADOW else it will overrun bitmap buffer.
     * and in order to get a real rectangular shadow, the dimension should be 3 * CX_SHADOW
     * amd 3 * CY_SHADOW.
     */
    if ( (cx < 3 * CX_SHADOW) || (cy < 3 * CY_SHADOW)) {
        fForceComplexRgn = TRUE;
    } 
    
    if (!DrawWindowShadow(pwnd, hdc, fRTL, fForceComplexRgn, &fSimpleRgn)) {
        return NULL;
    }
        
    if (fSimpleRgn && !fForceComplexRgn)  {
        DrawRoundedRectangularShadow(pBits, cx, cy, fRTL);
        return hbm;
    }
    
    DrawRegionalShadow(pBits, cx, cy);
    return hbm;
}

/***************************************************************************\
* FindShadow
*
\***************************************************************************/

PSHADOW FindShadow(PWND pwnd)
{
    PSHADOW pshadow;

    for (pshadow = gpshadowFirst; pshadow != NULL; pshadow = pshadow->pshadowNext) {
        if (pshadow->pwnd == pwnd) {
            return pshadow;
        }
    }
    return NULL;
}

/***************************************************************************\
* WindowHasShadow
*
\***************************************************************************/

BOOL WindowHasShadow(PWND pwnd)
{
    BOOL fHasShadow = FALSE;

    if (TestWF(pwnd, WFVISIBLE)) {
        PSHADOW pshadow = FindShadow(pwnd);
        fHasShadow = (pshadow != NULL);
    } else {
        /*
         * The window isn't currently visible, so there is no shadow window.
         * We need to return if the window *would* have a shadow if it were
         * shown.
         */
        if (TestCF(pwnd, CFDROPSHADOW)) {
            fHasShadow = TRUE;

            if ((GETFNID(pwnd) == FNID_MENU) && (!TestALPHA(MENUFADE)) && TestEffectUP(MENUANIMATION)) {
                fHasShadow = FALSE;
            }
        }

        if (!TestALPHA(DROPSHADOW)) {
            fHasShadow = FALSE;
        }
    }

    return fHasShadow;
}

/***************************************************************************\
* ApplyShadow
*
\***************************************************************************/

BOOL ApplyShadow(PWND pwnd, PWND pwndShadow)
{
    POINT pt, ptSrc = {0, 0};
    SIZE size;
    BLENDFUNCTION blend;
    HDC hdcShadow;
    HBITMAP hbmShadow;
    BOOL fRet;

    hdcShadow = GreCreateCompatibleDC(gpDispInfo->hdcScreen);

    if (hdcShadow == NULL) {
        return FALSE;
    }

    hbmShadow = GenerateWindowShadow(pwnd, hdcShadow);
    if (hbmShadow == NULL) {
        GreDeleteDC(hdcShadow);
        return FALSE;
    }

    pt.x = pwnd->rcWindow.left;
    pt.y = pwnd->rcWindow.top;
    size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left + CX_SHADOW;
    size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top + CY_SHADOW;

    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        pt.x -= CX_SHADOW;
    }

    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = AC_SRC_ALPHA;
    blend.SourceConstantAlpha = 255;

    fRet = _UpdateLayeredWindow(pwndShadow, NULL, &pt, &size, hdcShadow, &ptSrc, 0,
            &blend, ULW_ALPHA);

    GreDeleteDC(hdcShadow);
    GreDeleteObject(hbmShadow);

    return fRet;
}

/***************************************************************************\
* MoveShadow
*
\***************************************************************************/

VOID MoveShadow(PWND pwnd)
{
    PSHADOW pshadow = FindShadow(pwnd);
    POINT pt;

    if (pshadow == NULL) {
        return;
    }

    pt.x = pwnd->rcWindow.left;
    pt.y = pwnd->rcWindow.top;

    _UpdateLayeredWindow(pshadow->pwndShadow, NULL, &pt, NULL, NULL, NULL, 0, NULL, 0);
}

/***************************************************************************\
* UpdateShadowShape
*
\***************************************************************************/

VOID UpdateShadowShape(PWND pwnd)
{
    PSHADOW pshadow = FindShadow(pwnd);

    if (pshadow == NULL) {
        return;
    }

    ApplyShadow(pshadow->pwnd, pshadow->pwndShadow);
}

/***************************************************************************\
* xxxUpdateShadowZorder
*
\***************************************************************************/

VOID xxxUpdateShadowZorder(PWND pwnd)
{
    TL tlpwnd;
    PWND pwndShadow;
    PSHADOW pshadow = FindShadow(pwnd);

    if (pshadow == NULL) {
        return;
    }

    pwndShadow = pshadow->pwndShadow;

    if (TestWF(pwnd, WEFTOPMOST) && !TestWF(pwndShadow, WEFTOPMOST)) {
        SetWF(pwndShadow, WEFTOPMOST);
    } else if (!TestWF(pwnd, WEFTOPMOST) && TestWF(pwndShadow, WEFTOPMOST)) {
        ClrWF(pwndShadow, WEFTOPMOST);
    }

    ThreadLock(pwndShadow, &tlpwnd);

    xxxSetWindowPos(pwndShadow, pwnd, 0, 0, 0, 0, SWP_NOACTIVATE |
            SWP_NOSIZE | SWP_NOMOVE);

    ThreadUnlock(&tlpwnd);

}
/***************************************************************************\
* xxxRemoveShadow
*
* Given the shadowed window, destroy the shadow window, cleanup the
* memory used by the shadow structure and remove it from the list.
\***************************************************************************/

VOID xxxRemoveShadow(PWND pwnd)
{
    PSHADOW* ppshadow;
    PSHADOW pshadow;
    PWND pwndT;

    CheckLock(pwnd);

    ppshadow = &gpshadowFirst;

    while (*ppshadow != NULL) {

        pshadow = *ppshadow;

        if (pshadow->pwnd == pwnd) {

            pwndT = pshadow->pwndShadow;

            *ppshadow = pshadow->pshadowNext;
            UserFreePool(pshadow);

            xxxDestroyWindow(pwndT);

            break;
        }

        ppshadow = &pshadow->pshadowNext;
    }
}

/***************************************************************************\
* RemoveShadow
*
* Given a shadow structure pointer, search for it in the list and remove it
\***************************************************************************/

VOID RemoveShadow(PSHADOW pshadow)
{
    PSHADOW* ppshadow;
    PSHADOW pshadowT;
    ppshadow = &gpshadowFirst;

    while (*ppshadow != NULL) {

        pshadowT = *ppshadow;

        if (pshadowT == pshadow) {
            *ppshadow = pshadowT->pshadowNext;
            UserFreePool(pshadowT);
            break;
        }

        ppshadow = &pshadowT->pshadowNext;
    }
}

/***************************************************************************\
* CleanupShadow
*
* Given the shadow window, remove the shadow structure from the list and
* cleanup the memory used by the shadow structure.
\***************************************************************************/

VOID CleanupShadow(PWND pwndShadow)
{
    PSHADOW* ppshadow;
    PSHADOW pshadow;

    CheckLock(pwndShadow);

    ppshadow = &gpshadowFirst;

    while (*ppshadow != NULL) {

        pshadow = *ppshadow;

        if (pshadow->pwndShadow == pwndShadow) {
        
            *ppshadow = pshadow->pshadowNext;
            UserFreePool(pshadow);
            
            break;
        }

        ppshadow = &pshadow->pshadowNext;
    }
}
/***************************************************************************\
* xxxAddShadow
*
\***************************************************************************/

BOOL xxxAddShadow(PWND pwnd)
{
    PWND pwndShadow;
    DWORD ExStyle;
    TL tlpwnd;
    TL tlpool;
    PSHADOW pshadow;

    CheckLock(pwnd);

    if (!TestALPHA(DROPSHADOW)) {
        return FALSE;
    }

    if (FindShadow(pwnd)) {
        return TRUE;
    }

    if ((pshadow = (PSHADOW)UserAllocPool(sizeof(SHADOW), TAG_SHADOW)) == NULL) {
        return FALSE;
    }

    ThreadLockPool(PtiCurrent(), pshadow, &tlpool);

    ExStyle = WS_EX_TOOLWINDOW | WS_EX_LAYERED | WS_EX_TRANSPARENT;
    if (TestWF(pwnd, WEFTOPMOST)) {
        ExStyle |= WS_EX_TOPMOST;
    }

    pwndShadow = xxxNVCreateWindowEx(ExStyle, (PLARGE_STRING)gatomShadow,
            NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, hModuleWin, NULL, WINVER);

    if (pwndShadow == NULL || !ApplyShadow(pwnd, pwndShadow)) {
        UserFreePool(pshadow);
        ThreadUnlockPool(PtiCurrent(), &tlpool);

        if (pwndShadow != NULL) {
            ThreadLock(pwndShadow, &tlpwnd);
            xxxDestroyWindow(pwndShadow);
            ThreadUnlock(&tlpwnd);
        }

        return FALSE;
    }

    pshadow->pshadowNext = gpshadowFirst;
    gpshadowFirst = pshadow;

    pshadow->pwnd = pwnd;
    pshadow->pwndShadow = pwndShadow;

    /* 
     * Since we added it the global list, we need to change the way
     * we lock its pool.
     */
    ThreadUnlockPool(PtiCurrent(), &tlpool);
    ThreadLockPoolCleanup(PtiCurrent(), pshadow, &tlpool, RemoveShadow);
    ThreadLock(pwndShadow, &tlpwnd);

    xxxSetWindowPos(pwndShadow, pwnd, 0, 0, 0, 0, SWP_SHOWWINDOW |
            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);

    ThreadUnlock(&tlpwnd);

    ThreadUnlockPool(PtiCurrent(), &tlpool);

    return TRUE;
}

/***************************************************************************\
* FAnyShadows
*
\***************************************************************************/

BOOL FAnyShadows(VOID)
{
    return (gpshadowFirst != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\service.c ===
/**************************** Module Header ********************************\
* Module Name: service.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Service Support Routines
*
* History:
* 12-22-93 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxConnectService
*
* Open the windowstation assigned to the service logon session.  If
* no windowstation exists, create the windowstation and a default desktop.
*
* History:
* 12-23-93 JimA         Created.
\***************************************************************************/

HWINSTA xxxConnectService(
    PUNICODE_STRING pstrWinSta,
    HDESK *phdesk)
{
    NTSTATUS Status;
    HANDLE hToken;
    ULONG ulLength;
    PTOKEN_USER ptuService;
    PSECURITY_DESCRIPTOR psdService;
    PSID psid;
    PACCESS_ALLOWED_ACE paceService = NULL, pace;
    OBJECT_ATTRIBUTES ObjService;
    HWINSTA hwinsta;
    UNICODE_STRING strDesktop;
    TL tlPoolSdService, tlPoolAceService, tlPoolToken;

    /*
     * Open the token of the service.
     */
    Status = OpenEffectiveToken(&hToken);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "ConnectService: Could not open process/thread token (0x%X)", Status);
        return NULL;
    }

    /*
     * Get the user SID assigned to the service.
     */
    ptuService = NULL;
    paceService = NULL;
    psdService = NULL;
    hwinsta = NULL;
    ZwQueryInformationToken(hToken, TokenUser, NULL, 0, &ulLength);
    ptuService = (PTOKEN_USER)UserAllocPool(ulLength, TAG_TOKEN);
    if (ptuService == NULL) {
        RIPMSG1(RIP_WARNING, "ConnectService: Can't alloc buffer (size=%d) for token info", ulLength);
        ZwClose(hToken);
        goto sd_error;
    }
    Status = ZwQueryInformationToken(hToken, TokenUser, ptuService,
            ulLength, &ulLength);
    ZwClose(hToken);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "ConnectService: QueryInformationToken failed (0x%X)", Status);
        goto sd_error;
    }
    psid = ptuService->User.Sid;

    /*
     * Create ACE list.
     */
    paceService = AllocAce(NULL, ACCESS_ALLOWED_ACE_TYPE, 0,
            WINSTA_CREATEDESKTOP | WINSTA_READATTRIBUTES |
                WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS |
                WINSTA_ACCESSCLIPBOARD | STANDARD_RIGHTS_REQUIRED,
            psid, &ulLength);
    if (paceService == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: AllocAce for WindowStation attributes failed");
        goto sd_error;
    }
    pace = AllocAce(paceService, ACCESS_ALLOWED_ACE_TYPE, OBJECT_INHERIT_ACE |
            INHERIT_ONLY_ACE | NO_PROPAGATE_INHERIT_ACE,
            DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS | DESKTOP_ENUMERATE |
                DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU | DESKTOP_HOOKCONTROL |
                STANDARD_RIGHTS_REQUIRED,
            psid, &ulLength);
    if (pace == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: AllocAce for Desktop Attributes failed");
        goto sd_error;
    }
    paceService = pace;
    pace = AllocAce(pace, ACCESS_ALLOWED_ACE_TYPE, 0,
            WINSTA_ENUMERATE,
            SeExports->SeAliasAdminsSid, &ulLength);
    if (pace == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: AllocAce for admin WinSta enumerate failed");
        goto sd_error;
    }
    paceService = pace;
    pace = AllocAce(pace, ACCESS_ALLOWED_ACE_TYPE, OBJECT_INHERIT_ACE |
            INHERIT_ONLY_ACE | NO_PROPAGATE_INHERIT_ACE,
            DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS | DESKTOP_ENUMERATE,
            SeExports->SeAliasAdminsSid, &ulLength);
    if (pace == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: AllocAce for admin Desktop access failed");
        goto sd_error;
    }
    paceService = pace;

    /*
     * Initialize the SD
     */
    psdService = CreateSecurityDescriptor(paceService, ulLength, FALSE);
    if (psdService == NULL) {
        RIPMSG0(RIP_WARNING, "ConnectService: CreateSecurityDescriptor failed");
        goto sd_error;
    }

    ThreadLockPool(PtiCurrent(), ptuService,  &tlPoolToken);
    ThreadLockPool(PtiCurrent(), paceService, &tlPoolAceService);
    ThreadLockPool(PtiCurrent(), psdService,  &tlPoolSdService);

    /*
     * The windowstation does not exist and must be created.
     */
    try {
        InitializeObjectAttributes(&ObjService, pstrWinSta,
                OBJ_OPENIF, NULL, psdService);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
          Status = GetExceptionCode();
    }

    if (NT_SUCCESS(Status)) {
        hwinsta = xxxCreateWindowStation(&ObjService,
                                         KernelMode,
                                         MAXIMUM_ALLOWED,
                                         NULL, 0, NULL,
                                         NULL,
                                         0);
    }

    if (hwinsta != NULL) {

        TRACE_INIT(("Service windowstation created\n"));

        /*
         * We have the windowstation, now create the desktop.  The security
         * descriptor will be inherited from the windowstation.  Save the
         * winsta handle because the access struct may be moved by the
         * desktop creation.
         */
        RtlInitUnicodeString(&strDesktop, TEXT("Default"));
        InitializeObjectAttributes(&ObjService, &strDesktop,
                OBJ_OPENIF | OBJ_CASE_INSENSITIVE, hwinsta, NULL);

        *phdesk = xxxCreateDesktop(&ObjService, KernelMode,
                NULL, NULL, 0, MAXIMUM_ALLOWED);

        if (*phdesk == NULL) {

            /*
             * The creation failed, wake the desktop thread, close the
             * windowstation and leave.
             */
            RIPMSG0(RIP_WARNING, "ConnectService: CreateDesktop('Default') failed.");

            ZwClose(hwinsta);
            hwinsta = NULL;
        } else {
            TRACE_INIT(("Default desktop in Service windowstation created\n"));
        }
    } else {
        *phdesk = NULL;
    }

    ThreadUnlockPool(PtiCurrent(), &tlPoolSdService);
    ThreadUnlockPool(PtiCurrent(), &tlPoolAceService);
    ThreadUnlockPool(PtiCurrent(), &tlPoolToken);

sd_error:
    if (ptuService != NULL)
        UserFreePool(ptuService);
    if (paceService != NULL)
        UserFreePool(paceService);
    if (psdService != NULL)
        UserFreePool(psdService);

    return hwinsta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

MAJORCOMP=user
MINORCOMP=kernel

TARGETTYPE=LIBRARY

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -DUNICODE -D_USER32_       \
          -DNTOS_KERNEL_RUNTIME=1 -D_NTDRIVER_ -D_NTSYSTEM_DRIVER_  \
	  -DNO_INTERLOCKED_INTRINSICS

!IFDEF USER_PERFORMANCE
C_DEFINES=$(C_DEFINES) -DUSER_PERFORMANCE
!ENDIF

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..;                                     \
         $(NTUSER_PATH)\inc;                     \
         $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O); \
         $(NTGDI_PATH)\ntgdi\inc;                \
         $(WINCORE_PATH)\w32inc;                 \
         $(WINCORE_PATH)\w32inc\$(O);            \
         $(BASE_INC_PATH)

NT_UP=0

TARGETNAME=userk
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

NTTARGETFILE0=$(O)\strid.h $(O)\msg00001.bin $(O)\strid.rc $(O)\callcf.c $(O)\kbdus.c

SOURCES=..\access.c   \
        ..\acons.c    \
        ..\atom.c     \
        ..\base.c     \
        ..\calcclrc.c \
        ..\caption.c  \
        ..\capture.c  \
        ..\caret.c    \
        ..\class.c    \
        ..\classchg.c \
        ..\cleanup.c  \
        ..\clipbrd.c  \
        ..\createw.c  \
        ..\cursor.c   \
        ..\dc.c       \
        ..\ddemlsvr.c \
        ..\ddetrack.c \
        ..\debug.c    \
        ..\desktop.c  \
        ..\dragdrop.c \
        ..\drawfrm.c  \
        ..\dtbitmap.c \
        ..\dwp.c      \
        ..\enumwin.c  \
        ..\event.c    \
        ..\ex.c       \
        ..\exitwin.c  \
        ..\fekbd.c    \
        ..\focusact.c \
        ..\fullscr.c  \
        ..\getset.c   \
        ..\ghost.c    \
        ..\globals.c  \
        ..\handtabl.c \
        ..\heap.c     \
        ..\help.c     \
        ..\hidevice.c \
        ..\hooks.c    \
        ..\hotkeys.c  \
        ..\hungapp.c  \
        ..\icons.c    \
        ..\imehotky.c \
        ..\inctlpan.c \
        ..\init.c     \
        ..\input.c    \
        ..\job.c      \
        ..\kbd.c      \
        $(O)\kbdus.c  \
        ..\kbdlyout.c \
        ..\keyboard.c \
        ..\keyconv.c  \
        ..\libmgmt.c  \
        ..\loadbits.c \
        ..\logon.c    \
        ..\menu.c     \
        ..\menudd.c   \
        ..\metrics.c  \
        ..\minmax.c   \
        ..\miscutil.c \
        ..\mnaccel.c  \
        ..\mnapi.c    \
        ..\mnchange.c \
        ..\mncomput.c \
        ..\mncreate.c \
        ..\mndraw.c   \
        ..\mndstry.c  \
        ..\mngray.c   \
        ..\mnkey.c    \
        ..\mnloop.c   \
        ..\mnpopup.c  \
        ..\mnsel.c    \
        ..\mnstate.c  \
        ..\mnsys.c    \
        ..\movesize.c \
        ..\msgbeep.c  \
        ..\multimon.c \
        ..\newmouse.c \
        ..\ntimm.c    \
        ..\ntinput.c  \
        ..\ntstubs.c  \
        ..\paint.c    \
        ..\palette.c  \
        ..\pnp.c      \
        ..\pool.c     \
        ..\power.c    \
        ..\profile.c  \
        ..\queue.c    \
        ..\random.c   \
        ..\rare.c     \
        ..\sbapi.c    \
        ..\sbctl.c    \
        ..\scrollw.c  \
        ..\security.c \
        ..\sendmsg.c  \
        ..\server.c   \
        ..\service.c  \
        ..\shadow.c   \
        ..\showwin.c  \
        ..\sirens.c   \
        ..\snapshot.c \
        ..\spb.c      \
        ..\sprite.c   \
        ..\srvhook.c  \
        ..\srvmsg.c   \
        ..\ssend.c    \
        ..\swp.c      \
        ..\syscmd.c   \
        ..\sysmet.c   \
        ..\taskman.c  \
        ..\text.c     \
        ..\timers.c   \
        ..\tmswitch.c \
        ..\tooltips.c \
        ..\tounicod.c \
        ..\update.c   \
        ..\usergdi.c  \
        ..\validate.c \
        ..\visrgn.c   \
        ..\winable.c  \
        ..\winable2.c \
        ..\winhtky.c  \
        ..\winloop2.c \
        ..\winmgr.c   \
        ..\winprop.c  \
        ..\winsta.c   \
        ..\winwhere.c \
        ..\wmicon.c   \
        ..\xlate.c    \
        $(O)\callcf.c


UMTYPE=windows
UMTEST=
UMLIBS=

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\spb.c ===
/**************************** Module Header ********************************\
* Module Name: spb.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Save Popup Bits (SPB) support routines.
*
* History:
* 18-Jul-1991 DarrinM   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* FBitsTouch
*
* This routine checkes to see if the rectangle *lprcDirty in pwndDirty
* invalidates any bits in the SPB structure at *pspb.
*
* pwndDirty "touches" pwndSpb if:
*   1. pwndDirty is visible AND:
*   2. pwndDirty == or descendent of pwndSpb, and pwndSpb is a LOCKUPDATE
*      spb.
*   3. pwndDirty is pwndSpb's parent.  (e.g., drawing in the
*      desktop window, behind a dialog box).
*   4. A parent of pwndDirty is the sibling of pwndSpb, and the parent
*      is lower in the zorder.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL FBitsTouch(
    PWND   pwndDirty,
    LPRECT lprcDirty,
    PSPB   pspb,
    DWORD  flags)
{
    PWND    pwndSpb,
            pwndDirtySave;
    int     fSpbLockUpdate;

    /*
     * When no window is passed in, skip all the window-related stuff and
     * go directly to check the rectangle.
     */
    if (pwndDirty == NULL)
        goto ProbablyTouch;

    /*
     * If pwndDirty or its parents are invisible,
     * then it can't invalidate any SPBs
     */
    if (!IsVisible(pwndDirty))
        return FALSE;

    pwndSpb = pspb->spwnd;
    fSpbLockUpdate = pspb->flags & SPB_LOCKUPDATE;
    if (fSpbLockUpdate) {

        /*
         * If the guy is drawing through a locked window via
         * DCX_LOCKWINDOWUPDATE and the spb is a LOCKUPDATE SPB, then
         * don't do any invalidation of the SPB.  Basically we're trying
         * to avoid having the tracking rectangle invalidate the SPB
         * since it's drawn via a WinGetClipPS() ps.
         */
        if (flags & DCX_LOCKWINDOWUPDATE)
            return FALSE;
    }

    /*
     * If pwndDirty is pwndSpb's immediate parent (e.g., drawing in the
     * desktop window behind a dialog box), then we may touch: do the
     * intersection.
     */
    if (pwndDirty == pwndSpb->spwndParent)
        goto ProbablyTouch;

    /*
     * We know that pwndDirty != pwndSpb->spwndParent.
     * Now find the parent of pwndDirty that is a sibling of pwndSpb.
     */
    pwndDirtySave = pwndDirty;

    while (pwndSpb->spwndParent != pwndDirty->spwndParent) {
        pwndDirty = pwndDirty->spwndParent;

        /*
         * If we get to the top of the tree, it's because:
         *  1.  pwndSpb == pwndDesktop
         *  2.  pwndDirty is a parent of pwndSpb
         *  3.  pwndDirty == pwndDesktop
         *  4.  pwndDirty is a child of some other desktop
         *  5.  pwndSpb and pwndDirty aren't siblings
         *
         * In all these cases, pwndDirty can't touch pwndSpb.
         */
        if (pwndDirty == NULL)
            return FALSE;
    }

    /*
     * If pwndSpb is the same as pwndDirty, then it will invalidate
     * only if the SPB is LOCKUPDATE.
     *
     * Non-LOCKUPDATE SPB's can't be invalidated by their
     * own windows, but LOCKUPDATE SPB's can.
     */
    if (pwndDirty == pwndSpb) {
        if (!fSpbLockUpdate)
            return FALSE;

        /*
         * If pwndSpb itself was drawn in, then we can't
         * try subtracting children.
         */
        if (pwndDirtySave == pwndSpb)
            goto ProbablyTouch;

        /*
         * We want to calculate the immediate child of pwndSpb
         * on the path from pwndDirty to pwndSpb, so we can
         * subtract off the rectangles of the children of pwndSpb
         * in case there are intervening windows.
         */
        while (pwndSpb != pwndDirtySave->spwndParent) {
            pwndDirtySave = pwndDirtySave->spwndParent;
        }

        /*
         * The SubtractIntervening loop subtracts the
         * window rects starting from pwndSpb and ending
         * at the window before pwndDirty, so set up
         * our variables appropriately.
         */
        pwndDirty = pwndDirtySave;
        pwndSpb = pwndSpb->spwndChild;

    } else {
        /*
         * Now compare the Z order of pwndDirty and pwndSpb.
         * If pwndDirty is above pwndSpb, then the SPB can't be touched.
         */
        pwndDirtySave = pwndDirty;

        /*
         * Compare the Z order by searching starting at pwndDirty,
         * moving DOWN the Z order list.  If we encounter pwndSpb,
         * then pwndDirty is ABOVE or EQUAL to pwndSpb.
         */
        for ( ; pwndDirty != NULL; pwndDirty = pwndDirty->spwndNext) {
            if (pwndDirty == pwndSpb) {
                return FALSE;
            }
        }
        pwndDirty = pwndDirtySave;

        /*
         * We don't want to subtract the SPB window itself
         */
        pwndSpb = pwndSpb->spwndNext;
    }

    /*
     * Subtract Intervening rectangles.
     * pwndDirty is below pwndSpb.  If there are any intervening
     * windows, subtract their window rects from lprcDirty to see if pwndDirty
     * is obscured.
     */
    while (pwndSpb && pwndSpb != pwndDirty) {
        /*
         * If this window has a region selected, hwndDirty may draw through
         * it even though it has a full rectangle! We can't subtract its
         * rect from the dirty rect in this case.
         */
        if (    TestWF(pwndSpb, WFVISIBLE) &&
                !pwndSpb->hrgnClip &&
                !TestWF(pwndSpb, WEFLAYERED) &&
                !SubtractRect(lprcDirty, lprcDirty, &pwndSpb->rcWindow)) {

            return FALSE;
        }

        pwndSpb = pwndSpb->spwndNext;
    }

    // fall through
ProbablyTouch:

    /*
     * If the rectangles don't intersect, there is no invalidation.
     * (we make this test relatively late because it's expensive compared
     * to the tests above).
     * Otherwise, *lprcDirty now has the area of bits not obscured
     * by intervening windows.
     */

    return IntersectRect(lprcDirty, lprcDirty, &pspb->rc);
}

/***************************************************************************\
* SpbCheckRect2
*
* Subtracts lprc in pwnd from pspb's region if lprc touches pspb.
*
* Returns FALSE if there is a memory allocation error, or if lprc
* contains psbp's region; otherwise, returns TRUE.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL SpbCheckRect2(
    PSPB   pspb,
    PWND   pwnd,
    LPRECT lprc,
    DWORD  flags)
{
    RECT rcTouch = *lprc;

    /*
     * See if lprc touches any saved bits, taking into account what
     * window the drawing is occuring in.
     */
    if (FBitsTouch(pwnd, &rcTouch, pspb, flags)) {

        /*
         * If no SPB region exists, make one for the whole thing
         */
        if (!pspb->hrgn && SetOrCreateRectRgnIndirectPublic(
                &pspb->hrgn, &pspb->rc) == ERROR) {

            goto Error;
        }

        /*
         * Subtract the rectangle that is invalid from the SPB region
         */
        SetRectRgnIndirect(ghrgnSCR, &rcTouch);
        switch (SubtractRgn(pspb->hrgn, pspb->hrgn, ghrgnSCR)) {
        case ERROR:
        case NULLREGION:
            goto Error;

        default:
            break;
        }
    }

    return TRUE;

Error:
    FreeSpb(pspb);
    return FALSE;
}

/***************************************************************************\
* SpbTransfer
*
* Validate the SPB rectangle from a window's update region, after
* subtracting the window's update region from the SPB.
*
* NOTE: Although SpbTransfer calls xxxInternalInvalidate, it doesn't
* specify any flags that will cause immediate updating.  Therefore the
* critsect isn't left and we don't consider this an 'xxx' routine.
* Also, no revalidation is necessary.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL SpbTransfer(
    PSPB pspb,
    PWND pwnd,
    BOOL fChildren)
{
    RECT rc;

    /*
     * If the window has an update region...
     */
    if (pwnd->hrgnUpdate != NULL) {

        /*
         * Invalidate its update region rectangle from the SPB
         */
        if (pwnd->hrgnUpdate > HRGN_FULL) {
            GreGetRgnBox(pwnd->hrgnUpdate, &rc);
        } else {
            rc = pwnd->rcWindow;
        }

        /*
         * Intersect the update region bounds with the parent client rects,
         * to make sure we don't invalidate more than we need to.  If
         * nothing to validate, return TRUE (because SPB is probably not empty)
         * These RDW_ flags won't cause the critical section to be left, nor
         * will they provoke WinEvent notifications.
         */
        if (IntersectWithParents(pwnd, &rc)) {
            BEGINATOMICCHECK();

            xxxInternalInvalidate(pwnd,
                                  ghrgnSPB2,
                                  RDW_VALIDATE | RDW_NOCHILDREN);

            ENDATOMICCHECK();

            /*
             * If the SPB vanished, return FALSE.
             */
            if (!SpbCheckRect2(pspb, pwnd, &rc, DCX_WINDOW))
                return FALSE;
        }
    }

    if (fChildren) {
        for (pwnd = pwnd->spwndChild; pwnd != NULL; pwnd = pwnd->spwndNext) {
            if (!SpbTransfer(pspb, pwnd, TRUE)) {
                return FALSE;
            }
        }
    }

    return TRUE;
}

/***************************************************************************\
* CreateSpb
*
* This function, called after the window is created but before it is visible,
* saves the contents of the screen where the window will be drawn in a SPB
* structure, and links the structure into a linked list of SPB structures.
* popup bits. This routine is called from SetWindowPos.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID CreateSpb(
    PWND pwnd,
    UINT flags,
    HDC  hdcScreen)
{
    PSPB    pspb;
    int     fSpbLockUpdate;

    /*
     * Non-LOCKWINDOWUPDATE SPBs can only be created for top-level windows.
     *
     * This is because of the way that the display driver RestoreBits function
     * works.  It can put bits down in places that aren't even part of the
     * window's visrgn, and these bits need to be invalidated.  The
     * SetWindowPos() code to handle this case only knows how to invalidate
     * one of windows (i.e., the window's immediate parent), but all levels
     * need to get invalidated.  See also the comments in wmswp.c, near the
     * call to RestoreSpb().
     *
     * For example: the Q&E app brings up a copyright dialog that is a child
     * of its main window.  While this is up, the user alt-f alt-l to execute
     * the file login command, which brings up another dialog that is a child
     * of the desktop.  When the copyright dialog goes away, the display driver
     * restores bits on top of the second dialog.  The SWP code knows to
     * invalidate the bogus stuff in the main window, but not in the desktop.
     *
     * LOCKUPDATE SPBs are fine, because they don't call RestoreBits.
     */
    fSpbLockUpdate = flags & SPB_LOCKUPDATE;
    if (    !fSpbLockUpdate             &&
            pwnd->spwndParent != NULL   &&
            pwnd->spwndParent != PWNDDESKTOP(pwnd)) {

        return;
    }

    /*
     * We go and check all the existing DCs at this point, to handle the
     * case where we're saving an image of a window that has a "dirty"
     * DC, which would eventually invalidate our saved image (but which
     * is really okay).
     */
    if (AnySpbs()) {

        SpbCheck();

    } else {

        PDCE pdce;

        /*
         * Reset the dirty areas of all of the DC's and enable
         * bounds accumulation.  We're creating a SPB now.  This
         * is only done if there are no other SPB's in the list.
         */
        GreLockDisplay(gpDispInfo->hDev);

        for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

            if (pdce->DCX_flags & DCX_REDIRECTED)
                continue;

            GreGetBounds(pdce->hdc, NULL, GGB_ENABLE_WINMGR);
        }

        GreUnlockDisplay(gpDispInfo->hDev);
    }

    /*
     * Create the save popup bits structure
     */
    pspb = (PSPB)UserAllocPoolWithQuota(sizeof(SPB), TAG_SPB);
    if (!pspb)
        return;

    pspb->spwnd = NULL;
    pspb->rc    = pwnd->rcWindow;

    /*
     * Clip to the screen
     */
    if (!IntersectRect(&pspb->rc, &pspb->rc, &gpDispInfo->rcScreen))
        goto BMError;

    pspb->hrgn  = NULL;
    pspb->hbm   = NULL;
    pspb->flags = flags;
    Lock(&(pspb->spwnd), pwnd);

    if (!fSpbLockUpdate) {

        RECT rc = pspb->rc;

        if (!SYSMET(SAMEDISPLAYFORMAT)) {
            PMONITOR pMonitor = _MonitorFromRect(&pspb->rc, MONITOR_DEFAULTTOPRIMARY);
            RECT rcT;

            /*
             * If the intersection with the monitor isn't the entire visible
             * window rectangle, then bail!  We don't save SPBs for windows
             * that span multiple monitors.  Since we do a lot of work to
             * pin dialogs and menus, there won't be too many of these
             * babies.
             */
            if (SubtractRect(&rcT, &pspb->rc, &pMonitor->rcMonitor) &&
                    GreRectInRegion(gpDispInfo->hrgnScreen, &rcT))
                goto BMError2;

            /*
             * Clip to the window's monitor
             */
            if (!IntersectRect(&pspb->rc, &pspb->rc, &pMonitor->rcMonitor))
                goto BMError2;

            /*
             * dont save bits in a mixed bitdepth situtation
             * we cant create the exactly correct format bitmap
             * in all cases (555/565, and Paletized) so as
             * a cop-out dont save bitmaps at all (on secondaries)
             * in mixed bit-depth.
             *
             * the correct fix is to create a compatible
             * bitmap for the monitor device and directly
             * BitBlt() from/to the device (pMonitor->hdcMonitor)
             * but this involves too much code at this time.
             */
            if (pMonitor != gpDispInfo->pMonitorPrimary)
                goto BMError2;
        }

        /*
         * If this window is a regional window, don't use driver save
         * bits. Because it can only restore an entire rectangle,
         * invalid region is calculated assuming the old vis rgn was
         * rectangular. For regional windows, this would end up always
         * invalidating the area of (rcWindow - hrgnWindow) every
         * time an spb would be used. On the other hand, the invalid
         * area calculated when not using driver save bits is perfect,
         * because the restore blt can be correctly clipped to begin with.
         */
        if ((pwnd->hrgnClip == NULL) &&
            (pspb->ulSaveId = GreSaveScreenBits(gpDispInfo->hDev,
                                                SS_SAVE,
                                                0,
                                                (RECTL *)&rc))) {

            /*
             * Remember that we copied this bitmap into on board memory.
             */
            pspb->flags |= SPB_SAVESCREENBITS;

        } else {
            HBITMAP hbmSave;
            BOOL    bRet;

            /*
             * The following delta byte-aligns the screen bitmap
             */
            int dx = pspb->rc.left & 0x0007;
            int cx = pspb->rc.right - pspb->rc.left;
            int cy = pspb->rc.bottom - pspb->rc.top;

            /*
             * NOTE: we don't care about setting up a visrgn in
             * hdcScreen, because BitBlt ignores it on reads.
             */
            pspb->hbm = GreCreateCompatibleBitmap(hdcScreen, cx + dx, cy);
            if (!pspb->hbm)
                goto BMError2;

            hbmSave = (HBITMAP)GreSelectBitmap(ghdcMem, pspb->hbm);
            if (!hbmSave)
                goto BMError2;

            /*
             * Copy the contents of the screen to the bitmap in the
             * save popup bits structure.  If we ever find we run
             * into problems with the screen access check we can
             * do a bLockDisplay, give this process permission, do
             * the BitBlt and then take away permission.  GDI
             * accesses the screen and that bit only under the
             * display semaphore so it is safe.  Alternatively
             * if it is too hard to change this processes permission
             * here we could do it in GDI by marking the psoSrc
             * readable temporarily while completing the operation
             * and then setting it back to unreadable when done.
             * Or we could just fail it like the CreateCompatibleDC
             * failed and force a redraw.  Basically we can't add
             * 3K of code in GDI to do a BitBlt that just does 1
             * test differently for this 1 place in User.
             *
             */
            bRet = GreBitBlt(ghdcMem,
                             dx,
                             0,
                             cx,
                             cy,
                             hdcScreen,
                             pspb->rc.left,
                             pspb->rc.top,
                             0x00CC0000,
                             0);

            GreSelectBitmap(ghdcMem, hbmSave);

            if (!bRet)
                goto BMError2;

            GreSetBitmapOwner(pspb->hbm, OBJECT_OWNER_PUBLIC);
        }

        /*
         * Mark that the window has an SPB.
         */
        SetWF(pwnd, WFHASSPB);

        /*
         * non-LOCKUPDATE SPBs are not invalidated by
         * drawing in pspb->spwnd, so start the SPB validation
         * loop below at the sibling immediately below us.
         */
        pwnd = pwnd->spwndNext;
    }

    /*
     * Link the new save popup bits structure into the list.
     */
    pspb->pspbNext = gpDispInfo->pspbFirst;
    gpDispInfo->pspbFirst = pspb;

    /*
     * Here we deal with any update regions that may be
     * pending in windows underneath the SPB.
     *
     * For all windows that might affect this SPB:
     *    - Subtract the SPB rect from the update region
     *    - Subtract the window from the SPB
     *
     * Note that we use pspb->spwnd here, in case it has
     * no siblings.
     *
     * ghrgnSPB2 is the region that is used inside of SpbTransfer to
     * validate window update regions. Intersect with the window clipping
     * region, if it exists. Don't want to intersect with the spb rect if
     * a clipping region exists because we'll end up validating more than
     * we want to validate.
     */
    SetRectRgnIndirect(ghrgnSPB2, &pspb->rc);
    if (pspb->spwnd->hrgnClip != NULL) {

        /*
         * If we get an error bail since an error might result in more
         * being validated than we want. Since the below code is only an
         * optimizer, this is ok: the window will remain invalid and will
         * draw, thereby invalidating the SPB like usual.
         */
        if (IntersectRgn(ghrgnSPB2,
                         ghrgnSPB2,
                         pspb->spwnd->hrgnClip) == ERROR) {
            return;
        }
    }

    if (pspb->spwnd->spwndParent == NULL ||
            SpbTransfer(pspb, pspb->spwnd->spwndParent, FALSE)) {

        /*
         * Do the same for the siblings underneath us...
         */
        for ( ; pwnd != NULL; pwnd = pwnd->spwndNext) {
            if (!SpbTransfer(pspb, pwnd, TRUE))
                break;
        }
    }

    return;

BMError2:
    /*
     * Error creating the bitmap: clean up and return.
     */
    if (pspb->hbm)
        GreDeleteObject(pspb->hbm);

    Unlock(&pspb->spwnd);
    // fall-through

BMError:
    UserFreePool(pspb);
}

/***************************************************************************\
* RestoreSpb
*
* Restores the bits associated with pwnd's SPB onto the screen, clipped
* to hrgnUncovered if possible.
*
* Upon return, hrgnUncovered is modified to contain the part of hrgnUncovered
* that must be invalidated by the caller.  FALSE is returned if the area
* to be invalidated is empty.
*
* NOTE: Because the device driver SaveBitmap() function can not clip, this
* function may write bits into an area of the screen larger than the passed-in
* hrgnUncovered.  In this case, the returned invalid region may be larger
* than the passed-in hrgnUncovered.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

UINT RestoreSpb(
    PWND pwnd,
    HRGN hrgnUncovered,
    HDC  *phdcScreen)
{
    PSPB pspb;
    UINT uInvalidate;
    HRGN hrgnRestorable;

    /*
     * Note that we DON'T call SpbCheck() here --
     * SpbCheck() is called by zzzBltValidBits().
     */
    pspb = FindSpb(pwnd);

    /*
     * Assume all of hrgnUncovered was restored, and there's nothing
     * for our caller to invalidate.
     */
    uInvalidate = RSPB_NO_INVALIDATE;
    hrgnRestorable = hrgnUncovered;

    /*
     * First determine whether or not there is any area at all to restore.
     * If hrgnUncovered & pspb->hrgn is empty, then all of hrgnUncovered
     * needs to be invalidated, and there's nothing to restore.
     */
    if (pspb->hrgn != NULL) {
        /*
         * At least some of hrgnUncovered needs to be invalidated.
         */
        uInvalidate = RSPB_INVALIDATE;

        /*
         * Calculate the true area of bits to be restored.  If it becomes
         * empty, then just free the SPB without changing hrgnUncovered,
         * which is the area that must be invalidated.
         */
        hrgnRestorable = ghrgnSPB1;
        switch (IntersectRgn(hrgnRestorable, hrgnUncovered, pspb->hrgn)) {
        case ERROR:
        case NULLREGION:
            goto Error;

        default:
            break;
        }
    }

    if (pspb->flags & SPB_SAVESCREENBITS) {

        RECT rc = pspb->rc;

        /*
         * Since the restore frees the onboard memory, clear this
         * bit so FreeSpb() won't try to free it again (regardless of
         * whether we get an error or not)
         */
        pspb->flags &= ~SPB_SAVESCREENBITS;
        if (!(GreSaveScreenBits(gpDispInfo->hDev,
                                SS_RESTORE,
                                pspb->ulSaveId,
                                (RECTL *)&rc))) {
            goto Error;
        }

        /*
         * The SS_RESTORE call will always restore the entire SPB
         * rectangle, part of which may fall outside of hrgnUncovered.
         * The area that must be invalidated by our caller is simply
         * the SPB rectangle minus the area of restorable bits.
         *
         * If this region is not empty, then the SPB was not completely
         * restored, so we must return FALSE.
         */
        SetRectRgnIndirect(ghrgnSPB2, &pspb->rc);
        if (SubtractRgn(hrgnUncovered, ghrgnSPB2, hrgnRestorable) != NULLREGION) {
            uInvalidate = RSPB_INVALIDATE_SSB;
        }
    } else {

        HDC     hdcScreen;
        HBITMAP hbmSave;

        /*
         * In the unlikely event we need a screen DC and one wasn't passed in,
         * get it now.  If we get one, we return the handle in *phdcScreen
         * so that our caller can release it later.
         */
        if (!*phdcScreen) {
            *phdcScreen = gpDispInfo->hdcScreen;
        }

        hdcScreen = *phdcScreen;

        hbmSave = (HBITMAP)GreSelectBitmap(ghdcMem, pspb->hbm);
        if (!hbmSave)
            goto Error;

        /*
         * Be sure to clip to the area of restorable bits.
         */

        GreSelectVisRgn(hdcScreen, hrgnRestorable, SVR_COPYNEW);

        GreBitBlt(hdcScreen,
                  pspb->rc.left, pspb->rc.top,
                  pspb->rc.right - pspb->rc.left,
                  pspb->rc.bottom - pspb->rc.top,
                  ghdcMem,
                  pspb->rc.left & 0x0007,
                  0,
                  SRCCOPY,
                  0);

        GreSelectBitmap(ghdcMem, hbmSave);

        /*
         * Now compute the area to be invalidated for return.
         * This is simply the original hrgnUncovered - hrgnRestorable
         */
        SubtractRgn(hrgnUncovered, hrgnUncovered, hrgnRestorable);
    }

    if (pwnd->hrgnClip == NULL || !IsVisible(pwnd))
        FreeSpb(pspb);

    return uInvalidate;

Error:
    FreeSpb(pspb);
    return RSPB_INVALIDATE;
}



/***************************************************************************\
* LockWindowUpdate2 (API)
*
* Locks gspwndLockUpdate and it's children from updating.  If
* gspwndLockUpdate is NULL, then all windows will be unlocked.  When
* unlocked, the portions of the screen that would have been written to
* are invalidated so they get repainted. TRUE is returned if the routine
* is successful.
*
* If called when another app has something locked, then this function fails.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL LockWindowUpdate2(
    PWND pwndLock,
    BOOL fThreadOverride)
{
    PSPB pspb;
    BOOL fInval;
    HRGN hrgn;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    if (    /*
             * If we're full screen right now, fail this call.
             */
            TEST_PUDF(PUDF_LOCKFULLSCREEN)

            ||

            /*
             * If the screen is already locked, and it's being locked
             * by some other app, then fail.  If fThreadOverride is set
             * then we're calling internally and it's okay to cancel
             * someone elses LockUpdate.
             */
            (   gptiLockUpdate != NULL &&
                gptiLockUpdate != PtiCurrent() &&
                !fThreadOverride)) {
    UserAssert(IsWinEventNotifyDeferredOK());

        RIPERR0(ERROR_SCREEN_ALREADY_LOCKED,
                RIP_WARNING,
                "LockWindowUpdate failed because screen is locked by another application.");

        return FALSE;
    }

    if ((pwndLock != NULL) == (gptiLockUpdate != NULL)) {
        if (!fThreadOverride) {
            RIPERR1(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "LockWindowUpdate failed because it is already %s.",
                    (pwndLock != NULL) ? "locked" : "unlocked");
        }

        return FALSE;
    }

    /*
     * This must be done while holding the screen critsec.
     * Deadlock if we callback during this, so defer WinEvent notifications
     */
    DeferWinEventNotify();
    GreLockDisplay(gpDispInfo->hDev);

    if (pwndLock != NULL) {
        /*
         * We're about to make pwndLock and its siblings invisible:
         * go invalidate any other affected SPBs.
         */
        SpbCheckPwnd(pwndLock);

        CreateSpb(pwndLock, SPB_LOCKUPDATE, NULL);

        Lock(&(gspwndLockUpdate), pwndLock);
        gptiLockUpdate = ptiCurrent;

        zzzInvalidateDCCache(pwndLock, IDC_DEFAULT);

    } else {
        /*
         * Flush any accumulated rectangles and invalidate spbs.
         */
        SpbCheck();

        /*
         * Save this in a local before we set it to NULL
         */
        pwndLock = gspwndLockUpdate;

        gptiLockUpdate = NULL;
        Unlock(&gspwndLockUpdate);

        zzzInvalidateDCCache(pwndLock, IDC_DEFAULT);

        /*
         * Assume SPB doesn't exist, or couldn't be created, and that we
         * must invalidate the entire window.
         */
        fInval = TRUE;
        hrgn = HRGN_FULL;

        /*
         * Find the LOCKUPDATE spb in the list, and if present calculate
         * the area that has been invalidated, if any.
         */
        for (pspb = gpDispInfo->pspbFirst; pspb != NULL; pspb = pspb->pspbNext) {

            if (pspb->flags & SPB_LOCKUPDATE) {

                if (pspb->hrgn == NULL) {

                    /*
                     * If no invalid area, then no invalidation needed.
                     */
                    fInval = FALSE;

                } else {

                    /*
                     * Subtract SPB valid region from SPB rectangle, to
                     * yield invalid region.
                     */
                    hrgn = ghrgnSPB1;
                    SetRectRgnIndirect(hrgn, &pspb->rc);

                    /*
                     * If spb rect minus the spb valid rgn is empty,
                     * then there is nothing to invalidate.
                     */
                    fInval = SubtractRgn(hrgn, hrgn, pspb->hrgn) != NULLREGION;
                }

                FreeSpb(pspb);

                /*
                 * Exit this loop (there can be only one LOCKUPDATE spb)
                 */
                break;
            }
        }

        if (fInval) {
            /*
             * When unlocking a Layered window (or a child of a layered
             * window), we need to invalidate that layered window specifically
             * or the window will ignore the invalidation request.  For regular
             * windows, we invalidate the desktop instead.
             */
            PWND pwndInvalidate;
            if ((pwndInvalidate = GetStyleWindow(pwndLock, WEFLAYERED)) == NULL) {
                pwndInvalidate = PWNDDESKTOP(pwndLock);
            }

            BEGINATOMICCHECK();
            // want to prevent WinEvent notifies, but this make break asserts
            DeferWinEventNotify();
            xxxInternalInvalidate(pwndInvalidate,
                               hrgn,
                               RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
            zzzEndDeferWinEventNotify();
            ENDATOMICCHECK();
        }

        /*
         * Invalidate any other SPBs affected by the fact that this window
         * and its children are being made visible.
         */
        SpbCheckPwnd(pwndLock);
    }

    GreUnlockDisplay(gpDispInfo->hDev);
    zzzEndDeferWinEventNotify();

    return TRUE;
}

/***************************************************************************\
* FindSpb
*
* Returns a pointer to the SPB structure associated with the specified
* window or NULL if there is no associated structure.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PSPB FindSpb(
    PWND pwnd)
{
    PSPB pspb;

    /*
     * Walk through the list of save popup bits looking for a match on
     * window handle.
     */
    for (pspb = gpDispInfo->pspbFirst; pspb != NULL; pspb = pspb->pspbNext) {

        if (pspb->spwnd == pwnd && !(pspb->flags & SPB_LOCKUPDATE))
            break;
    }

    return pspb;
}

/***************************************************************************\
* SpbCheck
*
* Modifies all of the save popup bits structures to reflect changes on the
* screen. This function walks through all of the DC's, and if the DC is
* dirty, then the dirty area is removed from the associated save popup bits
* structure.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID SpbCheck(VOID)
{
    PDCE pdce;
    RECT rcBounds;

    if (AnySpbs()) {

        GreLockDisplay(gpDispInfo->hDev);

        /*
         * Walk through all of the DC's, accumulating dirty areas.
         */
        for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

            /*
             * Only check valid cache entries...
             */
            if (pdce->DCX_flags & (DCX_INVALID | DCX_DESTROYTHIS))
                continue;

            SpbCheckDce(pdce);
        }

        /*
         * Subtact out DirectDraw dirty rect from all the SPB's. The call to
         * GreGetDirectDrawBounds will also reset the accumulated bounds.
         */
        if (GreGetDirectDrawBounds(gpDispInfo->hDev, &rcBounds)) {
            SpbCheckRect(NULL, &rcBounds, 0);
        }

        GreUnlockDisplay(gpDispInfo->hDev);
    }
}

/***************************************************************************\
* SpbCheckDce
*
* This function retrieves the dirty area of a DC and removes the area from
* the list of SPB structures. The DC is then marked as clean.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID SpbCheckDce(
    PDCE pdce)
{
    RECT rc;

    if (pdce->DCX_flags & DCX_REDIRECTED)
        return;

    /*
     * Query the dirty bounds rectangle.  Doing this clears the bounds
     * as well.
     */
    if (GreGetBounds(pdce->hdc, &rc, 0)) {

        if (pdce->pMonitor != NULL) {
            /*
             * Convert the bounds rect to screen coords.
             */
            OffsetRect(&rc, pdce->pMonitor->rcMonitor.left,
                    pdce->pMonitor->rcMonitor.top);
        }

        /*
         * Intersect the returned rectangle with the window rectangle
         * in case the guy was drawing outside his window
         */
        if (IntersectRect(&rc, &rc, &(pdce->pwndOrg)->rcWindow))
            SpbCheckRect(pdce->pwndOrg, &rc, pdce->DCX_flags);
    }
}

/***************************************************************************\
* SpbCheckRect
*
* This function removes the passed rectangle from the SPB structures which
* touch it.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID SpbCheckRect(
    PWND   pwnd,
    LPRECT lprc,
    DWORD  flags)
{
    PSPB pspb, pspbNext;

    /*
     * If this window isn't visible, we're done.
     */
    if (!IsVisible(pwnd))
        return;

    for (pspb = gpDispInfo->pspbFirst; pspb != NULL; pspb = pspbNext) {

        /*
         * Get the pointer to the next save popup bits structure now
         * in case SpbCheckRect2() frees the current one.
         */
        pspbNext = pspb->pspbNext;

        /*
         * In win3.1 they used to exit the function if this function
         * returned false.  This meant that if one of the spbs was freed
         * the rest of the spbs would not be invalidated.
         */
        SpbCheckRect2(pspb, pwnd, lprc, flags);
    }
}

/***************************************************************************\
* SpbCheckPwnd
*
* This routine checks to see if the window rectangle of PWND affects any SPBs.
* It is called if pwnd or its children are being hidden or shown without
* going through WinSetWindowPos().
*
* Any SPBs for children of pwnd are destroyed.
*
* It must be called while pwnd is still visible.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID SpbCheckPwnd(
    PWND pwnd)
{
    PSPB pspb;
    PWND pwndSpb;
    PSPB pspbNext;

    /*
     * First blow away any SPBs owned by this window or its children.
     */
    for (pspb = gpDispInfo->pspbFirst; pspb != NULL; pspb = pspbNext) {

        /*
         * Get pspbNext now in case we free the SPB
         */
        pspbNext = pspb->pspbNext;

        /*
         * If pspb->spwnd is == pwnd or a child of pwnd, then free the SPB
         */
        for (pwndSpb = pspb->spwnd; pwndSpb; pwndSpb = pwndSpb->spwndParent) {

            if (pwnd == pwndSpb)
                FreeSpb(pspb);
        }
    }

    /*
     * Then see if any other SPBs are affected...
     */
    if (gpDispInfo->pspbFirst != NULL) {
        SpbCheckRect(pwnd, &pwnd->rcWindow, 0);
    }
}

/***************************************************************************\
* FreeSpb
*
* This function deletes the bitmap and region assocaited with a save popup
* bits structure and then unlinks and destroys the spb structure itself.
*
* History:
* 18-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID FreeSpb(
    PSPB pspb)
{
    PSPB *ppspb;
    PDCE pdce;

    if (pspb == NULL)
        return;

    /*
     * Delete the bitmap.  If saved in screen memory, make special call.
     */
    if (pspb->flags & SPB_SAVESCREENBITS) {
        GreSaveScreenBits(gpDispInfo->hDev, SS_FREE, pspb->ulSaveId, NULL);
    } else if (pspb->hbm != NULL) {
        GreDeleteObject(pspb->hbm);
    }

    /*
     * Destroy the region.
     */
    if (pspb->hrgn != NULL){
        GreDeleteObject(pspb->hrgn);
    }

    /*
     * Forget that there is an attached SPB.
     */
    if (pspb->spwnd != NULL) {
        ClrWF(pspb->spwnd, WFHASSPB);
        Unlock(&pspb->spwnd);
    }

    /*
     * Unlink the spb.
     */
    ppspb = &gpDispInfo->pspbFirst;
    while (*ppspb != pspb) {
        ppspb = &(*ppspb)->pspbNext;
    }

    *ppspb = pspb->pspbNext;

    /*
     * Free the save popup bits structure.
     */
    UserFreePool(pspb);

    /*
     * If we no longer have any SPBs then turn off window MGR
     * bounds collection.
     */
    if (!AnySpbs()) {

        GreLockDisplay(gpDispInfo->hDev);

        /*
         * Reset the dirty areas of all of the DC's.  NULL means reset.
         */
        for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

            if (pdce->DCX_flags & DCX_REDIRECTED)
                continue;

            GreGetBounds(pdce->hdc, NULL, GGB_DISABLE_WINMGR);
        }

        GreUnlockDisplay(gpDispInfo->hDev);
    }

}

/***************************************************************************\
* FreeAllSpbs
*
* This function deletes all spb-bitmaps.
*
* History:
* 07-Oct-1995 ChrisWil  Ported from Chicago.
\***************************************************************************/

VOID FreeAllSpbs(void)
{

    while(AnySpbs()) {
        FreeSpb(gpDispInfo->pspbFirst);
    }

    gpDispInfo->pspbFirst = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\snapshot.c ===
/****************************** Module Header ******************************\
* Module Name: snapshot.c
*
* Screen/Window SnapShotting Routines
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 26-Nov-1991 DavidPe   Ported from Win 3.1 sources
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxSnapWindow
*
* Effects: Snaps either the desktop hwnd or the active front most window. If
* any other window is specified, we will snap it but it will be clipped.
*
\***************************************************************************/

BOOL xxxSnapWindow(
    PWND pwnd)
{
    PTHREADINFO    ptiCurrent;
    RECT           rc;
    HDC            hdcScr = NULL;
    HDC            hdcMem = NULL;
    BOOL           fRet;
    HBITMAP        hbmOld;
    HBITMAP        hbm;
    HANDLE         hPal;
    LPLOGPALETTE   lppal;
    int            palsize;
    int            iFixedPaletteEntries;
    BOOL           fSuccess;
    PWND           pwndT;
    TL             tlpwndT;
    PWINDOWSTATION pwinsta;
    TL             tlpwinsta;

    CheckLock(pwnd);
    UserAssert(pwnd);

    ptiCurrent = PtiCurrent();

    /*
     * If this is a thread of winlogon, don't do the snapshot.
     */
    if (GetCurrentProcessId() == gpidLogon)
        return FALSE;

    /*
     * Get the affected windowstation
     */
    if (!NT_SUCCESS(ReferenceWindowStation(
            PsGetCurrentThread(),
            NULL,
            WINSTA_READSCREEN,
            &pwinsta,
            TRUE)) ||
            pwinsta->dwWSF_Flags & WSF_NOIO) {
        return FALSE;
    }

    /*
     * If the window is on another windowstation, do nothing
     */
    if (pwnd->head.rpdesk->rpwinstaParent != pwinsta)
        return FALSE;

    /*
     * Get the parent of any child windows.
     */
    while ((pwnd != NULL) && TestWF(pwnd, WFCHILD)) {
        pwnd = pwnd->spwndParent;
    }

    /*
     * Lock the windowstation before we leave the critical section
     */
    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    /*
     * Open the clipboard and empty it.
     *
     * pwndDesktop is made the owner of the clipboard, instead of the
     * currently active window; -- SANKAR -- 20th July, 1989 --
     */
    pwndT = ptiCurrent->rpdesk->pDeskInfo->spwnd;
    ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);
    fSuccess = xxxOpenClipboard(pwndT, NULL);
    ThreadUnlock(&tlpwndT);

    if (!fSuccess) {
        ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
        return FALSE;
    }

    xxxEmptyClipboard(pwinsta);

    /*
     * Use the whole window.
     */
    CopyRect(&rc, &pwnd->rcWindow);

    /*
     * Only snap what is on the screen.
     */
    if (!IntersectRect(&rc, &rc, &gpDispInfo->rcScreen)) {
        fRet = FALSE;
        goto SnapExit;
    }

    rc.right -= rc.left;
    rc.bottom -= rc.top;

    /*
     * Figure out how far offset from window origin visible part is
     */
    if (pwnd != PWNDDESKTOP(pwnd)) {
        rc.left -= pwnd->rcWindow.left;
        rc.top -= pwnd->rcWindow.top;
    }

    /*
     * Get the entire window's DC.
     */
    hdcScr = _GetWindowDC(pwnd);
    if (!hdcScr)
        goto MemoryError;

    /*
     * Create the memory DC.
     */
    hdcMem = GreCreateCompatibleDC(hdcScr);
    if (!hdcMem)
        goto MemoryError;

    /*
     * Create the destination bitmap.  If it fails, then attempt
     * to create a monochrome bitmap.
     * Did we have enough memory?
     */

    if (SYSMET(SAMEDISPLAYFORMAT)) {
        hbm = GreCreateCompatibleBitmap(hdcScr, rc.right, rc.bottom);
    } else {
        hbm = GreCreateBitmap(rc.right, rc.bottom, 1, gpDispInfo->BitCountMax, NULL);
    }

    if (!hbm) {
        hbm = GreCreateBitmap(rc.right, rc.bottom, 1, 1, NULL);
        if (!hbm)
            goto MemoryError;
    }

    /*
     * Select the bitmap into the memory DC.
     */
    hbmOld = GreSelectBitmap(hdcMem, hbm);

    /*
     * Snap!!!
     * Check the return value because the process taking the snapshot
     * may not have access to read the screen.
     */
    fRet = GreBitBlt(hdcMem, 0, 0, rc.right, rc.bottom, hdcScr, rc.left, rc.top, SRCCOPY | CAPTUREBLT, 0);

    /*
     * Restore the old bitmap into the memory DC.
     */
    GreSelectBitmap(hdcMem, hbmOld);

    /*
     * If the blt failed, leave now.
     */
    if (!fRet)
        goto SnapExit;

    _SetClipboardData(CF_BITMAP, hbm, FALSE, TRUE);

    /*
     * If this is a palette device, let's throw the current system palette
     * into the clipboard also.  Useful if the user just snapped a window
     * containing palette colors...
     */
    if (TEST_PUSIF(PUSIF_PALETTEDISPLAY)) {

        int i;
        int iPalSize;

        palsize = GreGetDeviceCaps(hdcScr, SIZEPALETTE);

        /*
         * Determine the number of system colors.
         */
        if (GreGetSystemPaletteUse(hdcScr) == SYSPAL_STATIC)
            iFixedPaletteEntries = GreGetDeviceCaps(hdcScr, NUMRESERVED);
        else
            iFixedPaletteEntries = 2;

        lppal = (LPLOGPALETTE)UserAllocPoolWithQuota(
                (LONG)(sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * palsize),
                TAG_CLIPBOARD);

        if (lppal != NULL) {
            lppal->palVersion = 0x300;
            lppal->palNumEntries = (WORD)palsize;

            if (GreGetSystemPaletteEntries(hdcScr,
                                           0,
                                           palsize,
                                           lppal->palPalEntry)) {

                iPalSize = palsize - iFixedPaletteEntries / 2;

                for (i = iFixedPaletteEntries / 2; i < iPalSize; i++) {

                    /*
                     * Any non system palette enteries need to have the NOCOLLAPSE
                     * flag set otherwise bitmaps containing different palette
                     * indices but same colors get messed up.
                     */
                    lppal->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
                }

                if (hPal = GreCreatePalette(lppal))
                    _SetClipboardData(CF_PALETTE, hPal, FALSE, TRUE);
            }

            UserFreePool(lppal);
        }
    }
    PlayEventSound(USER_SOUND_SNAPSHOT);

    fRet = TRUE;

SnapExit:

    /*
     * Release the window/client DC.
     */
     if (hdcScr) {
         _ReleaseDC(hdcScr);
     }

    xxxCloseClipboard(pwinsta);
    Unlock(&pwinsta->spwndClipOwner);

    /*
     * Delete the memory DC.
     */
    if (hdcMem) {
        GreDeleteDC(hdcMem);
    }

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    return fRet;

MemoryError:
    /*
     * Display an error message box.
     */
    ClientNoMemoryPopup();
    fRet = FALSE;
    goto SnapExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\srvhook.c ===
/****************************** Module Header ******************************\
* Module Name: srvhook.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Server side of hook calls and callbacks.
*
* 05-09-91 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

LRESULT fnHkINLPCBTCREATESTRUCT(UINT msg, WPARAM wParam, LPCBT_CREATEWND pcbt,
    PROC xpfnProc, BOOL bAnsi);

/***************************************************************************\
* xxxHkCallHook
*
* This is the server-side stub that calls to the client to call the actual
* hook function.
*
* History:
* 05-09-91 ScottLu      Rewrote to make all hooks work client/server!
* 01-28-91 DavidPe      Created.
\***************************************************************************/

LRESULT xxxHkCallHook(
    PHOOK phk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT nRet;
    PROC pfnHk, pfnHookProc;
    PPFNCLIENT ppfnClient;
    PCWPSTRUCTEX pcwp;
    PCWPRETSTRUCTEX pcwpret;
    PCLIENTINFO pci;
    ULONG_PTR dwHookData;
    ULONG_PTR dwFlags;
    struct tagSMS *psms;
#ifdef LATER
    /*
     * WindowsBug 246329
     * The code was supposed to prevent the backdoor
     * for the surprise foreground change.
     * However, the implementation below locks the
     * entire system, preventing the legit, expected
     * foreground change too. It's obvious on MP systems.
     * E.g. in the case global hooks such as
     * GETMESSAGEHOOK are installed, the chances are
     * pretty high.
     * For this time being, instead of making the lock
     * per process or per thread, we decided to simply
     * disable the foreground lock during the hook
     * callback.
     */
    TL tlSFWLock;
    BOOL fLockForeground;
#endif

    DbgValidateHooks(phk, phk->iHook);
    /*
     * Only low level hooks are allowed in the RIT context.
     * Also asssert that the hook is not destroyed
     */
#ifdef REDIRECTION
    UserAssert((PtiCurrent() != gptiRit)
               || (phk->iHook == WH_MOUSE_LL)
               || (phk->iHook == WH_KEYBOARD_LL)
               || (phk->iHook == WH_HITTEST));
#else
    UserAssert((PtiCurrent() != gptiRit)
               || (phk->iHook == WH_MOUSE_LL)
               || (phk->iHook == WH_KEYBOARD_LL));
#endif // REDIRECTION

    /*
     * While we're still inside the critical section make sure the
     * hook hasn't been 'freed'.  If so just return 0.
     */
    if (phk->offPfn != 0) {
        pfnHookProc = PFNHOOK(phk);
    } else {
        return 0;
    }

    ppfnClient = (phk->flags & HF_ANSI) ? &gpsi->apfnClientA :
            &gpsi->apfnClientW;

#ifdef LATER    // per 246329
    /*
     * LATER5.0 GerardoB. This might generate some hate reactions but I'm
     *  not sure we want people hooking just to steal the foreground.
     * Prevent hookprocs from other processes from switching the foreground
     */
    fLockForeground = (GETPTI(phk)->ppi != PpiCurrent());
    if (fLockForeground) {
        ThreadLockSFWLockCount(&tlSFWLock);
    }
#endif

    switch(phk->iHook) {
    case WH_CALLWNDPROC:
    case WH_CALLWNDPROCRET:
       if (phk->iHook == WH_CALLWNDPROC) {
          pcwp = (PCWPSTRUCTEX)lParam;
          psms = pcwp->psmsSender;
       } else {
          pcwpret = (PCWPRETSTRUCTEX)lParam;
          psms = pcwpret->psmsSender;
       }

        /*
         * If the sender has died or timed out, don't call the
         * hook because any memory the message points to may be invalid.
         */
        if (psms != NULL && (psms->flags & (SMF_SENDERDIED | SMF_REPLY))) {
            nRet = 0;
            break;
        }

        /*
         * This is the hardest of the hooks because we need to thunk through
         * the message hooks in order to deal with synchronously sent messages
         * that point to structures - to get the structures passed across
         * alright, etc.
         *
         * This will call a special client-side routine that'll rebundle the
         * arguments and call the hook in the right format.
         *
         * Currently, the message thunk callbacks to the client-side don't take
         * enough parameters to pass wParam (which == fInterThread send msg).
         * To do this, call one of two functions.
         */
        pci = GetClientInfo();
        if (phk->iHook == WH_CALLWNDPROC) {
            pfnHk = ppfnClient->pfnHkINLPCWPSTRUCT;
        } else {
            pfnHk = ppfnClient->pfnHkINLPCWPRETSTRUCT;
            pci->dwHookData = pcwpret->lResult;
        }

        /*
         * Save current hook state.
         */
        dwFlags = pci->CI_flags & CI_INTERTHREAD_HOOK;
        dwHookData = pci->dwHookData;

        if (wParam) {
            pci->CI_flags |= CI_INTERTHREAD_HOOK;
        } else {
            pci->CI_flags &= ~CI_INTERTHREAD_HOOK;
        }

        if (phk->iHook == WH_CALLWNDPROC) {
           nRet = ScSendMessageSMS(
               PW(pcwp->hwnd),
               pcwp->message,
               pcwp->wParam,
               pcwp->lParam,
               (ULONG_PTR)pfnHookProc, pfnHk,
               (phk->flags & HF_ANSI) ?
                       (SCMS_FLAGS_ANSI|SCMS_FLAGS_INONLY) :
                       SCMS_FLAGS_INONLY,
               psms);
        } else {
            nRet = ScSendMessageSMS(
                PW(pcwpret->hwnd),
                pcwpret->message,
                pcwpret->wParam,
                pcwpret->lParam,
                (ULONG_PTR)pfnHookProc, pfnHk,
                (phk->flags & HF_ANSI) ?
                        (SCMS_FLAGS_ANSI|SCMS_FLAGS_INONLY) :
                        SCMS_FLAGS_INONLY,
                psms);
        }
        /*
         * Restore previous hook state.
         */
        pci->CI_flags ^= ((pci->CI_flags ^ dwFlags) & CI_INTERTHREAD_HOOK);
        pci->dwHookData = dwHookData;
        break;
    case WH_CBT:
        /*
         * There are many different types of CBT hooks!
         */
        switch(nCode) {
        case HCBT_CLICKSKIPPED:
            goto MouseHook;
            break;

        case HCBT_CREATEWND:
            /*
             * This hook type points to a CREATESTRUCT, so we need to
             * be fancy with it's thunking, because a CREATESTRUCT contains
             * a pointer to CREATEPARAMS which can be anything...  so
             * funnel this through our message thunks.
             */
            nRet = fnHkINLPCBTCREATESTRUCT(
                    MAKELONG((WORD)nCode, (WORD)phk->iHook),
                    wParam,
                    (LPCBT_CREATEWND)lParam,
                    pfnHookProc,
                    (phk->flags & HF_ANSI) ? TRUE : FALSE);
            break;

#ifdef REDIRECTION
        case HCBT_GETCURSORPOS:

            /*
             * This hook type points to a POINT structure, so it's pretty
             * simple.
             */
            nRet = fnHkINLPPOINT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    wParam, (LPPOINT)lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook);
            break;
#endif // REDIRECTION

        case HCBT_MOVESIZE:

            /*
             * This hook type points to a RECT structure, so it's pretty
             * simple.
             */
            nRet = fnHkINLPRECT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    wParam, (LPRECT)lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook);
            break;

        case HCBT_ACTIVATE:
            /*
             * This hook type points to a CBTACTIVATESTRUCT
             */
            nRet = fnHkINLPCBTACTIVATESTRUCT(MAKELONG((UINT)nCode,
                    (UINT)phk->iHook), wParam, (LPCBTACTIVATESTRUCT)lParam,
                    (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook);
            break;

        default:

            /*
             * The rest of the cbt hooks are all dword parameters.
             */
            nRet = fnHkINDWORD(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    wParam, lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook, &phk->flags);
            break;
        }
        break;

    case WH_FOREGROUNDIDLE:
        /*
         * These are dword parameters and are therefore real easy.
         *
         */
        nRet = fnHkINDWORD(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook, &phk->flags);
        break;

    case WH_SHELL:

        if (nCode == HSHELL_GETMINRECT) {
            /*
             * This hook type points to a RECT structure, so it's pretty
             * simple.
             */
            nRet = fnHkINLPRECT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    wParam, (LPRECT)lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook);
            break;
        }

        /*
         * Otherwise fall through to the simple case of DWORD below
         */

    case WH_KEYBOARD:
        /*
         * These are dword parameters and are therefore real easy.
         */
        nRet = fnHkINDWORD(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook, &phk->flags);
        break;

    case WH_MSGFILTER:
    case WH_SYSMSGFILTER:
    case WH_GETMESSAGE:
        /*
         * These take an lpMsg as their last parameter.  Since these are
         * exclusively posted parameters, and since nowhere on the server
         * do we post a message with a pointer to some other structure in
         * it, the lpMsg structure contents can all be treated verbatim.
         */
        nRet = fnHkINLPMSG(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPMSG)lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook,
                (phk->flags & HF_ANSI) ? TRUE : FALSE, &phk->flags);
        break;

    case WH_JOURNALPLAYBACK:

#ifdef HOOKBATCH
        /*
         * If this hook has cached playback info then we need to grab
         * the info out of the cache.
         */

        if (phk->cEventMessages) {
            if (nCode == HC_GETNEXT) {
                LPEVENTMSG pEventMsg;
                pEventMsg = (LPEVENTMSG)lParam;

                if (phk->flags & HF_NEEDHC_SKIP)
                    phk->iCurrentEvent++;

                if (phk->iCurrentEvent < phk->cEventMessages) {
                    *pEventMsg = phk->aEventCache[phk->iCurrentEvent];
                } else {

                    /*
                     * Free the cache set if it is still around
                     */
                    if (phk->aEventCache) {
                        UserFreePool(phk->aEventCache);
                        phk->aEventCache = NULL;
                    }
                    phk->cEventMessages = 0;
                    phk->iCurrentEvent = 0;

                    goto MakeClientJournalPlaybackCall;
                }

                /*
                 * Return the time and zero the batched time so if we sleep
                 * this time we won't sleep again next time
                 */
                nRet = pEventMsg->time;
                if (nRet)
                    phk->aEventCache[phk->iCurrentEvent].time = 0;
            } else if (nCode == HC_SKIP) {
                phk->iCurrentEvent++;
                nRet = 0;
            }

        } else {
#endif // HOOKBATCH
            /*
             * In order to avoid a client/server transition for HC_SKIP we
             * piggy-back it on top of the next journal playback event and
             * send it from there.
             */
// MakeClientJournalPlaybackCall:
            nRet = fnHkOPTINLPEVENTMSG(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                    (WPARAM)PtoHq(phk), (LPEVENTMSG)lParam, (ULONG_PTR)pfnHookProc,
                    ppfnClient->pfnDispatchHook);
#ifdef HOOKBATCH
        }

        /*
         * Determine if we received a cached set of events if so then store
         * them away off of the hook.
         * paramL will be the number of events.
         * paramH will be the array of events.
         */
        if ((nCode == HC_GETNEXT) && (((LPEVENTMSG)lParam)->message == 0x12341234)) {
            NTSTATUS Status;
            LPEVENTMSG pEventMsg = (LPEVENTMSG)lParam;

            /*
             * We should not be getting another cached set if we aren't
             * done with the first set
             */
            UserAssert((phk->cEventMessages == 0) ||
                    (phk->cEventMessages >= phk->iCurrentEvent));
            UserAssert((pEventMsg->paramL < 500) && (pEventMsg->paramL > 1));

            /*
             * Free the last cache set if it is still around
             */
            if (phk->aEventCache) {
                UserFreePool(phk->aEventCache);
                phk->aEventCache = NULL;
            }

            if (phk->aEventCache = LocalAlloc(LPTR,
                    pEventMsg->paramL*sizeof(EVENTMSG))) {
                PETHREAD Thread = PsGetCurrentThread();

                Status = ZwReadVirtualMemory(Thread->Process->ProcessHandle,
                        (PVOID)pEventMsg->paramH, phk->aEventCache,
                        pEventMsg->paramL*sizeof(EVENTMSG), NULL);

                if (NT_SUCCESS(Status)) {
                    phk->cEventMessages = pEventMsg->paramL;
                    phk->iCurrentEvent = 0;

                    /*
                     * Fill in the real EventMsg for this message
                     */
                    *pEventMsg = phk->aEventCache[0];
                    phk->aEventCache[0].time = 0;
                }

            } else {
                phk->cEventMessages = 0;
                phk->iCurrentEvent = 0;
            }
        }
#endif // HOOKBATCH

        phk->flags &= ~HF_NEEDHC_SKIP;
        break;

    case WH_JOURNALRECORD:

        nRet = fnHkOPTINLPEVENTMSG(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPEVENTMSG)lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook);
        break;

    case WH_DEBUG:
        /*
         * This takes an lpDebugHookStruct.
         */
        nRet = fnHkINLPDEBUGHOOKSTRUCT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPDEBUGHOOKINFO)lParam, (ULONG_PTR)pfnHookProc,
                ppfnClient->pfnDispatchHook);
        break;

    case WH_KEYBOARD_LL:
        /*
         * This takes an lpKbdHookStruct.
         */
        nRet = fnHkINLPKBDLLHOOKSTRUCT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPKBDLLHOOKSTRUCT)lParam,
                (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook);
        break;

    case WH_MOUSE_LL:
        /*
         * This takes an lpMsllHookStruct.
         */
        nRet = fnHkINLPMSLLHOOKSTRUCT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPMSLLHOOKSTRUCT)lParam,
                (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook);
        break;

    case WH_MOUSE:
        /*
         * This takes an lpMouseHookStructEx.
         */
MouseHook:
        nRet = fnHkINLPMOUSEHOOKSTRUCTEX(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPMOUSEHOOKSTRUCTEX)lParam,
                (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook, &phk->flags);
        break;

#ifdef REDIRECTION
    case WH_HITTEST:
        /*
         * This takes an lpHTHookStruct.
         */
        nRet = fnHkINLPHTHOOKSTRUCT(MAKELONG((UINT)nCode, (UINT)phk->iHook),
                wParam, (LPHTHOOKSTRUCT)lParam,
                (ULONG_PTR)pfnHookProc, ppfnClient->pfnDispatchHook);
        break;
#endif // REDIRECTION

    }

#ifdef LATER    // per 246329
    if (fLockForeground) {
        ThreadUnlockSFWLockCount(&tlSFWLock);
    }
#endif

    return nRet;
}

/***************************************************************************\
* fnHkINLPCWPEXSTRUCT
*
* This gets thunked through the message thunks, so it has the format
* of a c/s message thunk call.
*
* 05-09-91 ScottLu      Created.
\***************************************************************************/

LRESULT fnHkINLPCWPEXSTRUCT(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    CWPSTRUCTEX cwp;
    PCLIENTINFO pci = GetClientInfo();

    UNREFERENCED_PARAMETER(xParam);

    cwp.hwnd = HW(pwnd);
    cwp.message = message;
    cwp.wParam = wParam;
    cwp.lParam = lParam;
    cwp.psmsSender = NULL;

    return xxxCallNextHookEx(HC_ACTION, (pci->CI_flags & CI_INTERTHREAD_HOOK) != 0,
            (LPARAM)&cwp);
}

LRESULT fnHkINLPCWPRETEXSTRUCT(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam)
{
    CWPRETSTRUCTEX cwp;
    PCLIENTINFO pci = GetClientInfo();

    UNREFERENCED_PARAMETER(xParam);

    cwp.hwnd = HW(pwnd);
    cwp.message = message;
    cwp.wParam = wParam;
    cwp.lParam = lParam;
    cwp.lResult = pci->dwHookData;
    cwp.psmsSender = NULL;

    return xxxCallNextHookEx(HC_ACTION, (pci->CI_flags & CI_INTERTHREAD_HOOK) != 0,
            (LPARAM)&cwp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\srvmsg.c ===
/****************************** Module Header ******************************\
* Module Name: srvmsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Includes the mapping table for messages when calling the client.
*
* 04-11-91 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define SfnDDEINIT               SfnDWORD
#define SfnKERNELONLY            SfnDWORD

#ifdef FE_SB
/*
 * SfnEMGETSEL, SfnSETSEL, SfnGBGETEDITSEL
 */
#define SfnEMGETSEL              SfnOPTOUTLPDWORDOPTOUTLPDWORD
#define SfnEMSETSEL              SfnDWORD
#define SfnCBGETEDITSEL          SfnOPTOUTLPDWORDOPTOUTLPDWORD
#endif // FE_SB

#define MSGFN(func) Sfn ## func
#define FNSCSENDMESSAGE SFNSCSENDMESSAGE
#include <messages.h>

/***************************************************************************\
* fnINLBOXSTRING
*
* Takes a lbox string - a string that treats lParam as a string pointer or
* a DWORD depending on LBS_HASSTRINGS and ownerdraw.
*
* 04-12-91 ScottLu      Created.
\***************************************************************************/

LRESULT SfnINLBOXSTRING(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    DWORD dw;

    /*
     * See if the control is ownerdraw and does not have the LBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */
    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }
    dw = pwnd->style;

    if (!(dw & LBS_HASSTRINGS) &&
            (dw & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE))) {

        /*
         * Treat lParam as a dword.
         */
        return SfnDWORD(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
    }

    /*
     * Treat as a string pointer.   Some messages allowed or had certain
     * error codes for NULL so send them through the NULL allowed thunk.
     * Ventura Publisher does this
     */
    switch (msg) {
        default:
            return SfnINSTRING(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
            break;

        case LB_FINDSTRING:
            return SfnINSTRINGNULL(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
            break;
    }
}


/***************************************************************************\
* SfnOUTLBOXSTRING
*
* Returns an lbox string - a string that treats lParam as a string pointer or
* a DWORD depending on LBS_HASSTRINGS and ownerdraw.
*
* 04-12-91 ScottLu      Created.
\***************************************************************************/

LRESULT SfnOUTLBOXSTRING(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    DWORD dw;
    BOOL bNotString;
    DWORD dwRet;
    TL tlpwnd;

    /*
     * See if the control is ownerdraw and does not have the LBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */
    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }
    dw = pwnd->style;

    /*
     * See if the control is ownerdraw and does not have the LBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */
    bNotString =  (!(dw & LBS_HASSTRINGS) &&
            (dw & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)));

    /*
     * Make this special call which'll know how to copy this string.
     */
    ThreadLock(pwnd, &tlpwnd);
    dwRet = ClientGetListboxString(pwnd, msg, wParam,
            (PLARGE_UNICODE_STRING)lParam,
            xParam, xpfn, dwSCMSFlags, bNotString, psms);
    ThreadUnlock(&tlpwnd);
    return dwRet;
}


/***************************************************************************\
* fnINCBOXSTRING
*
* Takes a lbox string - a string that treats lParam as a string pointer or
* a DWORD depending on CBS_HASSTRINGS and ownerdraw.
*
* 04-12-91 ScottLu      Created.
\***************************************************************************/

LRESULT SfnINCBOXSTRING(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    DWORD dw;

    /*
     * See if the control is ownerdraw and does not have the CBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */
    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }
    dw = pwnd->style;

    if (!(dw & CBS_HASSTRINGS) &&
            (dw & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))) {

        /*
         * Treat lParam as a dword.
         */
        return SfnDWORD(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
    }

    /*
     * Treat as a string pointer.   Some messages allowed or had certain
     * error codes for NULL so send them through the NULL allowed thunk.
     * Ventura Publisher does this
     */
    switch (msg) {
        default:
            return SfnINSTRING(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
            break;

        case CB_FINDSTRING:
            return SfnINSTRINGNULL(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
            break;
    }
}


/***************************************************************************\
* fnOUTCBOXSTRING
*
* Returns an lbox string - a string that treats lParam as a string pointer or
* a DWORD depending on CBS_HASSTRINGS and ownerdraw.
*
* 04-12-91 ScottLu      Created.
\***************************************************************************/

LRESULT SfnOUTCBOXSTRING(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    DWORD dw;
    BOOL bNotString;
    DWORD dwRet;
    TL tlpwnd;

    /*
     * See if the control is ownerdraw and does not have the CBS_HASSTRINGS
     * style.  If so, treat lParam as a DWORD.
     */

    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }
    dw = pwnd->style;

    bNotString = (!(dw & CBS_HASSTRINGS) &&
            (dw & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)));

    /*
     * Make this special call which'll know how to copy this string.
     */
    ThreadLock(pwnd, &tlpwnd);
    dwRet = ClientGetListboxString(pwnd, msg, wParam,
            (PLARGE_UNICODE_STRING)lParam,
            xParam, xpfn, dwSCMSFlags, bNotString, psms);
    ThreadUnlock(&tlpwnd);
    return dwRet;
}


/***************************************************************************\
* fnPOWERBROADCAST
*
* Make sure we send the correct message when we resume.
*
* History:
* 02-Dec-1996 JerrySh   Created.
* 26-Nov-2001 JasonSch  Added code to validate pwnd.
\***************************************************************************/
LRESULT SfnPOWERBROADCAST(
    PWND pwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR xParam,
    PROC xpfn,
    DWORD dwSCMSFlags,
    PSMS psms)
{
    if (!RevalidateHwnd(HW(pwnd))) {
        return 0L;
    }

    switch (wParam) {
    case PBT_APMQUERYSUSPEND:
        SetWF(pwnd, WFGOTQUERYSUSPENDMSG);
        break;
    case PBT_APMQUERYSUSPENDFAILED:
        if (!TestWF(pwnd, WFGOTQUERYSUSPENDMSG))
            return 0;
        ClrWF(pwnd, WFGOTQUERYSUSPENDMSG);
        break;
    case PBT_APMSUSPEND:
        ClrWF(pwnd, WFGOTQUERYSUSPENDMSG);
        SetWF(pwnd, WFGOTSUSPENDMSG);
        break;
    case PBT_APMRESUMESUSPEND:
        if (TestWF(pwnd, WFGOTSUSPENDMSG)) {
            break;
        }
        wParam = PBT_APMRESUMECRITICAL;
        // FALL THRU
    case PBT_APMRESUMECRITICAL:
        ClrWF(pwnd, WFGOTQUERYSUSPENDMSG);
        ClrWF(pwnd, WFGOTSUSPENDMSG);
        break;
    }

    return SfnDWORD(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\ssend.c ===
/****************************** Module Header ******************************\
* Module Name: ssend.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Server side sending stubs
*
* 07-06-91 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CALLBACKPROC 1
#define SERVERSIDE 1

#include "callback.h"

#define SENDSIDE 1

#define CBBUFSIZE   512

#define PADSIZE     (sizeof(ULONG_PTR) - 1)

/*
 * Callback setup and control macros
 */
#define SMESSAGECALL(api) \
LRESULT Sfn ## api(      \
    PWND pwnd,           \
    UINT msg,            \
    WPARAM wParam,       \
    LPARAM lParam,       \
    ULONG_PTR xParam,     \
    PROC xpfnProc,       \
    DWORD dwSCMSFlags,   \
    PSMS psms)

#define SETUP(api)  \
    api ## MSG m;                                           \
    api ## MSG *mp = &m;                                    \
    BYTE Buffer[CBBUFSIZE];                                 \
    PCALLBACKSTATUS pcbs;                                   \
    ULONG cbCBStatus;                                       \
    ULONG_PTR retval;                                        \
    NTSTATUS Status;

#define SETUPDC(api)  \
    SETUP(api)                         \
    int iDC = 0;                       \
    HDC     hdcUse;                    \
    HBITMAP hbmDCGray = NULL;


#define SETUPPWND(api) \
    api ## MSG m;                                               \
    api ## MSG *mp = &m;                                        \
    BYTE Buffer[CBBUFSIZE];                                     \
    PCALLBACKSTATUS pcbs;                                       \
    ULONG cbCBStatus;                                           \
    ULONG_PTR retval;                                           \
    NTSTATUS Status;                                            \
    TL tlpwnd;                                                  \
    CALLBACKWND cbwin;                                          \
    PCLIENTINFO pci = PtiCurrent()->pClientInfo;                \
    PWND pwndClient = pwnd ? (PWND)((PBYTE)pwnd - pci->ulClientDelta) : NULL; \
    UserAssert(pci->ulClientDelta != 0);

#define CALC_SIZE_IN(cb, pstr) \
    cb = (pstr)->Length + sizeof(WCHAR);  \
    if ((pstr)->bAnsi && !fAnsiReceiver)  \
        cb *= sizeof(WCHAR);

#define CALC_SIZE_OUT(cb, pstr) \
    cb = (pstr)->MaximumLength + sizeof(WCHAR); \
    if ((pstr)->bAnsi && !fAnsiReceiver)        \
        cb *= sizeof(WCHAR);

#ifdef FE_SB // CALC_SIZE_OUT_STRING()
#define CALC_SIZE_OUT_STRING(cb, pstr) \
    cb = (pstr)->MaximumLength + sizeof(WCHAR); \
    if (!(PtiCurrent()->TIF_flags & TIF_ANSILENGTH)) { \
        if ((pstr)->bAnsi && !fAnsiReceiver)           \
            cb *= sizeof(WCHAR);                       \
    }
#endif // FE_SB

#ifdef FE_SB // CALC_SIZE_STRING_OUT()
#define CALC_SIZE_STRING_OUT(cchText)                                                 \
    try {                                                                             \
        (cchText) = CalcOutputStringSize(pcbs,(cchText),fAnsiSender,fAnsiReceiver);   \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        (cchText) = 0; \
        MSGERROR(); \
    }
#endif // FE_SB

#define BEGINSEND(api) \
    mp = &m; \
    Buffer;  \
    {

#define BEGINSENDCAPTURE(api, cCapturePointers, cCaptureBytes, fInput) \
    if (cCapturePointers) {                             \
        mp = AllocCallbackMessage(sizeof(m),            \
                (cCapturePointers),                     \
                (cCaptureBytes),                        \
                Buffer,                                 \
                fInput);                                \
        if (mp == NULL)                                 \
            goto errorexitnofreemp;                     \
    } else {                                            \
        m.CaptureBuf.cbCallback = sizeof(m);            \
        m.CaptureBuf.cbCapture = 0;                     \
        m.CaptureBuf.cCapturedPointers = 0;             \
        mp = &m;                                        \
    }                                                   \
    {                                                   \
        PTHREADINFO ptiCurrent = PtiCurrent();          \
        TL tlPool;                                      \
                                                        \
        if (mp != &m && (PVOID)mp != (PVOID)Buffer)     \
            ThreadLockPool(ptiCurrent, mp, &tlPool);

#define BEGINSENDCAPTUREVOIDDC(api, cCapturePointers, cCaptureBytes, fInput)  \
    hdcUse = CreateCompatiblePublicDC(hdc,&hbmDCGray);                        \
    if (hdcUse == (HDC)NULL) {                                                \
        return;                                                               \
    }                                                                         \
    BEGINSENDCAPTURE(api, cCapturePointers, cCaptureBytes, fInput);           \

#define BEGINSENDCAPTUREDC(api, cCapturePointers, nCount, fInput)         \
    hdcUse = CreateCompatiblePublicDC(hdc,&hbmDCGray);                    \
    if (hdcUse == (HDC)NULL) {                                            \
        return FALSE;                                                     \
    }                                                                     \
    BEGINSENDCAPTURE(api, cCapturePointers, max(pstrSrc->MaximumLength,   \
    ((nCount + 1) * sizeof(WCHAR))), fInput);                             \
    

#define LOCKPWND() \
    ThreadLock(pwnd, &tlpwnd);                  \
    cbwin = pci->CallbackWnd;                   \
    pci->CallbackWnd.pwnd = pwndClient;         \
    pci->CallbackWnd.hwnd = HW(pwnd);           \
    pci->CallbackWnd.pActCtx = ((pwnd == NULL) ? NULL : pwnd->pActCtx);


#define UNLOCKPWND() \
    pci->CallbackWnd = cbwin;       \
    ThreadUnlock(&tlpwnd);

#define MAKECALL(api) \
    UserAssert(!(PtiCurrent()->TIF_flags & TIF_INCLEANUP)); \
    LeaveCrit();                                            \
    Status = KeUserModeCallback(                            \
        FI_ ## api,                                         \
        mp,                                                 \
        sizeof(*mp),                                        \
        &pcbs,                                              \
        &cbCBStatus);                                       \
    EnterCrit();

#define MAKECALLCAPTURE(api) \
    UserAssert(!(PtiCurrent()->TIF_flags & TIF_INCLEANUP)); \
    LeaveCrit();                                            \
    Status = (DWORD)KeUserModeCallback(                     \
        FI_ ## api,                                         \
        mp,                                                 \
        mp->CaptureBuf.cbCallback,                          \
        &pcbs,                                              \
        &cbCBStatus);                                       \
    EnterCrit();

#define MAKECALLCAPTUREDC(api)                              \
        iDC = GreSaveDC(hdc);                               \
        MAKECALLCAPTURE(api)                                \
        GreRestoreDC(hdc, iDC);                             \
        iDC = 0;                                            \
        if ((hdcUse != hdc) && NT_SUCCESS(Status)) {        \
            GreBitBlt(hdc,                                  \
                      0,                                    \
                      0,                                    \
                      gpDispInfo->cxGray,                   \
                      gpDispInfo->cyGray,                   \
                      hdcUse,                               \
                      0,                                    \
                      0,                                    \
                      SRCCOPY,                              \
                      0);                                   \
        }

#define CHECKRETURN() \
    if (!NT_SUCCESS(Status) ||                              \
            cbCBStatus != sizeof(*pcbs)) {                  \
        goto errorexit;                                     \
    }                                                       \
    try {                                                   \
        retval = ProbeAndReadStructure(&pcbs->retval, ULONG_PTR); \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }

#define ENDSEND(type, error) \
        return (type)retval;               \
        goto errorexit;                    \
    }                                      \
errorexit:                                 \
   return (type)error

#define CLEANUPSENDCAPTURECOMMONDC() \
   if(iDC) {                                                    \
       GreRestoreDC(hdc, iDC);                                  \
   }                                                            \
   if (hdcUse != hdc) {                                         \
       GreDeleteDC(hdcUse);                                     \
       GreDeleteObject(hbmDCGray);                              \
   }                                                            \

#define BEGIN_ENDSENDCAPTURE(type, error) \
exit:
#define _ENDSENDCAPTURE(type, error) \
        if (mp != &m && (PVOID)mp != (PVOID)Buffer) {           \
            if (mp->CaptureBuf.pvVirtualAddress) {              \
                NTSTATUS Status;                                \
                SIZE_T ulRegionSize = 0;                        \
                                                                \
                Status = ZwFreeVirtualMemory(NtCurrentProcess(),\
                        &mp->CaptureBuf.pvVirtualAddress,       \
                        &ulRegionSize,                          \
                        MEM_RELEASE);                           \
                UserAssert(NT_SUCCESS(Status));                 \
            }                                                   \
            ThreadUnlockAndFreePool(ptiCurrent, &tlPool);       \
        }                                                       \
        return (type)retval;                                    \
        goto errorexit;                                         \
    }                                                           \
errorexit:                                                      \
   retval = error;                                              \
   goto exit;                                                   \
errorexitnofreemp:
#define END_ENDSENDCAPTURE(type, error) \
       return (type)error


#define ENDSENDCAPTUREDC(type, error) \
        BEGIN_ENDSENDCAPTURE(type, error); \
        CLEANUPSENDCAPTURECOMMONDC(); \
        _ENDSENDCAPTURE(type, error); \
        CLEANUPSENDCAPTURECOMMONDC(); \
        END_ENDSENDCAPTURE(type, error)

#define ENDSENDCAPTURE(type, error) \
        BEGIN_ENDSENDCAPTURE(type, error); \
        _ENDSENDCAPTURE(type, error); \
        END_ENDSENDCAPTURE(type, error)


#ifdef FE_SB // ENDSENDCAPTUREOUTSTRING()
#define ENDSENDCAPTUREOUTSTRING(type, error) \
exit:                                                           \
        if (mp != &m && (PVOID)mp != (PVOID)Buffer) {           \
            if (mp->CaptureBuf.pvVirtualAddress) {              \
                NTSTATUS Status;                                \
                SIZE_T ulRegionSize = 0;                        \
                                                                \
                Status = ZwFreeVirtualMemory(NtCurrentProcess(),\
                        &mp->CaptureBuf.pvVirtualAddress,       \
                        &ulRegionSize,                          \
                        MEM_RELEASE);                           \
                UserAssert(NT_SUCCESS(Status));                 \
            }                                                   \
            ThreadUnlockAndFreePool(ptiCurrent, &tlPool);       \
        }                                                       \
        if (bInflateWParam)                                     \
            PtiCurrent()->TIF_flags &= ~TIF_ANSILENGTH;         \
        return (type)retval;                                    \
        goto errorexit;                                         \
    }                                                           \
errorexit:                                                      \
   retval = error;                                              \
   goto exit;                                                   \
errorexitnofreemp:                                              \
   if (bInflateWParam)                                          \
       PtiCurrent()->TIF_flags &= ~TIF_ANSILENGTH;              \
   return (type)error
#endif // FE_SB

#define BEGIN_ENDSENDCAPTUREVOID() \
errorexit:
#define _ENDSENDCAPTUREVOID() \
        if (mp != &m && (PVOID)mp != (PVOID)Buffer) {           \
            if (mp->CaptureBuf.pvVirtualAddress) {              \
                NTSTATUS Status;                                \
                SIZE_T ulRegionSize = 0;                        \
                                                                \
                Status = ZwFreeVirtualMemory(NtCurrentProcess(),\
                        &mp->CaptureBuf.pvVirtualAddress,       \
                        &ulRegionSize,                          \
                        MEM_RELEASE);                           \
                UserAssert(NT_SUCCESS(Status));                 \
            }                                                   \
            ThreadUnlockAndFreePool(ptiCurrent, &tlPool);       \
        }                                                       \
        return;                                                 \
    }                                                           \
errorexitnofreemp:
#define END_ENDSENDCAPTUREVOID() \
   return

#define ENDSENDCAPTUREVOIDDC() \
        BEGIN_ENDSENDCAPTUREVOID(); \
        CLEANUPSENDCAPTURECOMMONDC(); \
        _ENDSENDCAPTUREVOID(); \
        CLEANUPSENDCAPTURECOMMONDC(); \
        END_ENDSENDCAPTUREVOID()

#define ENDSENDCAPTUREVOID() \
        BEGIN_ENDSENDCAPTUREVOID(); \
        CLEANUPSENDCAPTURECOMMON(); \
        _ENDSENDCAPTUREVOID(); \
        CLEANUPSENDCAPTURECOMMON(); \
        END_ENDSENDCAPTUREVOID()


#define ENDSENDVOID() \
    }                 \
    return

#define MSGERROR() goto errorexit

#ifdef FE_SB // CHECKRETURN1() & ENDSEND1()
#define CHECKRETURN1() \
    if (!NT_SUCCESS(Status) ||                              \
            cbCBStatus != sizeof(*pcbs)) {                  \
        goto errorexit1;                                    \
    }                                                       \
    try {                                                   \
        retval = ProbeAndReadStructure(&pcbs->retval, ULONG_PTR); \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }

#define ENDSEND1(type, error) \
        return (type)retval;               \
        goto errorexit1;                   \
    }                                      \
errorexit1:                                \
   return (type)error

#define MSGERROR1() goto errorexit1
#endif // FE_SB

/*
 * Callback IN parameter macros
 */
#define MSGDATA() (mp)

#define COPYSTRUCTOPT(x) \
        MSGDATA()->p ## x = (p ## x); \
        if (p ## x) MSGDATA()->x = *(p ## x);

#define COPYCONSTRECTSTRUCTOPT(x) \
        MSGDATA()->p ## x = (LPRECT)(p ## x); \
        if (p ## x) MSGDATA()->x = *(p ## x);

#define COPYBYTES(p, cb) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf, p, cb, &mp->p))) \
        goto errorexit;

#define COPYBYTESOPT(p, cb) \
    if (p) {                                                                    \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf, p, cb, &mp->p)))   \
            goto errorexit;                                                     \
    } else {                                                                    \
        mp->p = NULL;                                                           \
    }

#define LARGECOPYBYTES(p, cb) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf, p, cb, &mp->p))) \
        goto errorexit;

#define LARGECOPYBYTES2(src, cb, dest) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf, src, cb, &mp->dest))) \
        goto errorexit;

#define COPYSTRING(s) \
    mp->s.Length = (p ## s)->Length;                                                \
    mp->s.MaximumLength = (p ## s)->MaximumLength;                                  \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                            \
                                        (p ## s)->Buffer,                           \
                                        (p ## s)->Length + sizeof(WCHAR),           \
                                        &mp->s.Buffer)))                            \
        goto errorexit;

#define COPYSTRINGOPT(s) \
    if (p ## s) {                                                                   \
        mp->s.Length = (p ## s)->Length;                                            \
        mp->s.MaximumLength = (p ## s)->MaximumLength;                              \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                        \
                                            (p ## s)->Buffer,                       \
                                            (p ## s)->Length + sizeof(WCHAR),       \
                                            &mp->s.Buffer)))                        \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->s.Length = 0;                                                           \
        mp->s.Buffer = NULL;                                                        \
    }

#define COPYSTRINGID(s) \
    mp->s.Length = (p ## s)->Length;                                                \
    mp->s.MaximumLength = (p ## s)->MaximumLength;                                  \
    if (mp->s.MaximumLength) {                                                      \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                        \
                                            (p ## s)->Buffer,                       \
                                            (p ## s)->Length + sizeof(WCHAR),       \
                                            &mp->s.Buffer)))                        \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->s.Buffer = (p ## s)->Buffer;                                            \
    }

#define LARGECOPYSTRINGLPWSTR(ps, psz) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                            \
                                        (ps)->Buffer,                               \
                                        (ps)->Length + sizeof(WCHAR),               \
                                        (PVOID *)&mp->psz)))                        \
        goto errorexit;

#define LARGECOPYSTRINGLPSTR(ps, psz) \
    if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                            \
                                        (ps)->Buffer,                               \
                                        (ps)->Length + 1,                           \
                                        (PVOID *)&mp->psz)))                        \
        goto errorexit;

#define LARGECOPYSTRINGLPWSTRA(ps, psz) \
    if (!NT_SUCCESS(CaptureAnsiCallbackData(&mp->CaptureBuf,                        \
                                        (ps)->Buffer,                               \
                                        ((ps)->Length / sizeof(WCHAR)) + 1,         \
                                        (PVOID *)&mp->psz)))                        \
        goto errorexit;

#define LARGECOPYSTRINGLPSTRW(ps, psz) \
    if (!NT_SUCCESS(CaptureUnicodeCallbackData(&mp->CaptureBuf,                     \
                                        (ps)->Buffer,                               \
                                        ((ps)->Length + 1) * sizeof(WCHAR),         \
                                        (PVOID *)&mp->psz)))                        \
        goto errorexit;                                                             \

#define LARGECOPYSTRINGLPWSTROPT(ps, psz) \
    if (ps) {                                                                       \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                        \
                                            (ps)->Buffer,                           \
                                            (ps)->Length + sizeof(WCHAR),           \
                                            (PVOID *)&mp->psz)))                    \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->psz = NULL;                                                             \
    }

#define LARGECOPYSTRINGLPSTROPT(ps, psz) \
    if (ps) {                                                                       \
        if (!NT_SUCCESS(CaptureCallbackData(&mp->CaptureBuf,                        \
                                            (ps)->Buffer,                           \
                                            (ps)->Length + sizeof(UCHAR),           \
                                            (PVOID *)&mp->psz)))                    \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->psz = NULL;                                                             \
    }

#define LARGECOPYSTRINGLPWSTROPTA(ps, psz) \
    if (ps) {                                                                       \
        if (!NT_SUCCESS(CaptureAnsiCallbackData(&mp->CaptureBuf,                    \
                                            (ps)->Buffer,                           \
                                            ((ps)->Length / sizeof(WCHAR)) + 1,     \
                                            (PVOID *)&mp->psz)))                    \
            goto errorexit;                                                         \
    } else {                                                                        \
        mp->psz = NULL;                                                             \
    }

/*
 * Wrappers to determine whether copy out should be done.
 */
#define BEGINCOPYOUT() \
    if ((psms == NULL || ((psms->flags & (SMF_SENDERDIED | SMF_REPLY)) == 0)) \
            && !(dwSCMSFlags & SCMS_FLAGS_INONLY)) {

#define ENDCOPYOUT() \
    }

/*
 * Callback OUT paramter macros
 */
#define OUTSTRUCT(pstruct, type) \
    try {                                                                   \
        *(pstruct) = ProbeAndReadStructure(((type *)pcbs->pOutput), type);  \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }

/*
 * flags field with mask (propagate back bits in mask only)
 */
#define OUTBITMASK(pstruct, type, mask) \
    try {                                                                   \
        type flags = ProbeAndReadStructure(((type *)pcbs->pOutput), type);  \
        COPY_FLAG(*(pstruct), flags, mask);                                 \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }

#ifdef FE_SB // COPYOUTLPWSTRLIMIT()
// should we insert IS_DBCS_ENABLED() in COPYOUTLPWSTRLIMIT ?
#define COPYOUTLPWSTRLIMIT(pstr, cch) \
    try {                                                                   \
        retval = CalcOutputStringSize(pcbs,(DWORD)retval,pstr->bAnsi,fAnsiReceiver); \
        CopyOutputString(pcbs, pstr, cch, fAnsiReceiver);                   \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }
#else
#define COPYOUTLPWSTRLIMIT(pstr, cch) \
    try {                                                                   \
        CopyOutputString(pcbs, pstr, cch, fAnsiReceiver);                   \
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) { \
        MSGERROR(); \
    }
#endif // FE_SB

#define RESERVEBYTES(cb, dest, cbdest) \
    if (!NT_SUCCESS(AllocateCallbackData(&mp->CaptureBuf,   \
            cb, (PVOID *)&mp->dest)))                       \
        goto errorexit;                                     \
    mp->cbdest = cb;

/***************************************************************************\
* AllocCallbackMessage
*
* Allocates a callback message from pool memory and reserves space
* for arguments to captured later.
*
* 03-13-95 JimA             Created.
\***************************************************************************/

PVOID AllocCallbackMessage(
    DWORD cbBaseMsg,
    DWORD cPointers,
    SIZE_T cbCapture,
    PBYTE pStackBuffer,
    BOOL fInput)
{
    PCAPTUREBUF pcb;

    if (cPointers == 0)
        return NULL;

    /*
     * Compute allocation sizes
     */
    cbBaseMsg = (cbBaseMsg + PADSIZE) & ~PADSIZE;
    cbBaseMsg += (cPointers * sizeof(PVOID));
    cbCapture = (cbCapture + (PADSIZE * cPointers)) & ~PADSIZE;

    /*
     * If the captured data is greater than a page, place it
     * in a section.  Otherwise, put the message and the
     * data in a single block of pool
     */
    if (cbCapture > CALLBACKSTACKLIMIT) {
        NTSTATUS Status;

        /*
         * Allocate the message buffer
         */
        pcb = UserAllocPoolWithQuota(cbBaseMsg, TAG_CALLBACK);
        if (pcb == NULL)
            return NULL;

        /*
         * Allocate the virtual memory
         */
        pcb->pvVirtualAddress = NULL;
        Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
                &pcb->pvVirtualAddress, 0, &cbCapture,
                MEM_COMMIT, PAGE_READWRITE);
        if (!NT_SUCCESS(Status)) {
            RIPMSG2(RIP_WARNING, "AllocCallbackMessage: ZwAllocateVirtualMemory failed. Status:%#lx. Size:%#lx",
                    Status, cbCapture);
            UserFreePool(pcb);
            return NULL;
        }
        pcb->pbFree = pcb->pvVirtualAddress;
        pcb->cbCallback = cbBaseMsg;
    } else {

        /*
         * If the message is too big to save on the stack, allocate
         * the buffer from pool.
         */
        if (cbBaseMsg + cbCapture > CBBUFSIZE) {
            pcb = UserAllocPoolWithQuota((ULONG)(cbBaseMsg + cbCapture), TAG_CALLBACK);
            if (pcb == NULL)
                return NULL;
        } else {
            pcb = (PCAPTUREBUF)pStackBuffer;
        }
        pcb->pbFree = (PBYTE)pcb + cbBaseMsg;
        pcb->pvVirtualAddress = NULL;

        /*
         * If this callback is passing data to the client, include the
         * captured data in the message.  Otherwise, only pass the message.
         */
        if (fInput)
            pcb->cbCallback = cbBaseMsg + (ULONG)cbCapture;
        else
            pcb->cbCallback = cbBaseMsg;
    }

    /*
     * Initialize the capture buffer
     */
    pcb->cbCapture = (ULONG)cbCapture;
    pcb->cCapturedPointers = 0;
    pcb->offPointers = cbBaseMsg - (cPointers * sizeof(PVOID));

    return (PVOID)pcb;
}


/***************************************************************************\
* CaptureCallbackData
*
* Captures data into a callback structure.
*
* 03-13-95 JimA             Created.
\***************************************************************************/

NTSTATUS CaptureCallbackData(
    PCAPTUREBUF pcb,
    PVOID pData,
    DWORD cbData,
    PVOID *ppDest)
{
    PBYTE pbBuffer;

    /*
     * If the data pointer is NULL, the out pointer will be
     * NULL
     */
    if (pData == NULL) {
        *ppDest = NULL;
        return STATUS_SUCCESS;
    }

    /*
     * Allocate space from the message buffer
     */
    if (cbData > pcb->cbCapture) {
        return STATUS_BUFFER_OVERFLOW;
    }

    pbBuffer = pcb->pbFree;
    pcb->pbFree = pbBuffer + ((cbData + PADSIZE) & ~PADSIZE);

    try {
        RtlCopyMemory(pbBuffer, pData, cbData);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    /*
     * Fix up offsets to data.  If the data is going into a section
     * use the real pointer and don't compute offsets.
     */
    if (pcb->pvVirtualAddress)
        *ppDest = pbBuffer;
    else {
        *ppDest = (PBYTE)(pbBuffer - (PBYTE)pcb);
        ((LPDWORD)((PBYTE)pcb + pcb->offPointers))[pcb->cCapturedPointers++] =
                (DWORD)((PBYTE)ppDest - (PBYTE)pcb);
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* AllocateCallbackData
*
* Allocates space from a callback structure.
*
* 05-08-95 JimA             Created.
\***************************************************************************/

NTSTATUS AllocateCallbackData(
    PCAPTUREBUF pcb,
    DWORD cbData,
    PVOID *ppDest)
{
    PBYTE pbBuffer;

    /*
     * Allocate space from the message buffer
     */
    if (cbData > pcb->cbCapture) {
        return STATUS_BUFFER_OVERFLOW;
    }

    pbBuffer = pcb->pbFree;
    pcb->pbFree = pbBuffer + ((cbData + PADSIZE) & ~PADSIZE);

    /*
     * Fix up offsets to data.  If the data is going into a section
     * use the real pointer and don't compute offsets.
     */
    if (pcb->pvVirtualAddress)
        *ppDest = pbBuffer;
    else {
        *ppDest = (PBYTE)(pbBuffer - (PBYTE)pcb);
        ((LPDWORD)((PBYTE)pcb + pcb->offPointers))[pcb->cCapturedPointers++] =
                (DWORD)((PBYTE)ppDest - (PBYTE)pcb);
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* CaptureAnsiCallbackData
*
* Converts Unicode to ANSI data and captures the result
* into a callback structure.
*
* 03-13-95 JimA             Created.
\***************************************************************************/

NTSTATUS CaptureAnsiCallbackData(
    PCAPTUREBUF pcb,
    PVOID pData,
    DWORD cbData,
    PVOID *ppDest)
{
    PBYTE pbBuffer;
    ULONG nCharsInAnsiString;

    /*
     * If the data pointer is NULL, the out pointer will be
     * NULL
     */
    if (pData == NULL) {
        *ppDest = NULL;
        return STATUS_SUCCESS;
    }

    /*
     * Allocate space from the message buffer
     */
#ifdef FE_SB // CaptureAnsiCallbackData()
    /*
     * Reserve enough space for DBCS.
     */
    if ((cbData * sizeof(WORD)) > pcb->cbCapture) {
#else
    if (cbData > pcb->cbCapture) {
#endif // FE_SB
        return STATUS_BUFFER_OVERFLOW;
    }

    pbBuffer = pcb->pbFree;

    /*
     * Convert the unicode string to ANSI
     */
    try {
#ifdef FE_SB // CaptureAnsiCallbackData()
        /*
         * Enough space for keep DBCS string.
         */
        if (!NT_SUCCESS(RtlUnicodeToMultiByteN(
                        (PCH)pbBuffer,
                        IS_DBCS_ENABLED() ? cbData * DBCS_CHARSIZE : cbData,
                        &nCharsInAnsiString,
                        (PWCH)pData,
                        cbData * sizeof(WCHAR)
                        ))) {
#else
        if (!NT_SUCCESS(RtlUnicodeToMultiByteN(
                        (PCH)pbBuffer,
                        cbData,
                        &nCharsInAnsiString,
                        (PWCH)pData,
                        cbData * sizeof(WCHAR)
                        ))) {
#endif // FE_SB
            return STATUS_UNSUCCESSFUL;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    /*
     * Translation succeeded.
     */
#ifdef FE_SB // CaptureAnsiCallbackData()
    /*
     * nCharsInAnsiString is actual bytes wriiten in message area.
     */
    pcb->pbFree = pbBuffer + ((nCharsInAnsiString + PADSIZE) & ~PADSIZE);
    pcb->cbCapture -= nCharsInAnsiString;
#else
    pcb->pbFree = pbBuffer + ((cbData + PADSIZE) & ~PADSIZE);
    pcb->cbCapture -= cbData;
#endif // FE_SB

    /*
     * Fix up offsets to data.  If the data is going into a section
     * use the real pointer and don't compute offsets.
     */
    if (pcb->pvVirtualAddress)
        *ppDest = pbBuffer;
    else {
        *ppDest = (PBYTE)(pbBuffer - (PBYTE)pcb);
        ((LPDWORD)((PBYTE)pcb + pcb->offPointers))[pcb->cCapturedPointers++] =
                (DWORD)((PBYTE)ppDest - (PBYTE)pcb);
    }

    return STATUS_SUCCESS;
}


/***************************************************************************\
* CaptureUnicodeCallbackData
*
* Converts ANSI to Unicode data and captures the result
* into a callback structure.
*
* 03-31-95 JimA             Created.
\***************************************************************************/

NTSTATUS CaptureUnicodeCallbackData(
    PCAPTUREBUF pcb,
    PVOID pData,
    DWORD cbData,
    PVOID *ppDest)
{
    PBYTE pbBuffer;
    ULONG nCharsInUnicodeString;

    /*
     * If the data pointer is NULL, the out pointer will be
     * NULL
     */
    if (pData == NULL) {
        *ppDest = NULL;
        return STATUS_SUCCESS;
    }

    /*
     * Allocate space from the message buffer
     */
    if (cbData > pcb->cbCapture) {
        return STATUS_BUFFER_OVERFLOW;
    }

    pbBuffer = pcb->pbFree;

    /*
     * Convert the ANSI string to unicode
     */
    try {
        if (!NT_SUCCESS(RtlMultiByteToUnicodeN(
                            (PWCH)pbBuffer,
                            cbData,
                            &nCharsInUnicodeString,
                            (PCH)pData,
                            cbData / sizeof(WCHAR)
                            ))) {
            return STATUS_UNSUCCESSFUL;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    /*
     * Translation succeeded.
     */
    pcb->pbFree = pbBuffer + ((cbData + PADSIZE) & ~PADSIZE);
    pcb->cbCapture -= cbData;

    /*
     * Fix up offsets to data.  If the data is going into a section
     * use the real pointer and don't compute offsets.
     */
    if (pcb->pvVirtualAddress)
        *ppDest = pbBuffer;
    else {
        *ppDest = (PBYTE)(pbBuffer - (PBYTE)pcb);
        ((LPDWORD)((PBYTE)pcb + pcb->offPointers))[pcb->cCapturedPointers++] =
                (DWORD)((PBYTE)ppDest - (PBYTE)pcb);
    }

    return STATUS_SUCCESS;
}


/***************************************************************************\
* CopyOutputString
*
* Copies a callback output string to the output buffer and performs
* any necessary ANSI/Unicode translation.
*
* Copies up to cchLimit characters, possibly including a null terminator.
*
* A null terminator is placed in pstr->Buffer only if the number of (non-null)
* characters obtained is less than cchLimit.
* pstr->Length may be set larger than necessary: ie: it may sometimes indicate
* a string longer than that which is null terminated. This is a deficiency in
* the current implementation.
*
* 05-08-95 JimA             Created.
\***************************************************************************/

VOID CopyOutputString(
    PCALLBACKSTATUS pcbs,
    PLARGE_STRING pstr,
    UINT cchLimit,
    BOOL fAnsi)
{
    UINT cch;

    ProbeForRead(pcbs->pOutput, pcbs->cbOutput,
            fAnsi ? sizeof(BYTE) : sizeof(WORD));
    if (!pstr->bAnsi) {
        if (fAnsi) {
            cch = MBToWCS((LPSTR)pcbs->pOutput, (UINT)pcbs->retval,
                    (LPWSTR *)&pstr->Buffer, cchLimit, FALSE);
            if (cch < cchLimit) {
                /*
                 * Add a null terminator and ensure an accurate pstr->Length
                 */
                ((LPWSTR)pstr->Buffer)[cch] = 0;
                cchLimit = cch;
            }
        } else {
            cchLimit = wcsncpycch(pstr->Buffer, (LPWSTR)pcbs->pOutput, cchLimit);
            // wcsncpy(pstr->Buffer, (LPWSTR)pcbs->pOutput, cchLimit);
        }
        pstr->Length = cchLimit * sizeof(WCHAR);
    } else {
        if (fAnsi) {
            cchLimit = strncpycch((LPSTR)pstr->Buffer,
            // strncpy((LPSTR)pstr->Buffer,
                    (LPSTR)pcbs->pOutput, cchLimit);
        } else {
            cch = WCSToMB((LPWSTR)pcbs->pOutput, (UINT)pcbs->retval,
                    (LPSTR *)&pstr->Buffer, cchLimit, FALSE);
            if (cch < cchLimit) {
                /*
                 * Add a null terminator and ensure an accurate pstr->Length
                 */
                ((LPSTR)pstr->Buffer)[cch] = 0;
                cchLimit = cch;
            }
        }
        pstr->Length = cchLimit;
    }
}

#ifdef FE_SB // CalcOutputStringSize()
/***************************************************************************\
* CalcOutputStringSize()
*
* Copies a callback output string to the output buffer and performs
* any necessary ANSI/Unicode translation.
*
* 03-14-96 HideyukN             Created.
\***************************************************************************/

DWORD CalcOutputStringSize(
    PCALLBACKSTATUS pcbs,
    DWORD cchText,
    BOOL fAnsiSender,
    BOOL fAnsiReceiver)
{
    ULONG cch;

    ProbeForRead(pcbs->pOutput, pcbs->cbOutput,
            fAnsiReceiver ? sizeof(BYTE) : sizeof(WORD));
    if (!fAnsiSender) {
        if (fAnsiReceiver) {
            RtlMultiByteToUnicodeSize(&cch,(LPSTR)pcbs->pOutput,cchText);
            cch /= sizeof(WCHAR);
        } else {
            cch = cchText;
        }
    } else {
        if (fAnsiReceiver) {
            cch = cchText;
        } else {
            RtlUnicodeToMultiByteSize(&cch,(LPWSTR)pcbs->pOutput,cchText * sizeof(WCHAR));
        }
    }

    return ((DWORD)cch);
}
#endif // FE_SB

/**************************************************************************\
*
* include the stub definition file
*
\**************************************************************************/

#include "ntcb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\swp.c ===
/****************************** Module Header ******************************\
* Module Name: swp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains the xxxSetWindowPos API and related functions.
*
* History:
* 20-Oct-1990 DarrinM   Created.
* 25-Jan-1991 IanJa     added window revalidation
* 11-Jul-1991 DarrinM   Replaced everything with re-ported Win 3.1 code.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define CTM_NOCHANGE        0
#define CTM_TOPMOST         1
#define CTM_NOTOPMOST       2

VOID FixBogusSWP(PWND pwnd, int * px, int * py, int cx, int cy, UINT flags);
VOID PreventInterMonitorBlts(PCVR pcvr);

/***************************************************************************\
* DBGCheckSMWP
*
* SMWP can be a HM object, a cached structure or just a pool allocation
*
* History:
* 05/21/98 GerardoB     Created.
\***************************************************************************/
#if DBG
VOID DBGCheckSMWP(
    PSMWP psmwp)
{
    if (psmwp->bHandle) {
        UserAssert(psmwp->head.h != NULL);
        UserAssert(psmwp == HtoPqCat(PtoHq(psmwp)));
        UserAssert(psmwp != &gSMWP);
    } else {
        UserAssert((psmwp->head.h == NULL) && (psmwp->head.cLockObj == 0));
        if (psmwp == &gSMWP) {
            UserAssert(TEST_PUDF(PUDF_GSMWPINUSE));
        }
    }

    UserAssert(psmwp->ccvr <= psmwp->ccvrAlloc);
    UserAssert(psmwp->acvr != NULL);

}
#else
#define DBGCheckSMWP(psmwp)
#endif // DBG

/***************************************************************************\
* DestroySMWP
*
* Destroys an SMWP object.
*
* History:
* 24-Feb-1997 adams     Created.
\***************************************************************************/
VOID DestroySMWP(
    PSMWP psmwp)
{
    BOOL fFree;

    CheckCritIn();

    DBGCheckSMWP(psmwp);
    /*
     * First mark the object for destruction. This tells the locking code
     * that we want to destroy this object when the lock count goes to 0.
     * If this returns FALSE, we can't destroy the object yet.
     */
    if (psmwp->bHandle) {
        if (!HMMarkObjectDestroy(psmwp)) {
            return;
        }
        fFree = TRUE;
    } else {
        /*
         * Is this the global cached structure?
         */
        fFree = (psmwp != &gSMWP);
    }

    if (psmwp->acvr) {

        /*
         * Free any hrgnInterMonitor stuff we accumulated.
         */
        PCVR pcvr;
        int ccvr;

        for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {
            if (pcvr->hrgnInterMonitor != NULL) {
                GreDeleteObject(pcvr->hrgnInterMonitor);
            }
        }

        if (fFree) {
            UserFreePool(psmwp->acvr);
        }
    }

    /*
     * Ok to destroy ... Free the handle (which will free the object
     * and the handle).
     */
    if (psmwp->bHandle) {
        HMFreeObject(psmwp);
    } else if (fFree) {
        UserFreePool(psmwp);
    } else {
        UserAssert(TEST_PUDF(PUDF_GSMWPINUSE));
        CLEAR_PUDF(PUDF_GSMWPINUSE);
        /*
         * If acvr grew too much, shrink it.
         * Don't use realloc since we don't care about the left over data
         * [msadek], should this be ">=8" since we usually grow it from 4->8 in 
         * _DeferWindowPos?
         */
        if (psmwp->ccvrAlloc > 8) {
            PCVR pcvr = UserAllocPool(4 * sizeof(CVR), TAG_SWP);
            if (pcvr != NULL) {
                UserFreePool(psmwp->acvr);
                psmwp->acvr = pcvr;
                psmwp->ccvrAlloc = 4;
            }
        }
    }
}


#define MW_FLAGS_REDRAW   (SWP_NOZORDER | SWP_NOACTIVATE)
#define MW_FLAGS_NOREDRAW (SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW)

/***************************************************************************\
* MoveWindow (API)
*
*
* History:
* 25-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL xxxMoveWindow(
    PWND pwnd,
    int  x,
    int  y,
    int  cx,
    int  cy,
    BOOL fRedraw)
{
    CheckLock(pwnd);

    if ((pwnd == PWNDDESKTOP(pwnd)) ||
        TestWF(pwnd, WFWIN31COMPAT) ||
        (pwnd->spwndParent != PWNDDESKTOP(pwnd))) {

        return xxxSetWindowPos(
                pwnd,
                NULL,
                x,
                y,
                cx,
                cy,
                (fRedraw ? MW_FLAGS_REDRAW : MW_FLAGS_NOREDRAW));
    } else {

        /*
         * BACKWARD COMPATIBILITY CODE FOR WIN 3.00 AND BELOW
         *
         * Everyone and their brother seems to depend on this behavior for
         * top-level windows. Specific examples are:
         *
         *  AfterDark help window animation
         *  Finale Speedy Note Editing
         *
         * If the window is a top-level window and fRedraw is FALSE,
         * we must call SetWindowPos with SWP_NOREDRAW CLEAR anyway so that
         * the frame and window background get drawn. We then validate the
         * entire client rectangle to avoid repainting that.
         */
        BOOL fResult = xxxSetWindowPos(pwnd,
                                       NULL,
                                       x,
                                       y,
                                       cx,
                                       cy,
                                       MW_FLAGS_REDRAW);

        if (!fRedraw) {
            xxxValidateRect(pwnd, NULL);
        }

        return fResult;
    }
}

/***************************************************************************\
* AllocateCvr
*
* History:
* 05/20/98  GerardoB    Extracted from old _BeginDeferWindowPos
\***************************************************************************/
BOOL AllocateCvr(
    PSMWP psmwp,
    int cwndHint)
{
    PCVR  acvr;

    UserAssert(cwndHin